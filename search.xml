<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LC-567 Permutation in String</title>
      <link href="/posts/LC-567-Permutation-in-String/"/>
      <url>/posts/LC-567-Permutation-in-String/</url>
      
        <content type="html"><![CDATA[<p>给两个字符串<code>s1</code>和<code>s2</code>，如果<code>s2</code>中包含<code>s1</code>的某个全排列，则返回<code>true</code>，否则返回<code>false</code>。</p><p>最直观的解法就是：</p><ol type="1"><li>枚举<code>s1</code>的所有全排列。递归算法的时间复杂度为<code>递归次数*单次递归的复杂度</code>，递归树上每个非叶结点都是一次递归，<ahref="https://leetcode.cn/problems/permutations/solutions/9914/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">树上共有<spanclass="math inline">\(O(n!)\)</span>级别数目的非叶结点</a>，因此递归调用次数为<spanclass="math inline">\(O(n!)\)</span>。单次递归的复杂度为<spanclass="math inline">\(O(n)\)</span>。因此这一步的时间复杂度为<spanclass="math inline">\(O(n\times n!)\)</span>。递归调用的深度为<spanclass="math inline">\(O(n)\)</span>，即空间复杂度<spanclass="math inline">\(O(n)\)</span>。</li><li>对于每个全排列，check其是否为<code>s2</code>的子串。如果用KMP算法，时间复杂度为<spanclass="math inline">\(O((n_1+n_2)\timesn_1!)\)</span>，空间复杂度为<spanclass="math inline">\(O(n_1)\)</span>。</li></ol><p>综上，总的时间复杂度为<span class="math inline">\(O((2n_1+n_2)\timesn_1!)\)</span>，总的空间复杂度为<spanclass="math inline">\(O(n_1)\)</span>。</p><h2 id="approach-1">Approach 1</h2><p>我拿到此题的第一感觉是哈希表，首先统计<code>s1</code>中每种字符的频率，如果<code>s2</code>中存在一个长度为<spanclass="math inline">\(n_1\)</span>的连续区间窗口，完全符合<code>s1</code>的字符频率表，则返回<code>true</code>。</p><p>如果当前窗口不符合要求，向右滑动，更新移除和加入窗口的字符频率，继续与<code>s1</code>的字符频率比对，直到<code>s2</code>结尾。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        len1, len2 = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">        m1 = collections.Counter(s1)</span><br><span class="line">        m2 = collections.Counter(s2[:len1])</span><br><span class="line">        <span class="keyword">if</span> m1 == m2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len1, len2):</span><br><span class="line">            m2[s2[i]] += <span class="number">1</span></span><br><span class="line">            m2[s2[i - len1]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> m1 == m2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>比对2个哈希表的时间复杂度取决于不同字符的数目，这里为26，因此总的时间复杂度为<spanclass="math inline">\(O(26\times (n_2-n_1))\)</span>，空间复杂度为<spanclass="math inline">\(O(1)\)</span>。</p><h2 id="approach-2">Approach 2</h2><p>方法一用到了2个哈希表，<code>m1</code>固定不变，<code>m2</code>随窗口的滑动而变化，并与<code>m1</code>对比每个字符的频率是否相等。因此可以转换思路，将对比每个字符的频率是否相等转换为：<code>s1</code>中每个字符的频率与<code>s2</code>窗口中每个字符频率的差值，只需要1个哈希表来记录<code>s1</code>与<code>s2</code>的字符频率差值即可。</p><p>先统计<code>s1</code>的字符频率表<code>m</code>，对于遍历到的<code>s2</code>的每个字符<code>s2[r]</code>：<code>m[s2[r]]--</code></p><ul><li>若<code>m[s2[r]]&lt;0</code>，表明当前字符在<code>s1</code>中未曾出现，或者当前在<code>s2</code>窗口中的出现次数已经超过了在<code>s1</code>中的出现次数，说明窗口<code>[l,r]</code>中包含的字符太多，超出了<code>s1</code>的要求，此时我们移动窗口的左边界<code>l++</code>并更新<code>m</code>。如果移动后<code>[l,r]</code>中包含的字符仍然过多，继续<code>l++</code>并更新<code>m</code>，直到<code>m[s2[r]]=0</code>。</li><li>若<code>m[s2[r]]=0</code>，表明该字符在当前窗口内的频率与<code>s1</code>相同，且<code>[l,r]</code>内的字符频率都与<code>s1</code>相同，即<code>m[s2[l...r]]=0</code>，如果此时窗口大小正好等于<spanclass="math inline">\(n_1\)</span>，返回<code>true</code>。</li><li>若<code>m[s2[r]]&gt;0</code>，表明<code>[l,r]</code>内的字符不足以cover<code>s1</code>，移动窗口的右边界<code>r++</code>。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        m = collections.Counter(s1)</span><br><span class="line">        <span class="keyword">while</span> r &lt; <span class="built_in">len</span>(s2):</span><br><span class="line">            m[s2[r]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> m[s2[r]] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">while</span> m[s2[r]] &lt; <span class="number">0</span>:</span><br><span class="line">                    m[s2[l]] += <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> m[s2[r]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> r - l + <span class="number">1</span> == <span class="built_in">len</span>(s1):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><ahref="https://www.cnblogs.com/grandyang/p/6815227.html">字符串中的全排列</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MISC</title>
      <link href="/posts/misc/"/>
      <url>/posts/misc/</url>
      
        <content type="html"><![CDATA[<h2 id="ad">AD</h2><ul><li>A kind of directory service on Win Server, other directory serviceOpenLDAP, Apache directory server</li><li>Basically a centralized DB storing objects</li><li>An obj could be a user, group, computer. each obj has someattributes, such as first name, email, credentials, permissions etc</li><li>Intra-site replica (automatically) and inter-site replica (IP/SMTP)between Domain Controllers (AD Servers).</li><li>support kerberos and LDAP protocol</li><li>forest -&gt; domain -&gt; child domain -&gt; OU (group, user,computer, ...) -&gt; CN (user/server name)</li><li>DC -&gt; OU -&gt; CN</li><li>DN: the LDAP API references an LDAP obj by its distinguishedname</li></ul><ol type="1"><li><a href="https://www.youtube.com/watch?v=85-bp7XxWDQ">LearnMicrosoft Active Directory (ADDS) in 30mins</a></li><li><ahref="https://stackoverflow.com/questions/18756688/what-are-cn-ou-dc-in-an-ldap-search">Whatare CN, OU, DC in an LDAP search</a></li></ol><h2 id="ldapldaps">LDAP/LDAPS</h2><ul><li>C/S model, LDAP server (most case AD server) store dir entry in atree structure</li><li>cross platform interface/protocol for querying/communicating withdir service, such as AD</li></ul><p><ahref="https://www.varonis.com/blog/the-difference-between-active-directory-and-ldap">TheDifference Between Active Directory and LDAP</a></p><p><ahref="https://www.reddit.com/r/sysadmin/comments/nd0w3g/what_is_the_difference_between_kerberos_and_ldap/">Whatis the difference between Kerberos and LDAP</a></p><h2 id="network-basics">network basics</h2><h3 id="ip-addr">IP addr</h3><ul><li>private ip<ol type="1"><li>10.0.0.0-10.255.255.255</li><li>172.16.0.0-172.31.255.255</li><li>192.168.0.0-192.168.255.255</li></ol></li><li>localhost: device establish network to itself, 127.0.0.1 (IPv4), ::1(IPv6)</li><li>CIDR: notation, variable-length subnet mask, 192.168.1.0/24</li><li>default gateway: a device (router) between local network and othernetwork (such as Internet)<ol type="1"><li>route packet to appropriate external network, when there is norouting info available about dest</li><li>obtain device MAC addr in another network using ARP</li></ol></li><li>VLAN: logical group of devices, seperate different traffic(different departments) and narrow broadcast domain, switch use VLAN ID(1-4094) identify each VLAN<ol type="1"><li>port-based VLAN: port1-3 vlan1, port2-8 vlan2</li><li>protocol based; IP/IPX</li><li>MAC-based</li></ol></li><li>DMZ</li></ul><h3 id="vrf---virtual-routing-and-forwarding">VRF - virtual routing andforwarding</h3><ul><li>allows more than 1 routing table on single router, similar to VLANson switches</li><li></li></ul><p><a href="https://howdoesinternetwork.com/2016/vrf">VRF – VirtualRouting and Forwarding</a></p><h2 id="protocols">protocols</h2><h3 id="sshrdp">SSH/RDP</h3><ul><li>SSH: remote access, file transfer, remote cmd execution, SSH tunnel<ol type="1"><li>Authentication: pw, public key, host-based</li><li>port forwarding: tunnel to other protocols (HTTP, FTP)</li><li>secure file transfer: SCP (secure copy protocol), SFTP (ssh filetransfer protocol)</li><li>encryption</li></ol></li><li>RDP: tcp 3389<ol type="1"><li>multi-platform support</li><li>encryption, authentication</li><li>dynamic resolution adjustment, clipboard sharing</li></ol></li></ul><h3 id="httphttps">HTTP/HTTPS</h3><ul><li>HTTP: stateless (not retain session state from prev req, indepedentreqs between each other)</li></ul><h3 id="section"></h3><h2 id="spn">SPN</h2><ul><li><ahref="https://www.ibm.com/docs/en/filenet-p8-platform/5.5.x?topic=engine-creating-kerberos-service-principal-name-spn-identity">Creatingthe Kerberos Service Principal Name (SPN) identity</a></li><li><ahref="https://www.ibm.com/docs/en/filenet-p8-platform/5.5.12?topic=engine-creating-kerberos-service-principal-name-spn-identity">Creatingthe Kerberos Service Principal Name (SPN) identity</a></li></ul><p><ahref="https://serverfault.com/questions/350782/can-someone-please-explain-windows-service-principle-names-spns-without-oversi">Cansomeone please explain Windows Service Principle Names (SPNs) withoutoversimplifying</a></p><p><ahref="https://stackoverflow.com/questions/48096342/what-is-azure-service-principal">Whatis Azure Service Principal</a></p><h2 id="infoblox">Infoblox</h2><ul><li>DDI mgt: DNS, DHCP, IP</li></ul><h2 id="layer-4-vs-layer-7-fw">layer 4 vs layer 7 FW</h2><ul><li>layer 7: application layer inspect, such as URLs</li></ul><h2 id="load-balancer">load balancer</h2><ul><li>traffic routing, SSL offloading, session stickiness or HTTPprofiles</li></ul><h2 id="bandwidth-mgt">bandwidth mgt</h2><ul><li>full BW, business down, how to solve???</li></ul><h2 id="icapsecure-icap">ICAP/Secure ICAP</h2><ul><li>protocol for communicating between proxy/gateway and contentadaptation server (ICAP server)</li><li>ICAP server can modify/analyse request and response content, forvirus scan, ad filtering etc</li></ul><p><ahref="https://www.kareemccie.com/2023/05/what-is-icap-protocol.html">Whatis ICAP Protocol</a></p><h2 id="dhcp">DHCP</h2><ul><li>assign IP automatically based on MAC when connect to network</li><li>process<ol type="1"><li>discover: broadcast to locate a DHCP server</li><li>offer: unicast containing IP etc</li><li>req: confirm IP and other info</li><li>ack: server confirm the assignment</li></ol></li></ul><h2 id="dns">DNS</h2><ul><li>MS maintains its nameserver storing all final DNS records (A, MX,CNAME)</li></ul><p><ahref="https://www.cloudflare.com/learning/dns/dns-records/dns-ns-record/">DNSNS record</a></p><p><a href="https://support.google.com/a/answer/48090">DNSbasics</a></p><h2 id="nat">NAT</h2><ul><li>middleman between LAN and Internet, translate private IP to a singleshared public IP</li><li>implement on router, FW<ol type="1"><li>static nat: 1-1 mappings</li><li>dynamic nat: 1-1 mappings, but public IP chosen from a pool</li><li>port address translation (PAT): multiple private IP maps to a singlepublic IP, but change to diff ports</li></ol></li><li>how to operate<ol type="1"><li>outbound: change source IP (private) to NATed IP (public onrouter)</li><li>inbound: change destination IP (public on router) to NATed IP(private)</li></ol></li></ul><p><ahref="https://en.wikipedia.org/wiki/Network_address_translation">Networkaddress translation</a></p><h2 id="arp">ARP</h2><ul><li>IP -&gt; MAC, route data within same LAN</li><li>broadcast ARP req, all devices compare target IP with own IP, sendARP reply (contain MAC) if match</li><li>update ARP cache (IP-to-MAC mappings)</li><li>security concerns: ARP poisoning, etc</li></ul><h2 id="bgp">BGP</h2><ul><li>eBGP: route between autonomous systems</li><li>iBGP: used within AS</li><li>BGP table:</li></ul><p><a href="https://kadiska.com/how-does-bgp-routing-work/">How does BGProuting work</a></p><h2 id="snmp">SNMP</h2><ul><li>manager machine (run software as NMS/network management system),managed machine, SNMP agent (software installed on managed machine)</li><li>manager send reqs for info, managed machine response</li><li>SNMP Trap: an agent can send unrequested msg to manager to notify animportant event</li></ul><h2 id="rto-rpo">RTO / RPO</h2><ul><li>RTO is the goal your organization sets for the max length of time itshould take to restore normal operations following an outage or dataloss</li><li>RPO is your goal for the max amount of data the organization cantolerate losing. This parameter is measured in time: from the moment afailure occurs to your last valid data backup. For example, if youexperience a failure now and your last full data backup was 24 hoursago, the RPO is 24 hours.</li></ul><p>location, domain, vDOM, zone, vlan, subnet</p><h1 id="troubleshooting-tools">Troubleshooting tools</h1><h2 id="nslookup">nslookup</h2><ul><li>mainly for DNS, supports various DNS record types</li></ul><h2 id="dig---domain-info-groper">dig - domain info groper</h2><ul><li>DNS query</li></ul><h2 id="port-scanner">port scanner</h2><ul><li>Nmap: host discovery, port scanning through ICMP echo req, TCPSYN/ACK probes, ARP scans</li><li>Masscan,</li></ul><h2 id="ping">ping</h2><ul><li>ICMP Echo Req and Echo Reply</li><li><code>ping example.com</code></li><li>use<ol type="1"><li>verify remote device is active and responding</li><li>identify latency</li><li>test resolution of domain name -&gt; IP</li></ol></li><li>some servers may configured not respond to ICMP reqs -&gt; norespond/time out</li></ul><h2 id="ipconfig">ipconfig</h2><ul><li>Win only, display network config settings</li></ul><h2 id="iptables">iptables</h2><ul><li>packet filtering, add/delete FW rules in Linux: INPUT, OUTPUT,FORWARD</li><li>will lost when system reboot, can save and persistent</li></ul><h2 id="arp-1">ARP</h2><ul><li>view device's ARP cache</li><li>ARP spoofing (Poisoning): link attacker's MAC to legitimate IP, thusintercept and DoS attacks</li><li>monitor ARP traffic, use static ARP table, employ NIPS/NIDS</li></ul><h2 id="netstat">netstat</h2><ul><li>network connections, routing tables, interface stat</li></ul><p><a href="https://en.wikipedia.org/wiki/Netstat">netstat</a></p><h2 id="tcpdump">tcpdump</h2><ul><li>capture packets, and filter based on IP/protocol/port</li><li>other packet sniffer: Wireshark, Npcap</li></ul><h2 id="route">route</h2><ul><li>view and manipulate IP routing table, need admin privileges</li></ul><h2 id="tracerttraceroute">tracert/traceroute</h2><ul><li>identify each hop and RTT</li><li>cross OS,</li><li>some routers may discard ICMP echo reqs</li></ul><h2 id="mtr">mtr</h2><ul><li>combine traceroute and ping</li></ul><h1 id="network-based-attacks">Network-based attacks</h1><h2 id="dosddos">DoS/DDoS</h2><ul><li>flooding by sending massive reqs, overwhelming server capacity</li><li>Ping of Death: send large, malformed ICMP packets</li><li>Distributed DoS: UDP or HTTP flood</li></ul><h2 id="dns-1">DNS</h2><ul><li>DNS cache poisoning</li><li>DDoS</li><li>DNS hijacking</li></ul><h2 id="ipsec-vpn">IPSec VPN</h2><ul><li>collection of protocols and encryption algorithms, operates at thenetwork layer</li><li>Authentication, Confidentiality, Data Integrity, Anti-ReplayProtection</li><li>Components<ol type="1"><li>AH (Authentication Header): add an authentication header to each IPpacket</li><li>ESP (Encapsulating Security Payload): ESP provides confidentialityby encrypting the data in IP packets</li></ol></li><li>modes<ol type="1"><li>Transport Mode: IPSec is applied only to the payload of an IPpacket</li><li>Tunnel Mode: IPSec is applied to the entire IP packet, including theheader</li></ol></li><li>process<ol type="1"><li>establish a security association (SA), contains the necessaryinformation, such as encryption keys and chosen encryption algorithms,for secured communication. The Internet Key Exchange (IKE) protocol iswidely used to create and manage SAs</li><li>exchange data with key</li></ol></li></ul><h2 id="linux-systemd-service">Linux systemd service</h2><ul><li>system service: <code>/etc/systemd/system/xxx.service</code> -&gt;<code>/usr/lib/systemd/system/xxx.service</code><ol type="1"><li>root user</li><li><code>sudo systemctl enable xxx.service</code></li><li>config files auto generates in <code>/etc/xxx/</code></li><li></li></ol></li><li>user service to all users:<code>/etc/systemd/user/xxx.service</code> -&gt;<code>/usr/lib/systemd/user/xxx.service</code><ol type="1"><li>service avaiable to all users at once</li><li></li></ol></li><li>user service to specific user:<code>~/.config/systemd/user/xxx.service</code><ol type="1"><li><code>systemctl --user enable xxx.service</code></li><li>need have its own config files if it's a self-defined service</li><li></li></ol></li></ul><p>if <code>sudo yum install httpd</code>, then for a specific servicexxx, its config file is in <code>/etc/xxx/</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/etc/xxx/conf  <span class="comment"># main file is /etc/xxx/conf/xxx.conf</span></span><br><span class="line">/etc/xxx/conf.d</span><br><span class="line">/etc/xxx/conf.modules.d</span><br><span class="line">/etc/xxx/logs</span><br><span class="line">/etc/xxx/modules</span><br><span class="line">/etc/xxx/run</span><br><span class="line">/etc/xxx/state</span><br></pre></td></tr></table></figure><p><ahref="https://stackoverflow.com/questions/45288872/placing-httpd-config-outside-etc-httpd-conf">Placinghttpd config outside /etc/httpd/conf</a></p><p><a href="https://linuxhandbook.com/create-systemd-services/">How tocreate a systemd service in Linux</a></p><p><ahref="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">Systemd入门教程：实战篇</a></p><p><a href="https://nts.strzibny.name/systemd-user-services/">systemduser services and systemctl --user</a></p><p><ahref="https://www.cnblogs.com/snake553/p/8856729.html">centos7上搭建http服务器以及设置目录访问</a></p><h2 id="sql-injection">sql injection</h2><h2 id="systemidservice-account-vs-user-account">systemid/serviceaccount vs user account</h2><ul><li>non-human privileged account, can query AD etc</li><li>identify different programs to give them differentauthrizations</li></ul><p><ahref="https://www.zluri.com/blog/service-accounts-vs-user-accounts/">ServiceAccounts Vs. User Accounts: What Is The Difference</a></p><p><ahref="https://unix.stackexchange.com/questions/314725/what-is-the-difference-between-user-and-service-account">Whatis the difference between user and service account</a></p><h2 id="storage">storage</h2><ul><li>AWS S3, object (blob) storage</li><li>block storage</li><li>Dropbox</li></ul><p>network bandwidth QoS???</p><h2 id="section-1"></h2><ul><li>query DNS -&gt; tcp -&gt; https (verify cert)</li><li>local DNS record: C:, <code>IP tab hostname</code></li><li>NET::ERR_CERT_AUTHORITY_INVALID,</li></ul><p><ahref="https://serverfault.com/questions/973446/self-signed-ssl-i-created-for-localhost-cannot-be-trusted-even-though-i-have-alr">Selfsigned ssl I created for localhost cannot be trusted even though I havealready imported it to chrome</a></p><p>root CA is self-signed</p><h2 id="splunk">Splunk</h2><h2 id="spring-boot-swagger">Spring Boot Swagger</h2><p><ahref="https://blog.bytebytego.com/p/why-do-we-need-a-message-queue">WhyDo We Need a Message Queue</a></p><p><ahref="https://unix.stackexchange.com/questions/309986/how-to-use-sudo-with-the-i-option">Howto use sudo with the -i option</a></p><p><ahref="https://4it.com.au/kb/article/how-to-add-a-dns-entry-manually-to-a-windows-computer/">HowTo Add A DNS Entry Manually To A Windows Computer</a></p><p><ahref="https://opensource.com/life/16/10/introduction-linux-filesystems">Anintroduction to Linux filesystems</a></p><p>https://www.geeksforgeeks.org/linux-file-hierarchy-structure/</p><p>https://medium.com/<span class="citation"data-cites="jasurbek.go.dev/the-linux-filesystem-95673f4e3bd5">@jasurbek.go.dev/the-linux-filesystem-95673f4e3bd5</span></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Finance Glossary</title>
      <link href="/posts/Finance-Glossary/"/>
      <url>/posts/Finance-Glossary/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5bd4f2f9ad59b9a1b57fa842abc9ab96dcb2b2c05c50d2b512d7678f51bb8746">418fac4f173397084caccc18ab9f089e90c7a29408af94da76702e54e165326b6ed0ee44955febacd8566271326fe868e0ef34305717a124a8141013016ead1b16a43e04dd078c82ca81a404f9e4bb414373c63f4740b7192a9b7224d1ba219e6229559b33de444cc897d31e525521b3138925fcd80bdc710560de41469218b2f99bb6353feb3f1198036235bf392f8c9a3ab7dd324605be6205c86cf75cdd004e88e7f45c194b524d87c06e00bb550580eff1ce6de24c980911c612d0686592db99e4f760760a543f3324f093dba1a3ba1125f5f026af818f11f5d8647dcb8040e64cbb36c4f96a5e1391a2998ba56008b512732c466303a306881feca58c656887b3de63a1903638c8acf24f1b31e5b4bdbaaf9efabe17835926d9846607c5c167a88c88533a8bb63df20c91ae9f6dde031fabba4d65d0d8225e1ecb539c907288e2422dc37022a3a8f79e7f4c2654a35f5e44c87f4707affa534493c131baeed84e3a08748112a8fef32a57fc9184abbf1330926773fba0f839e81250d2550ef2c5bc20354629675280b52a10ade3ee2ddc25927031e3a1c1aaa91e29fb7b6f76b0c249dd0d1ca4f1490f8b44d20f7588d993ff718c2589fb1da42f60dd8c8c0f32a900c7fa5de9f8d9c99ccd282da7de80724e2c091f47a163e8d0487993a959adaedacca7bafe7c0d986032dc30e0ec82aa878ab4470e91854d1a730c8df05a721e04e0050f3c393f1725c87994874b8db11a0e6f7ef5b48d9f68e2fbb7ef8b9f4ebb3a931c0951dea32a1378b460f273282dfdc3b16c47ab5640ff41ec7f484d369d9cc0b82c1ca73db1f33fc19a1f19e879f713565a5e47921e88ca1f72c157c18eadbde4988fd22af6d8a4d21d76cdf0ba10bfb875bc589bd6e06114d47e609e257e35cad4fbd77e5212c5900839b142a4858234f5efc012c8989588b69248638262199af28a2fdfa13b05daa1d933df2969557036a0093fa8045c62008af9785a613d67f5f8adcd01c53294e7f9878440a100ee51eb11bf12e29176024df53af3b65307521369c444c124dfbd8c7f3b556f234d789bcae748687bd9b37b1ec974198dd8d1b8169727bae188f3e0329ce578e2a1dfd00fe55e0f3b17882847d1180e95e95bf2564b83aacc2d86b99809285fdfe7f580948508fc2fab76f541916626c9ee11977807c929b93fc9361174b523207d7705f6ec342c469306c48d3b8f56694b2438c0beec191e42011fb152447034600c30934ad824e87b9a441f4c3a3fb8a3b802c52b9c5c20796ba89974d1e31ca9abfe41ac5e167a2d30300cf6fc125a75103cf8716ee98d021249fa290b38e069540d7977259fdc12a41a1fcd1c6d0981ccc4f1b26f919248cb03459003e086091795f9d879cf8d81b7807255b179d289e88e3182e9ddec0c7fa52718df36dae7f1a853c8a94d5c5bc6b0b29d83c69c90a2a4c4262b470befb52a36cc4a2e26d71ca63f9a3653331cb37001f26f66b90410db19b5fee931276e414dd1060c6b046e6c2cec5b2bbefa4a096233b2be03503cba48cbad8bd413868199089f7a877f24dc2be540a2629d0a31ec6a9e5188666e3343b8577042eefa5a151b04258f9e4fb64d8147e4d0b6940c4e1fd245074c57a74b52b4c5c6e3af77472d123b7d2978e552b1c7f3f5864ad44caac23f0fb0b8aa305c9a46f52b6c93a40826e581c1709811c148e7c068f6db971ccd69abe2fdd520009fd3e25f707f7c1716aa69c58fc202e6cc3cfa5abc220baba697718a3003e0e201fe5d384fa5d85dc1b761dbd969891a02f971977c87aae0e126331a8d80323ee2379da2861681abd4014ae08d4702328d64ee3d01ba68074b19bd94ef241e5ec6fdbfb95b58b7257fcc36d5c6dd39247f1957cb6f97e7fba2ce9a809e4ca68d1c2a57370d811852b9fb4c7f6fd740c622ce85f881084236f97d36cf8703f6a57f54170712e8c718744e1310a446cb75eae9a82455d68fbd4a15b1394353533416a99279117900e3f4537dc47b553ff08128e7fe0dba9db3b18cd1bde42d28a7ce023b4678c55d9ef69e6f59184c097231eecfcb33155991e24b68e4681cfd5b6133b90fd732d009bb58d69871dcb1c182be8c6038b74139d5929df75b15bf07b551c62dc4b11242302f7244f0624aa3b3d8c44ca16a0b5db097759093e4a19ea15a56569eae3f28a61e72b8e02a1efb8eba732fd56eb99fbc19fe43702f589791cc24c2c5ca683a628e2898ecfa6ec190cf5e24aec8f80af63b535194eab6a1d6f1ee1637c0466fbe774be00da5350c77c5d1f7d91d8f72548e1560c60de3e032a0449f95b3b0b3d4b097b9119586362f0b4145cb8394aa515d226b9cc8fa5057299923531a18c3da58e1f83e85759d6571e22d4f60be8b76f46576838d423e8f91749bbb356a08862132acfb1ebd630d607f806b1ba2cea207cf40ca5b258c31f1f3555441f8a2d33e29fa6d505b046e2d0a1b1bf5d7fb6e44fc8e8cdd1558c9c141faaf7d94125e845fed45659922c25d5e7bbc26e9a237fbec01b1268b148a42535b63faeaf4f166ee49fe42d3b58d0dd1dcde3bf13d00e3ba5b948f80a3498ffaaefd0ddaf876604b3bc133bd67cb803a4dfbfcb9f4d683cdd2d835f878e1af8747c411de91e2457cf7b4a7194387be98511b431a2aee28a4595a04056d2e329734074e784bd6ce193892c72122e149c04acc1e36602188cf149461f385cd661d2c57a505db1d8d706e88ce582a6bee1e2e2a8c7a147d2aa527173d5dcc611844b9b5ba277ac43bea56ec49b30bb5581c1e8e1a2acee7e98d8aa6946dd804c85f1899de4e7d061faff730ebc6606f92f65693ab95728f971ae23a77f8a475a44e937bbd0dc30f57df4d71541b4582f7a43e56486c2d003b7c6c21deb1a0492775c8165b98223db479b157add427c86eb264d7b8059f8a3206a0dcb5ab9b40abf407d2bff658ecb53044e96a99b4c6546f6cad9bfd696a8011d4feaac21ec7c8a19dddf494f6ffcccb32965a1547969f97e9dda69bd3b272fc8daf6dca238c2baf0c1b1983734116e3bc57bcf0866e830ae312f078603ec9571b234d8a85c2e3798decb126b5fb227f26792a88ee5dee6b00d8298b9fb4c0ba549804c25079ee3d5c818147edc415d978cb9a32e6220a2a958e76535a438930f6869e01bae111426cf0ce836ef2ea5ac112294c3bdf8ab035fa17e536df7cf587b037f0c4e4716ae416c6ec4c97ae8a0117d1206e958229b1e17ba62b91f17db35b06e4e94a706718f2a5bc0d338b9fb89ee199b67e2d55d8a121ef779ae42930b6e49afecd760c3fb9930b43a0e309988cb05e790605c48d92687fb33fa649d95f6e039e07a51237cac3241c665c50bcd7f0b45a5a8c14203d415474b61a125cc562ac859b453443071ddfee67badef6148dbf580f855f1ef37e4e65ccab17e018a8118bba60a1b5313468954aa05dff3b6fff1b1a47bb27407cc1263ce679cab56bb571487b247f9b398edfa7e92e8ffe7c34e2633857908eea8c2dcd84f7ef301999d943a986c692d94726c04a825c49d5290b681f97a084a90f5d653ebcf9045d4e2a5930fa7001118339dd9811c32a3d368961a1610f7bce7b43a12a4757759f75e578d92d6d7ad8ca8357e350311057b33e3315af436505dc24362705f61b924c69fe3beedbb28a3c776413ac8880923b1efd1e326d5abd7edd66fc79a8c6241b05a2476805f2ed2e7a584cf89fee3b0fce77e38767d53341cfaffbafc78f5a7b6426ffaa869010cbc84801ac17f0144048d7c257f24c46ca51a465415fb762613c9edf08570224f042770defb146619f3a1430bc25f145ca798f95a53474ad35aa3e689c8a56f0918a8f328916e7271f34bc9ff361f6dc71333339bf51d67a10e4808807862607e4a9149efc4cdd785676c8bc4d464c84e877b17fb4be50bd9e0e8c7c7739df7243678a905319f86582639d7baf624d5b73812fb58b6654860ebe428a97a9861615fc18cab031c8b00e27924edda716b0005ffe8df5d89a757340b50d4461408148dd3875f247fcd2d7df93aa3c5a090f7a9277330ac63f5c9c278c5e03e32b26c88f4bedc30613d81125d953556bc9f97b63c04b512c3af23711bf85ce9a06deb75089d5d683c2dcbdea0f6cf87f487dd66f8e075ff890c0ce7d8130a101dacc7ab85c67e2a559803ebd7cde4fa25c144a78bb6fd63df0d460187aaef94f1979b69b4729d342ffe8e32c989766cf2c6c0d7f813911ebba668a66848663e3ee9fd0585b9ddd909043e9e69e77a853b238f70139038b0bc9909a4f759836856c4e771d9c92c67894398ca0442dee15558458ad5343cb7f869b5d288dc19992a0eead0b9ed0c5048e4b26a84b40f944429e20077be204b6f9dfe83a5da8dcfa01d3e8e9e8fead1b521723b5be0a1a01dbd5adac9d1ad1a7d91b964b4bbfffead4ab802575ebd2fe846468d5fba9740ce6164e543769aab6d1d60d6a2ce715b3e1670799fb922473caeb3f5747588dd34ce346f4f4f72e68e15de656032cbd38655d56cffbf0a694f1ebcba5ccf26f478b420bf31355093950f467cf2dec2bbe4a38381ffa4121f163c726ca09000b7532b629362777bd6e4e434df84136fd677adc94487b4f5b127f8ca4d1cb84baf78fa36e435f9fee11e861b3c5ca15cd86c80cc58816d6563aa595b8c879039ba25b4e7aef68f0a8b6fe1c688d104b0967330ef55539fc182852979fc2000f6a0bc680fc4c262ec33d62bddeff7ba93506de7975a7675fb860065476a5a376c6f5b42bcf961dd482bb3bff958b5ec1898fbbcea58824b3f413ac6a86c273756a7c72d1dadba2db0df28f2fd76fc45b706db661579e367b9ea75438c78dcf7aca811c3525998dfb92c2cf274984e17aef6a1e85d50ab732569650297890d8908228b02288273e7844984727c742dfc6d01557a3a267f431c6e18d79120f2adab84d90a30311bfac2c5962dda46a829d3f56a3fd890dc37d235ee3aaa2f4b87da3cf1b0e57ac01f6e77fedd390cd31f3c055404c97be54cad8527923834b17e422bfd496235bcf28690005f981bb44cbdd8d38a84183b32f73085379aa3d761be607550c937492d1e6025eff0f30944b99715ee8189c9004cd299ed97c3df5c5047205102f0184bceb2acf2da5fb4f40314bc1c308c37846cb32e7fd1e64fbd08839137b10fc94835d20a2efcb750a79aadd3aff2305f41ffe2276d0fd937f4b6d285db948b7120af494ea5e726eac583e4aefb1429424ffc3e99e0497dc16897a0c041df9b54db9032316290b21502774c8fd7b50db0bf38bcfa0a27be4eee4c1427ff1c614058b02304c80492aa3c4ba521403e6c31ea728426fd8048181ba013059870078e12361145667b9dffdfa110e1a1e0646864a178d58050103eb9e7a32772bd94101045ff8360bae15d92dc71d7a9f3b8f0b9aa72b9d939f28ec6ebaaafeead0a1e7f60c03b6e77268826170f20644bdce62e6ae3a91d7c44dd7d17e7734fff21319d4d2ba506f0eb42f81ee740a567f02937bf556d1a4f62e7f5d49b4d2734dcbcb3096de2b326e1f7ec0f99476a9897261e3aa85b464bd51bbb5788ffe356c74e5f92d8f415bb98db473aad31b34a81ca1f2063e9b84af4ba39d637e2f83896d5bae73e23bd56fce4e6c31aa4761d791ea2820ac1b5c493510ac97d56952c4966b3d69d31cd31b9000318b3e9b78e4d23f606a7b5d7751ddd70fe0b6f81e0965d52d3193834c48c449309f4b1dec4da8adcc51763c92e225f996b7a83fac420199d0e119c4bb0bd2d10d8c2a738882a93059762454520bff91120828ca8519f962b0ad0d26b642858d32c27926be983849a9b6f476620d39c04937a92662a9a438042eb9fd770846aec664f0dcf6b094496ec8cb9593e7b5be75c61238ae9d9618e3e3b3735b17e148f5ceb347aa3fbb90e77a57f7ca8651392b7d3a1f9c87a1bd3ec917318d9044c17c1512e488d8832cc816f839a29cdacc83c21f47c4c47a87157e305df50677a6cad1fabaa075e01ae295a9f50233af7ff87099db4ed8e80d4479376ec3d5ee69193c2ed8a8c1b4dfab1cabecb6ebd8b0a4b64248d8b5bd0308820239398f755457bd3668daba3d82210ba5c0685d6dcd5d1e0cbf24987e3fd0399f394f9dd1a96ef20abaa4cd36a1d88f21d01d0eacf4c38ca8356eb4f0c47fd591accac69b164bb7996c0bcad076bf54b470024de12cc275ebd65cee2b208f9c36b6fd690b2e0f227783cc231e000ecd9c22edf434a41548a72d2df0f3e3dd2d8756c785850e53e0f81c2e4fc89b995490f4cf7542d3b39b7db10dcf184153d68435f0ff48219444941e404b2a6a843cd9c4a33383aaaab2a85b67440c412e2c3793705580382e28f0e2a58dea6a1c591103b05e9d543b78ccffbaa00ecbbcf2e8a7b9596295032b175ff29ad5ae74af40da5405d093ae619375a4cacce3b282e29589f0d20fd60f503fc72b6406530c13a8077524e12e287bd9729d779fd54d11770445928837a0003e62fcbac28ff0bad1cc0e3c2721d2f90a6a3e9fa94be241e73a865faf6395af5e870ca15f0211ace2b4435d9fd5aa77b126f9b99e4ef15e9aa75c4a87b84c9ab312d5c41bc44bc37700e353fc92763d2631b995061743b636f584ee18a99c6a43ce3e5ee7fadfa82350b9c7686b8822b40405f79b76e59594c18e9dcaa3832702f17f69f24e0a66cb6f716ea98a46e945d62b96c5e34c2a859f0dac1cb7cfa870239d5e6f90811dce31b58b562ad5b04b777681af0ddaf5715f34577e6b459372340a3cdba79f37a9d580ff0e76768dc5aef53176085372fb5b7158cefd2e957db0905acf2c520ebc1b98e24238144cb90853cff9c4dae992ef42a02ac4521bb09165bee1b5b6bffb9afafec017f3caf3b4a467ed19de417a90fc90fa9681607ec9db6fd87357e472e7067c480c4b53425a8ae22ef4cd0c5241cf2e8c8b684f4d7ec2ffddb61d9a008d43b9267f740b1dc8320052414542c9aa795fe536b06fd04a4f6b31f1801f5f4cf5c241329b0ca6789aff48923fbd6fa65783e34e83fac6a6ecb07d3b0934a2ae487b196b5e03e5c7ba5a6704540eedce99818231612368dcc60472bb9209990a3d28478365414ed5d6b0e5ea5803f0b6b48c16ad8497728822b67345f8be0e625a5f37f1f704e26c31158d58aa31371bc3620ee581d834a2ea3b7babdc219b6ea89b73604b63be3e174f182d435e093d6360ef41580d65e3a306168063d52be414b0d34d70472103ea1e2e48b3d57e6cbf26f94f9061737e66a64a4fb887509bd993453c60997570605fc4fd35c3de6dd81ae2e502281c1654bd88ebf41c12ba1f54f9d7252ec0cc37f5cf2c9dbe9fe452fd20d8e6d72e5709a5035d8b2deb7a379ccd485cc1369b082f07abc48b823475fe190c920efbe08e7640847a279df3c8114198b46bf85c11a9908b52bc4c96f0aed6c38e552824c0fd70a642b9999288f4d0796ddd896ea013811afb643e85572b28a45bbe8171a9d75f76315c86ae13580554d5c7e0c79a5134ef2a71f73dcd0bd1b6f9eb9f85c5a805077737d856c46f3b70c0fc9086ea115f3dfc2d1cdf76b7430e6b4561524497266b5ee6c4407fc2d352cba9709abbdaeafaaf27c93dc94f68b9bdaf6452f0b1bec8b71c2a622af9b249c15678c8e80fc8e2cbac4c415622c35dc56986ef9f121c51e6d62c71d2701ee3cdee4be86e1687f94a3e2c768403b488f9296aa4b6ffbe6437f90dff91da4e59d6c77cb30d66c63b02bc6b0f579d9d5d81e2650a21ef60227a53c993b37187bfffa827a411552a63b09403ee8c8c0e7926985c5b264ff17c2b718bd4e2bae9bef7ab570399ab8f2d450083ea313630590e5ad2eebf98db51fab2fbdd159ebc9cdc36f6462fd5435251aeb76bff80434debc3060838deffdd8069d94183607e1bb29ad7553917a501c0d0f30ee0f94024fd3c48f0da868bb59286afaf1296c1f9739292e0b7f4afbbfb12952c4a15cc494513f5437a57486036af59ce69c66ed51141b688982e98212e9d54c3e61382e3346ad0e9173ed94c115f8c45b1cbb7f6caad4efb390742d587c2c638209373b4e800c13adeae5afca1760644e1b99ef2b14220d506dbc68a3c99ac93b580a760bbd8d02c3c7e9a28e816bb837416980822ddf7c82d967421491b8b2e4d257960a6dbb2605ec24cd7fcbbee69e1eb99b6bd6577a85b58e04206d9a24c2bf2c46bef1696f3482696cc5df7d655b7cb1e4823a8c1fda91c92b06ab591ef92ef1dee089ddbb4e2775293aef509d4598bfe8be9530fee2b5aa6b210c9d0976ecc0e00de9d4333c9578f63831979d954a5c0f1ce09bbefeac7a9860e7e6f0197da64db09cc1d98d92ed7d3e234bdd4a020bc937c21a3b25a00c7cfa0deedf9a8ad5f08998376cf6850e82e2db91eee7b8ea5308b7fdb7a61dd3d35bead7574ab66fb9989e505dc933ed5be331700b341c8062370d109e71052aaa762996fb126c7e3eafa98b6c9649d4269300169ed4bec0023f75e1963551761f51a603fc237446513ab1ebd9fd412150ef4da3165f5918ffb41bd08ef46236c21aa36037e1a1b9c62654ee636dfde747ac1b347f1abd75a52d02dc875ddce599eb5ad1bcb764d671762d4c31828bc9b1f2c24c278167533a01688c4f10e7f9facb922eb3ab92ffa835775a6e4f466cdaede825aaf82218b1ecd49d442ea0ae197a946a5acdc53c6fe8c30563c83076ed0146fe12b453dcfb8cdec20cbeea3ace80df2e8fba7af465d23027a6d8cebf89ace2dc355177f7252d649f0e3fb6ba2fa9fbdc7edc8e7470c07ee17142aa4f9718a76d5b63e313d9c379b30644dadc20bc0a878c27d95ba1bca48e9f3c9e990496915771d1426a8f78756d7494d5c13e529c8f09bf7b5f932d62c31542e04263fccbea5675147b3a4b9abb1e681459bf1221180838a34d338671980926b15ac1a9e15081ae6c5ed121c354094068bc23aacdffae7bd744548e34c67caa4ff55e1bc1bb8a2d95bb9cb374641708ca56ce2deeaa4955a5bf2466f6ebad0fe5ef34a55750929cec666d30f6dba4a3a799740cbfd55d6c1a1ff11c2a5dba334e09e7cf2d37580e4f8d17bd4fac13248c8060eeec1af09540fe9bfa5192cd6dc3d651f63d901d55289b20f00f4668e23bd0943efdac076a9b9c8c83a485244a32328a5382dec658f8f37d0780fe9479a7311d1d7c6dcbc00328fa7ccc8008350dde2d8cada7a1805a2295e1d44f46ff4fef6bb7d489b03f9e20f4aad69c44b8611266170944d24b9f492a6d055d4e2e48a4e1fc55ce19c017849256b733580950e6c1e2c1e81f60fdddcdf4425086c258dd964b133f518479dbc5451a3da0a3608f00a0c0ffc32a1271c2a3f9cf42ac1a7cec4795838ddf2e33a83889c735462dfaf274ff6de400e2d7bcf2c7c78a2a275efcb75cc6a0b701f7fac8bc65029626850e88af212bcfc03be3f82d58a95690b9110c4c0df147a32c947f57a868fbe51e00c34bb0498d10a66196e11dd1452f76b6d0573700cfd29574640af62bee8c48d51eaa832352ff2fd8fd757ef63ccf776db6244143302b1373f9658387c1a08faa0a4012cd434d4d8f02e4374d6fdca1613db5c4cd7aca6c22a1277aae72d7b4e74b07ce183d7160f0f98b2514a95243eaf953e172058e900c58f3b0c778ef24705ebffd02921702cd9b55f4a6b4d3397136f51da4dbbc6a583b1f562de3e45938bfc13645f793ad141ce3ea750d283e7ac41bcce9e4312206cbab9623a736ae3a54c4d1c694b08ed945ca1aa309dd61a267f685af42678c3f773a43205e9f7ebe719fef3fa856e7d7c850364c8e4c7cc7268475504ccebd4cbb85d3288576a8afd71902f181d8173d3967098f2f935fc4401080531477972d7aeb629ec78ef72399365c97345ffb2168bd6aee191ceaaee84a6977f3c9c4ddba2a6af08a4a2f9ba69063c752f116a3ca0d72767112bc6b549852c4db5cd962f3333f3e8b777109ff0784a488686a11e738ebdad1b8c40125108caf4a79937654688cb29b430cd9322162ae296d4f066c23b97b676bd962d29b5d690ef8aedfeeee64c497baaa988f7ee287277b8694ddc93ba5aa5251c3c15d379488f1541bc036117042ffd73be5fcc6e51cda8aeb7a82c12e370007c659e7287bae041097bb67a5f0f7c05e46e76696ccfb9450dc1309c32479f08556e21f0fab4ca300bd5e0991d423dc9b62f42d2db2ddb3993dec1644cb693bfdf389b92f0b53685746d95b2d96123ccfda2e1c0d40c31026b0fc07f9a231c53c03c5f685972a3825be78e34eb1ff2f493083e07d1640f23cdb6885f0aed3ce15c83fb3dafc4cdada0b5efec0d13d187ef4683522c6b20bd4a3a34fae7c0283b605ab019c664a05143ee2c021e59d9bc588de5d24ac3a9c5a22d6fa2ae64fd88f25de048e5497aa8b35d3e1299c7398d7661440c29516e0e91f5831478c7471df70ec63c447b8a8d25b0166c2eb9dfafd0a11829866cf106b31579285a2a3a660b04cc34f94b99e2d19af84f0886c79f59efb80e8d2ba37aa5c5d8945d2ec8000030b50b660d38d56fe9e2814ff10decef0013fe4c9146ff34546f3325c1bcdb841e366f03d2c7467d68b8b7bd0c45f99f7bc02d58f1579b22988489a84ab56d6c96e0e3c6de3bb8ffc871caf803df2866c681fd591eeb83840b0fd981698120212871769ce57baaf4c6382621295a2754b542a56c22c4461b2a803a3afd392925278743c2cdfa534913a2c5d67f039ab752ba0b1f4b87f7b28f3689d9fb0b6cf74be10abdb6f64f57e4b03f73a4346c6121834ec9b71f4cd0e50e5700b13001f32c410ac39ff690306262c86ff2a99d8e57627b28e3f70d7a731aa347ad5fc492ec4b539edca265b76a6c57489c46c246c5ba503a35ee1d903d44611179e801b17f0d1d987513b742e914458699093ab3b750f484bd7b88e5b4d762d87ced3b81282d9330100684b9b7e4a46af3fc5e94b4fc9f0caeeeb98bf8f5559e3746b5fa88ddbbeea63e2d51415611acda76576a3cd86a67ce36809932b510f2402ec763c8502f6a37ce3ea132c10a669ecf32d69ba89ff7c72cde39c1f4c5e16770e5005f6f3dd118145be4ecbe61574f126303fdfac8c38b322476d6b14b2c149cbc1c41aceaa5371c3ec765da19b78b230f25e5b4a9dbc5ef08bd8659905551ba2078d3e31f308ae6f9afe25470cc1a1a145bcb57851a50f9484a6fdd345528e7a5c993ad69f32639ae118c4164adc27a5f8bffa60d9d1561ba6849e17a75c4882b92a3a977977292f5f5566d4281eaff3ab3ff8f5f78671659fb1725e3b362dc3f2735660e4a7f63fccc55e2e50c5c63389eca1c428786795b29607edaf683a759488d3f213ae354fba1a70d53a642856eb093581757645c274b480c65e7b3709795752c4f4471254e85764de4d380500231a0279861284418b4c7a137851e7c7fa1666de9627d66470bb519e2a07983be01a06042e975b99c57b7f89bedf90ab1895856421b54fedf0b318b9418cf889764c5782069a58f71a5fcc74e3d4f388f5ae042638417fbafcb2cbad156bcdc06b68758c91e644b4f52fb99171540a77a8b3976684b2dfc455701c6aa1b7eddf308af9063ca9f1b74ceae25495f6e49b12256e681387957ecf2a75976b6fa47176dd3b25d20e2155580570b41a9ea508ef3b3c60708cd5317307a0851aa786cf0c3069a4416480aa16822edd51e858250f9fed4b6aa71b5758c79fd65fa1dbc0ee7aacaaa5e90b3d91b2ad8f12a0cb3923ad3582ad45380cf9a93fba9a14f8214252c50f30a122693d1d7f9b81da1bc3d7b47688a38e5f1510af4307ca2c3e105a6f4069246d56614cc6cb3af641ab1b201c5a489070d0b9bfc220aff8030da4e79d1d62eddd6c1fbb5020509e2e58ab3bff547d63a5449bb09a1e3c530030068a5fda2601ec98f190614992774ea115169281eb07943ba30497155206a763705a63138fb9bbf407506596c6096409f9e95628a5ea5574d787c0f6438a423cd700301291c5aec08af33a4639e5a27046d1a1eb2cf48fa8aacfbc0e9ba6c7c369c1fe32d5993b07734d3324d0f8df093c5ef370af9ddb19a873b25347854aafea03ecb7706ec55249664d7cd4d104bbcdc9fd2f2d01040214926ca4c5ff33e1a44ea7864dae4d9a24f11dc4fb2be28138d604d4595fbc9397329f6b7e7d82b3311d8af07ccb7e43aa33dfaae22c0a89dd7df060f6b9b787b40f60fabdf88c405027ee85edf1ec00795a6d42259c15b1566d3e2c4faf2b471b1c152ad38f6c7fffb7ece8ca671310a5f9a169508ba6519b487add9834e23c9a820c47866015b18b5e4d495c384958b3511275e6d28c2739a85e1481731703bda1002f81a344e0a3bd43dbd4314100d66458484860f09fef9f3e14f063f9ae3c60cd52d1273ace10b205627e22593ba7950a844291afc4677d3500858a59af0ff9a63b2ce23e8621e192d610be45b77908b22c861e9aa5d977f65d237de9a6d4146daf3f64a7c98ab7d5f7f6f307af3ab60618fb2591cc27f1b900ee1b7800dd8145bcdae4349bedf73672aba2d5c247f9cd497c4e5a0361325a53b78c81b49cfab56986d116ccec7056860a375d8644c913606ea6c16347a07b41a387faf01726e559fa002160fe26c40d2c0c8e26e532c5b5c1f72334a17649cf2df59b57da33842e58eff41d6400ccd868e86eae746284b88b5190ed33a6276922849fd0a687cc5938c4d5fdc90465134d7d0d877104378332ab1afc04da205e0053287c22ec15f9d3e118dd1713acab9c38796caa8c0cea39ad4ade1eb2b4e0c3d903d97ae5587d4c4b8ed2afbebe3348ae0b82a65eda681b24037954db6281a0f34e7f9ff077ad8cf699f463124abac4a7ba3c3573ac51f51b96c4307008bf3d12a3667488a7f0c734333e016ce3dbc1c671cfe2550044fff12f11ac8f2f76b8ea52f4246a68e8de3471ba9a43837281121f00cd22c33b6ed8be96efbd75c0ee498c74b932ad02454d0f490aaa9c78d48898b3781849e67603c60ee24ed75a0928405983dd7e198f8920e1b793f970b0d4c4f6b95087e74432702021b2bd3d5d40f1b70fcc9f53db4f5ee5748190008689c9ac4016771a53f0a191605c1e111e4fafad44bb4e9511e4a2886e11e68a3fbe6df45253d0815b6015c1f3d611932f5845498392fe3e7b1d4901dc46b9579d913bb8a909e89f35b9f011841b3f9755f14c851245509016ea80d811c596f55248d5219277af2d58ae1b8b68ffeabc67203997c8df865c6e34054b1420b0bbe6e1a0f10111079268c74ce7171239646a9e60848e6d9fe420d1c5e6ced2bed581b213f515a3f21b49947df7999bb91a54e8854eb61c8a0c0a54856e7737284d2a17e2bced5d35bd05d87344b167f05175ea30679fed568555344be6b5fef5c4418f175152cfaba818f17f03d4454b2b7c4934c7608dc1629c302907fea5465b95165942ae95d796b215591aaa50e5509d93e541b979f35eb5ab6183cee974081492884ed3cced4e6fecbf82cdb0fea1de2f73c603b99c87e628de3507e888576fe37b136be1f6effa5e59266460195ad281d55a978f50638ffa22d37b69612363e94f25f0fcf61c8c74b5a0b337cbfdf558de738f6a0f42fe231e5ce78ab6506a3dc7020ba0c079689c1e2fbb486b18a7771453826b45ef91f07b5488b58c5e5ed4a1c9101d526cab2d90e7206582a4ccab93b2ae721b8573160f1e6b056dcbe68c46ba9d8ea6c96757ef1591844169151514f899ba12b02b469092b14360465f10b72c6c929f792cddf2d8c421926d9f415c9f6075005a7c1048b173bb371858d0ae4ede8bb5e136a17614d443cc8c44a48e69373b9f6d2952bf132f7b1aa05327fb14d8cdc8e1cca71ead007747dfe3f1bbb646e1d374dd4515efe7dd9f8d0e69e976b78895ebff3a77875c99987c0705d1072d2b6c5dc44cafe71b70cf54d2a1572e6266aaab7edd43ff515564d51dfa8da94b2a9c6ebdfb2b13f36565d6baddd26bb7bca626952357dae771e9755c5e913f0fab91a7384b9a9f97f72b2196061c7482e7657686f49e303d18eaad89519e8f21b2bb998be2b3cba2424b87d7216bb8c605b9364411d14e315dc111db5ecd715865bad670280540854d9f89c1cf82e554a65e41ad26977a83b8cc1221464135addce6a5dafd75a90d9fa51bbc7d77c5a7ac90679fb8eb3118b556c6d0cb884d05d066be47e7b7fe31c97496173f7e18d40e8dda763843e73e10a926fe747f29b8d59bb6d4d899754f1c12414d423f3a3980e3f7a1a0abf097ee8591239ba542bb99375b3f58472a4d67a33855baa62e826c1db40d2e274b3a7ac4b9eba41d10cb8dd9c8626c4ef8ca281e0e400cdea635f250b834106d9b70d303dc965bf24224daccd84d6aeb918b4d5c813e5ddcf1766b337c066ee211c7da00b0a25dc341b6820aa11034dd9d82574287177afc2a1d0be5e19da494fa161ebe55e102ccf52c15c3d422a2db236940a51b3735683d6b538940e8a4a398d3fdc8b8c98d089737990b5fe2676b95cb2bb26b8e13d86ef4b900ff2c0e2c62443df16288f89ae2abe267f6c87f577f24e6014efac3da215d26d68ede3487f5aed424ba79aa36d9e88dd23cf56d9c8fa40bc1b22c8792ecfff80993c913a844702487c9f32e1c4eee025d115243f78ab4a19756bd3e671b389a70c611f961effa6a3e404b874902d3d8a8ec72b32ddf6aa8f82d8aa1cba160f1c43874f9b4edade90afada4a14ceb74413226de5f30ce28df91e2a0480db7a36030fc07924e5b0c5eac547a5d1aad2f724f745a78ee821bea2ab52772ce52ae8d1c8b1af1b44220786bba041ab3776482be44534fbeb159b4cd9b0194b00d17f30eefdf16ac5564b30656e79c193e70dbcfb8ed094dac2b4c60a597159584eb006123a6ffb33dd5822f69f978311840cf057eca54f292293d6d0b2327da7685dbf68fda1533b672385614aab40dc7d08d95c0843963cf9d0d88c71b9131c22c448af3eff0a2e255ccf40b4fc317d7da333291c40dd6f1abceb29e98a47e6788cb1f9e5567e6459c3a6713d969f03ba02a7ac4fd6e94c517efc55daa3e11645c1b3f128b46745bf39b7d3fef274a979c861eb2ad70f14001c5dd74ecf8c89982a323dc48dd9c63a7a3fb7a259ae64dd23a8a05ead58d41a32a2ac9bea473607a7188334dd3a2ab26bcc3015a91dd413d832297ae4169581ae27019696277527ce708a58ad8ec75805cde9411916dc2359bd80670ab0da5ae4aeb6741ca08e2c44e97661fc93100585dce02dd07f3388267f8e7377e303a37335317c714d9a0a2cbe0f27bdf5054740b1ab89c62cb286d9e7d3b7bea83b4b4d84a326a2abc961bcf4a4694aae1ae5f7b03738fd03714697e1a8edc16d7c51d7966e1c122c9180f970a34630c2dc76d6fd2da47983d55f45dda4ec5bc4fbc635cc20c9230f164f86165d14bde22bd88a567bb182fa71173a6f96a1399342c7bc0134e04c1a8d8cd8cd38328bb5a53675c63fecee6c4d21e2bd79bdaee2eb1e56c62d1498598655a705fb46c404ee5dcc67bb4e0e166fd2f98792f8f9426bb94eacfe13299bcb8bba1387fe8e9b94d12de64306a29b5b3113baaad73223f15d383f3cf7789554055f5398774c45e0da2bc6bf08d5a8d3322821ea8c0e8c37108af92200a293ef27a05353fa1949786b07e13ac8c9cb148d7bbd31ee951be523bdca15da0d14baa078e4020224befdefee919ef14781a6f3fb2339dd2fd5587259eb07c76f4ef01f53eb067c8f2d132dade1fa11ec9c75e885df9ef8005b6dd43bbb6ce72091ae43306711dfe2f979330f705c9d2fb860f2b1a6f867d23331c2e5b9e36087a4d899f9abfb3e5df79148c3ffd8b7e75cf8234226015f1e180a10cc9f41d8ab392b6d77ec77b50c479a0befd2e3226699f7bc3416a1982af3d8a3a96edb50b1d556334c179d9e5a32b6c50d5fa25ff0b9927307746965701aa906b49b95b3f9226c39d06f2402ee25629863e99dbdf7fc3882d1d42fdee288e0a6b475017663155015b9b300bbacfceaaa6c8752020da318064c52f6ea6740b72a46663794976bc24dd2f6d8003df12640c69c33d6cd7c927626993b0a7f23ad2b7bf6cb1451196f8f3bbeca16d6e50d6f90503c1f1a95f52c1bfc14953b85156a1b4a02aeac98454cc1c6ae803d59885692b94df498ae165a4c221eaa3003829579f150fc1017e6c1a39cfc0882d785bffb7285d799a128922e82c1c9626a4ac28721524d52e7cd8b4d3938c93c79a04fe24a4d9688e5328b898ac2e03acb5edd5513e21baa23555c4a2bf4e3375eaca270c9e0a30bd90d01cc45ffe1e9c166e8191356076ab6898a623f3e00032870bfbcc8bbf9abbc78ac761b11e256ac328f07605687e6029bf42b7b5a4b84807cb38423cfef67c4c34f079c68dac0a10e326efb4b623b9d801a347e3b4e319ee32e6fa47b7ef6655259287faf54f6eef8ebbb0148e0627c5c60d0b05747765aaaba2edcaa93f371fe8c5af9ed1bdf3f1e983e07b28c742deffaf589d90501e57c7802dd68899dec3217831a7622f59610f83532042f88a2817aa57341d36ef7e0e97e79ac58aea7965e54cf304f393321f2f7a31e34baaa8ff20cc91f696548915badd05ccc46fb4ecc3ee6d1a56fa3df9264abf0cf9db0689586614f2c674877d65963e52c74bb10462dec6ebbce625dc07eb45c5a374e9b10874ece214f270ce4b8900661f3d1f3c86b1f8511d814a7646da7412605570e8f9c1aaf8d716b9f7299f03be3967ee08597bfc738637e2af193ad877b6921fa3c52d45e5748cd463c2c499bf79ded163e24c39a3e9855600dad34293802128e1fb0c6b1d0de0511fccdd253e074671a07536fa38d9635aec0531591166c3c5b0d95095afb16fa675f443e15ef13c873970d206cc41131ee6bcf4cada45f89fec2167251d5c224169686733e7a5769fa409fca44f66222ec8a818e4b9e904a3d5bc8324fd8a86c200d4c50d5167f2cdd6e5f3585fead5a308c695367809bc17cfa7fa99c872762486f8da099e326c2f4d4202c0cc8657c44a67d09baab3ac5560125dbd54fb5e3ecd403f4f181abf26cb3a795344a785efcbacec12a84bbb4fcacd865d7fb9e9973951ec5a1b45680283d4a887ac2abf05a8a0c2cf3cb0ffddcf59dab460c8d5a4c8e94c5c56837c03be9d25990e800fb32b3a9f458304173e594a537f9c8548ad6568723f6634c36b58d0ef997e5a35b1b1038f995711ef5ce7de2f63b3c4215e00509822bb651f25caa2f2163ebec6bfe1121c226a0db7f3ef0c65620c26fa544a66b29a7f635e035eddd9a5fa46c053c4e4c7ffcbb9ac7f2ea35d65b23aa70c764cd354339bfa2cec5e334fe53074eccbdbe0edd871ba398e9fff58e67e2debc16c3933efc67e76df67af1469dbf0650435d009f70168b0658aec9e2ff5f4035412e798ab23ee5bd363e4e1304134508a47c6efad80e133f0c54b77ad1415df4a3397be8dc9cbab25fc9a3b5e153e3ba3b974e30497c0e3545c32de8204df2f9cdc6e2fd3f1a0fbcf95e1d383f860f095047cb51781847a90c23624426ada94ce41a7cf085a11963cd1e247aa3414982afc2de52933cd9d73a3689cb3acf22f3c3082ed73bde65eab6047c9c012971437297c99d77833184832a1a2955d652d74c1f8a7f4ffc948568d10419257744d820b508a9e068824e691e4cd4c5e18d7dff82440e9cfa9156d3367a2ee6dee7f09e60e78f4dc54e6b0ab60c1f6a6828e170880edd14181ac8683c7a719e1851d375c069ccc01f812964a217d7760bd44f7717b72a1141f60267c63b3b8560171faa9fe2341e37e96bfc2ed6380fc9e5ab03f877b5c3fc1cfbef597ab84c61fcc5418505e996f47969f176ed0a68fdcc275b5e49b552997230b0aecdd00e1fa1026a1498a38e668a956c1a4b12a824c8ba822699ed89d812eb060a06995113a8312a76e4b1afc414cb49186749029513dd87722bd2591dfcab63d7a0551dc72a94cde9af0b8f61353496824ed27b9cfad3373f3e8e2f7c19e1051bb3ef10bc5eb48c49893bd0f92522b5734b3badcb16cd0e2183a7a85e3d2321c1886ce18cb92f9b5b45be13127f46623aeaed5122d8784d62697685a9f7f4749addb25fe7a450a1e622f877bb8cef59f1d666aefdcebf8f7118015bd15908844b0c3c2380dd091816e7125e5eaa5a07fc264b607b21fe09e79fece1821bfd5dcb4de6e9eab0ea76b7bcfeeb42f679d99d5c499185a91cdbd76032dfa2c9cebf543aff8642cc2f04cbdfc2dd7c21c1d85a7632edad5704222914686862e2a191ff86daa45a615f15089a706145c35fb01dd689782e597f13e1c32350e3cad1fd35eafdab7441a2e56297efc5b7442cbfe69989932ebfc883096c0dab2e5520e1f64eddc3961b61b669a93e132bce7109f828f5795e33ce700f82deb1ba21bc21be65c58cfe65052d51a1559be070c04eddae0e9ca2253270c2660cf5eca038ea06c76be74bd3b619171db610ee2f4cb1204d41ba4f2e29ba6fe8fcd82e59d6b326be4fc6310a3c766227f2e1b1a3de4a32c02ff1e368a49b676703a90f008c73d5e335264325ba86905f38c76c39c3b6f10fb51e6247f28dbc9dcd2b4285e4e8a98b4ef082cfcf02cface927da5afa1383989f7e6fb2f49fe18bd1b94a9ed85e73b8f6e75f77985ba5dc8dabf01247abbe3a925f943e8da4b553dbb27a0326cf1aa5c3bfd7fdb371f1c8a49794e0689ac245189c0b83d78cbacb20ba443278699df5463ef6d2af4d1a47f99b50e01270e07a48660592832f465ae705311e1c455bd7a6eb960b1da3d3bff373f9a3367c72de89189512e71fb3bb6a345f319913af22da0523b4909c4d7b6b315215612c03eba464b36d56f98101ccbf2cdb617ad49d96f3718ba75512a87bfa9b718265a63573e1420a509053c0628c4b093cba068cb2441d3cf529d99039d4f7c9badd521a8d176cb786be61a6d8514eee54b4c416d0907ee6573adbf1ab7f585cf2ab5206f6708d6f8b575b4651268db5bd45f929c4803812faa05c310b9507169582e30acec61125bb3bf2ba8d6f3997757bf9c41d1aaac1b0efa28736d6a2128f82cda663e69406f984cf0f4c0602080fe6490e9152b21d1e4cc21904b452c9e5b7fd44b52a648ef3315e92a029929e2907b1e2b4632098a2e1e3bed70672ed254b091e3dcab7896cb42ec92d25e69ff343380e3460b2bce5d735876e275dfb5f5ef46fa4f1cf6ade8594e18c3e0558c78a992d68cd39c8240d99fadf3f0662ad77def0cadb3b4c80136b4e74d66ec92b9ae9d7275931017ecf06942fde48b7591693e9d019e2fce615ac555a3ae7338d5d4afab6bae61fb83ae9fd95304b61c9473731ccdbaf3b27e3eab8d308bd3f8fc30931d38ff77b5d3d51e5430db734547a02a87b5bb382cc9e1e84159d35da06bb31d01ec1b4373acf576b765185ecd197d5d24156b48f09d852bac407150692d0ed55f34b3552923a2952717c9ca1477ba28f3339a44dfd9bb9deab733042a12fd7a71b0672a5b4aeddea7f1778bfc54b8ff8352d66100f6adba76a1c2ce23ac7afea7efbfffffa6a8300ba2249e7e2d085f1cdb58b1cb1d2ca40da964732db6446560ebd5ee21e974bedd070e79c435017e73d7b7fc156fa2899808479cec32a56c4f5b953d714eecc9fdd3637a2dee1d25fe947e6fded2d4b6f44f96531855fc429fecd7a36b0864320835d7d634d2be1e6e5f05fe4267078870d137a3c3b739b27b354ff5a1c46c32c448c02bf98ad230cf2af6eec82e3e9c10b144eceede58f7ce56bf7dc63ab5db37d201db35ed15ba79fb736049165be03793fc1b77de003039aaf27a239f3bb9d3e3df9ba54e33f8de50003093fc1453edf339b63b6fc37ebedf1546fe686a6158caadc68921669ebb7b65f3f0b74fac8943cb96083cbd9824770a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Finance </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SB + maven</title>
      <link href="/posts/sb/"/>
      <url>/posts/sb/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f152f8b972197a283d1a9948ee209c10971d68b712c3c301584f6c3b759001eb">418fac4f173397084caccc18ab9f089e90c7a29408af94da76702e54e165326b538d3bbc0524c310794701af7409d334aa8e0c615f1f7cb3fa946c666446e919ead29d9920444d20a9a7d397a0b6a0e691d0148728d6c6f4038b2851c6d51866ca2b6eed77ce21f7f281ff9f854bd1632f490b3f5b30b0ce45c9b769ede88749fc7c642332b6b70360210c88b0763f3f168a34817a68ffaede0af30e26e17ff2c23caf6e6b213f891928c7ce4ac0956bf9b36f2130eaf00ec5fc86d133f850f1734d09128bb2914e8de59ce0173085da67b1c0ab0a51992fd42053c7d29f30be7320286d3f2a372a0c43ec5cbb9e6fcc1696729c398a74799f3df835fcad6ff275cc47d073158d7149082f1e4f5401f710126f571f2b36853c6c30bdd9b4779dc6082aefa609821d346e6042e50849d5905b2ac1827d867493cfc1bef1ee60a9037197ab2a8248517669b9f60d169d47df9eddaa606463071f3bdab9c5c97a1b34badceebfed95123ad5a5c1bd9a693dcec44b528a4489aee5ae9fd65dc5d4e3310fae20794f775d5a6b8bae4eea67e2f38b90ad4116ef26cf785fbd07870443dd5e3d315baa0236959bdf2be36f690289194bdbffe84a3c16384b4490504d7becd50142c66c938388a05edf5bf3a492527dd3e4b06362de6844535f4ad5de499de4806d9152244867c4dff68495abdda16316cf92b25525547520598629907e28944bfcdf95aa8052f415bca7e46e1518fe0cc195cf1b96771dd0727ec400a063ba8a61b310c0da59f7077b02f22275c5ffe5bedb7de044b5d8b62fac5ae4c6a6bf5adc5896fa6fdcc60e3b96d07fd4a023d99316a9d74daec8ebc129eba067306c2131de888f4319e6cd451c51b0123b4d3458e29e4f88aacb682eee3b10d4832062a81be22bcfa4a2586659d41a444e0a54ebf02ec03707daddc368be799139cbf20c684240c9174d2918212c1ab8941e8313952b694e0e0ca819ecce9aa9c48ef6dc7b616bd12903f50ff25a5118eeb0f265b6cc792ac7c792aeb061f502c6e21c93b020d6be5b8fd03f4e7cf4b5eb96c5e1327ee513c334ee7214ebeb49ab9a4a09ea2b37f24de0c91aaac4a1437a7a03fc844ab57eab4e368e9991315e456f04d4bf536ee129489da133e3cdd7d51f70e463bd0e619e1a8dd539135406d362f8ebae08bb6ce512a01b064946e74a9ec917cc323630d77666f3a1dfe1be089f8ef6cff74d9ce524f12419ca0047a2b9f99db78ea89a8ffdd5ca835c95620b1902f56207252651b73c30cd0882ca080b6f38c3402fe65cf90e223d1f7efaab4dd438c01c6c8bedf9ca8925f5db83ebc2144ad73f6fae9d36892235c9f4bb0b348527a1839650ef049c47136c0c71ca0fc7055c518f81290c9798a6647a3ea216c72f94184190299ae80c32ac169910a541d5e3f9632a3b9357382cd3911c06199100035c82a0c9c2102e5d80b2e6e8bd104fc4ffe040cf58aeaad5aff533c474b50bc05839662b0f91b54881782cdc60fa45f4aab7a405c92f34046789d53f869b2b42633daef15b9915b49a53f5e24b6312f00b7c3007f1845eebcd2bbff8326ecd29e9c1d612a40cd95440add4e56e629b1507b8ba0af42aadb2be90f9b059752f13244437c5f8779e57150c31</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Finance </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新年新念想</title>
      <link href="/posts/new-year-thoughts/"/>
      <url>/posts/new-year-thoughts/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ea4f330f7b24096b89504d090e1e25298ef49f01d2658a365d212bec79b89c6c">418fac4f173397084caccc18ab9f089ebb7cf72090164e930f857b7e576e078d4c2c721629671bbf7dba45286464fe0bbeb36ea3dcd52bdb0f679b87a016470751b8c247b5f393c7c4a2b4dec3e7dc1128c02bf9b907443d362697e6f51e931970f34c8b09c9b17018ba570f555cb3697e88c5751d51334cca2e8719e018f5c78dea13b3bcaee3d32c94abf8156dac311f04c5d201a28d9a5859626804a8a3ebee3e5c5214b4cbfe37728d58808cb8674f77e8c56c63ee60d60f8b5db1fce5828bedffd1935c27952be162113e2fb8772df2bf76655769eec7255efef2a731b7e65861d55c6d3abeae5f101deaacca397eb1ac09e9992f1f46bb1c03c9880c53eb28a2f6128e575b2321b73c6e6de515b43beb381366d66e153711c0caf718b78e03a9463042210cfdddbff218f4e2b40dcad0f5a545c21a7ba34ac4a40ec1a38d64d25ecc715ed2ada7139fd5e9fb3bdae4a03e8ae4203ee1b4e1b7665ef2e00669e3cb32a0b110bfff73c99ec03c46639b9d54096518e4ea1fb175c852b3a0c1c756aa791b42a60e319f50edf4d4cbcf6615c0765350d7a9b703833fc381171c3b0da8c1dd9a5b51e7c92cbf30e47715381117fa0b5b23d6e5002091fab7aaf6fc698ff0ea5b3033d55ac60f8a19cb68786f6b608600dd65a2a885a22815bc2879196e951fbcfe0bbc0d820fe9f3840acbaa2775d10da797e83c3c232c7998153624aaffe219471c2ad18b1acd790e30f167d91eb94b95dab2096e074a65e511c8115f77f6c09024ee4dbabe107195659f984638278180ebd00601e310e4bf8d41833bb7c20dc3eca25125bff4e6607e92cc14d262b5adb5a6582ab48ccbc72da6ab4e6b3c27e4766c9241ae7db39bace76c431614dedabfecd194bdf198ebe8ff1290922990d44e93bc41e34993434a50a86e385c7b680134bbab95dc82010a9d9abe4cbfab0a7f1bd7e090850051cdd077bff28db7b594cc9d044d6c7cb9c8023ffa3fd64f4bc40865c99eb9113d622497e98eac7bfe5d6f7ca3232b0a4f3fef80f2415fdc57e8dc93ef2d2227f934d86696599dbf21c4592ec94c144cc2554fb2a56987cd3d023f4d48bd7895a018b68a4b27a4ce1bfba642b936f011f5433fa2d9e63c2d6b7b53e40b7dbdb1e4b94c5511d5afc76cffefa750b6900b5eff8437857492238b3a5cdb42784bfdd7158d423666acb2b163b9f137fccdf76002dc361ae4907d00eaef8d1f658864de5a24372c6721e6f02c1dfa2131f383c35fd21f24adca25d7ed989aa4146007ea3c0fc377d9da4e18a5a4a4ca2cbc2a6b5b839fdb74abba2981e935145436a28eb833dc81b6bebbfb6f9b0332940be3c3831e11e507e6d5e5f7644c90c63c21b35bceeb26dc3b181202f10a22e284501eb7adf9fa4e96ec089778acb3599cee441695ea8c876dcb3cbe7057fee7d63abb064ac5ced7362b205e55bb090e3a9c0541880ce248464c7e658af5f36b6fc9205acb58888ba7526a82d783c01eb94f5609dcee549a51c9cf73d4ca30b036140ffe73217a73553d4bac1efbf73f904432b05d1e9d540bac2bd99280ded337de00b95cd380ffd4d1222ccd07e9fdebedac335cf9627beefbe4548eff5070564bb8135df4d19415d288611324b51ef3951007340c81014dafd748837ec6f6c633b5995f47903338b3e38c47d3a18ef263b0b61ad31feaa1fd224f4e294c24fd7b476fdf005e71bbe7b37de198d6ddc85084d41fda48066071e18bd44bfd176d7bbbd1e27521ac7d9b6836f0d7587414b021d3dda9a8287e03284f2eab296054fe61dcc1a2e5bf9a6c31d4c2045123b988687d552d0129f0ac3c6c5c928487a5d950462dd621625782e5e877c0dc483d9e3ae9621015402214764b2c579ddace9f5c321ad6849712d6320a7a865cfffc5637c3d8df2a2747c75a5f7b98c717808cab2cf666dfe70109bd90c3174c03182f7e48930ecb2c2599efc905c6098a860eae2101efdba40df34faa43238d51cfc2c3f7f6aa6d16148641abe599617d053c9fe9983d1fa81e97de72288a88ee40d67fa43fbffe0fdf151784c481d3bcc674f35d35fbc3678605cfdfd5230b22d632c9bf2a79fc24c120d617b9ea2a58d9cec486e37ddf3a8f4c801d7c2e974c0fa32ecf60e792e1060c5ad0a4fbbc946ce2a03bbf0b4c9cdd998832c2de8537ec34fd18afc7e663422fbc51072b965339f97e0d049d83fc46bba76f0d904359973886f1e343e67e594094ff83a47132e8ba8984773ab71b94a85638ad76464fc53501d8720420519a0bb54e03f41b2a302a5ccfcf877cc94bbf4ae2fd50e49b92bc8bef95b907ffb8d498f13d09ddcc5f44bc79d643b7b082519bdcd671da332f73cd42eefb854b0f1c7f6ec56b64b0e97bf6e503459c94e924ed0cc55896d6335f88a41c4fa2653ce4f2ab548d25e41820d45baae50e04d733266ec0f027190862e5facfbbeb296df22f1de63d47cc7640eff40236cf494ab224d48565a99d3cbc4b55aeea9b0d98f0de10a88f7d4a6a137ef87417ba7b3117c4025b33a5f6fe626b068e8219c74bb443a4475ecc46b8c7fc5f79ee816556dd33eed6c31f6d0c17d2a3b5c65c7261a4c98d78a717693c5c92850611e61bff76e81ab77591436a47e828b6d52d49c1907fe49609b2ac52ae623e7707abfa7ab4da793a0c4c7dd4dc54bd3cbf0de09baacee020a7cac93d27a5a3eff2e28a7ead5504bea02c125cadfdad44f61622175788a1b22d616a44e766e6e64ac7dc49f9d21bea75effc110f989c3f542c578fecc9b4d084ed7a9bed1b8d4f982a51835706e87b2e58ed878b0e968361ab5389f3457e7b8fa6c8ea484979c3858f885e4e7c802ee865e18963f8f76c1567ef1307833f329fdef1a5264ebf0ea5fb4a13cb874fe97d0e5e5e48f4b8dbb69d193d87e7ecd78a8572e5f63d755b1c270c500cbc75ba96e1f754ff213ff3a9ada342804f6130b2f170118b0ae9c3a03c0738918c9e4688bb40ec950b797de4fa1dfd5487f576b23547b33d359cd509feba5476bd01e5eced6f801d52789635d49ca86e896c9d3841cbea611958091517fd44143778a47d41e96fff87de9ff7eddb72477f0684464455c8a3f514e9ddb2e4257836ea49cc1c9d83563b0532edd76dc20334a3a022c3d76b3e7c651a1dd22ca747de69564ca92625f918af0d3b7642dd8e93602cc44f8a3f8f3a902078b5bf5e2ae95a66fd05ac78b77e9f98d0af2f47d67c54972b62beaa35fbbed809dbc69ca52ad532bf9c3da4c900f70d52b05639408237b11640261590d1067e067def7e723469a65f9c47aca7807d1bae3e7229af1d4d755d787ab7f88eb1de638ea0a61fe048bda1f49f7f63cd047fffaa90faabd6df4929f32965b99ddba345517fb4199f5514ef886ceb34409af027fa520950d593c22dfce3cf823e8d35cb5047bf01151803f0a1681701b3d7f166d363b809d87fd48f66d33b34af73c17b714ca03cba7515e329c2aad04a5cbd733d908f05acfd05d125dae9c73e4520fa5e5760e3e0db605b8785b0602ae5bef5b5cefb113636aead4ab696c50d17f1ff89600b7d922e9bb103b3d052dabf39259b080bf2ea9b7d9ff95bf4f73461a36e509fe49b602fe1099016b0c8c42d66ffb36fa25c69ef4f613c244238303403f082b2e6e5300841077a91d460a08fe70770595b145c8f2cf43a8446f2b124b1adf829c83da69255af869efd2972cb7e74b3374733d71fadad9440013e5cc2cdcb72cfb29db880bdb0b560f48563cd7fc31343d2a721ee46cdcf0a74ebf09d4cd112d904ea4c9cf2736b48c1b8085194f5c31cde319d21a65e1b7ac2deba1a5e5d229a77dba789a3f0088261f04455fbdedd6cc0150c5a5d4a4abbe55cb4dd54afd36cf626a1a9d6abe28fae8faa4753ba3d14c5281bb9f887df862cb9c969bfaeaf98a2d52b04be4128954499657005e178a6f58e47cd5bf1b514f7f925f3e3c6fecfe9ed5658c08725cc65a1946adeb31376ef46573395070393a052cbf19bdc81732290e1e41671dfdd4f403dc6cda45e21c0f0b384bfed0ad20c0db14d469f44d15cde698425012b55141ef56c9770c17174799277aef65768ba268687bd3ac34bd326469d721323a0856925c8f98b118f41a9a55b9da6e8f0ac77d82de766041ee7abb5b4c8e40e7ed868d9f1ab679d437e04c5ed0c6e4b485ce9ebe673fff87bbf3d30ebe97dc657920b3332cc2a409e98ef7abacf1091c0a7df7589590fabed5dbe963e83b914f232cfac1b7ba4c17e146938d7a21caa7c4dc28c9f3368cf850ba02e3ed52a798ae9e492c6674cd59266bf8d95e402e570f4cf8a099b7e066aa2eb592de2af42a8e1ebaaf7ec46c32c73c496aab712a76aa48d7e01a6f23bf298503ff4fe60d2a357760c5d8f790d1b3323434187917da315b22f3dc3777f38c7e72046a4ad5db7c7617b1f3f9170a6a98292efcb26f1b2f7e1514f4ab3e19c387de48ee9f9cba4c1fc18ecb0b8dcc96e5afc98480dd9beb8f6e88ed8fde032d9b9130853fa6b6ca5af841a2de722da917fcd274c8109031a6c408909bd49dee3c364834441a4aea94961e7d34d68c6960be3732c12ceadcf23c725e895752a4acb632957199502a60c913177e685eea84c57e6036207032889b3d541434d6876fa71f75f906e05f34bb33e37b587451ac5b7232f052becbe69803926ff7d7e5d12d928cc46f15e797e1fc4453932f798e3dd36da719025d9aba36a9af6781e9ce352651da84a5624c6a101568eceb56911cbe33b69bf39c3a0249745f69d96222554b97fdd7926b91a0bc8bda16b654c0083d2d52e816dc5fb3527ff84c0d31e3b85160c49309a8b725ded6a6d28f8e07ddaac74a9b599deb7ed56d573332d681e556e223d4d6b4f2e08ee3d21b0c7ea5f9f5b2650ca5d36761ed01368bbb91eac8afad1e58cfed0a97649980a43f4bc7abecf2b471e9a2efcfc3223cfe046e2823b85fc54165210d891fb36e3863495c84f41705e39810b93d72c57f839c6c7209850c1da6eb13d31a066e0000fc75e9995bda0d10c57b63988693e5dabc5151a033f940efc3dbcaf0e8f897988455962aeeec355cc1c8a63cd633ee8acf1c1fd6b80f12b65acf3579c47d20a5ebd26f903aa32c5c4b4664256d18e28b4eed3bbbe71f2ff250e9d4d8f4073af355945b5fd9b280f13b86b818c1f76202929554e8e4b67189d3417fc26b2968440902bc403895db202da098d477ba30690361f873a9f14f1c458e51e403c4a0b5a11f89582f59a8f92fa097ad82b23852f64e1f4b879c45297e7307a9220fb3c67e4d741b7b971fbecd12a5625846370da12edd1eff672f3418dc1cc0871971f24454dc636aa4c306c78dcf9f96eb8392c81888259b7e0f4dc8263d5242bf87be7a015f87667265870bd4da944f46d9f813a7af96e32cffc324f03f551274011836fa57159247de113d419a43617ee4aeb00b1d0357496bf57b20e662de5d433b2ac7ade5873eb0704ab1c64d09269942c2fa27ca8cc3c4e12818e161508fc39b90698b7e7160d9be811205f51c2ca8e03e06c418639a306f9baaaad7ee9e8bcbf8138a3e0a6162862cf7371ea63a45bd92d0291da07f55e9278fdc98b08be170841892eb8a139a8aea2a0a27d4aeb371278358416dd2c3cb676f0f9b06bd6958f3d6fc5b076c77b4c9a572d8989797d7bb525d40e6bf3206d6beeabba549d2b90d58da5448b8abc6abef300b22e807988208ceeb1ef9ea64c3ba86c0290da790728632e3b6de8fb3791adfb76865a2810a483b13e76795a3dc3ee1c20bcf5c6f133dd7738b4dbeed20ad3ac652f8aea583c2793748e59cc6d860b6099bdc0a9b17675f62fb13fe1e8cd5b1e65a7ddb093c32a5e97e743680b27a312e80da90db0e8cab75a9f6eba017380942226031b62074197fa5e1c3349665a42bf95595e50ad12b0259c31ef45b1d1aeeba062e8222fec47d24fc0eb0cb6aaf4d64bbfa4c1e92cbe6d543a918a646e9fdd93f7a6c9d05912d99105bccb2a05f0010c7c463e5e26e67e73ce66afd249b31fa0078f008338232dc8b0487def3ff6990983a9f76a05ae95a9bee20ba7ae58ebfb203ab5e57bd7ef4d4725f34df03fe4c7833813bf65b2c92598daeae782b0f546a05797fcb4f5aecfd773b18e0ec6464fdb3b9285cbd75483873d783bd9691b481f935ab4d2176e1441bae7f218c4d61ec5a9fd6d0ed57c557a97cb80f426a58522eb91109e52d4f2e055e4397507e3dd0248ed763662ce2173a92af51cd4c43ae6e53b18a303486d8d838456d9991918b6d00d81b0562d0b2760186d571c49b0f0dad2fd4d5b04bc8ff7700739bde24f594fa6604cac6a6d77b45be86903632462f164704bb83e66f4f6681c2ad1dda5156064a107af825cf68a366cc7a4d2784673b0e4d4f0ba81c345829f3ba9ba19a4b60731163da1c5c8068157f5faecf726934dab4c52833214dd8b6a0021b65df4240b8eb3746bc1281784055831637002ba7cc1e20a4e6ee0be9244ddd9d7f2869b2955aebeb00e73087302cb6ae8f32a5829c4d6690fec960c8a3b9df2e9e192862e09ed78c27e5a1c4e1b1bdf0fd4c890884ba49cbc6c0302e3239968c6eb3f1d8bd04d4fe566d4893f77f448c5b061b172ccc989d180a2190225f6aaa3fc9f818607bf74354cb4734aeaeafc83d3f85a1fbf6a5c17cfaad7be940f6fc136f1da45329283952c1ec275e3d2ed5c3a16a4936c6d2dfdb983b67cc4e2a2d17485c02172ac0f070289a9d4ef6b688b79cc1305f67761aa312768caf6b8b60ba722bc2621434d44b8e89a9ce9985a34fdef5eb0c676c5199ddd519fc7eff9de0dbdd5b71ee49e2d023194090a98dccf097ca1f90a511fac0e75c5d9268acfde1687f9ba38bf744c370110a3e7b302f931c18d588c317823fc93ca3810684507a798860c2c3190aa6d7d90148949c9cdb0b988900189f8ec62ae53a2a3e18217eb461ca10842b04c37d64b1dc9c8cb183375fc8774767520540f1d05992e599c9a3a4b7788cad1746a1906576a43cfc88fbf085792539c6f7f3be67a62bc18de27c590116ec322abbef130f99f59eafb8ec7cd3712cc7571271e8f022eef7c9ed2f75c703b104a3462a582b80023d33ca5104b86d1182fad9e3427254afa5852c647ddcf438242bdaaaa0fd8c353aace573275fbe105c05c7b545d32cd3b26aeb4f7a0b6da1ea2c4fdd786ce801e93521c3a9e104fc7e546f9bd80cab1375603cfe140038350093b032f3242597d440357902bbfa4a615268b92be394965e363c1ada287cb0e3b120d6544ea3ca22d25f32ff6361d96a0b13ca034a75ca69dbf8304c3eaa4633d45b0400f049b1e5d229d19f436e12040cb277a472536a3abd48df0f51a4e669602a28c9f6146316437182ed4782f5a9c876e88da903775c52013899e6039ff9add96928e57b33cb33a6c0cfdef9156b33b76470ee1f0824b9d681b1d5c1ca84d1ebf24f8bc29742a755b36d298ff88495fff637048bb3729a7b1b4d48e55d8f573bd425c1288053be6ea009329be6c9f9b36261710da3e45074e0353f1de3d576b69343ec00e87186ec3eb7e8647232c8dbe08c86709f5833e606b2b95e7a74e3f40593b8714637860122a9955c81a2f6ca7701546e7a5fcfe4b446c6d152216e68e7d602aa603c202e440c133a80acd8007e084c651cd40fe780246fafadf1ce8e4b338628a374d69c3536f6184988089dffbed915755de8fa6876e95e60c96bc13b436cba7e396f10650589edd70c862c702c35aadfa85e986083c329fd15c15b33a05791d5c5bcb95c181be4c34d0a2ff790e0c3e0bf533614076459cfcb537ef3d527515a9629ef5e0e30dfaf4572d0b752241cd45ae2b1cafb66677022f2a84bf0d4ecbd5671d14f3196ddeb98f8a2cf615a27481ab8a896d5e98dc6309714e957adc160c411662f76d029ed6a9fd6f43099bfd4ab5f954cff5ab9eb3a923a0c3d95e61df4fcc51ce3ef7a760a7d58403e6bfa70438537d32ab14279287a6907351f25de65094f8a3d79b0ea459fe13b4ec10aad950b983144ce3af61bdb36505e8ba90bef64c63af9be6971df767eeb6aad914ddb7417d32f837ff9975506652273e2f978d976e4df50b9b8f2edc47f80a13e1d7c90520de150415e11b12cfbd4141cfadded850839310eb411f2bb61fde79ec78b6385f0f0a0fb99a933af3e1e71289b39fae0f753625480ec1a7aafc8c15a8d3bfc2e304843ee4a0b9346c53b4383c57e8542a57584255ccc481313471f0cb4289d3f9f62ffd5ab433e2d6043ad342346d9e4f90b1fbed36945a86d6bdf094928244e8100153c1e0a66ef4f479f6dc5aae54c346d7cdf44312f010af075fef5dba6d0972435b16dc4327d4e5fe5282051883542a8cb3a9e1fda76ac972d69f4e6b770a4509b64e5152fc22d0c7e4b40a8ae3f29787f9116c772bfaf090e137fcdba534837c760ef71c02e78ebeb0ad258d3a68b14ba24c60a826b698b7530a1fdac2fdf005559b6004a4e9ebab3cb96c65cb35693e611d40df67c668f7b7d255a5399f67a6fc5cba81e29dc95a53aaf8cf77dce2f3b575e56217d876af3582874c8646f18034c07e4b7645e63a1ff8c23e52168d253fe78cbf56e2dbe05401b4c501524782854585f669ef7524b365c72f0f7704545d25173e0b9431e07c40d5d8663717f82605ba1968326a3c8417d5edfb80d3e4100efbff29cffa30bebb75d6b885fd71190b6c7c9a0be4c67d4456649fdea9abcf47f670aad415b3e12f918626d9b9676c75d081136c95a0633c3c19ba7ea57e6cf676b911259f4d98190e2e16995bb87293a518fbc348344959cf46793dc4003b47255f6db247ccf1ab1481a25adc8fe8fc89e4f610fec53c2cd1db0d2a94ac06328f885baf03137f546c42648e91315d3308c45d6dddcaa0e6634db68af532028f6841035c8b4703866837ec3e52912457b564f1bc8800da5e4b9128934bb718369f71d2bfb7bd6bbf3e4fdf34928884dc3b413fbcf1f4489a4ae64f7a0df01f2ac3009a5fe9339a7337817b581b95ffcbab4bd1ff18252fa7a0eb88621d7e57a958e390646431ed70f25eacd758df2e7b47ee549cb3d4dfd0ec74c411a316d3c4237e374596d066eb4e9ac665df9c65e67a97920ef2e2009bd18b78247ffabe129284f0f48468fac71049623f3bbafcab78dbd48afbcb916453be291529d7ce4cc735d8a09d1f042f154d8989641a084de4647e674686f12d5c8f604d14453b0949e1f448961e0be0fa65d4f7c803715ee730f3e5da9d5699b217255d3ba007efd2df7a5d750c3694309a3d79fdf65d3bcb3718cecd4fd1153d758a7a6f9d2cf2d5ff7cd2267db51b048bfc0c234d9262a83f61683918866a8a3d7f2a9edbd984ea02cd7192afd623cea9401f829e8b63711f66417dcba3a192e6cbc77f19c521b25d2cccccba79bb6f13ca65780d9e5a4c7d9fec57c9708fc57ba070dbb8b39fb46125b2f932bcb7d3e176e66a9a6365d20fb13791e9dbd43a33a76ae8e04c54800e6a3147dbdfdbaa69070f6631b1ad8cc95ed63b59f8eac7be4cf3aeb9904bad5121f883ba248cabf24f351cb5aa4293486950b1aaa3c9b785a2588017a8bfc73294874058a43fbc41909e27e91e50f28a2825c93370c013bf72ad8cfcfd063d1e1061cfa53a2d18c4001245243e4799952d11c806ac72c8e1594900ece8c0e9cf554045b684996bf6cc4882c130e338eb301952969f253e0142bad20bf3d63b783d04067f6c8ce6dac688e0d26025decbacc4423badbd2dda2ba614c3dfaad27fb504e0250d7da115f994cb1a72b591b3f6b33d4b121e6fe339820d3e7c114499cbec3ebc610486615646be34828525edd98102755889a3583f51f8f9e9b3c98e546b67c5c85bbd408cee909424d46f12727a8f2fddbdbdc86d0cbc700d5d61f29936981ab6f60ee99d69b356ac5f0d70aa3140c16c9413ec7177c3863b43c3cb7dd29df04235215d41b279415fbb87acb091b360975771b1142b8757d9d4d095d83778b89d2781ad8eff2d4a51f7a5e8b4be7ff233d99da267f8799456401e9715e0ce3d01b4f2a1ecf46460a44b75ec82e4f4859f5bc3e62f326530877e2aa75b0de4c250a09eb9fb5b1c20d442306c0d2c47350a58abd361c36798bfe680ec8e27e1f55ec468c342f1e378341b5b443206200609d95b260cc7dfe197f491c99fe6a2850ba40849177f3ed68ae0771b18855222c54123b2d0ef83f4282e76f901d773e446a1e38e8cff404eaf6d4dad99045801523304c3797d8b608b3f056ba0ce989ac7e9dd8f823aeef290ad395e45e461a16ad9dfdb414494af0ac6e1060fb2e626ceca839e3ff5a9329a1006ddabf645ba582611200bdb1f3eaefffbed6125b6d92e0755f326b0ad14875628da0645d22091c06e4a5f8a488992a870ffadf1631e0ad3ef16d5299db6e56460f2d8663187936256fb79e9611f8c90527673fceb8ca5bd2adf601363cd1252628b415b5d39be2e995dd46857e81acdeca0ddaa484711897f530bca282c920f75ed8dc1421f00b062ddb07d08d4653a7fe003631b7db20149120d75b610c00317b572100396a50ab9d6722b1427e0dac1d2c398a08b12765d659f725bedf682ca4b50dffa56925102096849d4bafbd1b2556e64dd80ef00a148321dbe03dc1463250fbe680144abb1fc74e26a2e52d38c22791bb9c0b071f7a54aa1d5ec4dcc71f4ed1ed345e08d6e742fcbba30f34c14400ead317e07728690e3d4fb7e2063323c7c4d4af045e8a0b170cc56d9b3b0a415479303c8bd8c9e4e2e6f356750d45eca3bd3ce89dc4ef1edaf7e1bad3d26cfd3c262dfbd5407fb0aa0fc7ac6793c8644264b030532ed7d381d5a34ffaa3e9282682ac2bc6333fb663e52755728c1fd3859b9ba4d26c35f3e85c1084501bff9e4b89b233c4c148d226c47376e1f21ea650f84b837a7b3ac05cb6029fe6b73d033aa98e6dbc5736c2a4f8c2e6b434533fd54f0b5c7e4a21dc0e9e41c6b32add38a4abec70f5faf840e7cd1eb066b487d2b6bc497dc644e18f35e9afa6189d9ccf2b796b10c3af2c09fbea03d5b47faa00eb61fdf8fedfa44deacf8320b6a5e2f2c727b3e22af95b4784781ba1e153894ad5524e7ea9bc937eff47ba571d08e1160bc0ff750e921f22568189994a096375e610092c7ba674b04895560f043818633bb0612418e73b5c11033f2a8cf1372a6cfe492c7ba0775d9af7b31fdc8b21e16903e4e5a33e9368cd24c306d09471fe523ac8807f80ac94d4716af74c5e6c73b54feafb552f0dc0a72fcb1f6fdb63f5a1a76524071186c61e6d245cc4b892abe7ec52a043c8629fd66147d324ced35a0ef61228ead11ba653d9ec7476e3e788c2e53697290ba3eda7e177075c1b501ded64ac8b1272d9164188d40f8c51b7dd1eb5038c610467a2d7a61eb4747fd946f8940aa09a377f472c2daf9615e0524069a0a2eb790191eb7717ca5db538b8052642b3d1021e38f648328871dd5053d0260b8904dc1e5e84c6c0de928e5767ac20b49b9a59b5337d5cfcd8fac7f6911884442fa019ae30be2b48556e49fc8364efa55c34b4cf46843985ff20274c89ed1b7788e6b132278f7b6edd4ad8ffbb971de75bfb5413477700677f2fb7cdfc09b532373e12dd4524a102aa4c23b9f9b70ccfb01a099695805225c4fe9d33d7bf83db2cba16cdf3df9a9aa585f909cc4657ff2f32e478bb9269cdcc9286efd0c6173b7aa4401314940b472ef9201dece5966761ea7d0e2a969811aa0cb939b07395ef14ee1d9f4b1b24776d684181ddd0884594832ecc29b00f893b8f102250ef49c29fcec9b65e9b98274f825fa19d750b9b94847d1c648b08bae7f9728bbe3f4e53032ed61c8176691251a5fb5f441861313a2de7cab8cf42bafad85d3f57cedb364ad1c004b293f5dd8dac7be74e37a01b2b0d7310ba187000f42a962a467db26781192c13e2a955168578dee15a747d4a024c8eab89232bff34f95cfc63d75dd7960c6d3b38731fcc3053cecc4211fbe16b2293bdcc0ebabb68c790d0f588d975644f5a191bed4dd6917222bd1df65f0e1599c09416311af5168a563d8c3365222d82c7823037deb4d7d8039767334a738b4f25e6d30d6c5aa55b036e6637444c124debf0c06551deba5ba91642319a13a8df00062fe4a85d562feb836fa78134f7177bf4592d070b046637fbbed6a0efac70cb6de572ba1c9c611c64570275c7216edb4687e900f09e2e0bbe6123fb42e08b1738389541a0b6e3f936d105fac174325ea6f33484a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
            <tag> Reflection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce Lab</title>
      <link href="/posts/mapreduce-lab/"/>
      <url>/posts/mapreduce-lab/</url>
      
        <content type="html"><![CDATA[<h2 id="开篇废话">开篇废话</h2><p>自从去年这个时候找完工作，就再也没有认真地、系统地了解一些专业相关的东西，上班以后更是放飞自我，再不搞搞真的没人要了😭。思来想去，还是决定深入了解下分布式系统，其一，分布式现在确实是一切计算与存储的基石，无处不在；其二，感觉的确对这块有些兴趣，想深入了解。</p><p>众所周知，想要深入、全面了解一个比较成熟的话题，要么看书，要么上课。看书实在是太折磨了，所以这次决定好好整整6.824这门课（服了，几年前也是这么说的）：</p><ul><li>notes: 每节课都有了，不用自己记笔记</li><li>video: 打算看Robert Morris的，油管自取</li><li>paper: 硬着头皮，结合各路大神的理解看吧</li><li>lab: Spring 2023，重中之重，据说爆难，应该会写博客记录吧</li></ul><h2 id="env-setup">Env setup</h2><ul><li>Mac or Linux, Windows/WSL seems impossible</li><li>Go 1.15 or later</li><li>VS Code with extensions</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install golang</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin  <span class="comment"># add this to .bashrc</span></span><br></pre></td></tr></table></figure><h2 id="sequential-mr">Sequential MR</h2><p>Application(<code>wc.go/indexer.go</code>)已经实现了<code>Map</code>和<code>Reduce</code>，<code>mrsequential.go</code>用singleprocess实现了串行的MR，即：</p><ol type="1"><li>对每个splitted的文件，通过<code>mapf</code>得到包含<code>(word,"1")</code>这种kv对的数组<code>kva</code>，展开后<code>append</code>到大数组<code>intermediate</code></li><li>将<code>intermediate</code>按照key排序，使得相同key的kvpair聚在一起</li><li>对每个distinctkey，将其对应的值<code>append</code>到<code>values</code>，传给<code>reducef</code>统计，输出结果</li></ol><p><code>go build -buildmode=plugin ../mrapps/wc.go</code>将application编译为<code>.so</code>文件，在<code>mrsequential.go</code>里通过<code>loadPlugin</code>调用<code>.so</code>文件拿到<code>mapf/reducef</code>，即<code>go run mrsequential.go wc.so pg*.txt</code>，最终的统计结果在<code>mr-out-0</code>中</p><h2 id="distributed-mr">Distributed MR</h2><p>一个coordinator process，多个并行的workerprocesses，coordinator和worker之间通过RPC通信。coordinator和worker的入口分别在<code>main/mrcoordinator.go</code>和<code>main/mrworker.go</code>，具体的实现在<code>mr/coordinator.go</code>，<code>mr/worker.go</code>和<code>mr/rpc.go</code></p><h3id="worker-reqs-a-task-and-coordinator-reponses-with-a-task-file-name">workerreqs a task and coordinator reponses with a task file name</h3><p>第一步的目标就是worker通过RPC请求一个任务，coordinator响应请求，返回需要执行的文件名，worker获取到该文件。</p><p>因此，首先需要弄清楚worker和coordinator是如何通过RPC交互的。<code>mr/worker.go</code>中，<code>Worker()</code>调用<code>CallExample()</code>发起RPC请求，通过<code>call()</code>调用<code>Coordinator</code>的<code>Example()</code>方法并传入<code>&amp;args</code>和<code>&amp;reply</code>。<code>mr/coordinator.go</code>中，<code>Example()</code>方法作为RPChandler。</p><p>可以先运行coordinator，再运行worker，就会发现work能够打印出coordinator返回的值，至此也完成了两者间的交互。</p><h3 id="section"></h3>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flow</title>
      <link href="/posts/flow/"/>
      <url>/posts/flow/</url>
      
        <content type="html"><![CDATA[<p>第一次听说心流（flow）这个概念还是在Tal的PositivePsychology课里，回想自己这么多年的经历，经历心流的时段屈指可数，最接近的或许是高中时全身心地投入运动的时候吧。</p><p>后来就经常性地提不起兴趣，也没有太多欲望，每天谈不上不开心，更谈不上开心，所有事情都抱着一种无所谓的态度。尤其在工作以后，每天就像一台上好发条的机器，过着行尸走肉般的生活，也越来越难以专注于一件事情，总是在不停切换、四分五裂。</p><p>这种状态很不正常。首先它不是抑郁，因为内心并不厌世，也并不觉得活着是一种折磨，甚至还抱有希望。另外它不是躺平，因为还有能量，还有一股劲想做好一些事。最后它也并不是孤独，因为每天都有与亲人朋友交流。</p><p>组织心理学家AdamGrant将这种状态叫做颓靡（languishing），一种空虚、停滞、无趣的感觉，每天都在浑浑噩噩地度日，没有什么期待，完全丧失兴趣，看着自己的人生笼罩于层层迷雾（Whenyou're languishing, it just feels like you're muddling through yourdays, looking at your life through a foggy windshield）。</p><p>有研究表明，颓靡会扰乱人的专注力，消磨耐心和意志，减弱驱动力，使人的快乐变得黯淡，也是导致抑郁症的风险因素之一。想想看，对所有事都丧失了兴趣是一件多么恐怖的事！</p><p>那么是什么原因会造成这种颓靡的状态呢？当某件事刚发生在人身上不久，人们可能会欣喜、恐惧，这种情绪的巨大波动持续不了太长时间。很快地，这种短暂的情绪让位给长期的颓靡：长期处于某种环境，每天重复的工作和生活（GroundhogDay），看不到尽头，会让人觉得世界停滞了，逐渐变得麻木。另外，由于很长时间没有那种心流的感觉，久而久之，也很难发现生活中值得开心的事情。</p><p>因此，摆脱这种颓靡状态的方式可以有两种：不停寻找新鲜事或盼望大事降临，寻找自己的心流。盼望大事发生要看天吃饭，不停寻找新鲜感会使得刺激的阈值越来越高，并且情绪的回落会越来越快，可能导致隔三岔五就要刺激一下，并非长久之计。</p><p>如果能找到心流，并且周期性地长期体验那种感觉，就有可能帮助我们摆脱颓靡。心流这个概念是由心理学家MihalyCsikszentmihalyi提出，是一种全身心投入某种活动的状态，一种置身于某个区域里的感觉。这种活动可能是cooking，running或者gardening，在做这些事情的时候，会忘记时间流逝，甚至忘记自己的存在（losetrack of time and might even lose track your sense of self）。</p><p>心流可以来源于虚拟活动或者现实世界。比如沉浸式刷剧或玩游戏，它可以让人在一个不同的世界里，沉浸于另外的故事中。虚拟世界的问题在于：我们只是被动的单方面投入，游戏角色并不知道我们的存在，所以这些只能帮助我们短暂地逃离颓靡而非治愈它，我们真正的现实世界会与剧情产生割裂感。</p><p>更高级的心流来自于主动参与真实的世界。Adam认为顶级的心流需要三个条件：掌控力（mastery），正念（mindfulness），重要性（mattering）。</p><p>心理学家发现：给我们日常带来动力和快乐最重要的因素是一种进步感（asense ofprogress）。我们平时总是过多地关注今天以及未来还未完成的事，却较少关注自己已经取得的成就，尤其是在工作当中被KPI绑架时。其实掌控力并不一定来自于大成就，也可以是小进步，例如拼出一块积木、写好一篇博客、做出一盘佳肴等。</p><p>这种小进步带来的掌控力也依赖于正念：在一件事情上全神贯注（focus yourfull attention on a singletask）。现代社会里，各种各样的事情或诱惑变得越来越多，比如工作中，时不时teams就会弹消息、outlook就会弹邮件、各种各样的会议以及同事间的讨论。再比如生活中，短视频不停地切换、不断地新开浏览器窗口、做着这件事心里还在想着那件事。我们每几分钟切换一次自己正在做的事，将时间切成了碎片，原本生命中更有意义的时段被我们撕碎，变成了一些越来越小、无用的碎屑（wetake what could be meaningful moments of our lives and shred them intoincreasingly tiny, uselesspieces）。我们长期遭受时间碎片的迫害，如果要寻求心流，就必须建立时间边界，不论是在工作还是生活中，99%的事情都没有紧急到需要立刻处理，因此需要选择恰当的时间处理那些琐事，例如在午饭前几分钟再去查看邮件，而将宝贵的连续时间段专注于一件真正重要的事（weneed to treat uninterrupted blocks of time as treasures to guard）。</p><p>第三个条件是重要性：明确知道你做的事对别人的影响（knowing that youmake a difference to otherpeople）。Adam举了一个例子：电话筹款员的日常就是给校友打电话请求捐款，乏味单调。后来，让这些员工随机地去会见获得奖学金的学生，实地去感受自己的工作给学生们带来的变化，他们开始全身心投入一个更有意义的目标，收到的捐款几乎翻了3倍。Sothink about the people who woule be worse off if your job didn't exist.Those are the people who make your work matter. You need to know theirnames, their faces and their stories, and you can find flow in projectsthat benefit them.</p><p>Where do you find mastery and mindfulness with the people who matterto you?我想是时候重新思考日常做的每件小事，当你专注于它的时候能否体会到心流的感觉，那会成为照亮你走出虚无的道路（youcan start finding the flow that lights a path out of the void）。</p><h2 id="reference">Reference</h2><p><a href="https://www.zhihu.com/zvideo/1429024000794537984">How tostop languishing and start finding flow - Adam Grant</a><br /><ahref="https://www.ted.com/talks/mihaly_csikszentmihalyi_flow_the_secret_to_happiness">Flow,the secret to happiness</a></p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
            <tag> Psychology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design Twitter</title>
      <link href="/posts/design-twitter/"/>
      <url>/posts/design-twitter/</url>
      
        <content type="html"><![CDATA[<h2 id="background">Background</h2><p>Twitter是一个社交网站，用户可以进行posttweet/timeline/follow等多种操作，国内的类似产品有微博、小红书等。</p><h2 id="clarify-requirements">Clarify Requirements</h2><p>首先需要和面试官讨论系统的requirements，并且确定重点要focus的几个feature。</p><p>requirements通常包括functional req和non-functional req。functionalreq指的是常规功能/业务逻辑，例如create/delete tweet，home/usertimeline，follow user, like/dislike tweet, searchtweet等。non-functional req主要指以下几点：</p><ul><li>Consistency: 每次read都要读到most recentwrite也就是最新的内容。</li><li>Availability:每次request都能够得到non-error的响应，但无需保证读到most recentwrite。关键在于scalability，就是说traffic不断增加时如何保证响应。</li><li>Partition tolerance(Fault tolerance):节点间通信失败时不影响整个系统的工作。</li></ul><p>上面3点其实也就是分布式系统的CAP理论。</p><h2 id="capacity-estimation">Capacity Estimation</h2><p>明确requirements后就需要对系统承载的trafficsize进行讨论和估计。假设Twitter的traffic size如下：</p><ul><li>200 million DAU(Daily Active User), 100 million new tweets</li><li>each user: visit home timeline 5 times, visit user timeline 3times</li><li>each timeline/page has 20 tweets</li><li>each tweet is 280B(140 characters), metadata 30B.</li><li>each image is 200KB, 20% tweets have image</li><li>each video is 2MB, 10% tweets have video, 30% video will bewatched</li></ul><p>首先估算一下Storage，每天写进来的数据主要有：</p><ul><li>text：100M*(280+30)B, 31GB/day</li><li>image: 100M*20%*200KB, 4TB/day</li><li>video: 100M*10%*2MB, 20TB/day</li></ul><p>因此总共的存储大约24TB。</p><p>再来看下bandwidth，用户dailyread的量是200M*(5+3)*20，大概是32B条tweet。所以daily readbandwidth：</p><ul><li>text：32B*(280+30)B/86400, 110MB/s</li><li>image: 32B*20%*200KB/86400, 14GB/s</li><li>video: 32B*10%*30%*2MB/86400, 20GB/s</li></ul><p>所以总带宽大概35GB/s.</p><h2 id="system-apis">System APIs</h2><p>根据之前确定的feature定义API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postTweet(userToken, tweet)</span><br><span class="line">deleteTweet(userToken, tweetId)</span><br><span class="line">likeOrUnlikeTweet(userToken, tweetId, bool like)</span><br><span class="line"><span class="comment">// pageToken指读第几页, 默认最新页</span></span><br><span class="line">readHomeTimeline(userToken, <span class="keyword">int</span> pageSize, opt pageToken)</span><br><span class="line">readUserTimeline(userToken, <span class="keyword">int</span> userId, <span class="keyword">int</span> pageSize, opt pageToken)</span><br></pre></td></tr></table></figure><h2 id="high-level-system-design">High-level System Design</h2><p>可以先从简单的feature开始设计整个系统的数据流向，如从posttweet开始：客户端的请求首先打到LoadBalancer(LB)，然后打到writer服务器，负责将tweet写到DB和cache。</p><p>访问user timeline的feature: 客户端请求过LB后，打到timelineservice服务器，负责读取某个用户A的主页。最直接的方式就是service去DB查询A最近的tweets返回给用户，问题在于这个请求的latency要很低(~200ms)，所以读DB就太慢了。所以加速方案就是把用户最近的tweets写到cache(posttweet时候写就可以)，然后从cache读。</p><p>最复杂的就是访问home timeline,因为涉及到不同用户tweet的merge。客户端请求过LB打到timelineservice服务器后，最直接的方式是service去DB查该用户关注的人(N个)，再查这些人最近的tweets，然后merge起来返回用户。同样的问题：太慢了，要读N次DB。</p><p>所以可以把每个用户的home timeline存到cache，那么用户A发推时，writerservice会从DB找出A的follower，然后更新这些follower在cache里的hometimeline，就是把A发的推插入到每个follower的hometimeline，这就是所谓的fan out onwrite。这样的好处在于用户并不care系统write花的这些时间，只要不影响访问hometimeline的速度就行。一般是通过async task更新每个follower的hometimeline，所以每个follower被更新的延迟不同，就可能导致展示latesttweet时会有delay，不过用户对这个并不敏感，延迟几十秒才能看到最新的tweet并没有什么问题，最终都会看到的，这就是所谓的eventualconsistency。</p><p>那么fan out on write解决了readlatency的问题，带来了什么新问题呢？显然这对于大V很不友好，因为要更新几百万follower的hometimeline还是很有压力的，何况还有很多僵尸粉，你更新了人家也不看。</p><p>因此可以采用一种hybrid solution，对于普通用户发推仍然采用fan out onwrite的方式，大V发推时并不进行fan out on write，而是当关注者刷新hometimeline时再去fetch这些大V的tweets(fan in onread)，然后和普通用户的tweets合并在一起返回给用户。</p><h2 id="data-storage">Data Storage</h2><p>DB首先要有User表，包括userId, name, email, createTime, lastLogin,isHotUser等字段。还要有Tweet表，包括tweetId, userId, createTime,content等。另外，还要有Follower表，包括userId1, userId2。</p><p>像User表这种结构化数据可以用SQL DB，对于timelinecache这种非结构化数据可以用NoSQL，image/video等多媒体文件可以用filesystem来存。</p><h2 id="scalability">Scalability</h2><p>当用户数量越来越多，系统怎么scale up？基本就是做datasharding，LB以及cache。</p><h2 id="reference">Reference</h2><p><a href="https://www.youtube.com/watch?v=PMCdWr6ejpw">How to DesignTwitter</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硕士总结</title>
      <link href="/posts/postgraduate-summary/"/>
      <url>/posts/postgraduate-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">0 前言</h2><p>三年前我写过一篇本科时代和GapYear的总结，讲述了自己高考五年以来的些许往事，回头再看当年的文字，有些仍有意义，有些略显偏颇。如今我的学生时代即将结束，这段日子里又有了一些新的经历和感悟，我也早已不是三年前写<ahref="https://eimadrigal.github.io/posts/thoughts-over-five-years/">痛撞南墙才回头</a>时候的那个我了。今天趁着毕业季的欣喜，接着上篇博客，聊聊我的研究生生涯。</p><h2 id="课业">1 课业</h2><p>开学前的几个月，除了在王道做专业课辅导挣点零花钱之外，因为恰逢暑假，所以每天就和妹妹一起做些好吃的，中午吹空调玩游戏，傍晚出去遛弯，回想起来的确十分惬意。6月底因为疫情的影响，全家人得以团聚且有大把的时光，我们一起爬了趟华山，以后这样的机会也许不会太多了。同时借着空闲时间学习了一些CS公开课，当时做的一些项目也顺理成章地写在了后来秋招的简历上，为我节省了宝贵的时间，使得我有精力进行其他方面的准备。好的公开课多如牛毛，当然不可能面面俱到，因此很感谢胡神等前辈为我们踩坑。</p><p>开学季如约而至，记得9月9号是个小雨天，堂哥送我报道，之后在A区食堂和本科同学吃饭。我非常平静地来到了这个十分荒芜的所谓“创新港”，丝毫没有开学的喜悦，当然也完全没有本科开学时那种生疏感。那天下午便在实验室开了新生见面会，同门们自我介绍的场景依旧历历在目，就这样，我开始了自己的硕士求学路。</p><p>研一刚开始的几个月主要是上课，由于在GapYear里早早认清了国内CS教育的垃圾本质，因此我几乎翘掉了“培养计划”里所有的课程，用这些时间来自学国外的公开课并完成它们的大作业。事实证明我是对的，国内的CS教育仍旧是依托答辩（我甚至在UCB发现了关于LeetCode的课，教学生刷题，帮学生mock，这在国内简直无法想象），花时间上这些课在绝大部分程度上都是对生命的浪费，“上课耽误学习”这句玩笑话依然能够完美适用于当下的教育体系。当然，我并非是想全盘否定所有的课程，比如当时一开始为了找算法岗相关的工作，我选修了数学学院孟德宇老师开设的机器学习课，质量还是非常不错的（但仍然和美帝的类似课程有着巨大差距）。</p><p>在应付课程以及考试的同时，我开始刷题、改简历，准备找实习和秋招，也积极参加了入党相关的活动，考了教师资格证，因为当时并不太确定未来是去做程序员还是高中老师，而这些事情也是在入学前就早早计划好的。另外还重考了一次六级，想着刷刷分，早忘记了六级考试是一边听一边涂卡，结果听力基本交了白卷（最后的成绩竟然和大一差不多，真不知道当时在干嘛），后来觉得六级成绩并没有什么用，就没有继续报名。</p><h2 id="科研">2 科研</h2><p>经过3个月的适应期，实验室进行了科研选题。当时的课题主要分为生信、统计和机器学习，我的导师主要做生信相关，但我对这个方向完全没有兴趣（高中生物都没有学明白），看来又选错了导师，研零5月份咨询师姐时明明说的是算法相关，只怪我没有认真去看他的publications，而是只关注了放实习这件事，其实当时是有机会去张鹏组做网络和系统的，但是我执拗地希望做机器学习相关的内容，到头来才发现算法并非自己想象的那样。</p><p>因此，我凭借着当时所谓的兴趣选择了另一位老师的机器学习课题，主要有不均衡多标签、大数据分类算法推荐和高维数据特征选择3个选题，可以发现这些课题非常零散杂乱，完全看不出科研的重心和擅长的方向，我稀里糊涂地选择了算法推荐。开始时我还雄心勃勃，想要做出一些成果，当时导师还说实验室已经和MSRA、字节、腾讯等公司都建立了合作关系，可以派人过去实习。我心想如果能去MSRA实习就好了，后来的事实证明这些都只是水月镜花而已。</p><p>选好课题以后，只能自己找论文试图寻找已有方法的“缺陷”，老师基本上没有任何有效的指导，组里也几乎没有相关领域的师兄师姐传帮带，大家都在蒙着眼睛摸石头过河。起初一窍不通，就去死磕顶会论文；基础知识不牢靠，就学习公开课。因为当时还是一心想去算法岗，所以花了大把大把的时间去学习CS229和CS231n等课程。后来的课题几经辗转，终于在研一下学期的4月份得以确定，这里也非常感谢张敬奇学长给予我的帮助。我想，这下终于可以好好科研了吧。</p><p>在研二上学期的9月底，我完成了第一篇论文并投稿至PatternRecognition，那个工作非常垃圾，我自己都觉得做这些垃圾课题是对科研的侮辱，但也许正是这些垃圾课题养活了无数所谓的researchers。即便如此，小导师还是执意要投PR，在这几个月和她的科研交流中，我逐渐发现自己想要在这个实验室靠着发顶会paper找份好工作已经不现实了，于是我迅速将目标转向开发岗，并在随后的日子里以极其敷衍了事的态度对待“科研”，将大部分时间和精力用于求职准备，只想着出去实习并且找份好工作。</p><p>现在去看自己在这段时间里的所谓科研，可以说是完全失败的，读研三年被拒稿三次，造成科研之路如此崎岖坎坷的原因是复杂的。首先，十分大意地选错了实验室和导师，大概就是只重视战略而没有重视战术，当时想清楚了自己想做的方向，却没有从publications等多方消息验证师姐的话是否属实（这些错误真的太低级），导致3年科研一事无成，我对这个实验室的总结就是：整最花的活，挨最毒的打。其次，课题的严重滞后和无效的指导导致科研兴趣完全丧失，因为每天都是在炒一些传统机器学习方向的冷饭，就像学着用不同语言把HelloWorld输出到黑框框一样，令人倍感无聊和厌倦。最后，从我个人的性格来看，我喜欢有快速反馈的工作，不想长期泡在一个事情上，也不喜欢探索，只喜欢把已有东西用好，不像有些人做科研眼睛里会放光。因此，也许我确实没有这方面的潜质，也就没有继续读博的必要了。可能这3年在科研上最大的发现就是完全确定自己并不适合读博，Anyway，要告别科研了。</p><p>在接下来的小半年里，我把几乎所有的时间都用来找实习，当然这些准备和科研是完全冲突的，自然也导致了小导师的不满，她多次找到大老板告状，但我仍然是当一天和尚撞一天钟，不愿再在科研上投入过多。<strong>我们的利益诉求在有些时候、某些事情上和老师们、学院、学校是一致的，但是在大多数情况下都是冲突的，这是个人与学校、学院、实验室以及导师之间的博弈，比如硕士生的目标是在保证顺利毕业的前提下找到更好的工作，但老师们只是希望你好好科研，多发文章，为实验室争光。在发生这种利益冲突时，又有什么理由不以自己为重呢？</strong>后来的事实证明我是对的，尽管现在说起来风轻云淡，但在这个过程中的滋味却并不总是甜蜜的：</p><blockquote><p>不要抱怨环境和老师，他们确实很差，但是这是自己无法改变的，抱怨只是在浪费时间，最好的解决办法就是停止抱怨，和他们的相处让自己利益最大化，提高自己的姿势水平。20220203</p></blockquote><p>最后，在秋招大致结束后（即使在找工作最忙的时候，小导师也要坚持组会），我才开始重新将重心放到毕业的事情上。充实了小论文的方法和实验，并在11月中旬重新投稿，但是一直等到盲审前夕才给了大修（4.24就要提交盲审，小论文4.2才出大修，时间根本来不及），搞得最后十分狼狈（4.6与老师沟通，4.12完成revision和responseletter，4.20晚上提交小论文，4.24提交大论文盲审，前天才接收）。回想起来，第一次投稿时就应该认真写一下小论文，给自己预留足够的容错空间，否则就不得不花费非常多的时间去弥补之前欠的账，导致步步赶不上趟。不得不感慨：专注也是一种能力，尤其是在面对自己并不感冒的事情上。另外，不论是生活还是工作，保持自己的节奏很重要，该忙就忙，该闲就闲。</p><p>幸运的是，大论文顺利通过了双盲评审，整篇论文她只看了5分钟左右，而我整整倾注了5个月的心血，最后十几天看到论文都反胃。更加神奇的是，起初我的对比算法只有2个，实验部分也非常不完备，但小导师竟然完全没有指出这些问题，我自己后来主动补充了相应的内容，实在无法想象初版的论文送去盲审会是什么结果，现在回想起来仍然有些后怕。所以我有时候觉得：<strong>硕士其实是学生时代和社畜的分水岭，很多事情需要靠自己的主观能动性，而非靠学校或者老师的push。</strong></p><h2 id="工作">3 工作</h2><p>在将重心转到开发岗之后，我在研二上学期完成了CS144的project，并且将其作为简历上的最后一个项目，至此，我的项目经历基本定型。之后又做了一些八股、算法题等方面的准备，时间便很快来到了暑期实习的档口。找实习的过程十分艰难，糟糕的大环境下不知道该去大厂、外企、事业单位还是高中教师，对于未来有着无限的焦虑，看似有无数可能但却不知该迈向哪里。那段时间彷徨挣扎导致经常失眠，看了很多缓解焦虑的资料（向帅臣学习，保持好心情和乐观很重要）：</p><p align="center"></p><center class="half"><img src="3.jpg" height="30%" width="30%"/></center><p>这种状况直到4月上旬拿到实习offer才有所缓解。回过头去看当时的浑浑噩噩，一方面是身体极度缺乏运动导致十分疲惫，另外就是缺乏长期目标的激励。实习的日子起初也并不好过，人生彷佛会让人处于永恒的痛苦之中。因为疫情的原因5月份迟迟没法入职，到北京的第二天上届的盲审就出了结果，50%延毕...在出租屋里也没法静心准备秋招，接着，就又是一阵焦虑：</p><blockquote><p>不论什么事，焦虑、担忧甚至想象都没用，只会让人更痛苦。唯二能做的就是:乐观 + do it<br />我的算法、项目、八股水平已经很不错了，因此完全没必要焦虑，做好复习即可。20220524</p></blockquote><p>终于在6月初得以入职，实习期间遇到了非常nice的mentor和同事，前辈们在我入职时亲历亲为教会我很多，两位mentor带给我诸多成长。百度的人走人留让我见识了职场的残酷，这家公司的没落与颓败也随处可见：最低配的MacBook，1080P的显示器能把眼睛闪瞎，正版Navicat都没有，看个数据库能给人累死...但这些还并不是最令人糟心的事情，刚开始实习不久便收到了小论文又双叒叕被拒的消息，实习之初的适应期也非常痛苦，再加上因为疫情拖了大半个月才得以入职以及上届盲审出事，我一度打算提前离职回校，看来不论做什么事情都一定要预期到最坏的结果。关于实习期间具体的经历可以看<ahref="https://eimadrigal.github.io/posts/internship-summary/">这里</a>。</p><p>实习结束后就马不停蹄地开始了秋招，虽然很早之前就看过<ahref="https://conanhujinming.github.io/post/tips_for_interview">胡神的面经</a>，但实在太过残暴和血腥，不是我这个菜狗能做到的，只能尽力效仿，进一步算一步，丝毫不敢懈怠，面经里给我印象最深的一句话就是：</p><blockquote><p>Nothing replaces hard work.</p></blockquote><p>在我秋招结束之后，也写过一篇blog整理自己的经历，不过当时并没有时间和心思详细聊一下其中的一些体会，所以在大论文送完盲审的当天就火速填坑，关于我自己找实习和秋招具体的流水账和一些体会都在<ahref="https://eimadrigal.github.io/posts/interview-summary/">这里</a>。</p><p>秋招过程中见到了太多毁offer、卡转正、缩HC的情况，遇到了很多令人略显无语的公司（中兴问我一共写过多少行代码...），也有很多让人倍感尊重的企业和面试官（大摩的面试官竟然认真看了我的简历并浏览了我的github，出乎我的意料，面试过程中也可以Google记不太清楚的API）。我现在觉得企业文化的match程度也是选择offer的重要因素之一，有些公司的企业文化完全是畸形的，整天和打仗一样，但是产品却做的稀烂，迟早💊。</p><p>关于offer的选择，借用陈硕大佬的<ahref="https://www.zhihu.com/question/22101615">一句回答</a>：no betterchoice。找工作大概可以给自己打70分，考虑到去年的就业环境（室友说23届就是牺牲品，被前后倒挂😂），可以给到80分。有些事情的结果和我的预期还是有些偏差，长者说得很对：<strong>一个人的命运，当然要靠自我奋斗，但是也要考虑历史的进程。</strong>刚拿到offer我很激动，觉得非常了不起，但是冷静下来之后发现并没有什么用，一份工作而已。选择每家公司都会有得有失，国内这些公司非常不规范，外企也并没有传说中那么光鲜亮丽，本质上都是一丘之貉，不过手段略有不同而已，资本家都是很坏的(:😀。这世上并没有完美的工作，我只是在钱和空余时间之间做了一个权衡，成为资本的附庸而已，因此也要早做打算，时刻准备着跑路。</p><p>面试是有运气成分的，人生也处处充满了运气和各种奇葩事。收到的顺丰本应是纸质合同，打开以后却发现是一条抖音电商的黑科技养生裤...签字以后打算寄回，结果因为疫情导致封校、快递停运，合同无法寄出，只能请假出校，跑了好远找了两个快递点才得以寄出。<strong>人类的运气如果呈现正态分布，那么我一定处于左侧的<spanclass="math inline">\(3\sigma\)</span>点之外。所幸整个过程虽然历经无数曲折，但我发现：我的路虽然崎岖坎坷，最终的结局却都是颇为完美的。相比于一帆风顺的人，这并非是什么值得骄傲和炫耀的事情，我不知道这是否是所谓的“命数”，但我确定的是：这其中离不开自己艰辛甚乎于绝望的挣扎，希望未来也能保持这份“运气”。</strong></p><p align="center"></p><center class="half"><img src="4.jpg" height="25%" width="25%"/></center><h2 id="感悟">4 感悟</h2><p>这三年里经历的很多事都会重新引发我的思考，但遗憾的是，<strong>在某个时间段点醒你的人基本上是可遇不可求的（比如后来当我再看Tal心理学视频的时候，再也无法找到当初那种震撼的感觉），可能是身边的朋友，也可能是网友，还可能是在另外一个角落里的陌生人，但是这一切的前提都来自于你的好奇心、你的思考。</strong>我想从学校、社会和自身3个方面谈谈这段时间的一些感悟，可能会有很多偏激的言辞，万望包容。</p><h3 id="学校">学校</h3><p>必须要承认的是：这三年里我有着非常多的戾气，这个瞧不上、那个看不起，尤其对于这所学校，我基本上是持全盘否定的态度。以我在XJTU的经历和目前的认知来看，这所学校落后、自大且不自知，几乎不会在意学生的切身利益和感受：</p><ol type="1"><li>很多老师和部分学生都有着一股迷之自信，觉得西交的学生去哪就业那都是公司求之不得的，所以辅导员（我亲耳听到某周姓辅导员和某公司HR的电话沟通）和就业中心总是一副高高在上的嘴脸，殊不知这些基本上都是垃圾公司。不过也正常，他们的视野就这么狭窄，外面的世界是什么样子他们自己也不知道。就业办的老师也压根不会在乎你去哪上班，对于ta们而言学生就业只是用来混日子的工具而已。之前看到一个米哈游的学长<ahref="https://maimai.cn/web/feed_detail?efid=vjXpRjJ2K-zDPbhMbbLVFw&amp;fid=1777117849&amp;id=1777117849&amp;operation_id=eb492717-0477-4767-aa79-a2cf484d1ea6&amp;share_channel=2&amp;share_uid=227029623&amp;use_rn=1">吐槽</a>，线下的宣讲之所以没有来西交，原来是就业办的老师处处使绊子，导致人家直接放弃。这帮傻X真把自己当盘菜了，看看西交有几个能拿米哈游offer的吧...</li></ol><p align="center"></p><center class="half"><img src="1.jpg" height="50%" width="50%"/></center><ol start="2" type="1"><li><p>教学水平、就业质量、行政管理、科研质量一塌糊涂，每天就在陕西这一亩三分地里自嗨，靠一些自娱自乐的奖项忽悠领导的同时满足一下可怜的虚荣心，维持一下所谓老牌大学的颜面。事实上，XJTU的很多东西早已和时代脱节，包括但不限于一些简历辅导、找工作的宣传指引等活动，就业办的老师可能自己都没有找过工作，又怎么能奢求ta们指导学生找工作呢？</p></li><li><p>沉迷于对实验班的幻想，举大部分财力、物力和资源支持实验班的发展，挤压普通学生的成长空间，使得普通同学无法接触本应属于ta们的教育资源，甚至会害惨大家的一生。不禁让我想起了高中，把年级前几名送去衡水培养一两年然后直接高考...西交可以直接把实验班的同学送去四大交换四年，然后宣称自己培养出了顶尖科学家，那不是更加美滋滋...<strong>非常不幸的是，大部分同学都会被环境蚕食，视野和格局受限，导致最后本应去更好的地方，却无力回天。我始终相信，认识什么样的人，才可能会有怎样的视野，而视野会决定思考的宽度，进而影响重要节点的选择。而大多数同学受限的视野则会导致整体氛围感的缺失，最终的恶果会进而传导回每个人。</strong>我自己最切身的体会就是找工作时有些孤独，很多方向比如外企等都是自已一个人准备、琢磨，没有人传带，也没有人共享。</p></li><li><p>其他的一些看似小事（其实并不是）也无处不在显露着这所学校的颓废和腐朽。大部分导师给研究生的补助都是最低标准每月200，学校每月给500生活费，这点钱恐怕连吃饱饭都费劲，哪里还有心思科研呢。我在浏览其他学校的信息时，发现几乎其他所有高校的官网以及计算机学院的网站都已经迁到了HTTPS，只有XJTU的绝大部分网站仍然是HTTP，还大言不惭地宣传自己的信息化建设多么多么先进...一个毕业论文模板，latex和word竟然有非常多不一致和自相矛盾的地方，我是真的想不到这么重要而又简单的事情也会有这么多扯皮和问题...（越来越烂是必然的，只想早点离开这个傻逼地方）</p></li></ol><p>不想无脑喷这所学校和这个学院，但我相信，只要稍微睁开眼睛看看，就能发现西交在很多方面的表现有多差（于我而言唯一比较感恩的就是单人宿舍了，比本科时睡得好了），这所学校积重难返，建议趁早关门倒闭，纯纯浪费学生生命，误人子弟，我希望能加速踩油门，早点完蛋。<strong>但是学生是无辜的，我们绝不该为这些错误买单或付出代价，如果有学弟学妹看到这篇blog，真的希望大家早点跳出这个学校的圈子，抱着一种开放包容、谦虚学习的态度（夜郎自大要不得），tosee biggerworld，多与外面的人接触沟通，看看同龄人都在想什么、做什么，再去思考自己要做什么，永远不要被单一价值观所禁锢，在局部世界里内卷，长期内卷会让人麻木、思想僵滞，进而很容易导致忽视bigpicture或者一些基本问题。</strong>正如BYVoid在<ahref="https://byvoid.com/zhs/blog/recent-one-year/">这一年来</a>中所说：</p><blockquote><p>其实我们大多数人并不缺乏能力，而是囿于见识，只敢走前人铺好的道路。一方面这是承担风险与规避风险的问题，另一方面这是多数人缺乏广阔的视野。许多人并非不是雄心勃勃，我相信愿意背井离乡去美国留学、工作、移民的人肯定不是胆小如鼠，只求稳妥的人，而是许多人只看到了自己前辈走过的道路，没有另辟蹊径的意识。</p><p>追求更大的成就、更好的生活绝对不是错，错在大家都在挤几个独木桥。对于清华计算机系的学生来说，大家心中认可的无非就这两条「出路」：成绩好的出国读研，稍次的本校保研，至于挤不上这两个独木桥的，只能「被迫去工作」或者走其他「歪门邪道」。为什么大家都要一窝蜂地去读研，很多人并没有想过，许多选择保研的人的理由都是：不太清楚自己能干什么，先读研再说。因为无数前辈证明了读研是一条稳妥的道路，所以大家都亦步亦趋地步着前辈的后尘。为什么大家没有看到别的路可走呢？譬如投身产业界，譬如创业或加入创业，甚至譬如直接去国外工作，从事自由职业，或者花一年去世界各地流浪？有人说，不够稳妥，太不现实了，不能满足父母寄予的期望。终极的原因还是在于，你根本没想到可以这么做，没有认真考虑过自己真正愿意做的是什么。</p><p>我想告诉看到这篇文章的我的同辈朋友，以及学弟学妹们，世界竟然如此宽广，你需要有一颗宽广的心去容纳。人在年轻的时候机会成本是最低的，所有你因为顾虑不敢做的事，将来只会顾虑更多。</p></blockquote><p>学校的管理的确非常拉跨，但title（XJTU本还行，硕基本凉了一大半了。来西交读本科，失败了50%；留在西交读研，失败了99%）基本能让我们的简历在大多数公司不至于被表刷（幻方那些高端的只要清北复交浙），但真正的好公司是不会来西交宣讲的，需要自己主动出击。另外，带给我最大感受的就是各行各业都有非常多厉害的校友，<strong>一些很厉害的前辈在我们成长中的重要性是毋庸置疑的，我们也许远不如前辈们出众，但站在他们的肩膀上，能看的更远。</strong>现在本科生和研究生的视野、水平早已远超我们当年，如果能利用好这些校友资源，也许会有不错的发展。</p><p>最后，祝XJTU好运。</p><h3 id="社会">社会</h3><p>以我目前十分浅显的看法，社会是复杂的（容不得那么多矫情），人也都是复杂的（还是要就事论事），但是事情还不至于那么糟糕。</p><p>在3月份的时候，我有幸接触到了一些前辈，察其言观其行，感慨自己不只是在技术上，在人脉、见识、social能力等软实力方面我都差的太多（工科的同学普遍不善于表达自己，包括我自己。大部分人的想法都是先把技术搞到非常厉害，再去谈其他的，但技术有时候并不是最关键的因素，视野、信息等也非常重要，而且这些软技能也是可以同时锻炼的），顿时感觉压力倍增，不过这也正常，<strong>看到更大世界的同时也就意味着会带来痛苦和受挫感。</strong>交流过程中我也被有意无意地judge，心里不太舒服，起初我非常天真地从自身找问题，想看看自己是否真的如ta们所评价的那样。</p><p>不过后来我很快就想通了，<strong>任何人对其他人的评价，不论有意还是无意，都是建立在自身的评价体系之上的（经验有时候是好事，有时候并不是），这种体系大概率都是带有偏好的，甚至是单一的，</strong>比如在老师们的评价体系下，科研做得好就证明这个学生厉害，显然这并不公正。同样地，<strong>ta们是某种体系下的优胜者，不见得在另一种体系下也能取得成功，更遑论有些人总是有着一种游离于大众之外的优越感。因此，不论是多么厉害、多么德高望重的前辈或师长，都有着自身的局限，当然ta们也没有资格随便judge或者贬低别人的长相、性格、所作所为（如果遇到了，就当ta们在放屁，应该适当回怼），</strong>尽管ta们也许只是在开玩笑，有的老师和前辈也完全没有必要当成师长去尊重，而是要当成社会人去缠斗。<strong>我还是相信每个人都有自己独特的闪光点，当然每个人也包括自己还有很多不足，应当继续努力。</strong></p><p>除了个别不太友好的交流外，大部分大佬、前辈、同龄人都是非常nice的。我之前在YouTube看了<ahref="https://www.youtube.com/@arisaif/videos">Arash大佬的C++视频</a>，就抱着试一试的心态在LinkedIn上Connect，没想到他很快就同意了；还有研一的时候看OSTEP，有个地方想不明白，就试着给<ahref="https://pages.cs.wisc.edu/~remzi/">Remzi</a>发了邮件，没想到当天就得到了回复，不仅回答了我的问题，还让我不要太担心😂：</p><blockquote><p>don't worry, it's not some big insight you're missing.<br />keep studying and learning, you'll be fine!<br />good luck</p></blockquote><p>这些大佬们是真正的谦逊和平易近人，会给人无数鼓舞。许多同龄人也同样让人惊叹，无论是科研还是工程，有人天赋异禀，有人滴水穿石，普通如我只能试图汲取ta们的养料，也在自己的路上被一直鼓励着。</p><p>最后，无论遇到多么扯淡的事，可以吐槽，但不要长时间的抱怨，抱怨解决不了任何问题，积极面对就好了，gocoping！</p><h3 id="自身">自身</h3><p>关于自己，话语万千。</p><p>毫不讳言，三年前的那篇博客，当时其实在很大程度上还是想给自己一个重新证明自己的机会（本科过于放纵了），甚至现在也有这方面的影响，但是没有之前那样的偏执，<strong>现在只想简单地存在和生活，当然这并不意味着不会焦虑、悲伤，而是尽可能平静地看待喜乐与痛楚，尽可能纯真地享受每一天的酸甜苦辣，每活一天都是生命的馈赠。</strong>因此，现在的我并不是特别关注所谓的宏大叙事，也不像五六年前那样沉迷于观察岁月的痕迹，此刻我只想过好自己的小日子。如龙应台所言：</p><blockquote><p>我不在乎大国崛起，我只在乎小民尊严。</p></blockquote><p>初识此话，觉得没有格局，满脸鄙夷。后来知道的越多，才越觉得有道理，当然这是建立在生存基础得以保障的前提之下。我觉得国内一个很大的问题就是太过于强调集体主义，却忽视了每个个体自身的利益和发展，而且往往通过宏观层面的政策强制牺牲个人利益，那么最终集体发展取得的成果又是为了什么呢？</p><p>将精力倾注于自己的成长，我就越来越不在意其他人遇到的事情、害怕别人的看法和说辞，而只在乎自己最亲近的人（分清楚这世上每个人值得自己怎样的付出20220820）。同时，可以更加大方地展示真实的自己，不再遮遮掩掩，变得更加有勇气，与刚入大学校门的那个生涩稚嫩的我也渐行渐远。</p><p>三年里，一直意识到自己还差的很远，始终向着自己认为正确的方向不懈努力（当然努力这个词的作用总是被高估，但除了它我别无选择），没有浪费光阴，没有走多数同学寻常的道路（拼考试成绩、奖学金、论文专利、社团），沿着自己的路，做着自己认为正确的事。<strong>尽管走了一些弯路，然而现在回首，一切都无比清晰。平时出于兴趣或是其他因素所积累的点滴，看似作用不大，在当时也看不出什么脉络，但在将来某一时刻一拥而上的时候，一切都是那么自然，</strong>正如乔布斯<ahref="https://eimadrigal.github.io/posts/jobs-speech-stanford/">演讲</a>时所说：</p><blockquote><p>Of course, it was impossible to connect the dots looking forward whenI was in college, but it was very, very clear looking backwards 10 yearslater.</p></blockquote><p>所以将时间线拉长以后可以发现，<strong>有人比你聪明，有人比你刻苦，这并不要紧，重要的是发现自己擅长和热爱的事，并敢于在恰当的时候质疑和打破规则，我们太多人都习惯于拼尽全力遵守规则，却从未尝试思考规则的合理性，</strong>就像陈怡然老师所说：</p><p align="center"></p><center class="half"><img src="2.jpg" height="50%" width="50%"/></center><p>三年里，我亦有过各种各样的担忧：担心组会、担心盲审、担心面试，也曾担心自己因为Gap一年耽误一些东西。回看自己的经验，的确，人类90%的担心和焦虑都是多余的，有些事情看的越重，ta就伤你越深，<strong>一直在担心一件结果未知的事情完全是毫无意义的内耗，以前这么担心，现在还是如此，那么在这件事上你的进步又在哪里呢？这种内耗会白白消耗精力、浪费人生时光，</strong>我也对“尽人事，听天命”这句话有了更深的理解，诸葛亮在五丈原是如此，我自己的求学生涯又何尝不是如此，甚至工作、人生等等又何尝不是呢？老话说得好：生死有命，富贵在天，不要去想改变不了的事。想来人生也是奇妙：我们总是在曲折中成长，明白适用于自身的道理并身体力行，然而年龄却在这些曲折岁月中逐渐增长，也许在离开之前会达到心智的最高峰，但却是身体的最低谷，不得不说是一种遗憾！</p><p>三年里，每逢重大决定，我在做选择时都更多地遵从内心的感受，并且愈发相信自己的选择，执着于自己想做的事，哪怕有一天一无所有，就像乔布斯所说：</p><blockquote><p>Your time is limited, so don't waste it living someone else's life.Don't be trapped by dogma, which is living with the results of otherpeople's thinking. Don't let the noise of others' opinions drown outyour own inner voice. And most important, have the courage to followyour heart and intuition. They somehow already know what you truly wantto become. Everything else is secondary.</p></blockquote><p>这样便可以全心投入，也许能够取得些许成就，而取得一些突破会极大地增强自信心和自尊心，进而更加坚定自己的选择，形成良性循环。然而，取得一些成绩也会让人不再那么谦逊，因为可能会看到周围的人比自己差很多，瞧不上他们，这也是Tal讲的关于自尊的矛盾（具体细节和解决方案可以看<ahref="https://www.bilibili.com/video/BV1Ka411w7qd/?p=22">这里</a>）：</p><blockquote><p>Part of the problem is that there is contradictory evidence. On theone hand, self-esteem is associated with benevolence and generosity andempathy. On the other hand, high self-esteem has been shown to beassociated with hostility, lack of cooperation, defensiveness.</p></blockquote><p>最后，是关于自己一个挺有趣的发现。很多事情第一次接触时并不感冒，甚至有些厌恶，但是过一段时间后再次接触，才发现饶有兴趣。大一接触编程时学得反胃，现在觉得还不错；包括金融学也是，本科辅修时觉得大部分课程很无聊，现在要入职了重新学习觉得挺有意思。果然时间才是最好的良药啊！</p><h2 id="未来">5 未来</h2><p>在研三最后的日子里，我时常会想：未来的我会变成什么样子？未来的世界又会变成什么样子？或者拉近一点，十年后的我和世界会是什么样子？Noidea...彷徨无助时，我想到了乔布斯在Stanford的<ahref="https://eimadrigal.github.io/posts/jobs-speech-stanford/">演讲</a>，想到了胡神初入职场时的<ahref="https://conanhujinming.github.io/post/thoughts_of_hunting_jobs/">纠结</a>。</p><blockquote><p>最近时常感到空虚，人生没有意义，也经常担心上海的高消费、高房价自己未来能否承受，是否选择offer时又被虚荣蒙蔽了双眼，未来又该何去何从。20230417</p></blockquote><p>选工作地点时会有一些来自家人、朋友等等的阻力，陕西人好像都有浓重的留乡思绪，也包括我自己，但是我相信自己选的路和看重的东西：年轻时的视野、格局、人脉。以前囿于各种因素，一直待在小圈子里，我想逐渐找补回来。</p><p>现在也慢慢地有了感觉：<strong>日子就是问题叠着问题，越长大无力感越重，</strong>或许受到阅历、金钱上的掣肘和瞻前顾后会少一些，但仍然会有各式各样的其他窘迫，会被家庭、工作、人际关系等各种琐事缠身，实在不会有太多时间拿来挥霍（不止学习和工作，很多事情都是需要花时间经营的）。既然时间非常有限，那么只能用来做最有价值、最重要的事情，不要看到什么都想学，最后一无所获（如果打算刷题，那么刷哪些题最重要呢？）。借用MorganStanley的一句价值观：DO THE RIGHTTHING，而且还要高效地做正确的事。对我而言，现阶段以及下一阶段mostvaluable的事情又是什么呢？也许是为开源社区做一些贡献，也许是做一些教学相关的活动...我的人生或许是为了留下一些memory，在经常性的浑浑噩噩中闪现一丝丝过往的灵光？不论怎样，现在和将来都希望自己能认真审视自己的价值，做一些感兴趣的有益的事，就像Tal所说：</p><blockquote><p>Help each other makes you happier.</p></blockquote><p>即将开启新的航路，我想会有形状各异的风浪，但唯一确定的是：又是一段不同的旅程，ittastes different！</p><h2 id="tips">6 TIPS</h2><ol type="1"><li>我觉得有时候简单一点，选自己喜欢的、想要做的，可能就是最好的选择。</li><li>对自己的水平要有客观正确的认识，每天的所有事都要有大致的计划，不能盲目和拖延。</li><li>很乱无从下手时，想想怎么分解任务（就像写毕设一样，分解到每张图、每张表），把任务拆成很小的小块，在半天或者一天内就能完成，这样可以及时获得正反馈，持续获得成就感，利于后续学习。这一点对我非常重要，也很有效。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Live Before You Die</title>
      <link href="/posts/how-to-live-before-you-die/"/>
      <url>/posts/how-to-live-before-you-die/</url>
      
        <content type="html"><![CDATA[<p>这是Steve Jobs在2005年Stanford毕业典礼上的<ahref="https://www.npr.org/2011/10/06/141122856/steve-jobs-speech-at-stanford-university">演讲</a>，其中很多内容深情流露、发人深省，特摘录于此，<ahref="https://www.bilibili.com/video/BV1oW411h7Ea">视频在这里</a>。当然这并不意味着我认可他所有的做法，或者想成为他那样的人（我也没那个能力哈哈）。</p><p>以下是全文：</p><p>Thank you. I'm honored to be with you today for your commencementfrom one of the finest universities in the world.</p><p>Truth to be told, I never graduated from college, and this is thecloest I've ever gotten to a college graduation.</p><p>Today, I want to tell you three stories from my life. That's it. Nobig deal. Just three stories. The first story is about connecting thedots. I dropped out of Reed College after the first 6 months, but thenstayed around as a drop-in for another 18 months or so before I reallyquit. So why did I drop out? It started before I was born. My biologicalmother was a young, unwed graduate student, and she decided to put me upfor adoption. She felt very strongly that I should be adopted by collegegraduates, so everything was all set for me to be adopted at birth by alawyer and his wife.</p><p>Except that when I popped out, they decided at the last minute thatthey really wanted a girl. So my parents, who were on a waiting list,got a call in the middle of the night asking: We've got an unexpectedbaby boy. Do you want him? They said: Of course. My biological motherfound out later that my mother had never graduated from college and thatmy father had never graduated from high school. She refused to sign thefinal adoption papers. She only relented a few months later when myparents promised that I would go to college. This was the start in mylife.</p><p>And 17 years later, I did go to college. But I naively chose acollege that was almost as expensive as Stanford, and all of myworking-class parents' savings were being spent on my college tuition.<strong>After 6 months, I couldn't see the value in it. I had no ideawhat I wanted to do with my life and no idea how college was going tohelp me figure it out.</strong> And here I was spending all of the moneymy parents had saved their entire life. <strong>So I decided to drop outand trust that it would all work out OK. It was pretty scary at thetime, but looking back, it was one of the best decisions I evermade.</strong></p><p>The minute I dropped out, I could stop taking the required classesthat didn't interest me and begin dropping in on the ones that lookedfar more interesting. <strong>It wasn't all romantic. I didn't have adorm room, so I slept on the floor in friends' rooms. I returned Cokebottles for the five-cent deposits to buy food with, and I would walkthe 7 miles across town every Sunday night to get one good meal a weekat the Hare Krishna temple. I loved it. And much of what I stumbled intoby following my curiosity and intuition turned out to be priceless lateron.</strong></p><p>Let me give you one example. Reed College, at that time, offeredperhaps the best calligraphy instruction in the country. Throughout thecampus, every poster, every label on every drawer was beautifullyhand-calligraphed. Because I had dropped out and didn't have to take thenormal classes, I decided to take a calligraphy class to learn how to dothis. I learned about serif and san serif typefaces, about varying theamount of space between different letter combinations, about what makesgreat typography great.</p><p>It was beautiful, historical, artistically subtle in a way thatscience can't capture, and I found it fascinating. <strong>None of thishad even a hope of any practical application in my life. But ten yearslater, when we were designing the first Macintosh computer, it all cameback to me. And we designed it all into the Mac.</strong> It was thefirst computer with beautiful typography. If I had never dropped in onthat single course in college, the Mac would have never had multipletypefaces or proportionally spaced fonts. And since Windows just copiedthe Mac, it's likely that no personal computer would have them.</p><p>If I had never dropped out, I would have never dropped in on thatcalligraphy class, and personal computers might not have the wonderfultypography that they do. <strong>Of course, it was impossible to connectthe dots looking forward when I was in college, but it was very, veryclear looking backwards 10 years later.</strong></p><p><strong>Again, you can't connect the dots looking forward. You canonly connect them looking backwards. So you have to trust that the dotswill somehow connect in your future. You have to trust in something,your gut, destiny, life, karma, whatever, because believing that thedots will connect down the road will give you the confidence to followyour heart even when it leads you off the well-worn path and that willmake all the difference.</strong></p><p>My second story is about love and loss. I was lucky，I found what Iloved to do early in life. Woz and I started Apple in my parents' garagewhen I was 20. We worked hard, and in 10 years Apple had grown from justthe two of us in a garage into a 2 billion dollar company with over 4000employees. We'd just released our finest creation, the Macintosh, a yearearlier, and I just turned 30, and then I got fired. How can you getfired from a company you started? Well, as Apple grew, we hired someonewho I thought was very talented, to run the company with me. And for thefirst year or so, things went well. But then our visions of the futurebegan to diverge and eventually we had a falling out. When we did, ourboard of directors sided with him. And so at 30, I was out - and verypublicly out. What had been the focus of my entire adult life was gone,and it was devastating.</p><p>I really didn't know what to do for a few months. I felt that I hadlet the previous generation of entrepreneurs down, that I had droppedthe baton as it was being passed to me. I met with David Packard and BobNoyce and tried to apologize for screwing up so badly. I was a verypublic failure, and I even thought about running away from the Valley.But something slowly began to dawn on me, I still loved what I did. Theturn of events at Apple had not changed that one bit. I had beenrejected, but I was still in love, and so I decided to start over.<strong>I didn't see it then, but it turned out that getting fired fromApple was the best thing that could have ever happened to me. Theheaviness of being successful was replaced by the lightness of being abeginner again, less sure about everything. It freed me to enter one ofthe most creative periods of my life.</strong></p><p>During the next 5 years, I started a company named NeXT, anothercompany named Pixar, and fell in love with an amazing woman who wouldbecome my wife. Pixar went on to create the world's first computeranimated feature film, "Toy Story", and is now the most successfulanimation studio in the world.</p><p>In a remarkable turn of events, Apple bought NeXT, and I returned toApple, and the technology we developed at NeXT is at the heart ofApple's current renaissance. And Laurene and I have a wonderful familytogether. I'm pretty sure none of this would have happened if I hadn'tbeen fired from Apple. <strong>It was awful-tasting medicine, but Iguess the patient needed it.</strong></p><p>Sometime life - <strong>sometimes life is going to hit you in thehead with a brick, don't lose faith. I'm convinced that the only thingthat kept me going was that I loved what I did. You've got to find whatyou love, and that is as true for work as it is for your lovers. Yourwork is going to fill a large part of your life, and the only way to betruly satisfied is to do what you believe is great work, and the onlyway to do great work is to love what you do. If you haven't found ityet, keep looking and don't settle. As with all matters of the heart,you'll know when you find it. And like any great relationship, it justgets better and better as the years roll on, so keep looking - don'tsettle.</strong></p><p>My third story is about death. When I was 17, I read a quote thatwent something like: <strong>If you live each day as if it was yourlast, someday you'll most certainly be right.</strong></p><p>It made an impression on me. And since then, for the past 33 years, Ihave looked in the mirror every morning and asked myself, If today werethe last day of my life, would I want to do what I am about to do today?And whenever the answer has been no for too many days in a row, I know Ineed to change something. <strong>Remembering that I'll be dead soon isthe most important tool I've ever encountered to help me make the bigchoices in life. Because almost everything, all external expectations,all pride, all fear of embarrassment of failure, these things just fallaway in the face of death, leaving only what is truly important.Remembering that you are going to die is the best way I know to avoidthe trap of thinking you have something to lose. You are already naked.There is no reason not to follow your heart.</strong></p><p>About a year ago, I was diagnosed with cancer. I had a scan at 7:30in the morning, and it clearly showed a tumor on my pancreas. I didn'teven know what a pancreas was. The doctors told me this was almostcertainly a type of cancer that is incurable, and that I should expectto live no longer than 3 to 6 months. My doctor advised me to go homeand get my affairs in order, which is doctor's code for prepare to die.It means to try and tell your kids everything you thought you'd have thenext ten years to tell them in just a few months. It means to make surethat everything is buttoned up so that it will be as easy as possiblefor your family. It means to say your goodbyes.</p><p>I lived with that diagnosis all day. Later that evening I had abiopsy, where they stuck an endoscope down my throat, through my stomachand into my intestines; put a needle into my pancreas and got a fewcells from the tumor. I was sedated, but my wife who was there told methat when they viewed the cells under a microscope the doctors startedcrying because it turned out to be a very rare form of pancreatic cancerthat is curable with surgery. I had the surgery and, thankfully, I'mfine now.</p><p>This was the closest I've been to facing death, and I hope it's theclosest I get for a few more decades. Having lived through it, I can nowsay this to you with a bit more certainty than when death was a usefulbut purely intellectual concept, no one wants to die. Even people whowant to go to heaven, don't want to die to get there, and yet...</p><p>...death is the destination we all share. No one has ever escaped it,and that is as it should be, because death is very likely the singlebest invention of life. It's life's change agent. it clears out the oldto make way for the new. Right now the new is you, but someday not toolong from now, you will gradually become the old and be cleared away.Sorry to be so dramatic, but it's quite true. <strong>Your time islimited, so don't waste it living someone else's life. Don't be trappedby dogma, which is living with the results of other people's thinking.Don't let the noise of others' opinions drown out your own inner voice.And most important, have the courage to follow your heart and intuition.They somehow already know what you truly want to become. Everything elseis secondary.</strong></p><p>When I was young, there was an amazing publication called The WholeEarth Catalog, which was one of the bibles of my generation. It wascreated by a fellow named Stewart Brand, not far from here in MenloPark, and he brought it to life with his poetic touch. This was in thelate 60's, before personal computers and desktop publishing, so it wasall made with typewriters, scissors, and Polaroid cameras. it was sortof like Google in paperback form 35 years before Google came along. Itwas idealistic, overflowing with neat tools and great notions.</p><p>Stewart and his team put out several issues of the The Whole EarthCatalog, and then when it had run its course, they put out a finalissue. It was the mid-1970s, and I was your age. On the back cover oftheir final issue was a photograph of an early morning country road, thekind you might find yourself hitchhiking on if you were so adventurous.Beneath it were the words, stay hungry. Stay foolish. It was theirfarewell message as they signed off. Stay hungry. Stay foolish. And Ihave always wished that for myself. And now, as you graduate to beginanew, I wish that for you. <strong>Stay hungry. Stay foolish.</strong>Thank you all very much.</p>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加息二三事</title>
      <link href="/posts/interest-rates/"/>
      <url>/posts/interest-rates/</url>
      
        <content type="html"><![CDATA[<p>从2022年3月开始，美联储在本轮加息周期累计进行了8次加息，累计增加了450个基点，基准利率从0.25%上升到4.75%。就在前几天，商务部表示2023年中国外贸领域的主要矛盾转变为外需走弱、订单下降，从全国港口的集装箱可用指数就可以看出外贸形势的严峻。我来扯扯这中间的联系。</p><p>通常来说，美联储加息的原因是由于经济过热，因为经济过热会导致通胀以及资产泡沫，影响经济稳定性，而加息则是最直接影响市场的货币政策。加息后，企业和个人的贷款成本增加，同时存款利率也增加了，人们倾向于把钱存银行，流通的钱变少，自然经济就降温了。</p><p>加息最直观的影响就是股市债市，都知道美国的蓄水池是股市（据说大于50%），CN自然是房地产（超过70%），加息导致企业借钱成本增加、生意减少，股市下跌，企业损失，美国人财富缩水。</p><p>由于美元结算体系，中国的外汇以美元为主，来源主要有几个方面：</p><ol type="1"><li>企业贸易顺差：出口东西挣回美元，外汇管理局扣下，兑人民币</li><li>外企到中国投资：外汇管理局扣下，兑人民币</li><li>中国企业借的美元债：恒大、碧桂园等，外汇管理局扣下，兑人民币</li></ol><p>外汇的用处大概有：</p><ol type="1"><li>中国企业出海兑换，需要美元在国外买矿</li><li>出国旅游兑换美金</li><li>投资</li></ol><p>一进一出之后，仍然有大量的外汇结余，成为<strong>外汇储备</strong>。手里攥着这么多美金花不出去，怎么办呢？总不能换成卢布吧。比较靠谱的投资方式还是大量购买美国国债，因为美国国债流动性和安全性都很高，收益率也还可以。所以美元最后还是存在美国银行里，变成持有美国国债了。</p><p>而加息以后美元回流，国内的投资等就要把人民币兑换成美元回美国挣钱，但是外汇管理局手里美金不够，只能抛美债给人兑付，同理日本、欧洲都会抛。其他国家做空美国国债，美国政府就没法提高债务上限了，再发没人买了，而美国就是靠发债过日子，这下政府卖不了国债没钱了，最终这些措施传导回美国自己，因此是把双刃剑。对中国来讲，就是资本外流，股市楼市下跌，人民币贬值。</p><p>另外，由于总爱搞关税壁垒和贸易制裁等等，加上俄乌战争导致能源价格和运输成本升高，油气粮食价格上涨，因此加息以后美国物价仍然在上涨，CPI仍然很高，治理通胀的效果并不明显。</p><p>从中国来看，在消费、投资、出口三驾马车中，由于目前内需不振（参考Apple销量），投资面临饱和且风险较大，因此出口变得非常重要。而中国外贸出口趋势性下降，原因主要是：</p><ol type="1"><li>由于美联储加息、疫情、俄乌战争等因素导致的全球经济周期性衰退</li><li>订单流失到越南、印度等成本更低的地方，还有就是没人愿意和反复无常的人长期打交道</li></ol><p>因此，我对外企在大陆的前景持悲观态度（我不会失业吧...）。另外，由于一直以来对中国的贸易、芯片等的制裁，导致大陆只能换供应商，因此大陆对台湾的贸易逆差会继续增大。</p><p>参考<br /><ahref="https://www.forbes.com/advisor/investing/fed-raises-interest-rates/">WhatHappens When The Fed Raises Interest Rates?</a></p>]]></content>
      
      
      <categories>
          
          <category> Finance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Economics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒气逼人的秋招</title>
      <link href="/posts/interview-summary/"/>
      <url>/posts/interview-summary/</url>
      
        <content type="html"><![CDATA[<p>自从8月13日开始第一场笔试，到11月15日最后一场面试，耗时3个多月的秋招终于宣告结束。错失了一些所谓的机会，也浅尝了生活的另一番滋味。offer寥寥，教训良多。</p><h2 id="时代的一朵小浪花">时代的一朵小浪花</h2><p>今年的就业形势不用我多啰嗦，再加上这届硕士大规模扩招，因此秋招的阵仗甚至可以用惨烈来形容。当然寒气其实并不会影响金字塔尖的那群人，只是吹得我等半瓶子晃荡的选手无奈向下兼容。其实3月份找实习的时候，就发现情况不太妙，但由于很幸运地拿到了大厂的实习offer，所以还信心满满，想要在秋招中“乱杀”。</p><p>我的秋招节奏整体上偏晚，8月20日才结束在百度的实习回到学校，因此错过了比较多提前批的机会，复习也开始的比较晚，9月份才有了秋招第一面。由于一直以来都想去外企，再加上实习时感受了下国内所谓互联网大厂的氛围，更加坚定了我的方向，所以开始时我的想法是用国内大厂练练手，主要投递微软、亚麻、Intel、Hulu、虾皮、Zoom等等。但是随着秋招进程的深入，我发现这些公司要么挂我简历、要么挂我笔试，虾皮甚至爆出了裁员丑闻，我才将目光重新转向国内大厂，当然我指的是相对稳定些的公司，比如华子、OPPO、荣耀等等，当然还有一部分原因是我想留在西安。同时也浅投了几家研究所、证券公司和银行。</p><p>面试过程中规中矩，经过3个月的实习，我并没有迸发出进大厂搬砖的激情，相反，我对那种工作环境持否定态度。因此，八股背的不好，项目也答得很烂，由于LeetCode刷了500多题，算法题基本没出啥大问题。这种随缘面试的结果就是：所谓的互联网大厂全挂了哈哈哈。10月中旬拿了TP以后，就开始拒笔试和面试了，把还在面试流程中的走完就可以了。</p><p>最终：过了2个小外企，虽然特别的wlb，但是钱太少，拒了。还有一些点击就送的厂子，特别点名表扬比亚迪，今年的秋招之光，没有她估计一半人得失业。最后选了另一个外企消磨余生，还是挺满意的。</p><p>我自己的找工作之旅已经到达终点，对后来同学的一些小tip：</p><ol type="1"><li>有些学历厂的提前批一定不要错过，往往能拿到sp。</li><li>不同的公司有不同的面试风格：美团喜欢数据库，阿里百度喜欢刨项目，字节喜欢考算法。因此面经尤其是同部门的面经非常重要，极大概率会遇到原题。</li><li><strong>项目的深度远比广度更加重要，一些拓展思考以及开源实现要有所了解，ToyProject最好能从最基本的实现方式，一步步改进和优化。如果不是独立项目，一定要清楚项目的整体逻辑和自己负责模块的位置及价值。</strong>不论是平时的项目还是实习干的活，一定要120%的理解在做什么、怎么做的，我在这方面做的不够好，自己简历上的项目没有吃的特别透，所以聊项目时总是稍稍有点怯。</li></ol><h2 id="学而不思">学而不思</h2><p>人生的路还很长，第一份工作比较重要，但也没那么重要。对我而言，比较迫切的事情就是尽快确定一个system的小方向深入钻研，<strong>深入参与一些大型的开源项目或者自行实现一些demo并一步步优化，贪多嚼不烂。</strong></p><h2 id="吐槽时间">吐槽时间</h2><p>洗脚大9月16日就开了三方，因此秋招过程中面临了很多逼签，关于这所学校的种种劣迹我不想一一阐述，总结起来就是：坑学生永远第一名。</p><p>最后，是时候好好搞毕设了😵</p><h2 id="流水账">流水账</h2><p>2023.4.25更：论文提交盲审了，记录下整个找工作的过程。</p><h3 id="找实习">找实习</h3><ul><li><p>微软<br />微软是我第一家投递的公司，印象里他们的暑期实习很早就开始造势了，在21年的12月就开始为暑期实习提前批宣传了，提前批是可以免笔试直接进面的，我当时主要担心刚上来就面微软，有点点害怕，就没有投递提前批。接着在年前大概1月20号左右投递了C+AI（HC很少）的正式批，想着能够趁过年这段时间再练习练习，大概2月底参加了笔试，一共3道题，难度不大，应该A了2道多，但是可能后台的case没有全过，后来就没消息了。。</p></li><li><p>字节<br />字节也是过完年回学校后投的，当时感觉基础架构很牛逼，大佬们很多都在做这个，听着也很高端，就投了。字节好像一般没有笔试，所以直接约面了。由于是实习第一面，所以印象深刻，面试前20分钟笔记本电脑坏了，速度去工位找室友拿电脑，然后回宿舍面试。问了非常多的八股，涉及到计网、数据库、OS、分布式，而且问的都比较深，算法题问了跳表和一道二叉树路径和的变种，由于对自己的水平没有清晰的认知，再加上是第一次，所以我的整个面试表现堪称灾难，第二天就收到了拒信，后来再也不投基架了。过了大概半个月，被新业务部门捞了起来，两轮技术面的难度都不大，但是二面面试官看起来很疲惫、很不耐烦的样子，而且连摄像头都不开...</p></li><li><p>阿里云<br />阿里云的实习宣传也非常早，挺多同学年前就面了，而且它们每个部门是单独招人的，因为有几个学长一直在宣传，就投了云开放平台。阿里可以先面试后面再补笔试和测评，所以大概不到一周就约了一面，八股和算法不难，但是简历上的每个项目都进行了深挖，有些问题之前没有深入思考，答的不太好。笔试大概做了1道半，没过几天就约二面了，3.28下午一位面试官直接进行了电话面试，先拷问了很久项目，而且比一面问的更深。。然后问了几个C++的问题，最后让设计一个十亿级别的白名单系统。真个过程能感觉到面试官水准非常高，我全程被凌辱...项目答得稀烂，设计题基本写出来了，所以还是放我过了。最后是HR面，大概就是一些常规问题，面完第二天看官网就发现流程结束了，大概率是因为gap了一年，或者阿里味不对。总之，阿里的HR总是盛气凌人，高高在上的样子，我很不喜欢。</p></li><li><p>百度<br />百度是一天下午直接搞定3轮面试，我觉得这种挺好的，省心省事。一面开始给了2道medium，我大概20分钟做完了，面试官小姐姐应该是看时间没到，就问了几句八股，闲聊了下学业和人生。二面的工程师比较严肃，把我简历上每个项目都从头到尾问了一遍，同时给出了一些场景考察实际应用能力，不知道咋回事我那天发挥很好，几乎每个问题都给出了让面试官满意的回答。百度整体上还是比较看重工程能力的，二三面都问了我是否有开源项目经历。三面是leader，问了一些科研相关的内容，聊了下项目，说之所以捞我，是因为看重我做过工程项目，也有机器学习的科研底子，告诉我她们主要做深度学习平台开发，我说自己想做一些系统开发，不太想做机器学习相关的东西了，她就把我过了，然后扔回池子。后来也接了百度的offer去实习了几个月，其实后来有点后悔没去面试时候那个组，也许能学到更多东西。关于实习期间的心路历程，可以看<ahref="https://eimadrigal.github.io/posts/internship-summary/">这里</a>。</p></li><li><p>华为云<br />网申比较早，笔试大概做了350分左右，结果拖了一个多月才安排面试，一面直接从蓝桥杯抄了一道题面贼长的题，而且那个窗口没法全屏，连题目都看不全，到最后连题目都没读懂...二面没什么印象了，应该是找实习的最后一场面试。华为的HR果然名不虚传，面试前热情似火，面试后发消息都不回，而且一直拖到6月都没有结果，就纯纯养鱼，对这家公司没什么好印象。</p></li><li><p>网易互娱<br />互娱的笔试挺难的，我只过了1道题。一面大概90分钟左右，上来前30分钟先做题，接着问了很多C++、操作系统和数据结构的内容，最后又做了1道题。2道题都比较难，应该都是自己出的，我做的不太理想，后面就没消息了，自己确实也搞不了游戏...</p></li><li><p>摩根士丹利<br />投递大摩也是机缘巧合，实习群里有人发了宣传，我就投了。过了3天就进行了笔试，笔试整体难度不大，应该接近满分。又过了3天，大概3月底的某天中午进行了30分钟的全英文电面，电面中问了一道hard，快20分钟了还是没有思路，面试官提示了一下还是没有正确的思路，又简单问了几个八股就匆匆结束了，我也没抱任何希望。结果到了5月中旬，在我即将去北京的前两天，收到了邮件让参加18号的AC面，由于16号就要入职百度了，所以就拒绝了面试，HR还打电话问我为什么不参加了，然后说那后面秋招保持联系，也为后来的故事埋下了伏笔。</p></li><li><p>招行信用卡<br />投递的是量化数据分析岗位，几轮面试中基本没有技术问题，大概3~4个面试官问了一些科研方面的内容以及对银行数分的理解，我们双方都感觉确实不太匹配，就挂掉了。</p></li><li><p>其他<br />除了一些主动拒掉的公司之外，腾讯、美团、拼多多、Amazon笔试以后没有消息，快手、OPPO、携程、蔚来、联想、小米投递之后没反应。</p></li></ul><h3 id="秋招">秋招</h3><ul><li><p>微软<br />8月初就投递了，也是我投的第一家公司，确实很想去。这次吸取了实习的教训，投递了HC最多的苏州STCA，笔试可以参加4轮取最高成绩，所有轮次我都参加了，最后仍然没有收到面试。不过按照去年微软的情况，实习生都没法转正，秋招HC约等于0，这样的结果也就不足为奇了。</p></li><li><p>京东<br />因为有朋友在京东一直撺掇我，实习回来就投了C++开发岗。9月1号进行的一面，也是我整个秋招的第一面，结果接雨水都忘了怎么写...还问了一些C++和网络的八股，我确实状态一般，后来捞起来又面了一次，也面的非常一般，就无缘了。</p></li><li><p>B站<br />因为实验室同门有在那边实习的，就投递了搜索推荐的研发岗位，没有笔试，一面大概1小时左右，感觉面试官黑眼圈很严重...问了一道medium、一些C++、网络以及项目的问题，我整体感觉答得还不错，结果很快就挂了，应该没什么HC，而且据说这个岗位竞争比较激烈。</p></li><li><p>大疆<br />一直对DJI挺尊重的，也知道bar比较高。应该是仅次于微软第二家投递的，然后周末去公司做了笔试，结果耗了一个月给我挂了...后来一直给我邮箱发无人机的广告，醉了...</p></li><li><p>华为<br />还是一如既往的早早宣传造势，我实习的时候就有HR不断打电话劝我投她们部门，后来避开了2012和华为云，投递了无线网络开发。由于实习笔试成绩可以复用，就直接进行了3轮面试。华为也没有确切的面试时间，所以只能盯着电脑看还有多久轮到自己，挺无语的，终面的时候那个网站隔几分钟自动退出登录，然后我尝试重新登录，弹窗说达到最大登录次数，差点没赶上面试...整体面试难度不大，面试官也都非常专业，一面面试官让我把摄像头怼到纸上，画出实习所负责项目的整体结构图，然后给他解释每个模块，算法题顺利做出来以后，面试官当场告诉我：他这轮面试的结果是通过，二面让我复盘笔试，半年前做的，早都忘得差不多了，就随便口胡了一下。最离谱的事情是面完以后等结果，从9.20面完最后一轮直到12.15才oc，而且今年由于HC收缩，开了很多13级的offer，期间还有部门直接把招聘群解散了...很多朋友也从爱华信华等华变成了骂华，总之这家公司挺“神奇”的，一个招聘过程能整这么多幺蛾子也是不多见。最后给我开了14A，但是去年有个学长拿了16级，果断拒了，这点钱很难让人卖命呀。</p></li><li><p>TP<br />知名学历厂，我是因为实习没投提前批，所以直接投递的正式批，不过后来看提前批薪水会开得高一些。面试过程中规中矩，最后在杭州给我开了SSP+8，在所有offer里还是挺有竞争力的，也是我第一个比较满意的offer，所以oc以后很多公司我就不想面了，每天做测评和笔试也确实很烦。找学姐打听了里面的情况，感觉氛围没有网传那么夸张，所以后面就一直在我考虑范围内，差点都签了，但是为了等华子就一直拖着...</p></li><li><p>OPPO<br />投递OPPO主要是因为在西安有base，但是笔试后一个多月才发一面，不过面起来很快就oc了，开的薪资也还不错，但是和TP差距有点大（可能是HR问我期望薪资的时候说少了），就没有接。</p></li><li><p>摩根士丹利<br />大摩其实投递的比较晚了，而且听说大部分offer都给了转正，所以其实没抱什么期望。9月中旬做了笔试，应该也是接近满分。一个月以后才电面，电面感觉表现得也还不错，又过了一个月才安排AC面，AC面分了4个session，基本每轮都有coding，甚至还要手动在屏幕上跑一个样例，一行一行给面试官解释发生了什么，直到她认可你的做法和思路。我在倒数第二轮表现得很差，因为不太能听懂面试官的口音，面试官提前看了我的简历、个人网站和github，问我MIT6.824的项目做了吗，看架势要和我聊分布式了，可惜6.824我还没来得及学...其它几轮感觉发挥还可以。大概过了一周，大早上收到了oc前的咨询电话，接着他们那边商量了大概几十分钟（应该挺悬的），然后在工位接到了HR的offercall，因为前几年实验室有个学姐去了大摩，找她聊了下情况就接了。</p></li><li><p>HSBC<br />汇丰投递了西安的科技岗，测评的内容真的巨多，完全不想做，忍痛做了之后还是挂在了AI面，连面试官都没见着...</p></li><li><p>广联达<br />还是因为西安的公司太少了才投，只有两轮面试，会有一些计算几何和图形学问题，不太会，但还是给开了SP，总包和OPPO差不多。</p></li><li><p>科大讯飞<br />流程也非常慢，base在合肥，钱也不多，而且薪资的构成花里胡哨，就直接拒了。</p></li><li><p>美团<br />美团也是8月初投的成都，一面大概2小时，做了2道hard和1道easy，面试快结束时面试官告诉我组里主要用Java，因为技术栈不太匹配，需要向大老板请示下，然后就被放回池子了...后来又被北京的买药捞了，一面问了很多八股，说我网络方面的基础很扎实，二面基本就是在聊天，技术栈还是不匹配，就没再继续了。不过美团的面试体验非常nice，面试官都比较尊重候选人。</p></li><li><p>深信服<br />二面面试官给我印象非常好，应该提前精心准备过面试题，水平也非常高，我卡壳了会教我这个东西是怎么回事，最后看我有些失落，还夸我基础不错，在应届生里算很好了。三面和四面是在西安的一个酒店，下午快吃饭了还给点了外卖和奈雪，这也是秋招唯一一次线下面试，主要在聊项目，面试官的评价挺高的，所以后来又进行了一轮SP加面，应该是个高管，问了挺多虚无缥缈的内容，比如问我是理想主义者吗，最佩服哪个同学...面了这么多轮我以为会开挺高的，没想到相比去年还压价了...最后开的薪资真的非常一般，base还在深圳，就没有接。</p></li><li><p>联想<br />联想真的非常神奇，不知道筛简历的标准是什么。实习投递了联想的服务端开发工程师，直接简历挂。秋招又投了SSG的数据开发工程师，一面主要聊了未来工作方向的规划等等，因为在百度实习做的东西也和数据有关系，所以面试官觉得很匹配。二面是2位大老板，面试前一面面试官还特意发邮件叮嘱我一些细节，非常感动呜呜呜，二面的体验也很丝滑，整体来讲，外企的面试体验都非常棒。后来通过面试后，一面面试官打电话询问我的意向，也很直白地说了联想的薪资没法和互联网大厂竞争，因为offer审批非常麻烦，所以让我考虑好了再回复她。</p></li><li><p>中兴<br />面试过程非常水，9月中旬就oc了，也是我拿到的第一个offer。当时坐地铁和室友一起去签约会，在地铁上才发现那个部门主要是做测试的，而且风评巨差...更令人无语的是，签约会上的几位面试官非常高傲，言语间都充斥着装x的气息，还PUA我成绩不高、项目不行、论文也不咋地，最多给开个17、18k吧...实在不懂他们哪来的自信，当场就拒了。</p></li><li><p>字节<br />投了系统架构，一面大概70多分钟，让我设计一个推荐系统并且coding出来，还问了很多八股、项目和实习内容，面试官水平挺不错的，只怪我基础不牢，第二天感谢信就来了，和字节实在没缘分...</p></li><li><p>荣耀<br />一共两面，9.15第二轮面试结束，直到12.14才oc，果然有其父必有其子...不过荣耀开的薪资挺不错的，基本达到了西安的天花板，当时确实有点心动，不过好像加班很严重，和大摩比较了下就拒了。</p></li><li><p>比亚迪<br />迪子是个好人，XJTU估计去了有好几千人...所有面试加起来可能都没有10分钟，平心而论，迪子的薪资在西安还是不错的，而且据说不怎么加班。不过为什么给我调到了工程院，后来想重新投递规划院，结果好像不能改志愿了...</p></li><li><p>三星<br />投递的是存储软件开发，面试难度不高，国庆节前夕oc，开了SP，在西安性价比也不错。可以自己选感兴趣的部门，而且给了非常充足的时间考虑是否接受，HR也非常专业，还让部门的工程师打电话给我介绍具体的业务，不过由于薪资原因还是没有接。</p></li><li><p>国企 &amp; 研究所<br />投递了一些银行总行的科技管培，不过考虑到他们的笔试实在有点恶心，大部分都放弃了，招总给我AI面挂了，不理解...邮储、中金因为已经接了大摩，所以也没有继续面。</p><p>还投了移动研究院、联通、电信优才计划、天翼云、招银网络科技等，感觉给的钱太少了，除了杳无音信的以外，大都放弃了。</p><p>另外，还投了西安的504和618所，504没消息，618也挂在了AI面...</p></li><li><p>其他<br />阿里重新投了一个部门，直接简历挂，后面简历一直在几个部门流转，也没有笔试和面试，应该是个人经历或者实习面试踩到什么红线了吧。腾讯由于那张广为流传的HC截图，我压根没投。百度在截止前投了成都，C++只有5个开发岗的HC，笔完就没消息了。米哈游、SHEIN、蚂蚁、网易互联网、互娱、雷火、蔚来、小红书、携程、VIVO都是笔试挂。小米是最恶心的，笔试时不同语言给的代码模板不一样，对C++选手很不友好，而且那个平台真的难用，所以随便写了写就交了，事后也被牛客吐槽“不想招人可以不发笔试”，这公司也是醉了。</p><p>ZEKU的提前批太早了就没投，秋招想投结果发现招聘页面只剩博士了...猿辅导、贝壳、快手直接简历挂。滴滴由于面试和组会冲突了，想推迟几天，结果就没了。海康由于面试前要调岗，就放弃了。</p><p>本来一开始是奔着外企去的，结果外企的战绩更惨，Amazon、BIGO、eBay、高通、西门子、Insta360、NVIDIA、Thoughtworks、Zoom、虾皮、Dell、IBM、Arm直接简历挂，不过TW幸好挂了，前段时间它把所有校招offer都收回了...Zoom分了好几批，由于第一批开的时候我还在实习，就拖到了第二批才投，果然没捞到面试...虾皮也幸好挂了，有学长刚落地新加坡，HR通知offer取消...</p><p>AMD、Cisco、Intel、Lazada、特斯拉笔试完没消息了，特斯拉错投了软开service岗，笔试考了一堆运维的题，直接寄了...Intel我做的挺快的，做完还慢慢悠悠地从头到尾检查了一遍，结果发现最后一道题看错了，时间到了没调出来...Lazada后来都快2023年了打电话问我要不要考虑其他岗位的面试...Hulu我自知水平不够就没参加笔试，出去玩了，结果今年中国区就全部端了...ArcSoft放弃笔试了。去年那个形势，能去这些外企的也都是巨佬了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>亲身走过的才是自己的路</title>
      <link href="/posts/internship-summary/"/>
      <url>/posts/internship-summary/</url>
      
        <content type="html"><![CDATA[<p>昨天是我结束在百度实习的日子，这是我第一次真正意义上在互联网公司实习，对我来说是一段全新的体验，回想起这三个多月，感慨良多，不吐不快。</p><h2 id="技术成长">技术成长</h2><p>我是在公共技术团队下的数据分析小团队搬砖，实习期间主要负责内部一个分析平台的设计、开发、测试和运维，平台的功能类似于字节的<ahref="https://www.volcengine.com/docs/6285/65957">火山引擎</a>，平常的大部分工作都是CURD，当然也经常化身为SQLBoy。从技术深度上来讲，这些工作的难度甚至远远不如我做过的一些公开课Lab，也并没有十分复杂的算法。我个人肉眼可见的一些成长主要包括：</p><ul><li>对于大厂开发流程有了深入的了解，包括需求设计、排期、前后端联调、部署上线等，由于公司正在降本增效，因此我得以接触到全流程的每个步骤，甚至作为主力开发成为了平台代码最大的贡献者。在这些过程中，对于一些大数据的开源/自研工具有了初步的使用经验，比如Spark，ClickHouse，Pingo，AFS等。</li><li>对于国内的互联网公司而言，技术永远是为业务赋能的，顺便，学到了对齐、拉通、赋能、抓手这些互联网黑话。分析平台看似简单，其实底层的整条数据链路是非常复杂的，需要各种端的协作以及对业务的深层理解，在公司内部的推进还是需要高T去协调资源的。对于类似于数据研发/数据分析/基础平台研发这种支持性岗位，在晋升时和业务部门一起PK是十分吃亏的，但是相对来讲比较清闲，算是各有利弊吧。</li><li>根据我的观察，百度还算是一家技术导向的公司，内部基建也比较完善，牛人也很多，没落主要是其他因素导致的。</li><li>需求排期非常紧，完全没时间把控代码质量，除非你愿意牺牲休息时间重构代码，可是又有什么收益呢，所以只能屎山上雕花。很难静下心做一些底层基础的事情，比如代码质量等，最重要的是迅速地跑起来。</li><li>OKR制度确实可以提效，可以借鉴来制定自己的目标。</li><li>技术选型以及参数格式的设计在初期非常重要，会极大程度影响后续开发迭代。</li><li>及时commit代码，将功能需求拆分成很小的story，例如controller打好桩提交一次，service实现一个功能提交一次，这样容易定位bug，也便于别人review代码。这一点我做的不好，总是一次提交成百上千行代码，幸好mentor没有打死我。。</li><li>不要随便删除别人的代码：有一次没仔细看删了一个mentor写的重载函数，结果CR时被骂的狗血淋头，因为参数的个数虽然一样，但顺序和意义不一样。。</li></ul><h2 id="人情练达">人情练达</h2><p>这几个月能明显感觉到自己在职场上的沟通交流亟待加强，主要有以下几点：</p><ul><li>印象非常深刻的一件事：有一个用户包分享的需求，我在实现之前没有和mentor沟通技术方案，给表加了一个字段，通过位运算判断分享到的APP，完成后进行CR时mentor告诉我有更好的方案，可以用中间表，因此很多代码都需要重写。。这个惨痛的故事告诉我们：对于一些稍大的功能优化，实现前一定要沟通好技术方案，避免返工。</li><li>职场第一课：除了技术方案，其他事情也要及时沟通和汇报，不要拖太久，避免出事和背锅。</li><li>正确理解领导的意思：由于平台使用人数增加，小组长让我部署一个线上环境，告诉我要确保jar包等配置、测试MySQL的连接、判断Pingo任务是否提交成功、设置数据库和离线任务的白名单、搞成一键部署的脚本...当时就给我整懵逼了，我心想我靠这咋弄。但是后来我揣摩了下组长的目的：说了这么多很专业的词汇，其实最终就是希望线上和测试环境分离，其实就是把原来的数据库啥的copy一份，改下maven的配置，清理下垃圾数据就ok了，最终互不影响就行，事情瞬间简单了。</li><li>领导的记忆力都是很好的，可能几个月前给你的一个小任务，几个月后的周会上他还能清楚地找你要结果，不要抱有侥幸的偷懒心理。</li><li>不得不承认一个残酷的事实，我们和大部分人都只是利益交换关系而已，不过学生之间利益牵扯少一些而已。职场上以自己利益为主要操作方向，更有侵略性一些，不要掺杂感情因素。mentor教育我：职场没有感情，关系再好也只是同事间的利益而已，公司裁你的时候眼睛都不会眨一下。</li><li>虽然如此，但还是要搞好同事关系，晋升时候指不定谁就是答辩委员会的，包括同一批入职的。</li><li>百度有些老鸟真的很烦人，素质很低。</li></ul><p>我的两位mentor教会了我挺多东西，尤其是晓燕姐，在我刚入职时候不知道从何下手时鼓励我大不了推倒重来，告诉我数据做到极致就是让人感受不到数据组的存在，教我思考不可替代性和自己的价值，公司为啥用你而不用更廉价的人。涛哥开始给我的印象很不好，但是后来接触多了发现他的确是一个非常规范的职场人，印象颇深的是8月10号午饭后遛弯，他问我团队为什么要做这个平台，我说了提高影响力等等，他告诉我这些都对，但显然说服力不够，说服别人需要定量的数据，如平台的需求覆盖率分析，这是建立在高层次的认知基础上的，因此年轻时还是卷一点，技术是学不完的，但是可以更快到达更高的认知层次，看问题更加全面，以后会轻松一些。</p><h2 id="感性碎片">感性碎片</h2><p>这篇文章最开始的标题是『大厂再无光环』，后来随着实习的深入，我发现这个题目并大不合适。不去亲身体验根本不知道自己是不是真的喜欢和适合。刚入职的体验确实非常不好：坐在工位，看着满屏的代码，砸着有些酸疼的腰椎。从早到晚都在嗡嗡嗡，打语音对需求，午休还有人叽叽喳喳，脑袋一整天都是僵硬的，感受到的全是痛苦。有的人就是可以在这种环境中如鱼得水，兴奋地找Bug。而我感觉像是彻彻底底地活在梦里，自己完全不属于自己，也完全没有解决技术难题的喜悦感，每天都在忙碌着开会肝需求。一天中最开心的时刻就是下班回出租屋的路上，一个人带着耳机听着歌。</p><p>这种感觉是极其压抑的，这辈子不想再碰这些了，每天很痛苦，盯着屏幕一整天，感觉不到任何乐趣。难是一方面，还有就是一天看代码真的受不了，需求叠着需求，没有松口气的时候，整天写代码我就疯了。我暗暗发誓并且120%地确定：这绝对不是我想要的生活，绝望了，身体或心理上最难受最绝望的时候甚至有些生不如死的感jio。其实CS（特指码农这份工作）更像物理而非数学，更偏向实用科学而非理论科学，我从小就不擅长动手，根本不是技术控。</p><p>现在仍然清晰地记得：6月14号晚上下班后，走在路上我几乎濒临崩溃，在💴和痛苦之间苦苦挣扎，不知道何去何从。彷佛前几年做的一切，都是虚空甚至起了反作用。坐在回龙观新村的长椅上，抬头仰望夜空，却满眼都是乌云。我当时想：房子和付出的成本都不是最关键的问题，只要让我立即辞职止损就好！</p><p>6月17号是一个周五，天气好闷热，完全一副暴雨将至的样子，当时的情况就和我的心情一样压抑。我交完代码后，于7.30冲出公司，快步向回走，半路碰到共享单车，听着《淤青》，终于在下雨前赶回出租屋。我发誓这个周末一定要搞清楚未来的路。当时和npy在冷战，真的特别想哭，如果真的下雨了，我又该找谁借把伞呢？好吧，后来知道公司可以借伞。</p><p>度过了最初期的两周，逐渐适应了社畜的生活，最开心的就是周五周六，周天最不开心，因为第二天就又要上班了。我住在19楼，18楼有一个大爷，每天早晨上班他都会在单元楼门口，每天晚上下班他也在。组里和我关系最好的不是经理，也不是mentor，而是组里另外一个小哥，他帮我debug带我看源码，可惜我入职不到2周他就走了，休假前最后一天他才告诉我自己是被裁员的，他说一开始没告诉我是被裁员，因为我刚去，不想打击我。小哥说话不多，但是比组里留下的两个人热心的多，也许这种机制就是让这些无情的工作机器留下吧。他走的那天下午(0623)，我真的非常失落，走在路上的一瞬间特别想哭，眼泪一下就用到了眼眶，那种难过的感觉，我在想，如果走的是我，我是否有他那么乐观，有重新开始的勇气。</p><p>后面就彻底适应了这种生活，即使很多事情(科研，实习，找工作，人际)交织在一起，我的心理压力也没有刚去的时候那么大。</p><p>lastday时，再也看不到西二旗熙熙攘攘的自行车流，看着离职交接流程一项项审批(36/42)，入职时候工位放的半杯水在离职时也正好蒸发完，离职这天上厕所也不用盯着如流慌慌张张。离开北京的前一晚，我心里五味杂陈，有不舍、有茫然、有畏惧、有期待。人如果对未来几天的将要发生的事情有一些期待，那么当下的生活也会美妙很多。</p><p>再见了，后厂村不息的早高峰！再见了，回龙观舒适的晚风！</p><figure><img src="回龙观.jpg" alt="码农大本营回龙观新村" /><figcaption aria-hidden="true">码农大本营回龙观新村</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希</title>
      <link href="/posts/consistent-hashing/"/>
      <url>/posts/consistent-hashing/</url>
      
        <content type="html"><![CDATA[<p>由于hash算法的均匀性，可以用<code>hash(object) % N</code>得到数据的存储位置，使其平均存储到N个节点上。如果每个数据的访问量比较平均，负载自然也是均衡的。这样的问题在于分布式系统的节点数目通常是在动态变化的,因此传统的哈希会有大量的数据迁移, 可扩展性很差.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NODE_NUMBER := <span class="number">100</span></span><br><span class="line">    DATA_MAX_NUMBER := <span class="number">10000000</span></span><br><span class="line">    cnts := <span class="built_in">make</span>([]<span class="keyword">int</span>, NODE_NUMBER)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; DATA_MAX_NUMBER; i++ &#123;</span><br><span class="line">        data := md5.Sum([]<span class="keyword">byte</span>(strconv.Itoa(i)))</span><br><span class="line">        dataStr := hex.EncodeToString(data[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">        hash, err := strconv.ParseInt(dataStr, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            id := hash % <span class="keyword">int64</span>(NODE_NUMBER)</span><br><span class="line">            cnts[id]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    desiredLoad := DATA_MAX_NUMBER / NODE_NUMBER</span><br><span class="line">    maxLoad := cnts[<span class="number">0</span>]</span><br><span class="line">    minLoad := cnts[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; NODE_NUMBER; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> cnts[i] &gt; maxLoad &#123;</span><br><span class="line">            maxLoad = cnts[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnts[i] &lt; minLoad &#123;</span><br><span class="line">            minLoad = cnts[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxPercent := <span class="number">100.0</span> * <span class="keyword">float64</span>(maxLoad - desiredLoad) / <span class="keyword">float64</span>(desiredLoad)</span><br><span class="line">    minPercent := <span class="number">100.0</span> * <span class="keyword">float64</span>(minLoad - desiredLoad) / <span class="keyword">float64</span>(desiredLoad)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Desired loading: %d\n&quot;</span>, desiredLoad)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Most loading in one node: %d %+.4f%%\n&quot;</span>, maxLoad, maxPercent)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Least loading in one node: %d %+.4f%%\n&quot;</span>, minLoad, minPercent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Desired loading: 100000</span><br><span class="line">Most loading in one node: 100695 +0.6950%</span><br><span class="line">Least loading in one node: 99073 -0.9270%</span><br></pre></td></tr></table></figure><p>可以看到负载整体上是比较均衡的，此时如果增加一个节点：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NODE_NUMBER := <span class="number">100</span></span><br><span class="line">    NEW_NODE_NUMBER := <span class="number">101</span></span><br><span class="line">    DATA_MAX_NUMBER := <span class="number">10000000</span></span><br><span class="line">    moveCnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; DATA_MAX_NUMBER; i++ &#123;</span><br><span class="line">        data := md5.Sum([]<span class="keyword">byte</span>(strconv.Itoa(i)))</span><br><span class="line">        dataStr := hex.EncodeToString(data[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">        hash, err := strconv.ParseInt(dataStr, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            id := hash % <span class="keyword">int64</span>(NODE_NUMBER)</span><br><span class="line">            newid := hash % <span class="keyword">int64</span>(NEW_NODE_NUMBER)</span><br><span class="line">            <span class="keyword">if</span> id != newid &#123;</span><br><span class="line">                moveCnt++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    movePercent := <span class="number">100.0</span> * <span class="keyword">float64</span>(moveCnt) / <span class="keyword">float64</span>(DATA_MAX_NUMBER)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Moved items: %d %+.4f%%\n&quot;</span>, moveCnt, movePercent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Moved items: 9900989 +99.0099%</span><br></pre></td></tr></table></figure><p>可以看到：只增加了一个节点，竟然需要移动99%的数据，这是完全不能接受的！一致性Hash主要用来解决服务器的负载均衡问题.一致性hash不仅需要计算存储对象的hash值,还要计算每个节点的hash值<code>hash(name/IP)</code>,并将其分配到圆环区间<span class="math inline">\([0,2^{32}-1]\)</span>.对于存储请求, 将<code>hash(obj)</code>利用二分法顺时针分配到第一个节点,从而提高<strong>单调性</strong>, 即增删节点后,原有数据的哈希结果不迁移或迁移到新节点, 但不会迁移到旧节点.在Swift云存储系统中, 负责存储对象与物理位置映射关系的组件叫做Ring,也许就有环hash的意思.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NODE_NUMBER := <span class="number">100</span></span><br><span class="line">    NEW_NODE_NUMBER := <span class="number">101</span></span><br><span class="line">    DATA_MAX_NUMBER := <span class="number">10000000</span></span><br><span class="line">    moveCnt := <span class="number">0</span></span><br><span class="line">    startDataId := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    newStartDataId := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    remainder := DATA_MAX_NUMBER % NODE_NUMBER</span><br><span class="line">    base := DATA_MAX_NUMBER / NODE_NUMBER</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NODE_NUMBER; i++ &#123;</span><br><span class="line">        startDataId = <span class="built_in">append</span>(startDataId, cnt)</span><br><span class="line">        <span class="keyword">if</span> i &lt; remainder &#123;</span><br><span class="line">            cnt = cnt + base + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt = cnt + base</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remainder = DATA_MAX_NUMBER % NEW_NODE_NUMBER</span><br><span class="line">    base = DATA_MAX_NUMBER / NEW_NODE_NUMBER</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NEW_NODE_NUMBER; i++ &#123;</span><br><span class="line">        newStartDataId = <span class="built_in">append</span>(newStartDataId, cnt)</span><br><span class="line">        <span class="keyword">if</span> i &lt; remainder &#123;</span><br><span class="line">            cnt = cnt + base + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt = cnt + base</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; DATA_MAX_NUMBER; i++ &#123;</span><br><span class="line">        data := md5.Sum([]<span class="keyword">byte</span>(strconv.Itoa(i)))</span><br><span class="line">        dataStr := hex.EncodeToString(data[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">        hash64, err := strconv.ParseInt(dataStr, <span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            hash := <span class="keyword">int</span>(hash64)</span><br><span class="line">            target := hash % DATA_MAX_NUMBER</span><br><span class="line">            id := sort.Search(<span class="built_in">len</span>(startDataId), <span class="function"><span class="keyword">func</span><span class="params">(k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> startDataId[k] &gt;= target &#125;)</span><br><span class="line">            id = id % NODE_NUMBER</span><br><span class="line"></span><br><span class="line">            newid := sort.Search(<span class="built_in">len</span>(newStartDataId), <span class="function"><span class="keyword">func</span><span class="params">(k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> newStartDataId[k] &gt;= target &#125;)</span><br><span class="line">            newid = newid % NEW_NODE_NUMBER</span><br><span class="line">            <span class="keyword">if</span> id != newid &#123;</span><br><span class="line">                moveCnt++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    movePercent := <span class="number">100.0</span> * <span class="keyword">float64</span>(moveCnt) / <span class="keyword">float64</span>(DATA_MAX_NUMBER)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Moved items: %d %+.4f%%\n&quot;</span>, moveCnt, movePercent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Moved items: 4897001 +48.9700%</span><br></pre></td></tr></table></figure><p>一致性hash虽然减少了数据迁移, 但是在node较少时仍然要迁移大量数据,因此引入虚拟节点Partition. 引入Partition后就形成二级映射:<code>obj-&gt;虚节点-&gt;node</code>.通过提前设置固定的较大数目的虚节点, 使得obj到虚节点的映射固化,增删node时只需要维护虚节点和node间的映射即可.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NODE_NUMBER := <span class="number">100</span></span><br><span class="line">    NEW_NODE_NUMBER := <span class="number">101</span></span><br><span class="line">    VNODE_NUMBER := <span class="number">1000</span></span><br><span class="line">    DATA_MAX_NUMBER := <span class="number">10000000</span></span><br><span class="line">    moveCnt := <span class="number">0</span></span><br><span class="line">    vstartDataId := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    newStartDataId := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    vnode2node := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    remainder := DATA_MAX_NUMBER % VNODE_NUMBER</span><br><span class="line">    base := DATA_MAX_NUMBER / VNODE_NUMBER</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; VNODE_NUMBER; i++ &#123;</span><br><span class="line">        vstartDataId = <span class="built_in">append</span>(vstartDataId, cnt)</span><br><span class="line">        <span class="keyword">if</span> i &lt; remainder &#123;</span><br><span class="line">            cnt = cnt + base + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt = cnt + base</span><br><span class="line">        &#125;</span><br><span class="line">        vnode2node = <span class="built_in">append</span>(vnode2node, i % NODE_NUMBER)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    new_vnode2node := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(vnode2node))</span><br><span class="line">    <span class="built_in">copy</span>(new_vnode2node, vnode2node)</span><br><span class="line"></span><br><span class="line">    remainder = DATA_MAX_NUMBER % NEW_NODE_NUMBER</span><br><span class="line">    base = DATA_MAX_NUMBER / NEW_NODE_NUMBER</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NEW_NODE_NUMBER; i++ &#123;</span><br><span class="line">        newStartDataId = <span class="built_in">append</span>(newStartDataId, cnt)</span><br><span class="line">        <span class="keyword">if</span> i &lt; remainder &#123;</span><br><span class="line">            cnt = cnt + base + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt = cnt + base</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newNodeID := <span class="number">100</span></span><br><span class="line">    reassignNumber := VNODE_NUMBER / NEW_NODE_NUMBER</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reassignNumber; i++ &#123;</span><br><span class="line">        vid := i</span><br><span class="line">        new_vnode2node[vid] = newNodeID</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; DATA_MAX_NUMBER; i++ &#123;</span><br><span class="line">        data := md5.Sum([]<span class="keyword">byte</span>(strconv.Itoa(i)))</span><br><span class="line">        dataStr := hex.EncodeToString(data[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">        hash64, err := strconv.ParseInt(dataStr, <span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            hash := <span class="keyword">int</span>(hash64)</span><br><span class="line">            <span class="comment">// 不用二分，数据项到虚节点映射固定：vid := hash % VNODE_NUMBER</span></span><br><span class="line">            target := hash % DATA_MAX_NUMBER</span><br><span class="line">            vid := sort.Search(<span class="built_in">len</span>(vstartDataId), <span class="function"><span class="keyword">func</span><span class="params">(k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> vstartDataId[k] &gt;= target &#125;)</span><br><span class="line">            vid = vid % VNODE_NUMBER</span><br><span class="line"></span><br><span class="line">            id := vnode2node[vid]</span><br><span class="line"></span><br><span class="line">            newid := new_vnode2node[vid]</span><br><span class="line">            <span class="keyword">if</span> id != newid &#123;</span><br><span class="line">                moveCnt++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    movePercent := <span class="number">100.0</span> * <span class="keyword">float64</span>(moveCnt) / <span class="keyword">float64</span>(DATA_MAX_NUMBER)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Moved items: %d %+.4f%%\n&quot;</span>, moveCnt, movePercent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Moved items: 90423 +0.9042%</span><br></pre></td></tr></table></figure><p>上述方案中需要预设合理的虚节点数目,如果实际节点多于虚节点数目，会导致有的节点分配不到虚节点，此时如果增加虚节点数，就会导致大量的数据迁移。因此通常需要将虚节点数目预设为系统最大规模的若干倍。</p><p>为了加快速度，还可以通过位操作代替取模操作，即所谓的partitionpower.</p><h2 id="ref">ref</h2><p><ahref="https://www.cnblogs.com/yuxc/archive/2012/06/22/2558312.html">Ring实现原理剖析</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更快乐些吧</title>
      <link href="/posts/be-happier/"/>
      <url>/posts/be-happier/</url>
      
        <content type="html"><![CDATA[<p>Positive Psychology是Havard开设的一门心理学课程,这门2003年的课程解开了我相当多的疑惑,是我研究生三年中上过的最重要的一门课. 在2021年6月左右就刷过一遍,时至今日仍然常看常新.</p><h2 id="成长第一问-人生的意义是什么">成长第一问: 人生的意义是什么</h2><p>我想在每个人成长的过程中, 都会或早或晚从某一时刻开始, 不停追问自己:人生的意义是什么? 我大概从初中开始想象: 既然人终归都要西去,那么每天努力学习又有什么用呢? 这个问题一直萦绕在我心头,时而觉得已经靠近答案了, 时而推翻曾经的答案. 犹记得大学室友说:人生的意义就是没有意义, 人生就是用来追寻意义的. 看起来很有哲学意味,但切记: 汝之蜜糖, 吾之砒霜.</p><p>随时间流逝, 我也变得忙碌起来, 不过还是会经常思考:辛勤工作挣大钱有什么用? 勾心斗角追名逐利又有什么用? 到头来不都是一场空?所以有段时间我变得十分佛系, 并且经常感到生活如同行尸走肉,只是在为了一个目标机械式地付出时间精力. 就像Thoreau和Floyd所说:</p><blockquote><p>Most men lead lives of quiet desperation.<br />People are comfortably numb.</p></blockquote><p>幸福感这个词虽然偶尔仍然会在耳边闪现:</p><blockquote><p>人生嘛, 最重要的就是开心!</p></blockquote><p>但彼时对于幸福的理解却完全是二元的: 要么幸福, 要么不幸.从来没有想过幸福感竟然可以是连续的, 是可以有比较级的: happier.因此人的情感不可能永远维持在高位, 每段时间都会有ups and downs,但是通过科学的方法可以让自身的幸福感呈现出总体上的上升趋势,而这则应当是衡量人生意义的唯一标准.</p><p>那么人生幸福感的持续增加是否能够依赖他人呢? 或者说是否能够遇到伯乐呢?很不幸, 概率极低. 我以前低谷时, 总是幻想会有人来拯救自己,但往往事与愿违, 直到最后也不会神兵天降. 所以抱怨和幻想都无济于事,正如Tal所言:</p><blockquote><p>No one is coming. You are responsible for your life, for yourself-confidence, for your self-esteem, for your happiness.</p></blockquote><h2 id="认知误区之成功">认知误区之成功</h2><p>如果用实现某些人生节点的目标来作为成功的标准,正如我们小时候一直被教育的那样: 考上好大学就是成功,抑或是拿到tenure就算成功. 我相信: 你原本想象成功后就会永远高兴下去,比如考到所谓的好学校便会一帆风顺. 但事实往往是:这样快乐的情绪并不会持续太久, 接踵而来的便是新的烦忧,即幸福感会很快回落到之前的baseline. 同样地, 失败也会是相同的感受:你以为自己会很长很长时间处于低落情绪中, 但其实没过几天就会走出阴霾.</p><p>因此, 在基本的物质和精神需求得到满足后,外界因素对于幸福感的影响其实是很小的.幸福感baseline更多取决于自己的state of mind, 取决于如何看待世界,看待发生的事情.</p><h2 id="关于理想主义">关于理想主义</h2><p>曾经在很长一段时间里, 我都自诩为理想主义者,但后来我发现自身的认知有些偏差, 我顶多算个半理想主义者.理想主义者要有理想, 这只是前提,是否拥有足够的勇气和智慧去践行理想才是区分理想主义者与否的关键:</p><blockquote><p>To be idealistic is to be realistic.</p></blockquote><p>这个世界最最需要的是有实践精神的理想主义者:</p><blockquote><p>What the world needs more than anything else is practicalidealists.</p></blockquote><p>很不幸, 目前看来我并不具备这样的勇气和智慧. 我之前还有一点疑问:对于那些所谓精致的利己主义者, 或者说只顾自身幸福的人我是持鄙夷态度的,但很明显这样看起来并不正确:</p><ol type="1"><li>追求自身幸福并不是一种自私的行为, 幸福感是正和博弈, 是具有传染性的:助人即是助己, 助己也是助人.因此传播幸福最好的方法就是经营好自己的幸福.</li><li>作为伪理想主义者, 我自然没有资格评判别人的行为.</li><li>目前某些国家的大环境的确没有理想主义者生存的土壤.</li></ol><h2 id="关于完美主义">关于完美主义</h2><p>我从小就有完美主义的毛病, 小到考试要将卷子写满, 大到人生决策全都想要.我甚至曾经一度认为这是一个好的习惯: 追求完美, 追求绝对纯净.栽过几次跟头后我隐约觉得这种认知不对, 但是无法科学剖析.</p><p>完美主义者通常更加看重未完成的事, 看重缺点错误, 急于做出改进.正因为如此, 这类人经常忽略自己的优势和成就, 忽略过程的享受,更容易成为所谓的rat racer. 另外, 总是会后悔: 如果当初选了那条路,结果会不会不一样? 这种All or Nothing的思想是病,是一种对充斥于生活中的失败的一种失能性恐惧, 尤其对于我们所关心的方面.看得越认真, ta就伤害你越深. 另外, 通常会很急躁地,仓促地急于完成这些所谓很重要的事, 最后效果也不好.</p><p>是病就得治:</p><ol type="1"><li>Permission to be human. 你是人, 不是神, 给自己一个做凡人的空间.尽人事知天命, 随ta去吧.</li><li>从A点到B点一定是蜿蜒曲折的, 不存在最短的直线, 否则就违反了天性.如果你希望journey是直达的, 那么你在白日做梦.</li><li>Go coping, go trying, go hearing.</li><li>Learn to fail or fail to learn. 吸取教训,下次不要掉进相同的坑里.</li></ol><h2 id="自尊">自尊</h2><p>自尊代表人对自我的评判和感受. 很多时候明明已经不错了,但还是经常感到痛苦和低自尊?这个悖论其实取决于你的自尊中三种不同层次所占的比例:</p><ol type="1"><li>Dependent self-esteem. 依赖型自尊是指需要别人赞扬,将别人的评价作为自尊的体现, 与他人比较来评估自己的能力. 这是part ofhuman nature, 只是或多或少而已. 高依赖型自尊的人很可能有完美主义倾向,总想在别人心目中留下完美印象.</li><li>Independent self-esteem. 独立型自尊是指根据自己的标准评价自己,与自己比较来寻求自身进步. 这也是鸡汤文最喜欢说的: 不用和别人比,和自己比就行了.</li><li>Unconditional self-esteem. 无条件自尊是指足够自信,不需要依赖他人或自己的评价, 既不和别人比, 也不和从前的自己比,对自己当下的状态十分满足, calmer. 是一种just to be, just to exist的感觉.这种超然的享受事务原始美的状态并非漠视他人的情感,相反会更同情怜悯他人.</li></ol><p>随着年龄增长, 第3种的比例会增加, 但是it takes time.</p><h2 id="reference">Reference</h2><p><ahref="https://www.bilibili.com/video/BV1kx411S7ZU">幸福课</a><br />Happier: Finding Pleasure, Meaning and Life's Ultimate Currency.中文名《幸福的方法》<br />Choose the Life You Want. 中文名《过你想过的生活》</p>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
            <tag> Predecessor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Finite State Machine</title>
      <link href="/posts/finite-state-machine/"/>
      <url>/posts/finite-state-machine/</url>
      
        <content type="html"><![CDATA[<p>有限状态机在本科数电实验接触过,但是最近在做LeetCode第8题时才发现其妙用. FSM通常可以用5元组<spanclass="math inline">\((Q, \Sigma, T, q_0, F)\)</span>表示:Q表示有限的状态集合, <spanclass="math inline">\(\Sigma\)</span>表示有限的输入集合,T表示状态转移函数, <span class="math inline">\(q_0\)</span>表示初始状态,F表示结束状态.</p><h2 id="deterministic-finite-automaton">Deterministic FiniteAutomaton</h2><p>如果不知道DFA, 那么在做诸如LC 8/65等题时, 面对浩如烟海的corner case,即使写出了代码, 想必也是一团乱麻.</p><p>以LC 65题为例, 给一个包含大小写英文字母/数字/+/-/.的字符串,判断其是否是一个有效的数字.</p><p>DFA的思路是: 开始是自动机处于初始状态, 之后顺序读取每个字符,根据当前状态和该字符的转移规则转移到下一个状态,读完整个字符串后如果自动机处于某个可接受状态, 则合法.如果读取过程中转移失败或者最终自动机处于非接受状态, 则非法.</p><p>第一步就是要枚举所有的可能状态,通常对于字符串匹配问题可以考虑用字符串的不同部分作为状态集合.例如本题中一个合法的字符串应当包含以下部分:</p><ul><li>符号位+/-: 如果存在, 其后必须跟着数字或小数点</li><li>整数部分: 若干0-9组成的串</li><li>小数点: 两侧至少有一侧是数字</li><li>小数部分: 与整数部分相同</li><li>指数部分: e/E, 符号位, 整数部分</li></ul><p>所以状态集合包括:</p><ol start="0" type="1"><li>初始状态<br /></li><li>符号位<br /></li><li>整数部分<br /></li><li>左侧有整数的小数点<br /></li><li>左侧无整数的小数点<br /></li><li>小数部分<br /></li><li>字符e/E<br /></li><li>指数部分符号位<br /></li><li>指数部分的整数部分</li></ol><p>小数点有些特殊, 其两侧至少一侧有数字才合法.通常来讲小数点可以转移到e或小数部分, 但是对于左侧没有整数的小数点,其右侧必须有数字, 不能转移到e, 只能转移到小数部分,否则违背了小数点的规则. 例如<code>.e1</code>就是非法的,<code>3.e1</code>就是合法的. 因此小数点的状态需要分为2类:左侧有整数以及左侧无整数. 那么为什么不按照小数点右侧有无数字来分类呢?我认为最大原因在于状态机是不能回退的, 即如果已经访问到了小数点右侧,那么无法结合其左侧状态进行下一步的转移.</p><p>假设右侧有数字的小数点为a, 右侧没有数字的小数点为b.例如对于初始状态的输入<code>.</code>,能否转移到a或b都是<strong>不确定的</strong>,因为此时无法判断小数点右侧是否有数字. 如果采用左侧的划分方式,转移则是确定的.</p><p>第二步需要找到初始状态0和可接受状态2/3/5/8.</p><p>最后需要根据合法字符串的格式定义转移规则, 并画出转移图: <imgsrc="https://img-blog.csdnimg.cn/3f282f79feeb47d799fcf0d02a5a4867.png"alt="状态转移图" /></p><p>为了写代码方便,通常用<code>unordered_map&lt;state, unordered_map&lt;cur, state&gt;&gt;</code>来表示状态转移表,只要将上述转移图翻译成代码即可.</p><p>除了算法题的应用, FSM与KMP算法和正则表达式都有着密切关联.</p><h2 id="refs">Refs</h2><p><a href="https://patterns.eecs.berkeley.edu/?page_id=470">FiniteState Machine</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云</title>
      <link href="/posts/cloud/"/>
      <url>/posts/cloud/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5446cd6267fe089d7d82c0073efa122dc6cc34a53b00c810cf410228e22a6208">418fac4f173397084caccc18ab9f089e707caf583bd354c6ef7976737c697a3f3b9a8cb267430489472d32a541523ccda228af51cff66f4307241ee65cc0ce480cfc012e360f7934ea080ddfd65126c083ac1847b9e9928e0c5dd43e0e384be72f2ae72b2a910da86d76684e1d84b71fc9c985f85cf65d82330ac5e079734cc49c311e5567e7eff5baea52e47654ab005f940aed0f0ff0199b8563e775053e42eb06612e09e91f89d19674fdba99b9f92f28247add1425fc212cfe731826fcface14bdbe8fcfd987a8118aaa090cfae56bbf8a0bbcb95386be2b9a8ce169e2a8a469bb526e9cec6bfe4dbea89b4abfdc5755d6476cec378c24d7b518d89584e674f796eb57ff0108fac408a016d1877aeec062f4a3097b09aaba3af2d54b4d82f862787e51d7efe06db029a9716ba0378c1a291976fa746e37d3dd9a5a071be0b6d7d49180ae378b9e3ab18087a05e46b14cefffb5794bebca7c1cd05d1aa515bbb7ee36b5ae65fdc36688ff1a6f3bfd3008e9a2514b4f3ce6a342f0676758b3595b1dbfae23316cb5578ad3bd1c3cf055226aa2f795fb652aad446cd92df1ce751548cc1b6c577e71cf36bc8f1f41763fd33272192f01914a3e84d70e5cd4d43942cd7af66fe903b606601501a43cede526f56c645573b69242a03d0cb27d9870163ce2361cb92e4e14f92251cbb80800e81954d6f2b0ba79c9601c0303342a8f47c060971cbb8ac48ba5224909cd6c212fdf1916c7ef2a644cdc1265af4f669efaeabdf54ac3013f012cf19c391355bbff656928e441a3eaf4dba8b2ab30a3e48f315b5a7341722c73ff86d8be981acdb9d2cd02f39fded59304517a4d196e2307678456cef88e1240aa5b2afca94b355f3f34d4f2a9966d22d8c1ccb85442bada928c728a9e4c02c360e59e948826202cc86cd70edd318adf56ce33ec1a90192a74759bb2e6285f6850be04fcfb052cec6a7a592c79a01eec6ff3a51a96d11d16e94fa5f6781ad65c56f6a2aec86a9292a3d5ee5717d619f57c978ea0cd02f1d8a1e925b0157dc5cc629eb94b5ce337e54c99946180c4847e83c1b9aaec9b76a09c9868be06dab56b9a5d9f04cca63ab15ef2331aabd61b9d31f5760608c32874dd0b34c1cec644fa35e85fe131cd0206596667c7ec29fbbb0790e234c649bc8d2dc66f049fd7b735bd82fda03062e7b148f544c997782d7a98c6af993314aee2b5d0e4517244f445f8f9384190ef6f387bc7a5ea3f8f44834091dc08e462f616b41d89f67ed274f813035e985b9bd5eafa5c2658345cc0b34409072cc8ce5437e5ac27cf224a36b477207b7fa89182c7a58ce93a230925d2f742e96e38e8dc2da07b6713ff7d8e64219daa569eecf1f74110ec599c654d761da8265c99134c130e805e5e46d4a00aa6a1093b78143a5a42f5da155ba61f66ef73f78c0a8e97accf2bd59d4e87c0c6f889659582378834a350d6a4d5bc59e82860e715c52910a67c5f1558953179b53d5c9c82ae0fa5250a18f8c13535636fc4ed07b99ba6490c7a14d3cf5bb1db93fda6c8fc344b564de09881901c0fa3f76e232afc1a489af6f714ed95af9e6ee4155c383d3355d0175517d94cda4018e63ced9ddee0a7fb946b745de6467ec16f3dc6fdafb09829d565c975eb25d4084e439208e9776d748b2b9329583ef3fed00422317dfdff98d959efa98120cf1707e754fb62a4325e966efc8a7d50f919932af07b4dfdb4326b53eee7e65231239621efcf67628264532c2b27b649890cf0699839e0d6b2f0877a26c4bdf5c5b972c12f22d4ec5f5bb6d118a75c48e8ed88389463d2990e5f2232dbbbf9a226ab02f583e8867819c99eb4796b70c3f762262afe3bde3678e720ed0a0dc0d7ab0720ed773d6ecdbf957d6678e47212e36dcf993b0693a3a33316a8b419eaf98270cd0578b2e15f7ff421c7adc0f11d6c0664e2f1ddc1f86cba94827f6e9696429b1dcd1a0f3e68cc847d4f2245367597e50a08712a1864b3e98637dc2800a68d2c641398331cf4ff44304950b1a83d83879795e8dff180f108203c98963416dc307db458543dfb34f8b364b9dff59fb0cc650b6adeebf9ee59168f544cb306f6dac64a958eaf9e366248d638e1d2110f31e76ffe1466b27353594514b170f6a641f79f7260c7cda509546d5cd312aafb71010faf34447d8f1e183c892f116dfc4cfe0dad6590e8c0d17790e1eb98f6e2dd409dcc61858add3bd50a5e2b50752020e67728bece363bca06c8bc6ea2cf8d98863623deb5840406c1ba4c2e8af44e41efc929aa8946fa264ed3d1acdb053c987a1177bb09fff198d1df0ec6c5e22651c3a1410f37abc835750d08912cd7f4e96e1dafccdf19e6bc2ac0599d3efd1aee8baa486fa691571fdced0b4ff91d2693ad171ffcf52dd5cc9e8f6e02f65e175216c05c3cf007b4b2b226d5da1addbc0a2186b21880eb5e639005c46420015fa6b4d5abeb90be8471cd9d6be4434e470da4df73c0a1853ac1c760047fc19a3fea6753b23b1eb5dec60d45acf578f110a5604ac079fc55353c97d63beb18e466ab5f79ba061637c8abbe56a1922d1769aa152533e2b82f740731b4318170557b3816e557e934af83d5eb44c2407c442a48194023a6412bb784bf0017da0240084a53c5fbbbd8a11dcfff4b04606864dd5198fb82d4173609c313aaa73b42d0fd28a7cbb8b880f2361a834c50b414df4935a16d0938d1c1ab68ecdb1e143058ec859beb75af67b8eb456d6d7deec78283d833531210482a700a696c25b8684c9aa5ac87c21b54d5d8ec283f578d84bd852a1c0cc4eaba059e785bedff962ce9141f28be3719a1481aeefccf93b5aadc32338406d08f6388f623d8e12f6874fda22e1265ce844ae38cf2e2bbff9701f115bc384f63d0df112b3abb1f4914701b252dcd4118d6650f6a080d6799231abdd1d49943ee3bccedc41fb949192ec6bdaac7a1dd0017c0be749bc866c97948abc1c683c9030b80dcbff86a8d7e3492bc89f2fb3522be034aac0162e71efadc1bf09ed88e502eb31de49bf8e4ac3ee6994a9a10592498bb3b9b0f8c2e3ff0b13760023a0b4113c3602603324c4abf0172d0b6b94e5b2490221836bd0e24e3280219b3ab32b75c0f18988185a301b077bb38fde7f8c60ff4b5cf2198126312d9d1dc8e046bae80eaaa0dbe7acefd8d81c3808d8f0b5fdbad6df268d8cc296f3998dd8793cc9b942632a4be330bc55c67c90f720e6b07677a4f2645706eedef3a7b41db7880f02d5bc0b0922299bea0cc39b02f2069c284c1de5a0623af0ace8c058333e4aceda9dca726e1f2fb5adeb34af21403cb71dbbeb6053eb65081fef0cb5a4bb90dc438ba3586a084a0c7d07f2194cac783338cfe265b0811a4e06c3a0625717480b6168e26e62db1f85b91ccf2f767c34222b963175fb4ed65e70acc56a5c89ea6c294fb83ba362001efa9845ec5a6aaa73f520e452ceaa1b0d16873dbbfd87aae0ef37ac8ffde931ca40d2e08b9f754fbaeadd697f3220e0f48a110006ecfc6f61df64aa2b4c763adaa36fd8d021439dead43aaa107850e72521df5ab3f21302bb10cfb48b31fc2fac4450e6708604de240c94a5fea28cb2337cac2dead8a7adbe902a7c6a3bc32dbfafdd8dd5e88c9dc51bc675b434e4c64ff00438a8f9f6f7dc43f450c1c46dbafd60beda6e34db937899aec09d7698705780f677e9a3cbadb68a9e61d55fba72278c4f1be729ae48a87cf7d552cf75484cc7f5af35f03c0d32a23ec04f3e8a3cfa46311d3ad7df8f87b336c50459d43abe0d2fce158d46e6a67dd7c21c78d9f1872b34073d298d52d46e0930cd6524f6e04cd97e1912d868ff565051dec00253eb6067cbedd522d69c370a7fcb30d45cbf01b42c0009b7bc4ac93d5dd3f14b33144f597ea07e32006c844900bcd98f8403aa059d48f27d921f74bdd8013a57669dd25266a0fe6ad39cdebb2a03deca2a3a0301f1f71490ea48ee6b2e1140aed16d6734a9f471c5c150a67fd1717e64a84d83ea25ad4ea73267b58a8177bd6b56977db91f3494cafaa916e85571a9cf95a48dcaa2e02ac8f8128fe04d9786d2be7a62df01353ec7c65cb66230e715919acc02bad1315ee7d1bf8844993c09a0e8389562b0b2707bdad01907ca60d970e4ae6802d027dc0c5cdfc544be6be601c96e2e399fbfdac0ebd8e2822d3ba448762e87e8fee7425145bd23101d5046bf6ce026cf979879f10a02b7491f46fd801f4fab088f9e7a8da2687ee13d36ea460aa07e7675203efe9504be9836ee8106e6533d089e1013095d056ea3d5f094351119afb3200bdca851ac7f3ce2573a50c5f8ea3cf15c89070dedb5f669c4c68a09b4a7c285bbfa8e6bf898698a6170317baf83e9820d29448af5e2d882c860ce1a29602ed75c9c503b72ad238a8f8198f11afc3215e04959673026078d66b5489e878bd212604a8622dcae005c175b1ddb7d020e6f110dab0eaff876ba010913270aa9c1b00b12c17f51cb58b92af75695b1d585baf551213cce568fd68ab1a3293ed14e019e60472ce618158c399c3dee50ce85dd8e82d62ab892bb28cc904b46abc8d1b226bfb0d6a548340556949d87e5e0551581156d22aba1d93a78dfedd1ca45f8cf63f2a7aeef6870e1020cc6d1a9d97bf9cfc7cc04a73bfcbbc9e67d2bbd28b564878fcfa788c3b473bb32950f5dc4e4ea23cf09b9d31eb5aebede3b04b3e4639a09939dd84f1978a7c74f9d4b9b40775c6e1298fcc780494de550dfcc8ffe3f670f35960b55f16d41b0ee6b1123d4db149d9463f3bb85e2189a0f8a18c173bb158c31e6c334cd822f4c639e533428468196adadf9da0310d17bae1d0688727c2557815a35fe6f0c838b6cf9312d646b98cbe19b1f06f5a93b7769901bd4e26bb63a1ca17d2f2e0577ef6f30f52b8dca662a6d860aac384daea9433b1830fd831c30c102c0303c5c49973609ecbcf7e3bbce43967c5971a2ea17dac74be47bdbb7a2ba7fc8a7e3bbf02b7032cdb89902afee03c7c2ea8397a0eaf4ffec5f8fac64be218f9f57b8d3e1577f743142228192dccc517f69008fcae3a3509e385f78f05180302c9b0d933d7710cd5d67a88f5360f931e4e09802a1b9140278ab734dbdd4f08fac9d7e3c1afb6528cfd6bfaa4160821df5e4fc5beb9bb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成年人呐</title>
      <link href="/posts/hard-adults/"/>
      <url>/posts/hard-adults/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8b60e3164406eb546344c41484457cbfb70eb6f485f8621f8d4cce0f0759bfec">c172f4ee74b2b6d246b20cbfdc0b877e3c5bb7f712e97548f8a290a5810ed13ad1a232e9bac13f74c6bbbcacde9ec62adcd72baa74dee248412382d3ff42cac7c780a33e54885d70c7e27579afb0a5111e8bd43aff9a8ecce4c327a4f09d0de0260e31ab1c2ee7b7060e64cfa85a349620e4ae75fb2974383a01bfcabb9955419e6b4517386be7436167ba768b9b67e10ddc9a84db80bc77cf6b97e0ecb6af963037625e6c5bc82b390dcbdf118c0fa48120bc50fb21f87ee02114d8ca2f30abab8819aa86b00da62bb1a7ace710a0d3438b2b5584ab79657102a9d62951a107232160748ffaab30172f819ae99d3de000d572a7d1ccc87730689e777d9d069c4ffc105a2dd41ef989bb76b18b6b804a8585e7757974fa9052d24a6310f8a446520a616d20b448b303c3c3ccbb84a1cab97a2dc5df8837a49c9bc2e5027ca9853baf9b57467878ffb7a5e1a29d65df2e5ee2f42eccef36c9a83eda2d40535fe1cce3c9b992a105696eb32139166409b7804e9b727eac6e2d53b5400a2bc1ea5612313b2e1094ed732398a719e21fd0c5b938a7c06bf79c11be7acc8126b7aa8858060274a332c965bf27181c0901526cb713a9d198a30cbd04977a3b7cce913b3ad402ceddf3a488a370b2413e043174e486fc8f8e64c63ffd4ead34d6f279d98bb05e105e8583e4ab979122c17186e50a1ac0b3c8585128c8f63b68d746d247b1b566e6ee75436f84adf1866cad60d405a8f0a69c55019b7d7b95cfdcbec0835da7d41f4d7dc383a7e732c8ee9122a5f255c23db2c0d6ee0935bf4518ad26656dd46842ceb4388a9a61870c0065e2c159bbf0340058d79f3a188e52cf742d2a222046d61a1b52b3d021a738045cd2bc9c0c0ad49202b05962ba480df906707f41b50495e5f1fba35db21fa6aad8eed097e44ce1e7838bf8323099a6cdfedc2d6afddc564646398096a70513f0044f04d4144e400d7d418655a693c311a397b6b9fc1e7b83ec3dc212c97d35cc3761bdcfcc5c77a10fc38544b1842c850d5b6270aa3499375481b15b75f4c4f227092f3756176df9046e20446659cbc8d03e45841c4cb816d656b6f28db5d9f648da5318f0bc424af4559f3af818bb26c3ab7b0417d92d167c30f173601f31ed673fd78ad275a89becc2479c06d2bd6c13c7ddd2dee6988ba42ecf05e8c5b288bcb4503b8ddbc89c9c15e4858b0f2f30a7286b0f51048c9d9cbc6b53aa07443ab435aedf09c5a68ab9b6fcf81f8af9077a40c38f28f1819a7aae014ef08a605f07e1f22d91d8256f81c4ede3cc04a8c161aceefdef9e3da60fe9248e77281c27662244b141864be2e63e55ba9d957252a9f0193c9433fb06ad88664441c3f4574071a36962d2ece0f6eaa7378fee8e249c1b3b4994593e2d8487f1d7f1e2c36452e4b9f1ab7f15fac0d3464f6a7a3c177ab9195830910d496f4b7ba27d3dca3243ab690a0a9cb73660017e3f3302da3fb855ed90787bf2b3a3429ffbdecdc6d62045ffa75929ce8eb92b3240533f942df64b01fee0ccf9c57764885bc41d839423dea3dd47c7a503968fc16f9fb9c7bc7ebb510038a2720eb11d370604342a35930e1d947c0af2c6f5a1fc398177ad9de2a3528b459395e9d65672f36d9d1079a96f39cf73936e643b771a327a414c211f7e306ba80c58da8da2aeb6761087bdbe9e37099c1f04604ad532a08f0ed0c7ccd09600012e5e16edabb6a961ec7acac0ba81fe155ad5bce989453e1a88f1470420b545c95bdf1cac8d7ac3c0989a85e67c0a1322907ebf7ad4279cd4d50d98fec4fc1f27aab7405bc76677362bf41ea9134211442536bf16f482dcb97929177706116f2a89f09e24594b5a851672085c6b457b0d7ac2bfd3a8bafc56249d1b0ff97b2f6adb403c1ea2d18de0e1db6c89b57933612de266b8fb35d07d2812f6be499e91544d3a753bdf53e349efface336aff8eacb82616e0ccf496bc8b4a09cd18f67c22211399fa300e495fdd7130d8dff283a0cce02333a48cea58e6b5a96f2f1c2e5fa634c26c6b9ca75e64179650530ce980cedfc97f4a5ed1548db8917142cfb253e6a0d71f32cb9ed7775471804d2c86fcf361d9087fedf3b15ce9e6600b4879babcf826418ad5ed9fa425a2794331b5415bf03f9554a77b3491200390473e7dd037721442622ce8c66910da8470ec5b9c0d97dfe0202f4c365452725d89131a69cc9dd3e1199493b70efc97d48301d0a98e0ed0fd1d75aaa4cf05ccc4b17aafc28533bf5400d3d2ff7cb39aa54ae8c0bbd16e9a2baf4c43e4d7785795a550ce7be890c9883dd9872283cc0e98694cd7e4b420f560293756901bb055f5505e9be58d908fc356b9160eed99e5ffc0b922af7d19410d2419083d8150a59c955be35210f7f9423c2fae27d6026fda6f087696bff83a8a02046540af84bc804de599abbf8f8b1e861ffe823c48b4b52005f2688f8dbaeb3b8016d90b9785468a8db0efed0ad80e3c4a04a19ab5268267385b455c38c276ab307fbe08939b4725aaa5bb87aa875a204822ea03b1e9370b3979c2d367d1f3db99ff09176fb7ceaf1d4257d1c429cda167c6bb5407d5ee4f904f95c9bfc8fe99f5a97011877f2f992e3ba797d22b10ca862ca6bb22e8b7ba51501ffeaa3268e6daaf6cfcab6a5840dfae382e5ad702915c430d5b3d776144a2c21fd199d81c4e42e8bfcb2982df3d9232908a37f1cac423a88699c9687cdfc384b5821bb2a331d6ab417253c4f88d50ceaa01eef6d3b23cd78f8341fe4359351424e00a61cd7a59cf5bc4031e31d3be509027099d8a129e3f305c021e7e75eaa8f27c1243ae8546a785e27ccfd7ef4e1f05ec310b7baaa914dd12040afc071f04115ac629fce8b38e16f9069e68bb992f6b67591c8ca532e7e60f30dd719dfa80933af72df7d9b150e53d77509cf0f0981fc6a16155491ebb423a30b2eaafbd5da2c60c243d9319e224e1d7e549eeab43af0eb1a5fdb1e6903f1015ee81f664e607a433b8823639801cc855a1a262c2ef8e8f134c8a290d6f8115b1ce75bc679e97c4305bf6d150ab3581ea802c06fe76943297e731d6b5e7f33439a013f00fb3a92e96da66b20bdeeb2eeeec932eec0fa4cf9db01995655487e8b1331718b7a7ae897752b7b9100031eb13f0fa9b612a875cbab7d0919306d4605629a1e84c44f8f38be98ddfc29eb53854f10923efd2ff8e6dcf2eba131e6297dec7a629070bc007bd7cc551b736dc4680877bcb18acf82fea9783a1880b6ff71c08def5a842509508c20964fc4927bf4d0f67c508ae42385b856f87cfc82fc235b86f5715d2964d9d5f1a7336295eecae5d492da6cdad76baf6b2e0aa500d572fa340c47f772af63fac2653f4ad2c467b96829bf4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中途岛海战</title>
      <link href="/posts/battle-of-midway/"/>
      <url>/posts/battle-of-midway/</url>
      
        <content type="html"><![CDATA[<p>中途岛海战是第二次世界大战中太平洋战场的决定性战役，其地位堪比苏德战场的斯大林格勒战役以及中国战场的平安格勒战役。从小学至今看了无数的资料却仍然稀里糊涂，但愿这篇blog能解此心结。</p><h2 id="战役背景">战役背景</h2><p>1941年12月7日，日军偷袭位于夏威夷群岛的珍珠港，以极其微小的代价重创美军太平洋舰队。不过这次偷袭并未对美军造成致命打击，尤其是美军航空母舰依然完好无损。为了逼迫美国进行谈判，日本决定彻底摧毁太平洋舰队的航母。为了将航母从珍珠港引诱出来围歼，日军最终决定通过“围点打援”的战术在进攻中途岛的同时伏击并歼灭美军太平洋舰队，即所谓的MI行动。</p><h2 id="战前准备">战前准备</h2><p>日军方面：由于珊瑚海海战中祥凤号沉没，翔鹤号被重创，瑞鹤号也需要休整，因此日方将剩余航母划分为第一航空舰队（一航舰）和第二航空舰队（二航舰）。一航舰由日本海军最强的4艘航母组成：苍龙号（常规情况舰载机52架）、飞龙号（常规情况舰载机54架）、加贺号（常规情况舰载机63架）和赤城号（常规情况舰载机54架），此次进攻4艘航母共搭载248架飞机以及12架侦察机，一航舰包括第一航空战队（一航战）和第二航空战队（二航战），一航战包括加贺号和赤城号（旗舰），指挥官南云忠一中将；二航战包括苍龙号和飞龙号（旗舰），指挥官山口多闻少将。二航舰拥有2艘轻型航母隼鹰号和龙骧号。需要注意的是：此时的日军飞行员毫无疑问都是顶尖选手。</p><p>为了掩盖真实的战略意图，日军制定了极其复杂的攻击计划，并且联合舰队司令长官山本五十六要求路途全程保持无线电静默。一航舰的主要任务是：夺取中途岛，摧毁岛上的飞机和机场跑道等重要设施，为登陆部队扫清障碍；寻找并消灭美军航母。因此南云将一半的舰载机装备对舰武器（鱼雷），防止美军航母出现。二航舰负责占领北边的阿留申群岛作为佯攻，试图声东击西来分散美军注意力，行动代号AL（Aleutian）。</p><figure><imgsrc="https://weaponsandwarfare.files.wordpress.com/2020/06/midwaybattle.png"alt="1942: Japanese Options | Weapons and Warfare" /><figcaption aria-hidden="true">1942: Japanese Options | Weapons andWarfare</figcaption></figure><p>美军方面：1942年5月，美军已经部分破译日军无线电密码（据说破译了80%以上），还通过经典的“AF缺乏淡水”钓鱼行为确认日军的作战意图，因此总司令尼米兹上将决定提前设伏，将美军航母部署到中途岛东北部，在日军攻击中途岛时发起偷袭。珊瑚海海战中列克星敦号航母（CV-2）沉没，约克城号（CV-5）被重创，但是美帝损管仅用了3天时间就将约克城号大致修复。美军3艘航母分为2个特混舰队：第16特混舰队包括企业号航母（CV-6）和大黄蜂号航母（CV-8），由斯普鲁恩斯少将指挥；第17特混舰队包括约克城号航母（旗舰），由弗莱彻少将指挥。5月28日，第16特混舰队率先离开珍珠港，5月30日第17特混舰队紧随其后，6月2日美军航母在东北部设伏完毕。</p><h2 id="战争过程">战争过程</h2><figure><imgsrc="https://upload.wikimedia.org/wikipedia/commons/5/5a/Battle_of_Midway%2C_Movement_of_Fleets_%28ENG%29.svg"alt="Battle of Midway, Movement of Fleets" /><figcaption aria-hidden="true">Battle of Midway, Movement ofFleets</figcaption></figure><p>战斗前夕，中途岛附近出现大量的美军活动迹象，由于前期的潜艇侦察并未发现美军航母驶出珍珠港，因此南云认为美军航母仍然停留在军港内。1942年6月4日凌晨日军所有战斗力量就位，0430战斗正式开始，一航舰出发轰炸中途岛，4艘航母以惊人的效率在10min内放飞了108架飞机，队长友永丈市大尉。同时仅起飞7架侦察机搜索半径300海里的东部180度半圆形区域（能覆盖才见鬼呢），由于气象条件不佳，加上南云认为美军航母在珍珠港没那么快出来，因此日军的侦察形式远大于效果，最终因此付出了巨大代价。但目前来看，7架侦察机中只有从利根号巡洋舰上起飞的那架晚了30min，其余一切正常。</p><p>0532南云意识到自己的一航舰被一架美军PBY飞机发现，意味着中途岛的美军飞机可以提前起飞避免被友永炸毁，事实也的确如此。美军轰炸机提前起飞后直奔一航舰，只留下18架老式水牛+6架野猫战斗机负责岛上的防空。0620，留守的24架美机在距离中途岛基地30海里处拦截日机，被日军的零式战机爆锤，13架水牛+2架野猫被击落，日军轰炸机随即轰炸中途岛。0634日机开始轰炸，美军防空火力击落11架日机，击伤14架，也因此导致日机轰炸效果不佳，飞机跑道只有轻微的损毁，因此友永丈市请示发动第二波空袭，彻底瘫痪中途岛。</p><p>0710，日军发现第一波（中途岛共起飞了4波）美军飞机（6架TBF+4架B-26）来袭，30架零式起飞迎战，美机投掷的鱼雷均未命中，5架TBF+2架B-26被击落，一架受伤的美军飞机试图撞向南云的旗舰，最终差之毫厘，日本仅损失2架零式。此时南云收到友永第二波空袭的请求，南云可以选择让友永返回航母补给后再次发动空袭（大约需要60min，中途岛可能用这段时间重新组织防御）；也可以选择使用航母上的预备队前去空袭（但是山本要求不能出动这些飞机以防随时可能出现的美军航母）。此时7架日军侦察机（按时起飞的6架基本达到航程极限）并未发现美军航母的踪迹（云层帮了大忙，从筑摩号起飞的侦察机没有发现企业号），而且自己的旗舰刚刚差点被中途岛的美机撞到，所以南云认为中途岛才是最大的威胁。</p><p>0715，南云无视山本命令，开始在下层机库中将一航战预备队的对舰武器（鱼雷）换成对地炸弹准备第二波炸岛，俯冲轰炸机则直接在甲板上安装炸弹，这顿操作需要大约90min。0745，从利根号放飞的那架晚点侦察机报告在中途岛以北240海里发现了10艘美国船舶，南云吓傻了，命令停止换弹（此时有64架还未换装炸弹，换装了15架左右）并开始分析研判，有2条路：其一是立即起飞所有飞机（挂炸弹的去炸岛，挂鱼雷的去炸船）；其二是等友永降落后再去空袭船队。</p><p>第一条路不符合日本海军的作战操典，而且也没有多余的战斗机护航。由于无法分辨该船队到底是普通的运输队还是航母编队，并且按计划船队出现的位置并不属于该侦察机的侦察范围，要么侦察机偏航要么报告的船队位置有误。如果报告属实，那么该船队很可能是美军航母编队，因为这样可以从侧翼攻击日军编队，可是如果是航母编队为什么要逆风行驶呢？因此南云觉得大概率是普通船队。除了这些情报外，时间对于南云来说非常紧张，燃油不够的友永编队大概在0815到达并且最晚要在0915降落完毕，整个编队的降落过程需要30min左右，所以最晚0845就要清空甲板让编队开始降落，因此南云需要立即决定到底是选择第一条路还是第二条路。南云从0745获悉美军船队到deadline0845大约有60min时间，但是排队放飞所有飞机并清空甲板需要45min，所以最晚0800就要决定是否起飞，因此0745-0800中间的15min才是真正供南云决策的时间。</p><p>0753，中途岛的第二波16架无畏式轰炸机接近日舰，日军派出9架零战，美军飞行员战斗经验欠缺，因此无一命中并且8架被击落，日机损失1架零战。在0745-0800的决策时间里，日舰还要走位躲避美机轰炸，虽然也可以起飞但是风险较大，并且此时45min的放飞时间肯定会被拉长至60min甚至更长，意味着即使从0745开始起飞，0845也很可能无法全部放飞并腾出甲板，友永丈市编队大概率就要坠海，显然此时先让友永降落再去组织攻击是风险更小的决策。另外根据侦察机的报告距离来计算，美军船队至少要到1015才能进入攻击日舰的作战范围，因此南云认为有充足的时间回收友永后再去攻击，加上南云本身的性格非常保守，所以选了第二条路。</p><p>0810，中途岛的第三波15架B-17从高空投弹，IJN闪避，双方均无损失，飞龙号差点被命中，下图是其风骚的走位。通常在这种规避转弯下是无法放飞飞机的，只能等待美机攻击结束后再放飞。0820晚点侦察机报告美军船队可能是航母编队，机库里的飞机为了攻击美军航母编队，又将炸弹换回鱼雷，由于匆忙便随意将卸下的炸弹扔在机库中。但此时仍然无法直接放飞去进攻，因为友永编队大半还在天上，因此南云只能等待，别无他路。</p><figure><imgsrc="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Japanese_aircraft_carrier_Hiryu_maneuvers_to_avoid_bombs_on_4_June_1942_%28USAF-3725%29.jpg/1280px-Japanese_aircraft_carrier_Hiryu_maneuvers_to_avoid_bombs_on_4_June_1942_%28USAF-3725%29.jpg"alt="IJN走位" /><figcaption aria-hidden="true">IJN走位</figcaption></figure><p>0827，中途岛的最后一波11架老式俯冲轰炸机来袭，但很有自知之明地选择攻击战列舰榛名号而非航母编队，11架日机迎战，美机无一命中，损失2架。与此同时，一架美军潜艇鹦鹉螺号向日军雾岛号战列舰发射鱼雷后被日舰发现，雾岛号躲过攻击，美军潜艇跑路，日军岚号驱逐舰离开舰队追击美军潜艇，“带路岚”最终返航时带着企业号的美军轰炸机（麦克拉斯基少校）找到了日军航母编队。</p><p>0837美军攻击结束，南云开始回收飞机。0910，友永机队全部降落。不过最迷惑的是这段时间南云的编队竟然朝着美军船队不断行进，而且日机比美机飞得远啊，为什么要主动靠近呢？接着，南云只需要等待45min放飞飞机攻击美军航母即可。0918，美军航母编队15架VT-8鱼雷轰炸机来袭，被零战锤爆，最终全部被击落，30名机组成员只有1人幸存，日舰没有受到任何伤害。0940，航母编队第二波14架VT-6来袭，此时停在甲板上的日机重新补给完毕，满弹满油，事实证明日军侦察机报告的距离有误，美军完全不用等到1015就可以打到日舰。美机9架被击落，日军损失1架零式。这2波攻击虽然没有造成伤害，但却拖延了日军放飞窗口。</p><p>1010，12架VT-3+6架野猫继续来袭，美机采用了著名的萨奇剪战术击落4架零战，仅损失1架野猫。美军的护航战斗机吸引了大部分零式，使得轰炸机可以抵近日军航母，在日军航母上空巡航的零式不断加入舰队东北方与美军VT-3和野猫的低空狗斗，造成日军航母上方防空力量空虚，这一波美机损失10架VT-3，日机损失7架零式。其实这一波又一波的饱和攻击并不是美军安排得当，恰恰相反是由于航母舰载机起飞管理混乱造成的结果，也算是因祸得福。</p><p>1020，50架美军俯冲轰炸机（好巧不巧，分别从企业号和约克城号起飞的2批编队飞了不同路线，并且约克城号的放飞晚了30min，竟然同时到达）几乎没有受到日军防空的零式拦截，这一波南云好运不在，加贺号被命中4发，并且引爆了飞行甲板上的满油满弹日机，苍龙号同样如此，赤城号被仅投的1枚炸弹（贝斯特少校）洞穿机库，引爆机库内未被妥善放置的炸弹，只有友永所在的飞龙幸存。1030，南云将旗舰换为轻巡洋舰长良号，日军此时已经注定失败了。山口多闻意识到自己的飞龙号是唯一的幸存者，开始组织反击。</p><p>1045，飞龙号的6架零式+18架俯冲轰炸机奔袭美军航母。1050，山本获悉战况，召回阿留申群岛的隼鹰号航母和龙骧号航母，以及其它佯攻力量救援南云，可惜远水解不了近渴，此时美军航母舰队向东行驶远离日军。1152，美军雷达侦测到日机编队，战斗机升空迎敌，重创日机编队。1210，日机剩余的轰炸机开始攻击约克城号，4分钟后约克城号瘫痪，日军13架轰炸机+5架零式被击落。山口多闻自信地认为已经干掉了约克城号，接下来就是1v2的局面了。</p><p>1331，日军第二波10架轰炸机+6架零式由友永带队，山口多闻要求再干掉一艘美军航母，这样就可以出现1v1的黄金局面了。1430，友永发现30海里外的一个航母编队，看起来完好无损，他认为是企业号或者大黄蜂号，但是美帝的氪金损管使得这艘还是苦命的约克城号😂，美军6架战斗机迎敌。王牌对王牌，萨奇击落友永，日机损失5架轰炸机+2架零式，美军损失4架战斗机，约克城号再次被重创，1500舰长命令弃船。约克城号很坚强地活到了第三天并差点被救活，可惜最终被日军潜艇I-168击沉，同时参与救援的哈曼号驱逐舰也被不幸击沉。</p><p>1545，剩余日机返回飞龙号，随后山口得知干掉的仍然是约克城号，随即命令飞龙号撤退，准备休息后发动白天的最后一波攻击。又一次迷惑操作，飞龙号一整个下午都在朝着美军编队行驶，可能是已经杀红眼了吧。此前1133由约克城号放飞的美军侦察机在1430返程途中发现飞龙号。1705，企业号+约克城号的24架飞机抵达飞龙号，由于日军没有雷达，13架疲惫不堪的巡逻日机直到美机抵近后才发现，4发入魂，15min后大黄蜂号的机队抵达发现飞龙正在沉没。</p><p>山本最后希望再赌一把，利用其它战舰在夜间和美军航母对决。由于南云被撤职，近藤信竹中将接替指挥，直到2330仍未发现美军航母，不久后全体撤退。6月5日0255，山本宣布取消MI计划。</p><h2 id="战果分析">战果分析</h2><p>日军损失：4艘航母，1艘巡洋舰（三隈号），250架✈</p><p>美军损失：1艘航母，1艘驱逐舰（哈曼号），144架✈</p><p>经此一战，大量的日军优秀飞行员、经验丰富的机械师被消耗殆尽，后期只能神风了，美军完全扭转了力量对比并开始在太平洋易守为攻，采取“跳岛战术”不断迫近日本本土。退一万步讲，即使日军勉强赢了中途岛，也几乎没有可能战胜美利坚，强大的工业制造能力背后蕴藏着巨大的战争潜力，后期战舰下饺子就是铁证，这绝非战争资源匮乏的日本可以匹敌的。</p><h2 id="reference">Reference</h2><p><a href="https://en.wikipedia.org/wiki/Battle_of_Midway">Battle ofMidway</a><br /><a href="https://www.youtube.com/watch?v=Bd8_vO5zrjo">The Battle ofMidway 1942: Told from the Japanese Perspective (1/3)</a><br /><a href="https://www.youtube.com/watch?v=BXjydKPcX60">The Battle ofMidway: Hiryu's Counterstrike (2/3)</a><br /><a href="https://www.youtube.com/watch?v=WHO6xrSF7Sw">The Battle ofMidway: The American Perspective and The Strategic Consequences of theBattle (3/3)</a><br /><ahref="https://www.bilibili.com/video/BV1Rh411v7de">再来亿局能翻盘？中途岛海空大战</a></p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> History </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷静思考 拒绝盲从</title>
      <link href="/posts/thoughts-on-coronavirus/"/>
      <url>/posts/thoughts-on-coronavirus/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4b6c573a40cafa7888800411f72780329f7f6cc3e0f83fdbcddee6193fa75081">418fac4f173397084caccc18ab9f089e4418037cce73db100e9f35c582f9caba008c1027876eb9e3962ecf8ba9f8bf51e9acee9e312b6e0d67e8b2667ebf104101c4cd3e92dc9438b278f7ae71873e74f3beb5e31d17a0134edf2f30e818d59cb209bc63963ab1f198b74ccc21a815555da3103cadd9ada8f9a31a785669f16bd575c41fc3357345c998511d22e1bf75116d1d6278ea802b7fb0bf4b22404a2f9bad76747d055a138724002670a83b0ade009e101352ae34e7f565742f8cfca7d67c42a72fdbef289a051484567b2379b09af9316a533334d696b9515635e1eb72b0e44230472b8fa76e3e7c5b04db2a16112d5fe63afea869955a758777484448056baa501cfe2a043c5a661d375b0bcbe669b7462541832ed6d32de9478d58a7e5a7aa258c9f31792369c0fb80d458d003d8ce39dfadbf9da940876ba963c7bc9be13a79a249f89d11c22453259e9794ff5ff8ea5a339beffba50f82e5862413739cf5a29e475e3a7c52e719e2c402619065f658658661d9451dac543f99cc950a69183e68079ff2a8a1e1ad291f73cc875583abd6505483a7cc16c1a8f2e683dde148456e96ba979eec8980f8acd89b1fef7b8a2effc7aee582aeebe3328efe590ca2c7c83b5f625446e6f9454a9737152bec5dbe6d9e466088b82354e6ab59df4552cbc3bce5fdea7d11e502bd4b8c27a5b7e47c50c67ea2558b3ad10d8dba2e5a80167c26629752068338394aebacf2b7a9a2126a794e86c8fea17fb441d56d5246f9be0e777a6d287b38f26589aaa1f8aed46e751eb17e74daa2a830f4d86af597bda58e891ee93105def503344a59a152739ea36d28f48402d0ef57043e17f22db18525f78ca4388b64c43ddadf4f302f7e84ea8cbd749d8ac290aa9e6803010b0cc153a7a08336f11c67bfa07159bc1ed265c0ce553793acaae245e9d0e971d8e907a51479018cac8961cda3218c12496b9a317ca6cf8b9656c0a98cc230539474eea81427c068aba73cd7e0fc4533920eccb6c20c8db982793c819b84ed0f975aa110b823ae7508169b499fa55c88feefa0ead69930a126085d7ea546bf899d7ced6d1119442ab23c220f9a747e19e7a3e442a05948de3e96403d0b4567a9d3575f0db4f1f5001ddedca099b6324efdb1555ac8c3d2684d5fba4f938bce94c9c19980417477c902165c5094ba1facba37d97f1178b34cf2703dd6c51fcca48ddbe0a2cf52ce948bd866013567c8999163083ea42259672ac9c8eb0afdad9c16d4dc21c5d206c5f9a56e5d35065037a63887d88457960933fb71f1c359ed366acf678d144236a1ba58f5990c9f292836962c0f67bbd745c3fc2f03fbb0bbf8fed117db9e2dc4c9ec869ed0b5346d4b6d034d05833c0f8d78ebb31eb28846b4f179e6a25f92f69eefece8e2c06b295ab2b4c42fa5e8b0356937d7d36d3fd276a036a318e2d729b567dc061cd6974bc42aac366d9862b2d3a1f7a4af22efe51158bcdce8e4e15f60f8975694dcda2f37e47819177a9dcd2d450e9d3c754710ff9a212d58806f8c013be9d86239eac6be01a0f27b08915f2765483ae686de8d17d20b1a22a41d7576ba6feb85b037a077070ff84dd6caf5093eee27ca6caea0f22bca8b8c8d8750e348cbd2601f1cf662fe5e7119bea516d2a0860ff279d13c8c0d6aff936801d447ef08dc1ea96c4a19a2a67d0890f2c764c357c39821608b61f62b227f79bc9732ed93466df605be3d1247ea1f9a16aa7a733300dfe31c20ceab42e8f8185f3dfbabe7b8bdb9e567a41cc528df1612825326e3c1bba5a6bf3e6c80e0610f4024e4b7b4b2f7992bfb4e882ad66d3f48d7572f0a4871599fa322753f0b170bf57a30ed1ba915febf455b133c2de95f11dba136c8cf7b5c5f307de1792e1554749809bc65ef260ed3aa734110ca06c94304e55fa194fc5e245cb8c1414676f82c266cac17f504aa09e13ab2c218682521770f1a70bfb98b01abf4571e3cbd36fb832082adc1be671cdd9aa066c93e050f93abc67f3c123cec253b6bfe9c4f862794931d0ff60f8cbb442c292c77da95f53ee2bf9c23f4df379a9b9cd0feeb93ee18d8d38b5ce35cd8bcb8d439d89d925eb7f4204289b142b8d88f722c8f6b99fa5adde3e8e586d420d8a3270d8e4fc4f13ad8d7850e4259d44d690bb49bca8afb287fb7832ed29e35bf80db4381df4a22f55b3341d7048dc2b640c327a8fbae2a14822c6cf7032ab97b9b4eef260e965eddc06906a679c1439840cb72bb693ca75de6b86aa09827477132106bc35308cf61b0a9aab880254d35153d9dc1e405640caeeba25694e5564ba4a894808aef449db82c86dd69a5de4490bdec407f782a834d0c1f7c7d985131df6d86c25d927042499540e329e4835fd7b47600454b5da745da884f687cfa7d12c4eeccbbd3aa4e4c983ac50c03e498d96986ec2cf6b542448ad81ca1b17a468127b9133cee295277e0d2f5ed9d446e3fba4df9d42d8c49a15460e4a9eeedbd066e31f8160b80b688b2bce2c6b8411d4a1a9454bb0ea02e58582b8503e7996ad037fd18944ccfe92e852a2bc1d9b60ef91829fc47bf2c23850cc4ea84b7433168773d3c13a4b9eb8bb1388374d6938e9f4a13e0ca6c18e3453f2e581f3f79c9364504191c1c84bbcc8cfe1a4de3c69b11fbc77d81c454c522e28b8222316a39c5c0b74d63de4280e86adb6b40c40c2bb361377c4cab394c484d8389e40f32d69d9ad1ca5f9f3decb6726e1886db5106f2c98006ee92d1e844bd783bdd62aef53a9d1c814cc1a8d64957c191a03357bd517036b76e21f06f093ad43946e639537aca015a5c6cacefa30acc7ffddc4b142715f10dc36806e5b543ef889b96a56acea21ef4ab8fda999f7c2adb09a2646152431d8dca050d2cdedea8aaec6f5f9fd6657aa8d09d7b297be51a20499ae4c7644da44fa34b4d1f970e3179878e45cc814592227a55e33c8352e8d028bc648563c7e5b262aa587286115803e68a8c09919fb1a8d0ca50fe9ff2facf2d6e593b6c8bc81ab2c2341c2a23613cca5d771c23b7fbda60e31988130d8811c026507ec3cb56c691588fad0a0446cfbb72ef8d051e76d0aebaf98de70e33aa1da51af2c7e81726726b0634e38cfffa3340ddd80b173911a46414562c8a748ad99586c22f1bb2addc84fd931e6ceef8fc4a9d565da71a052b99ef241b11ddd4a9f52f6b0f6750f7fc1399e9156248e91527bda36d7b093e173739b4ec53132a3f8838a8f9a13f8328bbb7c147b4921b622d8bcc0499b88aa62f3c0ee3e59f1a5eec1621de032ee081f774434cc91a7f71176ab7cc0c82ea0c510e4c89605c04503023025c7bfce65618b551e9e6225d68e8b2a35e4112f6034168459021c4c25f3e3e558385ddd048bd3e6a750f39fa33744163f702525dd8b459e9f5a97e052c94e36220ae2474b8106114cb6ac1574d9f483437e0bdbe2685af95a44374edc386de0fb3cbcca1e65cb9e260ffa9c33f9de0f95d2d17dbc83a66c7fb7b872b426b81a7db50c5bc1900761d7bb8c1007d8cedf2d9b45e41e5c5ae3fc02c5d80ac5d65a7d27ab579f904df15c12cfc224cabb9d14b7282a8b8f113fb133f5b1419f3721cbdd2a8bcf77858e7954c9145d7b5162a373dbea639703ac987c67d5019a9678e4d8b6278f1f57e53bc3e9a402fbc489b5d909559238e08b7762ff4d0f883974cb43f52c022fc69e76829d6ec6a202838058ac4e4b02568fff33bd17535ab39fe1bb6ec00b17b058c70d388ce37a9f07c5055e69fe9b157dc8b028e2527a13952bfcf4a991cfdf21b9e0aa20a66d4e9fc4febf17f017a0e6c986e34c1f2f829f30a49196d3e777697601b51a4c6217eeb643f0a1d4e4f23edc41dcb2106d7418c71883f141e782810363fbb5cc704854882ec0ae465c23a193bd5c3685911a864d638972d98e8acd0f72d66353b7534dc3376f002bed4e91665e2572950f709ff7af7bbc95a17206d3e98a03da8719195d9a02f40ffda273c0d01619b2686774a4fb9ecc43a3ba3f1c6e5082b36a0d67ae4a9a7352346463613815554970294c13f1addfb850e0c281c946903c69d5963900e3ee9fda9d3672618a145ba1e0b2daf4b6026a71330105b833730097b6bb906218281e40df4b44cf30b261d981ed697c6fd18e71f351377508fe01f2c1dc00810b0e42d34baabb596b6b92979e84d08d2af885446f897e185090b00e4c9a7d9bd5be4549287102a59793128d5362903c84b6753eb7c137fd94b279e2e4f2d6cccb0333d20a5df6a32fc41aeb95be1e8cbc1915037bb8a3df36cfba394c2bb3ffab3b664bf886b37675d0bae7958336a3f5d357851d4c38636d11787d4ae5d4067f6670568908cd8857dfe32112b4efb84b1f86cd223b9c54e7dd2f26698c146058492b20e0c75dd2283e787a0ad30a350be09c8b3448a4a1cabf2406b6049eb38e8cfd7d731e3c4c5bf07168b958eb3764fc6caec78563ecead99525e08c8c55105fb3c1035f1209b27e7d8316437ecc8bfe485861a9a6ea52eca644a0fb8a0bb92cead9ee52b6cdf56e143eb6f39475f66f6ce156d0fe320c9c7d7e21f0676e27a62856ef4a8f14f2f23328e3af4350d2ffddf51bcaa338c05ffbd0e353ce09c0982e4d8618a0ff613d767055e5de105596dff2dd217a07e5c82e3d992f283bdd6dfe1a1d4509c3c633585be9df6e7da09dfc9a8815c6548136b10cdf7b5f916f65c440f23d6403e65883b5e3e545c5874af953570dc8985dba39b98bbb354a52ae9a1fe3a4528e9f2e4491005864dd38554525a01d4fd64ad4e51d42ee492bdd422fc695ea5362c2714d384b9b117dbe2104276c9f9a3d9b09487facdca7680a9c1fd4acb1a4142481543bb78d82e8c3af99dc5e06797e6811e675fb7305ac4154434b03f7046f2c8ed4f6c07bffa4e2afc64c7d7fafa759215f74cd306510c555ac38f7c3f8d8bef1147042b9e9625b1fbc0cef8e3c4d80e7f261d73f7f4bb5d450d6970ce0dcb4b03942aa126053aef7692584fc75092d3e34625aea0cf8a6866df93770a2ccdca74a483f02f5780512a1248aa45f21fd62101ba993d9421bd05cc97eefe606a862a12ce72323fec8abafad4e423c6f48da88369f572daf8a25cab7229331976a30eb18a11218a0f556eaed9a07d0417f43c047fc9d97938ed537e2b2fb9e49f87c0df44c15a9dfd235a59422e8ae21b4f7cca6293cbba4708d87f3fd7e5fe7cb51ea860bb47f0f4610793b73bf1d224adb09f3bcbf240e6287219efac35d02afeb2324760859a6423c6fddc166770a8dd9f554c429a2dbd86055022d2547a7131bbc4cdaafd36ffb6647b5aa2aef3bd6fdd11642b29713f6f2329b45b4e2c2a37b6a9f437ccb52ba5d9ef085627c0795a0de4fe710c2602e317700aec56e2cbd57a1dada9d8c9c9750aad4bbaee9d7b25809dca66f3a6d649723cf7eb7e0fcc4c46865d001124417431e73461a6248d5d0277e2a04483dbd3d863dbb86fe765166a0c4fde8a86b81208a35fe8ef813d837dfb7fbe20501565a303eefe8ee36fb149ce9ca0fc93d4be7b7dab2591d47440dc67aaf47e1fff3c24979755eff72df837608c70831a13a0c604de5b96c7f12b030222dfead8af2e054b75d69fc66630a34ed9c4765ecc48e269ef2c422628b773dbb3f49197b9cc1524ced1192bf8ed01c3d45f6b636e458f316e93780509c43f818f0b489fe422c04013f61cb5aa92bdd26bdfbef2f97cbc1e210d3b3d45e49d6770d56c0216afca9d13d928367a00ce7c936d02c34ad9f3250479ba90a21851d6e7791f11d279b7a8289f8840d7a1dda12229f4cbd54a45adbd58dad80213f6711816837cd7f497e1a48883fd77238324a84849a0e93f7138e6eb68f3120e390c3070f3859f0788f663da6e69f6f924cfc42628d5adc0956fbb850d8fd837bf687dcae56ce59b6acadfd3219fd7a992e5b5dcb451617663109d4c6e6a4d1060b3818effa5c2245b6452a92eb3ac64190df5578559e40d11c398d270e61a51df2a00e904ca1040c9c512233229301ca358d600be3d00cda7f1f3ef07883c7da887e6d59441b84a3e69e4acae8546bf13b5f88e1816b651b8c9c62ef33aaec71bc54fafb4c13d28116ad8a8959b0acb8288a57d17468e5ea5c79a8b094ad5f31515a05acf61de2576df505fe07a8f03216f9a5ee14a52ea8e4b07db71e18a0e46b98e15f7aa69255a3b2255c1c85d8ceb1cab62d854834bb8bbab592f4f7385a5fd141b0fe50095f6e02927cb5d2195eb61034350570ca87f67b4a6d5ff427b89745a01bcc9c13781353ee3196b87b732202b7c31a58e0113ec6ab60f1b5909b0e09fd163228ba7d4ffe65aa9a99d874479bafab0b9d2956e38052450259c06110f5c56eb4487dd2071c0de582789cc0eb3be1dd0f4261bc12c3f65a3f72e2817fffbb50af396f67585069ae5c0e95413f7f6952ea29375a8a779f37ce6b76e19f460ff21bf73c38f663534e564bd6cd400724a90bc61aa062818fcc754e5ebcf90de7c4d35fe814b98f212743ccf65719fb8abd14b8a2a90b2d01f2421f618f17323bba4ee37fb2120704310f8bcd5b6b6105797c9552217598a715f58fe3dea8fd6e921f5a2af305a129d7666363907fff629340b9ef0100de22f43d99ed2e2900cea8a429eb621e2014bf398b3378b98f061d59cd921599622945f57233546abec</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2021</title>
      <link href="/posts/my-2021/"/>
      <url>/posts/my-2021/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0f21b84568cb58fc8127fba3e1118c99255d03cce2c804fb3655b69fd79ce8a8">c172f4ee74b2b6d246b20cbfdc0b877e4796208fb8efd1cbae1d198a549ca20b7df7bad19209fbc2fa7b16ffb3c37723442b9b48691d2c71f35e3c27e02aa6dd1992d58e8a79f167d9bdfc05e73c3d7134b029e0148f4e7a03a4075f7f17d0de7c7ff5aa4a4cb2271537747e55652d2a18842caa63935e3874e347f552f5a0a541de48a51ed2de3ed4ac94b1c354d299bde5655be6c333daee777ce7d44796bfa9cbf73d7e7b06902abf1f988c148aeca62a02266f2b66c71862c3a354bdc5bf34c283e92fcf60ca989c28001857403d8b6545095055b0cefeaed2838b93bd2e34892af049685a14296aa02a04643a7efc97bc8084ec9cd64925498443b61c70f03f42a7f6968fa7ce75d2957cd4e91cc016f82cc3752d316e955a9b378e80d59b3f765cc4b9f1190470207f07c522877d4e2323ad42488bc31d40d710e0f9ed81a1f22c1ccf91198adafb8470077dff374ef9f8eb3869efcbef08552ad13725d287ccb63d6200a75fceebe6cd27596eb687c4b12dac935095d700d5d04499c41a37020366b7c77540272c929bb4dca6352d011ece3c6eff9d3a6e7877137d24a134e0dbcfa5ff46fcd70f1aaee077e1b68833e17f917acd58cddea519365c2ea8108f8d80d56ac68f6987009c3d8c44192c763ba6b0698fd6a154be003a3cc3227175aa224c9a26b6aa8c9583c1365a766084ff408947b652e817cde35fadcce53695405ae2cc28b970803d53f87f637bc4191a7ead4a3b2377d81d02c7775318ec4cc691d87f0e645474cc2f3880db3c62d66047143471f73742a296513d2cca675f9cbdeef6ce503cfaa75418bd3e9ece9d335f96179adfcbd4994cba16b705ac2f2e3db5e60a0c498138b546016c1739da45f7091ab9dd33b457630a1b25bf2c79adc4bf374a6f6f55b73158c73d324e3df92ce13d256d6d8f9c1dcbeadb03d5dc19eb8cdcf86232d1f67bd94fa7ccd5cdd57380dcdc283572baf30c7c2fc4835add96f32faa5f5912287d83e5085441b2e467c9c2efe2d966496cf0569c364c33cc2f87ce835b7ba8006c684193739732449db9da8de29527dc16c38258557aad6b5b4e9b936e65fd9e97da18faf5fb0f5cd1a1646327dde36e2bef80ceab4c37acb7e2ff128bbb2f4507b9f8e4753314622cb1c6f5259847a1c52a233969dc913d38a6b79d14b23e6801a0584c81fdcb879ce4e5daa1550318264885e9e7a51efe7d50fff2a58b367756abcda0c059a024a4bbf0658cbf5e924bc955098d41f16be5395e8efc23e826ab25fe1be8dcf91d3bb32260eaf4c3a0ee899a757c6c3fe682f192060136b7d349dd5027ee99b5945e03ebac7de6651ec807f13abac0fb265a6df9d1d955c9b3cb3e22af8c22e300e76204aba7bbb4795d8ae8eae2387ca200f280174de95dd6766a4c8c1b57773da570be1dfc84701df02d37fee01e2eda0710b6e39978c0b7a0e6f92b51a04887b835cee2184a5a620a3d513d9cdfc839f399b1f57d9c34f8c475ffa0682e795a741d6b6d4b100a071e0d49aa837637586f37daefe6742792d8fe32ae96354bd9d1d9ceb86721a714aaaa3314c933c1dedee1ab368f9b879061c98d94d89ed8a59d107cbd2d3ea4444a3598e14a84734f5292a98154e4a715399353719de824919e54b88e633298b2039219b90b725fb8ca3d6ab4e9e328947250ea5f3f808996b82fd11911ecf55793852e8bff7e00c51698c5a0b9f4284d8990c72aac480c093775902050b53c71c4a8f6517beb123d593e1937d98a228531e3c1bd0b2a92d9b4534d5601fc947305d90a08b591c2667f62f878fcec30c31a5b998ea0b6ad2d7e09993e578ee1814bcde980146543e266d715d24d92bac46a7206c68821341d1de1019b4e9ecc580a8011e3754c8f18702ab24532c8fdbfe77baab70fb1fa426f762ead434f58f7f5bc2d8eed5c9fe39b337df50c96b42ce1877ddc50d682bed3a7a392bf994888b57f5f8ea3c71bfd4404c38d3780602cacef209fd9a059d5f6cb03b433c4bbda9e9963376a45e23604a78b72155e70ffb0df2e4fbdd1e449ffa80abee58c2769c6711dd2435e1c9fbf71ed8b497a296ca17b7ceac1744afc7b723fbac3b038f9ce3ffbb4fc3f89845559299d77f2e332f3ba0742a5b7e8d3b12ff08707dcc96764b4c3f017c6921cc1fe15f32d00af419a75b9982653bc358693c12d4677bcb87988f1e5c009b2ab12b97df2d1eb9245d47d55b70d05a946197a6bec069902d465dbf3b918967ff9b11d3b371eee1580118833b8f46a6f06d53464463bf0852b77f46c46a75e53ae7999a92ae22457a54f6b276d3bf3a0c21400fb02cc89881c00b887784165541bc52c4f45268d4f2bcee52e7a4739f310b5451288f1e7f39bcd3f93c435c72baebe33c93b9f5416e680cb86048233fd304d0602b73a08a222251b934e88160e04eee3f816d1cd1c5a85d0f3918448e7b7b64cfe28e1f6091f719ebd38f693129b3b8593cc9ec75e6cdb57e5a951042b5b2248b1d65385d10d9eb7eec71f2b948c8b4c3e3d50d7128d568ad0b1bd7856b46be1bbbd52f5113e0914db46c931fd8b4f0c884ac3cb9b6ac64847f3f468b8d8dec7a86726c36cf3731919ca4a976b8be737a28da358a7c24927087efa5ab2097c5ed9a6fad30df26eb308ac1ea37438c351c0ea79a5599385d76912b9c8044b1a0e52e76ee259dea0cad820529cc07b894451b6f2d7ff9dfd2d965f6086a9561c90f0b5aa78c26d53f7a5cf5d20b3395462df45b999ea98506c23c985f429d20f4fe08a95b28392f6c5c4fad1a44e3e4b3158bb0bd0ea35c89acef02b0c90df5025f4801dfaa57ed3042696752008fcb33ea56e990fc6835780fc1d382ba97f9de635045bad9a0c05cef700e53e131dec6206e4977b92191f38818ec0f74d67f6f2575379065136266d60127684f3b7a5963aac0b6996d154ca5aad7ee6a6cb880dd234a4d52ceb024bf8a5c5ce24fb9f261bf84b1bbef992a8a9db51d8d19e3cd1ccea9187c0ff68b5bc9d640c5fcc1fa09a17c70688b153ec8ee429a0f2df0ead9f057c19e855e14f32cf634f10210f27cdac78c96462140e115d1d5de062843684deac3f3d223396a41fe7bb7847dcf58f09ebda13082778746c0c79f97da560d5c1510290a23fec6a6b86023dd5fc6e230912eb79737a671be53f4c065050a4eec42227fba16c77438bf90b8d5869459bc42c3cd418b227c2d5ae5216ace996628e8119bcadf367cd51f95430cd54a19b3bb3774fbf5f4a8db72887a23eb87dcf49cec582f3e0b7f43542e25041347a98faa05a8f5aeee0112b5f7962f2e69c5a5914c9f37421800a247685d1aaad95d86207e9d816d88f0a63369893b93199bc0141e627a4372b7952bafccfd674e4e34e2f7713a134417b4ca091623158bfc9df3742b04725fc31600b0c933c615f3a03ca0640c12d7410c6ef66f76ebe5c9ccf71fa572573f6e014c39b7033f3c4ddd5225507c068fb58f91a9a9d746b2d4bb173a6fa947b7bb3c891d60d82415a1e3a48f573b4dadeb780f7921e990f89fafa42983eb4773cf7745e6bebdba839b5daf9095d992a220f5f0b83c2e7ba3d6c721d82d47133c8910b1385310ed17759fcbb147e17042d804e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Social Connections are Good, Loneliness Kills</title>
      <link href="/posts/relationship/"/>
      <url>/posts/relationship/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="017dee2f5c836c8f7d252e5866a511deaaf47db809dde2820c20d8f578be6478">c172f4ee74b2b6d246b20cbfdc0b877e98714098114e5e214ad2e1bc0791ac811da87126e79ec0c1b3dd59428e481fb518de8f57431b8dc5ef3f337ba7413ea8f8153d7554dd71b5aeb490fba7db5417536876a8e2cfd85fbd886f89968859dd66404c54f92926e1c895795eff5c89d1f407659acc1e8eeb11956098fe2e387bef1e40ff86f44112b929a802819f7e070b32550340cb5c9c3edecf15a6c11e9316191efaefafa5de639816ac986df76e41971eb1bfd9c0d1150485a7c3bd0b79dce71889ed0c5a1a428bc90638e40dfb4eb278869c07438617f5caffc308669ae710b8afc1faf7c0ba1ab05dab657f79b7b0708ce661b5ce2cd4805d49dc3de2403afcfc68f89eea771128504dabad9c6c4e651588094b1a58b79328c801e159c97aabfb2f768d78300cab26656e54c880ff0aa50185cc9d7a93822f732f320e1135056d134c94b8c37f97ca1f33679fa186bb384d1cd8a6c258db904846669004ddc76e7f78b6cbcd3c2bf8038b3af400064639d49db579c42461b0d67efd8d414541b03b5793da2a593a678c96ae9111fc4407e4dff0f74efe6f125ce1c04b52ed3e07a89e7383deb88cfe0efe170af6a9a15ef9791fa0cb33704e9f72e9bf199e722c9de473ad367120b1086a8c5f4bc34b0ba7750cca98772671412eb1fd80554c0e6b7989af93392ecd3d75df956d6234b9e4e1ab180444bd68c6b0a5c6751cfe85d6353f1fa8763ba23b50d634d3072b22a7e25de4cf3eb31aaba14d4cad0557ac92cb858d1657065a0195c447645491fcd0726aed0902e2a7e65140886bfd5b634f72f99dc5c77e950822ac8c93b4f949e53132039181cc0cbf50f80e4899062abf503a99ad47fe40bc0a5fed14cbbb328b09fba2a6504bdb5a9341e834915f1dd6057287182e089fe59914bd9053c9ab2d5159bac36335557aefc8ea49d2936aeb077fce8b3b69fa45ef225feb2f6a5626b2388eb2b2dfbbbfce2604768bf385954b1220fa35b2361886f398b1de0e5bb3d6725532117903a89d5445239b70bab4a81de58dfcc5bef38cdfed41d878db8864ff2cd0cc5c65addf7aa14a1999443020a4eface865cc97dbc5d06aba11769c1c6d810df03e46149151fe756a9d3f5152973e6ddfe0b42b92a57461b35a355f333b600a70fe8a291bdfab101ab062b813da55ddc9ace2ab213e50247e36ee11cf9891b97f275ae29f0d1b2e64ef92c7046045b50fa23d083e33e4a5b803d04d25efaf40e82e5b53923cb703c22f18b21e129005ee6120595627fc06b8c5ac51f0b75098adeaf29b61cc9ccfe686e578e1340c08c4297355c14146de1bc0fc385235311e387f6dccaa73db3f4616bdb3067a4d1066d94a3ea6e1699531ada9da2a604c677ce3de4d1ae5cf583aa8a5ce875d53211ab6e83d1f80ba811e80216917db04c455587d0d685991cee5eaca1d448f957353e81e7bc7984f9d46ae38511592e503f4855106c33cd7b0dc372a6dedf16608080d1fc39669c916a9ee5e16afac580c05b12e32eaf146c0f4b1dfd8497f3d415ddebd53c9f2da708c63dabb27fb89fbd2ed54f1ed37a6ec88bad2a7e61207e8a671d1398f51886078749253fa4a629502fd3586242e8f6f50ab7955502c2419742203e0b5e12525d19d39f0a2e389f62427d690c7470060cacf100e3be01baced87b7d3dadbb3de03c37e4318a70cd3552fef257f876e81e1bc7369bc29607f26dba3d1ad4c10a03aac24612b53bbe16a9bcbb15f6c88842c68c0d5bd78c96085cefa69ac7aad4cdac4a8bf62475b8a9bf226a221330983e23e4348fd6eeee129282b075f7144bd124681acbbba8d490973cb7702d30f57fba80702412e4ae5fef61386336e1b43080275882e18cc24ac6956c54f879b086e7d45721f60d368153708ebed82917b45a862e03f0b0e555c5d24124ba08662c99a768f1059adad36bb4744b560ed3a000a10e8aa443cad321274c8f336da055a27957944b4eb1764e1066dc7d75be789786206be2f24ff694ee2bd7303487b282a22ea22abb5f9c77b8ddf063804564317165ae4f1908a8a2215c72e993157db8ab8b3deecd620dcc2c85d35c5215aded6a0945bc8be27a8ff8de7762132d45f47a003f58d41aa2e586025468fbb500efadba4e511f59e13eb338d203e7c219c48976133ba06504077b8532c425e61945a1a548460d157d273106670dbab1a7e939a7278c9342ea3afa92afdd86269600955d86b052959ccf239ee5a15654ca3e1740e15c9849aebbb2db0c491fc07a675e15080885245276dd3b15bd4eee2bf27fef8276afac68015a572bcfb8e8bd8a0ec56c77417dc456d55471438f3b7fbaf50514ec96ae748d0b4040990a7e22ee917f2e7012fc526e00a1bfbdf95467d431e2c27ab8e0f2ec004a9a37a256289addbbea6c9575ede0761ae079c172829a838002a8bbed701c8288c20711ed3c5003edaee250cbfdef8a0a8bb0d962a7f6b74068063d7568eef467395263ce71dc928d0002239f71a64a0bbc9a8f7aadccdf06e227607bb10ae8fd4377b0a0d05b1f6734c633cfb1a33b4a16abb625caeb891623801a51e15dc564568245d9858cff70eb66d5fa21fdecb7239ddfbdec0fd97bf20f3a0d53849b10a442a8ea33ce0e619c00f389da1096cdecdf55fd63e261129c89f4daf76d475ef511d71d7f890e98a9ee1e3b02f1a7dd987a45ce33394c896b824f07d8f7db37f558a49812534848140ce2086ac8e1f35528dcc98aecb722f1a99ef9ce947976a82f01fb2383b3b0d56181446810b0647339ad1e9bdf1ad677d843a3590bc2881d265b0efd49260d062f2cf4bfea921b1db8b56e55ea3fcaf0d22797af94db3a01b4106d8e94bd256bffbad37f09d5d4ef63ac4aedc49258c166263228e5708d2487acca1dd3565bcdbcb1715f8c092e463a082f831069018fe611119d104e4880413782f5651a1c79dd0cbbed46b1b590d8e39a6d34ad33e41c9bebdc7a6c8026d31fc2c01e7e598e09a5ec2375e9f7ca4a91a4adebd4354e46bdac9dbb788140a2073d365e73e7e95f23e8060860a066ad675be5a8838dfe1f5f989e759e529b1c1cf7de6d6a15e290a6cf21505452a441287d80420292618817ae348281fc601f0439670b64c98b48d2ad6a809ac468beb1bf344a1ebf46e40995c2cd68b291ede4ac6b86a25553c014f05e99fb67293bf80e7348b58815c39956146b45fa762fc475bd77438e9fcf4837d206b3c03e6d54ee25166ee29f22cae1fc4f4522dd7a164</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Where to go and What to do</title>
      <link href="/posts/where-to-go-and-what-to-do/"/>
      <url>/posts/where-to-go-and-what-to-do/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e7f9be09d4aa119ba654d11755d01ea64f430b204b1ca6c9336280f4423f7c45">c172f4ee74b2b6d246b20cbfdc0b877e8bbcf32b0350f372e58bf556c0a0e018a278f0d8b1957ddfd9765be148897416a00132d101c5251115bde0c1fec649f8ea46100ee8ef47be6dc34b7db67930107ac58c386a26f4bff999cd1800f08bb77ab00ab7275f0087faf7bb9ed6519b42d2eee9864c81b703c11b0cbe9052c1ea7c02189879a9b1af251f06f39b2798df97fac82f336f8c874dc0096a937a7e908babe003639df24b23cbc69f2a0fd9e4a39622e7c63051623ad208c95606516ab2b119a77d3ea2ac8f37a01aaab28a380b8562a42e69557e4ba3dc6b62a81b8fdf35176130c70d66330ebd55e6d731ae90b9d7aa3ebc8ecf5e2c854c2a1843f6278936993164471efcbead5060372611d9f087463634d4f9115aa262a23ade45325b0b9582c30db14d3b6fb18e1b2be4b6c7e410d4316b67609e329f1a10ab5c103191ef9b3ad8be55cf261dea448accc1f89b26a6c3f59eaff8a428bb311e9db75939f23027910fe3d716fd24eeef40a1f30faa614890216fe200a9191f248f55fc9c6b76c023e789f236a150440cf11af3effaccf4311a926fa7bb0d276349f780c27421249c8d3d90929fadf7de6d2aacf122333fe34edcb2a5abaff69d32dc3a296b5d84892f8c917d3515f05a5b73140431006bdd24dabb55ca3fd55aae6dcd848a6052089b2543c84d394e8d510b8246e0618dbc2706774a87d7af2ef2699ebe7cb818ed4f153e132a9466c4e2eceafee6e96b2958e6821ca4dec1db7c8f93b234c6de5fa6ad6f7b99fac5bf3687ffd2bb855d87f8a02a99a07828fc66401960f2372ab111977812c7d963854a9d999b87fa676703fe369bb1ce89ef568d950381321d33999164a644ba53fd244f845a3821486cbc2835779747a0b6ce3515f78492fa5183a2937a066df011f0d19e0c26f151928fea1c8acb5eacd520e4eff1dbbf0550e780aca11cc045d44f61e623379e45ef431c172613dddedd47becb669ef9a7c208d96586d4c06eb475136c11e4c3b44cde518a04ba9fb08283ccde868243f21dc173af3a97ffdc7fc0fcce2b62538499914e96eba1775ba49cadec298d11ac668f4aeaa50e5364eef692145102634ef90e60944f2754c92c9975dad53a3483de626cf51a3b1f4b454614962061b047fa494c05c14a4c4b9f0bdfe2a38d01e5e619458e70c1f93b3b86ab65b81d1e04c0e4360393e6f017ea59fc7da74247930451c9f647606434eb66e285dcbd89105baf9724c319f14f5dd3267d271171b2db04822a399932e40c5576cafc33a0ba5e8d909a5b3285b1e742121f9b5806c00c6ce130c8f92ab1ed71fb30284b7d71f1aead2e512df39646a7197a543ee85e3218e8e76e23e831bfde7f68b9c209ce96d20a194098d909f1d8ebb13d6bb90609310982aa015ab4cc9d975b5d69fb1b5cb3b22202031a0bfbe14a1d6fb60963e34b61c22585c5cfb0a6ce938f7b6eec417b7f099ae7e3c16b3bb7e819f7e56984391742c7210e2513c4a5bdfa864d3554a6c69cfd7c313b93478a2cc580bcc856933ca527a7d3962c354af5720f7ac38866a611d2f18a5032c9c0d4c076bde1e4588a4707b6b0d05b8fe75f7924e1f186d6918d9ce8f9239e97a231c3ac7d47a2fc4337631482aebb87984429a19487f43f729f06ba9c8a51a7c7fba2d9a4f35a84c99361ecd2102a14c9ba75335d354ebb446876f9cd1f43dfed5b87e6c73fad3e2e7552d85766d510e49ec1f4346c6ca5f7c27f3af7622b66e7abec0da8ecaee6994ceb9bb0984631c06a6bfe180232cf4decee407fb17deb1906a157c6255b2fe7501e7768ad398c78264690126891ed1da381a7c119b9826ae77f61bd2ffcc304315826353f323038f28d4aa5237484bae15f263092ab3a7d4d1e1379eb021f503f298c0826cad903a76308756028f8546658d06789e6396fe6b395157d0f51f429c71bc90caee166aa69e2e91688912c82b53352c9020155abb8740279304b122852e5bd1b969757a071bb53b819f2f4219e2e5af17eecff19feb9d59d725c705a3b2438981531ea23bdb388f9b209a99f8f06aa08d09ee140fe2fa431234a8244c9a53119a9d1165b85639ba80e2b6ecafde5b60247565649d4092142b657b532861d553f04bc31ee0a6c88c33a43ce6732e71e77dda47eeaac24b4fe418834a0d83319401b7cbf35ce83e5b930283ae57bddc00eaac41a25ab171a6eb31bf3366556e380fa7b8d9cba7370e5a3cfa67724feeafda2ad7acfc3ae6e509de422fdcbb14ff652ba2c0dbe6592c155466b2da010404f379c53dfe001f6a6b0f7f9a13e5765e20e568887c5c4dcdd8e732ccdad3f4a98d67d845ed39fdc65d09cc59e4b0880051ae0ae5fd8c4a327b452242790bbe0737eb253c5aec5e960fd600be4c5bb2f6bd27a07c464c06f84280a942c058a317c1d9580f6eec9814410789b41485ef1701112256a1ec36c656ff53930a8600396c4944801b73a6f08f28e8e96ef8a75df984100c17b44da126e678aed5a18e8e371ef97145dde248324dfb896594f80a8c48c1a4cc989831bfaefe77ab817b347bf6346a3b5525f9350eba764d8df45bd99e2078e0cc18a814e6a51868d11c43e6ee41757998f6961ae9ae53b246a942087fa0fe81b565b21643193176593d9330c26baa1867a46083ca2a8ddf7276f00350c999f4678b06aaf94340b79fd7d578a9439082cb27d2decee6084c9693e3eb864ed9496b098cec49c1e5550bd9b3689aee6d0872ccf649ee5ef809f453aa86d7d3fcde48df3568814d4abf1207ba74a3cdb6e99b87b2c3cadd279a7c4c8eff92cd517d192977bd46eb42c60f17b884bf38b94f98c41285dd92f40512baba47f1ebd5cca7ff9bf6677f221aab22d5914caa8dd45b20bae93ad3862c89427e3a0f10ef77fedc1df4f44a413c4a8d681d99995d90745f98f5a9d3c23c173e2ac59dba0120fd57a4f9599466b62ebce700ccd349a4e74f35307d11b720bb5d38f05ca02cd645e177c7d6943ba82bdd2ba1490b24290fc4086abcd016f4522c720a791757dfb53fecb5ba4d9ba0679280929f0acffbe0b89a6d424ea153fa58c1e5b85ccc1b5f841d513b14b3105064b751af7fee1c3d1792a393f51762415ea3d21301e360e1dfecb7539d8e12ec0187767ee82ab4d8f43be941d6986f2395fe86cdad0c1f9dfb70a18f105c77053c8c8be6de72cc575e476b36e056f76894a7a1acde01841fe4f6203b91611997203e74e1e920796e2934dba02f6fe8d7177884f7b4a4a3fa057ed63b7ecc783eee2835d0c6b6c8880cd31c17daf490058a9116a080a767c55d612c64e78b88b5649cfa0212e5f16ea1adbde86a9d581ba6e4fd0c1d6e6b6e7db795971fe68030106513794f3417b2a9360991e620abed5b86447669ee7a88cc8d31af43c6f24898847c7cb8e6f841c0b59b53de483cf00dad58fb46d193d949db099ff962d10e2b320553aa432ae8b81ba500b2d75d7c7a6e44cb0d9875932b3c4047eada35960d580132321db64ec3fbc78ad18feff854cd07604218de18958ea753fb36e8155f22e9432e1df3d853d508dda47c7514c915355cf2c7ce579167795b69241369bf8621afb9f25dd689733cb779cec6480aecb794e4fe3346262385c2237b2c796c1cd23ab98916887fff7912f55fbbac5f41f4b48ce699f3994d8cc4bd63c81be8b6324c556dd27e2b6046db229ee809a5fbbe56737d7b507cb15ede9aadc4134a7112b0b0d1be61413ca39529f8c143707b9529298643432056e183c9f4155cc4c86c45b2a3475d8fac7a5cbe511de3834844e22027e636bfa8af69ad5b7d457c8071c1e067325cce495bad698477e6a379b933dc13862d71ce68d35ae021e878b7fe1f9bbde58cc518c5c7e5925cd9645749eb924f683644e36be0f08e6bf3e74d55fed6fd3827a0e369e3d0bc63efdfb6bb50ebd43fec1c46b41510c932638ff280692fc5cb16498ade38267bb8892648fc080c213b97956fc39a28d590f5561eb79c6869cb2f67929d9cfb78c6ce88a8f6fee7652f680773399fd7963a9910e6e44bc6165bd61a3f34180871682e7e3da0dabd42d1178f21ca40a972538b5491ce7d236395b335ce7e8acf102090fa137e560c7f592b116f69eef426bb2aa3f8789ccbd27252e17d7824c18535e6b4f6d19357dd3c6b4b6ffcf782c6dfe7aea608eac0110049787d08a02b243286b4869d224e9255c7237f5d2396111166885e91c39ee1a9007302c96852ceab9440f4148535777fc9123c4f34fd218376467671a9b66f8217f600abbc6b977ba83d2755809bde4824a7eebe6cc07c006085f69c9658782107227df8b3f323b30aaa090ec97c0a0206bd244cf3b1bf27928635af0f68e24ed20f8a76117a8fc751a4b6d5e12eb192ace624db35135fad25889539164f5fa7b1dc4556ae9cf365b7906adc20bb877ac7896454c0cab7db9a15e5b2e3c0060601946c021ac729a13dd3c6bcf13f8b7362347bc068af0881883827729bcf2d17246ae9735e73c10dbfdf983747108a9ea9a237083b8360aa72fbc27a9a3c2e2f979fcc28f91c1006fc6c18c77135327f0280912425df92ab944743004b746531b27a9ff2f8cb7fbe77d05d0cada9b3b899b7d8ea908db345d87566a4db1bbbebc4a43095b8b0bfbc7d39b46594a4003868372833f5693fd0cf8589e94a57acb3ffff7b0cdd93bea95c5ee6539cad1fd789bbd4fa872576513af961e76d2481045c2d917e7363de21d1dfaeaaa768e3538192450955fb8780667832279ed8b1b48ffe148934f38fe36ac1b35421e629564dc2e930d43c2f15a974abf23f2e52dfd9650ebbea35f2899789ed09294adb5c6a73ca642c4db276ba1701b1d3e6b5d80143b249d6ce82767e384a02f4f38c74e54a9c89044354dc067c59dfedfbcb0f9eb315b01ba495b76efbff27cbb4f7af7ec71091e5621230da08bef9db9a3ce804a77f45807261f8c9025cc83c652891976c3c61643147e01a7251aaca5603ec3d4ccde20d18db6a5e4d77e511e2ddaf7295ff7cddcc732028e94bb1d678662760b926fb9c1b5b3ab6490252ef147ef95f049cf13e751d9f125aaf836162507ddadf002db4b7c391b1a5e5d4ac7709fdd7b2d244d0cc2afdee3a6a5a5ffc69a157c36519747f1f0c11cb3426af3bf201ce32f886405f1c015a0e18c992bb8b7ecf7e0daf00e58eccd99be80caec2b6117a3eb90c8ad81b1f3df8eb7b47aa557abbee0aefa25c080f215ac7f9121c4cfb363fe7af35e0a9726a7dfabab8699b4f6422ddad4ff0f5411582b15d96b34f7c6a4eed398c427a8b8c738349778e067e20a6433e8346a1205d6afe81133174d5190199cb54e20d6c2a4b7b7c779e871425ea0a420a654ffdc630a2509ca5b40cffabb2ee42ea59f5d31d9bda45e94af22d04f28b34c2fb9ac2fd560bbfac88f552eebddb753969b8e9e075b02090bc5105d73b7d721024c6fc7204e44310d24eb15beea1cbd48a8222f469648711493ad570835906e694b12a9f3dc204896edb1a5fe3cc8868d603bdf188a340d60c8a4ea89fe288b566942b6ebe3b8817c85bf5e74e565f9a3534912127acdd40c876897c345e3f778b1dd30ee63af86274bbdcc63f3d0d53910cb9269e45dac14127185339662cd6018293a65e2c032f35a195dd0dc348254b41e3a0318c411b48cd8524cb46ddfdd1aa46ddc9a9700a26219b166e85d83a198c048662c67e79dc4ce8fb53fc964c69767df167f7c804b2804fbd2775282be7332b3f137e3aa3d53b11c977ba7145773d11a62919912f0a165c78dd1522e4dc7818247d77766a423b26aa16920b7090e4bfa1adc855ae71ca89a74725802e7d7594c938190789f6bc0c8025e84227beb2e3fdfa52cdb4dacb30ca83f7b57b06154e47731df23d2efc711b22ba797c1c269d6abb0ed0e30c4ef3f84192bb9d7669ad48c9e3f76d8c6b54c0317ce67e57ee72a65a8a47619a2725192862891969458902215ef556def1abc82be4ed7a176ff72531f70c0031bf5df38544caad6a23243daa698600ffeedc5b5459fa07c53aa60922f75b8ecd8cf97a2d538cda6cff3741a59adcc26c37c1420783f0e02a36f3f25fb8c8f1c149595f1b324dd845e520eff7d61cc6184159339c90826378cb1d6406576313cd9e27dd29e51315a1bf1894117ba27e2e017270b9c4ba0622b8992fd17d822</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wilcoxon signed-rank test</title>
      <link href="/posts/wilcoxon-signed-rank-test/"/>
      <url>/posts/wilcoxon-signed-rank-test/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>Wilcoxon符号秩检验是一种非参数检验方法（总体没有高斯分布），t检验貌似要数据服从高斯分布。</p><p>具体是这么操作的： 假如有两组数据<spanclass="math inline">\(X\)</span>和<spanclass="math inline">\(Y\)</span>需要检验对比：<spanclass="math inline">\((X_i,Y_i)\)</span>首先被转为差值<spanclass="math inline">\(X_i-Y_i\)</span>，记为<spanclass="math inline">\(Z_i\)</span>，假设<spanclass="math inline">\(Z_i\neq 0\)</span>且绝对值均不等： 1. 计算<spanclass="math inline">\(|Z_i|\)</span> 2. 将<spanclass="math inline">\(|Z_i|\)</span>排序得排序后的索引<spanclass="math inline">\(R_i\)</span> 3. 检验统计量<spanclass="math inline">\(T=\sum sgn(Z_i)R_i\)</span> 4. 通过对比<spanclass="math inline">\(T\)</span>和原假设下的分布求出p值</p><p>如果存在<span class="math inline">\(Z_i=0\)</span>，有几种处理方法：1. <code>zero_method="wilcox"</code>：忽略所有等于0的数据 2.<code>zero_method="pratt"</code>：排序时考虑为0的项，排完后扔掉这些0项的秩3. <code>zero_method="zsplit"</code>：</p><h2 id="refs">Refs</h2><p><ahref="https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test">Wilcoxonsigned-rank test</a><br /><ahref="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wilcoxon.html">scipy.stats.wilcoxon</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144 Lab</title>
      <link href="/posts/cs144-lab/"/>
      <url>/posts/cs144-lab/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cs144.github.io/">Introduction to ComputerNetworking</a>是Stanford的网络课，据说lab质量很高，就把它作为转System后的第一个小系统吧！</p><h2 id="准备工作">准备工作</h2><p>Stanford大气！能让我们这些野鸡学校的同学接触到最顶级的教育资源，甚至开放了lab，也希望大伙不要把题解po到github上！</p><p>因此我做的是Fall 2021的版本，所有的starter code都在<ahref="https://github.com/CS144/sponge">这里</a>。</p><p>至于如何在自己的github上备份代码，参考<ahref="https://stackoverflow.com/questions/10065526/github-how-to-make-a-fork-of-public-repository-private">这里</a>。</p><p>虚拟机平台用的是VirtualBox，144官方提供了基于Ubuntu的系统镜像，CPU和RAM随便设。</p><p>大致按照<ahref="https://stanford.edu/class/cs144/vm_howto/">官方文档</a>配置环境，windows环境可以用powershell，无需<ahref="https://putty.org/">Putty</a>。<br />开启虚拟机，通过sshclient建立TCP连接到远程主机的某端口：<code>ssh user@remote -p port</code>，<code>user</code>是在远程主机的用户名，<code>remote</code>是远程机器的地址（IP/域名），<code>port</code>是sshserver监听的端口，默认22（即登录请求会送进远程主机的22端口），上面通过-p参数改变了该端口。</p><p>不过遇到了点问题：<br /><img src="lab0-1.png" alt="putty error" /><br />奇怪！远程虚拟机明明安装了ssh服务!</p><p>从主机去ping虚拟机超时，但是虚拟机可以ping通主机，参考<ahref="https://www.cnblogs.com/mengjie88/p/11803879.html">这个设置</a>成功ping通，后来发现国内的这些blog都是在胡说八道，真正的原因和解决方案在<ahref="https://unix.stackexchange.com/questions/145997/trying-to-ssh-to-local-vm-ubuntu-with-putty">这里</a>，本质上是虚拟机的端口转发没设置好，设置好后VB会把连接localhost:2222的TCP请求转发到虚拟机的22号端口。</p><p>关于IDE，开始用的VIM，后来想用vscode，Host上安装vscode以及remote-ssh插件，关于配置网上一大堆教程，自行学习吧，powershell以后就负责编译运行了。</p><h2 id="lab-0">Lab 0</h2><h3 id="networking-by-hand">Networking by hand</h3><p>这些小游戏都是为了翻译翻译：什么是可靠的双向字节流，网络通过这种抽象完成许多重要的交互，如上网冲浪、发邮件等。</p><p>第一个事是要手动模拟浏览器的请求过程（注意手速，不然还没输完就408Timeout了）：</p><ol type="1"><li><code>telnet cs144.keithw.org http</code>：<code>telnet</code>作为一种client程序，负责和服务器的某个服务建立连接。用telnet客户端程序在本机和服务器之间开一个可靠的字节流，并请求服务器的http服务（80端口），连接成功证明端口可用</li><li>建立连接后就要通过HTTP协议请求内容：需要告诉服务器所请求URL的path和host：<code>GET /hello HTTP/1.1</code><code>Host: cs144.keithw.org</code>，不过为啥需要host呢？难道服务器不知道自己的ip吗，好像是因为服务器可以同时运行多个网站/服务</li><li><code>Connection: close</code>：表示希望服务器一旦完成响应，就关闭连接</li><li>输入回车（空行）：表示HTTP请求头结束，接下来是请求数据（当然GET没有，POST有）</li></ol><p>其实这就是一个HTTP请求报文，效果：<br /><img src="lab0-2.png" alt="在这里插入图片描述" /><br />作业就是瞎玩：<br /><img src="lab0-3.png" alt="在这里插入图片描述" /></p><p>第二个事是学着发邮件，请求服务器的SMTP服务（主要用来发邮件），我试试和自己的邮箱互动下：<br /><img src="lab0-4.png" alt="在这里插入图片描述" /><br />这里要注意：首先要开启IMAP/SMTP服务，还需要获取第三方客户端登录的授权码，登录时邮箱名称和授权码都需要Base64格式。</p><p>文档里说From地址是可以伪造的，有点神奇，垃圾邮件可能挺喜欢干这事！但是我实际操作时是伪造不了的：<br /><img src="lab0-5.png" alt="在这里插入图片描述" /><br />因为已经登录了本人账户，所以发件人必须一致，Stanford那个没有登录，也许是商业邮件系统一般都比较完善？</p><p>第三个事是作为服务器去监听，主要使用所谓的瑞士军刀netcat：<br /><code>netcat -v -l -p 9090</code>：-v表示显示执行命令过程，-l表示开启监听，-p表示在指定端口监听<br /><code>telnet localhost 9090</code>：<br />然后服务器（netcat）和客户端（telnet）就可以通信啦！</p><h3 id="network-program-using-an-os-stream-socket">Network program usingan OS stream socket</h3><p>这部分让同志们利用操作系统内核提供的streamsocket从Internet上抓网页，和上文中手动抓差不多，不过这次是把手动过程写成代码。</p><p>由于Internet只能提供尽最大努力交付的数据报服务，因此这些数据报可能会：丢失、乱序、内容更改、重复，所以通常OS会把Internet的这种抽象转为可靠的双向字节流，以便应用层软件使用。OS一般使用socket来完成这种转变并向程序员提供接口，socket和文件描述符类似，一旦建立连接就能进行可靠的通信。后续会自己实现一个TCP去揣摩这种转变。</p><p>这个简单的web client程序有几个要注意的地方：</p><ol type="1"><li>由于<code>connection: close</code>，因此服务器只会处理一次http请求</li><li>服务器响应后就会关闭从server到client的socket连接，但是client的<code>socket.read()</code>可以持续读：Ifthe connection is broken on a stream socket, but data is available, thenthe read() function reads the data and gives no error. If the connectionis broken on a stream socket, but no data is available, then the read()function returns 0 bytes as EOF.</li><li>EOF一般是一个定义为-1的宏，因此没有对应的ASCII字符，因此也无法显示出来（可以强制转int），C语言将其定义在某个头文件的宏里（可以直接用EOF判断），C++一般使用函数判断。EOF的作用就是client可以判断是否读完了server发来的响应，终端输入windows环境是ctrl+Z，linux是ctrl+D</li><li>为什么一个<code>read()</code>不够呢？因为<code>read()</code>是有limit的，超过上限就得多次读，<code>std:string FileDescriptor::read(const size_t limit=std::numeric_limits&lt;size_t&gt;::max())</code></li><li>及时关掉socket的写功能是一个<ahref="https://stackoverflow.com/questions/4160347/close-vs-shutdown-socket">好习惯</a></li></ol><figure><img src="lab0-6.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="an-in-memory-reliable-byte-stream">An in-memory reliable bytestream</h3><p>在单机上实现一个可靠的字节流（内存里当然是可靠的），即接收方收到的字节流和发送方发出的字节流是完全一致的，writer可以结束字节流输入，reader读到EOF后就无法继续读。<br />基本可以理解为一个容量为<code>capacity</code>的buffer，<code>capacity</code>用来进行流量控制，文档说了只会进行单线程操作，因此不用担心并发的读/写。<br />需要注意：流本身可以无限长，<code>capacity</code>存储的是已经写入但还未读取的字节，哪怕<code>capacity = 1</code>，只要writer每次写入一个字节，reader读走，这个流就可以无限长。</p><p>开始想用<code>queue</code>，但是<code>queue</code>无法支持<code>peek_output</code>操作，那就用<code>deque</code>了。<br /><code>size_t write(const std::string &amp;data)</code>：如果长度大于<code>capacity</code>该如何处理？这种情况多余的写入只能被丢弃，就和网络上超出线路容量的写入被丢弃一样。<br /><code>size_t bytes_read() const</code>返回的是所有pop的字节数目，包括<code>read(const size_t len)</code>和<code>pop_output(const size_t len)</code>。<br /><code>bool input_ended() const</code>返回流输入是否结束；<code>bool eof() const</code>是reader判断是否读取到了流输出的结束位置，因此必须满足writer已经有过写入且buffer为空。</p><p>记得先<code>make format</code>，再<code>make</code>编译，最后<code>make check_lab0</code>自动化测试。</p><h2 id="lab-1">Lab 1</h2><p>接下来的4个lab要自行实现一个TCP，模块如下：<br /><img src="lab1-1.png" alt="在这里插入图片描述" /><br />由于sender会将发送的字节流分割为若干segments，每段不超过1460B，封装为数据报交给网络传送，但这些segments可能会乱序、丢失、重复、交叉重叠、长度不一，但是不会出现inconsistent的段，因此Lab1要实现一个流重组器，将收到的字节流中的segments拼接还原为其原本正确的顺序。</p><p><code>StreamReassembler</code>会用一个可靠字节流<code>ByteStream</code>作为输出：assoon as the reassembler knows the next byte of the stream, it will writeit into the <code>ByteStream</code>.接着应用层就可以从<code>ByteStream</code>读取有序的字节流。<code>StreamReassembler</code>和<code>ByteStream</code>的容量大小是一样的，不过<code>ByteStream</code>真正的size（绿色部分）是动态变化的。</p><p><code>push_substring(const string &amp;data, const uint64_t index, const bool eof)</code>一旦超出<code>StreamReassembler</code>的容量，就只能丢弃该碎片（或者丢弃部分）；<br /><img src="lab1-2.png" alt="在这里插入图片描述" /><br />根据上图：可以想象为我们拥有一条index从0开始的无限长的字节流，每个段都有自己在流中的位置，随着应用层读取流中的数据，<code>StreamReassembler</code>就像一个滑动的窗口，落在该窗口内的段都需要被按序组装。</p><p>显然，需要用某种数据结构把不能直接写入<code>ByteStream</code>中的segments存起来：<strong>data+index</strong>即可唯一确定，因此单个segment可以用类、结构体或<code>std::pair</code>存储，为了方便起见，在segment结构体中增加成员变量<code>len</code>来指示其有效长度。<br />由于可能需要根据index快速查找合并位置，因此最好按序存储，并且自动去重，所有不能写入的segments可以用<code>std::set</code>来存，底层基于红黑树实现。</p><p>处理逻辑：</p><ol type="1"><li>新来段是否超出/部分超出了<code>StreamReassembler</code>的窗宽，如超过则进行剪切；</li><li>新来段是否和<code>ByteStream</code>之前（蓝色+绿色部分）有重叠，如有则切除重叠部分；</li><li>合并新段和暂存段：确定新段插入位置，不断将其前后的暂存段往新段上合并，直到找不到可以继续合并的暂存段；</li><li>判断能否写入<code>ByteStream</code>；</li><li><strong>处理后</strong>新段的eof为true：<del>若暂存区为空，结束向<code>ByteStream</code>的写入</del>结束写入的时机可能会导致潜在bug，后面有血泪教训；若暂存区非空，<del>报错</del>，可能是lastsegment先到达但还不能写入，因此存入暂存区。</li></ol><p>根据上述逻辑准备用3个函数完成：</p><ol type="1"><li><code>void _cut_overlap(segment &amp;seg);</code>完成12</li><li><code>void _merge_segs(segment &amp;seg);</code>完成3</li><li><code>void _write_to_stream();</code>完成4</li><li>直接在<code>push_substring()</code>处理5</li></ol><p>这个实验一般就会开始出bug，我直接跪在了cornercase，来了一个eof为<code>true</code>的<code>""</code>，空串是要被忽略的，但是这个空串带了我们需要的eof信息，由于在<code>_cut_overlap</code>直接返回：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (seg.index &gt;= _first_unacceptable || seg.index + seg.len &lt;= _first_unassembled)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure> 所以没有正确设置<code>_eof</code>：<br /><img src="lab1-3.png" alt="在这里插入图片描述" /><br />测试样例<code>t_strm_reassem_single</code>报错，所有的测试源码都在<code>./tests</code>文件夹下，对应的可执行程序在<code>./build/tests</code>。<br /><code>sudo apt-get install gdb</code>安装GDB，找到对应的测试源码文件<code>fsm_stream_reassembler_single.cc</code>打断点开始调试，跳出<code>launch.json</code>稍作修改就可以愉快地debug（面向测试编程😂）了：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;sponge debug&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/tests/$&#123;fileBasenameNoExtension&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: g++-8 build active file&quot;,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后来第7个样例一直过不了，而且ByteStream实际读取的字节数和真实值差距很大：<br /><img src="lab1-4.png" alt="在这里插入图片描述" /></p><p>怀疑是提前<code>end_input()</code>了，主要是下面这种case：<br />first unassembled=7且firstunacceptable很大，先来一个<code>index=9, eof=true</code>的""，再来一个<code>index=7, eof=false</code>的"ab"，如果这样判断：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_eof &amp;&amp; _unassembled_bytes == <span class="number">0</span>) &#123;</span><br><span class="line">    _output.<span class="built_in">end_input</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>很容易在第一个段就<code>end_input()</code>导致提前结束写入。<br />因此核心问题在于什么时候调用<code>end_input()</code>，我用了<code>_eof_index</code>来指示结束的位置而非用布尔变量<code>_eof</code>，一旦<code>_first_unassembled &gt;= _eof_index</code>就结束输入。</p><h2 id="lab-2">Lab 2</h2><p>Lab2要实现<code>TCPReceiver</code>，将从Internet接收的segments送入<code>StreamReassembler</code>转为可靠的<code>ByteStream</code>，以供应用层从socket读取。<br />除此之外，<code>TCPReceiver</code>还要负责和sender反馈：1. firstunassembled字节的index，也叫做确认号<strong>acknowledgment</strong>，这样sender才知道下次该发送啥；2.first unassembled和first unacceptable之间的窗宽windowsize，用来告诉sender允许发送的字节范围。两者结合形成滑动窗口用来进行<strong>flowcontrol</strong>。</p><p>第一件必须要处理的事就是序列号sequencenumber的转换：在<code>StreamReassembler</code>中我们用的是64位的streamindex，因此不太可能溢出，但是TCPheader空间宝贵，所以第一个字节的index采用32位的seqno，这样就带来几个问题：1. stream index可以近似于无限大，但是seqno只能从<spanclass="math inline">\(0\sim2^{32}-1\)</span>不断循环； 2.为了安全起见，seqno并不是从0开始，而是取一个随机数Initial SequenceNumber(ISN)来表示stream的开始SYN(beginning of stream)； 3. TCPheader中的SYN和FIN(end ofstream)标志位都要被分配seqno，但是SYN和FIN并不是真正的数据，只是表示流的开始和结束。</p><figure><img src="lab2-1.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><table style="width:100%;"><colgroup><col style="width: 7%" /><col style="width: 7%" /><col style="width: 7%" /><col style="width: 4%" /><col style="width: 19%" /><col style="width: 7%" /><col style="width: 4%" /><col style="width: 21%" /><col style="width: 4%" /><col style="width: 7%" /><col style="width: 7%" /></colgroup><thead><tr><th>isn</th><th>isn+1</th><th>isn+2</th><th>...</th><th>2^32-2</th><th>2^32-1</th><th>0</th><th>1</th><th>...</th><th>isn-2</th><th>isn-1</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>...</td><td></td><td></td><td></td><td></td><td></td><td>2^32-2</td><td>2^32-1</td></tr><tr><td>2^32</td><td>2^32+1</td><td>2^32+2</td><td>...</td><td></td><td></td><td></td><td></td><td></td><td>2^33-2</td><td>2^33-1</td></tr><tr><td>NaN</td><td>0</td><td>1</td><td>...</td><td>first unassemble</td><td>...</td><td></td><td>first unacceptable</td><td></td><td>2^32-3</td><td>2^32-2</td></tr><tr><td>2^32-1</td><td>2^32</td><td>2^32+1</td><td>...</td><td></td><td></td><td></td><td></td><td></td><td>2^33-3</td><td>2^33-2</td></tr></tbody></table><p>第一行是32位的seqno，可以想象成在圆环上走路（正反走均可），二三行是64位的absoluteseqno，四五行是64位的stream index。</p><p>absolute seqno转seqno：<spanclass="math inline">\(isn+n\%2^{32}\)</span>，<spanclass="math inline">\(n\)</span>直接强制类型转换即可截取低32位。<br />seqno转absoluteseqno：有点麻烦，可能对应多个结果，因此选择距离<code>checkpoint</code>最近的那个结果，<code>checkpoint</code>取前一次所收段的absoluteseqno。原因在于两个前后到达的段absolute seqno的差值几乎不可能超过<spanclass="math inline">\(2^{32}\)</span>。有个cornercase是当<code>checkpoint</code>比较小时计算得到的absoluteseqno可能小于0，需要加上<span class="math inline">\(2^{32}\)</span>即<ahref="https://stackoverflow.com/questions/4201301/warning-left-shift-count-width-of-type"><code>1UL&lt;&lt;32</code></a>。</p><p>做好索引的转换后，因为麻烦的部分已经在Lab1完成了，剩下的就是根据<code>TCPSegment</code>写一些业务逻辑。<br /><img src="lab2-2.png" alt="在这里插入图片描述" /></p><p>注意下SYN和FIN对ackno的处理就行： <img src="lab2-3.png"alt="在这里插入图片描述" /></p><h2 id="lab-3">Lab 3</h2><p>这次的活是TCPSender，负责将应用层的ByteStream分割为段发送，根据接收方的反馈情况进行超时重传。</p><p>每次收到接收方的ACK就可以知道其window size,发送方在每次收到ACK时更新窗宽，并且在下一次收到ACK前，根据发送情况记录窗口的剩余容量，决定是否继续发送。<br />只要<code>_stream</code>还有需要发送的内容并且receiver还有空闲空间，<code>fill_window</code>就要一直组装成段并发送直到填满该窗口，receiver真正的freespace应该是其声明的窗宽减去已发送但未被确认的所有段的长度总和，这个freespace才是可以不断继续组装新段并发送时可以利用的，在<code>fill_window</code>组装新段之前要check该空间是否大于0。</p><p>另外，发送的第一个段是SYN段，没有数据，只有SYN和initial sequencenumber，SYN段发完后就返回等待receiver的connectiongranted，即第一次握手，此时窗宽看作1：</p><blockquote><p>What should my TCPSender assume as the receiver's window size beforeI've gotten an ACK from the receiver? One byte.</p></blockquote><p>并且在TCPHeader中SYN和FIN不能同时为1，否则应该报错RST，FIN段是可以携带数据的。</p><p>如果收到ack表明窗口大小为0，在<code>fill_window</code>当作1处理，但是超时的段不应doubleRTO，因为这是receiver的原因而非线路流量限制导致的，但是SYN段超时需要doubleRTO并增加重传counter，以便判断是否终止本次连接请求。</p><p>FIN段的处理需要仔细一些：<br />如果<code>_stream.read</code>以后<code>_stream.eof()</code>意味着ByteStream已经没有需要发送的东西了，这时就要考虑设置FIN的问题了，但是FIN是要占序列号的，也就意味着要在接收方的window里占空间，如果freespace为50最后一段的payload size为30，那可以设置FIN；如果freespace为50最后一段的payloadsize为51，那么最后一个字节就需要进行下一次发送，并且在下一次考虑FIN的设置问题；如果freespace为50最后一段的payloadsize也为50，那么这段数据可以发送，但是这次没法设置FIN了，也就只能等到接收方腾出空间后才能继续。因此只有freespace严格大于最后一段的payload size才可以设置FIN。</p><p><code>fill_window</code>有一种情况，freespace还有但是<code>_stream.buffer_empty()</code>已经空了，但是只是数据发完了，FIN标志还没发，就需要再发一个段，因此这样写是不行的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!_stream.<span class="built_in">buffer_empty</span>() &amp;&amp; _receiver_free_space) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="lab3-1.png" alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>可以直接多循环一次然后用segment的<code>length_in_sequence</code>判断流是否真的空了以及是否要继续发送：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (_receiver_free_space) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> payload_size =</span><br><span class="line">        <span class="built_in">min</span>(&#123;_stream.<span class="built_in">buffer_size</span>(), <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(_receiver_free_space),</span><br><span class="line">             TCPConfig::MAX_PAYLOAD_SIZE&#125;);</span><br><span class="line">    TCPSegment seg;</span><br><span class="line">    <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(_receiver_free_space) &gt; payload_size) &#123;</span><br><span class="line">        seg.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">        _fin = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(_stream.<span class="built_in">read</span>(payload_size));</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    _send_segment(seg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但是这样可能导致一直发送只包含FIN的段，因此要在while循环限定<code>_fin</code>来确保只发一次FIN段。</p><p>关于重传，闲来无事，把重传计时器单独写一个类，因为这个类相对比较简单，所以就和sender放在同一个头文件吧，不过据说有些公司的codingguideline有规定：</p><blockquote><p>Each class shall have it's own header and implementation file.</p></blockquote><p>采用累计确认：如果发送方收到ackno代表之前的所有段都正常接收，因此用<code>std::queue</code>存没有收到ack的段（包括只被ack了一部分的段），超时后从队头开始传。<br /><code>_segments_outstanding</code>发送时在<code>std::queue</code>里是按照seqno有序的，只有每次收到ack才从<code>std::queue</code>里扔掉一些已经被完全确认收到的段，否则认为<code>std::queue</code>里的所有段接收方均未收到。</p><p>收到ack并清理完<code>_segments_outstanding</code>后，如果此时还有未被确认的段，重启计时器并将RTO和重传counter恢复初始值。<br />注意收到的ack可能是非法的，比如ack了一个还没有发送的段或者ack了已经收到的段的序列号<br />还有一个cornercase在<code>send_extra.cc</code>的95行，如果收到了与上次相同的ack，计时器是不应该重启的，重传时只有收到的ackno严格大于上一次的ackno才重启。</p><p>计时器的启动可以参考课本： <img src="retransmit.png"alt="计时器" /></p><h2 id="lab-4">Lab 4</h2><p>本次实验要实现<code>TCPConnection</code>负责将同一个主机内的<code>TCPSender</code>和<code>TCPReceiver</code>衔接起来，理论上如果<code>TCPSender</code>和<code>TCPReceiver</code>足够鲁棒，那么<code>TCPConnection</code>写起来很快，然而现实太过冰冷...第一次在项目中体会到测试的重要性，也有点理解TDD的好处了，好的测试不仅能够发现问题，还能根据测试样例debug，再次跪谢Stanford~</p><p><code>TCPConnection</code>既充当接收者，也充当发送者，可以理解为实现以后就可以在你自己的主机上使用，接收别人的消息，发送自己的消息。还有syn的处理需要考虑作为接收方和发送方两种情况分别处理。</p><p>通过<code>segment_received</code>收到TCP段后：</p><ul><li>如果RST为真，sender和receiver都要将其字节流设置为出错状态并立即终止连接；</li><li><code>TCPReceiver</code>获取自己需要的信息：seqno, SYN, payload,FIN。如果ACK为真，需要告诉<code>TCPSender</code>相关信息：ackno, windowsize。</li><li><strong>只要收到了<code>length_in_sequence&gt;0</code>的段都需要发ACK，如果sender要发数据那可以顺便携带ACK，否则就要发空ACK</strong>，便于peer更新ackno和windowsize。我遇到的第一个corner case就是空ACK段（比如第3次握手），由于Lab3的sender只关注ackno和windowsize，通过要发送的seg的<code>length_in_sequence</code>判断是否继续发送，第二次握手收到一个payload为0的段，以后正常交流是不会这样的，因此第三次握手应该回一个段（可带可不带数据），但是Lab3的<code>fill_window</code>遇到这种情况会直接返回，不会发送，我们在这里发送一个空ACK段作为第三次握手。</li></ul><figure><img src="lab4-1.png" alt="三次握手" /><figcaption aria-hidden="true">三次握手</figcaption></figure><ul><li>还有收到keep-alive段的处理：peer可能发送了一个非法序列号的空ACK段来判断连接是否正常并获取我方的windowsize，需要回应空ACK段。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span></span><br><span class="line">      &amp;&amp; seg.<span class="built_in">header</span>().seqno == _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>TCPSender</code>负责生成要发送的段并填充相关信息：seqno, SYN,payload, FIN。并且从<code>TCPReceiver</code>获取ackno和windowsize进行填充，如果有ackno还要填充ACK。</p><p><code>tick</code>这里如果超过最大重传次数，不仅需要关闭连接，还要给peer发送RST段：如果sender的<code>segments_out()</code>不空，直接将队头的段设为RST，否则调用<code>send_empty_segment()</code>设置RST并发送。</p><p>比较抽象的是TCP的关闭这部分，有2种关闭方式：</p><ul><li>uncleanshutdown：如果<code>TCPConnection</code>发送或收到RST段，立即将发送和接收字节流设为error，并且<code>active()</code>返回false</li><li>clean shutdown：不出错的情况下关闭连接。</li></ul><p>由于<ahref="https://en.wikipedia.org/wiki/Two_Generals%27_Problem">TwoGeneralsProblem</a>，背后的道理是在不可靠的通信链路上通信双方理论上不可能达成一致，因为总有最后一条消息是不能被确定收到的。因此只能A确认B是否收到即可，A保证B已经收到，但是B并不知道A知道B收到了。即client并不知道server是否收到了最后一个ACK，因此不可能两边都做到cleanshutdown。<br /><img src="lab4-2.png" alt="在这里插入图片描述" /></p><p>四次挥手是这样的：</p><ol type="1"><li>client发完数据后发送FIN通知server自己发完了，但是server不一定收到了，client也不知道server是不是收到了；</li><li>因此server发回ACK通知client自己收到了FIN，此时client知道服务器收到了自己的所有数据，但服务器不知道客户端是否收到了ACK；</li><li>服务器的数据发完后发送FIN，通知客户端自己发完了；</li><li>客户端对FIN做ACK，表示自己收到了所有数据。这个时候客户端知道：服务器收到了自己发的所有数据，自己也收到了服务器的所有数据，客户端没有问题。但是服务器如果没有收到最后一个ACK：它只知道自己接收了客户端的所有数据，但无法确认客户端是否接收了自己的所有数据。因此这个ACK如果没有收到，服务器重发FIN，但如果此时客户端已经关闭连接，最后这个ACK就永远收不到，这也是为什么有timewait。服务器收到ACK后就直接关闭连接。</li></ol><p>从client角度来讲，做到clean shutdown有4个前提：</p><ol type="1"><li>接收字节流已经被完全组装且该流已经结束（peer不会再有新的输入了），对应<code>ByteStream::input_ended()</code>，即收到Server的FIN，Server确定接收了所有数据。</li><li>发送字节流已经被本地应用层终止（即本机不会再发了）且已经完全发送（即字节流为空），对应<code>ByteStream::eof()</code>，即client发送FIN，但是并不代表server收到了FIN</li><li>发送字节流已经被peer完全收到，对应client收到的ACK</li><li>client知道Server收到了ACK，这一点无法保证，因此有time wait。</li></ol><p>总结一下就是：什么时候不需要timewait？如果是第二个发送FIN就不需要，那怎么判断是第二个发的呢，如果已经收到了FIN（对应<code>_receiver.stream_out().input_ended()</code>）并且自己还没发（对应<code>!_sender.stream_in().eof()</code>）就是第二个。什么时候cleanshutdown呢？满足前3个前提的前提下，如果不需要time wait或者已经timewait了足够长时间就可以关闭。</p><p>初步写完代码后，就对着测试样例疯狂调bug吧！！有时候打断点会瞎跳，据说是编译优化的问题：<br /><img src="lab4-3.png" alt="image" /><br />默认的Debug模式的编译选项是<code>-Og</code>，会对局部变量等进行优化，因此关掉优化选项，将<code>sponge/etc/cflags.cmake</code>中：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> (CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -ggdb3 -Og&quot;</span>)</span><br></pre></td></tr></table></figure> 改为 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> (CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -ggdb3 -g&quot;</span>)</span><br></pre></td></tr></table></figure></p><p><code>txrx.sh</code>的测试不好调试，可以用<code>cerr</code>打印一些变量，但不能用<code>cout</code>：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../txrx.sh -isDnd 128K -w 8K -l 0.1</span><br></pre></td></tr></table></figure> 调单个测试用例可以：<code>ctest -R test_name</code></p><p>如果按照状态机来写的话可能好一些，但不一定非要按照状态机写，网上有人说不按照状态机写肯定有问题，官方文档也说了，状态不过是一些模块的公有接口而已，不一定非要materializethese states in your code。 <img src="lab4-4.png" alt="image" /></p><p>神呀！<code>Test #104-#160</code>一直过不了，卡了三天，用Wireshark抓包，发现一直在重传SYN：<br /><img src="lab4-5.png" alt="image" /><br /><img src="lab4-6.png" alt="在这里插入图片描述" /></p><p>实在没辙了，无奈只能通过替换网上的模块找bug。但是Lab 0-Lab4全部替换后仍然是那个bug，不知道哪里有问题。。。严重怀疑由于服务器在美国的原因，结果不是。和大神讨论了下，据说换成VMware就好了。。。开始搭环境。</p><p>编译时如果提示g++版本太低，那就安装8.0以上版本并且进行<ahref="https://blog.csdn.net/kenkao/article/details/89550641?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-4.no_search_link&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7">版本切换</a>，如果还是报错<code>The CXX compiler identification is GNU ...</code>，还要修改<ahref="https://www.cnblogs.com/minglee/p/9016306.html">编译选项</a>。</p><p>接着就可以正常make和测试了。换到VMware没有任何改动一次性通过了所有测试：<img src="lab4-7.png" alt="image" /></p><p>有点离谱...第一次遇到系统级别的Bug，至今还不知道咋回事...<br />吞吐量结果： <img src="lab4-8.png" alt="image" /></p><p>虽说是达到了100Mbit/s的最低要求，但肯定还有提升空间。我没做profiling，参考别人的分析基本就是<code>ByteStream</code>的一些操作造成了瓶颈，换成<code>BufferList</code>后有一些提升：<img src="lab4-9.png" alt="在这里插入图片描述" /></p><p>接下来的瓶颈应该在流重组器，等以后有时间再说吧😂</p><p>性能优化：<br /><a href="https://zhuanlan.zhihu.com/p/414279516">参考1</a><br /><a href="https://www.lofivo.com/posts/44483/">参考2</a><br /><a href="https://zhuanlan.zhihu.com/p/553855680">参考3</a><br /><a href="https://vixbob.moe/25.html">参考4</a></p><h2 id="lab-5">Lab 5</h2><p>实现IP/Ethernet网络接口，也叫网络适配器/网卡，用于IP数据报和以太网帧的转换，可以作为主机的TCP/IP协议栈的一部分，也可以作为路由器的一部分。<img src="lab5-1.png" alt="image" /></p><p>主机与peer之间TCP段的交互主要有以下几种方式：</p><ul><li>TCP-in-UDP-in-IP：进程只需提供TCP段和目的地址，剩下的事情均由Linux的<code>UDPSocket</code>完成。内核负责构造UDP/IP/Ethernetheader并发给下一跳，并确保每对socket的组合都是唯一的，保证不同进程间的隔离。</li><li>TCP-in-IP：大部分情况下TCP段都是直接作为IP数据报的payload，需要向Linux的TUN接口提供IP数据报，内核负责构造Ethernetheader并通过网卡发送，因此进程需要自行构造IP头。</li><li>TCP-in-IP-in-Ethernet：网络接口<code>eth0/eth1/wlan0</code>负责网络层和链路层的转换，Linux提供了更低级的TAP接口负责交换以太网帧。</li></ul><p>大部分的工作都在ARP协议，有3个函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkInterface::send_datagram</span><span class="params">(<span class="keyword">const</span> InternetDatagram &amp;dgram, <span class="keyword">const</span> Address &amp;next_hop)</span></span>;</span><br><span class="line"><span class="function">std::optional&lt;InternetDatagram&gt; <span class="title">NetworkInterface::recv_frame</span><span class="params">(<span class="keyword">const</span> EthernetFrame &amp;frame)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkInterface::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span></span>;</span><br></pre></td></tr></table></figure>当<code>TCPConnection</code>或者路由器要发送IP数据报时，需要该函数转为以太网帧并发送。<br />如果下一跳的MAC地址已知，创建一个以太网帧<code>type = EthernetHeader::TYPE_IPv4</code>，将payload设置为序列化后的数据报；<br />如果下一跳的MAC地址未知，广播ARP请求来获取MAC地址，缓存当前IP数据报。为了避免ARP泛洪攻击，如果5s内某个IP地址已经发了ARP请求，不再针对该IP继续发送ARP请求。理论上如果一直收不到ARP响应，网络接口应该向源主机发送ICMPhost unreachable报文，并且丢弃相应的IP数据报。<br />只要ARP表没找到，说明需要学习目标MAC地址，因此发送的IP数据报均需要缓存。不论收到ARP请求还是回复，都需要学习ARP表，如果是请求，还要发送ARP响应。ARP表中条目的TTL为30s。</p><p>由于以太网帧只传递一跳，如果收到的帧的目标MAC既不是当前网络接口的MAC也不是广播MAC就忽略。</p><p>完成后，就可以将<code>webget.cc</code>中使用的<code>TCPSocket</code>换成<code>FullStackSocket</code>，这样从传输层到链路层的转换都是自己的组件。</p><p>VMware可以过，VB还是挂： <img src="lab5-2.png" alt="image" /></p><h2 id="lab-6">Lab 6</h2><p>这个实验要基于Lab5的<code>NetworkInterface</code>实现一个IP路由器，负责将接收到的数据报根据路由表转发：从哪个网络接口转发以及下一跳的IP地址。<br />我们只负责根据生成的路由表转发，至于如何生成路由表（RIP/OSPF/BGP）无需关心。<br /><img src="lab6.png" alt="image" /></p><p>第一个函数<code>void add_route(const uint32_t route_prefix, const uint8_t prefix_length, const optional&lt;Address&gt; next_hop, const size_t interface_num);</code>负责保存每条路由信息以备后续使用。<br /><code>route_prefix</code>和<code>prefix_length</code>共同确定一个网段，比如<code>18.47.0.0/16</code>的<code>route_prefix=18*2^24+47*2^16,prefix_length=16</code>，如果一个数据报的目的IP是<code>18.47.x.y</code>那么该条路由即匹配。</p><p>如果路由器直接目的网段，路由信息的<code>next_hop</code>为空，直接通过<code>NetworkInterface</code>发送到目的IP；如果路由器通过其它路由器连接到目的网段，路由信息的<code>next_hop</code>为下一个路由器的IP。</p><p>第二个函数<code>void route_one_datagram(InternetDatagram &amp;dgram);</code>通过最长前缀匹配找到最佳路由，如果没有匹配的路由则丢弃数据报，如果该数据包的<spanclass="math inline">\(TTL\leq1\)</span>也丢弃，理论上丢弃数据报需要向源地址发送ICMP报文，否则通过最佳路由对应的<code>NetworkInterface</code>转发。</p><p>这里的abstraction在于路由器只需要关心IP数据报而无需关心链路层实现细节，只是通过<code>NetworkInterface</code>与链路层交互。</p><p>在通过移位比较两个IP地址前N位是否相同时，需要注意32位整数右移32位在C/C++中是<strong>未定义行为</strong>，因此<code>prefix_length == 0</code>需要特判。</p><h2 id="lab-7">Lab 7</h2><p>到此为止，实现了Internet的传输层TCP协议、网络层和链路层之间的接口转换以及路由转发。<br />这个实验让我们用实现的这些组件和另一个人交互： <img src="partner.png"alt="image" /></p><p>由于学校局域网内的IP都是私网地址（<code>10.0.0.0/8</code>，<code>172.16.0.0/12</code>，<code>192.168.0.0/16</code>），为了交互，需要通过<ahref="https://www.zhihu.com/question/31332694">NAT技术</a>映射到公网IP，所以使用了<code>cs144.keithw.org/104.196.238.229</code>作为中继服务器。<br /><img src="nat.png" alt="image" /></p><p>按照文档交互： <img src="jiaohu1.png" alt="image" /> <imgsrc="jiaohu2.png" alt="image" /></p><p>任意一方按<code>ctrl+D</code>单方向关闭连接后，就不能继续发送数据，但仍可以继续接收直到peer也关闭连接。双方都关闭后，任意一方完成了lingering之后连接才真正关闭。</p><p>除了聊天，还可以收发文件。</p><p>通关截图： <img src="jiaohu3.png" alt="image" /></p><h2 id="reference">Reference</h2><p><ahref="https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html">【计算机网络】StanfordCS144 Lab Assignments 学习笔记</a><br /><a href="http://yuzijun.life/2021-02/CS144">斯坦福计网实验 / CS144 LabAssignments</a><br /><ahref="https://kiprey.github.io/2021/11/cs144-lab0/">CS144计算机网络</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
            <tag> Projects </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新思考机器学习及职业方向选择</title>
      <link href="/posts/thoughts-on-ml-and-career/"/>
      <url>/posts/thoughts-on-ml-and-career/</url>
      
        <content type="html"><![CDATA[<p>最近参加了一个<ahref="https://datafountain.cn/competitions/537/">AI比赛</a>，引起了我对机器学习以及自己未来职业方向的重新思索，我发现自己现在做决定更加在乎自身的兴趣而非舆论等其他因素，也算是一种进步了吧！</p><p>比赛的过程我很难享受编程带来的乐趣，只有在看到AUC指标提升零点几个百分点时才会有一丝丝成就感，而在数据清洗、特征构建、魔改模型以及无脑调参这种占据算法工程师大量时间的环节感受到的只有繁琐和无聊，这不禁让我反思自己半年前的选择：如果将来步入互联网，到底是选择算法岗还是开发岗呢？</p><p>从世俗的角度来看，算法岗毫无疑问有着更高的薪资甚至更光明的前途，我也坚信机器学习会持续改变人类生活并且在未来应用到方方面面，但是需要多久时间可能谁也说不准。</p><p>从现阶段来看，AI的发展尤其是落地遇到了很多困难，突然想起了《智能计算》韩德强老师上课时指出的数据驱动的方法终究很难解释问题的本质，我当时嗤之以鼻，现在有些许赞同了。</p><p>从自身喜好来讲，对于不确定的东西我向来不太喜欢，然而机器学习领域充斥着大量的不确定性，大多数模型缺乏可解释性，我在操纵灰盒甚至黑盒的过程中祈求获得指标的提升，在出现bug时不好排查。除此之外，现实世界的数据大多数是杂乱繁琐的，需要花费80%以上的时间去清洗数据、构建特征，这也不是我喜欢做的事情。相对而言，我更加欣赏自己能做出来一个确定的、完整的系统呈现在眼前，它可以解决现实生活中的某个问题，并且可以重复使用（可复现），所以我决定学习重心重新回到开发岗位，当然如果时间充裕可以去算法岗实习看看再做最终的决定。</p><p>还有就是胡神的很多思考对我触动很深。</p><p>我想好啦，做system！当然我肯定会把当前分内的事情做好、该学的学懂！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>屠龙少年 遍体鳞伤</title>
      <link href="/posts/transform/"/>
      <url>/posts/transform/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="db8b67a42241832f0968e4ba73c3129c64854be41fbe31b5d72db57a758896c3">c172f4ee74b2b6d246b20cbfdc0b877efc42ed51cc9967fea7e00930fce7ffa8d4d197ad92799923025d6ef122972b450ca5a0e8515135641fe6542c23b5848673f9e775a61d5d0821ac039b480ccad26bf3c8463effc083007cad62c4d1ec49ad35c1e55c88a5a860dd03f9b4ce3f61405fdd3c08ee59dedf6ca4a49350c99d4176f36ba7dc4f7fca6d28027267bcfb88b285613210d99a1d2c8ce61cbc97e0226108f471a3c10a96da69a478d5aa00b369b3b0c78239ea97952e7aed206e81535886dc586cec6ca9df6963c589ad62c7f769fa45744fb62a36f10e1787ef42f3d69f589a8b1cb13e9e2a01822498fafd3f931216bec49524444a198884b06802bea88d8105fc633ee5fde561f5f4056a2a99edbb3eaa507e2e2ec7c00ed5ef0878a4225e79d097bdc4872306bb073ae395b3ca436e78dc8b71a962c536a6caa33927cc5e2a23b4401a15fa907d98814b9ecadc2ca6e501fd0aab2306af1eb45bd037ef672a1fd9d6cee078e2950ab953d3501a51451e454175d8cd049fe6c8fa3f606737dff9fb261ce78807a20c6ef79e32e96dd99a5cadebf505bd81402a3d128285449acda2c27de1b1865b298863bbeb3eaf6249cf8401c7ed0417d1ed35a33ee95e851af6f9aca025fc150e358112994f05ee9814fe24baded924e65c85ee08fe23dba8a28d13e13247c77763194d6333bb05a2fc8200cabd3be7c55892487a56af603dbb5852ca94eef2822551c5238b1a13f43272997c757c15d3dff03235090a4be26d408c89a2e307b84fcbd9e7d6f0c744b3c859d53b17733f2a7b0fd70cf380cfb70bcfecbbecbc530c2ebfcaf35d8e5462cb9d60ac779122b1bd62bf01f56369e41ad4995a861d920a34bec8ba27356f1d4970527bac8b536c7e02c9b83eed23f603b3ef2c8167bdeb65e27b2d7a340c62da91bbd65f62f550aeeaa5d8057eda0143448ea6bbf7f6f06066113dd1f6911804e3c38beb09509a769ec5d18efa01c9454d408d8a46401c7d0d93691d937fb89fce179f77e8c4052be04e2987e82b167ce76138fdefe8de87947b6fc7f45ec89919c69b7c5fe07224312d3bd767a43e287a085903e964f752e31f3e420b0980a0f94b195bdfa79c83fe95284e09f5e16032169195bb6eef7b8465b448c3370168398caf5975bfc8c79fc0fd957c410dba90b83f8149fc4d81b1b6ab75d4793a9f6e4828d71b02c371c6b43c0714f420ac8dc1e6822dd10368c9ecf70a4b42ba95f8c6804dae152be4ae363f21700f5f71ca030ac210487fe5ae317489e96b9f2eec793147a5c5cfb70494799d5b0bf6f0db8f197e738cd8a18755dcc5f29ed8cfc8745d1c426cb8c59dc363f6b725102ef4e499549135a0ccc2808dc32fbe7d45f062d26b57b2a26fa52dcea94cd5f7a6174acce26e0871b5dbcc23f1bc3ff0c53f4f78dce33128bebe8a53075cb7c438508d9aefc502339cb2c962f5de26113a4f3f9e0eb6880698bf50951ce43e87f7a094b128a2fc8ae3d089eeed946bc5b699ff281b6ccf8c1c9ce221a735a40ed5c938f68cc6714cd94d18c9e480645615b328f47d8ca401e8b799106e626f772f7e22bb0b22f949af7514dede93926147f7866b481363c37cd7195a3d95553b0b550f67361a6cbdb2739a436bd6aede5cd57c901adf4260a64a463c8adfde9dff188d85e2118de834ee8095d787ae52a01e7f56730c0da8cb05f51cd3b400bec4308d3987d2d06a8d77bf274d80d1d0cf2b2736727fff9642f08efd40d43b3643b4e499406ae8f0ea83e473857aced2c30029fd5e5e7c6997a6cc179a14e4478e04493712ea8066919f4dc7ae391e20de10065b53b1f56efb2deb47b3235153c59bddf591ef6b7eee396ba8b1d7f4d53f2f72da9ee59ec465b82234f14652ed330185e66cd12c8a9c38f5833262d0f39c23e7f580d7a8864c067ebc3ab6942c89f486b0be75984ff4e27821032fee868113898c15b3dc430e325ec77f89b250920ee01102f132e0bd0f8fd9db13538e5d24a03e8350c06c0d06ea2d2e2ae804baed1b1cc83e7c8951152d514ac5d45c96ba57eba9048e0181e253b76277075f4fbefbc150e6a38a33f1103aedce6f1a1874cbb9c720fbb0397e6da176ebc5bc373da831d6c59561dca6ef157563700baf9231a1bbe0d6406df63fd991bc1db2988c63ff6fa1713bdb5ca7df76a45d7a5cdcf3716c906fd40aff069a1e7edf40a19f4c08f054e84e791810bc028eee2f4517dea76666c8342282c4e719e7ca9532a9c9df3dda0f90783e24a0d1946ce5fd0f0fad289e35cd927d0e98de88366133537c184a0fec042739f4704a5a4862fbae10c6cbd4d126dc2f53cfbc3e27ac7fb45dc29797765993e96a7027abb46130c7668843bbee7b6fe18a76b26aca510046f73e2a8d9cfcf7747949cdcb2d27698e167163b9088e57b53219a1516de51b1e7e5690e766a65718a1e14a119026579e23201acced187a691c26e6cf5ebda2f5a1e459014c709f293be6575460e5dc42f6711af6343173ba077db2e6269d6bb99badda8fa30dd09fc7d8c90abc0e979cb55cd97c5f71ea49929b4938226e9dfb2e6cfd0d0e59187131d873a632a0d5b2b3edb48f2d0404587504aa21e4bc602c33935569659f9f359658d9d436644fcd4985e5950db9c2ae8b0901e4f3a8c5d01a93b48e755db98bad82f7d5c453548cbaf9cd3e262675285c8ebd3fb8bd5fc23500ec27fd1250cfe711abb6419ee1ff0c116dca4375fddc1d7698b5eeab5a7673d38adc98d4537dd7a6d032c403f0fc7bd86188e91e7975e11db290c0ed4f4e36c0c0a834ad277f0e31cd92d9bc2c94ac4fb3269ef790db565622ed0f4f970ef58adc349d629d89fb052816bdcdf0b0a34027fbe5feebd3bcedb77a3240c8fdbf0d9af4b1138e463ab94920f1ff813e1179483e07d4ec8253c24ccbbbdca28bbd108b46365227d3e4ab422b81ad2152b889dcd5f3b5cdf72478ac866de7c3af45af77e863baad178250bb51a7dbab064eb8659b9f77c1daf7ca793304500bd23559b423c04e7897c0ecb28a366d38fd15729e59eeeb7ab09229b50bed9e77ca20f48eac9294d91f8f47169d00cdce8d38105978ff7d5cc5ad314ca66b091fe1bb4f87e1ad3ba6e06c3ae988791185cf0bfbf88cadc16ce455c7b6f182136ca110e3862f2bafc83e4fc80cf6562476ab75252bd2736dbede18c257417bbedaa8645ec31956c728b5d0f64995221abda23bcfca6b117cfefb6c313c4877ac66166e34193d8bef52c85db3f784d23b18bb70c2987e6d22a4a5587b48784f4ee8e449adba4cf6109d637025ede2a834c392c4e952c8abf6adcbcb32be55575057d39ba4fec48c895f83b2193aca67117f02d55822b88fb952fcfa64f104617455fb2d0fe065bf4d766363770ae29ffe6705cd2e95e5baa9a9c6c4ad18c4977dd6d55a409850e54540b504b46447d89eacde0eeae4e0374cc25879a4212e1d9d3387f6b5f3ada7dd176392128373cc12e26010df786a79e9fb344335fb62be9a28a43b5d39cb6648445328e7a1a926f8e7a65782eb550c68558a9760c6d6289d5cbc653272d6fcff7e700bd1a39d6f30fbdd3a1ecc8f1a63d5c0308f5d99bdac87d055b7cf4ba76ce3da0fc49627338d601a6a708c3847fc1b9222fb89ed730520351a5d738703fe9f6a813331d0577e19b8ab877e6cb961882bf19842171dd7d6714b59c1bcdf0f654bbc85c47b71d68aadd4e6cc44a4c1f0530d9c1fde11bbc749f31282bb4e50714274502f83c385314db43a1ac63700adcc0ebe10a9a90cab0f09e429f61ea222f0f5a1a618abd2aea1b6fab53dea3845237577232dabde55a7f310f9fb9e8b7c677b173060ed926ed9788dcbbc01ff3713a4471f7061a67bce8e232b0772c57f514c6b8a9b65af15938f0a2c1c150de1892329019d9147ea35301bdce25c74651ce6e11ac2c235eacbbaf0bfea39edc3c3b84fd649fd0aa7fc80293bc3df2c31def28166ec78c9bd5d7c6dafc9aa86d1d021c649df89e3368cea25fa7b9ab3a451c150849f936103aa3177de29a65906c747a07eed7e94e450d638c9c4be9fa7b3c4a94a1d19fd5bd82930a7dd26f38dd304d6dbb8d7c20d70e55f3647df334d6a83b569c20ca77f60c79a647b3152cbf62646fca146b02a14ed1a410c82bf8c0a76be3fb29c2d20ebba2c9b792b0a18396d5b1ee0184050b36410e424de7e9d99bbf2febf3a859496b0e8da07c401615f6583f92f3a4510e6835b2b737f6e5cf3a91ac6cc2f4a1cbdc87a81461a4148d580aef435b1b44bbdc035a1357865b6df6e0790e45d0ddb68facd3403aeb395f3ecf69a7b7d0fb51e54f957f33ac33652b77e5ab806892d87f09f6e0baac59d082b191717ff240f9fce6e825821b3a464215abe4a29ae7e9b2893eb3b834667c6b6ed26ec6d6e69c2532c6a840172840b64054ec7572f2e284eab0fbf65b00c2a6303ccb42a373be2effe754efe6fbb5b6476689abc4bfe1b487a8c03bee397e404a2671d4f0a1d54f31db063e51f034639487f7a63091d415c23a55642adce222abff7c183291a509089d61fc5a9d33c4c13fbc247ccc585c4e14936be972f97db782978a94e37318628683d35c4164d6278ebd507340e91c4a6517b6e37f0cdd2634794fe385960edaa6daf1fe560ee7773d9f685b922fc0e2dd96616975291d86c201073feb3d2d865d58a60bc44fa459dbd8027316a180f2583c7c6ebf37ac355866f8903ee55ece53d94dfe0445fdea6434cb7897df05aa1e8537f257d5ce9a3e8846a7d06bd5fb0c55729ca3fcd7a4605740397af5d3e188899b55fd90d4aa32daeda804e831861dca5a815c674e089c5af0786e50773dc40645554e7f8ab0ffb740934c2db796fdb178684eb61fedfe123138dcf75c50aacae8cbfb9e7a3f2bab382057ba34b3957544877420b1439258a6dd25fb059c28c28291ffa3bfba362a53b0ab3ecd9b2d884a31137141e5ef90c44eaa209b733d4eea99c69ffd33afdaa29b45c87ae8f1d02ba321f2699b02e84c2c9989a4a7e84056bddd27266776f997d677acda0a28c4236d508b78fd26ae9ba4d12174f9b811871811cf6652dd5f172c684971dcd0d96a80ec33dfdcff4b10394e28a4bd4c9b0fca48327721878b5d87b1d29e766b211fbb8f0cde79cda14e4bdcdc2b2fb3bf3c16142c9c1a922b1c8b8471e9f3ca99bc35df915a4bcb12ca65cdf59432d8288d86cbcd046662b57132b55cdc48a215eaf608589eaea089481c8a3d70731100f12ecbc4dd7a0d2ea4442e0f9be6ca57aa9273df816047ffbeb5c9ec154443866acc43f870caf434b32e9f3aa3f616b825cf11345b7cf725025ff19dd6e5c9814b39be7396e8ff54c85b098a62ce92d2c96dd6dd49f84de8e6a720db4e7e18b50abd56f0b55eb79d8227d30850ab77fc5de7a9e261bcb69976994b161f4c83104838b11bfd0c9fb155ccc2ab23851a4dec2e9161d6fc851dd037db5cc67f45f195c8c45ac641db8c23e30752ccdc3ed777ff214236b2fb30f856cb30f32fef5f305fc00dec7566e1481fa54b3d8536fa574c04d40643c0f73f8d8dfe738d0e8eced0dc351ce0a20fa401d0cf8f36666fdb840c54dded91a38535b9c065c545f8023bc54d29450f89aacf190d36bad3037596e738a9cc8b07830741f85e5fb1f57187e2883dfaf9329458c82b5e646c910684d9428037db41342248a888748eda3da875692a911e58272dc5e605be813db11f2d606a0028683a87ca68e6eb93b6a3f70a09a3f7d431adf8053f2f215e88e458b3ec0584695749f124349a08b619d8ac214fedbca7bb5e458553c7404eafa7eecb6d563c225e3c9d4677f065ef5db0953d063499b5da0afc9ba3188838598be1b0641c3959e42f7f81a029da43fa5910d4b39528c3d799d90e85156695e3e5e31e7c13d2d0ee066bd337aa727f3ebc7ccfb1fe4aff055ea8d26e569a6d53e69941ba8a5f330679e0d6f5da6307f36144f5ba6e7ba7be7f71b16f80ed99f62a4bd3e4ca5947930ef0ab855822654f4b047d4d6904ac1844f81e13a8fc539f131310292d80c73000b0bbb4d2db5ee08b93197dc182ab709afcc63ade2461623934b6f95e72d2fd3932f13d90947da679d2c0bf3b33c516a3bb48aa6d0708fd0ea07dc64352cc26bb6ff7d4743a22951ed276f3a9eaddbcfa93186376d427f9b8df5a6d30dc09f8c207e0db6c7dc0ce824ce192c3f0b7e3b20d7d3bd6b4de93b787e2bee2f9bf4de511f598eac9c4d6502d2ba1d6ade5d0136237e385327d0b6bb79d707476f14f0ad7f57d335d82c860c96bafe1707f18bd07cf92bb3fc6656b8f56bab92fb045d8564c39660428ccf29177d775be6337696c80359170e8f284267adc314594fee719d11f090c202ffc8279872f4fc335315ba65a7c0d0dbd868cb8e71484447111a40a62eadb84b1a4f58f0dbc47e2d46a8a378c2520464d3c8ab12e8417b3dad51c87e7790f536305c56948cfdc7da4bb6b671a3de3bee508f18422d7a2a81cff634156b0d0337481849c717dde2fce5e44bdd28b108fd70f82c673f96ec27788b1015eee04bf10c6e9cc32a3dad232014d4d5369132fb3c330cc8d2a8c7f543af863cc6723bc80aa2db19a42ee07c187d56b3234f01d773f62a6fb38d84613f69c6e7d874272f23db40187f9e9d57f53af10e8058dea9cd258b4367d6922ef6dc18fcdbbee1af022fdd784a49eb0ac42838c29933ba50ec78614bef78bbe21511fb5bf20e0eb211b57bd7f9b16abc0f30bec5625f04e06a7a0bad19685b91f2babdea1ae8eb84c8d0a18b8a1e04afc5862db6dbb1c73bc8460798ab71cf28533fafcbcc7984be9d9d5cf0efdd51a2b649ebc4bb9406b4661d66099b66bcd98ec66ecacb3523ecc80e39d3e622533147abda3c47e9021a29f0c4daceb37788ecc646c0116cea0eb6fb960681f91f9683f41374122d83b6821d45</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试注意点</title>
      <link href="/posts/tricks-on-algorithm-written-test/"/>
      <url>/posts/tricks-on-algorithm-written-test/</url>
      
        <content type="html"><![CDATA[<h2 id="输入输出">输入输出</h2><ol type="1"><li><code>cin</code>的结束符是空格, 制表符和回车,读完后结束符仍然在缓冲区. <code>getline</code>的结束符是回车,读完后结束符不在缓冲区.读取一行有空格字符串需要<code>getline</code>.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cin.<span class="built_in">ignore</span>();  <span class="comment">// 忽略\n</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删掉该行所有的回车</span></span><br><span class="line">string input;</span><br><span class="line"><span class="built_in">getline</span>(cin, input);</span><br><span class="line">input.<span class="built_in">erase</span>(<span class="built_in">remove</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), <span class="string">&#x27;\r&#x27;</span>), input.<span class="built_in">end</span>());</span><br><span class="line">input.<span class="built_in">erase</span>(<span class="built_in">remove</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), <span class="string">&#x27;\t&#x27;</span>), input.<span class="built_in">end</span>());</span><br><span class="line">input.<span class="built_in">erase</span>(<span class="built_in">remove</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), <span class="string">&#x27;\n&#x27;</span>), input.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>将空格分隔的字符串读到<code>vector</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function">istringstream <span class="title">ss</span><span class="params">(input)</span></span>;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; tmp) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; tokens;</span><br><span class="line">    string::size_type start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((end = str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, start)) != string::npos) &#123;</span><br><span class="line">        tokens.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(start, end - start));</span><br><span class="line">        start = end + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tokens.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(start));</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逗号分隔</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function">istringstream <span class="title">ss</span><span class="params">(input)</span></span>;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>知道数组大小后，可以直接读到数组中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>删除首尾空格</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>多个数最大/最小</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(&#123;a, b, c, d, e&#125;);</span><br><span class="line">*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="stl总结">STL总结</h2><ol type="1"><li><code>int stoi(const string&amp; str, size_t* idx=0, int base=10)</code>：<code>idx</code>指向第一个非数字字符</li><li><code>isalpha(int ch)</code>: 头文件<code>cctype</code></li><li>对<code>map</code>或<code>unordered_map</code>按值排序</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="keyword">int</span>&gt; record&#123;&#123;<span class="string">&quot;a&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">vector&lt;pair&lt;string, <span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(record.<span class="built_in">begin</span>(), record.<span class="built_in">end</span>());</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; b) &#123;<span class="keyword">return</span> a.second &lt; b.second;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><code>unordered_map</code><ahref="http://www.hawkers.cc/2016/04/unorderedmap-pair-funtor.html">自定义key</a><br /><code>unordered_map&lt;pair&lt;int, int&gt;, int&gt;</code>会报错，需要提供一个hash函数.如果key不存在，访问仍然成功，返回value对象默认构造值</li></ol><p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PairHash</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> pair&lt;T, U&gt; &amp;x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> h1 = hash&lt;T&gt;()(x.first), h2 = hash&lt;U&gt;()(x.second);</span><br><span class="line">        <span class="keyword">return</span> h1 ^ h2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>, PairHash&gt; m;</span><br></pre></td></tr></table></figure></p><pre><code>但是`map`就不需要, map的key类型必须支持`&lt;`运算符</code></pre><ol start="4" type="1"><li><code>sort(v.begin(), v.end(), [](int a, int b) &#123; return a &gt; b; &#125;)</code>或<code>sort(v.rbegin(), v.rend())</code></li><li>vector追加:<code>dest.insert(dest.end(), src.begin(), src.end())</code>.<code>vector&lt;vector&lt;int&gt;&gt;</code>每一维元素个数可以不同</li><li>C++ 17的structured binding:<code>for (auto [k, v] : unordered_map)</code></li><li><code>std::lower_bound</code>和<code>std::upper_bound</code>对于random-accessiterators的时间复杂度是<spanclass="math inline">\(O(lgn)\)</span>，但对于non-random-accessiterators如<code>set::iterator</code>是<spanclass="math inline">\(O(n)\)</span>的。这种情况下应使用<code>set</code>自带的<code>setObj.upper_bound(target)</code>，复杂度<spanclass="math inline">\(O(lgn)\)</span></li><li>反向迭代：<code>for (auto it = nums.rbegin(); it != nums.rend(); ++it)</code></li><li><code>sort</code>记录原始索引：可以先过一遍数组，将数字和索引绑定，然后对<code>pair</code>排序。</li><li><code>string(10, 'x')</code><code>string res; res += string(10, 'x');</code></li></ol><p>常见算法：</p><pre><code>1. 二分答案2. 数组、哈希表、优先队列、栈、双向队列（在头尾都操作的）3. 深搜：建图转化4. 排序5. 贪心: 从大到小/从小到大排序、单位价值排序6. 拓扑排序7. 并查集8. DP：线性、二维、背包9. 双指针：对撞、快慢、滑动窗口10. 模拟11. 数学：猜答案、打表12. 前缀和、差分</code></pre><figure><img src="1.jpg" alt="知识点" /><figcaption aria-hidden="true">知识点</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维原本：preSum[r] - preSum[l - 1]</span></span><br><span class="line"><span class="comment">// [l, r]区间和：preSum[r + 1] - preSum[l]</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preSum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维原本：preSum[x2][y2] - preSum[x2][y1 - 1] - preSum[x1 - 1][y2] + preSum[x1 - 1][y1 - 1]</span></span><br><span class="line"><span class="comment">// [x1, y1] -&gt; [x2, y2]区间和：preSum[x2 + 1][y2 + 1] - preSum[x2 + 1][y1] - preSum[x1][y2 + 1] + preSum[x1][y1]</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">preSum</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        preSum[i][j] = preSum[i - <span class="number">1</span>][j] + preSum[i][j - <span class="number">1</span>] - preSum[i - <span class="number">1</span>][j - <span class="number">1</span>] + nums[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Difference</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        diff = vector&lt;<span class="keyword">int</span>&gt;(nums.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for every num in [i, j] increase delta</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increament</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        diff[i] += delta;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            diff[j + <span class="number">1</span>] -= delta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(diff.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ans[i] = ans[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; diff;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://gregable.com/2007/10/reservoir-sampling.html</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reservoirSampling</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        res[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> random = <span class="built_in">rand</span>() % i;  <span class="comment">// [0, i - 1]</span></span><br><span class="line">        <span class="keyword">if</span> (random &lt; k) &#123;  <span class="comment">// 概率是 k / i</span></span><br><span class="line">            res[random] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Interview </tag>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常碎碎念</title>
      <link href="/posts/daily-chatter/"/>
      <url>/posts/daily-chatter/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a56cf828f2faa750197a3176f28fadef98b36c9f2f2b1a87cd85c4d7ba533549">c172f4ee74b2b6d246b20cbfdc0b877e4764b888105c1ce8666fa174a7a9eafc3c648dc18f6cb14add1c9082504309c4ccc445b7de8fc3253cf89b1765a11a0ea300e402749bd3a553fc21a987f36b89ea42d4b7fac4fd8d42d7bea137ea072ecc6483ff26c092275d4815a592e5ff5b02bfab9f8bf425d1ad055c8048b5c0edb21252dfaddf162682d12b193246a8f50d2b9f1bd4e9cfe60feb20b917d8a6b3df98a67d4264a6101019b3ee5cc964eb377b3e75b480643176774ffa01268c6b0c051095faba50054606fc55f37e000f1ca8e5f05b0bcf29e722e848dfca589404dfe3eea1f973ca90c02625361a08a9f7d720a80be31cf50b7b4644429c0aa2cae08b2c4a520cadc6129f0202f35818e3f9f65087b569c80f99e850f4bf13a403f392e4ce05a71515f59ac00a624d36af4d89790417444ec96dcd15972f819e570aca428a99d754fff12903f5783656544cf10202c9bfa21ae2cd395fd50f475fe1bf16a4984726d43a5c05a60c47b0de80423b64201e4d318f21f22942b502a669c1f4da5a65623e2950e5d5508d00eaa93b2c9ab76c4ca569ec5b863596af1eec73ad0b4bf94064cb748d3b709adac6b32bc92c84fa2996e558db44da82c751307306de305626e837b4c9a9e13503056b97bd044b296b4c2d202f4b23860d58fc661ffd15f9a617768840914bb25858829597550165b9ec227807c5cf9db83f99453c4d61db9577efe51c9cd07a83de8922234d2be85643eeb5861769d8168edec6751b025239110059338d7dd5a4f7d49ee795092b2bd558d1d9fa0ec7d005f321220657aff1c52fd0b59adf1075e7bdbe5e80acd500cd881504bbe2f2ee77343f6422663a9b84f3c3f454aecc4cd0047530f705f7fff3bf5b3ce0fb4ac366cea9bc354480b77bcdae905d4474885eafe458702b0c4ade6b56551de420f05ba514cab768a808b78adea7ec1fafdc599ee3b0bd5ac599a06681c0b18c4b69539218de82a35417fd93f736b1cd0d997dae6959b1057ecaf3eb80bfe022cd0f4a995116c06dbeb7364b3f889b8b5cd9bfab9cd063c66058e1b1d563fb9447228eeb2c02e186c54638b06fc791410afae0497090fdfaa012a706a3d94d66b085a2bcc0e4cc980801edc93ee055683a991f07b45a9718823ff7bc9200c0d01132</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是江湖</title>
      <link href="/posts/what-is-society/"/>
      <url>/posts/what-is-society/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ff5b424bb281151cc7f7308be7f878d2ec973a5ce48b2fa598c5244ba9ae11f5">c172f4ee74b2b6d246b20cbfdc0b877e79904ce4b41922be13efa65d3bd543c45ae5e2998a683b737fda11debe8a3e574a183c3da3e0ae9e4e898cc5bb81e85a300a3765a3bc2e4a076656b805517a1448c4efdce6243b3a9c57b858e2840efadabbb9efc3695216ccbce007af95e921f24e2836d829693dc53168b09c1d2b3b47b125f10f1ea182f22280908cb7bd48d93ae154cc2f0dd72a3136a76ee4b8146b2eea547b87752f7688c1e03d95a9172489e908d6c8e266ac22889e296c7acf7b5d49723ac8a461bd581fcf67eb9263323f18a832e2057c1e68a6b8ae3734e147f9a2056a7ba355690e4332f7c885cab3cbdeddfcdfbd4b018ed37fcf60d8b3d1bb4cf4ef5a44b3ad352b9e74b617493a2683043d4a8dbcbae59bcc1c5dc65f4052a6e2584e18d584cb37d574735a58cb707514c194b64a3674c6b05eedccb3ed530275d146db07e8bc829f9c3cb423ae7dfdcf8bc1b926509a6528f0da9d67d68dc7a7628a9903e07293d862677273c8e51a3709c08f6b27d94b65c9e74fd5627e1f2e00affcab492e8765316c3f19ea161e17aea6b8614dabb8e9f586c7eb831b074af78f965a5566f6a49e0dc60c08504e3a0c923e981e50eeae0488c06f2b401662f420ac366a3f4dfeb926b4069f314274117da67072c472e7068c7ddb616c02d166b3814a5c4b78cf5fccb10c1a0d9ae3e1db669704bbe05dec4e6efedbcd994da6c74682c4d7a20d3bf89fba1f0fc296c3ab880b500aca0de64daa93c04b3ce1d87bca34040e37a1f6c78a78b2453d373f0337a29f557bc3a43d7e8105ae94e21ad5028db66abf79088d24ca6519439c0af3368d8c78acfe66ec8ef35f9fdfafa975e195a9b2a7264dc928c90e9415538bddf74f5439802850fcfa586d84f203435d8c2f865438aa628417651e4f37e12a13baaf6f3e0521ee8f026962cb30c9c68f8af35ddee8af14f4a2371d16c4a6a5f25d80ed9b8f7a67f19d5d55c89971e5bb15cf1560145f7d5da0319d234cdb2ccb131fe5f576f43695d787ec0bc065629f114e6b5912a1341d232b3991a800464c8252f7a5d5fbd5cf862f63cb7e3a94aebb7357959f6465eabc0a4527ad184fb097cf73e065d1b743e714064de8febd0297fb04bbde805104fa07acfe9b73a4e1b3760f4dd7896b927befb6385da4617ca0063b347fceba2f0bb1d714bf82513e92543d96b3beae1c598e79c955142b59411b8758b2dec1c3c34d95aed9f5557a20dcb6224ee76a325b52138885be865ca4b66146c86798094dc28186725c6a928670be98c5bb69549d5430707e2aeb129a4131de8c134bb41d2764fcaa1ed2abc61d6a0ec41e0214593163f19f70e6e710cf360ffcbe391897bc821ea46c466dddfe850e12d0f6d641354cc6bdfac047223cd5e0da5ee0e4efa31b84d33af88ca46f97ad05f7aafba9d8130c692ccb80711a94b2953c19d062c1b197a9c54cfd89204922013c0e8fece1e6ad2bdd78f5f4537d0b433191272164df5cdf45040bac202a0f9c43b6e28739b6e1e65bf9e2ed25dc50fb98c529945584b6855cfc30c744c27c4c616de13fc68ce8a6d35d37d7aca0552715dd38f8899888f95406e21e110bd5604739daf5440875f50c59e448f3a5fad94bfe0dc44d640d912a7f9f38c06fc9c7c923e9822d93be3b8ec1093d5a94d5e6bf6f5d776f169d190a68480ce4247e411ec022e5d14d04ecda477baac119c57fb5105596ec11b988a7d449438a66a0e61fb01e7bc83e7ce81c95201acfba9154c1e4885d49a0afff4c508790e841f64cfa69edaca086c02fdb304cd18b3986f801305819657fbad39a278cfedf2fe55da62d040c4be336ab86454d762dbdb3cbb65cbbe3d55ff76a320725f31ba2b9d1957e0fd1dd208a3dabfa57fb16da14ac6a3efbec3adb3de0c80ee7a3479a17f02a80a0083d694cb1aa0be04d891f9af2b873a1fd75423ef5f9611405276a30d4fa15533ca30a0648fbc44020cd8c2d91e2e12784436811b8e928030d2b7f200a032aa1ddd44a32c3b947579fd6a998fa26a3a98d85a22815a850696e129f2635a26ab0d916376d7378708eeaa307e8cef9cf54298166b7c5340fdbc4bd03a64590e0959dbb5a4778a669adb1698dc41ed4cabc6d585041deed4caa8775a02000764aae8f4a1006b05676d49eac28573da587e3a88fef7b660abcbec5d10b053492370d7b2d183db405c2d606998c90996b80fceca2a32eeb6644783a7c2d5f8691dbbb8cc1eb8c1b75cbb4e61799786c070605e2aecd34c65253c763522a565d94ed98360821583dd2c8c5e456dc9cb385e68d14eb48e75f24992e741a218a386d3ab1e06e1fd66bd46fcab03ddde91f4eac9ced9fbdcc1317f9d10bf80b2c718834bb8cf5d8b929814d5e0c3091ee4530781cf787e9a8e264f1f721778559b5db5e32f88345e1963f426ef68a49dee3ca9f6283e51d967ee487aa123263824a01c74f6409515423a87a77fd8ca325cbfa7fa257d2505f826ee8d71abd21d9f1b93d1c52f64b2fa9122be787ad5141ee4ec3bd205d57c15b4c32f0b8fcc90b1abd7375472be0c37f08c9f304c17bc41a19e3593d4d2503b95ce83158c90bbd9ca125da151a11e888f2910a485af2bbc94637b4206a61944b96e924cb00f0a7ce0373e477d6f62a5e008f8cb058316734a503c8f53d0bad473f5b0007d565453e87c8759c6b9bc7fd28c34806156bbc6fedc8ef5684aba0a8e09cbc184db2e1603935ff0733b1229bbfc4dbf57b0d89bcece2ee714d17ce0ccd0f3f0f2be57bcf0bdf3c5ac80758529bfd8f3d39002f37a1a49f62b01d7b737375266ae46a12d4f9346bfd15fe192650ab57719d561ddc1905344db9ff80df4747d05a3938a1cf49f0a30c37a76480ee641c58fae6d06e453d253d6ea1cd6195b87d974b3cae4819c306065fdf193dfe78ecdc0a5fdc7fb8edb782a30a08b896328dc326fb26857b12167261789267c3dc25409aa6d9311339ee3dcd03264194fdb373ddd89db1024142e8963904dd5fc4d5edce133ff47edefe4f4fc08ecce0746728b3db5617d959590915f57a635510cd677119c2a1afdea72426e7f8932f69de7be5d5a31132845bde0edb23facb34057d7beabe43fc53316e2ae61f9ce8afbec05b11f7939128ad648ba28066f0de4ec5fb43b6576a4fe05c491c899d41c451d76f474740b93079a59210a4729fddbc503427045d004c0e845bf09a406fbffc4e9e94d22a745ad47e6485d35eb71fc83787edb080fb622aca4f8182ca2280716e102df489b2ce7e005e7c9fc88b31160cd8b2c5ff65b23c7fcc7e45abcdab8cb8ed345430db13ccdd95b13957d01b105ef7f7cebba200cadafcd06a643f49e1b12f7230ef9c19376e84a4729105673f404ccd6e9860a2627eb123644b59c54a5d25a232b293cd09bbc9cbac359f36b5dc51fdef434a135b890309e27ed7c9e505e9e30ecf1b38b58c7c88449446634b00323808e7bff676016d4f936f7a2079db3a659e6546763c5c757733c92f431e9cf846468718381923d471fa6bbe94f9726e7e2c40d8a02e49002a52f78563ea1e6ef7350822dbd4a6e6d73ef23058d63f1b1055c41467e598303e21c8e55cdf6e57c3ac839ac0d30dc37828c609f212bc6d42592f1f822bf572f9774c491a450d3e0c79ac65ec5d71930611c199ba9b9cfd70a468daabfe3295bc0a567e54678f83e88567e5d3c3e23b2aa8ec770a6157a4ddd8099a41c9bc416c07d5a61549ccccd148173736a060c07a9cfa9c9bd795edd95d6a1fc53a50ecfb2cfb1d287758a83aac288fc6deb04551915dbf3aa489f49ca175bd54d5cef6b2ec5e60e210b5cd48efb810636f7fc44283ae115206a41cfd4fdf7cd2c6b5a189518ba5c6f499d96abcaa5d3a29e9f5b5cdb47cb19719adbe5f489dcaeea89e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Make Plans</title>
      <link href="/posts/how-to-make-plans/"/>
      <url>/posts/how-to-make-plans/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3956fa765bce5422ae606c8243c2d6319df11ac37e67526265b22526318d582a">418fac4f173397084caccc18ab9f089e0dbe5a3f55ea9f5889ce3b2b354a143dbb8fb8de69281e5be84d3d0bd8f2cd11f9a3f2c716010bb4afa88b47b913f73b1783a60b8488c70bb3b5a1d8fe8e84d2087d284b4a31fbfa1719aef35c8658ffb7e6bb004df7d61293d6718784830be32f273ecd4c35cd6729798e06eae79d60c5a153598d66c12c5330fc4a42928929c823fc6729709455414abb677f69acdd85d6a6117711f018ec32fd50ef569f85b0634d78e5495bf4a199a0b958258d312ab277827ce5004747e8d4395ed8923ff49e4b490bb481703f7aae08e321c0536bdf110f5a1ee897fcb53dccb38299ea54ae1315c6a0c42136f30f3561359a0508b4fb9a416a900509a4f2f70031647196bb42b2153aaa9238748cbcfb88dfcae42f97adcd2ea790546df029f1aad432c037cc558093fd6237624a1956b854e92482c20c1523616abdb19f4f05d2f4f67fdbc9fc32df1e6d63a63b7d0bd41151119478d32bf5067e7a6e12b531de70373409d4fcdab49503d196b1b3dedca727e40e99d26878efdf60b5c19e2e5d3ac34c5c49259df69a5e38e8cdaeff3cb2b66147036ca85c92284a873403575de530e6228df6259b6b66d05b76dd137a04897f8d7d2ae92ec260cd6a29d12ba4a63b868b15db8fff9e60bfd0bf0c0657e0bc293855e2179fec20dd1dcdb6ceae9175d4df483fe9ab14fb7805b39f52aaa0c18dceb13dd85ac2df9ebe86e3c7b09cef3f504bfa93b30fd3b129d60de834992610ab099afc8650ed5623afa6af012ea2b727571eba04b368f275c97b2eedeec4128164920bf878cb566aec4dec528c8958b0a36471f087b01329f509f1c0fac184d0ac9c33304531776ca6b363d944e6ee15681d239056a21a85cb59c77b01de01fe8c5c749e695da0bd12b7e9876a8a19aec1bc39366e0da3a6f5cae425c183deddaa687bfb137f8503f2c21ceb6498c35641c4476f1387b2cf1f24f4893f9c261a58ed0a0aa3fed8a31bc3c6eec3d4a4acb04d00b99c422c273d88a1afb121ac66c7d0131ef436fdf73b2876577472039289e374e9e3aebc31db4b10a1046bc3e3593ded706e9885fcfe9bb1a2ad296ea7f9ec3fa22825a0389aff6b8be0c23c2e4262413c44403b8d647fb446a8d7472ee53e0e46186304ee08e41f3e7d454b5ad289d326bea0e52e8ed691e4d951f6feb909879a8ca956a5117b20474f69cbcf0f815e44fdedf7e870d2136a21bb8535b474da2325812847118eea8d58ba4af133cdb751519a7a7116d9d5f67b52c9afd88b271596f95fd4a2f5f12d10f82002f46bcb95eba037d08e99bd49b40eb18a84082d729c2c12a1f547239a4d710a3301553c701b0c0f473f4edd4a63598f3806674d98ba1f283ddfebf179efdcd8a84c1f3711a52bbd0cfaf28e691c34e182ebb6fb40f653a9086b3619ee2387068f04701ee495b6c2eb55b8280e1dcf5782c909c46b68e1197e8464d18adc9bd358e6ce8dda924570b12e29859848dc4437869217b373a9126ec1fcd660fbc922e97a3ce1a9afc774970cee5fd92f453879fb10c1123455e89106473e90a7e57b6f29d4e26870dbcbf9c8345bd1a3c73e27868ae303ee41b290fb0bc22340f9ccb3c105a762f95c6c38558c0e9591987cb5bf07770ef857050f36c7c1db6ac740741b0238d884bdd692ab262e38a9b373173912b71b94f8fd4649e94667e3c29d6bf1af3b8bacb4cffee97acb9bcfeaeebfa10384964f2f25752a59ab19ab73371db538da5e57019fa1e73a891a93d133be63c06bbc8af9191936d4b67e15976f578b5e4e3bea929bd2df512b2a0a6b6c0b7e1ffffa8e43aac9dba5ed1d1322ca3666134bc4ad35b1dfcfa5d5a81c3426fea9faeef47ea53ecb81b8f91f5fb117c14cd5ee63c4d009ab680893642af983093bafd14473a3d99606b0d3e6de9739cf709490fb340d87ef7fe3e6c3157f6edf83975f32192cb79125daaa1fa503d3c90b9f6fd61ffa21a8f35f48508785c70cbd173921e4e871a1e236a280e9f9413e8c6b02ce1caaf7183a3b81784cc0f0b166e034ba9bb71799acea1deb120dcf5e950a5f620102719ff955f383c40a1487ce23167d2e65a0505dea42b6031c2cfbcd14f6fad3e624b69a99500bc1ff7fec5703fce9d1d43f45554381ffcbf644be110b73f2f86ca9ce592eed267bed33c188741ff23f2dd4801463d4456c415b90697912cad7da1a7f041c0a09238e5a1be5b7b0204e08a1da5f155ee5f84a5c6e7486556132030472a33320ea8f9d435800b8a7c4d974b285dad3aa1eff972816d9aa62504ae440cd62586e9b755ab947fdeab97615077b986d15b97be8abb579b975f3d9175b40d138c687e4fc333b9a5ea48f43c1e1c5e3d7ddf872ed85ea63e92935540abc2fa25ea45e107bae2982ca36949c18ed1d9e45abd84182318a755a7b5fec08dda69156ee7ad9eb3efd87e3a353fae1d1ca0d73d3578371ebb0ddc30c5d1c115a4d0728f865d86b7ffe716ce3dae2551d170359d173085a32058552bc392ce8786c9d79c46a5bd62d30999b0185e6b148f0ae2eddf4932e0ce726851ad0f24f9c9a69c6b99a760261398088817c48dee4e561c006ca4a3eb9b84061aad79eb2b7bb5de769d85bfea7a835fbf0daee2550534e795488a2e04075687027a63e395e66dde1a2a4575ffe38a423c2802304219475c5277bb433c44be92492d337fe5b65dad699f44f79a7c1684a0915d920cb9d16c71bbec00f908b103aa28ddbd6126fe8b0a47ad735ccd4e1e89c387238a27457a4630f84f2689c961cb10d9099cca10ee5f8cab4f7d2a94671365aedfe56897914f935c1f8680ebcc37d8489c0f135db4436bb457add89b9f6116f1897d7ef7bae36d7d0fb3f38abf765025e6e26e57853d191b43091a686798674acb64af5b99e94e09af39c975c318376caa0723c27c64503c9dcb819781c36a986c7890373404d09991d0d36f33801a60812802ed4badac9af064bd2f314d2f44c57650d399fe7ce12a4bf24589918254bb148946e16fcd3effb3f93d81e52fcd3c8b8c53ac19c78e9942fd284c95a3389af70bd514d2712299e34d559f6c8e04e68d1108965d5d587790dc19e7a3dfa0bb1a07872033450efa68172cc29e517ff98eaa30f1c97c5d3cc406a11236f4bd0467d94b50118794a9bf5a1f1f117147939670999b84a4dd5344610f3e177e65db4f7407713b155d3689ce3b80caf328389eb6eb619bc9e7a29bc5e445a5ab89c38eea05f347f97c4ad31bf069274c95f139a80dea2ed6523addb926bdacc36c0b5ebef054d5802d265feea4d395394e34ab10930a9a3a595d0226a617ab0695ec6a277855183cc989df15822715a72e79bad02ff516bc8198afb5e7d3039aa4a9cc220106b050034c619</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inspiring Quotes</title>
      <link href="/posts/inspiring-quotes/"/>
      <url>/posts/inspiring-quotes/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fad2429c4233dd653c54809b38933fa9c42d83ef297b23886706cb126d6a08f4">418fac4f173397084caccc18ab9f089e07699afa44e088ef428d1995e53e30a583d4e9322728c37fd6f4fa7585a29f9a2f639967ddf0a0a70178dd7fba3bb0e046d2ec2216df3e7b0bf12cab8f77d0780ea1097a5dba881f5460559518268755be4a8e5bee8aa261ef802c09592eca63ec9ab85424e86c47022b79f89615fd498d6495c5a11930b83e5c93d842951db3cea0ea29a1fe102ff1bff1475d1ffe9cb0013daaf7e3b67870bd3693a30bb8858a21f6f7144ae18d0a2d3580eade70c1be2af10ab21c8ec9a7df776b0a8389468e3592b39061c3f547936e38ad75b9f93921ba975d2e4bc382eaa88effd4197228437abc779dafd092672e11775706d2838199357c1030a134abc784b565e9f0aa3b6eef48be8ce362c86bb5dc8173161d19a05284ad7de56e34f8dfa73e38e9e75d0a14e5f724a8297ca55a59292e7a7da297ecb3a8f49488154df0efcf0e76ece228383e9ff60c443131ec82876298a115e3541a51419a82880185dc242be8ded72e02f711103c2f2b70fa101f1adc5448791f64874c8a344eb51c94df482ceabbe9758af3f0b4c554395dcf7165ecc7609df3d43203f904bfc85a872e4fdee489fe47496003021064c3e62ff214f8bca6bd06199b5b79cae4ac40f8a8fd3a5fcf0e9e06987610e6cc7a5b2d9311ecfdeb082e79987307ae16b7027a906b31f097aa6ecce6317b52a1ad87d918dc6523dc23fdc7290d8c0e87b6479190653481ec091fd1717a84b347733f2747132dfd46921b460f85c682be5b2e5c21fb0e21615dff9cb430bf4471a06067ecbc0d000f0e001e744dc37cef0c8fb0d24602c1409207205a7a4f99d11448bcac84c7f6e076187caee489f07f85880cfc8693aeea29a1be0adf730792aeee5c9e86e0d3e71bb5f0c67748a1bed87b4fa7b7975e47b2e008284f3767c436c77c9cb51e3363439a71128ef527c7fdd3587074e244bf42aa2243291a648e97d4c16c380b1fe1a69d22d03fdc598de7174a2ac12e4134a306e4248a5cfdc05ef80142a9e2baaceec5cf6b7b70a6b711097bb156914aa4000eca2baa2856842d5a85bf3c1998eb93d0ccdee93c570cf2b2df3e427c65e79dd5957544c3f51641c648d733be71b670081967c02c5db6bd51279835f1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Predecessor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS231n Assignment</title>
      <link href="/posts/cs231n-assignment/"/>
      <url>/posts/cs231n-assignment/</url>
      
        <content type="html"><![CDATA[<p>先吹一波GoogleColab，所有操作都可在云上进行，还能白嫖🐕家的GPU；再吹一下Stanford的骨架代码，真的是干净整洁优美，堪称典范。<br /><a href="https://github.com/EIMadrigal/CS231n">My Code</a></p><h2 id="knn">kNN</h2><p>最幼稚的机器学习算法。</p><ol type="1"><li>计算测试集和训练集的距离<br />训练集<code>X_train</code>的shape为<span class="math inline">\((N,D)\)</span>，<code>y_train</code>的shape为<spanclass="math inline">\((N,)\)</span>，<code>y[i]</code>取值范围<spanclass="math inline">\([0,C-1]\)</span><br />测试集<code>X_test</code>的shape为<span class="math inline">\((M,D)\)</span>，最终的distance matrix的shape为<spanclass="math inline">\((M,N)\)</span><br />声明：不能使用类似于<code>np.linalg.norm()</code>这种东西作弊。<br />首先来看看2重循环：第一重遍历测试集，第二重遍历训练集，当然如果你愿意，还可以用第三重遍历dimension去累加距离；<br />再来看看只遍历测试集的单层循环：对于每个测试样例<code>X[i]</code>，减去<code>X_train</code>，通过广播机制得到一个<spanclass="math inline">\((N,D)\)</span>的差矩阵，做element-wise的平方，按列相加得到<spanclass="math inline">\((N,)\)</span>，表示测试样例<code>X[i]</code>与每个训练样例的距离，作为距离矩阵的第<spanclass="math inline">\(i\)</span>行；<br />最后来看看full-vectorized的版本，数学推导见<ahref="https://zhuanlan.zhihu.com/p/146076139">NumPy之计算两个矩阵的成对平方欧氏距离</a>，吃饱没事干的同学可以自己推推，我数学太差就溜了。<br /></li><li>根据距离矩阵预测测试集的标签<br />对于每个测试样例<code>X[i]</code>，选k个距离最小的训练样例，将其label（从<code>y_train</code>获得）存入<code>cloest_y</code>中，投票决定最终的预测标签。<br />先用<code>idx=np.argsort(dists[i])[:k]</code>取出前k个训练样例的index，再用<code>y_train[idx]</code>得到对应的k个label，最后用<code>np.argmax(np.bincount(cloest_y))</code>得到最终的预测label。</li></ol><p>kNN效果当然比较拉垮了，在CIFAR-10的子集上分类正确率大概在27%左右。比较令我震惊的是三个计算距离函数耗费的时间，2重循环57s，单层循环41s，fully-vectorized只有0.57s，竟然<strong>降低了100倍</strong>，写出高效的代码对于程序性能有着至关重要的影响，反思下自己写出的junkcode，不由得留下了伤心的泪水...</p><p>最后就是用cross-validation确定超参k的取值，就略过了哈。</p><h2 id="linear-multiclass-svm">Linear Multiclass SVM</h2><p>首先要为多分类SVM写一个损失函数，老规矩还是先写一个naive版本<code>svm_loss_naive(W, X, y, reg)</code>：<br />权重矩阵W：<span class="math inline">\((D, C)\)</span><br />minibatch输入X：<span class="math inline">\((N, D)\)</span><br />标签y：<spanclass="math inline">\((N,)\)</span>，<code>y[i]=c</code>表示<code>X[i]</code>的标签是c，<spanclass="math inline">\(0 \leq c&lt;c\)</span><br />返回浮点数<code>loss</code>和解析梯度<code>dw</code><br />Multiclass Support Vector Machine loss是这么定义的：<br /><span class="math display">\[L = \frac{1}{N} \sum_i \sum_{j\neq y_i}\left[ \max(0, f(x_i; W)_j - f(x_i; W)_{y_i} + \Delta) \right] + \lambda\sum_k\sum_l W_{k,l}^2\]</span> 看着有点复杂哦！主要有dataloss和正则项两部分，对于第<spanclass="math inline">\(i\)</span>个训练样本，data loss为：<br /><span class="math display">\[L_i = \sum_{j\neq y_i} \max(0, s_j -s_{y_i} + \Delta),s_j = f(x_i, W)_j\]</span> 什么意思呢？<spanclass="math inline">\(s\)</span>是第<spanclass="math inline">\(i\)</span>个训练样本的得分向量<spanclass="math inline">\((C,)\)</span>，<spanclass="math inline">\(s_{y_i}\)</span>表示正确标签的得分，<spanclass="math inline">\(s_j\)</span>表示其他类的得分。不妨看看什么时候损失为0呢？稍作变形即有：当<spanclass="math inline">\(s_{y_i}-s_j&gt;\Delta\)</span>时，第<spanclass="math inline">\(j\)</span>类损失为0，说人话就是只有当正确类的得分减去其他类的得分大于某个间隔<spanclass="math inline">\(\Delta\)</span>时才不会累积损失，否则就累加损失（必然为正数），这就是大名鼎鼎的<strong>HingeLoss</strong>。</p><p>如果<span class="math inline">\(f\)</span>用的是linear scorefunction，进一步有： <span class="math display">\[L_i = \sum_{j\neq y_i}\max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)\]</span> 其中，<spanclass="math inline">\(w_j\)</span>表示W的第<spanclass="math inline">\(j\)</span>列。<br />至此，naive版本的<code>loss</code>实现就不必废话了。接着来求<code>dW</code>，老规矩，还是先研究单个样本。</p><p>如果你的数学还行，下面的梯度推导可以略过： <spanclass="math display">\[L_i = max(0,w_1^T x_i - w_{y_i}^T x_i +\Delta)+max(0,w_2^T x_i - w_{y_i}^T x_i + \Delta)+...+max(0,w_C^T x_i -w_{y_i}^T x_i + \Delta)\]</span> 共有<spanclass="math inline">\(C-1\)</span>项，因为<spanclass="math inline">\(j=y_i\)</span>那项不算。另，只有在<spanclass="math inline">\(w_j^T x_i - w_{y_i}^T x_i +\Delta&gt;0\)</span>时第<spanclass="math inline">\(j\)</span>项的梯度不为0。</p><ol type="1"><li>对<span class="math inline">\(w_{y_i}\)</span>的梯度<br />每项都有，并且都是0或<spanclass="math inline">\(-x_i\)</span>，因此只要看几项大于0，梯度就是几倍的<spanclass="math inline">\(-x_i\)</span>，正式点就是： <spanclass="math display">\[\nabla_{w_{y_i}} L_i = - \left( \sum_{j\neq y_i}\mathbb{1}(w_j^Tx_i - w_{y_i}^Tx_i + \Delta &gt; 0) \right)x_i\]</span></li><li>对<span class="math inline">\(w_j\)</span>的梯度<br />只有第<span class="math inline">\(j\)</span>项有，0或<spanclass="math inline">\(x_i\)</span>，正式点就是： <spanclass="math display">\[\nabla_{w_j} L_i = \mathbb{1}(w_j^Tx_i -w_{y_i}^Tx_i + \Delta &gt; 0) x_i\]</span></li></ol><p>naive版本的<code>dW[:,j]</code>和<code>dW[:,y[i]]</code>就2重循环按部就班更新即可，别忘了除以<spanclass="math inline">\(N\)</span>和正则项梯度。</p><p>接着来实现<code>svm_loss_vectorized(W, X, y, reg)</code>：</p><ol type="1"><li>loss<br />首先求得整个训练集的得分矩阵<code>scores</code>，shape为<spanclass="math inline">\((N,C)\)</span>，每一行表示一个样例的得分。正确类得分向量<code>correct_class_score</code>可用<code>scores[np.arange(num_train), y]</code>得到，shape为<spanclass="math inline">\((N,)\)</span>，注意这里不能用<code>scores[:, y]</code>，简单试验下：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">y = np.array([<span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(X[np.arange(<span class="number">2</span>), y])  <span class="comment"># [3,4]</span></span><br><span class="line"><span class="built_in">print</span>(X[:, y])  <span class="comment"># [[3,2],[5,4]]</span></span><br></pre></td></tr></table></figure><p>下来到了最关键的<code>margins</code>矩阵，该矩阵和<code>scores</code>矩阵shape相同<spanclass="math inline">\((N,C)\)</span>，第<spanclass="math inline">\(i\)</span>行表示第<spanclass="math inline">\(i\)</span>个训练样本的margin即<spanclass="math inline">\(max(0,s_j - s_{y_i} +\Delta)\)</span>，在每一行第<spanclass="math inline">\(y_i\)</span>个位置上应当设置为0，其余位置按照公式即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margins = np.maximum(<span class="number">0</span>, scores - correct_class_score[:, np.newaxis] + <span class="number">1</span>)</span><br><span class="line">margins[np.arange(num_train), y] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>需要注意：<code>correct_class_score</code>是一个<spanclass="math inline">\((N,)\)</span>的向量，如果直接<code>scores-correct_class_score</code>就会报错，广播机制从最后一个维度开始比对，只有相等或者其中某个为1才行，因此用<code>np.newaxis</code>将<code>correct_class_score</code>的shape变为<spanclass="math inline">\((N,1)\)</span>；还有就是<code>np.max()</code>和<code>np.maximum()</code>的区别，<code>np.max()</code>和<code>np.amax(a, axis=None, ...)</code>等价，返回数组的最大值，<code>np.maximum(x1, x2, out=None, ...)</code>返回element-wise的较大值。</p><ol start="2" type="1"><li>梯度<br />这里也稍微有点tricky，根据naive版本对梯度的讨论：对<spanclass="math inline">\(w_j\)</span>的梯度需要知道margin的正负，对<spanclass="math inline">\(w_{y_i}\)</span>的梯度需要知道<strong>有几项大于0</strong>。怎么借助<code>margins</code>矩阵统计每一行大于0的项数呢？无聊的程序员先将矩阵中大于0的项都设为1，然后按列相加即可：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">margins[margins &gt; <span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">num_to_loss = np.<span class="built_in">sum</span>(margins, axis=<span class="number">1</span>)  <span class="comment"># (N,)</span></span><br><span class="line">margins[np.arange(num_train, y)] = -num_to_loss</span><br></pre></td></tr></table></figure><p>对单个样本<spanclass="math inline">\(i\)</span>来说，其对<code>dW</code>的贡献要么是在第<spanclass="math inline">\(j\)</span>列（即第<spanclass="math inline">\(j\)</span>个类）加上<spanclass="math inline">\(x_i\)</span>，要么在第<spanclass="math inline">\(y_i\)</span>列加上<spanclass="math inline">\(-kx_i\)</span>，<spanclass="math inline">\(k\)</span>为<code>margins[i]</code>中大于0的元素个数，即<code>num_to_loss[i]</code>，整个训练集对<code>dW</code>的更新即是在累加单个样本对<code>dW</code>每一列（每个类）的影响。对第<spanclass="math inline">\(j\)</span>列，其更新即为每个训练样本对该类贡献的线性组合，组合系数取决于该样本的标签以及是否满足指示函数，即为<code>margins</code>的第<spanclass="math inline">\(j\)</span>列，取值范围<spanclass="math inline">\(\{0,1,-k\}\)</span>，0表示该样本对第<spanclass="math inline">\(j\)</span>个类的梯度没有贡献（该样本标签不是<spanclass="math inline">\(j\)</span>且不满足指示函数），1表示贡献了<spanclass="math inline">\(x_i\)</span>（该样本标签不是<spanclass="math inline">\(j\)</span>且满足指示函数），<spanclass="math inline">\(-k\)</span>表示贡献了<spanclass="math inline">\(-kx_i\)</span>（该样本的标签就是<spanclass="math inline">\(j\)</span>），因此：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dW = np.dot(X.T, margins) / num_train + <span class="number">2</span> * reg * W</span><br></pre></td></tr></table></figure><p>可以从矩阵维度相容的角度验证。</p><h2 id="softmax">Softmax</h2><p>先用循环实现一个<code>softmax_loss_naive(W, X, y, reg)</code>，输入的shape和SVM相同。<br />softmax分类器不再将<spanclass="math inline">\(f(x_i;W)\)</span>看做每个类的得分，而是希望输出normalizedclassprobabilities，最终选一个概率最大的类作为预测，<strong>softmax函数</strong>就能将<spanclass="math inline">\(f(x_i;W)\)</span>映射到<spanclass="math inline">\([0,1]\)</span>且满足概率的性质： <spanclass="math display">\[P(y_i \mid x_i; W) = \frac{e^{f_{y_i}}}{\sum_je^{f_j} }\]</span> 从预测函数可以看到：softmax是把<spanclass="math inline">\(f(x_i;W)\)</span>看作unnormalized logprobabilities，因此对<spanclass="math inline">\(f(x_i;W)\)</span>先指数再归一化得到每个类的概率。</p><p>再来看softmax的损失函数： <span class="math display">\[L_i =-\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right) \hspace{0.1in}\text{or equivalently} \hspace{0.1in} L_i = -f_{y_i} + \log\sum_je^{f_j}\]</span> 从直觉上说：属于正确类<spanclass="math inline">\(y_i\)</span>的概率（括号里的分式）越高，损失应该越小，这就是大名鼎鼎的<strong>cross-entropyloss</strong>，衡量了真实分布<spanclass="math inline">\(p\)</span>和预测分布<spanclass="math inline">\(q\)</span>之间的差距： <spanclass="math display">\[H(p,q) = - \sum_x p(x) \log q(x)= H(p) +D_{KL}(p||q)\]</span> 具体到softmax： <spanclass="math display">\[q=\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} },p = [0,\ldots 1, \ldots, 0]\]</span> 其中，<spanclass="math inline">\(p\)</span>在第<spanclass="math inline">\(y_i\)</span>个位置上为1。<br />由于<span class="math inline">\(H(p)=0\)</span>，因此其实是在最小化<spanclass="math inline">\(p\)</span>和<spanclass="math inline">\(q\)</span>的KL散度，即希望预测结果<spanclass="math inline">\(q\)</span>尽量向<spanclass="math inline">\(p\)</span>靠近。</p><p>从概率的角度出发看损失函数，我们是在最小化正确类<spanclass="math inline">\(y_i\)</span>的负对数似然，本质上就是在做一个极大似然估计。</p><p>看完理论，还要考虑一些现实问题。比如数值稳定性，由于指数的原因可能会导致overflow或者underflow，因此做一个简单的等价变换：<span class="math display">\[\frac{e^{f_{y_i}}}{\sum_j e^{f_j}}= \frac{Ce^{f_{y_i}}}{C\sum_j e^{f_j}}= \frac{e^{f_{y_i} + \log C}}{\sum_j e^{f_j + \log C}}\]</span>一般选<span class="math inline">\(\log C = -\max_jf_j\)</span>，这个变换不会改变预测函数或者损失函数，只是将得分做了平移。</p><p>至此，naive版本的loss就基本有了，接着看看梯度咋求。先稍稍展开康康：<span class="math display">\[L_i=-f_{y_i} + \log\sum_je^{f_j}=-w_{y_i}^Tx_i+log\sum_je^{w_j^Tx_i}\]</span> 其中，<spanclass="math inline">\(w_j\)</span>表示W的第<spanclass="math inline">\(j\)</span>列。<br />然后使用我们的小学数学知识去求偏导： <spanclass="math display">\[\nabla_{w_{y_i}} L_i =(\frac{e^{f_{y_i}}}{ \sum_je^{f_j}}-1)x_i \\\nabla_{w_j} L_i = \frac{e^{f_{j}}}{ \sum_j e^{f_j}}x_i\]</span>记<code>p = np.exp(scores) / np.sum(np.exp(scores))</code>，shape为<spanclass="math inline">\((C,)\)</span>，表示样本<spanclass="math inline">\(i\)</span>属于每个类的概率。<br />所以<code>dW</code>的第<code>y[i]</code>列更新即为<code>(p[y[i]] - 1) * X[i]</code>，其他列更新为<code>p[j] * X[i]</code>。</p><p>接着看下vectorized版本，<code>scores</code>的shape变为了<spanclass="math inline">\((N,C)\)</span>，首先处理数值稳定性问题，每一行都减去该行的最大值（注意<code>keepdim=True</code>）；接着求出概率矩阵<code>p</code>，shape与<code>scores</code>相同，那么loss为：<br /><code>loss = np.sum(-np.log(p[np.arange(X.shape[0]), y])) / X.shape[0]</code><br />与SVM类似，<code>dW</code>的每一列（每个类）是由每个训练样本影响的线性组合决定的，组合系数取决于该训练样例的标签，比如对于<code>dW</code>的第<spanclass="math inline">\(j\)</span>个类来说，如果某个样例的标签恰好是<spanclass="math inline">\(j\)</span>，那么其对梯度的贡献就是<code>p[j]-1</code>，否则系数就是<code>p[j]</code>。因此只要将概率矩阵<code>p</code>中所有正确标签的值减1即得到系数矩阵，进而得到<code>dW</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p[np.arange(X.shape[<span class="number">0</span>]), y] = p[np.arange(X.shape[<span class="number">0</span>]), y] - <span class="number">1</span></span><br><span class="line">dW = np.dot(X.T, p)</span><br></pre></td></tr></table></figure><p>同样可以用维度相容去check。</p><h2 id="neural-network">Neural Network</h2><p>这是一个两层的全连接神经网络，架构如下：<br />输入<spanclass="math inline">\((N,D)\)</span>-&gt;全连接层1-&gt;ReLU-&gt;全连接层2（输出每个类的得分）-&gt;softmax<br />参数们的shape为：<spanclass="math inline">\(X(N,D),W1(D,H),b1(H,),W2(H,C),b2(C,)\)</span></p><p>第一步Forward Pass，根据输入X和权值W计算<spanclass="math inline">\(scores(N,C)\)</span>，然后计算softmax loss；<br />第二步Backward Pass，需要计算loss对于参数们的梯度，根据网络结构： <spanclass="math display">\[h=XW1+b1\\o=ReLU(h)\\s=oW2+b2\\L=\sum_i(-s_{y_i}+log\sum_j e^{s_j})\]</span> 根据链式法则+维度相容：<span class="math display">\[\nabla_{w_2} L =o^T \nabla_{s} L\\\nabla_{b_2} L =(\nabla_{s} L)^T(\nabla_{b_2} s)=(C,N)(N,1)=(C,N)(all\1\ col)\\\nabla_{w_1} L =X^T \nabla_{s} L\nabla_{h} s\\\nabla_{b_1} L =\nabla_{h} s (\nabla_{s} L)^T\nabla_{b_1}h=(H,C)(C,N)(N,1)=(H,C)(C,N)(all\ 1\ col)\]</span>可以看出：关键在于求出<span class="math inline">\(\nabla_{s}L\)</span>，在对softmax的讨论中可知，对于第<spanclass="math inline">\(y_i\)</span>列导数为<code>p[y[i]]-1</code>，对其他列为<code>p[j]</code>，因此该偏导为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d2 = p</span><br><span class="line">d2[np.arange(X.shape[<span class="number">0</span>]), y] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>另外对于<span class="math inline">\(W_1,b_1\)</span>，还需要<spanclass="math inline">\(\nabla_{h} s\)</span>：这玩意在<spanclass="math inline">\(h&gt;0\)</span>就是<spanclass="math inline">\(W_2^T\)</span>，否则就是0。因此<spanclass="math inline">\(\nabla_{s} L\nabla_{h} s\)</span>可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1 = d2.dot(W2.T) * (h &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="image-features">Image Features</h2><p>之前的样例都是直接用rawpixel，加上都是线性模型，效果拉跨太正常了。这里用的人工feature包括HOG(Histogramof Oriented Gradients)和colorhistogram，HOG捕捉texture（纹理变化？）信息，colorhistogram捕捉颜色信息，两者互相辅助。</p><h2 id="fully-connected-neural-network">Fully-connected NeuralNetwork</h2><p>我好菜啊！！很早就写完代码了，gradientcheck也过了，但是需要过拟合50张图片的时候一直不太对，调了几下学习率，我看trainacc只有0.14左右，loss曲线波动也很大： <imgsrc="https://img2020.cnblogs.com/blog/1260581/202109/1260581-20210912161403754-1113281186.png"alt="image" /> 因为最后要100%的trainacc嘛，我看差的挺远的，就开始怀疑是网络哪里写错了，就没管超参数，检查代码检查了好几天tmd，深度学习debug还真是无从下手...后来跑去看了下别人的东西，发现原因竟然是不会调参(T^T)。</p><p>仔细看下，这里还是很明显的，20个epoch训练损失才下降了一点点，说明学习率太小了。<imgsrc="https://img2020.cnblogs.com/blog/1260581/202109/1260581-20210912162656860-43278840.png"alt="image" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同辈压力</title>
      <link href="/posts/peer-pressure/"/>
      <url>/posts/peer-pressure/</url>
      
        <content type="html"><![CDATA[<p>见过更广的天空，才能愈发意识到自身的渺小，并保持谦逊的态度。</p><p>中国或者世界上不论做任何事情，牛逼的人都太多太多了，不论是天赋型亦或是刻苦型，因此不可能超过大部分人，只要自己学到新东西，过得幸福充实就可以了，归宿也没必要苛求，尽力够到或者接近自己的天花板也就无憾了！</p><p>很多同龄人的经历会让你惊掉下巴。向更优秀的人学习！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库 &amp; 分布式 FAQ</title>
      <link href="/posts/db-and-distributed-faq/"/>
      <url>/posts/db-and-distributed-faq/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库">数据库</h1><p>事务：一组逻辑操作的集合，满足ACID特性。事务要么全部成功，要么全部失败。</p><p>https://zhuanlan.zhihu.com/p/65281198 原子性：undolog记录事务修改前的数据信息，用来回滚 持久性：redolog记录已经成功提交的事务操作信息，用来恢复数据隔离性：依靠读写锁和MVCC（多版本并发控制）实现。读写锁包括共享锁和排他锁，MVCC通过为数据添加时间戳实现。</p><p>数据库权限：GRANT REVOKE DENY</p><p>索引最左匹配原则 https://juejin.cn/post/6844903966690508814</p><p>关系型与非关系型 https://www.cnblogs.com/progor/p/8729798.html</p><p>连接器 分析器 优化器 执行器</p><p>数据库八股 https://zhuanlan.zhihu.com/p/403656116</p><h2 id="分布式">分布式</h2><p>云存储 https://www.zhihu.com/question/25834847/answer/348271275云计算 云网络 云操作系统</p><h2 id="寻找两个正序数组的中位数">4 寻找两个正序数组的中位数</h2><p>最直观的做法就是合并2个有序数组，根据奇偶返回中位数，时间空间复杂度均为<spanclass="math inline">\(O(m+n)\)</span>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        sortedArray = [<span class="number">0</span>] * (m + n)</span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">                sortedArray[k] = nums1[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sortedArray[k] = nums2[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m:</span><br><span class="line">            sortedArray[k] = nums1[i]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; n:</span><br><span class="line">            sortedArray[k] = nums2[j]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (m + n) % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> sortedArray[(m + n) // <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (sortedArray[(m + n) // <span class="number">2</span> - <span class="number">1</span>] + sortedArray[(m + n) // <span class="number">2</span>]) / <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>空间的改进可以避免开辟新数组而采用2个指针，时间<spanclass="math inline">\(O(m+n)\)</span>，空间<spanclass="math inline">\(O(1)\)</span>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        i = j = cnt = <span class="number">0</span></span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cnt &lt;= (m + n) // <span class="number">2</span>:</span><br><span class="line">            left = right</span><br><span class="line">            <span class="keyword">if</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">                <span class="keyword">if</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">                    right = nums1[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = nums2[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == m:</span><br><span class="line">                right = nums2[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = nums1[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (m + n) % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>要做到log级别的复杂度，需要使用<ahref="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">二分法</a>。</p><h2 id="正则表达式匹配">10 正则表达式匹配</h2><p>判断字符串<code>s</code>是否匹配正则表达式<code>p</code>，<code>p</code>仅包含<code>.</code>和<code>*</code>。<code>.</code>匹配任意单个字符，<code>*</code>匹配0或多个前一个字符。题目保证不会出现连续的<code>*</code>。</p><p>可以发现此题的难点在于<code>*</code>，<code>a*</code>可以表示<code>"", a, aa, aaa</code>，<code>.*</code>可以表示<code>"", ., .., ...</code>。第一次看到这个题不一定能想到DP，甚至暴力做法也不知道从哪入手。我认为核心在于先不要考虑<code>*</code>到底需要匹配几次，而是考虑<code>*</code>到底是否需要匹配，即匹配0次/匹配1次的问题，多次匹配不过是将匹配1次重复而已。</p><p>例如<code>s=aa,p=a*</code>，从匹配0次/匹配1次的角度出发，暴搜的过程可以表示为一棵二叉树，左孩子表示匹配1次，右孩子表示匹配0次，开始时指针位置<code>(0,0)</code>，此时我们发现<code>s[i] == p[j] &amp;&amp; p[j + 1] == *</code>，意味着可以选择匹配0次或1次a：如果0次，意味着放弃目前遇到的这个<code>*</code>，那么只能<code>i不变, j = j + 2</code>，j越界匹配结束返回False；如果1次，意味着<code>s[i]</code>匹配成功，那么可以继续使用目前的这个<code>*</code>匹配<code>s[i + 1], j不变</code>。直到将<code>s</code>的所有字符匹配完毕，时间复杂度<spanclass="math inline">\(O(2^n)\)</span>。</p><p>另外一个例子<code>s=aab,p=c*a*b</code>，从<code>(i,j)</code>开始，先来看看可能使得匹配成功的情形：</p><ul><li><p><code>p[j + 1] == *</code>：无论当前字符是否匹配都要继续，因为<code>*</code>可以匹配0次，保留了成功的可能。此时可以选择匹配0次/匹配1次，如果选择匹配0次，意味着抛弃目前的<code>*</code>转移到<code>(i,j+2)</code>；如果选择匹配1次，意味着当前字符必须匹配且转移到<code>(i+1,j)</code>。</p></li><li><p>如果<code>p[j + 1] != *</code>，那么当前字符必须匹配即<code>s[i] == p[j] || p[j] == .</code>，否则无法继续进行返回False。如果当前匹配，那么继续判断<code>(i+1,j+1)</code>。</p></li></ul><p>如果上述2种成功的条件均不满足，那么只能返回False。</p><p>终止条件则是：</p><ul><li><code>i &gt;= len(s) &amp;&amp; j &gt;= len(p)</code>意味着字符串的所有字符匹配整个模式，返回True</li><li><code>i is ok &amp;&amp; j &gt;= len(p)</code>意味着<code>s</code>中仍然存在未被匹配的字符但模式已经耗尽，返回False</li><li><code>i &gt;= len(s) &amp;&amp; j is ok</code>意味着<code>s</code>中所有字符均匹配完毕但是模式仍未耗尽，此时不能判断成功与否，需要继续递归。</li></ul><p>即递归函数<code>dfs(i,j)</code>返回<code>s[i:]</code>与<code>p[j:]</code>是否完全匹配，暴力做法存在着很多重复计算，因此用哈希表存储已经求得的结果提高效率。</p><p><a href="https://www.youtube.com/watch?v=HAA8mgxlov8">Top-DownMemoization - Leetcode 10</a>讲得比较透彻。</p><h2 id="同时运行n台电脑的最长时间">2141 同时运行N台电脑的最长时间</h2><p>有n台电脑和一个电池数组<code>batteries</code>，第i个电池可以让一台电脑运行<code>batteries[i]</code>分钟，求n台电脑同时运行多久。</p><p>我第一次看到的时候就想到了优先队列，时间最久即每次选n个最大的电池<code>a=[]</code>，然后可以支撑<code>min(a)</code>分钟，直到<code>batteries</code>中正数个数小于n停止。</p><p>但发现连样例都过不了，比如<code>n=2,batteries=[3,3,3]</code>，第一次选2个最大的支撑3min，<code>batteries=[0,0,3]</code>，无法同时继续，但答案是错的。贪心策略不太对，每次选最大的n个是对的，但是不一定要支撑<code>min(a)</code>分钟。</p><p>最后发现二分答案是反着思考的：虽然求的是最长时间，先假设n台电脑可以同时运行t分钟，一台电池最多能供电t分钟，所有电池的可供电时间总和为S= min(sum(batteries),t*len(batteries))，检查这些时间是否能给n台电脑供电S / t &gt;= n</p><p><ahref="https://leetcode-cn.com/problems/maximum-running-time-of-n-computers/solution/er-fen-da-an-de-checkhan-shu-de-si-kao-f-g8no/">这张图很形象</a>对于当前枚举的时间P，共有k台电脑。需要看电池能否填满该矩阵，同一行不能有相同颜色。</p><p>对于大于等于P的电池，只能利用P，让其一直供应一台电脑即可，即填充一列，剩余电量只能丢弃，因为该电池不能同时供应2台电脑。对于小于P的，让其供应一台电脑直到电量耗尽，注意这些小于P的电池不可能出现同时供应2台电脑的情况，对于小于P的电池，首先拿一个填充一列，当然填不满，接着拿第二个继续填充，如果该列满了就填下一列，以此类推，由于小于P的电池最多填充P-1行，因此不会出现相同颜色。（最极端的情况就是：某种颜色的电量为1，只能填1行，第二种颜色最多P-1行，因此下一列不会重复，如果第二种颜色可以填P行，那么下一列才会重复）。</p><p>假设共m个电池, 大于等于P的有a个, 小于P的有m-a个.由于大于等于P的只需要撑a台电脑,因此问题转变为小于P的m-a个电池能否撑n-a台, 即sum(m-a) &gt;= (n-a) * P.稍微转化下: sum(m-a) + a * P &gt;= n * P.</p><p>因此判断P是否合法只需要求所有电池里：如果电量大于等于P，sum +=P，否则将剩余所有的电量小于P的电量全部加到sum起来，判断sum是否大于等于P* K。</p><p>二分法一般的题目就是求最大的最小或最小的最大，假设要求的是ans，那么从ans=0开始判断是否满足要求，然后判断ans=1,2,...直到上界。例如本题就是求最小里面的最大，比如0,1,2,...都满足要求，需要在其中挑一个最大的。</p><h2 id="section">767</h2><p>给定字符串，重排其中的字符使得任意两个相邻位置的字母不同。样例：s="aab"，输出"aba"最开始的想法是贪心+双指针，指针i从前向后遍历，指针j从i+1开始，如果s[i]==s[j]，j不断向后遍历找到第一个与s[i]不同的字母s[k]，将s[k]与s[j]交换。WA在了"baaba"，期待"ababa"，输出""，所以这种贪心策略显然是错的。</p><p>接着就想到需要考虑字符的出现频率，先按频率高低排序再去按照上述贪心，WA在了"aabbcc"，期待"abacbc"，输出""，很显然这种贪心策略本身就是错的。</p><p>接着就想到先安排出现次数最多的，如果当前要安排的与前一个字符相同，就选择出现次数第二多的，这样交替下去，可以写出如下代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reorganizeString(self, s: str) -&gt; str:</span><br><span class="line">        if len(s) == 1:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        from collections import Counter</span><br><span class="line">        dic = Counter(s)</span><br><span class="line"></span><br><span class="line">        ans = &quot;&quot;</span><br><span class="line">        prev = &quot;&quot;</span><br><span class="line">        for i in range(0, len(s)):</span><br><span class="line">            cnts = list(dic.items())</span><br><span class="line">            cnts = sorted(cnts, key=lambda x:x[1], reverse=True)</span><br><span class="line">            if prev == cnts[0][0]:</span><br><span class="line">                if len(cnts) &lt;= 1 or cnts[1][1] == 0:</span><br><span class="line">                    return &quot;&quot;</span><br><span class="line">                ans += cnts[1][0]</span><br><span class="line">                dic[cnts[1][0]] -= 1</span><br><span class="line">                prev = cnts[1][0]</span><br><span class="line">            else:</span><br><span class="line">                ans += cnts[0][0]</span><br><span class="line">                dic[cnts[0][0]] -= 1</span><br><span class="line">                prev = cnts[0][0]</span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></table></figure> 时间复杂度<spanclass="math inline">\(O(n^2lgn)\)</span>，空间<spanclass="math inline">\(O(n)\)</span>。</p><p>因为涉及到出现次数最多的问题，可以考虑maxheap。每次迭代时，从堆里弹出堆顶元素（意味着下次迭代该元素不会考虑）加入res，如果上一次迭代加入res的元素还有剩余，就将其重新加入heap，意味着下次迭代需要考虑该元素。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reorganizeString(self, s: str) -&gt; str:</span><br><span class="line">        ans, cnt = [], Counter(s)  # decent order</span><br><span class="line">        max_heap = [(-value, key) for key, value in cnt.items()]</span><br><span class="line">        heapq.heapify(max_heap)</span><br><span class="line">        prev_ch, prev_cnt = &#x27;&#x27;, 0</span><br><span class="line">        while max_heap:</span><br><span class="line">            cnt, ch = heapq.heappop(max_heap)</span><br><span class="line">            ans.append(ch)</span><br><span class="line">            if prev_cnt &lt; 0:</span><br><span class="line">                heapq.heappush(max_heap, (prev_cnt, prev_ch))</span><br><span class="line">            cnt += 1</span><br><span class="line">            prev_ch, prev_cnt = ch, cnt</span><br><span class="line">        if len(s) != len(ans):</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        return &#x27;&#x27;.join(ans)</span><br></pre></td></tr></table></figure> 时间复杂度<spanclass="math inline">\(O(n)\)</span>，空间<spanclass="math inline">\(O(n)\)</span>。</p><p><ahref="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">题目链接</a></p><h2 id="题意">题意</h2><p>给定一个单链表，删除和为0的连续结点序列，直到最终链表中没有和为0的连续结点序列。样例：head = [1,2,3,-3,-2]，输出[1]</p><h2 id="分析">分析</h2><p>由于链表头结点可能会被删除，因此首先创建dummy结点。一个比较直观的想法就是记录前缀和，依次遍历链表，遇到出现过的前缀和也就意味着出现了和为0的序列，就删除两次相同前缀和中间的序列。因此需要一个hashtable记录前缀和出现的位置，手动走一个简单样例吧：dummy设为<code>(0,head)</code>，hashtable初始包含<code>&#123;0:dummy&#125;</code>，避免[1,-1]这种情况。</p><ol type="1"><li><code>cur=p(1),sum=1,hash=&#123;0:dummy,1:p(1)&#125;</code></li><li><code>cur=p(2),sum=3,hash=&#123;0:dummy,1:p(1),3:p(2)&#125;</code></li><li><code>cur=p(3),sum=6,hash=&#123;0:dummy,1:p(1),3:p(2),6:p(3)&#125;</code></li><li><code>cur=p(-3),sum=3</code>：此时hash返回p(2)，因此就让p(2).next指向cur.next，相当于删除了[3,-3]，<code>hash=&#123;0:dummy,1:p(1),3:p(2),6:p(3)&#125;</code></li><li><code>cur=p(-2),sum=1</code>：此时hash返回p(1)，因此让p(1).next指向cur.next，相当于删除了[2,-2]，<code>hash=&#123;0:dummy,1:p(1),3:p(2),6:p(3)&#125;</code></li></ol><p>大概可以写出这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        cur = head</span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        hashtable = &#123;<span class="number">0</span>:dummy&#125;</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            prefix_sum += cur.val</span><br><span class="line">            p = hashtable.get(prefix_sum)</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                p.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashtable[prefix_sum] = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>交上去WA了，问题出在哪呢？走一遍出错的样例：输入[1,3,2,-3,-2,5,5,-5,1]，期待[1,5,1]，输出[1,5,5,-5,1]</p><ol type="1"><li><code>cur=p(1),sum=1,hash=&#123;0:dummy,1:p(1)&#125;</code></li><li><code>cur=p(3),sum=4,hash=&#123;0:dummy,1:p(1),4:p(3)&#125;</code></li><li><code>cur=p(2),sum=6,hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2)&#125;</code></li><li><code>cur=p(-3),sum=3,hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2),3:p(-3)&#125;</code></li><li><code>cur=p(-2),sum=1</code>：此时hash返回p(1)，让p(1).next指向p(-2).next，链表变为了[1,5,5,-5,1]，<code>hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2),3:p(-3)&#125;</code></li><li><code>cur=p(5),sum=6</code>：此时hash返回p(2)，但此时p(2)已经删除，因此让p(2).next指向p(5).next肯定是错的。</li></ol><p>至此应该可以看出问题了：在删除改变链表指针的同时，hashtable并没有做相应的同步删掉对应的元素，所以每当出现重复前缀和时只要删掉hashtable中两次前缀和之间的项即可，可以借助<code>OrderedDict()</code>实现，按照插入顺序即链表顺序有序：</p><ol type="1"><li><code>cur=p(-3),sum=3,hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2),3:p(-3)&#125;</code></li><li><code>cur=p(-2),sum=1</code>：此时hash(1)返回p(1)，删除后为<code>hash=&#123;0:dummy,1:p(1)</code></li><li><code>cur=p(5),sum=6</code>：此时hash返回<code>None</code>，符合预期，继续迭代即可。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        cur = head</span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        hashtable = OrderedDict(&#123;<span class="number">0</span>:dummy&#125;)</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            prefix_sum += cur.val</span><br><span class="line">            prev = hashtable.get(prefix_sum, cur)</span><br><span class="line">            <span class="keyword">while</span> prefix_sum <span class="keyword">in</span> hashtable:</span><br><span class="line">                hashtable.popitem()</span><br><span class="line">            hashtable[prefix_sum] = prev</span><br><span class="line">            prev.<span class="built_in">next</span> = cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>Two-pass：上述做法的hashtable记录的是第一次出现前缀和的位置。现在换一种思路：首先遍历一次链表，hashtable记录<strong>最后一次</strong>出现前缀和的位置，第二次遍历链表设置相应的指针到最后一次前缀和的位置，这样即使第一次前缀和位置被删除，指针也会相应地跳过：</p><ol type="1"><li>第一次遍历后：<code>hash=&#123;0:dummy,1:p(-2),4:p(3),6:p(-5),3:p(-3),11:p(5),7:p(1)&#125;</code></li><li>第二次遍历：<code>dummy.next=hash[0].next,p(1).next=hash[1].next=p(5),p(5).next=hash[6].next=p(1),p(1).next=hash[7].next=null</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        hashtable = &#123;<span class="number">0</span>:dummy&#125;</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            prefix_sum += head.val</span><br><span class="line">            hashtable[prefix_sum] = head</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        head = dummy</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            prefix_sum += head.val</span><br><span class="line">            head.<span class="built_in">next</span> = hashtable[prefix_sum].<span class="built_in">next</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>时间复杂度<span class="math inline">\(O(n)\)</span>，空间复杂度<spanclass="math inline">\(O(n)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Research Proposal</title>
      <link href="/posts/research-proposal/"/>
      <url>/posts/research-proposal/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0129bd90615d060ec6408657f5754bc3995e9347ac5b55287643bafd627786b6">418fac4f173397084caccc18ab9f089e90c7a29408af94da76702e54e165326b535cb6030fef10a1330e7467b6091dc9998fa47ff20a09e0ab508e5b7131efc636f5b1fb1bdcaf7ef4d44522e12b8d34636569fd857ecababf88af944d8fa35d0798c72b8c63ab5cc7a02dff61b0e6c8f6653edf7950dae7a7310bd3965d5fcdf781dc4d38adb5dfcb22693226182fc4920ad820791df82a52b781fd5916bbe0e7b84aa11d02af2b7fce70166ad473f98125304c524972f269b93e385fa0d2bd902582a6ae4fdabe42a9e0142a7916c977b7451a656f30b9c0f0002d9bd32142b73828374f3a70deceade802d8580bba6b9a9c16cffc795f109056050ad6af49be25904585033e2fab044e7b0e8381b979333d90beec521f6c964f1db082c5c19b1df05a3fb7475a84956f30f27e8990ea6243aa6d0491973a35b1771e01ab8e94b03fb34ff871855f7786f2f69249dd0ead29dca81062d76e7ddb18b6a5608ef78316997051359a1ed733a45bda9b1d9cb2e39ac3572e11f4a371a86f07422f1c3b6de698cbe79156ffd931ab1a290b1617aa717a21d76f877ce09e99abb9207079dabb5359916eaa0fe5317f81dacb413dd815eb92596606359665580e3676267ed2f3884284cc6b67afb140be764f1fd1158398640a9542e2769ea4d1bfe1f815c13ba899bb898839c131aa24a197c05e5e0b076d5ba5dc9cd26f8a4d700ae0872279d066c5081de2f7bf0189893065d06bfeb516588b69227f1dec8de2f88f405e1abe5aa2268bcd9a339f4b127b257c3a931ee3a40d11d97b2c39ce3ddc81e92816cc00ddc47d54a7264661ba9887cccb8c592a323dd8eba5564f91b73534be8f614bd6abcd0b8e449a5dabe2bd2cd947e095fbfa938f5a61f19a0826bb5ad8118d740742b29caee7ea0f394e0a2a2887bd24b1b861cdae7de02b061871e91d1d8ad8ca9f51a98468c1554935895fa15c6971dd5bcd66b45b9026afc7d767f57c7afb12187f50734b4ec30284ef067f3f9addc8b87c12711e9823d3f01c4391fbaa20235bef348f0fac2f3e58a5674cd4f665cd5dfd927b0c92c258a29eecf0b59b119b08752996c068cd2d1d1241e74650ade89138e473b8528b916c1477b717e65e15fed74e2d04db44aa77f466f1696029388f5b2ba0decce456362db916684fc19335766699b1a3502b85a61b067e649036594034240f71cd4220bca01e56b9f7943e73f1b2fdd88e064d3f580bc692deb7264a61fede782ae260f4d4d9468e453b53f97f806d592956ac95a1aa730ae0671874a72d08af31953fbd08d0da3b81e1d5b2dc2a2663ba4b2cb959bdbddc8b38ece87422969f86c165841991491f01be93db454b4edf671b1669d3c22a67a6882afb41570dfe35902746dc7067f0f1d90e46609daa0021fb2b5912d4e5bd4e83005939f6bc929e738f21850e2d11d0a3068b42424f0e5ad61739a037c6acf008c1662b08e793da599850caedd246fea394736dd5c80a03981094b3a0fbc92c176592a123c334976d44454308ea2c8cdf5dcb1f6ac3fac668bd7ceea155b80d59ac816f8a1299145bb93e15ce8a4048b14b733efa1d97d1847b77ce20d61ff82eafc131df0ee20ad609d57e913b4f0b919a1b9de2b6d9c9f013a5f98f0b463b0969f5789390f4fe3523581b4b18678d5695feb1c8ebe52d8101599c54a1232fbf6f3068583b3385156f40c4ee62147422f4171bbde6cd3aa082d5533c84e33ebd9deffd1b2fcef932d666c1c8db2bd0048a8e6636f38f0f5bd0fd02a777a4e8cd5cf824d2f46732ebd3c83dd2bd046c366054a58be981913199991690d72a75e59aba9eb7220db3ef6990c1479219182795037808fdbdc3d6d096b84a40e9a4ada334489adbbe5253f6a1024ca31a090eadecb0f8d8ed124465b6337cbdb8537f743cf28b75696406a1d1811d70b7d30b17bc4907b7ee1e7e1e72e9c15cd73383aafd4833de03c666aed1f2828e11b718f974922850fe3462c25dbf28c0ab80c5b4e5e13f0bb230131c8429f6e0770809def38a56489cc67fc15079a61dcfe2a65cddc2ac54461b6ff811736b55afbbfafcc45b722da83162d2a394c58054b4e46fd5afff901b6a2c141b8ce2f98f9db2f9b83a83804e0dc3b858ca75ed581f7b43138494732b920b882d11c3f9a31b89719433d1278c7a9e2e3c5d8ba4e24285de90f0e23507fc76d2d1bc528b2cf3690b6ed5c13f48fae70c0b7f92016051dd877f77f6fc963a7048cd2fdd4c3732f37ccc460181b2598b188781b18a5c8375033aa920c7e1e4c0dd4a0689a309a97a97558da4d63e7cf83d7c6d7ca5b780fdc614c007da6cb1aabeafe2f1c29f8c065652813868863d501f56e14481de827e6117a0de60920829c4ecea6795fd09536737bd5a390122b8a1569b1dcb34642f91bcd3022f2ad26119cc65140cd4df9d92a4a876b04875644013aaff505cf0bc3e8d07bc570814edcf2f990f6858626cc038f05514c9e9fd16278c24ffb5a6754f2021bf10fd3f6ae4be832d79fac8a6a96cffcb6d3938275119246e8af67eb7116aa7c5202b3ebafb3acdd867f3fb010c87e53b097e641264e82b68212822c7614365989634f40ec6cdf9dde6b3a5ea74c57e55a43012213829371be5a7dc03e6f367666832353668972193b8745c7cb7da24efc74c18e1ffe5e0bd39edb78df166b339d714a66dcb9496603a6bde57f4570cdd0da5f41ac69eadcb4c2a02455a167506e02c2550b8166d1c8db811630b41fff43e24443ec2749072e77326e128cb80c1a0ef61a802fc728167a23a105cc42c128cb78cefb8c0b139946af88e238b65e7aedffd78f9d0ce3408dc7cd2586fcd0c5d8a1b7705c3190d09f400203c5fdabdf08bf96d297a2b4c9c683da70f6aa76c7b6e6da6022409bc9d1fb86d0bf1c0ca582609c2494bdc984c8e71ecb470c755b58372d1827cdde3a8d7205d7ae616721da0bceeb7c9d6911f86cc3d9fa801456ff52e745e47708946592ca6060c640ddba0ed13950c60ac8b5a1f9519258102e73848ae4177154cea3178caf02608dea04467e9aced1720b5aa27c62ecffad6f5d7889584b9f505219afe104827ab754a509eb8ccc25f24930bedca2452ece60f8a559f08cc55cb26a214cc6fc24daf8e9ceff6fc1e1b163307964fb1fcc5082d1edc28bb2f39ccf9458caf9fefe0abdc5dfeb06918c6d451e9d4fc4322975a85b70afb4736eacff41c93bc1d12ff93aea30ee516b3478758ae4ea862c72b28f139b3fcde401236241727c2b30e04492f1015f50e5b4dc3509267945c946b5d5ede24b4a1e6cbf8725b88aaa912da80b4223039983cd791b345c3f98271fcaf2ef20804eda29a2182f3243ae7b010dce9db390bb500b5ce206281c2cb177eeb1604661cfd84e8811ccfe82e826b815bea375c3b0223c06d77720b120f2ce2eeeed8a74a219f9999ca7cad358afe170412e63c2224083bac8991f401fcf9897b048ca2148d0abd1a6e6dfca3dc9919eb29b21d3322a4375be6936788903c1bfdf690c768c221ef44d81ecce74f33cae840ad77534c32262365580b1b8ade925b2635b9f3037945d473747a903a38e4c41d15b2be663cf5f0b46754453d08337875fc58b6748ceaf14ad6eb3bf508830f06c2b15b39ade810e4447f2195c394522c0c465698df6d637999f6c563a995fd5372bba1a082eba9980f59015d7e8ff14846b77417453a4ed5c73b9938531ee24e4fee506d9bb15c37a4f5ca44a556791f2cee3deb42110b171aed6daf35805795e8f6ffaefabf6c9cd0f77d940b3b7791386445720813c0e73388ab86e1a6ffadcfad4c47558bcb75c7ead7001112bb6f43a7d62d1911b0c8c5c5c0b62162cfff42408a21e319c1d7bfdd877749e49f71a48bb15c00e58a741b66b733b0fcc0e5d1a049fe2d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于职业发展的考虑</title>
      <link href="/posts/thoughts-on-career/"/>
      <url>/posts/thoughts-on-career/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f92f567317f60b20bc675ddf5770eaad9df075c6889f33f84bd79288fce94f07">c172f4ee74b2b6d246b20cbfdc0b877e094fb3226c4a2a6f1e416805108b3eb298ad75b39a83c462261990cc9082fb9f36caad50fd0202ea2dafd3bed104fd727eb7fa912d74497c08cfa76d488c19527f1098f537e8df69a4a9220adf7a84f2d2337b766904ecf5e05b9d6474dbd23a0aa115c5e72fa8efdfd1ba940b5e036dd236b4ee1568d1a436d4a80ba6891957950bc21fe16df209e38b071f6b41152c5e02222563c2bbc7da1a66f2f18f743885b4400d15e13dbe6c9bc343fa96ec874f1bf8aa75f07103983e4eaa915676cf27e85afc2b3d904c3e62be37f992fa4a020a06b71e9fab53a00881ec7ae348acd3d77b538b6dd95693c9a3aeaac8c4541f374a43ea80bf5242bdb86fda7f3073e2612510c2ec234ef8fca447ef3efbb5acb455fcee723e9b303052e1ca3fcf13ea4ed633846d56b85fb9cd62235c95f4ff978532115aa50039cb2f22444432ccf0d40141ae6d16e9fcdd5b01b9774345dc434fa9be25ca6941a93588ec7dc0dd8f89e9dc916d59f09c454caa1a484ec76e7d5162cf31048e99d8385a52c87bae2efb492dcb948ebd0f9c0781ef3196a13514a11816fe1fcbe42f74de8d53b8c737c44a267c30d382d555e65ae2dc2bcf4859719fff080b7a5a7b2812971443276b5e2a81a2f62a9b60eb7cf2066f406cb74fd1ccdcb8b7ea241b2f80780d8fe2f452c360f0e0d0db03e88a978378cf7066eab1190ebefaf5c570a3bb5d9671a97ea637839fe65cd6e928c9fa044ac2eea6d7f076d15d1090a63178cb104cb46a5f3f92772307144965bccd0264df84bad82d4d076634f87db0a14fb1c96512d8143dee0151a6f16f807bc6d320848e159464d79b1ecc31657a8d11c9149d8d2177721b50415e1ac7e436e82cb4ac88e7a16f9948d5ce0707717e36e6618b7f2105bd7804b435d57eea3edb6213a3e97d8f30ff3475126b01ee438ddcfd4df3dc93bfa594ff743081ac260099b52738e037b4dbcf0970af213e4765894520a12bd7eed32c2ab584d129dcc6b2a6700e2e1d58f320bc0b68d82bfb26602bc36570f8cfa454c5e2c41917f5c81bd662243e5f5de267e739c8eca0d6ca3ef39030ebe52023c86364ae5cdefd8b1f67e671e9d4c20e71f8a9675cefaa0d6b9f78aa403de794c4d7e616f764762e83c69d98d9e1e38eb0ea0d932851c6cb56ac8f91a644a50e67fad735365a413e8ed60247711faaf65ebc92d51efd40a403bebec2edc9972a7e7e9d2268f55a9dbfae681be1affc2432619cdfa06fa6cf60c780c530d18c58f7ff8e79e66cd61135b76d7674f5e5c2aa841ce01630e68f05fd6f33083579eb4791a1e5ac4424b2b59b5186cdde463115eccb7084c1f5d13556b7bc48730ad00ff5579265df519c4d6e579f025008b24cb54c576e713ba8d28373c3682a21ef1493c2934c36971aeee35c7e886f23d045a4f98bc161e9840750cf1d1a516d022be039a066ca6647bd892350504dcfcfdb4cfc93a931d89b158ef6021156759ec483a1bcac4856e534928452b58d56317d08a67481d55fe39d8e3fa9768f24fb0b5d423b63ec91608acee029f4f253e6260c3efd4bee9e00502a5f5801281a513d0ed858364db78bb213c35589ab50897c4f73608ae16cb81fcd7b0ee847a02dbfc978e602fb26dca6fb5136bf131b445ff7cc00e91748692e1b3c450e99353551ebc412983071bde5667115356105252b4f41b382236d6fea840468aed32acccde50782d447339b12cb0784ed64e164ba5857834a0f7b39d0ceda409ecbceae4ff46e74552e115416a597e575314c13c0b5968a9efacdc938722f54ccf921ffcf0f2b7035bc2163bc706da31bfcd72f45621a7f332d0bbd58d6a955eed0ed0758942490ea9f249c30d0edc32870c1877170fd90e76fb53b68f482335dc487d658e2d36c68f8feac18a11fe1cb1ceb01137c264e0aa42815af034bca19ab800870b157b4c0488bceb86bdea906dd73c84c51fb867221252395605e99e86c9ec9c44fcdfefbf0e2b5d9a6ec2f97231cd7617249fbbbe4aac5786b3a022340dfe487e4d58db0d6bc0a074df3deacd28932d6aff1a73ff35cd489bb6e36fc81124bd2127ac6de1b5cbef1f9f5ab459af312c13d86ad598ffa05081010f1d0f4652e46a30ba168a39635a85e3582c8e32a26fca8b0ce2274ce65dd9f8d33368b8aacdba5e83ef8421de8bd98c33489df7bdb8c18f3f3f4ac8271965158b229f3d19e83bd995e19080623f935805f1898a68365be2b8fef7cac320fdb689f7d8fd8021729910a6eb67767e3e358caae66d4ce3596a420cafde45c1be59156988b93a44ac8bd6992f2899d6b416155442cb3031c4521123caadb64c626077c57661c8089bff83ed9a4dbceb35e2015b6c5492f77ca92ed7a79103e838873ee1735e51853b46d445e970719d1da2a93d71b94c2aab730c129a42897ce36b87a6637e06d5ad78b09566505113b3ce8592a674ebeda34702e258451c241bd77dbad4607ff5cfadc4cbddc090538b01c033b9f6ae0895a6109ae40e60cd5c3b4eebc0ad7d968e31cbc53d0513206623f1ee8fffbf2b7dcff98f7c79dc19a5b937a9c908f836707ad2828f0c027b8136abf831e3428a78b5cd079d91d3048fc282d3a3b41fc678ac18834450def27373d4439067161ee63273876cf4cadbc0a289d6a78926a642916522a2b9b16e6fc8252546aff7f19916d1b20b0dfac918841715175abfa30ca55f3e6e4efde9c6075fe1e71a5ec17267312f1aca4c3d24410bff1e85ec89d7b02a464f366271aebe973050a1120e4f605e47fb8eb1c234d51e0c5e904cef1e1ecda1860d4de1c43a4e8772f8d4f29bfd0a3b3c05721675f3ecc4828e1efb51a2bd5d98ae44d2fe41333cd9e261acb19006f15158a6d6a354ebccba51fc7561eb4f3bdd1fd6613eeea8751311348bca24e613ac874ecde24c32e019cf72c8f028b3006c6250f42bd58836f9747610805b9004df707a7bf68450373fb6915a12e57e1e2da6a13c8530f81abeb05887fccd556ff48af125360cdf82e51ff3b72022d71b3af188897ba15eb6e76439142367b55a94a28efc6bc0d47d8f717f7ece47824a5fff47dfd4bf0c2683de6a575867dbda90f9d22eceb97872a8db9ce26c20ad17e3324118cecf99a8be9356e31384dd3a2367dd4d4db4dbef78eb7b6c85bfd1f5f965130d7bced41de6c00f060fca886fd75f7377d36de9be7f6bddff05c7dae00ac91d652fa3f081df2bb1a9a627cc175867401f8fcd5ced9a27a8d222f57ea7737c8f7db274ab95c01f54e5310001f2a6d2b0c0d9d72131086e94e9be13359966b5986a8cd9e4b392ccdde1028dcf71bbb0a8883f8e6fb3e4a6dd65dae121c246d937d9910cc2a0c54faf4c869eef9a47df1178177af4d69543e51bc042b982d2bd03126490a6e3aa615e0ba69f529b2d12efa41b9e22a26f79c63e089e52e953a9a3de4603466fe679d215f830bfbb0fe5bcfa3ab3a7b36c3bbe0f13ebd4c7de55c6f6fb0bb2b53269a5757fecd71cb8ee1ba7c2fe13eb615612581abb2d57d54fbc8089177004bfddf7f59a04feef56512afc33bf602dbdacdebd49d9d9ff3ebc1d70ae1c40629ab8b33b63178178868ca7b19fcfe1acfdb770f543dfd1b1ae3cd95b145d3422db52436fe318d3fd086d1bccf3f0d18f996c3255efe22be1b70fcec44d4192734c12305c134ad10309533fc4c637fd9e9986f1ae236b4ca1bbd3fb4c1713f5eedb3b28534ed5e8cbd1a4e23f41772dec74570606e48b6180979e2f1a17aa826a5f17aaef21fc55c90d5df4cfedb4b374970dc216824518f9e845e0d18a9eac9145e997216810a53dee11353244122fae61a9ec62aeb1361e42d968a7d4915cb32b31c492baf24da8d421e15a6be02a8b8285983baa62461ca628390c8045fc36dbf4bd095eb8120563f6a676e1adeb8363058413c37af2fcb4b26fce33f37b127dc9e8701bb2ca81f943ea02244d3b41a65cd3649edaf5791d9e590abf9395cc38a469d804c0992aba6c8cb26843a536c104f513002898220089df276523f10054b7a9df798028e4f0a4effc7681f8673f2430fe61019b95a72a916b699af9994c49f7a555cc940a746b55d0ed291bdbe317eccbecf98e25e0cfa0329ae9ae6ad819af34efa419b269e7c3a7e1f045506167f7613984de02ba0b3c32cc1fcf2b406339f5970ae327ad72efa8a51fd4b9981f3f29787e0d948845206e6d126a47338d55815c0bdfb4c00a29648fdf8cc25751c8d627c09fd270a5ed10654e97d07d3fb9d5bb0ec29627af619d37f0b30e98cc60c462d84ca50e93b8e1fe6406619c4bb397700da718da269c8abe6b8338cafcab62e13da0d64f4f458cd322f8654fb5e81abd4e13edbb7acae4c1344e3fe49e4ae194e5decfdd387c4cd4f1b88922314652f6d05d78f7d9714b8e1896d680dc38499018c705ae12156d51b3e2db035cc393fedaabbd80790be9992ec255df95c34181711e18c713eee33145dd256d1e91426250bb68d0639794ecfdb8282c664a63e4c8f7f84ed375cb6805901f6a70ebdeb99a29f059ba51b82d1b69597fdf978f362a18f4fb13c97efe37191a5fd017780e3a10dd284981192dc00dabebcdd22c2a76b83a88b1fcdd954c84ec21036cd22ef13824ae47b26b34633be1468b00598b673b3d58d63f15f99e3e911054aa3600f6b9d585524849af5e6510fd93bcac6f72f44903f31f464e5f08b60644a21d0aed350ac9c8a10da8820544ad4740e6fa4f8e17ee20443444b41d9296971161d6c1993ce90b04f5faf31dede295795999700093001dd0d81f8347090bfb643a7f141b6ee3c928b98b6e0da2303975ce00106f08cc15dd0bf1bfde4b8b23e8a2c078fcc4616099318de79c8dda7e2aea648dad953ec9bff1b51460d5739a777a1388e2550d52b2c8a6903f71df555fcbf61492971b81b54fc5af290659f02cd34e6fcb63c4e6793b3529b83fca8f44423ef26adc8cbd129955548c26bd71e21b1fcd295a3882162e2a98b4966777b74c76c91c19818b98ac747f7d166f05b305f247d0ece838c7d3106cd4f4a1f64e887d19489343403f27a4d2ebf0e1584b688d80909d375eb4eb61047ccba78f63c377c7c2596cc2e4afcd94a0c1fedf1de99078e45b48bfd46022efe1a2ce5d79285c790d1cb594610d365a3c37d944af6bbeadefcfe54ba6cc90aeb6d8d50e28883413ad2fa7a7c13f9b40d4c925052092c3fcd0009fce71222dad0b7d9a4004a0b50166780889af2f71cf7073c0dc4bd5ea19c4fa288fd94afe3aa7a2ffdbbbe36b23333ff60b4595e7e75ebdc8a85be2a5017c3687894f3f0636142f16a74d9d177a1716770e8628597775dbfc7ca222d7bd37e8b89aa92d31ebd91573a6c6ded1e8b8247ccbf9987dfe94468195c4af711d0dfe357c514838fe4d19aebb968eca3fdd5118236aa6d7641699cd0d3fbbd5c86b312094b805a2ed9350b32f19e99141d7ac6aa23588ff79c1e7e68fc1769e1e46dc86203b5bd6cd0b7dc2f349967d4f6a4745c7101ca80261387a3c3be187f24c2ccb10b29ed433c14d2e334a7de839a63f1fd8570136f3b5ea9e15a787ec833808aef39ca5157d21bcfc9448d1a754d2bb38b7f592e6c8979a8c5a0adb573fa33d16c93882363584cbbeaf36b29ec2b01f3323a6433d49a4711f7d1f61c85904e38d07bbbbf04dd53c6237b6521e699d5f234f555ffcccf43877c3e100fad6d598dace88305b8327671a5b0ca05f47e35fa9aabceb173c2d1de6139ce3c5a4348c06d814801d154721977ea81aeb0c8f4a2274abc640e7360676735afa4dd4081f3015ba31acfdcd8b19104367a8a9365345f8b714249e321f034dee70fe714695dbe7149d415f3e6ebd1bd8885341f8baf7108188455c9fa8d7ef82fe2a075bf6d2118064a5e5c0d6448c9e02f80c8810554ed5826d6df97ee290137b2de180d5ddbbc534d83c8a4177b9949c8df061ab60456fc692b0aa444bec3662ccb53e01a14f4c55e1a5adce7bd89565fafce7ea3211889dd413e7eb85a6868e8ef5f8dc5d2542bd82a95aa3debdd3ab1b1cd00cb21a22790df09da0eeb852c29f0263b3238ae6377a5551fe9fef69e2709e819bd74569fbd062cbca626c3152136b422f3c35c82d1b244d411c0f8eed8a30f96afb9c35cc5e38d1847076dd02bc5d41722c75a8f74ed0f34038d12c9ff9aa78a213c3d7ed567ba29699c0dea9ed1d494bcf2b01133518c71a307118f87714de97998530d2de638e95f265b94ebaa2515072e216acb69d6c3f2237030b8995dceb3f2450f6798825d2b2dc8d4e857c5e10132c25b7499749dbc37ff87b6dd071b3c4195ccfa0a917a84d07d84578eb0271c6135e7f8bd2acd36fbebef84c5d08a60927ca76bc8ad43406e9ff9173ab8c3198456cffaec4ebd9ec0dc87644bb2b4e66f9cb2680e015fe62969c4de05468fd285c875c81dccf7b1a9af90bfcba97552c7e38537da4ff0f33fac5b79ac97aa39769663846f1f273eaaa62e93b7b3941f4d27c8cab92617500ce4795bed2b27c4a41f8fb02bf6596f80150c82c97e852e2a6b89dbfbc6491b5250b1908ca7e89205d326d296dbd5ad58226cc51193250baf1f63513276f1905c6ed7b49006ce4ac754cbd0014e8c7556462b37d53bdfe34929cc1e9b878a444983f829f0acd95250c02505856f22bb06b012f62818e6894c6f2b9d31626af396f18a2d91c2c1ba21209239e7da435cfd8327e41846a694f48db079f8b00a2540015dd66cd18d5c07a59e0e668f1105b647e7dc7141307970d353912fad9de265d78d6aff653005d7b51c8c7398802607ba9a2c0708cc1d47a764f2e8c7936390504f95f93ea76c220711872fc64dadf2a9ce80f3695ec4ad66621a476ca84b7c0563010fba803de65e72d4696c4991a5cbfb2b095207995dbde44f7b59c3d4458a359b32893275bccd248a1f66043b95a10a1ae31f6e2fc54ca8e819b35c4ea0c1b580364edfea51dcc30d1b6520bd62c096f5c48f756752740b66c3bccc0a0f27c602b7f2913fbcdb5c8e4f53992a2e42f5527e380dde777094fdf43132f3ad9de30eaf6e3c695bad96fbe8da7384fd2f32ee5b7cd9094713963b33ab886a02f057b28030145187e179a51fa16df64a4363dac4d115364731e089fe41cdfc2ddd4fe42d7023a1a739373e48b506d9ae4338a835be8a28d2bd2044138ca3229aeb31521806c9c5430bba0e963d9b0aad4791e9ccdb1bea3dceb5f1f11e42f431433a5db5bd1f6db78cfd2ba291da98056fa4bb3d4118792ca87aeffddb23997406d5fad16b4360baf6d67ec011c49126f76c8610e76a319c9c132a0b5219d86470094b3bf30ebdaef17708431ce90d781d5f7a969d0ce5272bdcb3194cd119ad733d893ce41e2e8607727bddb454324b4caf01184db8d5edde013ae7e7b8977e4a551b06a32fb4eb9a50bc627a0c6bee8a709062930cfc9d7862eb50737f7a742c5980b61bdd4b13c419ad73e3f5051f472b1c949b6a1a0ea14971147c4a139cee35f3a85548e02434f84fbad80de462a63c3feab982884f8fc2c23f19f7ad8ff91e77bc7d4764b302982997becdcb820f71a10346db8ce3ae105ae35b7cbddd381b6c30e4b84705bcc3b69aa0ecbbd802f139d40c9c248ba95d850e33053ea3fe044875f499d309c140472d752f7a1b74babae16a854e067ef04f826655b714da42146a66b01a1891dffafb3951907e7f7a39eaf15909f85c2cb6c12b70804955c59b11fff58ca097042fd4e57f7e7f4bebdc53d7fb5222f2a0cb9b407684fdb2a14dd351a9f508ba07348dd6b7310975d1542b1c4dcee6f3eb6622e73e5445aafc6cc1cd39bda0c9524502e5142c4c35aa46a61717d129a59491f5f4557eee3d6a0d5d2ee33b3e12324e0c014e18bb53cec8737b855a9297e2c2fddca8c8aeb2426bd0d319c5dc24b18a1bc6a4046403968de658c74e6f315f1e7c162f6e47a8e5c771b0c953a24888a7155ec375ca7564b23f53bc7444dc395df73477e8737a198e70662f262e6049e0d4f786fd5e6e228dfa11e54fe7cb315aa50c47dfeb90f3e51466fb7f7f82a966123150ae547b06daed324509f2b4e740fdca628c59178fab66b90c2579105811af4f300ed675f437a42ec671da7fe65e43e5ae7e67d285e801c86a1e768ae5d4b5c0da1c50b3061b18198d341b0d9ad18d7f5ebc4340d393a97d340eb6247c510a292e61e2e92b7bfe93130a1bf025d6650f214434e5ac200c70051f898474e049aa761242bae16ac3e5a7608b31d0718485fcb088fa92a75b3e22de02605fda8518aa5e9c1546d92f35775c393c7a1a2c51419b0dc3a81299ed9cfa9c3c18ae7182ad77a9eca14e1b065ef7533dd4a2d97a62185dad02acc2ea5493a0fb0ec8c06498a9d502f300a9622038858aa36a586f913f533b45c4959e68f87bec20bee1465ffc5844ddf50c6c78cff0fcf07f83ff1ddbf7154885a46603b2d3915e49eb10de69bc0622ea04f8c2bef02506cfbea0423ffe92aa6d51a4548740fd8487d600317c109b02c61d4256a73232694d45f3a78bd25a70c229099e5fc0db994fd00f77e6430a422c60fa3c2dcb3443d9037a5ad2f4a855cd31e62ccbf93682fe7ecaa06283265387a8750a20f7a103bfb0144c433e03ab097f47a616204b56a580eedd4a533e314ea1a903e2bb1577e8db541b219f144cbe74b8b011d84eb5c85f7336708156ba8f4e5c9863efee406f6847b3989a74c2ba173916066d839f2146e581d90d99b1a99af5243496ea60fb66409e9140b1acb10ac03442352aab154dc4bf2bd672dac43970796147d62f06993c44ec8c907adede4c5180d232cfaa74218a52cc7fdc2bd89529ac2ea9bfb00615b09259bc4111bd05331dc4b3a69dc839a07fa11336f6f0d8444dda5daaccde6b17b86b423333c6f92bcb84a4b2c6ced2bed86e416c6de047e44799e0965038cd69b6eae6a42cc80ad6715bfdc8df4edfeaa000a6343c1b4e958b76f4d88d4ccf4a3520d8d81c3af6a6ff50dae2e66f61db39c7c67fea854d955ebcb2884a0716765f3b53c2d106e6acde26b61ce27c10780ba6a62e6e1025dd6652cb0b911e7eec1a92f1031fcc54e4fad6f4f2cab4653a6efa7482fdf43d5eae7574d4fe98a4a7e818158e2b282c045a64220df6ae9ea22166a6221e34fadc1ded8874e5c75d4fd70e7fe34d7dafb3a55092e2d2959fe677aa4050705aaea13f140c6148ad1a2086955ec5e276a4d7f26daeb12f1f06f3642112d1dc63b08d3565f310162622bd22954204eab27a7812572efa6620be26767a02b5574692dad296975df3fcf79f68bb22b9b23a5b7c57283a732e90e79950278d79f64cc17bdb949f6c8f5d00634738bbfac374341bc53790783d84664d14c0fd08972cbc49bae4d8f44b17d8c88ade8753a63a90a4d3c7f19e7d4ce95fdb67041915edfb91af3e4464a75e901c2b57ace9b5323a87630c085ef68cbb3cbccc5190f165b874b3d1c57876f169e248a740742b69e715dec66731dbfe02992f2f6dd5b3a4f9c62ea5546e8dd39f4f0bb7683d248a97732f825a12b8edbffaee54ae89b20516a1df3003ff30751f0f212eb96850b2beb56c0978830ed5e482b45fc9aba9900d3ebfcef60c169a1acbfb2e34cc1922d8e67fe4819a5774dda06574a2cb8e781c47e80955e031515872c3e28f59e721db666da2e3bf0e0e1a644fc8dea95212c9e62bf248a3fa9d66802daaac10e004cd07c28013331f68365607850a6fa58648a8e7c3c32d8dbf221080b5a23e501da36dd794737bd3f01f6388dc469c152fab1e466108cba436f146b22913b4d8f505ec7c818f23fbdad861fbe7163f717b771d38ecce5e059150518d3d8371032f3e48d6bb92deeb0f227e729d040e3dc622025b9f7d9a9d47005a5bdd9d807bad7b6ac6ee3cf4019d2b2150d9ba870ea97d0d6761c9287155057761f5bf35cae9c04f256b6b3d7306253aa7bc73f8e44c4da724e0cb2a4468562290753ef7b733c6929451413784c0505187b0372976f2b22807e806d91f23578271ac3d2366da2fc97cd71920de503db58b7fca7a563fa2a0be2aff4f8ba1b66a79750efa5276f64341369cc1a0aa31eb378b696135d54d9a10c5974bbe11c73985b8a58f46337ee24a02ec654c6e61edbffd3ae5deb0e1e9175f4826aff424415a9e8866cf35e83f072c40ff1c9dca02c05ff461a79658dced1b587d9d941f95f09491f0457c3a45575c03dd2168d64bf6c7871674fcf3e1b6edffa396fd6968c25e4f3d11c2ded3eb77eb403ca8e8ea255aff3ee0126ea543bc0236bd761b2d61b812afc0b6ec12575d360c896f46a883f47782ada4c63498cdcc0f0c8775c48564c431c813db382a942c41a233b82b118bb33d334aa5873f6d0fe278ec3fda3a60bb3644b65710a92be18732dac54f4357444d0151429b5b7409c65c2d343406c0bb2f58d4ab2bc03565cce39ea9ae34f06aaeafe2a2d886c585b357537581f531aae88a4dafc69ac481f612abae480ae79ba28b77493ed9ef9d43a6e536cb5854a06dbd93c554653e39d90115b27b51e2e3bd57fe4a525ea5fa3e144686f6b76606958dc6ac27200ced77a1c9f751f3327b95286946268c4a8d117c22371fc85b1c207cffab8fe02bee0a0e8a5ae103381058dc465389c4fe392d37c6804d07ee8079fc66a2d4cd66692f5e610d4247b5ec6cd6c27cf0c2da364c91110c00530cdf6ece25cbc840b90388bf185f593f9bd7eb2707920dcddad916c99b6b0edd10794e6975ec308af68ab677a7a1906d5d5e3d9831a596702826f596a67d6c26bc0b43fee4faa23dac26a3b9dd6928df0848c7eca9ab16ef124cd67db4cceddc910cf1e8c5c9d512fce1a6d5de1f6689f914b8291bb78c8d9e943f3e8fa17dbd87c4cfbcfd76220e2487f99b8ff19fcf324ddbf8fa9ce7d0690e9b793a9a8fec562112d3073f530ff5b4112bfe78afa58897f679f3bdc3ed5a009ef201e4aaee8f81f3f8301d55fc47faf338d3436fbe77efae4eafe8f97ae8b93a054f4a0075335a9341185be5328666b3c1d74d71e3d2fb94fdd540c92492b090506ecf8cdc60ef8d88adcbe5b96f44099079e7d0824c4c323e3c73629aa0e651c88ea098b00a91a952e1320daa9b00423f96c299c82cda297939b40fd432da96d418858cbb351035213210d613aea88c7b0ea8d501146e6ed8697efa2e8d4b4c9af898e70a72e3bde174c49b1725c1032f059f3f8a0ce7cc97304897d131e2f3c62f3a631e8a258f864b6397d5471c64b3fe4582d97c9fd674e7e3d59d52d366016337d72fbc8fed4e4d5ee6435ec661473972443b3df99a09415b2360209c4ddf3579e6b94320d920e0179acd139a293bc6d3b0826409c773ea95a347791825c8abc4b7b9ba1fe04255174fe98d7c74b64da608d8180fc6aa57675ebe50dfe873bc353331dd918009b23abe85577bebbf4a8d86b2a02b85329cb507288b06a02b7638bab728511fc9e39c996e689ceaf82a232acf84bc6661210f8e36333a3f817a524524b5e615b42fd0ebb0bf9d1ff4ddbfcfb799b1146bcc0fccd2f602da8cbf21d3996719ffc29032f227618920ddc434630391e9d22d1363305c29d1fef0781ff0403e3f4c38f2a8144bfc639b4f0f5d745770885be8803cb58a8e5cc1c00d9cdacda46fb1446739c8180b0b3a4e11793436a299411a45ac804b02f4c36c3b967bb1cf90d1bfabf954c724d56103e3a58ee0c4df4ed85bba8091dc2503d62f325690d4ce026cc0065eb3150499623959ba11f55f200e7fa8f86e57c5572a0704297d9c0d8bdfd322ad86fda0898239ae7c60476991d01edecf2703877d4a403a2bcb886e8e9bf548e6d9b0e876a0ff5b40e8bacf421515a761e7db101b81f6e4d8dd85696cd2ab84d790b0c96be5706bc4f45ff663a847d8aa04d91df8d3e63b5be3e1bdf38506a6f7786e64be048946e2e42f53b3cde527a9f9441fd8f3f329325d46cc7d08906ee8f19177b7dde8c2b7a36079a75d73a345d4ce536512978b704808289370c10799427a04bfb684bebd8615cadee57817cd35d2d4b14f8b4be2666e825ba8574d85663df630b74ed3f968b4980f387d8b1e8e1e752c49c8e296ee3f05e4e048f942c04c761603b236ba7b6ba646b6b1cf6e17414b39b76ca334c002e911d486ea49d899ee2f1dc6251b5cae86b07f1d78ca750763e81793c7365a2af3be47aacc0dd8524961b34dac35bc65684c8b5e8819a5ac4960dcb6c6ec152e31bfd3a6e65c1cd2061d37ceb98de622c8c573bad3b4d73e3a46d86aa2e36e17d66a7b01b51e390facd2186d291988b22831e01fdf4d1d79c4380db6dae7d5b154c1a7927a64e5e1076058e3d9bc507e41549eea5e511b5c60f1154fc30959cdf8a4480fc1a784ebae71467195b70d77714ccd296b81549bd117341af2d1c13bc2691243190b5b37c862a473b0f540ce087aedf3f94741ce4a2df15cdefa07c3ff647627565653ce574d0752147f0ccf7c7c3923bb826b938927ec27e0c02bd56184af0ad9bdc155095c16b2ec5af41d4a8b9010f58a3535c20c0b87086b386397c691508850c001b893ae5cf2a6abc772dcf815998beb838e4b1441c2624deb655f95483dd713798e2a761de91875e8b69d21d15382c82f5e9cd9acc3511674ce2000597ed467057f2022807002fb95322f335f1a5b92df94b8bc24a65320961f6ec9f1863ef9ad0455a25509afd3f2fdfc92958f2d98352d3bf6345f492abb23d53c98ee496e1c8023a6798b2f4523f3ece1eabfa953bdc76e031d5194a15d901cffe6c467f083a57be9e6f689f0f150eb2d0280959bc050bf02fea4a7d3d26b2239a38084a4ac42235930b89b20ce69c1d98f9b5e8b804949ea0c6b56225572b17bf117cffb727badeedb81b1bb825e150fb028f5382904b39cd2f6f80f191b07aa385baf0630982d2f4fdf02695350f4fb93e8a6ca678d6715f0329a539e32980eb0fb0370d629120fdb755c8ccefb862f1dba97aef7087e0d3487b808025069a869515ccef577fd65dbf385c394db6101c7ff5f0aff615f5208c6ad872cf344207872a235b907964d916c24c20cc509bc9d9a97dcc4206a8ca074b39d5071ca1219e0226093840d0ab4680cb1184b02ec15b6368cb12c909dcc5d0f2ed0409d22425e103c4bbe585db826f4bf379824788d1c6f70d6dc7e5e458edd29c54bd782e79117ca5f369241f497852a69e58af086c46a22b13e6629040926c95da389c1ab19df76efc6c915b16ed20a06c99645d3cfa0f3989c3c092a1c23c42caeadbc6f64ededdc038deb65f6fda66f10311e45622a1c8708524b0845f757fa9fff44df7fece28659bdfa7a5894ada5e073714890449b24d185430299696b8a8e97924a48098bfe126f1c2b55535265d28ad277b032955fa1ba1948bee0a551abcdcf972a6ad5b0bb14426938fb378ec6ae5adcf0da2e984ce20a0d4c5792159ae956f73a986352e04bb61793295ee975579826a26e16b02331caeec475401bb23e5702dc206acf4f5ba1741910d941fd55f35d5dcf0ad848576a51719168080a7112427a7c5ccf69e93f10230a6c660a3c40fd79929fc789d53b8b9d9d0cd6d57eab166d0184f268a31e8c9a82a552e6bee00f2b5d0d9b0ef8cf8740e4f7e0b143a1040899206fccf6daf0e54fe2955b1c86bf6b2997df075d6bce71eb039a92cc515cffae728f3d26bb5cd11767e52d9dd71f617b09965ee5624da78b2c72de9426b3e0bd3394ee5a92a6b73de7402e0aa5f57c567f90bbecb1116c25a18fa3bfe2c718e089e2f3a50b57f31df14d2931ee79ad39574693d85bfeaf8bd5472e8e3b5322843cce70b1b6ba3d7b012886b6f3fe25b0575a2299cc735c8a9efe5e011dafaa4ad097fa0bb52017c3969bf2a2d6a3ed042e4f47d414e826e079f9b3298bb8ab1ccdb9a45ff1c393b5c6a86aea696b4291ee82b1f36b4b6294420416662c576705175e9283f9070e20b39a65643925518f62f6eb2f9ca3c6dc714ebca1de9a4a092b77347ab07b2e8ce24c8ca9215bbb91a4356f01f407e9a8fd8beba92549eee684df93153b8a5a6e93059b513ec88a8f4aa5cc578aeca516b316de72f3578058f31cfdf798cebc52fbcea45e836b4f2184a312cf56efbb0d6b2a1c9641b12fc636f027eb6635855842def07a35a1db739fafd96b76663e2be84d93b2a0597e7bb3de8fe4ff6211d206e968170770c55ebe162ec0f167c216308792a2f27316e79bd0b80da4d18520e8772a3771610b09325ec78ea804b8028c2fc89bc4582f483c7b91a880a7699fbaf9a16a535cdc99082983675c2b3d0a2ecd92c2d829e9d270f6efc586aad34fb847fd3abaf12b1b6c43384921ab51e3222549d2d4694522d842002b1dce0257d6837d7e7e0e0a9e1dcb0b4a779839835b8fe0790f2f41a17535dc005452a0efdcfc52710be441993061765dbdd61848fc422a8a12cb83a1a2d8efed3ddf9b7e520b97e1a2dbc37afa3df55f5f1d6dc4432fdb2db86b88578007d93a0bb34eba9fc9ab246c5ffc92ac1de40a0536e346df46a2cd33fbe9ad7d1b9e9daf438f8bdf9044c69dc5493b1b006a7021bb4bcac05d40261d3ed7861dec55dfe97c20500e89339b87e2cd40ff59bb12146ebe6e5018d1daea651fe0baf292fb559831277d39f0d838a57f2dc18cd6c4704e7b8f35609838809a2ec067897befdf65f3f0217387e8bb3fc11fa080a22b94d3f0977abaf9a8549d51980458ffc36b49f8a1592ea6d78bea7e0b6c71cbf26b1039179f41857eb9e38686b334998accac8b133a68e6423881bb1e7cc663086f2a5ab4cc740c6722b2bee6015a1b081e846a06e813b517dba2549d69b24c3b9c1d4948f8af4f70f0ca1936467a18f75403ca0c17ff43ef0b709877faaf3dab2c356291eb5a9c25927fa8cc98e8129defd797b82dc52dfc51c3531b60e97370edbb1be87b8285abd6cb08385db788199e7969a3682473cf4c960e71ee774100dfed4f59d37cf789dcd24ed7822f439a1743679f17558c65e71524768b84754e63a9e6c386ee1b58e89ca9ee93d654b9ba305fa506ed0d23aeee975d4e007900f0f7af1b22e640f252ca0626cafc52d997bc7da6a04c2fa5e94de1c8f022d65bbfe0a6347364837d33e4bac3204392e9e6c1c2bdb05e62b87c742e1ee8b1862512b0c3324c9db636ba4c273642e326db392443d57e9400b382eb7b934dee4259ebc097b1f0b2d03ad177143c7777fba757b12b7dccfcb79cb9f454ae97c4dfb013f4036dc1aef79d3f03876f3077e206e5ff061d3767716cd6e8d251929051916e68a91837f98db827d8ab801751211a516ccfd7ce6a5522157e2f3237de71adab3130306c945effdc3a36f9edbbbbbb0af0a76546f4598bfe96a3f2625ff0f529054c3f2faa82154eabc8d82ab1171ccdbc35a9ad5882e3ba7038d579910b31ba93b621cc4b89deb922600e8c2ece0d976d018a6d1d178de4ec4361342d032ff550f9a78e716f85e60769da0f42dd47519ca5317fdf181ffeb2ccbb741bb2b405b6bc9bc334daf0bacd3762ca1f342f1a2f21ebdc56a8ec723defb8967af67fb775e811e947c01cca1f1b467d0cdb116f6414b72de0d744f4f40e3f5c41d75e095f1609c24b5fdeb2ae6d7fe6a5fa84046dfba930cac360c0a0c0bb3121a6d0769a4b65cda12b1c1cb2b196266ab3394c7b6050e4467a3dbebaedd1df63a803d3f1c42a99ce09d976aef8b709fda83fa787b6c6436e656cac991e4e38244d420ddf12e445b56775a4b0d20e45050a3aa2aca5b1617b362e132b13bb69dee87ffc224bfcab0d9160dbfcc2b0c24275dbf6e0243d099771f9a517f6a26815d54abd6ae56a334e3f24c1b230459018ff151a099b16a8aa51d249204847e87d655302246a2fb711bff87c68b44bbdf877847bb9d2ebe753f01db4d0d893a8c9198a5e87ecf32896106c725e70492fa040f60e1982013f0ca5109fd174b532132fb040373c12a20e1fa318f598067b5083a5f4e8e11a2f90b4b68edfed041138f8bb10101f2e6281df07145536bea87afa06c5c2128d410c6b4a24253a7d6061d0804796c47baeb7ce871ab9b5c15aa907a40489f4f5afc994aa7e7e47d73f30d6b367991e6bb827f90766a1a61bb627d9aa3613f42eba2b8c9f61f32d121ee618222247d71a2f6a4e70fcc4c9b8b1f9cc14000a7e7f02de13d8dbde8f3b55b31087d078c353fbf5675cfab55efa9a89c13657b0cf2d316700878ebf48ad098b60ccadffb79af0bef1b3bcc56556ed9fc63906cf02bd1ec271c9cbbf23a961e7201ec8dc45a54ebce5572d0dfdcd2e368a1b7922d43aa7e81162bfae2ab6d32136402118ace43f8f53baf3926dc21d1e114d54e9c2dd2795454f2b954497a59c6370cbc6571c76200a92ec0d3f40e1145c8525b41d8efdbc940f21afa8391e4a2ce38461c0dcb854e0302ac3d9c5d2faf79b128fb289f8607643b569778dfcb79ca402df09f98c317ecffc18770923a8c2121740e4a0a2503c908a2ca6bc86161dc3d764185e2e91b2168ec508b5b82ce8782835ba682b2d3ce0fe438c5a717d0a1f55abc0004d46890aa61b5dab234bcac26b7cb551cbfb6cd8a6de4540a9e337e9128548a5512010216a4e797b43ef6ea8397cce43f4798f96cddb63ea9c434cc576737f0e21fc448f730a641c1613801352889e81b8bf80c02c731f295cb0a3d7fa6cb7d6be0a5b1cb6e8eeb4e828d05b23dd90dccc26d0d856d48117835b0fc7133a7210c34ca40bbdea1f46a9436972eb560ba90b3b4a2456c2e4a8418391ac5cc7322a263e176bfd1780a410e6ac700bbab47609b8a0ebf081cd057d86b541c3c1f613199377727434fd6de844af58d4258c6a8a2bdb53073a23fb78acbe8bc80b709cfd78db75f4cde09ad79737552fd56fe2f5888003ac678d5326ff49732205a96af44d14f5ca45f4d311abcee19783ae6a6876ddb3cee65ca7b200d8205c831d24a69c6f130345cf576c253c8e9980a8ba3567bc0048d0d130b6d7c86db08c38879ed6b10b9d901e7f60e4da1ae967a6ac72b862b1f86633fdd09d1c65a6fb450986f241b5c5c48dda4bc1162600a65b16f118ef73d301e62e74169edbacfc1f5fa8b29e0931b2d460dd96d23c817608abcd906c67f3515440ed057d5db96a453edf897b5a770aec6d9fe20dd7c85d0af232928be4e0f382a3ab9a3d42fb692d102611639cad5a4eb393d24de7fcb262480f9d74c972eb77fd73430ae4a053d1817d13b35bdb9da438dec656b6e5b3cbd10e3bec4f3d1148bce69a40a7944e196e877d589b474b7000568d3edebc08d909de94192eb1da99319adc9fbea2a61792bd96d56c49ca95e003d9137c3aa1e4c78ef79e9c1322c2e6546e40c16575291806073cc96915ae839ac4dd18c982bd33dafa67b88b41ba643f3ba20e810617b87c91978299704d7312be2d98d90a0ee58deeabc6cf18b891e3007a2df0e7e4a21b676a704411bb50bfa43db57d654abf853531c9f774ccf581a06b10044f706951fa448669f5b630bdb805dbc06f0b0d640e5c4108f95b676a4e93770007432c1b0ab2679e7f666697388aedfd3f784f87c4340f26ec7373fb92af61e2cb91229ec0e10ca02ddb01b8b8d1d36f6f197785da7119d3cfa35c4084adf0886d58f7a6a2ef73e2806fbd223734a1fc75665d5c1b6053d7fe30723e197f6e94ece3df4769c3a26906c9fbbd59f8d12ebc68c495167c495232a38fdf88661f77a84efec1e5064a82ee7f2c74387f45cb4e896fc1a18c0002720488b3329280fffd0afb0c2937cc2a4ecc002c5a55155e47b40e10c1599524a4e57371ab9d0a26202831719dac070ef86b09c490b89a9919740be12f68d88e3983ff69236fa8fb9cda7d9e754bde260622f85433ad32589e9c84e7bf2490d665a0ccafb47caae7713d5c1a0f5315e01f6616fa48fb0c22cddf2ef4fc26e20221d386a68aeda2ef475785c5e2b935e961791449086ad53506449e5af76708cad6927bbacb8154a5c649348329eb62896dce0ae022e673f0a1d7de54f6a3c6f653a1edad8fde9b29ec9fb1fd121ad9d70c0ccf55256fa6dede90d7eb8a99225ef17f69cf602eb0ed9453224dfe28eae76a2c89b6b7b4aa583445ad5f615dc4dfed3509da0ddc5f69ee40964d61c02ea3364fd18c0985961c0d151c77c10d90b270140a937a36554782c1d0caf044c7a9916e45821f0baf74bff1c61c03862b184aa3fbda0e58932a125363328e36c8c94d5bb8f60089fb78d250d03748da6f1f8940b7f6a6e97f9c6beed8dff7c585f577d59efdf059ad1108f6dc582610f57e992241045923d04028d0ca103d0822fd308b9b8a2fba96e08a0ee53c24cf86fec0a12c6ce0acd15131caeeffb26fee97bca5def01ce52045c57dac061ff90a0c36dcdbb8dea826b1284393a5de0d44d43b6e87260749924539ebbeac51ec7bbc518f192e83d7c1485d34f1bdde75c263b777324f2094e74d30d65f50969222e9e1bc5e0d947f530dd9aed78e618cc313f2079b3ad1d4ff63bbcca1f4300151796b15eeaaa6ef8835c70db74e58409169a8952c82ba813a97ce1460a569bf6a7747bb40cc298299615eece186bb1e9d5e224bb5298ec74e090b45894042f7802dc111e89b275fa7779b6e246ca9c34bcd6530cc1eafcf545841b292eda8fd4ccf566f219c13e709ab7500ecf92549eefaa4401f33c5c9b4cbcb4ab24138cf8ce7bc971a736144c7dafcbc03a4cfada03af03a0bb719d775fa5e96af3f800b0b3ed3a7b7ec5b5d9fb40aa565f813181a4579703b7b6e33345371a58f54a7a7eaf2ffe3a3879572876619f57fae6bf2bf43dd3c69b839bc21ededa7db238f2609f5888ea1adc354ff30d71467a10d1d8238ee646a9578338aa5d3c1acb7f8b602b71da41b4f86e15294310bbcda4c43453347a61edc905e57fa258ed7e6de1a34b5156d1b0639261fce810b9ecc565fd86b566019224a132acdf5ab9a6bf15149548360cdb5d972a6a4f96af4a817b68375696da4b7557b901de3da3fd8446244783ad185f19afc0083f2920b6a08b06dc76639bda49f940fcaa354101dd57e074c222a709c796c4081b8f197bd0869303b5b9945fee6f3123409f255255d6087ba174d80127c5d76755b4c549e465ac9794455f8f1d169322852135392a2adf8ccb315f1e7575f8c1e94437ec93ac2913edeacfed5759908b7173bba59ef5721a6f0f71201003faef3e52666c0b0e982e12e5b200a094d31ef6e775424bd2c70ff85d2b30b90ea61e7f7050a1ed92cf06bb085e05004685bc60642c239c75fc38388b0c12b256e1f9b723f744716589736b8b69d6e550b45cccc2d4cbb708f3798858464a59a7d8627cb875e91e476a644a22c88ac387c641beb4ddeb54ddd7fe59fca619a211d4ba04b7b544b7ad1f543643344224cb2a2268762354317416bf8382bf536498e47a684248c6ec831e73838fc8e56142fb7a8180675e995873300df547e1f7cf936adf99c916e5bbe84e70fddffcb0c11f565e2b69122eba0dfac5cab204cd539627615b5c4a16d6f80e68375bcf9a81d5b71ed0ba36269ee51a2843ed34f3d1b9e65ddda85d724adcb2dd9d9a880468670f6f644fb11d908de74933ac5bd3179f8e4793a35bb67a9ccb21bb569707f46899cc232eaeccd06649dd90636f7b7f9de3d51e5246757054b92583c2e89028ed8b63b6b73b82ecd013da5341800bdfdeda4de4eeec2628fb4ac919e12ced9e238abd544394e77b608f6af2f03d5bd2cc4feb39f54c8a0d91b348b1704567a9a2b9756032ead92a7007adf48864ed3a8d44aae53a3b2bf26b53a047a83d51734e4651668b9a55647eb99ef64c7c36798a10af4e4c2471946753ad2dc052e80e6b76f4d1aa919c66367e85b99e74ed961daf0cca6a9a648d4f55c03f20652de9f34338b3375414391410d51320d10a360874a065e12d802043c6d0e704cf412a54e936cc059dc37e924d5a4d5bf4e5b06e7b327b3d242e0aeb033954ffe5dbbaeab83681d0fa2947c99a83958cd692fec005b79e6aa6e071def9fd563316f9ddae8215e3c410968d1f77ec02b08384326a33a7689ea3890b2e285c4f46fae88816b5b0799c0360b3be913ec8827160591c05c7bb498989bc20064ff497eb1f553ceebb98fa62c741f60049dc773d47b4c7d88870ef586c87cd8c85a43f07aa5bd026a30698e903c34721f4f387dedf469949a7a89608e836039a32d6287c3a9654a57151ac0d185424d7010ecacb97d560a22ccfa979627ad68d6ddacf40e32c9485f664e829db39c7e6e305bd7626cbcf25e9eedacc104680ec5e7041f5fc1df37531ec44739fd3bd4dbc88949194c381a9de3a4ace8b10cadb2be5a86376da37909823ee5046e146b55ed70676f0680040de55380ef1d3c23fb21c1d1a73380dcc4f12056c48f4aed74d50ac7a9b150ca6567e445d2fa7722ac564dc2a40f1ad66468326bfadbc07bf014368ea3f9186e0c37ef48ea4cccc4d4d00c5e2a10da885004ee217a2c1b5730f7dc13dfcbf2a6812b99dedbead7728a4664ebdb60d0eb902536f3587db75f9f4dafa51554a8eac38ee38a41136a4c010622a076c8fd16f2bb6e8a26a5883561bb3969c543c2ad009b01ae4d50f7b15d3c6b3da82bbf2d5df54e2bf6fbdee7f33fd2a8cec59d91e93292ad3e420dd71acf6f760a1326e483c9a69f3d9151123e6fb1dbd42fab23c6bcf2be10043745f4c2ca8849d4c5354e645a77d240e1bc3b5d3d76b28a092e49a393c4b702cf3e22110b4bce048053bf5a422dd916569b10ee75c64edc0ee85fe5aff985e9ce53b288c1d31f1f69f811c70309e3ffafd71f460b6c3fd7b480f3f5af9ed9d6def506b104de4a8c241de7e8decae2209dfee91a8a1b3086b78707231b4e88bf7b7e65a53355ae89623cba382d64e79c26d170cee6963ff8855249cb1ce14205ace6739948df91577835e731aeb17c2bf68ed6b00f0a5952b328c3fb7c5aa2225c635132ad75e6e157fa8d115bdfab2a1a619a1d6395bf5d0d5e2968028ebe15b2ef50d1ef290b76c9a34d48af8a1a6b30ce833b182f9d6aa6791e3b0c0b2ff1805504d3bf52d1ce170dad57f7faeb5b010d3cbeb49248a233ba2392ad73df183afd791ddb09da90456525ecb1d0a84a12047a672aef6d76f2a21780f9031bbfeaebc64c7506e0b5840689b10bfe8548c5926b4b9519d0a8595cb2376105a192cad72afeeded93bd80a0458c4cccdccd7697eb83e83fb4e4b6a6c13690e80bc9bc7eff2e5640b983e5b4be8b328e19bcecbbc5bc8194064baf139dfed643bb3cdeb9e71fc8c67d84e3c623f39cdeecaa2a4383db83789411b4b9fb95625171a3e9a217b769957c9f707033f6e7263ff63a254a3c4e08b0d7296f23777d1eda3a12edfcee58c4e97bde59decf03ce615d797489316f186d92a23f1d5054203402d084f510334ba41d5ec6d16b9f9db7c42d7b0eb2d3912d919d6f506b829ac266d4abb0e30cca383fcf27c2fcf41389e8ce4dfd49d61172d857e4470492c50857c4e96652c125d78790b37ff436e102ca20784623e841a1d33b9ffbeab66442956d7b516dc6e87bc9da6dd869903e4f331d80b6846938fcb6ff370c338d4eb2c9572e00581c3b41fe42523a5e5cf5414011b53425855e59b6583b5637b1fa16ef67e0c0502678182aed4565862a766ae4c92fc4452a80727b0c08588b88c214df2cec86263c21361b4bb3d213379795abe745f9bc09b27007c7ebd8773c8565ccc3fd6175b352ce41b8bf10f7ee0369e8e1f9fb09089058106bef2f801a723300d8ff735394d777f1794a2c45fb9b12c2f4864c17b3e49f586cbce1558391d6d80c0d79b397f7bd82ea255eb1501182102e5a8952f7d3842e76b11d809b4f298106118670e8e4981bfbcef0560cde2cb23075fb2f0fdc073f5e73f1b238e5c110c3123ddaef97d83241438e14e49044d8c9824a48b12b87e26826d60e4220dd711423ff1c1303bf5df6ca82e6e9306ecc8ae0ee6cc8b02e7bdc83e1d4f210659b187359b39c6fa362c438d1d38c0ce5dee2e5ea1e2b58898596d1734f386c82a891071623361b19b5b671c3232578e990022356747e0f15e0208d5c69f8b43a30a35f9d0a08aaf2b292ec55a962b6ca29fe304e4a77700c775d08a5bdfde4fc81124a252ba29bdabe6807bbcba6b48602669d7b610ee17960f4e362c8e11c0f3dfd74b050a6b00f7869c93a6524d83d4cf100f96512128e8ac0c9785239e0b5837318b672ae86044e8ba4690b3687b314fd865585554747cfaee4a7f00d3b41362461893517a5b224c1184ed751fa11545f6eee6a08890c8af0d88d46913d10a679a677f376e9f195445190e6afb788ba45d30b183102d8d2aca975e091ab602db511bb14980255e6bbf84878f745fc2cf9aeeae245c577798e3ee97d283ac9330b2dc9acb740ff67c17f14de603da34ba2f05b96830a1a196dcf3ee6509a898247ee77e0d5e264c233348ef205d614b276f0bafea16e6bdecd1065fc53b8891e04de3ae3b768904b2ac03788066dadef3f56347ad162f9dc6fa904105a4236b5069288daf4099d755a874fa153392b7c6e5d0a867a5d19597783726e931f854c3be720c10b1f4c35e2f6e221ced2f29899d948f300e57ff5d9c85f400f0892008b6c04faee2d6d9c842e98d51ca0017a0b1a84f66c51ba78d50f927c37026f097f2b6de86c62100ba854cb54feb462447ce0928c18f1317dcb1449766e4500c347922222a76aadea5836dc1bc2f23f461407cb4dc36808f1048ffaecad461e7480005aa5a26c16e1454a159de10f3dc440527860dbcbc134714ec89b862d705576383a5163e9f8e2fb6301bef3155b2fc0d44ac0f8a6e0ceee4de82278906a3b4c76cefdf05810da6a822d61316150d28c09f41c8e733bc49fd517026c058613ddeda94eaa58859dc3b7d310721bfbb73f5035eae08dbb99e142e4abd8601f99dd086f55d0a23fe7d0d74de2eca6b010d1e59b469795f07428ee32a0932b405402d60486a68e4e46c8a9803b7e0899aba060cec70ab6bcf5d37315070fb538b3b4859c5a944a837844f010c049eea16c71da0f7119c9b9c5efe7f2cd6f0c1510f18a0eaf2b55bc87d61e29d8554a1c293b74f9ff9b855f65a6f013425f468f5ee83a5ca1e807304ae268e45fb71d3c647420af82acfa57180d859f8f4d97737da50633f743105c1ab3f0320ed0d920d77228d7f4abfdfa964ce8c68295006b634cde5b3871fc296b56c9cb78861e7a93bbbca9244d198325abba0214fd08a69b922aec7232261c6d853f1c81f3a854e2a2e176b6aa411439ab829f10838eadd40439407ebda5520303b6ad97619eeecf9ebf3031bd6341c49338a855d1a11fc891804c60365d483f45e6969bd47cc5e01ad5bfa9303e6d9d2392f3eea198ba3bb9a4c44b89d9729e171c69796efc71fac8d47ad0ee9211fd2c3cd03ce0e1205d7902ccf474ae3445616ea99436f6cdbcfa560e5724ac8d9c518f4637c81809f03bd470437522ccbda695761e369c4ac46be6d5354acb2017be1c82d1a505a9fab49fb0e908403ef7ca698a431f178856b9b9e383c38733d3d1165741d33ee29f9302f70bd93a9b4387670f477624c91a144de3a360e1712b9f92fc45411670768641533dd39ee841031c63ecb0988bc2828d1c74b81c893e25973e2a65511d258709b3bfe5b7b993c14dbcc780b56c43e0f8fdb42a72bd8aa55ed43c6a4633896aee83920704d80ec5c25a02c4d1dc8a7a984892748e57e50878fcd353dd0774a60f2b36faa38f30ef2fc13cb380eae1b852a767cf9211db9439e5be3a0a7d9f51c998afe769c9e66906d2d45965cc58bacf57706dfc49454f875cecb7b695f75fbe8bb2fbf2364c28c34078fab218ae8f32913992a01c2279c04f3a4f749a3415ca7d13fb9e874825709275d20d2932b0e107695f21d23f5e3e592a5d53370a9c9075de7b057d8149f39972603224b5af27307e3f6e3f9ef111c8a0ab7b1910798d0f6c747cb00f553913c9965733b1ed0fe5ceda02f240d6f8e40c2477792b93656fb7c4d7ca575149e7dc8916d4565ff15f12cd1da27efd0ddebfaeda98befc368c9d0207aa2d6ee10007bd999e875d5879a0dee913a578b5b04f2b8503484371e06ec736ca57336fd0badb2883d7355799e8f89973b5a160bd404fdfca069337c761d5c4c6e40e6cb4a4cd1ab95565435130c96a6c00f37825eb82e58f3fd8fda341de99bda6be6668e2a0888879b4e574a81e2bb737a431920d5ae2542ff12ea8737e3b417e5f2aa1bc0bd80ccde64e05480cef0ffc7bc67f79ff8dfa594e8f43dbd94db9849c71b0b5631ff6ffa60e80c9840a3b09ea4c8eda9e8da1e5fef616fc63fa6b6207a8f9eeeefedd46235991e78b1bfcb39a51d4999cb0fb6366ccc35dc4dfd6c226c02f085e6e4a3a468a4c2fc6df3f8719f55e130dceebe91d6aa4cf516abad7ad89f0bbcdbab3c2c46f41f5c58e6026a4deb436b8570403a08dca4b41443571092a9e3205a62d1dd4c175225eeda23dc6bc389afb17293cb27742ac9e1e4bd3ef196bcfec8078152480384b10b3e102d7ba694d5cf5b93b5e89160930db001241fc535b8cf8d762353ed1bd6a09d47fd4d575eb0a688c13b1295d7c76fe2ddb44ea18045b34631913fb0313e21a9e71abd090288c035e305fc6193934ddc987039bd6dfd0126a4b21c7d1cd514092e7988e17956808cd1ffa944a96a43c3d3ca34a1881bc3fc7698be3a55f079a81df04e609ff0fd9a77d0f7c170cb8c8275595f30fe8780c0733b9b98452efecb9f37a69c591c5c7b95714a95f7a0917154780265156c6b12dd589a43883c276ce7b064d8163e4c9b2db07d6cf3e14094582152b22ab054a2de02d0b0eceec634218bdc0be64fbed736be164878c5bfa059e9b5dc90f5e1c8d0de517e3f296d2a398f40ae22d76ea1ca97fd1fd71cda855486ea04d2c00f195f9824e63d773917366a26f5f99cc958fc8eb7d18b71ac69c978bd804e2385f52217844b98a05fb915cd4e6d331663bd4f57a18e41dd248652280869734a621c59438058388d31be18a743cd0b0aa8ca6a43774672361c5ae7b1f13e1d9c2ee206a03dfb13ba7b59f6fdade34795af774f1f84ddefaead3e83c8dfd85af5f08277165f0b77e690eed1049c7ca214677ef56dbc880313dfadc8f8bdf44169025071eb4edc55657ed401689786d9f7581715e29726eb0281d66921ced23eeb4bd3f05f19a6a9207033008981c2086e16a80f17ffc2768301bd9ff52202729d1c49d67ad2e4b40bc457f0751fc78486efabe296969e2ea2bf47898b349245c4514d3ddc515ab5ed973aac92f9bd8589b9ac4eb3304ef75ef73c7caa2577e757747ed511da3b08c2ea4886fd3114fb2c0065cbeb49b69de3e07e4c23a8f2d5272241500630711e84b3de45ea8465d08cd8a887f3759652a55f372f27f6064047d9d9dab0904da2435ebcc4f96811568a74a574889735e7f36357143e1c7fd0747f12f073d646c190183eac5aa4ee28012170ca20d0a1bb49c644f62cc6f77feea7f2b21a2a756de75707a104626cfffee227b7804bdd4c18688a08e16afe4ba41251ac749bb32d3b0d20bf956efde19b63f1e5b31842c9fce76b2b14ff04802ccf81b9f8acf45527e16fa24ecfe816db4908afef0d28a4ba23ecc82205e8c01b139497aa2b2d657ce96b264f2ef10ee11518ff8ebc34ea9bf9b1dca7135d818318eec6e1fd78d8a4d8ce2c7413c9b485fadfdbf18b548273ad237bf8dda4de33288931709ac79d9e61d936f5b8f6feea0e6cf5063ddd5986a2808bc582dc18fb14648cf549b1b7c28cf92fe8c5d6f332fd646f8a35d2e221f973013da501623b363889911e1b2c2b59f7dcb9ded5f02c946ad67519c7306db7754f3bbbfea077da6002347217ee5f799d391b3e756ec943e3daf9ff2b930c229be3ea0b701d310597e6e28fa335bc8d73fdc70fe3f35e345342cd3bef5f8f9c6332746d8f48e3a0ea3f12efd5847fedecd0a5709dc749eb5cc9f19d27a975455f6a1c64df232495ea46b3e7b2778dc39f2d1271d4f2bb2bcd64c174042a83e84b8b136a23aafed393d1f7c20ce99b4247799305fdfec113d7f11fd80b0be23ed595412652f73b7a1e2bc3dbeabb1fdf81c34fb0e57989521f889dcea04869aaafcdbc382a8c2540dfe69c01dc4f4bd64429d19a3c4cbb60a9bcf2283ffade902c8bd6892c296c00e7339fab9d6d841822ef00f32cbd3625d7c327ae33663ad8f2609fc6514b04c0f4d8dfb8956cd7853876cbe8dad12c3d6777a0e1c4c4f950fa3f84dcf5ca10e95f666e7584fd0eb0fe149169603147ca8f74f7a1c29cb7104a842817bb164fdf6ee8e4640bc27470a36603a9d9cb6001566c38c5d57e3377a33a84cb060544439887f797622555bd1b899dadcfb0486cc8ac5832f6a8342ef46f4ed18acac639e6a860dca8458c2dbad7b0a5b11a2b8dc79e5072d2ad9bf1b7df53cfab0aa59f3bff26b599239a81b36ab0630c65b16aa50ea4d84f8cf0aac4dc9b6447130a13fc5bb4baf2c26499306d28811c17c51c01f2e7401e443e8888b6bf81cdbe636dd278a2a5630a2a6e60e1284cf323e75b9a663b24dbf594871187f113c59eab45b3a6ce55551a304a4510f5bb0028004e64f6c551d02dc62f9565b060f7ef605dd3d09c4711bba2c8da83cf15480eb82d1987e107ceffaa156b245965288dc1385077ad921676d26f8c94a4bb376404e9b6d8baf3d1322af28182143abeb79fbaf836ced6d55485810f7e730018b3a66bb97442d971867438a260cb52161e02310d46635300630a7cbb95b281ec3569258019e8328bc417bd4b337315c79880855694523e037fe66c957ce1b6e4e85e5442b1a820fabe851cfd8334fe5be835c1d58985ef92a20025cb61ffad86c8eb186ee3dbd02aa929f75ce612c8a162f4fce061fe843dc56457cad3b698bfd5c0368fe90e2bcd4650d5cbdd53a56a14d700c27169656686411e709bd29712e0f8a4daeb5143d1cd47fa3950642bb54e66af790e0e7ecdb53f7c6f3e8f581e05d3c608af4753a39083f9473849114ababa365c21fb46c70caed9fd94bd88d32e2828a2884feed9e7f314cd4d4cfeedc3fa13b4bdbf3083684d742c686f77090bbb165022fcc9e792df119934f7164b52b0bb1aa995d3712ef8fa8e63feb54adc319c440872d87d6ab1108d97125a2a6f935323dea4d2cc259020f38945931de1f15f12ad9bab297f3ad26e358ffb7a2d1048fdd0a21df0336f713180e1b455167b8ab7a83d3fd65f519f9124ddd7793374c2db0963a1caf426aa30d26f9570a3632574a5415edd7351ee5787c3eb3f1df81572793113c1a95386b5368c1c11bae9b09d1ba64e0bb82ed03743aaa43d4294301ff950fa97b226a37acdd0ad651998a18968664dc390041b4ab64bf7bef6a39e3d7d6cf946033f2e460a52d8dd4a5ff17866279abeb53bbc9b5f76f992dd7fc03b2f0437a34ee22a05fdb71af8f368e0bed4bfd726cd11f1d8c9ea9727432cc1de774eb8dc94512e6cb9b710c1094456ed0e9277fb1ef8446677c3ed4e0c332764c61abeb84f94abba10304fa09b2ac2fb6c79e4c1466a2f3ce48e0cfcc36a172f1996daa97b0aa6ac9aa7da4f8642f831f5753e4850d737538fa0b8ec9238beecde92e29bb76557a7399ac2abcf5fa0780ebc27288ded86c23a574437e3531a8332d71eb0dce47290b672a458e44ff466a741bb448e8fbbee7ecbc3f7740ddbc24961ad95f08aaa27f80dc45a9748d87f93b836a4c78e48b13b9db36827110b727d5b9efbf33e00ce3a45c12ccc6c5976f29fd965840aea4aa229aa5af539914d472bb7496fa79b4e55f5aa9477285e061ca5180ee1d09f01679adc794664aed911ec0615325657d476c6428e06e167679c403ca138328f8e06fa117fa38cc1990628c60765acef5591f8683d748e8af4cb985341a79d8838210476e11ea8e995c6ee2065384b302f3467c561500479d7bb896a91389f62fb704aa1a7772f3d14c50f4da605bff7328b4078fa7d56a6291ef06815218dc50d507d5479c5d62b856ba6c575dc1141944d8cad5e32b610bfb71570fe8f54434c3c0f4b30316475621d30889557324d6b4f7a6972f764ef47fe79e40320450b1bc7271fd6234060539f54a54d51d21d75f9637769e59b1c3b9d12a5049c083688b0a292e3299d42536b32d9e5fd31e02cbab06caa4a4a8d6e1d4bfd9faa3f66fba3ad17ac791e32f474c92486fc96ba534ad0c07b0ea9e013137d2e9d24bc9ed1e362cbc03de041af73d50ce80f0adf769d56218366e8c110c4d9b869f8c28076592908937fd36de197326af997e604b28caddd2f017502390b2ed706be9979cd53b8417951cac6de1e093597f0855da579f52de57bc4c2fc82c60c5b92d97def490e1e0781c71d34a5c8a40deee6089649dc148d7d7907a6fd27cb67775b0de687c5fc70707d1f77c99c0247ae4f8d119df265a14902075c5eb48c09773b41e1c360a82e340336d9c511adcf972641694196db0247f05ebab294aa7ef737113b25964673d570abdf27d7bbe393b3f3d77b67d02b6f2cc4dfaf90d793c20043c1839bde04f5d3683af6c48d1da2146bf1676adc328bc1b2511d273df794a5729767fc18216b4e2420ec59f9a184f07d774a4b6f6fa9118508abfa58d437d5516f00549eac6fc3494bd70026e8d86f478f60eacb162c13b9d46a4e0571afce065e5f29c815db9f225971c3e0707c05d42e41a35ffa605ce7114005680b5ad21942eb648ce793b7fc3fe7b7519e5c721434f0465fd0cc9a8faa9096008fe3fcbf3cec44589df8e01cce125cf393093098f8ae7335c42d25ac6210d708cbfbc41d379b5f5d681bc98bed117f8a53939ab70e4cfb0e889b3d2bdcac2dc7638910c52bc27c12ffc5dcedefe3856a251ac6b9782d46829d3af1e091e8fdcb1d7151552ca39a7b03d350f4db7f287115a667b2821c819a028a5fdf35f16314cf35bdd485d47672a129beae6b5560eec16f40d339f69226b1771f9cae16a41b838cc98fcb6d6e134be246c04f872e75bec1332cf9867cd8c4ada56fa2f2a604e7b68266d125e72fec69c83553a311c0c5ff3b6ea385b14b20f9d57390545030d7c263ccfbb63a3c30bd0155fcd3d70ceff7020dbdb426a4fe9295ab533058b7058d359914acaac534b89b4fe66f4af9b47617df31f27d10231fa6215801abc2fb888a3fc1ac1f1865e70a570659cc07fcd86996e7fab9fd977203dc0fb6387d88c42580303e105e5fc5df752c7be7aa697766cb9e08662c1e1bdef8ec379c6b2a6b6a17b27b3a707e82b0561c28cd252d7c2cffb7c7695a1c76c325155d56be73d1be881bb10535d74963dbb84e1226bad23e608cc352bca68efc09ef927ab351366cfac8e9ddca0f2b87204faa0b7e9bbefee03a434f78d5a82ed0738a81fd1133b34d32427ad8f28b5b3aa0c717273419112563f5c30ff0265907fa1cdfd2e2242b52b5ee2e78dfff95552dded609e00eaa2fd03db7e2b2717d8214c219c467c4ff3abc22bb04b42b2b26770853d1fec219aaa1107bb96471f18325a1c557b5d5a14f34ea19714e9cd02812f2f65ec9a69b26244b39ec4cea4d887ecc993e68e64d615f7edca6e3ff7ea6eacd4da6e8e2697ee0ca5c0a209168a6826b5331789324753422efd294ff70dc1a39f51a761c23886cd4fd8577a8d51a19ccdae593b73172367c281e582945c9dc1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Optimization Methods in Deep Learning</title>
      <link href="/posts/optimization-methods-in-dl/"/>
      <url>/posts/optimization-methods-in-dl/</url>
      
        <content type="html"><![CDATA[<h2 id="background">Background</h2><p>深度神经网络的训练过程主要通过求解一个特定的优化问题来实现，然而由于该问题是一个复杂的高维非线性优化问题，并且不同的网络结构差异很大，不能将传统的优化方法直接使用。即使数据集和网络结构完全相同，不同的优化算法也可能导致完全不同的收敛效果。实际应用的一些简单方法虽然行之有效，但现有理论无法充分解释其有效性，超参数的不断增加也给优化增加了不少难度。如何确保算法收敛、如何尽快收敛以及能否收敛到全局最优一直是困扰学术界和工业界的问题。如果能够用优化理论去解释神经网络的训练行为，对于深度学习的推广应用将会起到巨大的推动作用。</p><p>对于有监督学习，给定包含n个样本的训练集<spanclass="math inline">\(\{(\mathbf{x}_1, y_1), \ldots, (\mathbf{x}_n,y_n)\}\)</span>，<spanclass="math inline">\(\mathbf{x}\)</span>表示样本的特征向量，<spanclass="math inline">\(y\)</span>表示该样本对应的标签。我们的任务是利用样本信息来预测相应的标签，使预测值尽可能接近真实标签。如果用深度学习来完成这个任务，就需要通过调整神经网络的参数（权重W和偏差b）来近似数据背后的函数映射关系，这个关系往往是高度非线性的，网络越深表达能力也就越强，逼近效果的精度也就更高，因此网络结构很可能是极其复杂的。</p><p>为了衡量预测值和真实值之间的接近程度，通常需要采用某种距离度量方式<spanclass="math inline">\(l\)</span>，<spanclass="math inline">\(l\)</span>一般设计为<strong>可微</strong>的，接着用一些优化算法去最小化该目标函数。因此优化问题变为寻找最佳的参数使得<spanclass="math inline">\(l\)</span>最小，在不考虑正则项的情况下有： <spanclass="math display">\[\mathop{\mathrm{min}}_f \frac{1}{n} \sum_{i=1}^n l(f(\mathbf{x}_i), y_i)\]</span> <spanclass="math inline">\(f\)</span>就是我们从输入到输出的映射函数，<spanclass="math inline">\(l\)</span>通常也叫损失函数，衡量预测值<spanclass="math inline">\(f(x_i)\)</span>和真实标签<spanclass="math inline">\(y_i\)</span>的差距，比如回归问题中经常使用的平方损失函数<spanclass="math inline">\(l=||f(x_i)-y_i||^2\)</span>。</p><p>需要注意的是：深度学习中的优化问题与传统意义上的优化问题有所差别。传统的优化问题需要尽可能找到目标函数的最值，而深度学习的最终目的是为了<strong>预测未知</strong>的数据，而不是将训练数据上的损失降到最低。我们定义的损失函数<spanclass="math inline">\(J(\Theta)\)</span>衡量的是当前模型参数<spanclass="math inline">\(\Theta\)</span>在<strong>训练集</strong>上的优劣，然而，最小化训练误差并不意味着模型的泛化误差也会最小，为了降低泛化误差我们还需要关注过拟合问题，因此损失函数往往要加上<strong>正则项</strong>。统计学上称为经验风险最小化，即由于无法获得全部数据，所以只能用经验风险作为实际风险的近似。非常有意思的是：尽管大多数神经网络都是严重过参数化的，但是反而有着比较不错的泛化能力，这与传统的机器学习观点是矛盾的，泛化理论也需要更加深入的研究。</p><p>深度学习中的<spanclass="math inline">\(f\)</span>通常是多层的复合函数，由于太复杂而无法求出解析解，所以要用数值优化算法去求解。实际中主流的深度学习优化算法都利用梯度下降来求解，梯度下降是深度学习优化算法的基础，尽管目前已经很少直接使用，但它却是其他高级优化算法的基石：假设网络的参数为<spanclass="math inline">\(x=(x_1,x_2,...,x_d)^T\)</span>，优化的目标函数为<spanclass="math inline">\(f\)</span>，那么<spanclass="math inline">\(f\)</span>的梯度为： <span class="math display">\[\nabla f(\mathbf{x}) = \bigg[\frac{\partial f(\mathbf{x})}{\partialx_1}, \frac{\partial f(\mathbf{x})}{\partial x_2}, \ldots,\frac{\partial f(\mathbf{x})}{\partial x_d}\bigg]^\top\]</span>每个元素对应着目标函数在该方向上的变化率，因此只要沿着梯度的反方向就可以使目标函数减小得最快：<spanclass="math inline">\(\mathbf{x} \leftarrow \mathbf{x} - \eta \nablaf(\mathbf{x})\)</span>，<spanclass="math inline">\(\eta\)</span>是一个被称为学习率的超参数，用来控制每一步的大小。<spanclass="math inline">\(\eta\)</span>过小，收敛过程极度缓慢；<spanclass="math inline">\(\eta\)</span>过大，可能造成损失函数在最小点附近波动甚至发散。学习率的调整是神经网络训练过程中一个重要的调整参数，常常使人头痛不已，因此也出现了很多学习率自适应调整的算法，将在下面深入分析这些算法的优劣。</p><p>有了优化模型及最基础的求解方法后，我们需要对其性质和优缺点进行分析，以便于后续的改进。深度学习的优化问题大多是非凸的，因此存在很多挑战：</p><ol type="1"><li>局部最优：对于凸优化问题，局部最优即是全局最优。然而对于非凸问题，当损失函数到达局部最优点时，<spanclass="math inline">\(J(\Theta)\)</span>的梯度为0，<spanclass="math inline">\(\Theta\)</span>无法继续更新，损失函数无法继续下降；</li><li>鞍点：该点既不是局部最小也不是全局最小，但是该点的梯度消失，无法继续更新；</li><li>梯度消失/爆炸：由于初始值和激活函数选择不当(如sigmoid)，当梯度反向回传时，可能在某一层求导后梯度值很小/很大，导致训练速度极其缓慢。因此初始值的选择通常采用很小的随机数，避免收敛到比较差的区域，激活函数通常也会选择ReLU，避免梯度消失问题。</li></ol><p>局部最小和鞍点示意图如下： <imgsrc="https://img-blog.csdnimg.cn/20210710191530881.png"alt="在这里插入图片描述" />尤其在高维空间中，鞍点的问题变得更加严重：假设<spanclass="math inline">\(\Theta\)</span>是一个k维向量，<spanclass="math inline">\(J(\Theta)\)</span>的海森矩阵就有k个特征值，其梯度为0的点有可能是局部最小（特征值均为正）、局部最大（特征值均为负）或者是鞍点（特征值有正有负）。高维空间中特征值有正有负的概率很大，因此鞍点出现的可能性远大于局部最优点出现的可能性，并且鞍点周围的平坦区域可能很大，需要增加噪声扰动来逃离鞍点。</p><p>由于上述问题的存在，通常很难找到<spanclass="math inline">\(J(\Theta)\)</span>的全局最优解，但实际上为了减少过拟合的风险我们并不需要训练集上的全局最优，经典的梯度下降就可以带来足够的局部最优。</p><p>分析完优化模型本身的问题，再来看看最基础的GD的问题：目标函数通常是训练集中所有样本的损失的平均值，故目标函数的梯度为：<span class="math display">\[\nabla f(\mathbf{x}) = \frac{1}{n} \sum_{i = 1}^n \nabla f_i(\mathbf{x})\]</span> 如果用Full-batchGD，那么每次迭代每个参数的梯度计算的时间复杂度为<spanclass="math inline">\(O(n)\)</span>，对于大规模数据，这样的更新速度显然无法令人忍受。</p><p>学习率的选择是一项重要的调参工作，因此学习率的自适应变化就成为了研究热点之一，一些二阶方法应运而生，我们首先来看看牛顿法该如何解决这个问题。</p><p>对于损失函数<spanclass="math inline">\(f\)</span>，利用泰勒展开式有： <spanclass="math display">\[f(\mathbf{x} + \boldsymbol{\epsilon}) = f(\mathbf{x}) +\boldsymbol{\epsilon}^\top \nabla f(\mathbf{x}) + \frac{1}{2}\boldsymbol{\epsilon}^\top \nabla^2 f(\mathbf{x}) \boldsymbol{\epsilon}+ \mathcal{O}(\|\boldsymbol{\epsilon}\|^3)\]</span> 式中的<span class="math inline">\(\nabla^2f(\mathbf{x})\)</span>即<spanclass="math inline">\(d*d\)</span>海森矩阵，存储了函数的二阶偏导数。为了求得<spanclass="math inline">\(f\)</span>的最小值，令上式对<spanclass="math inline">\(\epsilon\)</span>求导得0，有：<spanclass="math inline">\(\boldsymbol{\epsilon}=-\nablaf(\mathbf{x})H^{-1}\)</span>，即每次的参数更新为<spanclass="math inline">\(\mathbf{x} \leftarrow \mathbf{x} - \nablaf(\mathbf{x})H^{-1}\)</span>。二阶近似利用了损失函数的曲率信息，即如果曲率比较小，那么这步更新就会比较大，反之则更新较小。这里没有了学习率，而是通过“梯度的梯度”自动调整步幅，看起来比一阶的梯度下降要好一些。</p><p>然而深度学习的参数空间往往十分巨大，因此存储和计算海森矩阵的逆是不现实的，这也是牛顿法无法在DNN中使用的重要原因。为了缓解这个问题，学术界提出了一些拟牛顿法如L-BFGS等试图去降低存储消耗，但是计算代价仍然很高。</p><p>从以上的分析可以看到：无论是Full-batchGD还是牛顿法，都存在计算消耗大等问题，不适用于深度学习任务的大规模数据集训练，因此已经很少被直接用在深度学习模型中。为了处理这些问题，学术界提出了很多替代的优化算法，因此接下来我将调研分析当前常用的深度学习优化算法(SGD/Adam...)的优缺点，并结合实例及前沿研究进行相关讨论。 ## PopularAlgorithms优化算法在神经网络的训练中有着举足轻重的作用，选择合适的优化算法可以使得损失函数收敛地更快，同时收敛到更好的区域。目前比较流行的算法有下面几种：### 1 SGD尝试用mini-batch的梯度平均值作为整体梯度的无偏估计，参数的更新非常简单，沿着梯度的反方向即是loss下降最快的方向：<span class="math display">\[x_{t+1}=x_t-\alpha\nabla f(x_t)\]</span> 如果是BatchGD并且学习率足够小时可以保证损失函数单调不增。实际使用时一般会采用学习率递减策略保证模型收敛。</p><p>实现也非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -= lr * grads</span><br></pre></td></tr></table></figure><p>SGD存在几个问题：</p><p>首先，如果loss对于不同参数的敏感程度不同，那么收敛过程会在敏感参数方向上抖动：<img src="https://img-blog.csdnimg.cn/20210710192205509.png" />对于非常大的参数空间，可能会收敛到不同的区域。其次，如果loss函数有局部最优或者鞍点，这些点上梯度为0，无法收敛到全局最优；最后，如果采用mini-batch，那么计算出的梯度值是有噪声的，意味着收敛过程可能会是非常曲折的，也即需要更多时间。### 2 SGD+Momentum为了解决SGD的问题，有学者提出了带有动量的SGD，其思想也很简单：更新参数时不仅考虑当前的梯度方向，还要考虑历史累积梯度方向，如果两者方向一致，那么这一步更新幅度就会增大；如果不一致，就会减弱沿当前梯度的下降幅度。<span class="math display">\[v_{t+1}=\rho v_t+\nabla f(x_t) \\x_{t+1}=x_t-\alpha v_{t+1}\]</span> <spanclass="math inline">\(\rho\)</span>可以看作是对历史梯度的衰减，一般取0.9。</p><p>带有动量的SGD实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = rho * v + grads</span><br><span class="line">x -= lr * v</span><br></pre></td></tr></table></figure> 这样就解决了SGD的三个问题：首先，由于历史梯度的存在，朝敏感方向步进的数量就会减少，会更加平滑的向最优点前进，减小了震荡，加速收敛；其次，对于局部最优点，虽然当前梯度为0，但是依靠历史梯度可以越过该点继续下降；最后，梯度噪声引起的震荡可以通过历史梯度互相抵消。 ### 3 NesterovMomentum NesterovMomentum由SGD+Momentum衍生而来，SGD+Momentum是将当前点的梯度和速度结合起来，而NesterovMomentum则是将当前点的速度和下一个近似点的梯度结合起来，意味着我们不是在当前位置去看未来，而是多看了一步，在稍远一些的下一步看未来，可以提前调整步进大小：<img src="https://img-blog.csdnimg.cn/20210710192712932.png"alt="在这里插入图片描述" /> 所以Nesterov Momentum的更新规则为： <spanclass="math display">\[v_{t+1}=\rho v_t-\alpha\nabla f(x_t+\rho v_t) \\x_{t+1}=x_t+v_{t+1}\]</span> 通常我们希望针对<spanclass="math inline">\(x_t\)</span>计算梯度，通过简单的变量替换，得到新的更新规则：<span class="math display">\[v_{t+1}=\rho v_t-\alpha\nabla f(x_t) \\x_{t+1}=x_t+v_{t+1}+\rho(v_{t+1}-v_t)\]</span> Nesterov的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v_prev = v</span><br><span class="line">v = rho * v - lr * grads</span><br><span class="line">x += (1 + rho) * v - rho * v_prev</span><br></pre></td></tr></table></figure> ### 4 AdaGrad前面的几种方法都是设置了一个全局的学习率，AdaGrad则通过引入二阶动量使得学习率可以针对<strong>每个参数</strong>自适应地取值：对于更新频繁的参数，已经有了很多认知，不希望因为单个样本影响太大，所以学习率可以小一些；对于更新稀疏的参数，希望从偶尔出现的能更新该参数的样本中多获得一些信息，所以学习率可以设置地大一些。为了了解参数更新的频繁程度，引入二阶动量——每个维度上历史梯度值的平方和：<span class="math display">\[grad\_squared +=\nabla^2 f(x_t) \\x_{t+1}=x_t-\cfrac{\alpha\nabla f(x_t)}{\sqrt{grad\_squared+10^{-7}}}\]</span> 此时的学习率实质上是<spanclass="math inline">\(\cfrac{\alpha}{\sqrt{grad\_squared}}\)</span>，为了避免除0，一般分母加上一个很小的平滑项。如果某个参数更新频繁，那么grad_squared就会增大，学习率也就越小。</p><p>AdaGrad的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grad_sq += grads**2</span><br><span class="line">x -= lr * grads / (numpy.sqrt(grad_sq) + eps)</span><br></pre></td></tr></table></figure>AdaGrad的问题在于随着grad_squared单调递增，学习率最终会单调衰减到0，意味着很可能会提早终止训练过程。### 5 RMSProp/AdaDelta为了缓解AdaGrad的学习率变化过于激进的问题，二阶动量的计算不累积全部的历史梯度，只关注过去某段时间内的梯度变化，用指数移动平均值来表示过去某时间段的二阶动量的均值：<span class="math display">\[grad\_squared=decay\_rate*grad\_squared+(1-decay\_rate)\nabla^2 f(x_t)\\x_{t+1}=x_t-\cfrac{\alpha\nabla f(x_t)}{\sqrt{grad\_squared+10^{-7}}}\]</span> decay_rate是一个超参数，一般取值0.9。</p><p>RMSProp的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grad_sq = decay * grad_sq + (1 - decay) * grads**2</span><br><span class="line">x -= lr * grads / (numpy.sqrt(grad_sq) + eps)</span><br></pre></td></tr></table></figure>因此，RMSProp仍然是通过梯度的大小来调整每个参数的学习率，不过现在学习率不会单调递减。</p><h3 id="adam">6 Adam</h3><p>Adam的出现是集成了一阶动量思想和AdaGrad等的二阶动量思想，即AdaptiveMomentum： <span class="math display">\[m_{t+1}=\beta_1m_t+(1-\beta_1)\nabla f(x_t)\\V_{t+1}=\beta_2V_t+(1-\beta_2)\nabla^2 f(x_t)\\x_{t+1}=x_t-\cfrac{\alpha m_{t+1}}{\sqrt{V_{t+1}+10^{-7}}}\]</span>由于m和V初始化为0，所以开始的几次迭代会偏向取值0，为了弥补这一缺点，又引入了偏差纠正项，完整的Adam算法如下：<span class="math display">\[m=\beta_1m+(1-\beta_1)\nabla f(x_t)\\m_t=\cfrac{m}{1-\beta_1^t}\\V=\beta_2V+(1-\beta_2)\nabla^2 f(x_t)\\V_t=\cfrac{V}{1-\beta_2^t}\\x_{t}=x_{t-1}-\cfrac{\alpha m_{t}}{\sqrt{V_{t}+10^{-7}}}\]</span> Adam的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = beta_1 * m + (1 - beta_1) * grads</span><br><span class="line">m_t = m / (1 - beta_1**t)</span><br><span class="line">v = beta_2 * v + (1 - beta_2) * grads**2</span><br><span class="line">v_t = v / (1 - beta_2**t)</span><br><span class="line">x -= lr * m_t / (numpy.sqrt(v_t) + eps)</span><br></pre></td></tr></table></figure>如果Adam再加上Nesterov的向后看一步的思想，就是Nadam算法。 ## Experiment为了对上述算法有更加直观的认识，同时在部分程度上比较不同算法的性能，构造一维函数<spanclass="math inline">\(f(x)\)</span>作为损失函数，其表达式如下： <spanclass="math display">\[f(x)=0.01x^2+sin(x)+\frac{1}{3}cos(3x)+\frac{1}{5}sin(5x)+\frac{1}{7}cos(7x)\]</span> 这个损失函数含有大量的局部最小点以及悬崖，如图所示： <imgsrc="https://img-blog.csdnimg.cn/2021071019313296.png"alt="在这里插入图片描述" />为了公平起见，比较时将x的初始值设为-29，每种算法的迭代次数均设置为300次，学习率均设置为0.1，迭代过程如下图所示：<img src="https://img-blog.csdnimg.cn/20210710193206336.png"alt="在这里插入图片描述" /> 最终的收敛结果如下表所示： | 算法 | 最终x |最终损失 | | -------- | ------ | -------- | | SGD | -27.98 | 7.19 | |Momentum | -24.00 | 6.21 | | Nesterov | -24.00 | 6.21 | | AdaGrad |-27.98 | 7.19 | | RMSProp | -28.95 | 9.10 | | Adam | -26.46 | 5.59 |</p><p>从上图和上表可以看到：Adam算法在前期收敛很快，并且最终效果最好，是综合性能最佳的算法；带动量的SGD能够越过一些局部极小值，在没有精细调参的情况下一度达到了和Adam类似的效果；AdaGrad开始时的梯度很大，但是由于学习率过早地减小，最终效果并不出众；这些结果进一步佐证了之前对各种算法的分析。</p><p>如果将学习率设置为0.01，对比如下： <imgsrc="https://img-blog.csdnimg.cn/20210710193256448.png"alt="在这里插入图片描述" />可以看到：精调后的Momentum、Nesterov和Adam的效果几乎不相上下，这只是初步调整了学习率参数，如果通过验证集更加精细地调整超参数的值，那么SGD+Momentum完全可以达到甚至超越Adam的表现，当然这也需要人为付出更多的努力，Adam这个烦恼则小得多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Sun Apr 11 18:31:58 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Jingtao Ren</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = tf.constant(<span class="number">3.0</span>)</span><br><span class="line">b = tf.constant(<span class="number">5.0</span>)</span><br><span class="line">c = tf.constant(<span class="number">7.0</span>)</span><br><span class="line">d = tf.constant(<span class="number">0.1</span>)</span><br><span class="line">x = tf.Variable(initial_value=-<span class="number">29.0</span>, name=<span class="string">&quot;x&quot;</span>, dtype=tf.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_f</span>():</span></span><br><span class="line">    x = np.linspace(-<span class="number">30</span>, <span class="number">30</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># y = -20.0 * np.exp(b * np.abs(x)) - np.exp(np.cos(c * x)) + 20.0 + np.exp(1)</span></span><br><span class="line">    y = (<span class="number">0.1</span> * x) ** <span class="number">2</span> + np.sin(x) + np.cos(a * x) / a + np.sin(b * x) / b + np.cos(c * x) / c</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Loss Function&#x27;</span>)</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_train</span>(<span class="params">y</span>):</span></span><br><span class="line">    x = np.arange(<span class="number">300</span>)</span><br><span class="line">    labels = [<span class="string">&#x27;SGD&#x27;</span>, <span class="string">&#x27;Momentum&#x27;</span>, <span class="string">&#x27;Nesterov&#x27;</span>, <span class="string">&#x27;AdaGrad&#x27;</span>, <span class="string">&#x27;RMSProp&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Iteration&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Algorithm Comparison&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):    </span><br><span class="line">        plt.plot(x, y[i], label=labels[i])</span><br><span class="line">        plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>():</span></span><br><span class="line">    <span class="comment"># y = a * tf.exp(b * tf.abs(x)) - tf.exp(tf.cos(c * x)) - a + tf.exp(tf.constant(1.0))</span></span><br><span class="line">    y = tf.<span class="built_in">pow</span>(d * x, <span class="number">2</span>) + tf.sin(x) + tf.cos(a * x) / a + tf.sin(b * x) / b + tf.cos(c * x) / c</span><br><span class="line">    <span class="keyword">return</span> (y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimize</span>(<span class="params">optimizer, iters = <span class="number">300</span></span>):</span></span><br><span class="line">    y = []</span><br><span class="line">    <span class="comment"># optimizer = tf.keras.optimizers.SGD(learning_rate=0.1)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tf.<span class="built_in">range</span>(iters):</span><br><span class="line">        optimizer.minimize(loss, [x])</span><br><span class="line">        y.append(loss())</span><br><span class="line">    tf.<span class="built_in">print</span>(<span class="string">&quot;Final x = &quot;</span>, x)</span><br><span class="line">    tf.<span class="built_in">print</span>(<span class="string">&quot;Final Loss = &quot;</span>, loss())</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># plot_f()</span></span><br><span class="line">    ops = [tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>), tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>, momentum=<span class="number">0.9</span>),</span><br><span class="line">           tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>, momentum=<span class="number">0.9</span>, nesterov=<span class="literal">True</span>), tf.keras.optimizers.Adagrad(learning_rate=<span class="number">0.1</span>),</span><br><span class="line">           tf.keras.optimizers.Adadelta(learning_rate=<span class="number">0.1</span>, rho=<span class="number">0.9</span>), tf.keras.optimizers.Adam(learning_rate=<span class="number">0.1</span>)]</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        x.assign(-<span class="number">29.0</span>)</span><br><span class="line">        y.append(minimize(ops[i]))</span><br><span class="line">    plot_train(y)</span><br></pre></td></tr></table></figure><p>当然，这个实验非常简单，损失函数形式是一维的，实际中的网络模型参数的数量可能达到百万级别，超高维情况下算法的效率、鲁棒性以及模型最终的泛化能力才是我们真正关心的。</p><p>最后贴2张神图总结下： <imgsrc="https://img-blog.csdnimg.cn/20210306203509952.gif#pic_center"alt="在这里插入图片描述" /><imgsrc="https://img-blog.csdnimg.cn/2021030620351970.gif#pic_center"alt="在这里插入图片描述" /> ## ResearchAdam虽然是集大成者，而且也被推荐为起始的默认优化算法，但是一些Paper揭示了Adam的一些问题。### 1 过拟合 Berkeley在NIPS2017的一篇文章指出：如果一个问题有多个全局极优，即使从相同的初始值出发，不同的优化算法也会得到完全不同的结果。文章构造了一个简单的线性可分的二分类问题，证明了SGD在这种情况下测试误差为0，而AdaGrad等自适应方法会把所有的测试样例分为正类，泛化能力极差，也就是根本不能工作。</p><p>随后作者又用VGG+BN+Dropout的网络结构在CIFAR-10数据集上进行了实验：<img src="https://img-blog.csdnimg.cn/20210710193712619.png"alt="在这里插入图片描述" />可以看到：前期训练中Adam有优势，但SGD的泛化能力确实比Adam要好。</p><p>最后，为了彻底黑化Adam，文章又用了文本数据集和一些NLP模型做了实验：<img src="https://img-blog.csdnimg.cn/20210710193823396.png"alt="在这里插入图片描述" />即便有时候自适应方法的训练loss会更低，但SGD的泛化能力都无一例外地胜过了自适应的方法。自适应方法在训练初期速度很快，但是后期表现平平。</p><p>泛化能力差的原因在于：自适应方法倾向于关注稀疏的特征，因为这些特征对于训练样例的鉴别是很有效的，尤其在训练样例数少而特征较多的数据集中，但是这些特征其实并非关键特征，这样自适应学习率算法出现过拟合的风险就会增大，导致泛化能力不佳，最终的收敛效果不如传统的SGD。### 2 二阶动量波动Google的一篇文章从数学上证明了在某些特定情况下Adam可能不收敛，因为二阶动量取的是某个时间窗口的变化，所以<spanclass="math inline">\(V_t\)</span>的变化可能会剧烈震荡，尤其在高维情况下，梯度的方差可能随时间波动很大，导致学习率震荡，模型无法收敛。这也是为什么一般<spanclass="math inline">\(\beta_2\)</span>要取0.999这么大的值，避免二阶动量有太大波动。</p><p>一般认为Adam默认的<span class="math inline">\(\beta_1\)</span>和<spanclass="math inline">\(\beta_2\)</span>不需要调整，采用默认的0.9和0.999即可。但是这两个超参如果不按这样设置，Adam可能永远不会收敛到最优值。文章从数学上证明了对任意的<spanclass="math inline">\(\beta_1,\beta_2\in[0,1),\beta_1&lt;\sqrt{\beta_2}\)</span>，都存在一个随机的凸优化问题使得Adam不能收敛到最优解。</p><p>为了避免二阶动量的剧烈震荡，文章对其进行了控制，提出了一个新算法AMSGrad确保模型收敛，<spanclass="math inline">\(V_t=max(V_{t-1},\beta_2V_{t-1}+(1-\beta_2)\nabla^2f(x_t))\)</span>。</p><p>作者随后通过人造数据和真实数据进行了实验：</p><p>人造数据上的结果： <imgsrc="https://img-blog.csdnimg.cn/20210710193934596.png"alt="在这里插入图片描述" />很显然在Adam没有找到最优解的这些数据上，改进后的算法都表现良好。</p><p>在MNIST上的效果： <imgsrc="https://img-blog.csdnimg.cn/20210710193956571.png"alt="在这里插入图片描述" />这篇文章最终获得了2018年ICLR最佳论文，但是引起了很大争议。主要原因在于其构造的令Adam失效的数据在实际情况中出现的概率极低，即使出现也会在数据预处理时被筛掉，因此并没有特别广泛的实际用处。另外，文章过于强调训练集上的损失函数值，甚至有人通过复现表明文章提出的AMSGrad算法在测试数据上表现很差，与原文中的某些结论相互矛盾。### 3 学习率下降arXiv上的一篇文章通过在CIFAR-10上的实验证明Adam在一些情况下虽然速度快，但收敛效果没有SGD好：<img src="https://img-blog.csdnimg.cn/20210710194231292.png"alt="在这里插入图片描述" />文章通过实验发现主要原因在于后期Adam的学习率过低，影响了最终效果。文章尝试通过控制学习率下界，提高了最终收敛效果。</p><p>既然Adam后期有问题，那么一个自然的改进就是前期训练使用Adam，用来快速减小loss；后期训练转换为SGD，用稍慢的速度寻找更佳的解甚至是最优解。但是这样也会引入新的问题：在什么时刻切换？切换为SGD后的学习率又该如何设置？</p><p>文章提出了SWATS(Switches from Adam toSGD)策略来解决上面2个问题，在CIFAR-10和CIFAR-100数据集上实验效果看着还不错：<img src="https://img-blog.csdnimg.cn/20210710194309531.png"alt="在这里插入图片描述" /> <imgsrc="https://img-blog.csdnimg.cn/20210710194329636.png"alt="在这里插入图片描述" />这些文章都采用了一些比较极端的数据去探索Adam的不适情况，然而实际中遇到这些极端情况的概率并不大，因此Adam并不失为首选尝试。通过上面的讨论可以看到：SGD和Adam各有优劣，精调后的SGD一般最终会收敛到更好的效果；Adam在训练前期收敛速度快，在稀疏数据上表现更好，对超参不敏感，不需要十分精细的调参。</p><p>如果对优化算法不熟悉，可以先尝试SGD+NesterovMomentum或者Adam；如果对某个优化算法很精通，那么调参就会相对容易些。如果资源足够，也可以尝试L-BFGS等二阶优化方法。另外，选择之前要充分了解数据的性质，对于比较稀疏的数据可以优先尝试学习率自适应调整的算法。</p><h2 id="reference">Reference</h2><p>[1] CS231n: Convolutional Neural Networks for Visual Recognition.lecture 8, Stanford University.<br />[2] The Marginal Value of Adaptive Gradient Methods in Machine Learning.NIPS'17<br />[3] On the Convergence of Adam and Beyond. ICLR'18<br />[4] Improving Generalization Performance by Switching from Adam to SGD.arXiv<br />[5] Optimization methods for large-scale machine learning. SIAM Review,2018.<br />[6] Optimization for deep learning: theory and algorithms. arXiv,2019.<br />[7] Understanding Black-box Predictions via Influence Functions.ICML'17.<br />[8] Understanding Deep Learning Requires Rethinking Generalization.ICLR'17.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradient Boosting</title>
      <link href="/posts/gradient-boosting/"/>
      <url>/posts/gradient-boosting/</url>
      
        <content type="html"><![CDATA[<h2 id="gradient-boosting-regression">Gradient Boosting Regression</h2><h2 id="gradient-boosting-classification">Gradient BoostingClassification</h2><h2 id="xgboost">XGBoost</h2><h2 id="决策树集成">决策树集成</h2><p>集成学习可以组合多个基学习器，产生更加优异的性能。将决策树（如CART）作为基学习器，结合每个基学习器的预测结果作为最终输出，就像<ahref="https://xgboost.readthedocs.io/en/latest/tutorials/model.html">下图</a>这样：<img src="https://img-blog.csdnimg.cn/2021061621501811.png"alt="在这里插入图片描述" /> 正式一些的表示： <spanclass="math display">\[\hat{y}_i = \sum_{k=1}^K f_k(x_i), f_k \in\mathcal{F}\]</span> 其中，<spanclass="math inline">\(K\)</span>是决策树个数，<spanclass="math inline">\(f_k(x_i)\)</span>表示第<spanclass="math inline">\(k\)</span>个决策树的预测值。</p><p>为了定量描述模型参数与训练数据的匹配程度，我们还要定义待优化的目标函数：<span class="math display">\[\text{obj}(\theta) = \sum_i^n l(y_i,\hat{y}_i) + \sum_{k=1}^K \Omega(f_k)\]</span> ## Boosting Decision Tree集成多棵树的方式可以是Bagging，也可以是Boosting。Boosting的motivation是用一棵新树不断拟合当前的集成模型与真实值的残差，拟合后将该树也加入模型中，即所谓的AdditiveTraining： <span class="math display">\[\hat{y}_i^{(0)} = 0\\\hat{y}_i^{(1)} = f_1(x_i) = \hat{y}_i^{(0)} + f_1(x_i)\\\hat{y}_i^{(2)} = f_1(x_i) + f_2(x_i)= \hat{y}_i^{(1)} + f_2(x_i)\\\dots\\\hat{y}_i^{(t)} = \sum_{k=1}^t f_k(x_i)= \hat{y}_i^{(t-1)} +f_t(x_i)\]</span> 好了，接下来的问题就是每次迭代时的那棵新树<spanclass="math inline">\(f_t\)</span>要怎么训练呢？一个直观的想法就是选择那棵令目标函数最小的树：<span class="math display">\[\text{obj}^{(t)} = \sum_{i=1}^n l(y_i,\hat{y}_i^{(t)}) + \sum_{i=1}^t\Omega(f_i) \\          = \sum_{i=1}^n l(y_i, \hat{y}_i^{(t-1)} + f_t(x_i)) +\Omega(f_t) + \mathrm{constant}\]</span>我们先选择MSE作为损失函数，看看会发生什么： <spanclass="math display">\[{obj}^{(t)} = \sum_{i=1}^n (y_i -(\hat{y}_i^{(t-1)} + f_t(x_i)))^2 + \sum_{i=1}^t\Omega(f_i) \\          = \sum_{i=1}^n [2(\hat{y}_i^{(t-1)} - y_i)f_t(x_i) +f_t(x_i)^2] + \Omega(f_t) + \mathrm{constant}\]</span>虽然MSE的形式比较友好，但是如果选择其它损失函数就很难有上式那般人性了，吃得太饱的同学可以试试logisticloss： <span class="math display">\[L(\theta) = \sum_i[ y_i\ln(1+e^{-\hat{y}_i}) + (1-y_i)\ln (1+e^{\hat{y}_i})]\]</span>为了增强可扩展性、便于计算，一般采用损失函数的二阶泰勒展开去做一个近似：<span class="math display">\[\text{obj}^{(t)} = \sum_{i=1}^n [l(y_i,\hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i)] +\Omega(f_t) + \mathrm{constant}\]</span> 其中，<spanclass="math inline">\(g_i = \partial_{\hat{y}_i^{(t-1)}} l(y_i,\hat{y}_i^{(t-1)}),h_i = \partial_{\hat{y}_i^{(t-1)}}^2 l(y_i,\hat{y}_i^{(t-1)})\)</span>。 扔掉所有常数项，就得到了第<spanclass="math inline">\(t\)</span>步的目标函数： <spanclass="math display">\[\sum_{i=1}^n [g_i f_t(x_i) + \frac{1}{2} h_if_t^2(x_i)] + \Omega(f_t)\]</span></p><p>弄完了training loss，接着还得研究下正则项<spanclass="math inline">\(\Omega(f_t)\)</span>，首先得给<spanclass="math inline">\(f(x)\)</span>来一个正式点的定义： <spanclass="math display">\[f_t(x) = w_{q(x)}, w \in R^T, q:R^d\rightarrow\{1,2,\cdots,T\} .\]</span> 其中，<spanclass="math inline">\(w\)</span>是叶子结点的得分向量，<spanclass="math inline">\(q\)</span>是将样本点映射到对应叶子的函数，<spanclass="math inline">\(T\)</span>是叶子数目。如果有点抽象，就看看上图中的左子图吧：<spanclass="math inline">\(w=[2,-1],f(男孩)=w_{q(男孩)}=w_0=2\)</span>。</p><p>模型复杂度的具体定义随你了，XGBoost是这么定义的： <spanclass="math display">\[\Omega(f) = \gamma T + \frac{1}{2}\lambda\sum_{j=1}^T w_j^2\]</span> 就用上式重新写出我们第<spanclass="math inline">\(t\)</span>步的目标函数： <spanclass="math display">\[\text{obj}^{(t)} \approx \sum_{i=1}^n [g_iw_{q(x_i)} + \frac{1}{2} h_i w_{q(x_i)}^2] + \gamma T +\frac{1}{2}\lambda \sum_{j=1}^T w_j^2\\= \sum^T_{j=1} [(\sum_{i\in I_j} g_i) w_j + \frac{1}{2} (\sum_{i\in I_j}h_i + \lambda) w_j^2 ] + \gamma T\]</span> 其中，<spanclass="math inline">\(I_j = \{i|q(x_i)=j\}\)</span>表示第<spanclass="math inline">\(j\)</span>个叶子中样本点的索引集合，由于任意一个叶子中样本点得分相同，因此上式写成了对<spanclass="math inline">\(T\)</span>个叶子的求和。</p><p>令<span class="math inline">\(G_j = \sum_{i\in I_j}g_i\)</span>及<span class="math inline">\(H_j = \sum_{i\in I_j}h_i\)</span>，就有了一个相对简洁的表示： <spanclass="math display">\[\text{obj}^{(t)} = \sum^T_{j=1} [G_jw_j +\frac{1}{2} (H_j+\lambda) w_j^2] +\gamma T\]</span>因为叶子之间相互独立，所以令目标函数最优的得分向量<spanclass="math inline">\(w\)</span>为： <spanclass="math display">\[w_j^\ast = -\frac{G_j}{H_j+\lambda}\\\text{obj}^\ast = -\frac{1}{2} \sum_{j=1}^T \frac{G_j^2}{H_j+\lambda} +\gamma T\]</span> 目标函数<spanclass="math inline">\(obj^*\)</span>的值衡量着本次迭代树结构<spanclass="math inline">\(q(x)\)</span>对训练数据的拟合程度。</p><p>云里雾里一大堆，我都烦了，来看个例子： <imgsrc="https://img-blog.csdnimg.cn/2021061716123725.png"alt="在这里插入图片描述" /> 假设在第<spanclass="math inline">\(t\)</span>次迭代选了这么一棵树，按照if-then规则将训练样本分到相应的叶子，将梯度信息相加得到每个叶子对应的<spanclass="math inline">\(G,H\)</span>，接着用<spanclass="math inline">\(obj^*\)</span>计算这棵树最小的损失，不行就换一种树结构，以求减小<spanclass="math inline">\(obj^*\)</span>。</p><p>忙活了大半天，终于知道了怎么度量一棵树的好坏。那么只要枚举所有可能的树结构，选那个令<spanclass="math inline">\(obj^*\)</span>最小的就好了。傻子都知道这是不行滴，所以只能贪心地一层一层地剥开你的心...哦不对，一层一层地优化：将结点分类为左孩子和右孩子的得分增益为：<span class="math display">\[Gain = \frac{1}{2}\left[\frac{G_L^2}{H_L+\lambda}+\frac{G_R^2}{H_R+\lambda}-\frac{(G_L+G_R)^2}{H_L+H_R+\lambda}\right]- \gamma\]</span>其中，第一/二项分别表示左/右孩子的分数，第三项表示原始节点的分数，最后一项表示增加叶子的惩罚。可以看到：如果分裂后的得分增益小于<spanclass="math inline">\(\gamma\)</span>，就不要继续分了，凑合过吧...</p><p>为了在每层获取到最佳的分裂点，通常先将训练数据排个序： <imgsrc="https://img-blog.csdnimg.cn/20210617164041605.png"alt="在这里插入图片描述" /> 暴力枚举一遍分裂点找最优就可以啦！</p><ul><li><span class="math inline">\(f_0(x)=0\)</span></li><li>对于第m棵树的训练：<ul><li>首先计算每条训练数据的残差：<spanclass="math inline">\(r_{mi}=y_i-f_{m-1}(x_i),i=1,2...,N\)</span></li><li>接着通过拟合上面得到的残差数据，训练出回归树<spanclass="math inline">\(T_m(x)\)</span></li><li>此时第m棵树的输出即为<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+T_m(x)\)</span></li></ul></li><li>进行M次训练后得到最终的模型</li></ul><p>可以看到：Boosting DecisionTree每次迭代都将上一轮预测结果的残差作为当前的训练集，对于平方损失容易求得损失函数最小值的点，但是对于稍复杂的损失函数，残差的获得就只能通过负梯度<spanclass="math inline">\(\frac{\partialL(y_i,f(x_i))}{f(x_i)}\)</span>去逼近，这就是GBDT的核心思想。GBDT的训练与Boosting Decision Tree很相似：</p><ul><li>初始化弱学习器<span class="math inline">\(f_0(x)=\underset{c}{arg\min}\sum_{i=1}^{N}L(y_i,c)\)</span>，如果损失函数是MSE，那么<spanclass="math inline">\(f_0(x)=\frac{1}{N}\sum_{i=1}^{N}y_i\)</span></li><li>对于第m棵树的训练：<ul><li>计算负梯度：<span class="math inline">\(r_{mi}=-\frac{\partialL(y_i,f(x_i))}{\partial f(x_i)},f(x)=f_{m-1}(x)\)</span></li><li>得到新的训练集<spanclass="math inline">\((x_i,r_{mi})\)</span>，训练产生一棵新的回归树，对应的叶子结点域为<spanclass="math inline">\(R_{mj},j=1,...,J\)</span>，<spanclass="math inline">\(J\)</span>为叶子结点个数</li><li>对第j个叶子结点，计算最佳拟合值：<spanclass="math inline">\(c_{mj}=\underset{c}{arg\ min}\sum_{x_i\inR_{mj}}L(y_i,f_{m-1}(x_i)+c)\)</span></li><li>更新强学习器：<spanclass="math inline">\(f_m(x)=f_{m-1}(x)+\sum_{i=1}^{J}c_{mj}I(x\inR_{mj})\)</span></li></ul></li><li>最终的学习器为：<span class="math inline">\(\hatf(x)=f_M(x)=f_0(x)+\sum_{m=1}^{M}\sum_{j=1}^{J}c_{mj}I(x\inR_{mj})\)</span></li></ul><h2 id="implementation">Implementation</h2><h2 id="properties">Properties</h2><ol type="1"><li>extrapolate问题<br />众所周知随机森林回归是不具备推理能力的，那么XGBoost可以吗？<br />答案是可以，因为梯度提升模型并不直接根据训练集的结果做预测，而是通过一系列树的加和得到，加和结果取决于每棵树的权重，权重则是由损失函数的一二阶梯度优化得来，并不依赖于训练集的上下限。</li><li>缺失值问题<br />GBDT/GBRT自身不支持缺失值的自动填充，例如使用sklearn中的GradientBoostingRegressor在训练数据包含缺失值时将无法训练，人工填充可能会引入偏差，但是XGBoost却可以自动地处理缺失值（但并不是填充）。<br />根据陈天奇大佬的说法：</li></ol><blockquote><p>Internally, XGBoost will automatically learn what is the bestdirection to go when a value is missing. Equivalently, this can beviewed as automatically "learn" what is the best imputation value formissing values based on reduction on training loss.</p></blockquote><p>那么究竟是如何自动学习最佳的分裂方向呢？<br />假设在结点A有50条训练样本，并且该结点只有一个可能的分割点：比如只有一个二元特征x，那么分割点就只有该特征取值为0或1，这样训练数据可以被分为3组：</p><ol type="1"><li>x取值为B的20条样例</li><li>x取值为C的20条样例</li><li>x缺失的10条样例，叫做M组</li></ol><p>那么M组的样例会被分别赋到B和C，接着计算<spanclass="math inline">\(\{(B,M),C\}\)</span>和<spanclass="math inline">\(\{B,(C,M)\}\)</span>的得分及损失函数衰减，两者中选择损失函数衰减大的。<br />如果使用MSE作为损失函数，并且B的标签均值为5，C的标签均值为10，M的标签均值为0。<br />如果使用<span class="math inline">\(\{(B,M),C\}\)</span>：<spanclass="math inline">\(\frac{|M|}{|B| + |M|}\text{mean}(M) +\frac{|B|}{|M|+|B|}\text{mean}(B) = \frac{10}{30}0 + \frac{20}{30}5 =3.\overline{3}\)</span><br />如果使用<span class="math inline">\(\{B,(C,M)\}\)</span>：<spanclass="math inline">\(\frac{|M|}{|C| + |M|}\text{mean}(M) +\frac{|C|}{|M|+|C|}\text{mean}(C) = \frac{10}{30}0 + \frac{20}{30}10 =6.\overline{3}\)</span><br />最后计算两者的MSE与划分前MSE的差，选择使得MSE下降更快的作为分裂方向（也就是得分gain更大的方向）。</p><p>在寻找最优特征分裂点（如年龄＜20还是年龄＜30）时，只访问该特征不含缺失值的训练样例，即如果年龄缺失，就不参与20和30的决策，这样计算复杂度也就降低了，尤其是对于稀疏数据。</p><p>预测时的缺失值有２种情况： 1.训练阶段已经见识过该缺失值了：按照训练时选定的方向往下走就行 2.训练阶段该特征没有缺失：默认走向右子树。</p><p>Ref里还有一个更加全面的例子，训练集有6个小孩，只有一个特征年龄（其中有2个样例年龄缺失），标签是身高，初始预测值为0.5，接下来每棵树都要拟合残差。</p><table><thead><tr><th>Age</th><th>Height</th><th>Res</th></tr></thead><tbody><tr><td>7</td><td>130</td><td>－129.5</td></tr><tr><td>9</td><td>148</td><td>－147.5</td></tr><tr><td>6</td><td>115</td><td>－114.5</td></tr><tr><td>15</td><td>164</td><td>－163.5</td></tr><tr><td>？</td><td>125</td><td>－124.5</td></tr><tr><td>？</td><td>140</td><td>－139.5</td></tr></tbody></table><p>接着要根据年龄特征寻找最优的分裂点，将年龄排序并选择中点（<strong>注意：这里就不考虑缺失值样例了</strong>），因此候选分裂点有6.5，8，12，对于每个候选点，分别计算将缺失样例划到左子树和右子树的Quality/SimilarityScore：</p><p><span class="math display">\[Quality\ Score=\frac{(\sum residuals)^2}{\#residuals + \lambda}\]</span></p><p>比如，对于分裂点6.5：<br />如果划到左子树： <span class="math display">\[Gain＝划分后的Quality\ Score－划分前的Quality\ Score \\＝\frac{(-114.5-124.5-139.5)^2}{3} + \frac{(-129.5-147.5-163.5)^2}{3} -\frac{(-129.5-147.5-114.5-163.5-124.5-139.5)^2}{6}=640.7\]</span><br />如果划到右子树：<span class="math inline">\(Gain＝划分后的Quality\Score－划分前的Quality\ Score＝580.8\)</span></p><p>接着对于8：1083；630.8<br />对于12：874.8；216<br />从中选择gain最大的（也就是使得损失函数最小的），分裂点选8，缺失值划到左子树。</p><h2 id="bug">Bug</h2><p><a href="https://www.lycecho.com/archives/2364">PYTHON XGBOOST 报错KEYERROR: ‘BASE_SCORE’</a></p><h2 id="references">References</h2><p><ahref="https://www.youtube.com/watch?v=3CC4N4z3GJc"><strong>GradientBoost</strong></a><br /><ahref="https://xgboost.readthedocs.io/en/latest/tutorials/model.html">Introductionto Boosted Trees</a><br /><ahref="https://datascience.stackexchange.com/questions/15305/how-does-xgboost-learn-what-are-the-inputs-for-missing-values">Missingvalues in XGBoost</a><br /><ahref="https://stats.stackexchange.com/questions/304962/is-is-possible-for-a-gradient-boosting-regression-to-predict-values-outside-of-t">Isis possible for a gradient boosting regression to predict values outsideof the range seen in its training data?</a><br /><ahref="https://datascience.stackexchange.com/questions/77234/can-boosted-trees-predict-below-the-minimum-value-of-the-training-label">CanBoosted Trees predict below the minimum value of the traininglabel?</a><br /><ahref="https://github.com/dmlc/xgboost/issues/1581#issuecomment-249853718">Whydoes XGBoost regression predict completely unseen values?</a><br /><ahref="https://medium.com/hypatai/how-xgboost-handles-sparsities-arising-from-of-missing-data-with-an-example-90ce8e4ba9ca">HowXGBoost Handles Sparsities Arising From of Missing Data? (With anExample)</a><br /><a href="https://www.youtube.com/watch?v=OtD8wVaFm6E"><strong>XGBoostRegression</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learn to Learn</title>
      <link href="/posts/learn-to-learn/"/>
      <url>/posts/learn-to-learn/</url>
      
        <content type="html"><![CDATA[<p>上了十几年学，依然不会学习。不知是因为中学一些糟糕习惯的延续，还是当代知识难度的加深，我总是感受到日常学习的辛苦：身体累、脑子累、心也累。</p><p>刻苦的确是一种很好的品质，但这种品质有些时候未免有些夸大其词了。傻傻地机械地重复在中学时代那种应试环境或许可以带来一些成绩的提升，但是显然已经不适应现在的我。我尝试将每天安排得满满当当，恨不得每一分每一秒都在学习，然而效果却并不如人意。</p><p>除了智力等一些先天因素外，我个人觉得有以下几点问题：</p><ol type="1"><li>没有找到合适的学习方法，缺乏深度思考和知识体系。我总是试图单点单点地掌握未知的知识点，试图掌握每一处细节，甚至使用死记硬背的方式处理核心问题。笔记和博客也多是摘抄型，独立理解实现太少。</li><li>效率低下。尽管学习时长可能足够，但是且不说大多时间都在摸鱼，即使纯粹学习时间也经常犯困，无法专注完成手头的某项任务，总是过于频繁地切换，某段时间总想做好多件事。效率*时长=最终效果自然不会很好。</li><li>单打独斗。周围少有一起交流进步的伙伴，遇到问题只能单向地从互联网获取信息，没法通过讨论等形式取得快速进步。</li></ol><p>最近看了Marty Lobdell的一个演讲Study Less, Study Smart(<ahref="https://www.youtube.com/watch?v=IlU-zDU6aQ0">YouTube</a>/<ahref="https://www.bilibili.com/video/BV1Pz4y1f7oi">B站</a>)，有些启发，但是如何学习这种事是绝没有普适准则的，只能结合自身实际摸索总结。Marty还写了一本同名的书，内容比演讲稍微细化一些。</p><p>Marty认为比较重要的有：</p><ol type="1"><li>番茄工作法。每学习25~30min应该休息5min，可以听一首音乐、出去上个厕所、吃点喝点、回消息等等，这样再次回来后注意力和效率又会回升到一个较高的水平，而非效率指数级下降的持续长时间学习。完成一天的工作后，对自己进行更丰厚一些的奖励，比如看个电影、吃顿大餐等等，以形成正反馈。</li><li>寻找一个专门的学习地点，书桌是用来学习的，床是用来睡觉的。Intend tolearn rather than incidental learn.</li><li>费曼学习法。看完材料后，深加工以后尝试用自己的话复述给别人听，能准确复述或者能把别人讲懂才行。</li><li>对于学习材料要SQ4R(Survey, Question, Read, Record, Recite,Review)，要主动理解思考自己的笔记，产生更加深刻的认识，而非机械地摘抄背诵。</li><li>高质量睡眠、高质量运动。</li></ol><p>结合自身缺点和学科特点，我认为可以有以下改进措施：</p><ol type="1"><li>每学习一个新东西，理解算法流程、数学推导、实现细节等确实重要，但更重要的是领会方法的思想动机，掌握优缺点和应用场景，将其纳入知识体系中，也就是所谓的“解决现实问题的能力”。</li><li>合理安排学习计划，劳逸结合。不要安排得过于紧密，也不要过于松散。制定的目标不能模棱两可，要有可评估性，即某段时间里要扎扎实实做完TODOLIST上的某件事。</li><li>组队学习，提出自己的问题，解答别人的问题。</li><li>累了就休息，不要在低效率状态下学习工作。</li><li>科研，自学和生活尽量分离，一段时间只做一件事就不错了，不然会非常拧巴，非常累</li></ol>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生永远艰难</title>
      <link href="/posts/life-always-hard/"/>
      <url>/posts/life-always-hard/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="985d58f261c31bf15f199072867f2126ad11de87c9f76e0ef1183f314ccb9362">c172f4ee74b2b6d246b20cbfdc0b877e38d8a34e1cf0769d6fb32347a9e58283214dc7e19e6e1b5ac3814e48185c91163e9e02153bdba3445cab5142f6f4ed0ac5a17fa873d23daf631dd0bb2e708a9be0c2b65e291c5d78278ae85e1e871c82e3e279b6c6d0a8d1846a9273b6a5a2ea53b6b3113fecddbbc42a031e35d4aa4c0a534d078e7255e0e73abf79c7cf854ae2a7c1d117d0321a3d33aaf88bb661472b1c4fff419f3c28678469d34fb7fbd599838dbf0e81bbc9d9bae9b1a34b7bc4b734e60bf8544013a2807e015edbf332d4fa6891deae9f1a76813713e85070b98976a4e33f7216d253d37aee2b1b9fe1147d3a38e0bfe173bb6afc6babc27039e50179a09dad9791510dad8ae5c7409ebb5e65aee9eb9a5b6fb96de3b2627013e56ee709f69c4a6f0ea0ef01c9b9c19c3efcfdb579e95da0fc452f6bd676f16dd5e7af825aa0aeb4b4172b0678f6ec1564935c96f38e1cebc42c46eb4bd7975e202d74d5350550cd93b79bc212e517925fc0dc31f947cc931b055d84758ab3f76b439878bf5f44d316cc04d687fde36efe891e248bb0f04c658788f2bef70287776d9007c8b02a0b45defea43917c7e90ee0fb8efaa8eaf1a517a0feea573391c3efb3f2b24a5857af757ab99e9c392512c10ae7a49939f4119b435e8bc64961722b3318e8d95a26394dd206aebe66f206db0cd39d4d6f5abeab01c0443397748ef4a7dd5ec35cf56a4f230edf74deb006ec2d811f844e478ba217b452f677d5fe61bdae5ac85ec483538efca6523d2aeb668cbd8162a60e0525e8cc901bfd57e9ccb6a13d2883581617fca857de91de7340be519fba3cab7a61879768e39e2e88aa59c2335464f9737d85128a566d6d2dfd92b1e8e3d3c19bdd5f682af716ab39139255feba7b5332a4cf6fdcaadcaa6dccaf59cd3befd1b8bf6ad4558b83916f243f8391059ef23275554b4253602c567618fad58b2d85ff078574e0475f0dc5aa41d9c25cb6db9bcb06988818ffdb46a6e697bf28e0691667815465f69f04e47cea12c8179a1296548fbbadef54b4992060d7c61a75e75f22b902679d2f6c517d41b27643e0306252f48ce0b370ce1e61b4cd4c6237c276a197cd1a0bf2076438f56b93ab5c30688a778012330eb79c027cc52091cdafe233d2a19541150130932ea134e79ea63537266a75d518bd76bb510168fd582bfab6fec63eac140e91f794f3f32ef8edff64b9385a53f994a7ea8d6e3e7074706c4d3160d7d5129990ef6991b0ab2a9c5e3b61ee1d78dd59cd2008cfc59d1ceb55dd330f2817618418772884b259e28ac54dc4714a4e475a48f23736e260660fd64dea7b7822c20ee61f9287a00205540f2eec78948290926ecb7261a7ee4a5f746435566e6f334cd9901fc3cb9196cbad02dd5534df7e6970cb58f5e629f285b0556c5e247e1a51fa56c93b7b912c2eb175092e006df574fee156816f1aa2725a558a87c5ac029fa771cac97c2446414e4f19eee9de54a41931885efec5b4c408ef669685491c13ea1ad6440b0cf9793b7d4e98553857a3c82bf429836065140dae094ad56e1823131ed232596619bd7a489385e2443dad82107fdd89d9c91b3e0ea71f641bda32705e4aebefab352e21bbf4cf651f1ed15e2abd9660103c8a44b9198ab11693cb472065630a697ea13629f859cb2a6fbd4bf909f109abce03dfa5c1cca4d9c2217755133912916d50dd2181710257f657c58d2a2d4522a5b5aa2acc30a128cbaefc216f082ed005135c44643bb0158f6d45e17ba2bd471bab2e8a355f08efb7ab3029b43e8fca366dc0898529f1b47af522a28a9b8d99875f0ff6462e3a69b13f87896b19f22ff2511f9f412de2716b98c40b5d49406467e66ac8b4bdac59db945b4134d1cdbcf6b971e83adfa6a539e91dadf1141c0ec78b5ad6187cbe319f8f48999695d24b9353b8b3fa874528757cfd5672e7f257b5258c33633ccd0aa462c208b7a2fc8f0202fcc1e47f5a44bb8c1f3f52bc791af61fa0f2ef0ec4fd4f27ad52cb104e70c4d0533f2fa88b9b40a8cc63ad6ad589fd1c86a18622c7b974647ff7d758607035893c77ae150be293d3a2d253adca6fa6baac96469bba5a1ea67448fe77c422cb5c6754db993e6f9d4692232de749c1d31e0c892796ab875a672a4796d454e3a41a8d4b3b90d5a8a00db464f831d6502eeca72cd0b372284b445f64e52958362565fe6442ac019c7950ebfb6b75c98dafac69c80f2c8c2dae93940278ac617f4779b5e44e645d0278ad72f72de7934698c611f2872962ea32207d93c76b0d2d850d4fc65ddd8744d1b52a0dc6c23b60bbcdc745c9c637cb41bacb8c5e5461f54da42f77d9d2e44fa59280f0ad31ecd6f1e9bac5a71a5b1154ec4788c5b7f3b2a67d8757fff949755616d02cbfaf2d2b20454ee9c2c33be5fee332b9750ea465c753abf1f8ed6764da93ca3e405fb572e60fa2d31526ffe5ee4eb41cc60a85c8ef81db62e9c5b9d06fd89541a576a26043cf08173cedf0310f585c6ceb2d454ec7a7af377242bc27050810528d6684ffc2efe330bdbbdc784521133a3840ed530cd5e377c286e8bd7e3b4f96bae601add45dde17d948c3944e89814a5be6140852adb5f7d83eb463baadab9a2478074f2be326e668257ac92f4207a6218a6e955370f4f41a290c6ae38b35ec206702e7068ad4680f60198491cc812ed67805c08143928132e714ab44b719581f641dbd7dc12d51d90c370f6dfc8dd4c8151c2d6a8a56536468c86adb1345c9920342ae3b837ef28916569cb416b363e035ca89f8aa532337340beaa1580407277175ef6cdb983991e3b54b1da99aaa215de1860f46ec9d12b229cfd06f5bb423b15d04b06859f650ecd41fb99139a6e61c9b963731a16f0417abffff1805f14ebd6aa17362e1e899521ca8ff06bdaced6b8dc4c52cf629ebf81a0813beac5d1014b178848c29234674b047324d464d030defacb8bf38a89610fc7c54081488a23dc795d46af5f707971866f0e714ac50c7cd6c78cf5e1ac1f36cd6e43fcdfa550862368c3c722f48dac5d037ebedd179ba5d0828deb3c1ffc1465f5a7beb4bda5194b9aa91274ec6d76be1d9c32cb2f9e628260c6a4d2d930effb260f4715f9ea633177e190a91047a00e89a79480346fc751615fbe2ee2f7f99b50961ec632c1ff8851d52d157f6cd0551b318a6d36afdec8f3f96c31c6c37f0ae330b5a25e40628a845adb53577240792b9c3b154088d2a7c08ddf5ca4ca163ef86aeb6fb6ee06dbb9d3d8c3de0ffd64ba7fd5a775b67040f8d4b5fbb890296aae7618af31d6face79ab15fc37da68542806826bc0c22997b99c47a52569c5d1126199a8c491a23a6a8eb33e27518a564afe1229c8e779b2389f8d34bc2e42092bc134521ca7a32cba862b2df4b5d77275d4410ecf10e691699e5566b60a72a272b65c9ba9138a301eecdd895a8ce5451fe9b67f9be21eb4ffe064b727d5eec4d5d744010c6281997fda79d1ba9a921d1aa21ad9e23721675616e40070a33a3af97a81acba00a29845c375291f50237e79ce8916537bfac515b861cd20d1ef5e6aff80cc299ab3781998fdc30f1b5ff2dd358bc21b1e844e06151584e4bd81aacf984ed7a1415b1fd9189490c30cde8be2bea4efa289f26450e58d4b7e9990ff9f41522c78734be28961e9ac3343cb1e712098ac9c635c32108e12b59dd26b0f68502a0651a6365dfa292e894a8cc17128b276723d62878e180f578fc9f65723c9db67c01990b8693cf8041b4ff04d340ea3eafbff2146a609c4f2221701e2dc61f1e5484954454f3147c3b5287f29db5b1543f9bd3a6953373a738d99ab153047d827cc3879940e5bc11d0047f36bc75a33421bbd20c5b74730f5b0b89d7523f03d73d49bab9a09def6dbedb3f9d7f5b6e22931104ba2ca57660862f2ec618fc9d57ea37e97062c4df19a4a69dafa2742cf636db43ac208ae26df2dc78afb3a7e47f63ee5d56c5cc13ac21e6547255b6031d15c92b429f94f3e09b80f07adff913e59c0da23ce89b62f57fce2f7d471c92ff4a864cdb4da7b7c2bc9309f95d404e7ffcf6bbe4b778c8ca5dcd14fdd5268d998909ea1c6e44f8fd3eb0891d812ad1214ebe46effc96e69efaa531998a0ac18323fbea251bbc1f6b272c96fb1fa4de4eec4ab9fd69426184184f4353f2e13051020fe20f93b09af0f58892d167a9f299c2a117ddeff5b4d19e34b83ab568b8c0f5a38c0bf2ae89be1ca9e1d9c29f7a4dab8a032e19ccf1132fb8498350742fa747a9dd00e49153dfe90fd731bf2ca25694491789904aae4437fcbae9eb3bc0e51dc22efd8f96749414760c70f5761c74aeb5f81921680572aeca85d9c5f12388e461104d1a8cdc60c52c99590840af8a20d77ddab3a2ceb94b4db426789cbe6a13e752c8bf8ab54cfb69418cc4e146fb7035b48138aa7d8c7bc7e26c749a88ee0a2e3ead6eea6189261dca6bf0281a43c832770ebd7a2c63eee09f2274865954b5322b96c805a430ae7c8ad141775dd468ff3c2584d2806b9f5bbf4c39a5066137225824ecd57e8f186a018fbeb067092eb673eeca6cd6887f4ee7d3f493771e456105544ef2c93565f8e8f14799546a640493827f58e082d3a1e507281e51fd621512fa5367b28bf51da0862b9519dc45c192949bc930cb89cd007977cb3944546fdb48f1faf537b3d9141e94365bb89c377d4157575aceb54fefbdb2e32f61a01793ee1a107a81176dd5ebdd87923edfc4e328a78a9ccc1e53aa5a95d174f72c08f526e176581cdaf78b1369e2c3e9f9111c91e4f2addc8667b57d8aa4b19c52bbec8f9dcf994f6411f6c12c2a5c93aaa69dba70523274a16a87f3a967398f2696c4685e023d1f2a0a6f0885657eee085180565a0719244db9e499e9c9900c992a2c3859d0d867e441f9ec0a001accfa7168633ac155fc8c8377152698537c533fb51ba4b58eee03795637d90df778674bd291ee15e8a20a15d15e7a33c4c1d9fd0900d77ed565b6b21590fbd2e7b4cb1e9e22efbc7388eeb5492280695064925c029545d30d55835ba9cc90edc45f35f37477fade6f10a37da856be2240ac4cc5b5bee4348b704f2f889b24062f0b9cfae4a9186e2ffd5a0774cb69252e3286c9b599a66b29a75225516963acfc3014fadc439903ce1b743af5b0842b9ffbaba98a4dcf90d6ab207259c245fc99c2b0daed3b6cd9ee3d17c0a4c38875718cf068941534b64395a8c36bf4809fc3575be33a5633429eea4c67185d5ea7a98b2d736f18ea04b3caf895e9a7b237f5f2bd29af82b34d3e7b032afa401d04225a2756084fe15ca80e8ba549e6d20ca070c991c4c79df5e5dadaa2174764d104ec8662a32419d24730bf86433c1287e975d58a5e93239ccf2f868c2729647d3b6f91281fdb41b95512c5e803e920c01414f5a8467d97d37267cc80cb8b232bc158d0ac6cccab2d02962626d257f6de560945d7db3884419ee8d794fdce823322cd3d6ec64c200accc61be7980a4b7d0815ad6f44795ad31f4fc366e3e5886db8d619c7a770f438d9a0acfed460ebe260d479e0ce88bb8a5e07d5902c8209fe011f557ee6bd93c7ec0e0f72e35d7fddb5e8f24c710ac141ecb4c5eee27e3405b3d11575523efd3345c8cdbbc42d0b74df60c284926fbef37fafd08b45c29a71cf2402333ca674863c840016db2f49694356dcd4ee5d7bfefe76545ff2401d633e3bbcc501ce8dad21bcbd131cea986801df50363d250083c12adb13d9137121d3cf417367c3c1e1d2b656959a9be808e23ded78c992b24364c346d24b351285757e508e8d95af8bc6a0d5a5e7802a0c7cb25c5f502f81b7d9c582dd851abc028641f17aac96112ddb8bafb6f1aa0974304902287447ebddfd444eb78d9367ee84219f421111799073591c1e4210361d0893e16bb3fd82d293d12c4973d2cca7fa2c72a405cabe717e7bc22ed5ed44f00edd3f2acd2c5fd963a9e59fc1ff5c8ce0df3220cde14216752cf0d8e2512ba3352f04173d4197c11764a1b969f1b7db30a4459f454840fa5c7831bf09579338c7032aac45a15af75f23af84561b64e109012118a951c22c7c637f6f30baf91b497e9553d6aca4ffeeac6af130835c7071caa324106ac71222be1e1cdb1a2cb796e4a4cdbd41530cecbcdd83b1497f98f40d9ae896a9772ba0cb87042fd7279584ec049572dd69054619b3edc5c7fc267fcfd53815a4ca67c079a80c76ca3970002752bfdb2de5fc5c5a75e8b186875243e7d7a106375b3117e46bdbe8d3b82544724efbf15e859ea3a23f3133e93fd5d482a28445f9eccc3788ef606284c7405ac685354e066742e5b1e1c5c608d952553025cef439366b2b69d210130b257a1ab800ff2600604197dec7b70edd2560ab962e79554abe60c3d08f97b6bc1bb5ec86bc4efa1943ed1245050811ccb3c9ff19a30ed5cdb722e57f26a2f1031dc2a101cc93bacbe628259030a86ca02845a3e3154ddd9564fec60d03240a3d3f39949b3d58a2a95118116e9856adfad5e88793d0fb40e16da12914e833fe60c13634ca4edaa38c77de0ea15b6f0d7fc0eb2232372576236d2acf6351e4c697943fe9660b9981f5982e1cd5a9cf2537e99fe98c6099184a80573b8d7240984fba53ec2988ed39d4a1ba252d4a912ec57c2a599f98feeac59bc2f67dc921cb37ddbcd3ecd57ae79e51f06dae887c34f6bef63e53665bbc32a7f60ef7af9eecb9e2ad38ae8727ef3a8a34503c08103ac3548b4988f50a76a2347a978562b15b269b6b109587bac3ce7c9950b8d1f9f646173a517c50821c569e8a8aceb1310a70d5bfa14dec47b3fdc391f56e504fae1bcb1716ed9be47b941a3017e4cd199dfff61810bc16f4c87491a5198e235e32c1eb3eff5878322b2a111dac87414957931a1c95ef1b5ba4df1c28ead64f0daf75916399bc67fa917442fb9fb271155588f5d6dff8c751c98b54439b18453511215b6a71124c619c1f38c820f714603b9d58552a728dc3071aabb51c45e2eb978f534ae711c4eb948c73aac6a94184b6d972657524d774e3c9cb533ff3a290d7b21127e0ac34d45531f62780dd0cf67e2a0e9f871d50bdd24309da9b971c24e95534a229badf6f55bd5208e1699e4211cdfefb4da7b98e7e858d339893e3d02371625d51415fd9ada740d29cf0062ab3e93a5c5fbde3957959ec0f885ceaf7681575b578732c92eabf0a3a9bf7d117748dd070c344004974db4172e66d962a56515fa20d2e6c9f8dd3c935b43f0271a822b61cdc5a1f1743166ca927b4515e09a05894e52719f0a667ca02691e196fd657301a3929eb7ee73dd1172e47ff1cb32ea819e4ce6ec2131c57cb1dba530322b8b4d2bdf4cff7b6e2e62c79c382033accabfda5d0f6ff56079e59a1d87580f72ff3155c49193fabb511afce49177b7cc5c71fb0d21cd03bc0114b2723fca9ad598c73764de28348d569b71731aa4c21e4c2a8a29b6df560ba770cea1c4d315d38a983281579e38abaa5be19e52c1580dd6352cc11dc4c776aabf6cc280405a38edca239b38b903317af959c13d5f67898e43b15bc00bedb1c43a42bc02d4a6cc528204c7b9d0301c312359d0009c768b10370e78e211ee610e16aac6725d747b6719a1adc0b1c09080b9e1edb46ce55a4251382479904a5aca0d4ec8022b178279dedcce3936d7c3559e9706721d621d613971ad2270d5e413ed1ef9bb8c6370f1fb0f9221692438bfc54702e694b577f8c60f9a1731e2ed49296daad4451fef70927f7407672b24294109f1641f9f1d244e6d1bd3f395bd3fe9b3955b4345f733c646bccc57b98c939ef2aa6ac837149585b62d6e5ba780716b22260e3942e37c0ccc50cf2c2467c221ce151fbdb2209c8d7102c9ee4b0f20817e289fe919417919ff38bd3a0d3c2e98a4a78fe616bed4c8f7c8a31be97f75b181154b87d7674cf196506d9517f960be8a6b01193b94fc6a60fc664ff4aa86fdd26f38815b33cb54dbaee5630d992df4f5ccc132afe251e2719f2aad7e5eaa3d442c5f44f640aee4bf87e88a6a70acaeee82ab788f146d29cd583247c55cbb95a38d78dc93ea9d1df6b034ad0b95fb62f34d1f0bbac6a4760d298ea8cc20a71ae30f8fa042d8426e2edd7df008fbbf56fd8fbea95db591dcb50a2cdbec6616aa21069cd590233a61b97b4251fa2e36cec8f6f556038d4bf05b6d86e483a0d836f52bfe883a115b7164c34ffa7d51e8b052b58515f7cfa88a42b341d395378ba64c133167bedbb260cdf3ac2609416e5dfcee532082294f36c232a4834086deb34b822cef254754b53bd413d223dee3a629cce750a2d3104a9e39473564226c9225d0752c06c13e4d019ff81e47e585f35d9ecade9c5ba0c192634d61042bbdf94dd98c5ed20799d6dd4694800d3fe3efb42baf5c6a248bb546deb216dc8e4e5c532b4966582e5f2813d9bc51df43481beb2990dfe6a0efedeaa8c60ba5d7aebb8e7fda44dabe39acd97af392b22185ef877224673452dd171789e11d6375ff55a334c9e594054e80192b4825261130d43d1ab43a90322ef7d84f2819141837284e82d9bc151760426c5ff9724d3c8a563e8bcaaff49c51a32eb7225bf0fd0a2eb3f2c076ec9c956a86ad1c7de2854c02065fd375ddc5c1415a26761598e2439e06fe80ebc874ee845635ecb34369da08bd20fd73292912b2796c472ffebe3f0abc549cd0938d1d580dbdd3bca98f29b4d9aa453bc334059d28b2eff4c755cd852805f54d468465b3fe84473bf1a06999f75f9f73856d3f3b102487d65ae1b3541d023894d3c8a646fa2c4fcdc469d2c0380a5f61b93b14dcdf34778d656d6e966001f9c9c16e438db602406be6bceeb4e565e18993e0a7083239f7f5aebbca5c2ffcc2eefa9599f91326f78d3f256746fafd13a150cfd083828eb3e00520017fdb2467c4a473ea96d3ea3e76fc1f947de04ade795e96c0b3301f21788f9505547f378917cc06a5e303b1daeead040a32dd9ac267d4d55c6cbbc0776777d5e3165a1c699bee117ba64a3b4b6776c80c89ddb538def561a779467a9f080e69ab2d47b20465d7337f62c856d2d5c0ecc31f17b90b0703d7314dd7cf039375d4eac5ade5736da7e5a0349f1a2a7d5cc798f6588bec4bd2694c7082a3446230d4c1414427af00d847f92cd87b3383d40fbb0cf3db1b0b959df994ae716a02987f5832b59c85f78da3e5433bb0574cd525ea42e654fbc651701d9944bc00b0ded9e904ce696ea242735b06b84ebb645b88e8b35e1f17e64d9cf2f978046aea9ba7411ac9e2efa2477f9872def6a95702e3c6b53d7799568cca092bb88a0ae1cb9d801ad8f7834bd3375265e822ec977b97969aafe958a4938f88623f4b9eb33538458a696c83748b68bf8157fc62167e8a0066abec70e7cdcdd8bfd30c5c0ed568ae98147c4bda8fc9702a35ef3e046ac680ed07d67d87b984bd0c5cb20a8cc1cdfcfc182bd0eb13142c14a5cb61a222cc12eb106ad0c54d0078d6ddcef02a279bc7159ed377d7fd9f8dee4b295372e4887ad70e45eb1730e3965a364af55cfd7cf746af24d46a8895a43b0d6bbbf47438d407bebca339ac200bdf3e12b503647660558119d46c776aeb11164fd00d71fd8e836d092dac6c6ec3bea67abbdb38b9646407f13e411eb564fe3031d03fd1fe9f2f37debfa586ca4d4d86583e036711bfafdb2cb77c24b962bf0ecc15d2e85bb045a8a466f9cc7ac5a0444ae7e8100d1dddd3019a72aab530636c85e5dd4aa60b91dca7b476bd2a9318dfed15ab439e3dec392fd57bf40fbd6990a9608a82840a4cd71ec31d7960a6ca3cb8e917478e580a628893e8d5b043ddf2f120d1eb1f729f5a79f87ebc1d78cda15db0afb4de34c8c31761428a8e5af8a2fec46c1ca8d66f956222992bfb266490cc08932175cf697427d24b3abb0c0d08a94cf9e19c7bb8760d5675035aafa489fbc734a8aa743155e59c9a3a420e2db0661e09bf9a388e802094d839c8df7a029532890f529825df01e94e02f6b92c87f17c34e4207a4603ca1742ca5110956f9b5b406a0f629a85b0fbe9a1d8b01060f04e22239bc07d4305ddee11d8b7ca56885</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dealing with Imbalanced Datasets</title>
      <link href="/posts/deal-imbalanced-data/"/>
      <url>/posts/deal-imbalanced-data/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>The Imbalanced Datasets are very common in our life such as illegalusers or illness check. The machine learning model always performs badon these datasets if there are no specific dealings, especially theprediction accuracy of minority class. For example, if the data ishighly imbalanced such as 9995(negative):5(positive), then if your modeljust let every instance to be negative and you can get an acc of 99.95%but the result is meaningless. Another example is that misclassifyingthe minority is very severe. Assume that you misclassify the patient asnormal. Oh my god!</p><p>So researchers proposed two kinds of methods for this problem:</p><ul><li>Cost Sensitive Learning<br />When <strong>training</strong> your model, it will give differentclasses different weights in the <strong>loss function</strong> thus letthe model focus more on the minority class. In sklearn, there are<code>class_weight</code> and <code>sample_weight</code> for you. For<code>class_weight</code>, you can specify the weights for differentclasses such as <code>&#123;0:0.1,1:0.9&#125;</code> or you can set it to<code>balanced</code> then weights will be computed by <spanclass="math inline">\(\frac{\#samples}{\#classes\ *\np.bincount(y)}\)</span>. For <code>fit(sample_weight=)</code>, you give<strong>every instance</strong> different weights. When computing theloss for the instance, it will be <code>class_weight</code> *<code>sample_weight</code> * <code>loss</code>.</li><li>Sampling<br />Sampling means that we will change the original dataset rather thangiving them different weights.</li></ul><h2 id="sampling-methods">Sampling Methods</h2><p>Over-sampling means to increment the minority class.</p><ul><li>Random Over Sampling<br />To sample from minority class with replacement to let the number of eachclass is 1:1. Overfitting on minority class.</li><li>Synthetic Minority Oversampling Technique (SMOTE)<br /><span class="math display">\[x_{new}=x_i+\lambda(x_{zi}-x_i)\]</span> First you find the <code>k_neighbors</code> of <spanclass="math inline">\(x_i\)</span> in the minority class, then justselect one <span class="math inline">\(x_{zi}\)</span> randomly andproduce the new one. There are some variants such as borderline SMOTE,SVM SMOTE and KMeans SMOTE.</li><li>Adaptive Synthetic (ADASYN)<br />The difference between SMOTE and ADASYN is that SMOTE will generate newsamples for random minority data until 1:1. But ADASYN willautomatically decide the number of new points generated for each <spanclass="math inline">\(x_i\)</span>. There will be more points generatedif there are more majority data around <spanclass="math inline">\(x_i\)</span>.</li></ul><p>Under-sampling means to decrease the majority class.</p><ul><li>RUS<br />Data waste.</li><li></li></ul><h2 id="example">Example</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底作别</title>
      <link href="/posts/say-goodbye/"/>
      <url>/posts/say-goodbye/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="734023e3be1cdc917cd39a46dc8d0c7e67a845a2424ae50ef269895409d7960c">c172f4ee74b2b6d246b20cbfdc0b877e4bd57af87b207617392664b5e29f88e312d6e561f347b9926910d25e5102863696041f11fe8fe0606e5ed4a5d40239deb870b179549b9372cfe386f7fc1b3200db7532a26b0ce138046d8b8de3b1f12d508d011f45898d7fc309775a8f949cf7a2a5264f0855498b8e0d96327b4107020c299c532d4a8abc6800deb6ef633494936fecf940e17d3585e9cdd3e716e919fd6c62998ec1960c67bebfbaece529d9f49b81aa86875d0b7bac31428638bcde151f1b30c388195985f63e899547687ad8b919dcc90d6737c25d4c6ce8e365c06923ecb74ba1a65ab80c5d44baf76fae349d6227983b774b244fcd688110d822f15caf0c70626b654a0ace727d8133a04ebcc472de291730d3a7de78a2f145aec5e82da318d4062423d61de5bbbb6d9da142a1249df5084c3d030d476c9084e95ee780b768f9a2bc5207f6c977c530bc9cd9132d4b6efd456b0c42cd1d652449a984853a2850883268ec71fecfa8ac46da9d1e2eb219435151ba96afccfd828515f8834f6b176f03c31cd5c40c619a5b14ed2603916ea23adb3c2b520d1272cd2595aba9b9979985a2ccf7d3612a17c19212489f1b074c862569438914125d204851755a2d9a9d3b88696cc1557fe4cd44ea9bcfdb6e127f261e30d70e3d53652057a1307f01356d3155990bbe840253f2f0f117dfadaf3308a54cb2437b55fb09c70120f59f5fb51908978141e39b4951b11b75f8eeadc5a3745880d3f93a9b1fe1d8e666bae47b008cf6d86d2a3bd923ee9360508c0395733d13228588bc718c2baa67a435a1142a473470220dc789b25341c541b5129115107f58bebc6f29bb79f09d911e42fe3307619fdea465cb10e51354e6ffc6f5d46b63c631e31cd8699b34288f6ed3e03f200b39ff1f52c178b5ca2111f149e00893974e67efed6f86c10ad44d5f7b1b0e10d5f37a4e95ef60e8546c44030b364e8c7c775ba964a69af01b0810ee9cf0719463bc0487b4c1ff4d5334b7ada2d71f7b7aa448a6ab42b4c4c436bb837cce2a07357e472937761a7c0235a804d59359c27c8a9c081090be165b46742675464f0ef59a77fa7a398c47edc0b4876201a84d9ddf573d8502deff151765fcde1490bd44f13efed6dcfba0f8d0a77f6949758f89e96c763e9e7ec5e720be5b0d68afb4240dd4274da15d3b3abef4e38a2081b5e4dbdf61af16e272a32e995b6876550cf306eb5fa40c306dbcf7014e8500995deb993bf5757aa8e08105aa6fcb329cd0fed787b9de6ee5287783845caf088c276c7e8880f82d4e89b991d309039e903acfbf8898c47f575c2c20231a08c26f1ddd45e016dff4c7099f1edf79eee8b21de3f0156f97decd24b1aa0b974253247e3d236d75c051f34975ebad4d887531664bcf8a44302f5ac6d9e3cd914313bb65f455554850b99f067ed7db96c4f4b2be5a55be94a8ddf969511982b3d198ad8f6bc0b67dc26e68b7c61010bad34532a69f77def4743fd456f8c420067e9c2f07e714fa1448add845bb59b87b9098e672b578ddcfce5c67443b01100b1d84d621eb9fa6e04a13b18a9784386a653780e6a5439455b20b95daffdddcefc62a6a5e0eefe7d6e307df9f1727fa1206c973a95e2e14d3d3f4947278a4444e92f23327a2edb46a393b98b5e89a6380a181ebba3268c0fdb4a16896618c9130baaaebdca473029bc5a5c7dc5f7f294e3bdd8b17d369eb38ffa12733e6aed7beaff7ffdbf194fed160e512abccdc83504f4f525de9adc3ba3667a5db4b9ba48defcdb8248c6f4436c63005c041e2e185cc5c145cc487cfc2d06ce577905610e72074aafea49bcab8751dfc976e0bfcbe50f78a4601fe74d5098e914498a64370aa36ba4adfbaf5b7e245a30506ee0fbe819f87953b9141279c46702f406edbc73fb51261b847c58e59117ad00f131a7b677b5c19a006b16ffd0e457c6e51f151db7bad033efbf70f042279d2144ec4b8120e63cb0801ac806ea5b91001c9559146ec692a5e9f5111cfe1e280f38e97621e30062c2f6353c650035c99dcb27641c524b3949072f5fd5179f7ee78e4146dfb1a23f788517b2c7ba14a68d1d4acd75f13bbfec8b7d5ce090d1c119c9ff08072a44b0a155d80388c557d71a62b437a593016545f4953a6f32c1a8286da8c469bd6abe81141ee5fb4c55512877a021c153ec515e4ca9ef8e37bfdf59345442bab87ac32fb1feab4ac53a4b2879ef3181fc5b9bb837020d689ec21c1fb47d65266e132c715bb9748c9d0da84e850a0aa67b7e5d5e4d94a607325b09a38006aec683aad0232a09febd633dfa3315ea301a746c0b86c7fcb93203e1dbd118cd4bdd9e2c6398cba7447734753e7f5eca5457d3a6f371dedbe99e6e901952599dc0e3a40258edfd055cb43b036c4bcbaae32b38cd24c055e7be2a0e415ce3ac95d8d771e264e79261c7587466545e8337069988e94cc6bb9c20ba41395e8cb02c7fff90889b9c3f511ce1a22e07d16f78162055bdd964a1be21659770bb9db574148d1afdc317c2ee652ce1f549b41a29cb578db7148c8479442daf82f5dec82fbcf78fe5e9391800764a2007c82ea9d648a601fe4521da7b7aa17aaf786567ac0d6660570d1500202cc4689eb8b6a27a3540eb5936b9087a19254f2271bea8474112b031e9979fb38f5bf5532127dcbef3f39f623fcb857cbcde5662de05f0baeb7290093c067e4fc85b0966a6bf73b38abdcc85c503b5debe6616c3d4cd17195fcf3042726a283935bb9b73a1155bcdbb65ff281a013e279d7dc6dd27bab4673d7b06d9f7e0e478d52fa9913ec1a1eccd2e4277cc3a8715cc163dd14dd961617c79f550154b4e1c7f0b81a5e4f905202e8584c7e5c7a04f5e11085894c7992b8bfc4cfd3789fb0f30b4b07c061b25d39bd9f156a233a507a04386bf91be903b73be2c2272b990bbcbd05b598e3b5fc58477cc4cf4eafb331d0567a2f0d8eb018aff4e772e0bea3597a3acba3dff53e95fa8041c7f5a06dcbafc52d0667e60c6a2ab186c681a5ae1dc22a30a211ae17db9000eeb6c83b7b6b45e8efcaf3c845d6c1d77ac8bde6fea0cff093b2fe39ca87a700ad3f881893f30939ea2cc4300bde7509b507488a11c76fe7e6bf387cbdba2bebeaa77caa8c5cb4eca2065cba653c47ef073f1c44572415b0030909b1dc2fb65c3e8d50cba018ee50708a02c97d3ba94c20662997f70ab4f8e22dc986ef6433f98de5ff58fafb4961774f853241822f3451281ec49d40271524212f447dcf6bab8d9da851a77700f19c86a6e954cefb83ab9e3b19ca46d5592cba76aef9607c1b0813a009b7494469d30d5ad29f0194d405ef598bdf613f308cf737bb0ec8a8a61995b19d99b1ec5b77197ea4463a089a2c1651b99b6420de3cf0e613533f48fab779298118b5b5850134768fa744106d953634c27acb213140f7884fa3597ea8fc3e76fe97c86091f2f050721ec1d3ee712bb6ef8e83ad8e2e2d07f660725e5030f8ad7b707dcea99874b3d2e77c371b4a1e9dec4b63e9373576866691c88bc5a784dfb88b21d103ca33a78827580dabcaedd322d3be8f86a89412edfdabb6ded3bd19fb1df3d5cdf0f00041a24b3930952e936ae1815c16f454b1d27f41893929b08caab45532efb28a20c3318661b919b959bb6e96d625f3722c0c04022d99eb64442ebf231ec04e0503db94a7a6effaf40304d257040ca780c884b24dc8ff77cad2469c194d66a895cd1eb9b7bb19b193d8f969b9545c0e68f06ebd519ce0364c490e2e796a26f18e16ada89a95c62c4768850272ad31cd46bf18c7a30ef075c499e4f5c9b15de652f12c91b9d13101c191ed7d8cebd87cf17b81268e96e6eaf8c6fdc2c5db5f5f24d733edce32f9b52f506eef2cc257b7a2d59a5c7509075006904d1b9d48f257121b1882e8b721de070d0219d55a739f8e00a0f736fa8d4ac0cac192618cc90b3bb89d8aef80a6a84805185f6c3d7098f7749141be0be59fd6c139c569a4ab8526b209217045008fd7e31b9b450e8c6fac8b295b6f7f1cf4383fe7d11848f1f185f71e03af947eb90de45eb684a9525b19bbcbc293680f6478a6800d63f38350f56ceef8744113ead1745ffeceabba3e2edee9ecdaf34558bc229ea134f04acfb8cea49add396cfd95e8a7542b92a188353c5efbba2de85ac7fed06d2ce5ce60a8f279e4cdbf60cb1e6c1657c2923135773585c82f449b1d25b1bc1610e5c07f309444f9a5172c40e72b65510749efe839a319d71a516fbb20226644245200980811e4daaa19c2693c24f457ca2429042a104980af97f4aa956769bbce9bec31c10eb9b2f24574aaf195544d6fedd0fc88b8e2629a69bc35dcb3222cdc2dfa34fc7591f74e94291cfa8d0b1647be7a3eda80df3d3088e3e63e2d26cec9bf2b27bb9dda157fbd75aa4bef6d07fc4d76f0e165c632989e4663c0ebc286db5deacb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kick Start 2013</title>
      <link href="/posts/kick-start-2013/"/>
      <url>/posts/kick-start-2013/</url>
      
        <content type="html"><![CDATA[<h2 id="practice-round">Practice Round</h2><ol type="1"><li>题目大意：给定一堆人名，从上向下扫描，一旦当前值比前一个的字典序小，就将当前值移动到正确的位置，不论移动多远，代价都是1，求代价总和。</li></ol><p>和插入排序类似，如果当前值<spanclass="math inline">\(j\)</span>比<spanclass="math inline">\(j-1\)</span>小，将<spanclass="math inline">\(j\)</span>移到前面合适的位置，此时前<spanclass="math inline">\(j\)</span>个数是局部有序的。这道题只要求出代价和即可，不需要输出排序后的结果，不需要真正去移动，只要记录前<spanclass="math inline">\(j\)</span>个的最大值，如果<spanclass="math inline">\(j+1\)</span>比最大值小，那么必然触发一次移动。举例：<br />2 1 5 3 0 j=1, max=2, cost++<br />1 2 5 3 0 j=3, max=5, cost++<br />1 2 3 5 0 j=0, max=5, cost++<br />0 1 2 3 5<br />有2个地方要注意：<code>cin</code>读入<code>string</code>时，会把空格/回车作为分隔符，遇到即停止，所以要用<code>getline()</code>，默认以回车结束；<code>cin</code>读完<code>int</code>后，换行符<code>\n</code>仍然在输入流里，所以下一次的<code>getline</code>会先读<code>\n</code>，故用<code>cin.get()</code>先取走<code>\n</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, N;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        cin.<span class="built_in">get</span>();</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">names</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin, names[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string curMax;</span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                curMax = names[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (names[j].<span class="built_in">compare</span>(curMax) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ++money;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                curMax = names[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; money &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>题目大意：</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Monte-Carlo Tree Search</title>
      <link href="/posts/monte-carlo-tree-search/"/>
      <url>/posts/monte-carlo-tree-search/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>We all know that Monte Carlo Simulation is used to estimate someunknown variables through random simulation. It is because that theprocess is too complicated so we cannot know the true rule behind it.Only god knows. But thankful to the randomness we can do lots ofexperiments to approach the truth.</p><p>MCTS has the same idea but it is based on a tree. Every path fromroot to leaf forms a solution and the whole tree defines the searchspace. It is a heuristic search strategy based on some loss functions.But it will follow not only the loss but also try to explore theunvisited nodes. So it's also trying to make a balance betweenexploration &amp; exploitation.</p><p>One iteration has 4 processes: Selection, Expansion, Simulation andBackpropagation. Let's start to build the tree. Initially the tree onlyhas a root node. Every node holds 3 info: action list for the nextdecision; visit times to measure the exploration; quality values tomeasure the exploitation.</p><ol type="1"><li>Selection<br />Using some criterion to select a child node which is eager to expand.There are 3 possibilities for the current state: If all the actions havebeen expanded thus the node has finished a complete search, then we willfind a child with max UCB value and go down the tree recursively; Elseif there are still some actions which have not been expanded (e.g. thenode has 20 possible actions but there are 19 child node in the tree),then it will select one action randomly from the unexpanded actions anddo Step 2 Expansion; Else game over and do Step 4 Backpropagation.</li><li>Expansion<br />We have found the most eager node N to expand and the action A afterSelection. So we need to add a new node S to the tree as N's child nodeby doing A.</li><li>Simulation/Playout<br />Start from S to let the game run randomly until game over. Then we get aperformance to be S's initial quality value.</li><li>Backpropagation<br />The nodes along the path from root to N will update their quality valuesafter S's simulation.</li></ol><p>After some fixed number of iterations or time limit, we will get alarge tree and select the best leaf node as the result. Below is afigure: <img src="https://img-blog.csdnimg.cn/20210404201349819.png"alt="在这里插入图片描述" /></p><h2 id="upper-confidence-bound-ucb">Upper Confidence Bound (UCB)</h2><p>When we need to select a child node to go down the tree, we usuallyuse UCB criterion: <spanclass="math display">\[\underset{child}{\operatorname{arg\max}}(\hat\mu_{child}+C\sqrt\frac{log\ n(s)}{n(child)})\]</span> <spanclass="math inline">\(\hat\mu_{child}\)</span> is the average rewardgathered over all tree-walks with prefix child, <spanclass="math inline">\(n(s)\)</span> the number of the parent's visitsand <span class="math inline">\(C\)</span> is constant controllingexploration &amp; exploitation. UCB tends to select a node with highquality value (for exploitation) and relatively low visit times (forexploration).</p><h2 id="an-example">An example</h2><ol type="1"><li>Initial tree<br />Actually we only have root node <spanclass="math inline">\(S_0\)</span>. Assume there are only two actions<span class="math inline">\(A_1\)</span> and <spanclass="math inline">\(A_2\)</span>. <spanclass="math inline">\((Q,N)\)</span> means the quality value and #visitsof this node.<br /><img src="https://img-blog.csdnimg.cn/20210519201721793.png"alt="在这里插入图片描述" /></li><li>First Iteration<br />Since <span class="math inline">\(S_0\)</span> is a leaf node now, weshould expand. Since the 2 actions are both unexpanded so we randomlyselect one (assume we select <span class="math inline">\(A_1\)</span>).Then we add <span class="math inline">\(S_1\)</span> to the tree andplayout from <span class="math inline">\(S_1\)</span>.<br /><img src="https://img-blog.csdnimg.cn/20210519202838706.png"alt="在这里插入图片描述" /><br />Assume we got a performance of 20. Next we need to backpropagate thevalue to <span class="math inline">\(S_1\)</span> and <spanclass="math inline">\(S_0\)</span> and update Q and #visits.<br /><img src="https://img-blog.csdnimg.cn/20210519203559429.png"alt="在这里插入图片描述" /><br />We finished the first iteration.</li><li>Second iteration<br />Start from <span class="math inline">\(S_0\)</span>, since <spanclass="math inline">\(A_2\)</span> has not been expanded so we have tochoose it. Then add <span class="math inline">\(S_2\)</span> to the treeand playout from here.<br /><img src="https://img-blog.csdnimg.cn/2021051921175522.png"alt="在这里插入图片描述" /><br />Then backpropagate to <span class="math inline">\(S_2\)</span> and <spanclass="math inline">\(S_0\)</span>:<br /><img src="https://img-blog.csdnimg.cn/20210519212028325.png"alt="在这里插入图片描述" /></li><li>Third iteration<br />From <span class="math inline">\(S_0\)</span> there are no unexpandedactions so we need to select one child using UCB (assume C=2). <spanclass="math inline">\(UCB(S_1)=21.67,UCB(S_2)=11.67\)</span>. Thus weselect the leaf node <span class="math inline">\(S_1\)</span>. Assume<span class="math inline">\(S_1\)</span> has 2 unexpanded actions.<br />Choose one randomly (assume <span class="math inline">\(S_3\)</span>)and playout from here and backpropagate, assume we get performance of0:<br /><img src="https://img-blog.csdnimg.cn/20210519212745377.png"alt="在这里插入图片描述" /></li><li>Fourth iteration<br />From root we should decide which one to select. Again using UCB: <spanclass="math inline">\(UCB(S_1)=11.48,UCB(S_2)=12.10\)</span>. So wechoose <span class="math inline">\(S_2\)</span>. Assume there are twounexpanded actions so we randomly choose <spanclass="math inline">\(S_5\)</span> and playout and get a performance of14. After backpropagate:<br /><img src="https://img-blog.csdnimg.cn/20210519213431456.png"alt="在这里插入图片描述" /></li></ol><p>Assume the max iteration number is 4 so we get the final tree above.Finally we can select the best solution from <spanclass="math inline">\(S_0\)</span> to leaf node according to UCBvalue.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> AutoML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bayesian Optimization</title>
      <link href="/posts/bayesian-optimization/"/>
      <url>/posts/bayesian-optimization/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>Hyper-parameters tuning has become an important work during trainingneural networks. As the number of Hyper-parameter is becoming larger,researchers proposed Grid Search &amp; Random Search to wish to getbetter combinations of Hyper-parameters. However, Grid Search has a hightime cost. Although some experiments showed that Random Search got abetter result than Grid Search but the result is still notfulfilling.</p><p>Besides, there are some gradient-based methods to solve the problem.But the objective function is usually not differentiable or even notcontinuous. Thus these methods have a very finite usage.</p><p>BO is a gradient-free optimization method to get global solutions ofa black-box function. The function usually has a high cost to computesuch as training a deep neural network after tuning theHyper-parameters. For this reason, we usually find a<strong>surrogate</strong> function to approximate the original function<span class="math inline">\(f\)</span>. In the field of AutoML, we oftenuse Gaussian Process, Random Forest or deep network as the surrogatemodel. The simplest form of BO is as follows: <img src="1.png"alt="在这里插入图片描述" /> <span class="math inline">\(f\)</span>represents the black-box function that we want to optimize (black-boxmeans that the function transforms a configuration <spanclass="math inline">\(x\)</span> to an output but we don't know theexact function relationship). <span class="math inline">\(\chi\)</span>represents the search space of the combination of hyper-parameters.<span class="math inline">\(S\)</span> represents <strong>AcquisitionFunction</strong> which is used to select the promising <spanclass="math inline">\(x\)</span>. <span class="math inline">\(M\)</span>represents the surrogate model which takes a configuration <spanclass="math inline">\(x\)</span> and outputs the performance (much like<span class="math inline">\(f\)</span> does).</p><p>First we need to get some samples from <spanclass="math inline">\((f,\chi)\)</span>, thus we get <spanclass="math inline">\(D=(x_i,f(x_i)), i=1...n\)</span>.</p><p>Next we iterate <span class="math inline">\(T\)</span> times (oftenfixed) to select configuration <span class="math inline">\(x\)</span>.Use the dataset <span class="math inline">\(D\)</span> to train thesurrogate model <span class="math inline">\(M\)</span> (much easier thantrain <span class="math inline">\(f\)</span>). <spanclass="math inline">\(M\)</span> has several choices such as RandomForest, Tree Parzen Estimators. Here we use GP so we get theprobabilistic model <span class="math inline">\(p(y|x,D)\)</span>.</p><p>Then we need to find the most promising configuration <spanclass="math inline">\(x\)</span>. The most important thing forAcquisition Function is to make a balance between <strong>exploration&amp; exploitation</strong>. It means that when selecting the next <spanclass="math inline">\(x\)</span> we not only want to select thoseuntried points (exploration) but also want to select those tried pointswhich has a great <span class="math inline">\(f(x)\)</span>(exploitation).</p><p>Finally use the promising <span class="math inline">\(x_i\)</span> toget corresponding performance <span class="math inline">\(y_i\)</span>and join the pair into <span class="math inline">\(D\)</span>.</p><h2 id="gaussian-process">Gaussian Process</h2><p>If we assume <span class="math inline">\(x_i\)</span> is independentwith each other, the Multivariant Gaussian Distribution's probabilitydensity is as follows: <span class="math display">\[p(x_1,...,x_n)=\frac{1}{(2\pi)^{\frac{n}{2}}\sigma_1...\sigma_n}exp(-\frac{1}{2}[\frac{(x_1-\mu_1)^2}{\sigma_1^2}+...+\frac{(x_n-\mu_n)^2}{\sigma_n^2}])\]</span> We can rewrite the formula to the vectorized version: <spanclass="math display">\[p(x)=(2\pi)^{-\frac{n}{2}}|K|^{-\frac{1}{2}}exp[-\frac{1}{2}(x-\mu)^TK^{-1}(x-\mu)]\]</span> in which <span class="math display">\[K=\left[\begin{matrix}  \sigma_1^2     &amp; 0      &amp; \cdots &amp; 0      \\0      &amp; \sigma_2^2      &amp; \cdots &amp; 0      \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\0     &amp; 0      &amp; \cdots &amp; \sigma_n^2     \\\end{matrix}\right], x-\mu=[x_1-\mu_1,...,x_n-\mu_n]^T\]</span> Thus <span class="math inline">\(x\sim N(\mu,K)\)</span>,<span class="math inline">\(\mu\)</span> is the mean vector and <spanclass="math inline">\(K\)</span> is the covariance matrix (a diagonalmatrix since the independence).</p><p>But what should we do when <span class="math inline">\(x\)</span> hasinfinite dimensions? Such as in a continuous temporal T or spatial S.Actually GP means Gaussian Distribution and Stochastic Process (abouttime T). GP is defined by an infinite number of Random Variables on acontinuous domain. In other words, it is an infinite dimension GaussianDistribution. Formally, let's sample n moments from T: <spanclass="math inline">\(t_1,...,t_n\in T\)</span>, thus we get an-dimensional vector <spanclass="math inline">\((\xi_1,...,\xi_n)\)</span>, if this vector is an-dimensional Gaussian Distribution then <spanclass="math inline">\({\xi_t}\)</span> is a GP.</p><p>Let's take an easy example to illustrate: suppose during peoples'life time, at every moment <span class="math inline">\(t\)</span> theenergy of the population forms a Gaussian Distribution but differentmoments have different <span class="math inline">\(\mu\)</span> and<span class="math inline">\(\sigma\)</span>: <img src="2.png"alt="在这里插入图片描述" /> If we take 5 moments during a population'slife time, then <span class="math inline">\(\xi_1-\xi_5\)</span> allforms Gaussian Distribution but they have different <spanclass="math inline">\(\mu\)</span> and <spanclass="math inline">\(\sigma\)</span>. If we sample an arbitrary moment<span class="math inline">\(t\)</span> then <spanclass="math inline">\(\xi(t)\sim N(\mu_t,\sigma_t^2)\)</span>. If wesample at some points and connect them together we get two samples ofthe GP, as the figure shows.</p><p>Now that we know what happens at <spanclass="math inline">\(t\)</span>, let's consider the whole <spanclass="math inline">\(T\)</span>. We know that for a finite GaussianDistribution, it can be determined by a n-dimensional vector <spanclass="math inline">\(\mu_n\)</span> (reflects every Random Variable'sexpectation) and a <span class="math inline">\(n\times n\)</span> matrix<span class="math inline">\(\Sigma\)</span> (reflects every RV'svariances and covariance between different dimensions). It is almost thesame for GP except that we cannot use a vector to describe every <spanclass="math inline">\(t\)</span>'s mean since it is infinite. So we needa function <span class="math inline">\(m(t)\)</span> to describe thecontinuous <span class="math inline">\(T\)</span>. For <spanclass="math inline">\(\Sigma\)</span> we should use a kernel function<span class="math inline">\(k(s,t)\)</span> to describe the covariancebetween time <span class="math inline">\(t\)</span> and <spanclass="math inline">\(s\)</span>. Once <spanclass="math inline">\(m(t)\)</span> and <spanclass="math inline">\(k(s,t)\)</span> is defined the GP is determined<span class="math inline">\(\xi_t\sim GP(m(t),k(s,t))\)</span>.</p><p>The most popular kernel function is RBF which is defined as follows:<spanclass="math display">\[k(s,t)=\sigma^2exp(-\frac{||s-t||^2}{2l^2})\]</span><span class="math inline">\(\sigma\)</span> and <spanclass="math inline">\(l\)</span> are two hyper-parameters. If <spanclass="math inline">\(s\)</span> and <spanclass="math inline">\(t\)</span> are close in <spanclass="math inline">\(T\)</span> then the output covariance will belarger and it means the correlation between the two points isbigger.</p><p>Once we have some knowledge about GP we can start to know GaussianProcess Regression, which is a kind of Probabilistic Model. It meansthat we can use Prior and Observations to calculate Posterior. First wedefine a GP by <span class="math inline">\(m(t)\)</span> and <spanclass="math inline">\(k(s,t)\)</span>, which is a Prior. Then we observesome data to revise the GP's <span class="math inline">\(m(t)\)</span>and <span class="math inline">\(k(s,t)\)</span> to get Posterior. Buthow?</p><p>Here we need to use some Gaussian Distribution's nice properties:Once Gaussian always Gaussian. It means that marginal distribution,summation and conditional distribution of a GD are still GD. Assume an-dimensional RV <span class="math inline">\(x\simN(\mu,\Sigma)\)</span> and we divide it into two parts <spanclass="math inline">\(x_A\)</span> and <spanclass="math inline">\(x_B\)</span> then we get: <spanclass="math display">\[x=\begin{bmatrix} x_A\\ x_B\end{bmatrix},\mu=\begin{bmatrix} \mu_A\\ \mu_B\end{bmatrix},\Sigma=\begin{bmatrix} \Sigma_{AA}, \Sigma_{AB} \\\Sigma_{BA}, \Sigma_{BB} \end{bmatrix}\]</span> Then we can get: <spanclass="math display">\[x_A|x_B\sim\mathcal{N}(\mu_A+\Sigma_{AB}\Sigma_{BB}^{-1}(x_B-\mu_B),\Sigma_{AA}-\Sigma_{AB}\Sigma_{BB}^{-1}\Sigma_{BA})\]</span>Thus we could update the GD's Posterior parameters. It is much the samein GP. If we get some samples <span class="math inline">\((X,Y)\)</span>then the rest is <span class="math inline">\((X^*,f(X^*))\)</span>. Thejoint distribution forms an infinite GD: <spanclass="math display">\[\begin{bmatrix} Y\\ f(X^*) \end{bmatrix}\simN(\begin{bmatrix} \mu(X)\\ \mu(X^*) \end{bmatrix},\begin{bmatrix}k(X,X), k(X,X^*) \\ k(X^*,X), k(X^*,X^*) \end{bmatrix})\]</span> So wewant to know the rest of the points based on the observed points: <spanclass="math inline">\(f(X^*)|Y\sim N(\mu^*,k^*)\)</span>. <spanclass="math display">\[\mu^*=\mu(X^*)+k(X^*,X)k(X,X)^{-1}(Y-\mu(X))\\k^*=k(X^*,X^*)-k(X^*,X)k(X,X)^{-1}k(X,X^*)\]</span> Here is an example:<img src="3.png" alt="在这里插入图片描述" /> Finally let's return backto our BO's <span class="math inline">\(M\)</span>. We first assume ourprior: <span class="math inline">\(\mu(X)=0,k(X,X^*)=RBF\)</span>. Plusthe observed and evaluated <spanclass="math inline">\(D=\{x_i,y_i\}\)</span> we can get <spanclass="math inline">\(\hat \mu\)</span> and <spanclass="math inline">\(\hat{\sigma}^{2}\)</span>, then the posteriorprediction is <span class="math inline">\(p(y|x,D)\)</span>, which isstill a Gaussian Distribution. The calculation process is as follows:<span class="math display">\[y=(y_1,...,y_i)^T \\\hat \mu=k^T(x)(k+\sigma_{n}^{2}I)^{-1}y \\\hat{\sigma}^{2}=k(x^*x)-k(x)^T(k+\sigma_{n}^{2}I)^{-1}k(x)\]</span> Once we get the posterior prediction <spanclass="math inline">\(p(y|x,D)\)</span>, we can feed them to theAcquisition Function to get next <spanclass="math inline">\(x_t\)</span>.</p><h2 id="acquisition-function">Acquisition Function</h2><p>There are some popular Acquisition Functions:</p><ol type="1"><li>Upper Confidence Bound (UCB) <spanclass="math inline">\(x_{t+1}=\underset{x\in X}{\operatorname{arg\max}}[\mu_{t}(x)+\beta_t^{1/2}\sigma_t(x)]\)</span> The weighted sum ofposterior mean and posterior standard deviation. The two itemscorrespond exploitation and exploration, respectively.</li><li>Expected Improvement (EI) <spanclass="math inline">\(x_{t+1}=\underset{x\in X}{\operatorname{arg\max}}\ E_{f(x)\simN(\mu_{t}(x),\sigma_t^2(x))}[max(0,f(x)-f_t^+)]\)</span>, <spanclass="math inline">\(f_t^+\)</span> is the max observation value duringthe first <span class="math inline">\(t\)</span> iterations.</li></ol><p>Except the above functions, there are Probability of Improvement,Entropy Search and so on.</p><h2 id="reference">Reference</h2><p><ahref="https://jgoertler.com/visual-exploration-gaussian-processes/">AVisual Exploration of Gaussian Processes</a><br /><ahref="https://www.zhihu.com/question/46631426">如何通俗易懂地介绍GaussianProcess</a><br /><a href="https://zhuanlan.zhihu.com/p/76269142">贝叶斯优化/BayesianOptimization</a><br /><ahref="https://github.com/fmfn/BayesianOptimization/blob/master/examples/exploitation_vs_exploration.ipynb">Exploitationvs Exploration</a><br /><ahref="https://github.com/fmfn/BayesianOptimization">BayesianOptimization</a><br /><ahref="https://www.cs.cornell.edu/courses/cs4780/2018fa/lectures/lecturenote15.html">Lecture15: Gaussian Processes</a><br /><a href="https://distill.pub/2020/bayesian-optimization/">ExploringBayesian Optimization</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inductive Representation Learning on Large Graphs</title>
      <link href="/posts/inductive-representation-learning-on-large-graphs/"/>
      <url>/posts/inductive-representation-learning-on-large-graphs/</url>
      
        <content type="html"><![CDATA[<p>Stanford的帅哥Jure发在NIPS 2017的一篇文章。</p><p>GCN是TransductiveLearning，训练时的图要包含所有结点，是固定的，不能快速泛化到未知结点（图），本文提出了一种InductiveLearning的GraphSAGE。</p><p>GCN学习的是每个单独节点的低维embedding，由于输入的图是固定的，所以可以很好捕获全局信息。但如果要获得新节点的embedding，加入图以后需要调整其它结点，至少也是局部重新训练，计算开销太大，应用受限。</p><p>GraphSAGE学习的不是每个结点的固定的表示，因为图结构不断变化，所以学习一种节点表示的函数，这样就可以快速得到未知结点的表示。</p><p>简单来说：学习每个结点的特征如何由邻居的特征聚合而来，学到聚合函数后，只要已知新节点的特征和邻边关系，就能得到表示，并且这个表示会由于图结构的变化而变化，是动态的。</p><p>前向传播是为了生成结点的向量表示，<br /><img src="https://img-blog.csdnimg.cn/20210207163418476.png"alt="在这里插入图片描述" /><br />如果聚合K次，就需要K个聚合函数，初始时每个结点的表示是原本的特征向量，对第k层，对结点v，先得到v的第k层结点的聚合表示，加上v在上一层的特征，最后得到v的最终表示。</p><p>以作者的图为例，<br /><img src="https://img-blog.csdnimg.cn/20210220111424640.png"alt="在这里插入图片描述" /><br />我觉得知乎上这张更清楚： <imgsrc="https://img-blog.csdnimg.cn/20210220111932548.png"alt="在这里插入图片描述" /><br />每一层的表示都是由上一层生成，与当前层其他节点无关。</p><p>由于需要学习参数，所以要设计损失函数。无监督学习的损失函数应该是让临近节点有相似的表示，有监督学习用cross-entropy即可。</p><p>聚合函数作者给了3种选择：</p><ol type="1"><li>Mean<br />取邻居的平均值</li><li>LSTM</li><li>Pooling</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Loss Function</title>
      <link href="/posts/loss-function/"/>
      <url>/posts/loss-function/</url>
      
        <content type="html"><![CDATA[<p>For binary classification (+1, -1), if we classify correctly then<span class="math inline">\(y\cdot f = y\cdot \theta^Tx\gt0\)</span>;otherwise <span class="math inline">\(y\cdot f =y\cdot\theta^Tx\lt0\)</span>. Thus we have following loss functions:</p><ul><li>0/1 loss<br /><span class="math inline">\(\min_\theta\sum_iL_{0/1}(\theta^Tx)\)</span>. We define <spanclass="math inline">\(L_{0/1}(\theta^Tx) =1\)</span> if <spanclass="math inline">\(y\cdot f \lt 0\)</span>, and <spanclass="math inline">\(=0\)</span> o.w. Non convex and very hard tooptimize.</li><li>Hinge loss<br />Upper Bound of 0/1 loss. Approximate 0/1 loss by <spanclass="math inline">\(\min_\theta\sum_i H(\theta^Tx)\)</span>. We define<span class="math inline">\(H(\theta^Tx) = max(0, 1 - y\cdotf)\)</span>. Apparently <span class="math inline">\(H\)</span> is smallif we classify correctly.</li><li>Logistic loss<br /><span class="math inline">\(\min_\theta \sum_i log(1+\exp(-y\cdot\theta^Tx))\)</span>.</li></ul><p>Fortunately, hinge loss, logistic loss and square loss are all convexfunctions. Convexity ensures global minimum and it's computationallyappealing. <img src="https://img-blog.csdnimg.cn/20210226181824674.png"alt="在这里插入图片描述" /> Figure 7.5 from Chris Bishop's PRML book.The Hinge Loss E(z) = max(0,1-z) is plotted in blue, the Log Loss inred, the Square Loss in green and the 0/1 error in black.</p><p>From the figure we can observe that the hard instance (near theboundary) will influence the loss function a lot so we need to make themodel robust and can deal with the hard ones.</p><p>For binary classification we can unify the two cases (classifycorrectly or not) by <span class="math inline">\(y\cdot f\)</span>, butfor multi-class classification (0, 1, 2, ..., k) we cannot unify all thecases. So we use cross-entropy as the loss.</p><p>There exists a vivid example for transform the target function: If anoisy picture is given, and want to output the clean one. Here the cleanone is hard to control so we can let the noise be the target functionand wo should minimize the amplitude of the noise. Thus the problembecomes controllable.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BusTub</title>
      <link href="/posts/bustub/"/>
      <url>/posts/bustub/</url>
      
        <content type="html"><![CDATA[<p>马上就要成为社畜啦，把之前没有学完的课重新捡起来。DB一直是个心结，两年前尝试学了CMU的课，后来没能坚持下去，现在特来填坑！</p><p>由于之前的Gradescope不再维护，因此可能会遇到<ahref="https://github.com/cmu-db/bustub/issues/227">亿些问题</a>，<ahref="https://github.com/nefu-ljw/database-cmu15445-fall2020">折腾了亿下</a>感觉很麻烦，就做2022年了。。</p><h2 id="homework-1">Homework 1</h2><p><ahref="https://15445.courses.cs.cmu.edu/fall2022/homework1/">hw1</a>是SQL练习题，</p><h2 id="c-primer">C++ Primer</h2><p>这个lab主要用来搭环境，熟悉C++ 17的一些Feature。</p><p>环境：WSL2，Ubuntu 18.04/20.04，终端科学上网</p><p>实现一个并发的字典树，有点tricky的是删除<code>key</code>时需要自底向上地递归，还需要学习下智能指针、<code>std::move</code>以及<code>std::forward</code>等特性。</p><h2 id="buffer-pool-manager">BUFFER POOL MANAGER</h2><p>整体要为<ahref="https://github.com/cmu-db/bustub">Bustub</a>做一个面向磁盘的存储管理系统：<img src="1.png" alt="在这里插入图片描述" /></p><p>第一次作业是要实现一个内存缓冲池：负责将物理页面在磁盘和主存之间移动，这样DBMS就可以支持比内存更大的数据库。缓冲池的操作对其它系统部件是透明的，比如系统通过唯一的页面标识符<code>page_id_t</code>向缓冲池要求访问页面，而不管页面是在内存中还是在磁盘上。</p><p>缓冲池的实现必须是线程安全的，多个线程同时访问时需要用latches保护（OS中叫locks）。<br />关于DBMS中的🔒：</p><ul><li>locks：高层次的逻辑原语，在事务的整个执行过程中保护数据库的内容（元组/表/数据库），可以rollback</li><li>latches：低层次的保护原语，DBMS用来保护内部数据结构的安全访问（hashtable, regions of memory），只在某个具体操作时使用，不可以rollback</li></ul><p>具体来说：有2部分：LRU替换策略+缓冲池管理</p><ul><li>LRU<br />LRU的实现有多种方式：<br />1、数组+时间戳：每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。<br />2、双向链表：每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。<br />上面两种复杂度均是O(n)<br />3、双向链表+HashMap：当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。本质上是list看作时间戳，hashtable记录元素值到链表位置的映射关系，get和put均是O(1)。</li><li>缓冲池管理<br />缓冲池的组织形式是frame数目固定的数组，访问时将page从磁盘拷贝到frame。<br />与OS内存管理相似，也需要有page table记录哪些page在buffer pool中，page id-&gt; frame id；page directory记录了磁盘上的位置，page id -&gt; pagelocations in disk。<br />还需要有dirty位以及pin/refcounter记录当前正在访问的线程数目，只有flush或者置换脏页时才写回磁盘。<img src="https://img-blog.csdnimg.cn/2021022523062865.png"alt="在这里插入图片描述" />缓冲池和<code>Replacer</code>的大小是相同的，如果page的refcounter变为0时就可以加入到<code>Replacer</code>中作为替补牺牲页面。</li></ul><p>从缓冲池中根据ID fetch的时候有3种情况：</p><ol type="1"><li>如果page在缓冲池，直接返回；</li><li>如果不在，但缓冲池有空闲frame，从磁盘读取page放入该frame；</li><li>如果不在且缓冲池没有空闲frame，从buffer中牺牲一页，从磁盘读取page放入对应的frame。</li></ol><p>第一次提交忘了处理并发问题，只得了65分： <imgsrc="https://img-blog.csdnimg.cn/20210209211524362.png"alt="在这里插入图片描述" /><br />加了一些🔒后，还有2个test挂了：<br /><img src="https://img-blog.csdnimg.cn/20210209215248107.png"alt="在这里插入图片描述" /></p><p><code>isdirty</code>一直过不去，后来在群里看到：只有page当前的脏位是false且传入<code>is_dirty==true</code>时才需要修改当前的脏位。这里我是这么理解的：如果页面应该标记为dirty那么传入的参数就是true：</p><ul><li>当前为true &amp;&amp;<code>is_dirty==true</code>：页面修改过，也做了正确标记，不用管；</li><li>当前为false &amp;&amp;<code>is_dirty==true</code>：页面其实修改过，但没有标记，改正；</li><li>当前为false &amp;&amp;<code>is_dirty==false</code>：页面没修改，标记正确，不用管；</li><li>当前为true &amp;&amp;<code>is_dirty==false</code>：页面没修改，标记为修改过，这种也不用管，大不了置换时写回磁盘耗费些时间。<img src="https://img-blog.csdnimg.cn/20210210204925713.png"alt="在这里插入图片描述" /><br />数据库真的太难了，尤其是涉及到并发控制的部分，我真的没有足够时间去debug这些，以后有空再继续做吧。。</li></ul><h2 id="b-tree">B+ TREE</h2><h2 id="query-execution">QUERY EXECUTION</h2><h2 id="concurrency-control">CONCURRENCY CONTROL</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flow Control &amp; Congestion Control</title>
      <link href="/posts/flow-and-congestion-control/"/>
      <url>/posts/flow-and-congestion-control/</url>
      
        <content type="html"><![CDATA[<p>In order to make sure that every packet reaches its destination, weuse Retransmit. There are 3 approaches: Stop-and-Wait, Go Back N andSelective Repeat.</p><ul><li>Stop-and-Wait<br />Sender transmits packet one by one, label each with a sequence numberand sets timer after transmitting. If receive ACK, send next. If timergoes off, resend the previous packet.<br />When receive packet, send ACK. If packet is corrupted, ignore it andsender will resend.</li><li>SR<br />Send packets from the window and set timeout for each packet. Onreceiving ACK for left side of the window, slide forward and sendpackets that have now entered the window. On timeout, resend only thetimed out packet.<br />Receiver keeps a buffer of size of the window. On receiving packets,send ACK. If packet comes in out of order, just store it in the bufferand send ACK anyway.</li></ul><h2 id="how-big-should-we-size-the-senders-window">How big should wesize the sender's window</h2><p>Don't overload the receiver. Sender cannot send as fast as possiblesince it will overflow the receiver's buffer.<br /><img src="https://img-blog.csdnimg.cn/20200417151819468.png"alt="在这里插入图片描述" /><br />The solution is Advertised Window (W): tell the sender how much spacethe receiver's buffer has through ACK. So the window size of the sender:the size &lt;= W. Thus we won't overload the receiver. This is FlowControl.</p><p>But if we set the size to W, we cannot solve the problemthoroughly:<br /><img src="https://img-blog.csdnimg.cn/2021022516554078.png"alt="在这里插入图片描述" /><br />Sender's window contains a set of packets that have been transmitted butnot yet acked. But some packets will get dropped at router and senderwill never receive ACKs for these packets. The result is these packetswill remain buffered in the window. It means that we cannot set the sizeto W, we only want to send at 50Mbps. It will take a RTT(200ms) toreceive an ACK back for the first packet. We will send 50*200=1.25MBdata and that's exactly the definition of the sender's window.</p><p>The window size of the sender should &lt;= bandwidth-delay product(BDP). Thus we won't overload the network. This is Congestion Control.BDP is the "volume" of the link, the amount of data that can be "inflight" at any time.</p><h2 id="how-should-we-determine-the-bdp">How should we determine theBDP</h2><p>Things are much harder to calculate the BDP:</p><ul><li>We don't know the bandwidth or RTT</li><li>My share of bandwidth is dependent on the other user on the network,so the window size will change as other users start or stop sending</li><li>The router will stall the excess packets in the bottleneck queueinstead of dropping, so you can overshoot the size a little bit</li></ul><p>There are many algorithms to solve the problem given the priorconstraints. The old one is Reno, although no one uses it anymore,sigh!!</p><p>Use Multiplicative Increase at startup to find the right sending ratequickly, this process is called "slow start";<br />Then uses Additive Increase/Multiplicative Decrease (AIMD) to adjust thesending rate over time.<br /><img src="https://img-blog.csdnimg.cn/20210225174103869.png"alt="在这里插入图片描述" /></p><h2 id="reference">Reference</h2><p><a href="https://computer-networks.github.io/sp19/lectures.html">CMU15-441 TCP Part 2</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Entropy Model</title>
      <link href="/posts/maximum-entropy-model/"/>
      <url>/posts/maximum-entropy-model/</url>
      
        <content type="html"><![CDATA[<p>熵是对随机变量<strong>不确定性</strong>的度量，是对所有可能发生的事件产生的信息量的期望，没有外部能量输入的情况下，封闭系统趋向熵增。</p><p>信息熵指离散随机事件的出现概率：<spanclass="math inline">\(X={x_1,x_2,...,x_n}\)</span>，<spanclass="math inline">\(P(X=x_i)=p_i\)</span> <spanclass="math display">\[H(X)=-\sum_{i=1}^{n}p(x_i)log\ p(x_i)\]</span></p><p>Joint Entropy <span class="math display">\[H(X,Y)=-\sum_{i=1}^{n}\sum_{j=1}^{m}p(i,j)log\ p(i,j)\]</span></p><p><span class="math display">\[H(X|y_j)=-\sum_{i=1}^{n}p(x_i|y_j)log\ p(x_i|y_j)\]</span></p><p>按照<spanclass="math inline">\(Y\)</span>的各种情况进行加权平均，得条件熵<spanclass="math inline">\(H(X|Y)\)</span> <span class="math display">\[H(X|Y)=-\sum_{i=1}^{n}\sum_{j=1}^{m}p(y_j)p(x_i|y_j)log\p(x_i|y_j)=-\sum_{i=1}^{n}\sum_{j=1}^{m}p(x_i,y_j)log\ p(x_i|y_j)\]</span> 易证<spanclass="math inline">\(H(X|Y)=H(X,Y)-H(Y)\)</span></p><p>交叉熵，<span class="math inline">\(P(X)\)</span>和<spanclass="math inline">\(Q(X)\)</span>是<spanclass="math inline">\(X\)</span>的两个概率分布 <spanclass="math display">\[D_{KL}(P\ ||\ Q)=\sum_xP(x)log\frac{P(x)}{Q(x)}\]</span></p><p>互信息 <span class="math display">\[I(X,Y)=\sum_x\sum_yp(x,y)log\frac{p(x,y)}{p(x)p(y)}\]</span> 互信息就是联合分布<spanclass="math inline">\(P(X,Y)\)</span>和独立分布乘积<spanclass="math inline">\(P(X)P(Y)\)</span>的交叉熵。<br />易证<span class="math inline">\(I(X,Y)=H(X)+H(Y)-H(X,Y)\)</span></p><p>直观上看：在已知部分知识的前提下，对于未知分布最合理的推断就是符合已知且最不确定的推断，整个系统趋向于无序，熵最大。<br />在一定<strong>约束条件</strong>下，使得<spanclass="math inline">\(H(X|Y)\)</span>最大。 <spanclass="math display">\[p^*={\underset {p\in P}{\operatorname {arg\,max}}}\,-\sum_{i=1}^{n}\sum_{j=1}^{m}\bar p(y_j)p(x_i|y_j)log\ p(x_i|y_j)\]</span> 约束条件： <span class="math display">\[\sum_xp(x|y)=1 \\...\]</span> 又可以通过拉格朗日乘数法变为对偶问题求解。</p><p>由于无法求得解析解，只能用迭代法求数值解： <spanclass="math display">\[p^*(x|y)=\cfrac{1}{Z_\lambda(y)}e^{\sum_i\lambda_if_i(x,y)} \\Z_\lambda(y)=\sum_xe^{\sum_i\lambda_if_i(x,y)}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python FAQ</title>
      <link href="/posts/python-faq/"/>
      <url>/posts/python-faq/</url>
      
        <content type="html"><![CDATA[<h2 id="lambda表达式">lambda表达式</h2><p>对于一句话的函数，均可以用lambda表达式，一种语法糖。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x: x ** <span class="number">2</span></span><br><span class="line">g = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadratic</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: a*x*x + b*x + c</span><br><span class="line"></span><br><span class="line">f = quadratic(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">quadratic(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>)(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><h2 id="decorator">decorator</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># messy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    c = a + b</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(t2 - t1)</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><p>如果使用装饰器： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_time</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args</span>):</span></span><br><span class="line">        t1 = time.time()</span><br><span class="line">        res = func(*args)  <span class="comment"># do something</span></span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(t2 - t1)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@display_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">ans = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure></p><h2 id="gil">GIL</h2><p>是一个防止多线程并发执行的mutex，不是python的特性而是其解释器CPython引入的，使得在任何时刻仅有一个线程在执行，保证线程安全，但是影响多线程执行效能，无法利用多个CPU核心的优势。</p><h2 id="易错">易错</h2><p><ahref="https://stackoverflow.com/questions/51950193/python-a-b-b-a-implementation-how-is-it-different-from-c-swap-function"><code>a, b = b, a</code>赋值问题</a><br /><code>print(1 != 0 != 1)</code>输出<code>True</code>，因此不能用来判断3个数是否不等。</p><h2 id="basics">Basics</h2><ol type="1"><li>两个列表转字典：<code>dict(zip(list1, list2))</code></li><li><ahref="https://blog.csdn.net/weixin_37579123/article/details/89515577">Python中__new__()和__init__()的区别</a>：Python中的constructor是<code>__new__</code>，initializer是<code>__init__</code>。<code>__new__</code>首先被调用创建新实例并返回该实例，始终作为类的静态方法，类级别方法，默认调用父类的<code>__new__</code>构造该类的实例，也可以重写<code>__new__</code>，构造出来的对象取决于<code>__new__</code>，<code>__new__</code>返回什么就是什么；<code>__init__</code>没有返回值负责初始化创建的实例，实例级别方法，其<code>self</code>参数就是<code>__new__</code>返回的实例。</li><li><ahref="https://hj24.life/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E6%B5%85%E6%9E%90/">Python中的进程/线程/协程</a>：协程是比线程更小的执行单元，也叫微线程，用户态，在单线程上执行多个任务，一个任务等待时执行另一个任务，使用的内存动态变化，切换调度由用户控制，避免线程的系统级别切换的开销，内存利用率更高。Python的协程是1：N</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: cat&quot;, &quot;#2: dog&quot;, &quot;#3: monkey&quot;, each on its own line</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;person&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;cat&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spider&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal, legs <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A %s has %d legs&#x27;</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = &#123;<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: fish&quot;, &quot;#2: dog&quot;, &quot;#3: cat&quot;</span></span><br></pre></td></tr></table></figure><p>one of the most important differences is that tuples can be used askeys in dictionaries and as elements of sets, while lists cannot.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name  <span class="comment"># Create an instance variable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instance method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">self, loud=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> loud:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;HELLO, %s!&#x27;</span> % self.name.upper())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">g = Greeter(<span class="string">&#x27;Fred&#x27;</span>)  <span class="comment"># Construct an instance of the Greeter class</span></span><br><span class="line">g.greet()            <span class="comment"># Call an instance method; prints &quot;Hello, Fred&quot;</span></span><br><span class="line">g.greet(loud=<span class="literal">True</span>)   <span class="comment"># Call an instance method; prints &quot;HELLO, FRED!&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])   <span class="comment"># Create a rank 1 array</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))            <span class="comment"># Prints &quot;&lt;class &#x27;numpy.ndarray&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)            <span class="comment"># Prints &quot;(3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])   <span class="comment"># Prints &quot;1 2 3&quot;</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                  <span class="comment"># Change an element of the array</span></span><br><span class="line"><span class="built_in">print</span>(a)                  <span class="comment"># Prints &quot;[5, 2, 3]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])    <span class="comment"># Create a rank 2 array</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)                     <span class="comment"># Prints &quot;(2, 3)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])   <span class="comment"># Prints &quot;1 2 4&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>))   <span class="comment"># Create an array of all zeros</span></span><br><span class="line"><span class="built_in">print</span>(a)              <span class="comment"># Prints &quot;[[ 0.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  0.]]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))    <span class="comment"># Create an array of all ones</span></span><br><span class="line"><span class="built_in">print</span>(b)              <span class="comment"># Prints &quot;[[ 1.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">7</span>)  <span class="comment"># Create a constant array</span></span><br><span class="line"><span class="built_in">print</span>(c)               <span class="comment"># Prints &quot;[[ 7.  7.]</span></span><br><span class="line">                       <span class="comment">#          [ 7.  7.]]&quot;</span></span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)         <span class="comment"># Create a 2x2 identity matrix</span></span><br><span class="line"><span class="built_in">print</span>(d)              <span class="comment"># Prints &quot;[[ 1.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>))  <span class="comment"># Create an array filled with random values</span></span><br><span class="line"><span class="built_in">print</span>(e)                     <span class="comment"># Might print &quot;[[ 0.91940167  0.08143941]</span></span><br><span class="line">                             <span class="comment">#               [ 0.68744134  0.87236687]]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use slicing to pull out the subarray consisting of the first 2 rows</span></span><br><span class="line"><span class="comment"># and columns 1 and 2; b is the following array of shape (2, 2):</span></span><br><span class="line"><span class="comment"># [[2 3]</span></span><br><span class="line"><span class="comment">#  [6 7]]</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># A slice of an array is a view into the same data, so modifying it</span></span><br><span class="line"><span class="comment"># will modify the original array.</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;2&quot;</span></span><br><span class="line">b[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">77</span>     <span class="comment"># b[0, 0] is the same piece of data as a[0, 1]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;77&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two ways of accessing the data in the middle row of the array.</span></span><br><span class="line"><span class="comment"># Mixing integer indexing with slices yields an array of lower rank,</span></span><br><span class="line"><span class="comment"># while using only slices yields an array of the same rank as the</span></span><br><span class="line"><span class="comment"># original array:</span></span><br><span class="line">row_r1 = a[<span class="number">1</span>, :]    <span class="comment"># Rank 1 view of the second row of a</span></span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>, :]  <span class="comment"># Rank 2 view of the second row of a</span></span><br><span class="line"><span class="built_in">print</span>(row_r1, row_r1.shape)  <span class="comment"># Prints &quot;[5 6 7 8] (4,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(row_r2, row_r2.shape)  <span class="comment"># Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can make the same distinction when accessing columns of an array:</span></span><br><span class="line">col_r1 = a[:, <span class="number">1</span>]</span><br><span class="line">col_r2 = a[:, <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(col_r1, col_r1.shape)  <span class="comment"># Prints &quot;[ 2  6 10] (3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(col_r2, col_r2.shape)  <span class="comment"># Prints &quot;[[ 2]</span></span><br><span class="line">                             <span class="comment">#          [ 6]</span></span><br><span class="line">                             <span class="comment">#          [10]] (3, 1)&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># An example of integer array indexing.</span></span><br><span class="line"><span class="comment"># The returned array will have shape (3,) and</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The above example of integer array indexing is equivalent to this:</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When using integer array indexing, you can reuse the same</span></span><br><span class="line"><span class="comment"># element from the source array:</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Equivalent to the previous integer array indexing example</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">1</span>], a[<span class="number">0</span>, <span class="number">1</span>]]))  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new array from which we will select elements</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[ 1,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5,  6],</span></span><br><span class="line">          <span class="comment">#                [ 7,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 11, 12]])&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array of indices</span></span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select one element from each row of a using the indices in b</span></span><br><span class="line"><span class="built_in">print</span>(a[np.arange(<span class="number">4</span>), b])  <span class="comment"># Prints &quot;[ 1  6  7 11]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mutate one element from each row of a using the indices in b</span></span><br><span class="line">a[np.arange(<span class="number">4</span>), b] += <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[11,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5, 16],</span></span><br><span class="line">          <span class="comment">#                [17,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 21, 12]])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>)   <span class="comment"># Find the elements of a that are bigger than 2;</span></span><br><span class="line">                     <span class="comment"># this returns a numpy array of Booleans of the same</span></span><br><span class="line">                     <span class="comment"># shape as a, where each slot of bool_idx tells</span></span><br><span class="line">                     <span class="comment"># whether that element of a is &gt; 2.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bool_idx)      <span class="comment"># Prints &quot;[[False False]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We use boolean array indexing to construct a rank 1 array</span></span><br><span class="line"><span class="comment"># consisting of the elements of a corresponding to the True values</span></span><br><span class="line"><span class="comment"># of bool_idx</span></span><br><span class="line"><span class="built_in">print</span>(a[bool_idx])  <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can do all of the above in a single concise statement:</span></span><br><span class="line"><span class="built_in">print</span>(a[a &gt; <span class="number">2</span>])     <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)         <span class="comment"># Prints &quot;int64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)             <span class="comment"># Prints &quot;float64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)   <span class="comment"># Force a particular datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)                         <span class="comment"># Prints &quot;int64&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise sum; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 6.0  8.0]</span></span><br><span class="line"><span class="comment">#  [10.0 12.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise difference; both produce the array</span></span><br><span class="line"><span class="comment"># [[-4.0 -4.0]</span></span><br><span class="line"><span class="comment">#  [-4.0 -4.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x - y)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise product; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 5.0 12.0]</span></span><br><span class="line"><span class="comment">#  [21.0 32.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x * y)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise division; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 0.2         0.33333333]</span></span><br><span class="line"><span class="comment">#  [ 0.42857143  0.5       ]]</span></span><br><span class="line"><span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="built_in">print</span>(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise square root; produces the array</span></span><br><span class="line"><span class="comment"># [[ 1.          1.41421356]</span></span><br><span class="line"><span class="comment">#  [ 1.73205081  2.        ]]</span></span><br><span class="line"><span class="built_in">print</span>(np.sqrt(x))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inner product of vectors; both produce 219</span></span><br><span class="line"><span class="built_in">print</span>(v.dot(w))</span><br><span class="line"><span class="built_in">print</span>(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / vector product; both produce the rank 1 array [29 67]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(v))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / matrix product; both produce the rank 2 array</span></span><br><span class="line"><span class="comment"># [[19 22]</span></span><br><span class="line"><span class="comment">#  [43 50]]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(y))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, y))</span><br></pre></td></tr></table></figure><h2 id="问题">问题</h2><p>遇到一个问题： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            nums.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        </span><br><span class="line">        inorder(proot)</span><br></pre></td></tr></table></figure> 这段代码不会报错，但是如果：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cnt, ans = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == k:</span><br><span class="line">                ans = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.right)</span><br></pre></td></tr></table></figure>就会报错<code>UnboundLocalError: local variable 'cnt' referenced before assignment</code>不太理解为啥list没事，后来<ahref="https://stackoverflow.com/questions/2609518/unboundlocalerror-with-nested-function-scopes">SO</a>上的回答我大概明白了：python通过赋值操作来判断是否是局部变量，但是nums的append不是赋值，因此只要不在嵌套函数里赋值都不会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>()</span><br><span class="line">b = &#123;&#125;</span><br><span class="line">c = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A new classification algorithm recommendation method based on link prediction</title>
      <link href="/posts/link-prediction/"/>
      <url>/posts/link-prediction/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要还是在元模型上创新，采用基于链接预测的方式为新数据集推荐分类算法。基本框架如下：<br /><img src="https://img-blog.csdnimg.cn/20210127113628615.png"alt="在这里插入图片描述" /><br />用元学习做AutoML主要关注：元特征、元目标的表现形式、元模型。 ## 元特征第一步包括提特征和识别可用算法。<br />目前流行的元特征有5种：</p><ul><li>statistical and information-theory based</li><li>model structure based</li><li>landmarking</li><li>problem-complexity</li><li>structural information</li></ul><p>由于每个数据集可能有不定数目的可用算法，文章采用了multiple comparisonprocedure：如果我们用acc作为衡量标准（除此以外本文还用了ARR作为标准，将时间因素也考虑进去），这个程序能用统计检验的方法发现一系列与最佳算法相差不显著的候选算法。文中具体使用的统计检验方法是FriedmanTest+Holm procedure test，即如果FriedmanTest认为所有算法性能相差不显著，那么所有的算法都是metatarget；否则以表现最佳的算法为参考，用Holm proceduretest去识别和最佳算法没有显著差异的算法们作为meta target。<br />这样就得到了元数据<spanclass="math inline">\(M=\{m_1,...,m_n\},m_i=&lt;x_i,y_i&gt;\)</span>，其中<spanclass="math inline">\(x_i=(f_{i1},...,f_{ip})\)</span>是该数据集的p个元特征，<spanclass="math inline">\(y_i=(a_1,...,a_q)\)</span>是q个合适的算法。</p><h2 id="元目标形式">元目标形式</h2><p>有4种：</p><ul><li>单标签</li><li>多标签</li><li>连续值：预测算法的表现，回归问题</li><li>排序：预测算法之间的相对顺序</li></ul><h2 id="元模型">元模型</h2><ul><li>分类</li><li>回归</li><li>ranking</li></ul><p>本文将问题看作多标签分类，并采用DAR图+链接预测作为分类模型。<br />建的是一个异构图，有数据集（元特征作为结点属性）和算法（算法名作为属性）两种结点，有d-d和d-a两种无向边，d-d边的构建通过数据集间的相似性（<strong>欧氏距离</strong>最近的k个邻居，需要将元特征标准化min-maxscaling），d-a边就用每个数据集的候选算法构建。<br />建图的伪代码：<br /><img src="https://img-blog.csdnimg.cn/2021012815482635.png"alt="在这里插入图片描述" /><br />建好图后就可以推荐了，伪代码如下：<br /><img src="https://img-blog.csdnimg.cn/20210128161524948.png"alt="在这里插入图片描述" /><br />文章里LPMethod有3种：Katz,LRW,SRW。<br />综上，预测时需要的参数有：训练集<spanclass="math inline">\(D=\{d_1,...,d_n\}\)</span>，候选算法集<spanclass="math inline">\(A=\{a_1,..,a_m\}\)</span>，推荐的算法数目，每个数据集结点的邻边数目<spanclass="math inline">\(k\)</span>。</p><h2 id="评估">评估</h2><p>评估指标包括5个：Hamming损失、F值、acc、HitRatio、RA（推荐准确率）。<br />考虑DAR图的边的权重，类似概率图模型</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper </tag>
            
            <tag> AutoML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Climbing Summary</title>
      <link href="/posts/climbing-summary/"/>
      <url>/posts/climbing-summary/</url>
      
        <content type="html"><![CDATA[<p>看完<em>Everest</em>之后，我也做着有朝一日登顶珠峰的白日梦。懒癌晚期也没爬过几座山，希望有机会挑战下雪山（嘿！又一个雄心勃勃的flag）。</p><ul><li>骊山<br />没什么好说的，海拔1300+，高中翻个墙就是山路，基本没有难度。</li><li>太白山<br />很冷，海拔3700+，6月上到峰顶还是很冷，只有下面是旅游开发区，上面一大部分路段都没有开发，只是用石头简单铺了，手机没有信号，基本没有歇脚的地，风吹得你怀疑人生。</li><li>华山<br />海拔2100+，夏天上去完全不用外套，注意防晒，爬起来也没啥难度，基本开发地都不错，只是很多地方非常险峻，比如鹞子翻身、大索道，听说还有完全透明的那种。<br /><img src="https://img-blog.csdnimg.cn/20200829222658646.png"alt="在这里插入图片描述" /><br />路线很多，随你怎么走了。<br />我们是前一天晚上到华山北站，休息一晚，然后游客中心-&gt;北峰索道-&gt;北峰-&gt;中峰-&gt;东峰-&gt;南峰-&gt;西峰-&gt;西峰索道-&gt;游客中心，本来想走玉泉院徒步上去，但是人家关闭了，而且一天时间也不够，晚上在华山北休息了一晚，第三天早上回西安。<br />我觉得最刺激的有几处：<br />很多地方都有那种近乎于垂直的台阶，甚至有超过90度的，反正我上到一半就撤了。。<br />鹞子翻身：没敢玩<br />长空栈道：没敢去<br />西峰索道：下行20min，真刺激，山谷间吹个小风，索道就左右飘~</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MLE &amp; MAP</title>
      <link href="/posts/mle-and-map/"/>
      <url>/posts/mle-and-map/</url>
      
        <content type="html"><![CDATA[<p>自从贝叶斯理论诞生以后，频率学派和贝叶斯学派的争论一直没有停歇，平时的学习太注重公式计算，故在此谈谈自己对贝叶斯理论的一些认识。</p><p>频率学派认为概率是基于大量实验所得的定值（大数定理），比如抛掷一枚材质均匀的硬币10000次，出现正面的次数有4995次，反面的次数有5005次，大致认为出现正反面的概率都是50%。然而现实生活中很多事情是无法做大量实验的，比如某人得心脏病的概率是5%，显然我们无法通过多次实验来计算出这个概率值。回到硬币的例子，如果只允许你抛5次，5次的结果都是正面，那么出现正面的概率是100%了吗？显然这是存在弊端的。</p><p>再来看一个非常经典的医学上的例子：有一种很稀有的病，得病的人检测结果呈阳性的概率是0.9，没得病的人检测结果呈阴性的概率也是0.9，人们患这种病的概率是0.01。如果某人的检测结果呈阳性，那么他患这种病的概率是多少？</p><p>直观上看：患病的人检测呈阳性的概率是0.9，这个人被检测为阳性，那么有很大概率这个人是患病的。不妨试着算算：</p><p>假设用A表示检测结果为阳性，B表示患病，那么可以很轻松的计算出： <spanclass="math display">\[P(B|A)=\frac{P(A|B)P(B)}{P(A)}=\frac{P(A|B)P(B)}{P(A|B)P(B)+P(A|\barB)P(\bar B)}=\frac{0.9*0.01}{0.9*0.01+0.1*0.99}=0.083 \\P(\bar B|A)=1-P(B|A)=0.917\]</span>可以看到：即使检测结果呈阳性，患病的概率仍然只有8.3%，和我们的直观认识并不相同。</p><p>上面的计算其实就用了贝叶斯公式：后验概率<spanclass="math inline">\(P(B|A)\)</span>等于条件概率<spanclass="math inline">\(P(A|B)\)</span>（似然函数）乘以先验概率<spanclass="math inline">\(P(B)\)</span>，再除以一个常数因子。我们在已知先验概率的前提下，通过新的观测值<spanclass="math inline">\(P(A|B)\)</span>（检测结果是否阳性）来预测患病的概率。</p><p>关于常数因子<spanclass="math inline">\(P(A)\)</span>可以这样理解：分子<spanclass="math inline">\(P(A,B)\)</span>表示检测结果呈阳性并且患病的概率，那么还有一部分人<spanclass="math inline">\(P(A,\barB)\)</span>检测结果呈阳性但是没有患病，<spanclass="math inline">\(P(A,B)+P(A,\bar B)=P(A)\)</span>，我们要求的<spanclass="math inline">\(P(B|A)\)</span>即检测呈阳性的人中患病的人所占的比例<spanclass="math inline">\(\frac{P(A,B)}{P(A)}\)</span>。</p><p>更加一般的贝叶斯公式：</p><p>如果参数<span class="math inline">\(\theta\)</span>的分布是离散的：<span class="math display">\[\pi(\theta_i|x)=\cfrac{\pi(\theta_i)f(x|\theta_i)}{\sum_{i}\pi(\theta_i)f(x|\theta_i)}\]</span> 如果参数<spanclass="math inline">\(\theta\)</span>的分布是连续的： <spanclass="math display">\[\pi(\theta|x)=\cfrac{\pi(\theta)f(x|\theta)}{\int_{\Theta}\pi(\theta)f(x|\theta)d\theta}\]</span> 后验概率密度表示在已知x的前提下关于参数<spanclass="math inline">\(\theta\)</span>的一个概率密度函数，即<spanclass="math inline">\(\theta\)</span>是一个分布，而不是一个固定的值，这是贝叶斯学派与传统学派最大的不同。</p><p>似然函数<spanclass="math inline">\(f(x|\theta)\)</span>可以这么理解：每个事件的背后都有一个分布，这个分布里是含有参数的，并且传统学派认为这个参数<spanclass="math inline">\(\theta\)</span>是固定的，我们做了大量的实验，用很多样本x就是为了求出这个参数的值，观测到的样本x是以参数<spanclass="math inline">\(\theta\)</span>为前提的一个分布。为了估计<spanclass="math inline">\(\theta\)</span>，我们用到了<strong>矩估计</strong>和<strong>极大似然估计</strong>，本质上都是一样的，我们在参数<spanclass="math inline">\(\theta\)</span>的前提下，从总体X中采样n个样本，用样本的性质来大致替代总体的参数<spanclass="math inline">\(\theta\)</span>。具体到极大似然：通过找到使似然函数<spanclass="math inline">\(\prod_{i=1}^{n}f(x_i|\theta)\)</span>最大的参数当作<spanclass="math inline">\(\theta\)</span>，其实就是选择一个<spanclass="math inline">\(\theta\)</span>使得样本出现的概率最大，本质上仍然是在拟合样本数据。</p><p>从上面的分析可以看出：我们的未知参数<spanclass="math inline">\(\theta\)</span>是从样本中计算得到的，必然和总体中原本的参数值存在误差，并且只能求得一个固定的参数值。贝叶斯理论认为：参数<spanclass="math inline">\(\theta\)</span>不应该是一个单独的值，更加合理的解释应该是参数<spanclass="math inline">\(\theta\)</span>有很多取值，并且每个取值都有相应的概率，即参数是服从某种分布的。概率最大的那个参数值即<strong>最大后验估计</strong>，参数取值的中位数即<strong>后验中位数估计</strong>，参数取值的均值即<strong>后验期望估计</strong>。为什么仍然叫估计呢？因为我们的后验分布是从似然计算得到的，我们无法采样所有的总体中的样本，所以也就无法计算出参数<spanclass="math inline">\(\theta\)</span>的精确分布。</p><p>最后来看看先验分布<spanclass="math inline">\(\pi(\theta)\)</span>，即在获得实验观测值之前对未知参数分布的一个主观认识，这也是贝叶斯学派一直被攻击的一点，客观的统计学中竟然引入了主观的因素！比如对于材质均匀的硬币，在抛掷之前，我们脑海中就会认为出现正反面的概率各是0.5。</p><p>但是很多时候先验分布是很难获得的，如果硬币材质不均匀，我们的先验又应当是什么分布呢？此时就引入了课程上讲的<strong>无信息先验</strong>，当我们对事件没有了解的时候，认为参数所有取值的概率都是相等的，在硬币实验中，我们认为<spanclass="math inline">\(\theta\)</span>是服从(0,1)的均匀分布。接着我们来做实验，看看后验分布会怎么变化（图源：CameronDavidson-Pilon, Probabilistic Programming and Bayesian Methods forHackers, 2016）：</p><figure><imgsrc="https://img-blog.csdnimg.cn/img_convert/11e883581dd48f9c8442b8273371766d.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://img-blog.csdnimg.cn/img_convert/3110af9ecffd601bb7acd89d86ad9784.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>从图中可以看出：起初是均匀分布，连续抛掷了2次正面，此时认为该硬币正面向上的概率为1的可能性是最大的，但注意：正面向上的概率取0.6,0.4的可能也不是没有，不过这种可能性更小罢了。如果我们用极大似然去估计，就会得到该硬币正面向上的概率是1，正面向上的概率取0.6,0.4的可能为0，这显然与现实不符！接着抛了一次反面，正面向上的概率分布又进行了修正，不断通过观测值修正我们的后验，最终得到一个稳定的后验分布。</p><p>均匀分布<spanclass="math inline">\(U(a,b)\)</span>作为先验看起来很好用，但是他本质上还是有倾向性的，即认为在区间(a,b)内是有取值的，在区间外是没有取值的可能的，更加合理的无信息先验可以选取一个大方差的高斯分布。</p><p>选择高斯分布作为先验带来的一个问题是计算上的复杂性骤然提高，所以引入了<strong>共轭先验分布</strong>：即后验分布<spanclass="math inline">\(\pi(\theta|x)\)</span>与先验分布<spanclass="math inline">\(\pi(\theta)\)</span>是同一种类型的分布，就称先验分布<spanclass="math inline">\(\pi(\theta)\)</span>是<spanclass="math inline">\(f(x|\theta)\)</span>的共轭先验分布。这样我们在计算后验分布时，就无需计算复杂的积分，只要调整先验分布的参数即可确定后验分布。可以证明：<spanclass="math inline">\(\beta\)</span>分布是二项分布<spanclass="math inline">\(B(n,p)\)</span>中参数<spanclass="math inline">\(p\)</span>的共轭先验分布。即如果总体<spanclass="math inline">\(X|\theta\simB(N,\theta)\)</span>，从中采样n个样本，样本分布即似然函数<spanclass="math inline">\(f(x|\theta)\)</span>服从<spanclass="math inline">\(\beta\)</span>分布，假设先验<spanclass="math inline">\(\theta\sim\beta(a,b)\)</span>，那么后验分布<spanclass="math inline">\(\theta|x\sim\beta(a+\sum x_i,b+nN-\sumx_i)\)</span>。</p><p>证明： 总体<span class="math inline">\(X|\theta\simB(N,\theta)\)</span>，先验<spanclass="math inline">\(\theta\sim\beta(a,b)\)</span>，<spanclass="math inline">\(X=(X_1,...,X_n)^T\)</span>是来自总体的n个样本，则样本分布为：<span class="math display">\[p(x|\theta)=L(\theta)=\prod_{i=1}^{n}\tbinom{N}{x_i}\theta^{x_i}(1-\theta)^{N-x_i}\propto\theta^{\sum_{i=1}^{n}x_i}(1-\theta)^{nN-\sum_{i=1}^{n}x_i}\]</span> 可以看到：似然函数<spanclass="math inline">\(L(\theta)\)</span>具有<spanclass="math inline">\(\beta\)</span>分布的核，先验的核为<spanclass="math inline">\(\theta^{a-1}(1-\theta)^{b-1}\)</span>，所以后验为：<span class="math display">\[\pi(\theta|x)\propto\theta^{a-1+\sum_{i=1}^{n}x_i}(1-\theta)^{b-1+nN-\sum_{i=1}^{n}x_i},0&lt;\theta&lt;1\]</span> 显然后验分布的核与<spanclass="math inline">\(\beta\)</span>分布的核是同种类型，即<spanclass="math inline">\(\theta|x\sim\beta(a+\sum x_i,b+nN-\sumx_i)\)</span>，所以<spanclass="math inline">\(\beta\)</span>分布是二项分布<spanclass="math inline">\(B(n,p)\)</span>中参数<spanclass="math inline">\(p\)</span>的共轭先验分布。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率统计基础</title>
      <link href="/posts/probability-and-statistics-basics/"/>
      <url>/posts/probability-and-statistics-basics/</url>
      
        <content type="html"><![CDATA[<p>联合概率<spanclass="math inline">\(P(A,B)\)</span>即两个事件同时发生的概率条件概率（后验概率）<spanclass="math inline">\(P(A|B)P(B)=P(B|A)P(A)\)</span> 全概率公式 <spanclass="math display">\[P(A)=\sum_nP(A,B_n)=\sum_nP(A|B_n)P(B_n)\]</span> 贝叶斯定理： <span class="math display">\[P(A|B)=\frac{P(B|A)P(A)}{P(B)}\]</span> <spanclass="math inline">\(A\)</span>的后验概率等于标准相似度乘以先验概率</p><p>离散型随机变量概率分布（分布律）： |<spanclass="math inline">\(X\)</span>| <spanclass="math inline">\(x_1\)</span>|...|<spanclass="math inline">\(x_i\)</span>|... |--|--|--|--|--| | <spanclass="math inline">\(P\)</span>| <spanclass="math inline">\(p_1\)</span>|...|<spanclass="math inline">\(p_i\)</span>|... 满足<spanclass="math inline">\(p_i\geq0, \sum_{i=1}^{\infty}p_i=1\)</span></p><p>0-1分布：<span class="math inline">\(X\sim B(1,p)\)</span> |<spanclass="math inline">\(X\)</span>| 0|1| |--|--|-- |<spanclass="math inline">\(P\)</span>|<spanclass="math inline">\(1-p\)</span>|<spanclass="math inline">\(p\)</span>| <span class="math display">\[P(X=k)=p^k(1-p)^{1-k},k=0,1\]</span></p><p>二项分布：<span class="math inline">\(X\sim B(n,p)\)</span> <spanclass="math inline">\(n\)</span>重伯努利试验 <spanclass="math display">\[P(X=k)=C_n^kp^k(1-p)^{n-k},k=0,1,...,n\]</span></p><p>Poisson分布：<span class="math inline">\(X\sim P(\lambda)\)</span><span class="math display">\[P(X=k)=\frac{\lambda^ke^{-\lambda}}{k!},k=0,1,...,n,\lambda&gt;0\]</span> <span class="math inline">\(E(X)=\lambda,D(X)=\lambda\)</span>可以证明：Poisson分布是二项分布在<spanclass="math inline">\(\lambda=np,n\to\infty\)</span>的极限分布。</p><p>连续型随机变量概率分布函数：<spanclass="math inline">\(F(x)=\int_{-\infty}^{x}f(t)dt\)</span>，<spanclass="math inline">\(f(x)\)</span>称为概率密度函数。 均匀分布：<spanclass="math inline">\(X\sim U(a,b)\)</span> <spanclass="math display">\[f(x)=\begin{cases}\cfrac{1}{b-a}, &amp;x\in(a,b)\\0, &amp;其它\end{cases}\]</span> 指数分布：<span class="math inline">\(X\simE(\lambda)\)</span> <span class="math display">\[f(x)=\begin{cases}\lambda e^{-\lambda x}, &amp;x&gt;0\\0, &amp;x\leq0\end{cases}\]</span> 正态分布（高斯分布）：<span class="math inline">\(X\simN(\mu,\sigma^2)\)</span> <span class="math display">\[f(x)=\cfrac{1}{\sigma \sqrt{2\pi}}e^{-\cfrac{(x-\mu)^2}{2\sigma^2}}\]</span> <spanclass="math inline">\(\mu\)</span>是位置参数，决定对称轴位置；<spanclass="math inline">\(\sigma\)</span>是尺度参数，决定分布的幅度。标准正态分布<span class="math inline">\(X\sim N(0,1)\)</span></p><p>数学期望： 离散型：<spanclass="math inline">\(E(X)=\sum_ip_ix_i\)</span> 连续型：<spanclass="math inline">\(E(X)=\int_{-\infty}^{+\infty}xf(x)dx\)</span></p><p>方差：随机变量的离散程度，距离期望的距离 <spanclass="math inline">\(D(X)=E[(X-E(X))^2]=E(X^2)-E(X)^2\)</span> <spanclass="math display">\[D(X)=\cfrac{1}{N}\sum_{i=1}^{N}(x_i-\mu)^2=\cfrac{1}{N}(\sum_{i=1}^{N}x_i^2-N\mu^2)\]</span>离散型：<spanclass="math display">\[D(X)=\sum_{i=1}^{\infty}[x_i-E(X)]^2p_i\]</span>连续型：<spanclass="math display">\[D(X)=\int_{-\infty}^{+\infty}[x-E(X)]^2f(x)dx\]</span></p><p>标准差（均方差）是方差的算术平方根</p><p>样本标准差： <spanclass="math display">\[s=\sqrt{\cfrac{1}{n-1}\sum_{i=1}^{n}(x_i-\barx)^2}\]</span> 对于二维随机变量，协方差用来描述<spanclass="math inline">\(X\)</span>与<spanclass="math inline">\(Y\)</span>之间的相互关系： <spanclass="math display">\[Cov(X,Y)=E\{[X-E(x)][Y-E(Y)]\}\]</span></p><p>相关系数： <span class="math display">\[\rho_{XY}=\cfrac{Cov(X,Y)}{\sqrt{D(X)D(Y)}}\]</span></p><p>de Movire-Laplace中心极限定理： <spanclass="math inline">\(n_A\)</span>为<spanclass="math inline">\(n\)</span>重伯努利试验中<spanclass="math inline">\(A\)</span>发生的次数，<spanclass="math inline">\(P(A)=p\)</span>，对任意实数<spanclass="math inline">\(x\)</span>，有： <span class="math display">\[\lim\limits_{n\to+\infty}P(\cfrac{n_A-np}{\sqrt{np(1-p)}}\leqx)=\int_{-\infty}^{x}\cfrac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}dt=\Phi(x)\]</span> <span class="math inline">\(n\)</span>充分大时，<spanclass="math inline">\(n_A\sim N(np,np(1-p))\)</span>，故： <spanclass="math display">\[P(a&lt;n_a\leq \]</span>="" <spanclass="math inline">\(n\)</span>充分大时，<spanclass="math inline">\(\sum_{i=&quot;1}^{n}X_i\sim&quot;\cfrac{\sqrt{n}(\bar=&quot;&quot;\lim\limits_{n\to+\infty}p(|\cfrac{n_x}{n}-p|&lt;\epsilon)=&quot;1&quot;b)\approx\phi(\cfrac{b-n\mu}{\sqrt{n}\sigma})-\phi(\cfrac{a-n\mu}{\sqrt{n}\sigma})=&quot;&quot;b)\approx\phi(\cfrac{b-np}{\sqrt{np(1-p)}})-\phi(\cfrac{a-np}{\sqrt{np(1-p)}})=&quot;&quot;n(0,1)=&quot;&quot; n(0,1)\)</span>，即：="" n(0,1)<spanclass="math inline">\(，故：=&quot;&quot;n(n\mu,n\sigma^2)\)</span>，<spanclass="math inline">\(y_n\sim=&quot;&quot;p(a&lt;\sum_{i=&quot;1}^{n}X_i\leq&quot;x-\mu)}{\sigma}\sim=&quot;&quot;y_n=&quot;\cfrac{\sum_{i=1}^{n}X_i-n\mu}{\sqrt{n}\sigma}&quot;中心极限定理表明：任意的一个概率分布中生成的随机变量，其序列和统一地归约到正态分布：\)</span>y_n=""伯努利大数定律：事件<spanclass="math inline">\(x\)</span>在每次试验中发生概率是<spanclass="math inline">\(p\)</span>，<spanclass="math inline">\(n\)</span>次独立重复试验中，<spanclass="math inline">\(x\)</span>发生的次数为<spanclass="math inline">\(n_x\)</span>，则：=""即事件的发生频率依概率收敛于事件的概率。="" 独立同分布中心极限定理：=""辛钦大数定律：<spanclass="math inline">\(x_i\)</span>为独立同分布的随机变量序列，且期望<spanclass="math inline">\(\mu\)</span>存在，则对<spanclass="math inline">\(\forall\epsilon=&quot;&quot;随机变量\)</span>x_1,x_2,...,x_n,...<spanclass="math inline">\(独立同分布，\)</span>e(x_i)=",D(X_i)=^2<spanclass="math inline">\(，前\)</span>n<spanclass="math inline">\(个变量和的标准化变量为：&quot;&gt;0\)</span>，有：<span class="math display">\[\lim\limits_{n\to+\infty}P(|\cfrac{1}{n}\sum_{i=1}^{n}X_i-\mu|\geq\epsilon)=0\]</span></p><p>正太分布熵的大小，取决于方差的大小。&lt;/n_a&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逼乎摘选</title>
      <link href="/posts/zhihu-excerpt/"/>
      <url>/posts/zhihu-excerpt/</url>
      
        <content type="html"><![CDATA[<p><font size="2"><em>早已决定退乎，将一些曾经的收藏稍加整理摘录于此，均已注明出处，侵删</em></font></p><h2 id="多任务下如何保持高效率"><ahref="https://www.zhihu.com/question/374401049/answer/1055275763">多任务下如何保持高效率</a></h2><p>第一件事情，是想一想什么事情是自己应该做的，什么是要推给别人的，什么是要找人讨论再做，什么需要等一阵子的。这个是战略问题，比任何战术上的技巧都管用。多任务完成得再快，做自己不应该做或者不需要做的事情，只会累死累活还没什么用。</p><p>随时想着如果不玩这局棋了，把棋盘掀翻重来会是什么结果？也许会有更好的解法。</p><p>在这之后，再讨论战术。以下是一些应付多任务的具体方案：</p><ol type="1"><li>每做一个任务要百分百集中（比如说现在在写这个答案的时候，就不要写一半刷手机了）。</li><li>每个任务最好持续一段时间（我的经验是最少15分钟），切去一个需要一定脑力的任务，做5分钟再切回来基本上没有成功的例子。10分钟的任务除非在做之前有非常清楚的规划，不然要不什么事都没做成（比如说还在手忙地找浏览器里的相关标签页），要不因为专注而超时。</li><li>每个任务有非常明确的完成指标。比如说某个任务是代码能跑起来，文章的introduction看完，或是审完一篇论文并且写出评审建议。不完成不要停手。如果实在得要暂停（比如说得去开会），记得把完成指标再分得更细一些。</li><li>难的和简单的任务可以错开做。做完难的需要休息可以做些简单但不得不做的，做完简单的可以再切回难的（这样有挑战性）。如果发现自己并不需要休息就迫不及待地去做下一个任务了，说明任务安排得好。</li><li>不要安排得太满，不要要求每天都一定要全部完成。总会有完不成的事项。我觉得我每天订的TODOlist总有一两个没完成，然后就会发现，有些其实并不重要，有些其实挺重要但下意识逃避了，下次就要把它们拿出来第一个做完。</li><li>经常锻炼，充足睡眠，合理膳食，才能保持充沛精力。偶尔熬夜也许确实活多，但天天熬夜，就说明战略上有大问题了，身体不是这么玩的。</li></ol><h2 id="应届生是选择一个公司还是选择一个行业"><ahref="https://www.zhihu.com/question/27032313/answer/315544084">应届生是选择一个公司，还是选择一个行业</a></h2><p>人生的幸福，我的感觉来自自律，独立思考能力，控制住自己的欲望，保持对新事物的敏感度和参与度。</p><p>比选择行业更重要的是一个人独立思考能力，自己纠错，自己拯救自己的能力。</p><p>我混到今天一直在自己做决策，从大学填写志愿，到跳槽，找工作，做生意，都从来不问别人，都是自己研究琢磨。我也有问人的时候，但是我从来不问人生该怎么选择，我只问具体的技术性问题。</p><p>保持对物欲的控制，管理好自己，培养良好的习惯，我们可以摆脱很多不必要的麻烦。</p><h2 id="你生命中最艰难痛苦的一段时间是如何度过的"><ahref="https://www.zhihu.com/question/24917544/answer/154775610">你生命中最艰难、痛苦的一段时间是如何度过的</a></h2><p>对于我来说，从来没有觉得有什么最艰难和痛苦的日子。人生本来就是一场旅行，能够和爱的人在一起度过，又何必在意旅途的风景是什么风格。也许，这场旅途对于我来说，只是可能比父母和孩子早下车几站而已。</p><p>当你用心拼尽全力过好每一天，会发现早死晚死都是一种平淡无奇的结果，艰难困苦只是自己给自己懦弱和懒惰的开脱词。祝尚有余生的各位安好。</p><h2 id="活着不开心怎么办"><ahref="https://www.zhihu.com/question/29956916/answer/311913864">活着不开心怎么办</a></h2><p>如何减少不开心？一是别瞎去比较，人确实都有损失厌恶，但你如果不主动去做一些无谓的比较，就能让自己舒服很多；另一个是别瞎揣摩别人，别因为不理解别人，而给自己制造不必要的不快。</p><p>说完这两点还没完，因为它俩都属于“别做什么”，还要再聊一点“要做什么”。</p><p>要自在如风，要在不违反法律、不伤风败俗的前提下去尽情享受生活，享受自由。</p><p>我以前觉得那些走在马路上唱着歌还唱得不好听的人特别蠢，可是人家一点都不蠢，他唱歌的样子就能证明他很快乐。</p><p>那些跳广场舞的大妈，人家是真的开心，在跳舞的过程中，她们是心情愉悦的，不然谁会每天都准点跑去跳啊。</p><p>咱们也得好好对待自己，别老那么在意别人的目光，人家路人其实压根就不在意你。</p><h2 id="如何看待论调所谓稳定不过是在浪费生命"><ahref="https://www.zhihu.com/question/278108330/answer/400776080">如何看待论调「所谓稳定不过是在浪费生命」</a></h2><p>纸醉金迷可能会有一时之爽，但午夜梦回，浮现在眼前的是孩提时代的无忧无虑，还是高档场所的推杯换盏，真不一定。</p><p>内心的平安才是真正的平安。</p><p>人活着，要常常问自己，到底想要什么。不要总跟别人比较，不要过于苛求自己。和自己相识，和自己和解。</p><p>盗用头文字D的一句台词，这世界上只有一种成功，就是能够用自己喜欢的方式度过一生，这才是成功最返璞归真的定义。</p><h2 id="我们是怎样一步步地走向平庸的"><ahref="https://www.zhihu.com/question/33220674/answer/58248246">我们是怎样一步步地走向平庸的</a></h2><p>认为我这么一个大好人才，却被投闲置散，落至今时今日这样的田地。</p><p>也试过自怨自艾，认为自己不知不觉间变成了一个废人。</p><p>直到这个时候，我才知道，我之所以觉得亲朋好友们的夸赞大惊小怪，其实是因为在我心底，我一直以为自己本来就应该是个天之骄子。</p><p>一路以来走得太过顺畅，我以为自己并不高傲自大，其实这种高傲自大已经深入骨髓，我根本没有机会察觉。</p><p>及至看到周围那些，曾经和我一个水平，甚至不如我的人，踏踏实实地走每一步，一步一步地抛离我，我才慢慢意识到，我并不是什么天之骄子，我只是一个平平凡凡的人。</p><p>接受自己是一个庸人这个过程非常痛苦。我每天都在剧烈的内心煎熬中。</p><p>一时劝说自己，生来便是庸人，坦然接受便是。一时又斗志激昂，只要努力，我便能回到原来天之骄子的位置上。</p><p>食不能安，夜不能寐。精神的压力直接导致身体的衰弱，一度卧病在床。</p><p>每个人都理所当然地演绎着自己的每一日。</p><p>相比之下，我国内的朋友，最近一个个结婚生子，安居乐业。我的妹妹，看起来学历能力一切不如我，却兢兢业业安安稳稳地工作着，闲时与朋友吃吃烧烤喝喝啤酒，上瑜伽班，学画画，日子过得不亦乐乎。</p><p>你说这样是平庸吗？然而她却觉得幸福无比。我拿着两个名校的学位又一次进入了名企，努力了那么久，曾经我以为我也算一直在进步，最后也不过是朝九晚五地工作。</p><p>而此时此刻，我只想回到家人的身边，过那带着油烟味的乏味无奇的日子。</p><p>我想，大千世界，谁人不平庸谁人平庸，一切不过是心魔。努力上进也好，安稳度日也好，若是不幸福不快乐，又有何用。</p><h2 id="大学毕业之后同学之间慢慢拉开了差距还有必要参加老同学聚会吗"><ahref="https://www.zhihu.com/question/20004337/answer/18961389">大学毕业之后，同学之间慢慢拉开了差距，还有必要参加老同学聚会吗</a></h2><p>唯有真正的好朋友，你过得好，他们反倒会问候你，这样累不累，不累就好；你过得不好，他们也会真心体贴你：「没关系，加油，做你自己想做的事，兄弟帮不到你，但你不开心的时候，可以找兄弟出来喝喝酒、吃吃饭、唱唱歌，哥儿几个陪你。」</p><p>当朋友之间不用显示优越感时，就能好好聊天了。</p><h2 id="如何让自己变得开心起来"><ahref="https://www.zhihu.com/question/20657503/answer/28028792">如何让自己变得开心起来</a></h2><p>不要和他人比较。我在精神病院工作，我可以直截了当的告诉你：太多看上去成功和开心的人被自己内心的骚动活活折磨疯了。所以，只要专注自己就好。</p><p>参与社交。即使你是一个内向的人，也要强迫自己去进入社交环节，这会给你和人结识、建立联系的机会。这些联系会使你和你的人性连接在一起。</p><p>做有关健康的决策。运动和好的饮食会改变你的世界观，这是很神奇的。你脑中看起来很真实很迫切的消极想法会消失的。</p><p>做不一样的事情。不要再浪费时间试图找到“完美的爱好”了。学习一点新的，无论是纤维艺术还是品尝咖啡。找到一件你可以投入精力的东西，自己能够胜任，然后等待结果。</p><p>和转折点保持联系。当我们长大的时候我们就慢慢失去了那些转折点。试着在任何一个你觉得亲切的群体里更好的安置自己，无论那个群体是你的家庭，你的邻居，你的文明，或是你的种族。</p><p>少往前看，少往后看。试着更多关注现在的自己。开始建立回忆而不是活在回忆里。开始创造你的未来而不是期待更好的未来。如果你不这样做，你的生活就会成为一片雾，横跨你的整个人生。（在某个阶段做事时候，不要总想着下一阶段，专注于现在。）</p><p>创造。在旅行中书写，或者画点什么。写一首歌，即使你从未演奏它。当你走的时候，开始改变你遗留下来的纪念品。</p><p>放手。原谅那些伤害你的人。我很遗憾你受到了伤害。但是如果你不将那些伤痛留在过去，它就会像狼一样跟着你——当你做任何事情的时候，它永远扮演着一个危险的影子。</p><p>更多的为他人担心。很多时候是我们的自恋毁了我们。这听上去很反直觉，但是每天花些时间想想你生活中人们的需求。帮助他们实现一些需求会使你更加开心，这个你现在可能不会理解。</p><p>停止奔跑。其实没有一个地方是“在远处”的。你想旅行多远就多远，但是当你到达那里的时候，你将始终发现你在等待着自己。拔出你的剑。是时候回头和你心中的巨龙搏斗了。</p><h2 id="关于高考你印象最深的是什么"><ahref="https://www.zhihu.com/question/24047876/answer/37943380">关于高考，你印象最深的是什么</a></h2><p>高考前的人生轻薄如纸，越往后走，生活才越显出复杂与沉重的本来面目。</p><p>我希望各位能在高考中取得好成绩，但我更希望，当你们背负着越来越沉重的人生往前走时，依然不会失去感受幸福的能力。</p><p>从知道得病至今我一直坦然和平静，我总是想，人不能只允许自己遇到好事，不允许自己遇到坏事。当不顺或困境找到我时，我会反问自己：为什么不可以是我？于是就能平静地去面对。</p><h2 id="这样的努力真的有意义吗"><ahref="https://www.zhihu.com/question/23606484/answer/25156325">这样的努力真的有意义吗</a></h2><p>强者懂得，不管喜欢与否，现有的事情要做得漂亮。才有资格在人生方向确定时，发现自己已经有充分的积累，实现他们的梦想。</p><p>不管你是什么level的，永远有无数的人跟你同一个level，而你只要不断努力，就能超过这些本来跟你同level的人。</p><h2 id="你是如何变得不浮躁的"><ahref="https://www.zhihu.com/question/19627497/answer/15875565">你是如何变得不浮躁的</a></h2><p>浮躁是因为急于求成而产生的一种不安的心理。心中总是想着做更多的事情，更快的获得成功，更快的抵达自己的目标，使我们忘记了，我们是为什么去做一件事情。</p><p>做一件事的最重要的是求的心灵的安宁。当我们充满激情的想做完成一件作品时，我们的心不是安宁的。一直到作品呈现出，它应该有的形式，我们心灵才获得了安宁，才获得了喜悦。</p><p>然而当你想着赶快做完一件事的时候，就说明你不再关心此事，而是想着下一件事，你匆匆忙忙的应付了眼前的事，然后又赶紧开始下一件事，你的心没有得到过安宁。前面事情又做的不够好，你会更不安，更浮躁。戒浮躁就要做好当下的事，投入你的热忱，直到做好它，那时你的心才得到安宁。</p><p>高僧把扫地也当成他生活的一部分，他沉浸于扫地这个过程，直到把地扫干净，他获得了心灵的安宁，这种安宁对他来说比任何东西都重要。他过得是一种沉浸式的生活。而心浮气躁的人总是过着肤浅的生活。</p><p>放慢自己做事情的速度，投入自己的热忱。不要着急地去做一件事情，先端正自己的态度，寻找做此事的热忱。</p><p>冥想，静坐，都是不错的训练方法。</p><h2 id="能否用一百字写清楚你最想要的生活"><ahref="https://www.zhihu.com/question/34970791/answer/63071829">能否用一百字写清楚你最想要的生活</a></h2><p>冬。 大雪。 小火炉。 热巧克力。 温暖的沙发。 脚边打滚的猫。阳台上赏雪的狗。 笼子里好动的仓鼠。 靠在我肩上瞌睡的你。水瓶里开得正盛的鲜花。 爸妈刚打来一个电话。 你们有空回来喝茶。我给你盖上被子。 没想吵醒你啦。 你揉了揉眼。 一起睡吧。 那好吧。 讨厌！哈。</p><h2 id="如何做一个让人眼前一亮的presentation"><ahref="https://www.zhihu.com/question/28639137/answer/374782107">如何做一个让人眼前一亮的presentation</a></h2><p>当然，不同场合需要不同的风格，但是整体流程一定要像讲故事一样，大致有3步：</p><ol type="1"><li>一个看似平静的现状<br />不超过10%时间，用一个小故事开场引出问题，接着要改造，团队应运而生，我是xx团队的xxx，团队致力于xxx，最主要的feature是xxx</li><li>遇到困难，甚至已经不行了<br />对比，幽默、数据展示、逻辑说明（乔布斯）<br />经典采访音频、震撼的图片<br />大图片+小文字<br />大数字+小文字<br /></li><li>凭借聪明才智翻转，最终战胜困难<br />勾画出一个美好的愿景</li></ol><p>下来就是看一些经典的发布会，加强练习。</p>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Predecessor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Performance Measurement</title>
      <link href="/posts/performance-measure/"/>
      <url>/posts/performance-measure/</url>
      
        <content type="html"><![CDATA[<p>程序性能的衡量一般有2种方式：Benchmarking和Profiling。 ##BenchmarkingBenchmarking通过绝对运行时间来比较程序的整体性能，例如给定一组同样的输入，比较不同版本的程序在同样硬件环境下的运行时间，或者比较相同版本程序在不同硬件环境下的运行时间。</p><h2 id="profiling">Profiling</h2><p>Profiling通常用来识别程序的耗时瓶颈（通常是一些函数），优化这些瓶颈后再去做Benchmarking评估整体性能。<br />Unix系统提供了GPROF工具，CSAPP上有一个示例：</p><ul><li>编译：<code>gcc -Og -pg prog.c -o prog</code><br /><code>-Og</code>表示关闭了很多编译器的优化开关，并且优化了调试信息；<code>-pg</code>表示产生供GPROF剖析用的可执行文件。</li><li>执行：<code>./prog file.txt</code><br />会比正常执行要慢一些（慢一倍左右），生成待分析的文件<code>gmon.out</code>。</li><li>分析：<code>gprof prog</code></li></ul><p>结果通常有2部分。<br />第一部分是不同函数的耗时情况：<br /><img src="https://img-blog.csdnimg.cn/20201012215440170.png#pic_center"alt="在这里插入图片描述" /><br />第4列显示了该函数被调用了多少次（不含递归调用），库函数一般不显示在列表中，但是可以通过wrapperfunction去显示它的执行情况。<br />第二部分是函数的调用情况，以递归函数<code>find_ele_rec</code>为例：<br /><img src="https://img-blog.csdnimg.cn/20201012220111993.png"alt="在这里插入图片描述" /><br />前2行显示了调用该函数的情况：自己递归调用了158555725次，被<code>insert_string</code>调用了965027次，<code>insert_string</code>自己递归调用了965027次；后几行显示了<code>find_ele_rec</code>调用其他函数的情况。</p><p>由于GPROF采用的是intervalcounting，所以计时可能不太精确，尤其对于运行时间小于1s的程序误差更大。<br />如何使用Profiling去优化程序，CSAPP上给了一个非常精彩的例子，这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quarterly Review</title>
      <link href="/posts/quarterly-review/"/>
      <url>/posts/quarterly-review/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3c8424215136e5c81a6d40d64851faa9e522936de564a6181fa631bf595e2a68">418fac4f173397084caccc18ab9f089e90c7a29408af94da76702e54e165326b954ea2bf755f452b7d2c4562fe83eff1cc4056c74e87eced62e495c74185208746a79023f78465b91a9a78a20d34cb7bb616044291cf087fb367c679d2c39b3360572206912f96535b1264ffae43a33622bcd8f5d2c79d4f5fe20d91fba86c5914997741c5d329ab60ff45270ac96f2a50ada9e9f80979772329c939ca877266f744a4de773c6d9565a01c90dfd703460b06cea113ddd06e7a5a3f4f6d72c7a87f8e887a8a4d490548df2b345d0db636c6fe3c486773a755e3163b8c0125f81e8df44a63990df97e12b52a34f87dfe4f22da890090b018d270455c7e7bd7a15e49748044e7176119bb626652f91c2442e911b69dbe27a59ed76635b33622e597880e05415d366e6e0a9ebfb6fd98cedcac9848b4cc11286c0facb4f2f8ef47be61b0c1541e5df4573fc9265900074b18cf217b5325147b2eb8c7b18135162046451ecef19540d45086c168f8966f4b2ba611745f5a4c73f69e8da1600c4d6356402d9687e762d513d78fe82550f9873350c01378a884fa4d9fbd16d22fd7b652761d6b250829d01717df908f18c3c2550c942990ec487d4df1b7e2d8da6a4e83b36af54d09220eb0c4a48beb5926d824777ecf3d1aec8a694235314d809653dac6772da13461a8d0028a932e3cfd34fc5a90d0f18ad4a6a1fa7623d7493d1edbd23ac39cad69725f6c7b2c43d8732b8ecd7f8f1601bcf46e8d8346303ea0395c247ba876ee20b7cc7f6d96c9b83cc1456cbd65c73f25a09f7fef934a3d79abc45aefc338e1d2189aa8c7a1e7732412a46ac6892f5e345682370a99064bb2dd924ff60d4e36614abbb1f47cfffea2121d41fff42552474e18a033fc2a1e8eb971cd9965bbc0374f1f5900ab4fca2140a3f5e1e04148273a87a6c78fc66fe1fab994c0dd92481a86e7fc775840661f3f660379f7aadc9e9ad4910f743371ab6a7356be50cd895fd2b49101538cea422c3a7867fb0f8dfd218fb31601456350759aa0c5551665776578a5c5169539f7be6f76b436933128e1b53b36791b7eddbe4cb296ea0dc81a6a00622ecaa57e7722253ad928e2d94385574ad7345fc041de3cd206b56a1f7c20fb7d59f30b133f121df66803622327b98eba56203c7508eaaec24b7873182af5e07bbdb1418e9d8a44548c0c1ffd11258d0e15b43701e9ead9f0415c259a3b554c2892a9ebcff46378b266d62041161ffa0309a9480bff7eb8af22d963b0724ba5dc8d1c322de3efe926a482947007127e1f1fb89dd13d3da0fed9d6bf2c1cfc1a8f41efe3eceb3276a898be78adce0dc3827b701f25cae4aab16d65d21f4a35bad91970d080efee1452126854e5ecf40f149efd6a599a57d9b6dae59b89abc2a1c16c392f4c456b0e54143799351ed43f2743061225c3d1f61d5b8d25191214cb4accfd1ffa4df6fc64dd8366437beb0d37445969ca4d91cf1dd2940b5f8322880f0e20e3542bd6b017a4846071dbe2e4634c4cd9f880b69256093e8a9c25c2f5f139be9380057c3fc606d7eaaea58e266b420b1de48ce08443d7b9c9eff23f92ed894700cdde7a3afb8b529c2b9245b0032253c65cee536b2f7809727578d09c9413c6c469224bd80e871af4e7cccc64103b2f1be30ff2a1c284e7fdb26303447359bb46d7be87c0f66bbcaf28f662c9375bc0e1831562eb9234c0a4c3f8fbc457d49165479b92b5068aa40104a337ad9e974c728f368c5a44fc328918f4809773a95a49605887ede6f6d5c2301b91e9c3d0305d644cf8eccd4f79441b1576bef7c53689e0c6433827e55df7f1a0d5cac671b79979ec4eb827aec9979fed363c51aadfd177a5b906a9ea16fa776561f6e2c327261fc0f57da3979026ab9760d00b79dac1acca63c61f2069e51a4ddaa6bb574b70a8bd7be51556810c9af3c9ec5fbf659ffedc28596a88bad6cd1e07f9be18f6465abcf1ce3becc0072054dd5f84b0662a6172ad938db987072979ec0c278b99e1ca6446b443500194f23cc0b3f781729a0fbe9835be4fbdf5f438ec7ccb116b9579f78e394038446628ce502ac5f7817c4b6086e69cd1e1d769504dee5aa97d5f68f59432000d2a0894f57a3137961c590064733a7f224629578c5c23b4fe086fd1cfaefe11a000013716e71de6900fa45d7388632a5fa850adbdbcd520321e113d30443def36982c31a3fc63fd3c58a314054cd0002fcab32b5ad05fddcdedff4d7f0061dcffa99e01ffd11fdd599c08580c9c795d5ea18c8b8140394f7f6e6c4e5ff1d7328750579aaeb32b4501add229fe49f32e4505ab7e7937b83f99a1b331989809cef198fca9a5b7bda621bb85a631d91614ad79d5a0a85c2492ae8fd65737615e9f05a8a56c6d84504a3f3670abe5389aecb51860ddeb3c4bbd7e09db8530ecd2b8a41945ba195ecb4caa08aa54ff4031671259f9e43f2b9871fa1701d6bcff3126999ee9249665dd67cc9be257d30cbfd402d7b08873e702d00aa0bbed951dba32df7c7976ab9ebdcf83c673d1981389c6dbd1d172d769a55a494b7a20e89cd7c52ba449f9ce233a0faeb794ab281b339cf47cc9adda56c982d277d1112b5be4f25f8b6207b855b3e7d3890650d12ca22b326984fa4afe356746e4ee3a64e8e2022738dafe1d1ed5c06da85a659fce210e1c22494c20314e6ea9c10ab625f98ec8e1076f200f6ec9841b402987c0d6f048df3c1c2257f7174e5542d50474a2471ea6ad98e97f1ee30df8edc354a12ab663b224b1b592160010c028d894652fb482b91013001fa589ef0cc1bcbb4aaeeaa0f15228cd5ca0fd3d67fb7d6ffbe34d928b3d0fa189837d7aa51ad839a4a6614e6b8e5bc8770b803555c2b9aed72ba229e5ce63525a7c28e888082bacf03bd3fc8e2bdd80c11ddd946a947ba83fd493ab0d1b5632bdf0040eabe2b283202a04685473e68b77d043709b7d9e559f6d52b43c2d63d80eaf5e2202bdee9e1ffcbb71b4b11d839f7e1f1859f3b6d0f758491b27330cf33d7a889826518239dfc7abb63c0d76fe282ce2f019f24d77c7d09e28d31a5f864ff03bf8250cd3e16785253405cdfc3c17461158b06e89917bad1fab3ce7636049ee3ecd4d58f3352f8bc27edf7ffa2e57c2fa6c93d458ce74a4139bb8a645f023eb5144c33e8e18c02a90abeb7a1b0b68348b67a172fe9b243c6e6d0f279fe635fba1013eeaacc132fdb1fd851de5877c2cd8b0d3d83a84e9b85baf490d6df8c8de12802abbf7c6ae342b1901155e08ec84796363cd7fea8074dd462210b4c50578f32e674d2e4f3589a0ccc8d591fc3a4f9c8e2bf64dc526896e049771a974c78d986416e5f6ad0da62d2b70d5364164e6880295e3da97bc5b47d9e9fc0610aa771ba49c4b13da37ce6aa60875a154ef9958e0541c44af7eda039408615f03acf25c0b8af3bf126d1bd74f733828152c8cd2d6c39cfe8f2108b9eb07acd81d999b073d2f56c67571f2dee22d2b5a12ac4ec61253831040af2133649cc781d188144c3b4ab3145acccf9fcbafe3db1c42f3fab988789667291ff0010303d80b7c45b50c7149192d359b859bcefa7317fee070eb110906c1c746a4c645837de60873e2f54d95314ac8592ce94661f3276f19f481b01ab37b25e9f7ac326d09d09e3309cb314e998b3db7649346886d140427479078bce637b98996fc6e431bc8a2ecbf4d9119ea207f4a39e9ac63328e64999d3b5f9ff036230f21ce40cdd8684ea62f556fb23994a57ee0933eb7583bed5e0e170bb5308f64c81865a1c3196ccf2593d44fcf70c84894d8f6cd35ac6bd7642f5b9183060aa48f51f8c00b6bfdf71b2811637e61d61c02b8dfb5f481b1b96223a555c1c9333937047db84f0ea1f386d73e5d206b1b8272d8a14340f12d9673b31ade357de31318eea047b674d0255e6b257af60a9a2a83570d182ddb995ac3809572ae2a145669030fbb551225bf8d1341fc203188f89d3b468f1332eafbeac3647096798d2d1f58eb7af0d1f0a37b68fc431c0d5c655f0c39332f6a375be6b4a79267193328d96afd3d0a208df36ddc29ed643ad8b591ed6b013587ceed1be97938d23df1a2e125d1c91fc659d3216fde5b1cf79c0fd87daf4300ebe6f21ca1022c335815f7a21267b0e1c87f2f7740c1f79786f0e329be1f0922a0de796fbc4f48a7c128dd2eceaceb0c2a02b4d02b8655bcc2dcbd3ce0c13b5355ff5bf2087315ee743edf6da5684d9fe9d5361c090ea2d63fbead1140c2c0b3ea36c7ee98d53123083e2f1807087f539807bfb461f68c74735b31bcf7859cf334ec86123a1d8381569ed60de61d8727a1a04bffc4d25fbc2c50961591678ab23f5ddd3ddaa9f5eb53c146c44c6293ea6aad866177a3e9e18249f35fd48fd3d7243d77ba0ce11ef04f76845abc69c5d5f99752070e5557bc0573070e14638b83259e7ae36820448745a171969db3c7da6264ffe0c4676eb984134663011e33ae3aaf44aec242b053cd33fc3a7b076099a6dba6c9da4f666a37dc5a15307666980b5ccbad3bc98fa37b65ccf5b0f091ef901e82be853dcad7c505adf8b02d11ad7b14a976913ff655e35b16de8ffefdb30b47bceaab77e791689d7aa3b6529c1ef4fddf3b8a4c50f1e1b952d80f369fca52a85ae31de8ed506059f6d8bf12838b0b099a6d9a6b3bb8dbd7f848ac463f37b7f70aa88455df3ae7568595a19b4d09aaf78120628a3837bbf17d7ba6a14993a0f48949c46e10ac42707f3dda6bfd1e4d34ad5714613a7cbd622f6330e961ac8655e8662342609c0e390b06da389477efc39304624d1dc5584b870e6b9537fe84959b3f044adb58e16350b495d3d5912e7025881f604275b2c065df30556b46b0e618a865c974b3372f87007676840043c21227ce50d172fc14a2fe72faf50e9c5a93c08cd0bb4046a55f5f2d78eeab5211790d0222de515a373b60677827e0ac5a940681f1171703b011e88849a115504e1ac58b3df39d7a7baeb97790768e83b413b4316d25e06393f5fa1aa974cfb62aaf5fed9e980710b85e33872cbeec17cfc9daac000189be2e632fdf54770dfa4ddb9fb3f46fa25c18152e2fba359fb3dfddb3e301bf23c6a3ee9a33aa94ed6309291445d2797ee473402faceb6879b7721ce94b282e6f2b47011ddcd7b56113f72b97c540fed3f6fa63c5ce5438f5b5ec2c4afc5c1106eb6cc34be679c4152e165895a67a1a4b66b915108777cd132f60ec316c4be884044b6a063442127595cdd60792e1b79e4be118617acd252321ee5838053d0907e4b312fda0c4f5e18272cf74c94447dd029a5c97db64977bf4784ecfc578342f3c1b78246396cdfc9afa7b680d18d6033f4a6baaf3ea9fa63cb9b29b1ccbc1f000eb20198760482e531a8f82473432fd649d794e831e8ee1bed2a4865471195a10cafbc6deb02984df5ea13450b55cbe80fb13952e03f4e7dda4748ab7ec6d94b5ddaa0731a761cbd431795cbd5dc5037ba2174adc8e4c5d26e61ebec549386989fad19c6344bc397bf56cc362e1aeee8c113abba08a347bae13923db4950156b5c48cdebe4a98930280a10b1ef3971d727406560d82a24205de24db9529e643699781911bf5e475f1c4cc25504396d089792871baa8f54b5bdadac0e2eff8cf0d0da6c54ae08d8ab807cee6a8aa1639ec214ba1043a23fcea104b50a30fdab940e4c6b77eeb8220cdeed9df77325d0bc8fcef3bb419cf7cfe8a596cf68afa1a1f20578b50e048c9ab61210a700320e5fdf5ba0446b1c4ce07839467d4462fb284190d458e42e1a994f7abdc7ff1a8f8567b61f80beda1604e8f554873936c30640beb722bbf2c5c3a96960e5cf54adce87ad3da7753eeb3608126fcfbf1c8a87f2eb7b8184487737fbce8d56ea529a98f05c67173d515a61dc2236ba7c0be26d4a307821be4c84bb173676116d74368f88857b3b6d14dced366b435bcd18dde7d26f0f88ba07dcc586851a13bf99d32b48cc86364e4072d83c654e03bd8eba46a45ab285a009152e0747eafe5bd5d6d1153c0ab465ddadc9dd111c5fdad227e01edb6118bd3f3a49528e0220a293d373eccc68dc97d1c828928b1ff1fb00c4ae68a59c7fc802661521542f4a4183e0e2eb7bc3509e5c53b05bb1baf23487fd875488a1b0aca734374c4694ae56cc4ea11c53356963da1392db9eb1d19e85d972b3eb087bc7bbd805a8159578d09ff008f2d5e02384dd67a730ff40d91974d670a2d70f67db2a3cce4c7ff99ea6940c22919c369dcb7fb01818cd52b116dde8a4cfe3c40989f20e126d2b50a8bf66a1e5c1a38dcb1100e5828ebeaf695987c65eb6fe4c2768cdeca0ddbfb2a2b89824c470ef7f6ee3ea8ec37cd929eed008350b09e34b3d28c061a563dfca55e07526c53621e541a4404dbf7d8a06c1398f80685112de71344a91dfe77c83db94b49f6c7ac7ab8badbf27fc4d71dc2fbabf0a0005db844b690c67eac66e7f7e1a47a82161f1d58e6255b2662850ecc4c03ba264fad09554662804a03c10de0b21702d550c105e164d01d2cb5d8a6e60b5685935fc916244a8c553090f33075bac1b32b9fe650a84cb122ece0080c277f839b4e7762b983fcc2fb072fe045ca6f6fb24ce3e18b36c21e5c3f1495350b3cac0c70eef2b8f89a7b38aa0f2ae27d8dcde1b1f3d9b031fd79da457c9f85ca6470482dfde4b2d08580d88c7bbacb2e06e4643b85aa904e360283efc63fca3c297ad45cb4c2b8c8a20b8710f02150e03d2d64c2b30c436c6739d11004496b3e6540ecda3018b53ad73d8abb5207e35e38b5dadf641665810b2e9e419426e628ffcb13056e31562d9aa737f2ca2aa1be770c50094b0ecf6e1d6a954e8cdfaf35e7c52e296a936581cf43e49ae23de028995d7ff7ff3711099348152a872d0610879ee620bff6e95939445d10a65511cdf89a285096d562fc1411700a3c7e7fe890def64880417d3ada5c602a7f9d06b6c7f2c022dc8ee70ac5995adf3acf6babee2936385ae8f748c011c867a06992e223719bbf4ba7014faa52f11e76c48ce87d863127db21bd424831a21efdebe73860bd864b0e4105bd2c37296ff27c501a12106a84e54dba77150550678f559300f2387470d9c9a07093a25a068ea9049a400d4d78ed4a11e8fcddf139ef8099e8249938730559aac4ea801d79a5aa8bb46aa70264ee6e7346977f1c4c06b813d4f2d58a825e936006c3c7813e240136c6253b0fa3d29decdf196a2606147d0fa7df1ddebadfd9a16b0999a15f2aa515f96b94389149528f45c966d0a323506ca63773a5b3ee2bb9c8b304cf3b7cc0addf379c1094d9fa001b7fa308b57fbcacdc9404275c44f6d5ebba27fd6688a58db41c0152b1eee1f44230f537abc82cfd3071c2a76e006ea7736e7b0f538ee2943d63c3b9e5ae4c67104baee063184b2b83c218f234fd6eaf05b2d33374987ac2ed4231074c2558fbbdbcef2e4cf51f778ff5c87777b75f9d789c6a1c6ef1f843d52efefbdb61becb9345323ae7322335a2f0a7fe91bfb11034f892ac484b55de26fd400dbb2eb4578ee3bfebabfc1aebe8379a5afd12cb40975054556a647f8e84a8cca93503ffa5f3358b15c21ecd8a630acecea42a754791e525af74bb05cb6912f3c0fd7bcae5c4d498f2e6580d0f43ebc95e7f69bc86156053672ad3da2898f66d77ada00ec5a313b77d3e2adfc21ee3a3031f699e61ee589a91c46a81cdaeb23a5abaf3028d3ff1ef43c770c9bc1d8b0844339b60b7e59e77057e32ddae840288c4366f50e393b33b8824568eabd1d7991209efc7d52e393106ffbd384dcb9a720dac8e55e9b354cfdc4eeea95c0e5b8f0a310cb901bba091686c2419422147028c54b54501dee5942a9667a424cd73b1947db2e4c64f3636958c562fce59d704eb2e6107c0465093896b418e5e1ac3232dcd46654e19d71ab65b28dd9ff6ad89bccd9d87c5dfc7c0a2cca57325778643dd1ebfc1bd4dd760ea5314091488ee806e614e7fc188af3ee1079c97d4ffdde51aee519daf31a442e43b71bed603ddc9e4c665e4ada0717cb4b712e268201c037f23ff62f210f42dcd1e3e2c4c9a5fc71af194348992347a49cc4a45ab73860eb8f5b92ed4d323c37cc42402bd21d460c54de0faf4719c26c911c83bb92cff4c9e74a6ac188d4ed88c366ac25ffefbb6f3cdf37934724fefdc8e5121bc4700563c2c76f358fd8d9905bb87fd17eeaac82fa198b24917e4d45ab2865fe343e22d7af2233ce85eeb39adc2c95084503f455a0538c5bafd26032807cd00caf52f9426b42356e9409dcfdcde1681dc5ddd236567592981f12a3e03b96c3210ff780164ee980e0316c358df7c41843f4809881bba336b5b772065b3e0fadf5d54f15100bd8eca563b30cb42e3f0b2739d0f8bc0ae2ec7044074d4cb2e6a4a11f00aeb93734a7e7e1aab07845185923d4d791f19a39ffcef9aec33dc688a3cde868e8a0136caa1e68a1d5ecb398f8d7b74056e5b465417a5f03acdea38f9e486c8c117f00216ef6e85095e0266cef759800224e4ee69fd442f16dcd566655ee4dfbf4caa00e0b231c9af3a29e8aa9625b64a7d07f8abf688e76cc5f3fc4860539f3cb3cfaa1b1d5931ce9122fe1d4bccd941cac5bbddcadac475615932d00ccb97ca7ca4505e2f0e4d773a173f9b3c20e87425998dad483b70d6236c9d93a0232a7338d60d89c21b7704a14700855ab99d50e1a21b631a11c84aed6fd7866a12941b5b230614f4f2230165d6bd21c08ba9023bcfca86cd58b030a3264505a6df2f27abb4c2f13ce4d06e1c721d311a2e5e0c740cf81941fe52f82fb26da37a66e36e493ac0a3de24c94d768ff9c4e75cfc4329c064f4e8699328a7afec893ec643c2d6e6aff5d21c3c97e9b1ff9c29ae5f65fe526247fe74877630e9d05d27997fcea2475bb88f2480881b5d0a94099b1577e3291b4ae1f47c9c87dc03e0c74a38ff5a35b3416c3a5e34634475ecd72e59075978f6a6b180e8402da4493d3541a62bc3ffb579ad75d6818352a9abaea39fc03a2ac212ed30ca3b7d2db7911b30728217814b8542be284d5b21a8138ac99a24babdb9b903c951315e3690ef4973497f76e72340f359456f12a3392c887ed64906e054160e0089130085b8d6e0981d943c1538caaec3e9c70ca3e8f21db5e67c65ad50c2e37898ad744e4fec6271e1b6342aedc0da66fab7d0cac712d33e19c16b32b0369d6fbbd8bd4d584273f206013faf57936d7df9c6203e8b3383c46a51d8535fffdc9abf84ea9c56ecf33b3857ff97e5483e397cad5ff3c4a9aecb620d6f2164662dfd99ed102f6bcc8c4d54d9856861c25ec46631f08b0ca5ff6e1d94a074f8629da685657d835836217b7a1095fbb2f975615236996debc0b0a67343ec88c7f36e1d35989dfc4b0e6357486d81878775afd763084cd14547c9ece9cd9fe8700e0c1f1165254d1ddf42f0069475e554b159e42f3dbffea026ef88610066922fa095396f53fac805c381d597b28d193b963b05654c4a5937b3b845cfdb4fd9675617fcc373ae1e873c86491a03db921c83fa53f882dd7950df03be250c8a320ae5e30a58b3e07c31b1806a32cb62dfe6ed64595cc59913647aba6f2b7c368427fdbfa85b04818a81a17b1419439506faa6dd97ce01983abed88aacebce39e0ed4cfb4cde567b218d83e5a7bd2d33a65bd43aee89e1429a080fba4666d243d8710671e130f663d1daa61fc194807521269f4c610c93959230677ac606f897e9e5751b7ea6515a5cd9faa8af9e35221266875c2303bea8475eeda182deb758b54db70dd748a17b54f372b69be88a46194edc8e4a743f50d019437c4ed1deba60c8257ff9c5350951b8a72fd1ce045f96d14433262a2af275a73e277cd7d5f4c62de87ddf761e3c4adcb232a9d484dca930300e2cc0c9ab59ee17358c6ad0b91d59d40713cfabb7142f649ecff873515ccedfdb2e135faaa8299639b8beff55bdd6d850c7dac6c93027eaeaf631f1fca4dee4bf447415d8550037dea11f8ed2ada723bfdbe05eb749c4932a69efa38dac0a9b68dfce4392698b7ad07a8cbb4786ae813a9eb491269aa2f5bc24b4a3681213d1056134e7fccdfbef811275d11882e8485135b291134f192abaa33aaef5cb479a35125bf54c40bc5262f72c6aee8862a56c9520084c343fd2f080bbc71723a8bc124fa0d3cbf027d5d1e730f11ca3ff6df1bfdf9b24741a7962b0de3a7344e804384166391c86138bd34f1e9bb0cff7540403749d016198b10ac00e02bbc8aeb2d156286219a42c9437bcf0653f886f2898c317f5bb0e9fc0e97f60306475714e7565d6b0ba3ed10cf892946280886385d911a558634328618e62d8fb246c6fe40317eaa614e9d5479ae0d16d6f863bfdff9aaa0d3ed5ccc4d89633b2ab0b094dbd9a4836a0c28253e677a9c5dfd72062b011458339777992a71332073f9c873c149b97710ac57bd54a9e083f7ff3d69a3c0ed2508c9300a83e9fc82de3eb5f630260ebe6402ae24425c7e462e342d3a36209d897e73e8ceb2c50e200191416e0eb552f2a216debfbd90a98f1b5738aad90ef60f224ae5f1a1679bb85a887b7ff3a5c8d5f92edad183e2db0bd1eb6a6c4147a980347b5f2666aaa908e68c2c2dba2ae26e52a4134d4e4f5c8c3a8496c06ec2ee783767abeea0260cba804bdb5e76315a969eb7b79bae3195c35b03af8e6c654f214c67fd29ec65f90c02f467a663788d190c2617293e6b109311e4cc264d0bd802745b95b2e02bd034408adb264a90a57da92c2472a734b20f1510c566134d3aeda6acbcc30f818a4477d36fdc5166328f2815e92e7dea610d80af6883ff6fc394f2e4398eb958d5d3983284b4913e16dc93dc07255b8d66ccaec4bb3330b849267300e07e652a4eef3593a1aa9679b50bcc8de24a16ed66a81e3b0dacb592523af7f384c51b59d4385f29ffec5e296b64ef48423b3c59e122f307bd01275e1083909d914192e0ed923d965fe08f12b3d8837772521d11ddf6dda11f99ce38d1e9b808b8be3d18a66fb052812ebe47007c9ef285a524a4d0196f29b56f96b1c1f1292dbd7b2f1407c580395ff4842ed51411196bbcd917ca3f07abd17d60d230f0493a65822159b902f915b546115fd4789e528e105ab445da3c7c26373fe5f394e2f1d03a85dd021ec24f2d8b9dc8f06ef2e34a885d029fa8222472fbeba753deae1275c510a0fb4045781dbd535c6b378c8992e21ae2990107e697ae9a826bd18caac2e71b56b7a4f5fae628c676eecd6cf33fd079ecc9de2e3ceb91d7fda6a40e9a3c3d1a8fbf090c7f70f67d483207468caf3f4b9792be5455a638f1dab7f104a2b29550574427e120e65e3fc6221546d80ce944afef65494cfc3875e03eac1ca125c62f7798ab73f0a5ee5dbdcfe135ebc926bc7735397e354bddd40f37a780e2f47e9c0488dd94d994f7124f451ba187b4879a4a09a8fefb5d9cd1202edbe8d3d09eae705e46ac061f7999d4aa4be1d1d6e9b90f55245c2937f964dd3ecb13ed018c00de615e8e14b61c4d136948962e8d32c37ab086e8974d8a7fe643c23f5b4c72d9bd1248186787dcd942c7630beeef1eaa50bff4955fb75b5f8985126ba2c1e41bad9085f594f8c666f2690cf451549c432bf61f61c9944da17acf468c1f9aec91b9eda509436551b66658178907a5a456fa96d0c85b727f53cf02d34908be7ad4b4d7e7b8e093eef3cc35a442fde2191dbfd5de76339c9eb2f29c15fa6e6d980c171c0d0393c0707d2165ef089926954a75939aa3859c719d5ef2a8189518912c9e863e27e82b5918a5b8fe81233d03958796f693299d07afd459090451d0133cc09a2b55be7a1d01161ef86c0fb2d7211249fba0187eea0a0826e1c4f80b961379c38177389abd7bfbdb2d46def3ff2033ae8941752cfa32faebe2f2f660930aabbcd3df9c161f56859dd9d693440be4bee8b29abd35891c54c9c39460c35c36d3a6b5aff1ff2ae01d9fa1e69c24bc1d9047bf21a6ddbb9afc140ea6c8ae91a0c8711fa5607497182637a258c3570bf7865cca9dc06c81b0821f0ab62422756676147c976af4b3abef47c08f43d4c3f5451292eebce8ebdc28521f39327796fe5856730e5e7851b3a08bca9ab81f43ed89a52144e49719acc7846456ff6b049049ed7635c5c45c6564136cd817bc5e997003521e609ebd3b102eb6efc3221ff6bce234001b9031f83a536fb3c8599758bc294f69e5caca66947b469b96b9900bdbb060c28bede9165c013b33a1ceef5f21d50890d807f69a6ab571530618c95c2d940460ec8405bf7d7f79b7ddcfc657cb2c9ba031f317a073e4557ca8513c390ff84679f95780152b0242a3a68d58a91d4c8b44d47c6317d7b32ab1e0d2e0e793496d8099c61fa6b141b36a77b15d40b23b3eb25e985b23e31b2c409ed99be96fc414378b677144357b8abd0c9db2abe57434745f5e44ad8d67c38623d4ea4f30e43c3440b86a35ec74657c9b26e9e089b0f487adec1a254da3491db00a16a5a79f2154aedbc66a6c4209859584563f67a8a81fd7d82e018f420b49ba57b356b2b90080220cdd34f3d38ea6aa80f04510fe0a814fe9652c039e7e2681410c7d81b9fea168fd437477d1113b75333f6ab05116041683a5d263c9c524c62151dc6d5b9cb0f99e8b1e144d0acaabe0574abdf91809c6230b512c787baa93b2467f6fe8660d35b071de79a660629c7e6cdb973dc52f2683d706c3dd6acbcbb9f0dd7038c1a19939f0138a50773252f3da5b188ca0d669fb848a45e72e20dc965aba66b4ed12c780cb9d0509ed9b7894e71580a32a11894190c084da1cf4e5b9d5203f83676abec25215541a498482539b267cd82143848f756c9211e7e4647bd15b7e8335e6d1ae1fed68e8965b1d6f3d735f98fe85113dd34a90af47a0efad583280224c8c69c086b9dc5d3c6add1bfbba8da166cb12b6227d08f2b33371947fc8b1f6fab121af35846545657268ba0092152a73fff513bed036ff0b5b2132cb5094c96af9d6c6b31242cd8211b1cad9cd1c584ad972efb176f93c43ffed427abd27c247ae7a5a153884e73780bee4b942d7757281671a69b458948b9995c5ec22fb5f820e90710a8ee1adc062808d4126fbef2a9dd9287d3fc4acf883001f6869de7995c4fad6f7caa68db899510fec4da1d72b5dd8fef4cd5c76a0882d2617b5a985e5ed6a7b977f025c6404502a66ac9c78acebed72cf52af8e1c9953d0a7f462ad555b90a954e6f56ced5adb4e28c05a708ff62159d510d2b4c2750aeb71872e6dce75ff48968433cca0c5022ce97a511b53218213c180129ecccad992fc5355f94a68012e53c225cd535ad1100fd736cbc6444508ad97cb4f065add4481869f630c2230ae655efb044b58398023873248e9d3363a6722369aeda66c25476e9b5c148f4280fbd6eefeaba5db24d2c67f27813a22ca4ef7b2a65c42e0de927b2c896a74d9fd94c166ac18b0de4da291161999b687a84d456489395590e4a25deea6e162c401fd181883d208cf39337e817b3d148748d645a794366423586b5a886570d640836be697fd305a6c294db5f52ee8b085f526896ac926e616ce54e4bf7957a4c1946f5c07a06d466f7d02b47a54b56387f34d4fe0c02fba0ea45d849e32bccc1f4bdca10378e20c65bfbcf0223581d13185b6e8998527183559dfd91e4f5b8f3648c0d573a274eed9f2cd7a58e25b5d729608e153124d9c3a364613dd60da10d2f804b742239501c100a27eda5d805b96ff48500e739b3264766c53ede3702b43c2b625b10c5724252ec26d19d77311e32c1cc205a0ec41e5926bebb591ddac7b51e98c82dcc5bc60eb2ea9525f90ff6d817a5461c4d147cabcb2667a4e3a6ea151004f4117413565eec4a3fb9d41ed8cb2b7ad2dbf45fb5d78493e00866cfec95d10e646535f74cdcd7d623e44ed1c681ad862404c48d3d60d0ac9bdba5d5af52ace40633d50b1dcd6ba6b25c3a87299d9fa529fccbb1de49363939e45284e506aabbbd814c8972ac13625f724fc3628f5e29d496e2398fc2501ca5a01f42367b6ab54a75fd4332f9f6e921841918351542a60b156550d7c991e50508a9900e379bc96438e26343a8efb872925f9b1f0f0bf8ef7d63a41498add5a8489b3129e3a8be087cc40da1217a07e1691cb55b78fea12bf97c0ebab50e74dfaa755026afda9eb05105899b7dbba5438bf533b18ede51b8bdb32404bd26e32763d4ee11a003c5b078828d807bf5aad1d06e0ff6de53fafa8a8aad98f2f4dc8ae7fb6d8a8920b8c5fd0cc01300744d69b33fdf1dc269aeb5257b8c8f6ea2e678d796608d18b7cffebc7860f04fbedfb1a6aad51e510ac649674926c6f9593139ca5133025968378e43107d2f24ae0476a9f53ca8f8a8af05f7c23af7c773f0229201c0ba3445ff9c4d7240e755e320e2b56a897bfdf498c8e243019a3c1136d7f4ed7084800ae2c8912435dcf3ea0db9a3287c96cc06c2fdfd4adbff19fddb92a64ee608ce6bbc6c65d35af689aa8c0a5b00c33a6e62c42c0d2d6987d818cf24899f9a477a27c81b032683adf013e0ee02194e8054d1cc090efcb63c62e98445fc1c34f353d019fdcda72c21ab39c2d6d3b26311a06a9fb1cfb01462039e3a4f2fe2071e7f7f0e16fab38490360190d359560dae78740b8377393a2f2a965c51a2aa6246b8b34b916bd46d77b6402ea98d26a4052cb3a984ebbe39b543f335a66e497ecb50cda064af05c9a5fbb1cb1b572f09b43b760a447fe1d7bdd373622b4bd3e044525906f685ba2651dd658151a2a356e0ffa7a99ad18d8d85910f0850519cba00e076adbb7f2862e1c8dee3d56f78b259a740e02f39ea27a3b3859a87a5f80af106dcefcb4c094a643f5f3ee7cdedae42d28e30e2c8c6f3989c6100395dada7db37945f01b9e12f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Malloc Lab</title>
      <link href="/posts/malloc-lab/"/>
      <url>/posts/malloc-lab/</url>
      
        <content type="html"><![CDATA[<h2 id="basic-info">Basic Info</h2><p>这是CMU 15-213的Malloc Lab，本来没打算做，被同学安利了一波~<br />需要用C语言实现一个动态内存分配器(Dynamic StorageAllocator)，类似于<code>Glibc</code>中的<code>malloc/free/realloc</code>,由于涉及到很多未知类型的指针操作, 整体来看难度较大.</p><p>开始没什么思路，看了下CSAPP动态内存分配那一节，内存的划分是这样子的：<img src="https://img-blog.csdnimg.cn/2020101116464245.png" alt="在这里插入图片描述" style="zoom:80%;" />程序动态申请的内存主要是Heap段，Allocator将堆视作不同size的块，Allocator有2种：</p><ul><li>ExplicitAllocators：需要应用程序手动释放申请的内存块，<code>malloc/free</code></li><li>Implicit Allocators：就是garbage collectors</li></ul><p><code>malloc</code>返回的对齐地址取决于编译环境，32位是8的倍数，64位是16的倍数；<code>malloc</code>不会初始化申请的内存，<code>calloc</code>会初始化内存为0。堆的增长是通过增加内核的<code>brk</code>指针来增加/减小堆：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span>;  <span class="comment">// success: old brk pointer; error: -1</span></span><br></pre></td></tr></table></figure>如果<code>free</code>的是一个非法指针，那么结果未定义。</p><p>主要实现在<code>mm.c</code>中，有4个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mm_init</code>负责初始化, 比如分配初始的堆空间,初始化自定义的数据结构. 成功返回0，失败返回-1;</li><li><code>mm_malloc</code>负责分配指定payload大小的块，但是这个分配的块必须在已经<code>extend</code>的堆里,且不能与其他已分配的块重叠; 返回指向该块payload的指针, 按照8B对齐,与<code>libc</code>中实现的<code>malloc</code>类似,最后会有一个PK；<br /></li><li><code>mm_realloc</code>负责：</li><li><code>ptr==NULL</code>等价于<code>void *mm_malloc(size)</code></li><li><code>size==0</code>等价于<code>mm_free(ptr)</code></li><li>如果<code>ptr</code>不为<code>NULL</code>，把<code>ptr</code>所指的内存块增加/减小到<code>size</code>个字节，返回新地址（可能与原来的块相同，也可能不同，取决于实现方式、原块里内碎片的数量以及请求<code>size</code>的大小），保持原块的内容不变（如果申请变大，剩下的空间是未初始化的；如果申请变小，那么只保留<code>size</code>大小的原块内容）</li></ul><p><code>memlib.c</code>为我们的分配器模拟了内存系统，可以调用里面的一些函数：<br /><code>void *mem_sbrk(int incr)</code>:将堆扩展<code>incr</code>字节，参数是正整数，返回新扩展的内存起始地址；<br /><code>void *mem_heap_lo()</code>: 返回堆的首地址；<br /><code>void *mem_heap_hi()</code>: 返回堆的最后一个字节的地址；<br /><code>size_t mem_heapsize()</code>: 返回当前堆的大小；<br /><code>size_t mem_pagesize()</code>: 返回系统页面大小。</p><h2 id="implementation">Implementation</h2><p>首先明确设计约束条件：</p><ul><li>可以处理任意的请求释放序列</li><li>请求需要被立即响应</li><li>内存对齐要求</li><li>不能修改已经分配的内存块</li></ul><p>再明确设计目标：</p><ul><li>最大化吞吐量：平均每秒能够完成的操作次数</li><li>最大化内存利用率：<code>mm_alloc</code>或<code>mm_realloc</code>申请但还未被释放的内存空间与堆大小的比值</li></ul><p>内存利用率最大化：用peak utilization衡量，假设有<spanclass="math inline">\(n\)</span>个请求：<span class="math inline">\(R_0,R_1, ... R_k, ..., R_{n-1}\)</span>，在<spanclass="math inline">\(R_k\)</span>完成后，将aggregatepayload(申请的字节总数)记作<spanclass="math inline">\(P_k\)</span>，当前的堆的大小记作<spanclass="math inline">\(H_k\)</span>(单调不减)，单调不减的条件可以通过使<spanclass="math inline">\(H_k\)</span>为high-watermark来松弛，这样堆就可以上下都增长。那么peak utilization为： <spanclass="math display">\[U_k=\frac{max_{i\leq k}P_i}{H_k}\]</span>我们的目标是最大化<span class="math inline">\(U_{n-1}\)</span>。</p><p>这两目标是需要trade-off的，吞吐量越大，意味着需要提高速度，减小操作的时间，往往就不能花费时间去处理碎片，利用率下降；<br />内存利用率越大，意味着要精心处理分配和回收的块，自然需要更多的时间，吞吐量下降。</p><p>具体来说，有以下几点： <imgsrc="https://img-blog.csdnimg.cn/20201023215211206.png"alt="在这里插入图片描述" />这些关键细节的设计非常重要，再BB一次：程序架构、数据结构和接口设计是一门艺术！</p><ul><li><code>free</code>只给一个指针，怎么知道要释放多少空间：记录每一块的大小；</li><li><strong>空闲块的组织管理</strong>：隐式链表、显式（双向）空闲链表（存储指针域开销太大）、SegregatedFree Lists</li><li><strong>Placement Policy</strong>:有多个满足要求的空闲块，如何选择以放置新的申请：First Fit, Next Fit,Best Fit</li><li>Splitting:在一个空闲块放置申请后如何处理剩余的空闲空间。可以直接将整个空闲块分配出去，也可以将剩余的空闲空间重新利用；</li><li>无法找到合适的满足请求的块：做空闲块合并后再次检查是否可以满足；用<code>sbrk</code>向内核申请更多的内存，插入空闲链表；</li><li><strong>空闲块合并</strong>：需要考虑何时合并：立即合并（可能引发抖动）、延迟合并（申请失败时合并整个堆里所有的空闲块）；合并后面的块很容易，但是要高效合并前面的空闲块，需要用双向的BoundaryTag(可以优化以减少空间开销)；</li></ul><p>不仅需要记录每块的大小，还需要区分已分配块和空闲块，所以block的格式可以设计如下：<img src="https://img-blog.csdnimg.cn/20201011195117307.png"alt="在这里插入图片描述" /> 如果要求double-word(8B)对齐，那么Blocksize总是8的倍数，所以低3位都是0，可以利用其存储分配状态。</p><p>这样整个堆就可以组织为连续的分配和空闲块，由于已经存储了每块的大小，所以隐式空闲链表就应运而生：<img src="https://img-blog.csdnimg.cn/20201014165121101.png"alt="在这里插入图片描述" /></p><p>隐式空闲链表的优点就是实现简单，缺点就是当需要在所有的空闲块中查找时（如placement），需要扫描整个堆（包括已经分配的块）。显式链表的分配时间复杂度是<spanclass="math inline">\(O(free)\)</span>，速度较慢但是如果采取bestfit，内存利用率会比segregated free lists好一些。</p><p>为了降低隐式空闲链表合并的复杂度，Knuth大佬提出了boundarytags，这样实际上相当于隐式双向链表： <imgsrc="https://img-blog.csdnimg.cn/20201011214226551.png"alt="在这里插入图片描述" /></p><p>这样就可以通过Footer在<spanclass="math inline">\(O(1)\)</span>检查之前的块的状态及其开始位置，缺点在于如果小的内存块比较多的话，内存浪费太大。<br />双向tag带来的内存开销可以优化：只有前面的块是空闲，才需要它footer里的大小，所以可以在每个块用后3位里的某一位来存储前面块的状态，那么已分配块就不需要footer了，可以把footer的空间用来当作payload，但是空闲块仍然需要2个tag。</p><p>那么现在整个堆变成了这样： <imgsrc="https://img-blog.csdnimg.cn/20201016204303577.png"alt="在这里插入图片描述" /> 这里的<code>heap_listp</code>指向Prologueblock的中间是做了一些小优化，方便直接定位到下一块的数据位置。</p><p>这里的实现非常tricky和subtle，一开始只申请了4words共16B(unused(1)+Prologue(2)+Epilogue(1))，后续的<code>extend_heap</code>申请一个空闲块后，将原来的Epilogue作为空闲块的header，空闲块的最后一个word变为新的Epilogue。</p><p>由于对齐要求（Headers在非对齐位置，Payloads对齐），分配器应该有一个minimumblock size，即使只请求了1B，也要分配minimum block size，这里是16B。</p><p>写代码时先实现并测试<code>malloc</code>和<code>free</code>，如果能正确并且高效执行，再去实现<code>realloc</code>。</p><h2 id="evaluation">Evaluation</h2><p>性能主要考虑2方面因素：</p><ul><li>空间利用率<span class="math inline">\(U\)</span>：peakratio即评测程序申请的总内存（<code>mm_malloc/mm_realloc</code>但是还没有<code>mm_free</code>）与分配器使用的堆容量的比值，需要用好的策略减小碎片，使得该值接近1；</li><li>吞吐量<spanclass="math inline">\(T\)</span>：每秒完成的操作数量</li></ul><p>评测程序会综合考虑2个方面，计算一个performance index <spanclass="math display">\[P=wU+(1-w)min(1,\frac{T}{T_{libc}})\]</span><spanclass="math inline">\(T_{libc}\)</span>是<code>libc</code>中的<code>malloc</code>的吞吐量，大概在600Kops/s左右，<spanclass="math inline">\(w=0.6\)</span>。 这个<spanclass="math inline">\(P\)</span>既考虑了内存资源，又考虑了CPU资源，两个矛盾的指标需要适当权衡。</p><p>第一个版本<code>mm1.c</code>基本就是抄书，Implicit Free Lists+FirstFit+Bi Boundary Tag，抄书也就将将及格。。 <imgsrc="https://img-blog.csdnimg.cn/20201115143013580.png"alt="在这里插入图片描述" /> 将First-Fit改成Next-Fit，还不错： <imgsrc="https://img-blog.csdnimg.cn/20201115202312126.png"alt="在这里插入图片描述" />可以看到：Next-Fit在速度上有很大提升，主要是因为它是从上次终止的块开始搜索，避免了前面很多块的无效搜索。</p><p>最后对于Implicit Lists的性能做个总结：<br />分配：<span class="math inline">\(O(n)\)</span><br />释放：<span class="math inline">\(O(1)\)</span><br />Memory Overhead：取决于First Fit等策略</p><p>感觉这个性能已经不错了，但是一些无聊的计算机科学家还是不满意分配时的效率。接着我们看下更加🐂🍺的方法SegregatedFree Lists： <imgsrc="https://img-blog.csdnimg.cn/20201024204031234.png"alt="在这里插入图片描述" /> 每个size级别的块都有自己的freelist，分配大小为n的块时：</p><ul><li>搜索合适的free list使得size&gt;n</li><li>找到：split并将remainder放入应该去的list</li><li>未找到：向操作系统申请更大的内存，分出去n，将剩下的放入相应的list</li></ul><p>释放时合并空闲块并且放入相应的free list即可。</p><p>这实际上近似模拟了Best Fit，而且不用搜索整个free list，BestFit一般有着最优的内存利用率，但是运行时间<spanclass="math inline">\(O(n)\)</span>，又是吞吐量和内存利用率的trade-off，终于明白了为什么官方的<code>malloc</code>要用这个方式了：吞吐量更大<spanclass="math inline">\(O(lgn)\)</span>、更优的内存利用率Best Fit。</p><p>Segregated FreeLists中的空闲块包含Header+prev+next+padding+Footer，已分配块没有前后指针。写代码要注意：整个堆中的块位置是不变的，只是状态（分配、释放）在改变，整个堆中的空闲块是用seglist的方式串起来的。</p><p>Debug可以自己写一下<code>mm_check</code>，还是很有用的。<code>realloc</code>快de疯了，整整一个晚上。。。其实就4种情况：</p><ol type="1"><li>如果当前已分配块后面是结尾块，直接申请新的堆空间，与原块组合返回；</li><li>如果当前已分配块后面是一个空闲块，且两者之和&gt;=size，组合返回；</li><li>如果当前已分配块后是一个空闲块，但两者之和&lt;size，但是空闲块后是结束块，申请新的堆空间，三者组合返回；</li><li>malloc新块，将原块复制，释放原块。</li></ol><p>第一次写完，只有85，内存利用率太差了： <imgsrc="https://img-blog.csdnimg.cn/20201117220719669.png"alt="在这里插入图片描述" /><code>place</code>的时候，如果申请块比较大，我们将其分配到后半部分，将前半部分切割为空闲：<img src="https://img-blog.csdnimg.cn/2020111909030584.png"alt="在这里插入图片描述" /> 之前class的划分是1，2-3，4-7，8-15...但是最小块是16B，所以16B以下的用不到，所以改为0-16B，17-32，...，257-512MB</p><p>这样优化后直接96： <imgsrc="https://img-blog.csdnimg.cn/20201119092357832.png"alt="在这里插入图片描述" />后面还可以继续优化榨干性能，比如去掉已分配块的Footer，<code>realloc</code>组合块以后对remainder进行split...<br />以后有时间再说......</p><h2 id="思考">思考</h2><p>显然上述实现只是toy example, 工业界涌现了很多优秀的内存分配器,如glibc自带的ptmalloc, Google的tcmalloc, Facebook的jemalloc.</p><h2 id="reference">Reference</h2><p><ahref="https://stackoverflow.com/questions/9866145">tcmalloc/jemalloc</a><br /><ahref="https://www.cyningsun.com/07-07-2018/memory-allocator-contrasts.html">对比分析</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stacking</title>
      <link href="/posts/stacking/"/>
      <url>/posts/stacking/</url>
      
        <content type="html"><![CDATA[<p>EnsembleLearning的基本思想就是将多个基学习器组合在一起，产生泛化能力更强的模型。<br />组合策略有许多种，包括Voting、平均法和Stacking等，Stacking就是选择某种学习器作为组合基学习器的方式。<br /><img src="https://img-blog.csdnimg.cn/20200926193430376.png"alt="在这里插入图片描述" /><br />既然要结合多个基学习器的优点，那么基学习器的选择最好是“准而不同”，元学习器一般选择比较简单的模型（如逻辑回归），防止过拟合。<br />比较简单的想法就是将全部训练集用于训练基学习器，将基学习器的预测结果作为元学习器的训练集，从而得到整个模型。<br />这样做的问题在于：基学习器最终在训练集上的表现非常好，再用基学习器在该训练集上的预测结果作为次级训练集，同样元学习器在该训练集上表现也会非常好，但是模型的泛化能力不一定很好，有过拟合的风险。<br />因此，采用K折交叉验证的方式，用训练基学习器未使用的样本来产生次级训练集。<br /><img src="https://img-blog.csdnimg.cn/20201109191045436.jpg"alt="在这里插入图片描述" /><br />具体来讲：<br />在训练阶段（假设训练集<spanclass="math inline">\(400*10\)</span>），对于每个基学习器（假设有3个基学习器），进行5次训练与验证，得到<spanclass="math inline">\(400*1\)</span>的验证结果，那么最终次级训练集是<spanclass="math inline">\(400*3\)</span>（类标签还是原始类标签），用这些数据训练次级学习器，完成后再用全部的训练集训练所有的基学习器（可选，提高基学习器性能）；<br />在测试阶段，如果训练阶段选了最后一步，那么每个基学习器直接得到一个结果，就会得到3个测试结果，送入次级学习器，得到最终的预测结果；如果训练时没有选最后一步，那么每个基学习器都有5个小模型，将测试样本用5个小模型分别测试，将5个结果平均得到某个基学习器的预测结果，也会得到3个测试结果。<br /><img src="https://img-blog.csdnimg.cn/20201109192340496.png"alt="在这里插入图片描述" /><br />Weka里的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Buildclassifier selects a classifier from the set of classifiers</span></span><br><span class="line"><span class="comment">   * by minimising error on the training data.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> data the training data to be used for generating the</span></span><br><span class="line"><span class="comment">   * boosted classifier.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the classifier could not be built successfully</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 建立整个模型</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildClassifier</span><span class="params">(Instances data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_MetaClassifier == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No meta classifier has been set&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断分类器是否有能力处理该数据集</span></span><br><span class="line">    getCapabilities().testWithFail(data);</span><br><span class="line">    <span class="comment">// 删除类标签缺失数据</span></span><br><span class="line">    Instances newData = <span class="keyword">new</span> Instances(data);</span><br><span class="line">    m_BaseFormat = <span class="keyword">new</span> Instances(data, <span class="number">0</span>);</span><br><span class="line">    newData.deleteWithMissingClass();</span><br><span class="line">    </span><br><span class="line">    Random random = <span class="keyword">new</span> Random(m_Seed);</span><br><span class="line">    newData.randomize(random); <span class="comment">// 打乱整个数据集</span></span><br><span class="line">    <span class="comment">// 如果是分类问题，分层抽样</span></span><br><span class="line">    <span class="comment">// 原始数据按照类标签集中在一起，按m_NumFolds为步长重新抽取数据，保持训练集/验证集数据分布一致性, 避免因数据划分引入额外的偏差</span></span><br><span class="line">    <span class="keyword">if</span> (newData.classAttribute().isNominal()) &#123;</span><br><span class="line">      newData.stratify(m_NumFolds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理原始数据得到新的数据，建立meta classifier</span></span><br><span class="line">    generateMetaLevel(newData, random);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// restart the executor pool because at the end of processing</span></span><br><span class="line">    <span class="comment">// a set of classifiers it gets shutdown to prevent the program</span></span><br><span class="line">    <span class="comment">// executing as a server</span></span><br><span class="line">    <span class="comment">// 创建线程池，为下面的基学习器训练做准备</span></span><br><span class="line">    <span class="keyword">super</span>.buildClassifier(newData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提高基础模型的准确度，使其在测试数据表现更好，用所有的训练集进行基学习器的训练</span></span><br><span class="line">    <span class="comment">// 这里为了节省时间，测试时，可以直接在多个基学习器预测后取平均</span></span><br><span class="line">    <span class="comment">// Rebuild all the base classifiers on the full training data</span></span><br><span class="line">    buildClassifiers(newData);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Generates the meta data</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newData the data to work on</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> random the random number generator to use for cross-validation</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">generateMetaLevel</span><span class="params">(Instances newData, Random random)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 先用newData得到metaData的格式m_MetaFormat</span></span><br><span class="line">    <span class="comment">// 确定元分类器需要的属性</span></span><br><span class="line">    Instances metaData = metaFormat(newData);</span><br><span class="line">    m_MetaFormat = <span class="keyword">new</span> Instances(metaData, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_NumFolds; j++) &#123;</span><br><span class="line">      <span class="comment">// 得到训练集</span></span><br><span class="line">      Instances train = newData.trainCV(m_NumFolds, j, random);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// start the executor pool (if necessary)</span></span><br><span class="line">      <span class="comment">// has to be done after each set of classifiers as the</span></span><br><span class="line">      <span class="comment">// executor pool gets shut down in order to prevent the</span></span><br><span class="line">      <span class="comment">// program executing as a server (and not returning to</span></span><br><span class="line">      <span class="comment">// the command prompt when run from the command line</span></span><br><span class="line">      <span class="comment">// 线程池，多线程并行构建基学习器</span></span><br><span class="line">      <span class="keyword">super</span>.buildClassifier(train);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建基学习器</span></span><br><span class="line">      buildClassifiers(train);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Classify test instances and add to meta data</span></span><br><span class="line">      <span class="comment">// 将未使用过的原始训练数据通过基学习器预测后加入metadata作为新的训练集</span></span><br><span class="line">      Instances test = newData.testCV(m_NumFolds, j);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.numInstances(); i++) &#123;</span><br><span class="line">        metaData.add(metaInstance(test.instance(i)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用元数据建立元分类器</span></span><br><span class="line">    m_MetaClassifier.buildClassifier(metaData);    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>因为基学习器之间的训练是独立的，所以每次交叉验证划分好数据后，都是利用线程池并行训练。<br />如果是在分层抽样的基础上划分训练集和验证集，<code>trainCV()</code>抽取数据后，需要将新的训练集Shuffle，保证独立同分布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes the format for the level-1 data.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> instances the level-0 format</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the format for the meta data</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the format generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 生成元数据格式</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Instances <span class="title">metaFormat</span><span class="params">(Instances instances)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果m_BaseFormat属性连续，就加入m_Classifiers.length个属性</span></span><br><span class="line">    <span class="comment">// 如果是离散的，每次要加入level 0类别属性取值个数个属性</span></span><br><span class="line">    ArrayList&lt;attribute&gt; attributes = <span class="keyword">new</span> ArrayList&lt;attribute&gt;();</span><br><span class="line">    Instances metaFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历基学习器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m_Classifiers.length; k++) &#123;</span><br><span class="line">      Classifier classifier = (Classifier) getClassifier(k);</span><br><span class="line">      String name = classifier.getClass().getName() + <span class="string">&quot;-&quot;</span> + (k+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (m_BaseFormat.classAttribute().isNumeric()) &#123;</span><br><span class="line">        attributes.add(<span class="keyword">new</span> Attribute(name));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果离散，后续会通过每个取值的概率来判断，比如杂色、圆花，这2种特性不能用一个属性表示，所以每个取值都要独立成单独的属性</span></span><br><span class="line">          <span class="comment">// 来保存概率值</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_BaseFormat.classAttribute().numValues(); j++) &#123;</span><br><span class="line">            attributes.add(</span><br><span class="line">              <span class="keyword">new</span> Attribute(</span><br><span class="line">              name + <span class="string">&quot;:&quot;</span> + m_BaseFormat.classAttribute().value(j)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加上原始类标签</span></span><br><span class="line">    attributes.add((Attribute) m_BaseFormat.classAttribute().copy());</span><br><span class="line">    <span class="comment">// 形成元数据格式</span></span><br><span class="line">    metaFormat = <span class="keyword">new</span> Instances(<span class="string">&quot;Meta format&quot;</span>, attributes, <span class="number">0</span>);</span><br><span class="line">    metaFormat.setClassIndex(metaFormat.numAttributes() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> metaFormat;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>生成元数据格式时，如果是分类问题，类标签的每个属性都被作为一个新的属性：<br /><img src="https://img-blog.csdnimg.cn/20201109195503863.png"alt="在这里插入图片描述" /><br />这里我个人这样理解：有的基分类器可以输出属于某个类的概率（如逻辑回归），将概率作为元属性而不是直接将基学习器的分类结果作为元属性，这样做能够减小基学习器的分类误差带给元学习器的影响，模型整体更加精确：<br /><img src="https://img-blog.csdnimg.cn/20201109195918632.png#pic_center"alt="在这里插入图片描述" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes a level-1 instance from the given instance.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> instance the instance to be transformed</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the level-1 instance</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the instance generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 产生元数据</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Instance <span class="title">metaInstance</span><span class="params">(Instance instance)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// values保存分类结果，连续属性直接保存，离散属性则先求得分布，将每种取值的分布加入values，设置为m_MetaFormat格式返回</span></span><br><span class="line">    <span class="keyword">double</span>[] values = <span class="keyword">new</span> <span class="keyword">double</span>[m_MetaFormat.numAttributes()];</span><br><span class="line">    Instance metaInstance;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m_Classifiers.length; k++) &#123;</span><br><span class="line">      Classifier classifier = getClassifier(k);</span><br><span class="line">      <span class="keyword">if</span> (m_BaseFormat.classAttribute().isNumeric()) &#123;</span><br><span class="line">        values[i++] = classifier.classifyInstance(instance);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 基学习器对该实例的分类的概率分布, sum(dist)=1</span></span><br><span class="line">        <span class="keyword">double</span>[] dist = classifier.distributionForInstance(instance);</span><br><span class="line">        <span class="comment">// 将该基学习器对该实例的预测概率输出到对应的元属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dist.length; j++) &#123;</span><br><span class="line">          values[i++] = dist[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标签值对应最后一个元属性</span></span><br><span class="line">    values[i] = instance.classValue();</span><br><span class="line">    metaInstance = <span class="keyword">new</span> DenseInstance(<span class="number">1</span>, values);</span><br><span class="line">    metaInstance.setDataset(m_MetaFormat);</span><br><span class="line">    <span class="keyword">return</span> metaInstance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在实际数据集上的结果其实不一定比其他模型效果好，可能是我参数调的不好吧（雾）~</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bear Maps</title>
      <link href="/posts/bear-maps/"/>
      <url>/posts/bear-maps/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>这是CS 61B的Project3，也是最后一个Proj。刚好上完这门课出去旅个游，放松下心情开始15213。<br />完成基本的要求花了5天时间，当然现在的版本还十分简陋，这个工程我是想做得比较大，后面还得抽时间消化理解、完善优化。</p><p>SP18用了<a href="https://maven.apache.org/">ApacheMaven</a>做项目建构工具，<ahref="https://blog.csdn.net/qq_41431457/article/details/102999439">折腾</a>了一天也没有配好，<del>不知道这么垃圾的工具有啥用</del>，最后实在没辙就把该项目所有需要的jar包导进来，后来发现SP19就抛弃了maven。<br /><img src="1.png" alt="在这里插入图片描述" /><br />项目需要的地图集以及地图上的点/路信息都是Google采集好的，可在<ahref="https://github.com/Berkeley-CS61B">这里</a>下载，当然这个地图只是一小部分，后面想要扩展可以去下载需要的<ahref="https://www.openstreetmap.org/">数据集</a>，包括tile images和mapfeature data。</p><p>整体需求是实现一个网页端地图，用户通过浏览器输入URL，Java程序接收，然后生成相应的地图结果并返回，在浏览器中显示。服务器框架用的是<ahref="http://sparkjava.com/documentation.html#getting-started">Spark</a>，前端以及前后端交互的部分已经写好了（TA真的太强了），其实我有时候觉得这些dirty的工作比较考验码力，这些代码写得漂亮说明System的能力是挺强的。</p><p>后端至少需要实现3个类：</p><ul><li><code>Rasterer</code><br />输入upper left latitude and longitude, lower right latitude andlongitude, a window width, and a window height.<br />输出2D array of filenames corresponding to the files to berendered.</li><li><code>GraphDB</code><br />输入Open Street Map数据集，将其转为图存储起来：每个结点是a singleintersection，每条边是一条路。</li><li><code>Router</code><br />输入GraphDB, a starting latitude and longitude, and a destinationlatitude and longitude.<br />输出从起点到终点的一系列结点，以及路径导航信息。</li></ul><h2 id="map-rastering">Map Rastering</h2><p>首先要将用户查询的真实世界的经纬度信息转为实际地图，<code>Rasterer.java</code>会接收用户请求的矩形参数<code>Map&lt;String, Double&gt; params</code>，生成对应的图像名称<code>String[][]</code>：<br />主要工作在<code>getMapRaster()</code>方法中完成，用户输入的查询请求共有6个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;lrlon=-<span class="number">122.2104604264636</span>, ullon=-<span class="number">122.30410170759153</span>, w=<span class="number">1085.0</span>, h=<span class="number">566.0</span>, ullat=<span class="number">37.870213571328854</span>, lrlat=<span class="number">37.8318576119893</span>&#125;</span><br></pre></td></tr></table></figure><p>表示用户希望显示经度范围<code>lrlon</code>~<code>ullon</code>，纬度范围<code>ullat</code>~<code>lrlat</code>的区域，并且分辨率大概是<code>w*h</code>。</p><p>街景图采用<strong>冗余存储</strong>，所有图片都是<code>256*256</code>：<code>d0_x0_y0.png</code>是整个区域的街景，但是分辨率最低，<code>d1_x0_y0.png/d1_x0_y1.png/d1_x1_y0.png/d1_x1_y1.png</code>分别代表西北/东北/西南/东南四个角的街景，但是分辨率加倍。</p><p>更加规范的说：在第D个缩放级别，共有<spanclass="math inline">\(4^D\)</span>张图片，<code>dD_x0_y0.png</code>到<code>dD_xk_yk.png</code>，<spanclass="math inline">\(k=2^D-1\)</span>，随<code>x</code>增大向东移动，随<code>y</code>增大向南移动，我们需要返回<code>String[][]</code>代表用户请求区域的图片文件名矩阵，当然还有一些其他参数（查询是否成功等）：由于Java只能返回一个值，所以结果组装成<code>Map&lt;String, Object&gt;</code>返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[d2_x0_y1.png, d2_x1_y1.png, d2_x2_y1.png, d2_x3_y1.png],</span><br><span class="line">[d2_x0_y2.png, d2_x1_y2.png, d2_x2_y2.png, d2_x3_y2.png],</span><br><span class="line">[d2_x0_y3.png, d2_x1_y3.png, d2_x2_y3.png, d2_x3_y3.png]]</span><br></pre></td></tr></table></figure><p>上述返回结果的分辨率为<code>1024*768</code>，几乎满足用户分辨率要求<code>1085*556</code>。</p><p>这样对于同一个区域，可以有很多选择：可以用更多张高分辨率图片的组合，也可以用较少几张低分辨率的图片组合，只要满足用户要求，比如对于上述例子，<code>d2_x0_y1.png</code>可以采用<code>d3_x0_y2.png/d3_x1_y2.png/d3_x0_y3.png/d3_x1_y3.png</code>代替，这样返回的图片是<code>6*8</code>共48张，分辨率可达<code>2048*1536</code>。</p><p>但这样做很可能overflow，远远超过用户要求，浪费时间和资源，因为分辨率高就意味着展示的空间小，并且前端是不会做缩放的，如果用很多高分辨率图片，浏览器会有太多太多照片加载显示，因为大家都是<code>256*256</code>的。</p><p>所以定义单位像素的经度距离：<span class="math inline">\(\text{LonDPP}= \frac{\text{lower right longitude} - \text{upper leftlongitude}}{\text{width of the image (or box) inpixels}}\)</span>，我们要展示的是小于用户要求的LonDPP的最大值，比方说用户要求每个像素2度，如果我们大于2，那么分辨率低到不能满足要求，只有小于2才能满足要求。又不能太小，分辨率太高展示范围变小。当然如果用户要求的LonDPP很低，只能用现有的最低的LonDPP图片，即<code>d7</code>系列。<br />可以将LonDPP理解为模糊程度，LonDPP越大，显示的图片越模糊，比如<code>d0</code>系列就有最大的LonDPP。<br />纬度也要做类似处理。</p><p>举例来看：<code>d2</code>系列共有16张图片，用户请求QueryBox应该返回9张图片：<br /><img src="2.png" alt="在这里插入图片描述" /><br />具体实现只有1个方法<code>public Map&lt;String, Object&gt; getMapRaster(Map&lt;String, Double&gt; params)</code>，分2步：</p><ul><li>需要的图片的<code>depth</code><br />全图即<code>d0</code>的经纬度范围是：<code>-122.29980, 37.89220/-122.21191, 37.82280</code><br />因为地球不是规则的，但是在确定Depth时，经度方向的LonDPP满足要求即可，不需考虑纬度方向的影响。</li><li>确定四个角的下标</li><li>corner case<br />判断输入是否合法时，边界判断一定要加EPS，不然一点小误差会崩掉程序。<br />输入不合法（用户拖动至全图外等），将<code>query_success</code>置为<code>false</code>返回即可。</li></ul><p>Bug：读取图片文件时，总是<code>javax.imageio.IOException: Can't read input file!</code>。一般都是路径问题。</p><h2 id="routing-location-data">Routing &amp; Location Data</h2><p>明确了前端需要显示哪些图片后，接下来就是要建一个图，因为最后要路径规划嘛。<br />路由和位置数据是通过<code>berkeley-2018.osm.xml</code>文件给的，是整个<ahref="https://download.bbbike.org/osm/">地球数据</a>的一部分，文件格式是<ahref="https://wiki.openstreetmap.org/wiki/OSM_XML">OSM XML</a>。</p><p>解析XML数据用的是SAXParser，遍历每个element，在每个元素的开始和结束位置，调用<code>startElement</code>和<code>endElement</code>回调函数。</p><p>先来熟悉下OSM XML文档：<br /><img src="3.png" alt="在这里插入图片描述" /><br /><code>node</code>元素是组成地图的主干，有id/lat/lon等属性。如果结点是一个位置，那么<code>tag</code>标签就会有<code>name</code>，如果是其他的，比如路上的一个点，那么就没有<code>tag</code>。<br /><img src="4.png" alt="在这里插入图片描述" /><br /><code>way</code>元素表示一条路，路上可能有很多<code>node</code>，用<code>id</code>表示。<code>tag</code>会包含额外信息，如果<code>name</code>是highway，那么<code>v</code>就是道路类型。假设所有道路都是双向的。</p><p>在类<code>GraphDB</code>中存储图，要求允许插入和删除结点，最后要用<code>clean()</code>清理掉没有连接的结点。<br /><code>GraphBuildingHandler</code>会解析XML文件并调用<code>GraphDB</code>的一些接口函数构建整个图。</p><p>如果选择邻接矩阵存储，由于这是一个动态的图，可能要增加或者删除结点，所以一开始顶点个数是不确定的，也就不能用<code>int[][]</code>表示。所以选择邻接表，因为有<code>clean()</code>操作，需要判断结点是否与其他结点相邻，邻接表速度更快。</p><p><code>GraphBuildingHandler</code>每次只处理XML的一行，也就是一个标签，<code>GraphBuildingHandler</code>这个类可以被其它方法多次调用去处理完所有的XML，我发现这种拆分很有用，系统会变得简单，只需要考虑当前状态就很好写。清楚需求后，需要设计类的接口，数据结构和算法，这才是最难的部分。</p><p>由于parser的解析是从上到下的，所以处理<code>way</code>时最好不要直接把边和边上的结点直接加进图里，因为后面的<code>highway</code>的值可能不在合法范围内，这种边是不算的。所以在碰到边上的点，先存到一个数组里，最后<code>endElement()</code>时候如果路合法，再加进图里。处理<code>node</code>也同理，在<code>endElement()</code>时加入图。记得每次做完一个<code>node</code>或<code>way</code>要<code>clear()</code>上一个的状态信息。</p><p>每个<code>node</code>有一些属性（id/lat/lon），每条边也有一些属性（fromID/toID/name），所以首先要有<code>Node</code>类和<code>Edge</code>类。<br />邻接表的顶点表<code>Map&lt;Long, Node&gt; vertex</code>，边表<code>Map&lt;Long, Set&lt;Edge&gt;&gt; adj</code>。</p><p>Bug：对<code>ArrayList</code>等在迭代时同时进行修改就会引发异常<code>ConcurrentModificationException</code>。</p><p><code>long closest(double lon, double lat)</code>方法会被用来找最短路，需要返回最近的<strong>有邻居</strong>的<code>node</code>，一个点可能没有邻居，因为他是饭店啥的，不能用来找最短路。另外，这个方法复杂度要求<spanclass="math inline">\(O(lgn)\)</span>，先实现一个<spanclass="math inline">\(O(n)\)</span>的做法，后续有时间再去优化吧。</p><h2 id="route-search">Route Search</h2><p>建好地图后，就要做路由工作：给定起点和终点的经纬度，选一条距离最短的路径，需要在类<code>Router</code>中实现<code>shortestPath</code>方法。<br />应该从距起点最近的<code>node</code>开始导航到距终点最近的<code>node</code>结束，当然这些<code>node</code>必须是connected的。</p><p>两个<code>node</code>间的距离采用<ahref="https://en.wikipedia.org/wiki/Great-circle_distance">great-circledistance</a>，即当作球模型来计算弧长距离。整体距离就是计算1-2之间、2-3之间...的距离之和，还要考虑经度和纬度有不同的尺度，并且随着纬度变化，每度代表的实际距离也是不同的，还好计算距离的函数已经由🐂🍺的TA写好了。</p><p>最好用A*而不是Dijkstra，启发函数h(n)用结点n到终点的great-circledistance就行，要注意目标不可达的情况。</p><p>开始只能在<code>berkeley-2018-small-osm.xml</code>上跑起来，我以为是笔记本配置太烂，跑大的数据集跑不动，只能用小的来测试，后来发现<code>GraphDB</code>里一行写错了。。。debug真痛苦啊！！</p><p>找到最优路线后，这里有一个optionalfeature，就是显示方向导航信息Turn-by-turnNavigation，需要在类<code>Router</code>中实现<code>routeDirections</code>方法。导航方向的表示是在<code>Router</code>类中写了一个新类<code>NavigationDirection</code>，具体的导航信息格式如下：<br />DIRECTION on WAY for DISTANCE miles<br />其中，DIRECTION有8种选择：</p><ul><li>“Start”</li><li>“Continue straight”</li><li>“Slight left/right”</li><li>“Turn left/right”</li><li>“Sharp left/right”</li></ul><p>所以我们需要确定正确的DIRECTION/WAY/DISTANCE，方向取决于当前结点和上一个节点间的<ahref="https://en.wikipedia.org/wiki/Bearing_(navigation)">relativebearing</a>：</p><ul><li>Between -15 and 15 degrees the direction should be “Continuestraight”.</li><li>Beyond -15 and 15 degrees but between -30 and 30 degrees thedirection should be “Slight left/right”.</li><li>Beyond -30 and 30 degrees but between -100 and 100 degrees thedirection should be “Turn left/right”.</li><li>Beyond -100 and 100 degrees the direction should be “Sharpleft/right”.</li></ul><p>难点在于：一条<code>way</code>上可能包含了若干<code>node</code>，如何在遍历<code>node</code>的过程中判断<code>way</code>是否发生了改变，只有<code>way</code>变化后才能产生一条新的导航信息。如果恰好来到了一条没有<code>name</code>的路，就将WAY设为“unknownroad”。</p><p>举例来说：<br />假设出发的<code>node</code>在“ShattuckAvenue”这条路上，那么DIRECTION应该设为“Start”，遍历接下来的<code>node</code>时，需要累加在这条路上走过的距离，最终到达一个不在“ShattuckAvenue”的<code>node</code>时，设置WAY为“ShattuckAvenue”，DISTANCE为之前的累加值。接着，下一条导航信息的DIRECTION应该根据相对方位计算，WAY是当前<code>node</code>所在的路，DISTANCE重新累加。</p><p>最终的效果：蓝色线表示最优路线：<br /><img src="5.png" alt="在这里插入图片描述" /><br />单元测试还是非常重要的，只有确保每一个函数都是正确的，最终组合的功能才可能正确。</p><h2 id="autocomplete-and-search">Autocomplete and Search</h2><p>作为一个很有用的Feature，自动补全还是很酷的：搜索地名时只输入一部分，就返回以它开头的所有地名。需要在<code>MapServer</code>类中实现<code>List&lt;String&gt; getLocationsByPrefix(String prefix)</code>方法。</p><p>输入的参数<code>prefix</code>是clean后的字符串：除了大小写字母以及空格外，其它字符全部被移除，全部由小写字母组成。需要返回所有locations（有<code>name</code>的<code>node</code>）的全名，前提是clean后的全名与<code>prefix</code>匹配。<br />复杂度要求<spanclass="math inline">\(O(k)\)</span>，k是共享同一前缀的所有地名。</p><p>比如这样：<br /><img src="6.png" alt="在这里插入图片描述" /><br />除了自动补全，还需要完成Search功能：clean后的用户输入与clean后的<code>locationName</code>完全匹配，同名的<code>location</code>都需要加入<code>List</code>。<br />复杂度要求<spanclass="math inline">\(O(k)\)</span>，k是匹配的地名个数。<br />需要在<code>MapServer</code>类中实现<code>List&lt;Map&lt;String, Object&gt;&gt; getLocations(String locationName)</code>方法，返回同名的所有地方的信息，如果正确实现，那么就会有一个mark标记在那个地方：<br /><img src="7.png" alt="在这里插入图片描述" /><br />具体实现一般用Trie，这里的难点在于输入是clean后的字符串，需要输出clean前的全名，所以我们的Trie结点除了有<code>children</code>和<code>isWord</code>外，还需要保存一些额外的信息（clean前的<code>name</code>/<code>id</code>/<code>lat</code>/<code>lon</code>），当然这些信息只有叶子结点才需要保存，用<code>List&lt;Map&lt;String, Object&gt;&gt; extraInfo</code>来存储。这样重名的地点虽然占用了相同的叶子，但是所有地点的信息都存在了该叶子的<code>extraInfo</code>当中，可以直接展示出来。</p><p>Debug好痛苦啊！！有一次怎么样在浏览器都渲染不出来，折腾了一天，最后发现是因为html文件里一个js文件要FQ才可以访问，醉了。</p><h2 id="extensions">Extensions</h2><ul><li>Front-end Integration<br />现在是每调用一次，就在后台raster the entireimage，然后传到前端显示。实际中前端可以缓存用过的tiles以及路线，下次调用无需后台计算。</li><li>Vectored Tiles<br />现在的数据是一张张图片，实际上这些图片是可以从roads, lines, filledareas,buildings等基础矢量几何图形提取，可以用OpenGL/WebGL将其全部绘制为三角形，这样非常同一的工作就可以用GPU去做，速度比CPU要快很多，这些矢量图形可以在<ahref="https://wiki.openstreetmap.org/wiki/Vector_tiles">这里</a>下载。</li><li><ahref="https://sp19.datastructur.es/materials/proj/proj2c/heroku">Deployon Heroku</a><br />目前为止，我们的地图还只能在本地运行，下来就将它部署到服务器~<br />具体的部署过程可以参考上述链接，完成后APP就会部署到<ahref="http://bearmaps-fun.herokuapp.com/map.html">这里</a>。<br />后续的代码更改需要rebuild jar包，然后redeploy。</li></ul><h2 id="todo">TODO</h2><p>做工程真是长期的活，遇到bug每天能写50行就不错了。</p><p>所有<ahref="https://github.com/EIMadrigal/CS61B/tree/master/proj3">代码</a>均已通过AG的测试：<br />Part I：<br /><img src="8.png" alt="在这里插入图片描述" /><br />PART II &amp; III：<br /><img src="9.png" alt="在这里插入图片描述" /><br />附加Feature：<br /><img src="10.png" alt="在这里插入图片描述" /><br />单元测试除了<code>TestDirections</code>外全部通过。<br /><img src="11.png" alt="在这里插入图片描述" /><br />这个Bug真的有些诡异，不过：<br /><img src="12.png" alt="在这里插入图片描述" /><br />尽量少用<code>protected</code>修饰成员变量，写一个函数接口去访问。</p><h2 id="reference">Reference</h2><p><ahref="https://sp18.datastructur.es/materials/proj/proj3/proj3">Project3: Bear Maps, version 3.0</a><br /><ahref="https://sp19.datastructur.es/materials/proj/proj2c/proj2c">Project2C: Bear Maps, version 4.0</a><br /><ahref="https://www.redblobgames.com/pathfinding/a-star/introduction.html">a-star</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Support Vector Machine</title>
      <link href="/posts/svm/"/>
      <url>/posts/svm/</url>
      
        <content type="html"><![CDATA[<p>SVM是入门机器学习绕不开的一个话题，但愿这篇文章我能把它讲清楚。</p><h2 id="线性可分">线性可分</h2><p>SVM的核心思想是：对于<spanclass="math inline">\(p\)</span>维输入数据集，找一个有着maximummargin的<span class="math inline">\(p-1\)</span>维的超平面去做decisionboundary，这与直觉是相符的：<br /><img src="https://img-blog.csdnimg.cn/20200903193214259.png"alt="在这里插入图片描述" /><br />回忆下小学数学讲过的几何知识：空间中一个超平面由法向量<spanclass="math inline">\(\vec w\)</span>和截距<spanclass="math inline">\(b\)</span>唯一确定： <spanclass="math display">\[a(x-x_1)+b(y-y_1)+c(z-z_1)+...=0, \\w^Tx+b=0\]</span> 那么如何求解最优超平面的<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>呢？</p><p>假设<span class="math inline">\(\vecw\)</span>指向的一侧为正类（设为负类也没关系，后面会统一表示的），还<strong>假设</strong>在正类的支持向量上有<spanclass="math inline">\(w^Tx+b=1\)</span>，在负类的支持向量上有<spanclass="math inline">\(w^Tx+b=-1\)</span>，这里之所以将间隔假设为1主要是为了方便表示和求解，并不影响最终求得的最优超平面和决策函数，证明如下：</p><p>假设正类支持向量距最优超平面距离为<spanclass="math inline">\(c(c&gt;0)\)</span>，即<spanclass="math inline">\(w^Tx+b=c\)</span>，此时对应的最优超平面为<spanclass="math inline">\(w^Tx+b=0\)</span>；又<spanclass="math inline">\(\frac{w^T}{c}x+\frac{b}{c}=1\)</span>，即<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>同时缩小<spanclass="math inline">\(c\)</span>倍，那么这时超平面方程同除以<spanclass="math inline">\(c\)</span>并不改变其形式。</p><p>因此对于正负样本有： <span class="math display">\[w\cdot x_++b\geq 1\\w\cdot x_-+b\leq -1\]</span> 为了统一表示上面2种情况，引入<spanclass="math inline">\(y_i=\begin{cases}1,&amp;\text{+sample}\\-1,&amp;\text{-sample}\end{cases}\)</span>，所有样本统一表示为： <spanclass="math display">\[y_i(w\cdot x_i+b)-1\geq 0\]</span>如果能确定<span class="math inline">\(b\)</span>和<spanclass="math inline">\(w\)</span>，那么分类超平面和决策函数也就随即确定。</p><p>根据小学数学，间隔即为2个平行超平面的距离： <spanclass="math display">\[width=\frac{(b+1)-(b-1)}{||w||}=\frac{2}{||w||}\tag{1}\]</span></p><p>综上，<strong>原优化问题</strong>为： <span class="math display">\[\begin{array}{ll}\min _{w, b} &amp; \frac{1}{2}\|w\|^{2} \\\text { s.t. } &amp; y_{i}\left(w \cdot x_{i}+b\right)-1 \geqslant 0,\quad i=1,2, \cdots, N\end{array}\tag{2}\]</span> 这里之所以构造为<spanclass="math inline">\(\frac{1}{2}\|w\|^{2}\)</span>而不是<spanclass="math inline">\(||w||\)</span>是为了后面构造的Lagrangian求导的便利。</p><p>明眼人都看得出来：优化目标是一个Convex Quadratic OptimizationProblem，并且只有线性约束条件，意味着不会卡在局部极大，一定可以找到全局最优解。此时上述问题已经完全可以用一些QP软件求解了。之所以还要继续讨论下去得到其对偶形式，一是为了在高维空间应用kernel，二是对偶形式的求解有着更加高效的算法。</p><p>回忆下学过的高等数学：有约束优化问题可以通过拉格朗日乘子法求解。首先构造Lagrangian：<spanclass="math display">\[L(w,b,\alpha)=\frac{||w||^2}{2}-\sum_{i=1}^{N}\alpha_i[y_i(w\cdotx_i+b)-1],\alpha_i\geq0\tag{3}\]</span> 如果<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>满足<spanclass="math inline">\((2)\)</span>中的约束，那么<spanclass="math inline">\(\max_{\alpha}L(w,b,\alpha)=\frac{||w||^2}{2}\)</span>；<br />如果<span class="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>不满足<spanclass="math inline">\((2)\)</span>中的约束，那么<spanclass="math inline">\(\max_{\alpha}L(w,b,\alpha)=+\infin\)</span>。<br />因此下式的优化问题与<span class="math inline">\((2)\)</span>完全等价：<span class="math display">\[\min_{w, b}\max_{\alpha} L(w, b, \alpha)\tag{4}\]</span> 根据拉格朗日对偶性（不懂就暂时当作成立吧嘻嘻），<spanclass="math inline">\((4)\)</span>的对偶问题为： <spanclass="math display">\[\max_{\alpha} \min_{w, b} L(w, b, \alpha)\tag{5}\]</span> 为了求解对偶问题<spanclass="math inline">\((4)\)</span>，先求<spanclass="math inline">\(L\)</span>对<spanclass="math inline">\(w,b\)</span>的极小，再求对<spanclass="math inline">\(\alpha\)</span>的极大：</p><ol type="1"><li>固定<span class="math inline">\(\alpha\)</span>，求<spanclass="math inline">\(\min_{w, b} L(w, b, \alpha)\)</span> 分别求<spanclass="math inline">\(L\)</span>对<spanclass="math inline">\(\vec{w}\)</span>和<spanclass="math inline">\(b\)</span>的偏导并令其为0： <spanclass="math display">\[\frac{\partialL}{\partial\vec{w}}=\vec{w}-\Sigma\alpha_iy_ix_i=0,\vec{w}=\Sigma\alpha_iy_ix_i \\\frac{\partial L}{\partial b}=\Sigma\alpha_iy_i=0,\Sigma\alpha_iy_i=0\tag{6}\]</span> 决策向量<spanclass="math inline">\(\vec{w}\)</span>是样本的线性和，将<spanclass="math inline">\(\vec{w}\)</span>代入<spanclass="math inline">\((3)\)</span>： <spanclass="math display">\[\min_{w,b}L=\Sigma\alpha_i-\frac{1}{2}\Sigma_i\Sigma_j\alpha_i\alpha_jy_iy_jx_i\cdotx_j\tag{7}\]</span></li><li>求<span class="math inline">\(\min_{w, b} L(w, b,\alpha)\)</span>对<span class="math inline">\(\alpha\)</span>的极大即求<span class="math inline">\((7)\)</span>对<spanclass="math inline">\(\alpha\)</span>的极大，等价于取负号求对<spanclass="math inline">\(\alpha\)</span>的极小，于是终于得到了<strong>原优化问题</strong><spanclass="math inline">\((2)\)</span>的<strong>对偶优化问题</strong>：<span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdotx_{j}\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; \alpha_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\tag{8}\]</span></li></ol><p>利用SMO等算法可以比普通的二次规划算法更高效求得最优的<spanclass="math inline">\(\alpha^*\)</span>，进而根据<spanclass="math inline">\((6)\)</span>求得： <spanclass="math display">\[w^{*}=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}x_{i}\tag{9}\]</span> 再利用KKT条件（不懂就装懂吧嘻嘻）求得： <spanclass="math display">\[b^{*}=y_{j}-(w^*)^Tx_j=y_{j}-\sum_{i=1}^{N}\alpha_{i}^{*} y_{i}\left(x_{i} \cdot x_{j}\right)\tag{10}\]</span>其中，<span class="math inline">\(y_{j}\)</span>为任意一个支持向量。</p><p>最终的分类超平面为： <span class="math display">\[w^{*}\cdotx+b^{*}=0,\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}(x_{i}\cdotx)+b^{*}=0\tag{11}\]</span> 分类决策函数为： <spanclass="math display">\[f(x)=sign(w^{*}\cdot x+b^{*})=\sum_{i=1}^{N}\alpha_{i}^{*} y_{i}(x_{i}\cdot x)+b^{*}\tag{12}\]</span>最后要bb的是关于支持向量，根据KKT条件里的互补条件<spanclass="math inline">\(\alpha_{i}^{*}[y_{i}(x_{i}\cdotw^*+b^{*})-1]=0\)</span>：非支持向量必然有<spanclass="math inline">\(\alpha_{i}^{*}=0\)</span>，只有支持向量才可能出现<spanclass="math inline">\(\alpha_{i}^{*}&gt;0\)</span>。</p><p>如果回头看<spanclass="math inline">\((9)(10)(11)(12)\)</span>，所有的非支持向量对SVM没有任何影响，最优超平面以及决策函数都只由少量的支持向量决定，这大概就是支持向量机名称的由来吧~</p><h2 id="近似线性可分">近似线性可分</h2><p>上面讨论了完全线性可分的情况，然而在现实情况中，训练数据会有一些outliers，除去这些点后数据是线性可分的。为了处理这种情况，允许SVM分错一些样本。对每个样本点引入松弛因子<spanclass="math inline">\(\xi_{i} \geqslant0\)</span>，即样本点的函数间隔只需要大于<spanclass="math inline">\(1-\xi_{i}\)</span>，放松了限制条件，<strong>原优化问题</strong>变为：<span class="math display">\[\begin{array}{ll}\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i} \\\text { s.t. } &amp; y_{i}\left(w \cdot x_{i}+b\right) \geqslant1-\xi_{i}, \quad i=1,2, \cdots, N \\&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\tag{13}\]</span>如果样本点严格满足约束，对于损失函数没有贡献；如果不严格满足即<spanclass="math inline">\(\xi_{i}&gt;0\)</span>，损失函数就会有相应的惩罚。惩罚参数<spanclass="math inline">\(C\)</span>控制了一种权衡：既要间隔最大（即<spanclass="math inline">\(min\||w||\)</span>），又要分对尽可能多的样本点。</p><p>类似地，<spanclass="math inline">\((13)\)</span>可以通过拉格朗日乘子法转换为对偶问题后再去求解，建议吃饱的同学自己尝试一下。<spanclass="math inline">\((13)\)</span>的<strong>对偶优化问题</strong>是：<span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdotx_{j}\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; 0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N\end{array}\tag{14}\]</span>此时此刻恰如彼时彼刻，使用普通的二次规划算法或者更高效的SMO求解<spanclass="math inline">\((14)\)</span>得到最优的<spanclass="math inline">\(\alpha_{i}^{*}\)</span>，进而得到软间隔SVM的解：<span class="math display">\[w^{*}=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i} \\b^{*}=y_{j}-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}\left(x_{i} \cdotx_{j}\right)\tag{15}\]</span> 其中，<span class="math inline">\(y_{j}\)</span>要满足<spanclass="math inline">\(0&lt;\alpha_j&lt;C\)</span>。</p><h2 id="非线性可分">非线性可分</h2><p>上面讨论了线性分类问题，对于非线性可分问题，SVM的思想是做一个变换<spanclass="math inline">\(\phi(\vec{x})\)</span>，将样本映射到另外一个空间，也许就线性可分了。<br />由于目标函数和决策函数<strong>只依赖于样本对之间的点积</strong>，所以无需显式定义变换<spanclass="math inline">\(\phi(\vec{x})\)</span>，只要定义一个函数<spanclass="math inline">\(K(\vec{x_i},\vec{x_j})=\phi(\vec{x_i})\cdot\phi(\vec{x_j})\)</span>提供新空间的样本点的点积即可，<spanclass="math inline">\(K\)</span>叫做<strong>KernelFunction</strong>。<br />此时原优化问题为： <span class="math display">\[\begin{array}{ll}\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i} \\\text { s.t. } &amp; y_{i}\left(w^T \phi(x_{i})+b\right) \geqslant1-\xi_{i}, \quad i=1,2, \cdots, N \\&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\]</span> 对偶问题为： <span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\alpha_{i} \alpha_{j} y_{i}y_{j}\left(K(x_{i},x_{j})\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; 0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N\end{array}\]</span> 一种常用的kernel是线性的：<spanclass="math inline">\((\vec{u}\cdot\vec{v}+1)^n\)</span>，当前空间的<spanclass="math inline">\(u\)</span>和<spanclass="math inline">\(v\)</span>通过简单的点积映射到了另一个空间；<br />另一种kernel是高斯核：<spanclass="math inline">\(e^{-\frac{||x_i-x_j||^2}{\sigma}}=e^{-\gamma{||x_i-x_j||}^2}\)</span>。<br />高斯核对应高斯径向基函数分类器，这里有2个参数<spanclass="math inline">\(C\)</span>和<spanclass="math inline">\(\gamma\)</span>需要调节：惩罚系数<spanclass="math inline">\(C\)</span>表示分类器对于误差的宽容度，<spanclass="math inline">\(C\)</span>越大表示越不能容忍误差，容易过拟合，按照经验可以在<spanclass="math inline">\([10^{-4},10^4]\)</span>间调节；<spanclass="math inline">\(\gamma\)</span>控制径向作用范围，<spanclass="math inline">\(\gamma\)</span>越大，径向作用范围越小，有可能将每个样本点单独形成一个分类，容易过拟合，<spanclass="math inline">\(\gamma\)</span>过小，径向范围过大，容易将2个样本映射为同一个点，无法区分，一般<spanclass="math inline">\(\gamma=\frac{1}{样本特征数}\)</span>。另外，这2个参数可以通过交叉验证和grid-search来调整。</p><h2 id="扩展">扩展</h2><p>SVM处理多分类问题的方式主要有2种：</p><ul><li>one-against-one<br />在每2个类之间都构造一个binary SVM，共有<spanclass="math inline">\(C_m^2\)</span>个SVM，对新数据采用Voting的方式进行分类。</li><li>one-against-the-rest<br />对每个类，将其作为正类，其余<spanclass="math inline">\(m-1\)</span>个类作为负类，共<spanclass="math inline">\(m\)</span>个SVM，对新数据采用winner-takes-all策略。</li></ul><p>如果样本不均衡，目标函数中的惩罚项主要由多数类构成，超平面偏向少数类，甚至将所有样本都分在同一侧。<br />此时目标变为了在不严重损失多数类精度的情况下，在少数类上获得尽可能高的分类正确率。一般来讲有2种做法：</p><ul><li>数据合成<br />对少数类样本进行分析并根据其特点人工插值合成新样本添加到数据集中，构成均衡数据集。比较常用的方法是SMOTE(SyntheticMinority Oversampling Technique)。</li><li>加权SVM<br />将少数类分错的代价很大，所以在惩罚项中对两个类设置不同的惩罚系数，少数类的系数设置更大，甚至可以对每个样本都设置不同的惩罚系数，此时原优化问题变为：<span class="math display">\[\begin{array}{ll}\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C^+ \sum_{y_i=1}\xi_{i}+C^-\sum_{y_i=-1} \xi_{i} \\\text { s.t. } &amp; y_{i}\left(w^T \phi(x_{i})+b\right) \geqslant1-\xi_{i}, \quad i=1,2, \cdots, N \\&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\]</span> 对偶问题： <span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\alpha_{i} \alpha_{j} y_{i}y_{j}\left(K(x_{i},x_{j})\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; 0 \leqslant \alpha_{i} \leqslant C^+, y_i=+1 \\&amp; 0 \leqslant \alpha_{i} \leqslant C^-, y_i=-1\end{array}\]</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的IO模型</title>
      <link href="/posts/io-multiplexing/"/>
      <url>/posts/io-multiplexing/</url>
      
        <content type="html"><![CDATA[<h2 id="blocking-io">Blocking I/O</h2><p>简单易用，本地I/O性能很高。处理网络I/O会造成进程阻塞空等，浪费资源。</p><h2 id="non-blocking-io">Non-Blocking I/O</h2><p>kernel在数据未就绪时直接返回，增加systemcall的次数，消耗CPU资源。</p><h2 id="io-multiplexing">I/O Multiplexing</h2><p>当多个独立的I/O事件同时发生时，I/O多路复用是一种解决方式。<br />为了提高服务器的吞吐量，<strong>单个线程</strong>通过记录跟踪每个I/O流的状态同时管理多个I/O流，非常类似时分复用技术。<br /><img src="https://img-blog.csdnimg.cn/20200825092905568.gif#pic_center"alt="在这里插入图片描述" /><br />I/O多路复用的具体实现方式有3种：<code>select()</code>、<code>poll()</code>和<code>epoll()</code>。</p><h3 id="select">select</h3><p><code>select()</code>系统调用：<code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code><br /><code>select()</code>会一直阻塞直到至少一个文件描述符就绪，可以读写，或者出现异常。<br />中间3个参数会被修改，表示哪个FD准备好了，最后一个表示等待时间，NULL表示无限等待。<br />返回就绪的FD数目，有错-1。只知道有就绪，不知道哪个FD就绪了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd[];  <span class="comment">// 需要监听的socket集合</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = select();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fd.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET()) &#123;  <span class="comment">// 判断哪个socket接收到数据</span></span><br><span class="line">            <span class="comment">// 处理数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>select()</code>是阻塞方法，只有某个socket接收到数据才会继续执行，唤醒进程。<br />直接的方式缺点就比较多：</p><ul><li>时间开销大，所以规定最多监听1024个socket；</li><li>每次调用都要把fd集合从用户态拷贝到内核态。</li><li>线程不安全：</li></ul><blockquote><p>If a file descriptor being monitored by select() is closed in anotherthread, the result is unspecified.</p></blockquote><h3 id="poll">poll</h3><p>去掉了1024的限制，线程不安全。</p><h3 id="epoll">epoll</h3><p>线程安全，知道哪个FD就绪，只有Linux支持。<br />相比于<code>select()</code>，<code>epoll()</code>不会无差别轮询，只处理接收到数据的socket，这样复杂度就降低为<spanclass="math inline">\(O(k)\)</span>。</p><p>水平触发：边缘触发：读只要状态变化就会通知，写只要从满到非满就通知</p><h2 id="signal-driven-io">Signal-Driven I/O</h2><h2 id="asynchronous-io">Asynchronous I/O</h2><h2 id="reference">Reference</h2><p><ahref="https://www.zhihu.com/question/32163005/answer/55772739">I/O多路复用是什么意思</a></p><p><a href="https://zhuanlan.zhihu.com/p/358208161">这次答应我，一举拿下I/O 多路复用</a></p><p><ahref="https://www.zhihu.com/question/59975081/answer/1932776593">IO多路复用到底是不是异步的</a></p><p><ahref="https://wiyi.org/linux-io-model.html">带你彻底理解Linux五种I/O模型</a></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魏晋风度浅探</title>
      <link href="/posts/win-jin-style/"/>
      <url>/posts/win-jin-style/</url>
      
        <content type="html"><![CDATA[<p>从小学作文开始，就喜欢写一些辞藻华丽的诗歌文章。<br />竹林七贤我当时只听说过山涛、阮籍和嵇康，引用之意是觉这几位遗世独立、傲然风骨，没有世俗羁绊，整日琴棋书画、饮酒作乐、不问世事，潇洒写意的生活，正是吾向往之。《广陵散》和《与山巨源绝交书》更是勾起了我对于嵇康无限的崇拜。<br />我极喜欢嵇康和纳兰性德，即使一些毫无关联的题目，也要用他们的事例强行去阐述论点。但由于只喜欢钻研近现代的战争史（可以原谅，男孩一般都喜欢枪支、火炮等近现代武器），一直对古代史不感兴趣，觉得几千年前的文化故事不过是落后、腐朽的代名词而已，所以其实对一些人物只是略知一二，最近花了些时间重新捋了一下魏晋那段历史，故分享于此。</p><h2 id="历史背景">历史背景</h2><p>我一直觉得想要真正了解一段文化、一个人物，就首先要了解他们所处的历史时代。<br />曹操在东汉末年的群雄逐鹿中“挟天子以令诸侯”，在三国末期势力最强。曹操去世后，其子曹丕于公元220年建立曹魏政权。公元265年，司马炎建立西晋，史称晋武帝。竹林七贤就是生活在这样一段历史时期：<br />山涛：205~283<br />阮籍：210~263<br />嵇康：224~263<br />刘伶：221~300<br />向秀：227~272<br />阮咸：不详<br />王戎：234~305<br />曹丕去世后，曹叡即位，公元239年隆冬时节，曹叡驾崩之际，将皇位传给仅仅8岁的曹芳，并将其同时托孤给司马懿和曹爽，于是在接下来漫长的几十年中，曹氏集团和司马氏集团开始了你死我活的政治斗争，史称“曹马之争”。</p><h2 id="竹林七贤">竹林七贤</h2><p>在那个极其黑暗动荡的乱世之中，文学和艺术却得到了出乎意料的大发展，人们对自由解放的追求达到了极致，鲁迅先生称之为魏晋风度。当时盛行清谈和隐逸，古人的心灵更加丰富和缠绵，规则的约束压抑了个性与自我，却在频频交流中迎来了文化的繁荣。不要用成王败寇的观点去评价历史人物，参差百态，实乃幸福本源。</p><p>而对魏晋风度影响最大的自然就是竹林七贤，虽然百年之后后人将其称之为七贤，但这个文人沙龙的规模其实大于7人，之所以定为七贤，据刘强老师的说法是为了攀附《论语》：</p><blockquote><p>贤者辟世，其次辟地，其次辟色，其次辟言。作者七人矣。</p></blockquote><p>另外，关于竹林七贤是否因为经常在竹林活动而得名也存疑。陈寅恪先生认为有可能是借佛经之中的“竹林精舍”的故事来表达出世的理想。据考证，他们的活动地点在都城洛阳以及山阳（今云台山）附近，后来当地可能为了借竹林七贤的名声促进旅游业的发展，所以人工栽种了一些竹林。</p><p>当时流行修身齐家治国平天下，但是这些才华横溢的文人开始却不愿做官，这是为什么呢？</p><p>“曹马之争”愈演愈烈，再加上这些名士的名气和影响力，他们被逼站队才能得以生存。那么问题来了，是站在司马家族一边，还是支持曹氏集团呢？曹爽此时被封为大将军，司马懿则是太尉，选择稍有不慎，很可能会被秋后算账。</p><p>作为老大哥，山涛最先受到“曹马之争”的冲击。</p><p>山涛早年丧父，出身庶族，隐居不仕，刘老师说可能是因为时机不成熟，2个政治集团的形势不明朗。山涛本人是有政治抱负的，但为了自保只能暂时推脱出仕邀请。</p><p>公元244年，他觉得形势明朗，自己的机会来了，终于在40岁时开始了官宦生涯，并且选择站到曹爽队伍里。</p><p>为了彻底击败曹氏集团，司马懿称病不朝，以退为进。极富政治头脑的山涛嗅出了不同的味道，突然醒悟，夜半弃官。</p><p>山涛弃官以后，司马懿在称病迷惑曹爽的同时，积累军事力量、联络曹魏老臣取得道义支持、散播舆论蛊惑人心，家族势力日渐强大。而就在此时，山涛结交了阮籍、嵇康等名士，整日醉饮玩乐。</p><p>公元249年，司马懿发动政变，一举粉碎了政敌曹爽集团，史称“高平陵之变”，以谋反罪处死了曹氏整个家族，数千人惨死，竹林七贤也受到了惊吓。接着为了缓解白色恐怖的气氛，司马家族开始招贤纳士、笼络人心，竹林七贤自然也在招贤之列：</p><p>山涛由于和司马氏的姻亲关系，第二次做官便凭借亲戚的身份主动投靠司马师，从此以后官运亨通，步入了仕途的快车道。</p><p>相比之下，在音乐、诗赋方面才华横溢的阮籍就显得异常凄惨。</p><p>阮籍的背景十分复杂，他的父亲阮瑀是建安七子之一，和曹魏关系密切；同时他又是司马氏的亲戚。<br />被招纳时，由于害怕司马懿的屠刀，于是阮籍答应为官，做了一个闲职。但他尸位素餐，整日划水摸鱼，几乎没有作为。并且他和司马氏倡导的封建礼教格格不入（司马氏当时号召“以孝治天下”，公元258年左右，阮籍丧母，他公然违背礼法，在葬礼期间喝酒吃肉），生活得极其痛苦但又不想过早结束生命，所以只能寄托于司马懿的死亡。</p><p>司马懿死后，其子司马师又把阮籍召去做官。司马昭上台后，为了拉拢阮籍，想要将阮籍的女儿嫁给司马昭的儿子司马炎，阮籍只能用烂醉如泥来应付。天天这样也不是办法，他就主动求官，调往外地，金蝉脱壳之计，但很不幸，十天后又被司马昭看穿并召回幕府。从此慎言慎行、明哲保身、郁郁寡欢。</p><p>嵇康死后，阮籍抑郁而终，晚年被迫为司马昭写了一篇歌功颂德的《劝进文》，成为了人生的污点。</p><p>向秀跟嵇康关系最好，嵇康的死给他带去了巨大的阴影，后来为了自保也踏上了仕途。</p><p>王戎后来做了大官，却变得非常吝啬，跟年轻时候判若两人，但是他依然很重情谊。<br />阮咸后来被山涛举荐，但没有被任用。</p><p>刘伶据说是7人里最丑的，但是他的精神自我十分强大，整日烂醉如泥，在酒中放飞自我，晚景凄凉。代表作《酒德颂》，刘强老师说他是真正的行为艺术家hh。</p><h2 id="嵇康">嵇康</h2><p>嵇康出身普通，自幼颠沛流离。和曹操同乡，其妻子是曹操的曾孙女长乐亭主，嵇康最后被司马昭所杀可能与这个因素也有关系。诗歌、文章、书法、乐理造诣很高，据传还是个大帅哥，史书记载：</p><blockquote><p>嵇康为人，肃肃如松下风，酒醉时倾倒，若玉山之将崩。</p></blockquote><p>他提出越名教任自然，反对礼教，追求自然和本我，厌恶政治斗争，据传嵇康在打铁时，司马氏的走狗钟会前来探访，所谓道不同不相与谋，故意把钟会晾在一边不说，走前还冷嘲热讽了一通。</p><p>当时司马师废掉了曹芳，引起淮南兵变，嵇康也想起兵响应，被山涛劝阻。</p><p>公元255年，司马师在平定叛乱时，由于得病死掉了。随后司马昭上台，希望招纳嵇康，嵇康借口避地河东。</p><p>嵇康以宽厚待人，虽然他的哥哥嵇喜还有几个朋友做了司马氏的官，但仍然没有影响他们的友谊。对待朋友友好，但是对待敌人却像严冬一样冷峻无情，也导致了后来悲剧的发生。</p><p>后来他又多次拒绝司马昭的邀请，但很不幸，嵇康最终还是卷进了政治斗争：<br />皇帝曹髦一直被司马昭操控，被迫封其为相国，眼看分分钟就要被取代的节奏。后来也由此诞生一个成语：司马昭之心——路人皆知。公元260年，曹髦很快就被司马昭干掉了，又找了一个傀儡。</p><p>公元261年，山涛升迁，找到嵇康希望他代替自己之前的官职。两人虽然“契若金兰”，但嵇康依然愤怒地写下《与山巨源绝交书》，极尽讽刺羞辱山涛，他觉得山涛拉拢他是为了缓解自己的尴尬，一起下水就不觉得那么罪过了。嵇康在书里自明心志：自己生性疏懒，阐述了自己做官的七不堪、二不可：<br />没法睡懒觉；喜欢休闲弹琴，出去玩不自由；需要正襟危坐；不喜欢写公务信；不喜欢吊丧；不喜欢和俗人共事；性情不耐烦，不喜欢做繁琐的事情。<br />菲薄古代的圣贤，被发现就挂了；性格刚烈、嫉恶如仇，沉不住气，不适合做官。</p><p>历史上关于两人是否真的绝交有争论：尤其是后来还发生了托孤事件。</p><p>屋漏偏逢连夜雨，接下来又发生了吕安事件，直接将嵇康送入了火坑之中：</p><p>吕巽是吕安的哥哥，对吕安的妻子有非分之想并且给他带了绿帽子，吕安告诉了嵇康，嵇康严词谴责了吕巽，但为了声誉，劝吕安隐忍不发，事情就这样被捂了下来。</p><p>吕巽和钟会关系很好，为了报复吕安，他向钟会进献谗言，钟会很可能为了牵出嵇康，以报一箭之仇，不久后就抓了吕安。嵇康听到消息后十分愤怒，写了一封《与吕长悌绝交书》，之后只身前往洛阳，去为吕安辩护。</p><p>吕安在流放途中，给嵇康写了一封言辞激烈的信。大意是说天下大乱，自己承受冤屈，他要改天换地。这封信很快落到了钟会手上，钟会终于等到了机会。</p><p>吕安事件由此升级为谋反罪，嵇康被当作同犯抓了。司马昭本来就忌惮嵇康，对他的不合作态度怀恨在心，但对于是否要杀嵇康也犹豫不决，此时钟会又站了出来上纲上线，说嵇康上不臣天子，下不事王侯，私下又罗织了几个理由：他说嵇康是人中龙凤，并且当年有起兵谋反之意。</p><p>欲加之罪，何患无辞？于是吕安和嵇康被关入死囚牢房，等待秋后问斩。</p><p>命犯小人，嵇康入狱后，有几千太学生为他抱打不平。他也在狱中反思自己，写下了《幽愤诗》，觉得自己虽然心地善良，但却没有识别坏人的能力。</p><p>临死前将其儿子嵇绍托付给山涛，有人说这是为了缓解山涛的愧疚之意，山涛接受了嵇康的托孤，把嵇绍培养的很好：</p><blockquote><p>巨源在，汝不孤矣！</p></blockquote><p>就在行刑前，太学生又请愿释放嵇康当太学老师。司马昭看到嵇康如此的影响力，杀心更重：<br />公元263年，嵇康与吕安一起在都城洛阳被处死。</p><p>据记载，行刑那天人山人海，嵇康顾看日影、神色坦然。</p><p>嵇康找哥哥嵇喜要了一把琴，嵇喜果然随身携带，而且嵇康的弹奏要求竟然被同意：<br />在刑场上，他平静呼吸，调整琴弦，弹完了最后的哀歌《广陵散》后说到：当年有一个朋友袁孝尼求学此散，自己由于吝惜，没有教给他：</p><blockquote><p>广陵散于今绝矣！</p></blockquote><h2 id="reference">Reference</h2><p>同济大学的刘强老师是魏晋史的专家，百家讲坛和上海图书馆系列讲座中都收录了他的精彩分享：<br /><ahref="http://tv.cctv.com/lm/bjjt/index.shtml#&amp;Type=0&amp;Y=2010&amp;M=10">百家讲坛之竹林七贤</a><br /><ahref="https://www.bilibili.com/video/BV1Zt411d7Fr">竹林七贤与魏晋风度</a></p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> History </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bomb Lab</title>
      <link href="/posts/bomb-lab/"/>
      <url>/posts/bomb-lab/</url>
      
        <content type="html"><![CDATA[<p>给了<code>bomb.c</code>和<code>bomb</code>二进制可执行目标程序，<code>bomb.c</code>不能直接编译和运行，只是有一些提示，但是程序大致结构是：有6个关卡，每个都需要输入（stdin/文件）一个字符串，运行后判断是否输入了正确的字符串。我们需要反汇编<code>bomb</code>，找到这6个正确的字符串。<br />我是在Amazon的云服务器上完成的，64位Red Hat。</p><p>第一步把汇编代码扔到一个文件中，方便调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.asm</span><br></pre></td></tr></table></figure><h2 id="phase-1">phase 1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  400ee4:be 00 24 40 00       mov    $0x402400,%esi</span><br><span class="line">  400ee9:e8 4a 04 00 00       callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:85 c0                test   %eax,%eax</span><br><span class="line">  400ef0:74 05                je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:e8 43 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  400efb:c3                   retq</span><br></pre></td></tr></table></figure><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8,r9。<br />我们的input作为第一个参数存入rdi，第二个参数0x402400存入rsi，传入函数处理，<br />调用了<code>401338</code>处的函数<code>strings_not_equal</code>：</p><p>在400ee4设个断点，看看402400里是啥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb</span><br><span class="line">file bomb</span><br><span class="line">b *0x400ee4</span><br><span class="line">run</span><br><span class="line">x/s Addr// 显示内存值为字符串</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200703101513705.png"alt="在这里插入图片描述" /><br />为了确认这就是我们要的答案，再去看看调用的函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0000000000401338 &lt;strings_not_equal&gt;:</span><br><span class="line">  401338:41 54                push   %r12</span><br><span class="line">  40133a:55                   push   %rbp</span><br><span class="line">  40133b:53                   push   %rbx</span><br><span class="line">  40133c:48 89 fb             mov    %rdi,%rbx # 第一个参数(地址)存入rbx</span><br><span class="line">  40133f:48 89 f5             mov    %rsi,%rbp # 第二个参数(地址)存入rbp</span><br><span class="line">  401342:e8 d4 ff ff ff       callq  40131b &lt;string_length&gt; # 用rdi的值调用string_length</span><br><span class="line">  401347:41 89 c4             mov    %eax,%r12d # 返回值存入r12d</span><br><span class="line">  40134a:48 89 ef             mov    %rbp,%rdi # 第二个参数作为入参调用string_length</span><br><span class="line">  40134d:e8 c9 ff ff ff       callq  40131b &lt;string_length&gt;</span><br><span class="line">  401352:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line">  401357:41 39 c4             cmp    %eax,%r12d # 比较两个字符串的长度</span><br><span class="line">  40135a:75 3f                jne    40139b &lt;strings_not_equal+0x63&gt; # 不相等跳转</span><br><span class="line">  40135c:0f b6 03             movzbl (%rbx),%eax # 将rbx地址中的值(input的第一个字母)存入eax</span><br><span class="line">  40135f:84 c0                test   %al,%al</span><br><span class="line">  401361:74 25                je     401388 &lt;strings_not_equal+0x50&gt;</span><br><span class="line">  401363:3a 45 00             cmp    0x0(%rbp),%al # 比较rbp地址中的值(待比较的第一个字母)</span><br><span class="line">  401366:74 0a                je     401372 &lt;strings_not_equal+0x3a&gt; # 相等跳转</span><br><span class="line">  401368:eb 25                jmp    40138f &lt;strings_not_equal+0x57&gt; # 不相等跳转</span><br><span class="line">  40136a:3a 45 00             cmp    0x0(%rbp),%al</span><br><span class="line">  40136d:0f 1f 00             nopl   (%rax)</span><br><span class="line">  401370:75 24                jne    401396 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line">  401372:48 83 c3 01          add    $0x1,%rbx # 指针+1</span><br><span class="line">  401376:48 83 c5 01          add    $0x1,%rbp # 指针+1</span><br><span class="line">  40137a:0f b6 03             movzbl (%rbx),%eax</span><br><span class="line">  40137d:84 c0                test   %al,%al</span><br><span class="line">  40137f:75 e9                jne    40136a &lt;strings_not_equal+0x32&gt; # 跳回循环</span><br><span class="line">  401381:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line">  401386:eb 13                jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401388:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line">  40138d:eb 0c                jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40138f:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line">  401394:eb 05                jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401396:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line">  40139b:89 d0                mov    %edx,%eax</span><br><span class="line">  40139d:5b                   pop    %rbx</span><br><span class="line">  40139e:5d                   pop    %rbp</span><br><span class="line">  40139f:41 5c                pop    %r12</span><br><span class="line">  4013a1:c3                   retq</span><br></pre></td></tr></table></figure>所以这个函数就是比较两个字符串是否相同，先比较长度，再比较每个字符。故我们的第一个key就是Borderrelations with Canada have never been better.</p><h2 id="phase-2">phase 2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:55                   push   %rbp</span><br><span class="line">  400efd:53                   push   %rbx</span><br><span class="line">  400efe:48 83 ec 28          sub    $0x28,%rsp # 栈指针-40</span><br><span class="line">  400f02:48 89 e6             mov    %rsp,%rsi # 栈指针作为第二个参数</span><br><span class="line">  400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:83 3c 24 01          cmpl   $0x1,(%rsp) # 检查是否相等</span><br><span class="line">  400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt; # 相等跳转</span><br><span class="line">  400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:eb 19                jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:8b 43 fc             mov    -0x4(%rbx),%eax # (rbx-4)赋给eax</span><br><span class="line">  400f1a:01 c0                add    %eax,%eax</span><br><span class="line">  400f1c:39 03                cmp    %eax,(%rbx) # 比较当前数与下一个数</span><br><span class="line">  400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt; # 相等跳转</span><br><span class="line">  400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:48 83 c3 04          add    $0x4,%rbx</span><br><span class="line">  400f29:48 39 eb             cmp    %rbp,%rbx # 是否比完了6个数</span><br><span class="line">  400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:48 8d 5c 24 04       lea    0x4(%rsp),%rbx # 栈指针+4赋给rbx</span><br><span class="line">  400f35:48 8d 6c 24 18       lea    0x18(%rsp),%rbp # 栈指针+24赋给rbp</span><br><span class="line">  400f3a:eb db                jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  400f40:5b                   pop    %rbx</span><br><span class="line">  400f41:5d                   pop    %rbp</span><br><span class="line">  400f42:c3                   retq</span><br></pre></td></tr></table></figure><p>第一次是1，第二次是2，4，8，16，32</p><h2 id="phase-3">phase 3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:48 83 ec 18          sub    $0x18,%rsp # 栈指针-24</span><br><span class="line">  400f47:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx # 栈指针+12赋给rcx</span><br><span class="line">  400f4c:48 8d 54 24 08       lea    0x8(%rsp),%rdx # 栈指针+8赋给rdx</span><br><span class="line">  400f51:be cf 25 40 00       mov    $0x4025cf,%esi</span><br><span class="line">  400f56:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400f5b:e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt; # 返回值存入eax</span><br><span class="line">  400f60:83 f8 01             cmp    $0x1,%eax</span><br><span class="line">  400f63:7f 05                jg     400f6a &lt;phase_3+0x27&gt; # 大于跳转</span><br><span class="line">  400f65:e8 d0 04 00 00       callq  40143a &lt;explode_bomb&gt; # 否则爆炸</span><br><span class="line">  400f6a:83 7c 24 08 07       cmpl   $0x7,0x8(%rsp) #(rsp+8)即输入的第一个整数与7比较</span><br><span class="line">  400f6f:77 3c                ja     400fad &lt;phase_3+0x6a&gt; # 大于爆炸</span><br><span class="line">  400f71:8b 44 24 08          mov    0x8(%rsp),%eax # 输入的第一个整数赋给eax</span><br><span class="line">  400f75:ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8) # 跳转8*rax+0x402470</span><br><span class="line">  400f7c:b8 cf 00 00 00       mov    $0xcf,%eax</span><br><span class="line">  400f81:eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:b8 c3 02 00 00       mov    $0x2c3,%eax</span><br><span class="line">  400f88:eb 34                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:b8 00 01 00 00       mov    $0x100,%eax</span><br><span class="line">  400f8f:eb 2d                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:b8 85 01 00 00       mov    $0x185,%eax</span><br><span class="line">  400f96:eb 26                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:b8 ce 00 00 00       mov    $0xce,%eax</span><br><span class="line">  400f9d:eb 1f                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:b8 aa 02 00 00       mov    $0x2aa,%eax</span><br><span class="line">  400fa4:eb 18                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:b8 47 01 00 00       mov    $0x147,%eax</span><br><span class="line">  400fab:eb 11                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:e8 88 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400fb7:eb 05                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:b8 37 01 00 00       mov    $0x137,%eax</span><br><span class="line">  400fbe:3b 44 24 0c          cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:74 05                je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:e8 71 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  400fcd:c3                   retq</span><br></pre></td></tr></table></figure><p>400f51将地址0x4025cf赋给esi，作为第二个参数，看下这个地址有啥：为了方便，我们把前面问题的答案仍在一个文件ans.txt中，<br /><img src="https://img-blog.csdnimg.cn/20200703164446264.png"alt="在这里插入图片描述" /><br />输入是2个整数，第一个不能大于7，基于第一个整数（0-7）跳转......</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈我的理想</title>
      <link href="/posts/thoughts-on-my-dream/"/>
      <url>/posts/thoughts-on-my-dream/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="948c8f6a163266f4e7963f01e16bcad4a9352e49d6b08b331f8a2c90418ec0c6">c172f4ee74b2b6d246b20cbfdc0b877ea29f3f69224a35aa384277b5b4b094121c176dcf6723e0e2bffac0b86f04ba6313d1d5425b08e889b5464fdf6edc014eeed8d599d14a5cbc488603a649279abc916b631dbd8940fe96ddbc4d103d26ffe261bab7c81321b4ef21a3f6aa75626ced8241325b4366aa3de5e8a9ba7b742058d4ad6746b578ac3fd90c56aa4ce3e33a704cfc235f2863b6bd60f3a1e774a6a6026905c46404b6df1d917e22efd3bc9aff7682dfdac4a319ecf696218dee6c2696e531c1b6124ff53a1ca1eebbc1b142f4de2286261e149bdf72fc346fe5c67fdf7b0ac914dbf912f531fefc9fe224350a54e3dae04960e771622691b0eea4519c12e75a7c5ddcfebce0ae292548e484947780424257c30a631ae83d176688d7a1d43d7a8ae59382ca91ccfcb755e377bd9ee92125ee166043d924191e90f1de213ed08a3089a7af5214cc83f980435cb72e2d5e173373be25db54216855c8547619e3db9f13fae09b345c3c29d775b05b6c72f75fdde9e3b9ae3fa7c99f7fb76dcfcc78dfecb0005fa53b460ddd11e2f29cb822b12fff7eed277799163f6c2ee76d88cd2daf77612d0ddb323b6a6ef63881f4e145cab33537fe682023146eb0a30dda2139eaa10183805eda4c113d36e0140f9f8493b880b0cb0b366810f287fa98733ec048b5d962044a7ef0ec409c8557f73332ea6186f91e83a902d192c2e01fbe6361ccd2cc854d31a12227cddde813e67a5b798963cd30ed14cdb575d4fdb1227588b75f6a4a3e6bc6be223e0bcfe58e9d903c7e4621ee448a25bd170294c128734563839d5df676d1a3c2fff65fddabbe316e9c731c98ae242596a825259d8b31e0e65e6ae384189342b6255049d8ac4641c221850a06d4c8f16e30200945f7b01cefb7ba5e83dbdb61a223d59faaefa5dfea7e42d13bbe58a3a6f013cdb16f4ffd94bbbbbe43020fce646b4d9a4c239930e584c3de741f96679ba6c7dc0c44cae7c13bd9beba5abdc8f71136ff548968cf50f43a67e82a72fafa06739503590881787ea6d1e96e4383bacbc8688f832a7175598cdf03955e22d66f1d33b2815de1cbbbf851b6836e428e28b77e13203ef6afd07747bf9f49c03c4966e88fe5ad87adce86bcfed34c0e96891614b152bcab1bfdabb6a410c6413b11908971a02aab1be78bc0b70eeb6a2964e5137f23a4187b487b2c36b0d6fa9538ed784b55bccc90e95f0cb3b5acde97959217c93420d67469d1af3417ab436d5d6a43f70baaefba0a3bfe5a54a243c721328983bc902b9e73c19555e3c6a70aa54ede0e8c25d44f68a84dfa26029f2e4de8d197c685d06505cad920c13303e60aad974780c11b5b90c0d2773478abe2055b5a020a2104a48b9d34efa7cb1aca981ffe6fb5a1d930d6ffc9cb6661248a669902ce2a28eb11b238cbb45341d55bf792ad2da450a17bd3c0aeba7e560004de71d20b326ec0a374f08d6c4711df5d24035fb867ea32a11a5e4f34d88771a09a15c3b91ac68f7e2a056e3bf65f4fd8b7b605ec43a249b80ff60e003db4d5048d6a35c5e5a27ceace9ad5f6f27ce7698da1e937ceb88ed0e14c8d7eb76cf250ab839b9046b346a9036519ed28d075cd5bd6c9f6e016583a5c38a0f2abc89cc8b860ed2a73bed72111e34ad6e00120f925c922a28de729702c59e4aa6c0fb2bf86759f583f9b8f0ecdce296512535ed4cdff2bcecc45c84dbbbc7bbb45062a0f4d7ddce5a60a7722170c6e9dfaee48879fc941d65d3bd497c7df6a707b93fae72c9bcf355672b379d50840da8bc952cac67fa540a12ec9458a99344a0e9da11bec3c5edbba8857273a91ba95d87f717c33144b8c675fc46d13a027f10d20d88ba049d16cc5a85d3f75c009062c024ff972f4f77abacb81bee9d5192302de4541d2986759c76d3139cb31ac25da91ef74d680da95aeb1fac9b7430d3b9678a9b6f8abfb53946001b61ea4464df3899e58f2f68f6a112b3ac21db80a4756ccc481dc93c918dfc904cca1bce71eb1f895e02aa3ad9aa8fb887a3ff32f5e3b76e51f3756d6b1108d483b3e2d7e2d5215b7f5c8656ade789722348189ca059340965e47163bf5534680e93e71e2464e5dfbad08c69187eece42ce2f559c34eab8005939b50bfe23b7eed5815931d3594a1353bad27648903306cbc67520b673bd89ac4ada443b7ee9d5a0caab78bbeb42cf351ea6128d5ca293fec12650c7522e99afe1b70240b65a30835a561abea2c5912b6cc9a327e745000348c2e62051934b1c83b4a3175134769fb4ee137ab478fdee29ba76404cca58a1ab7c854a15c10e4eb35f6a814dbeb0af9bd8178d96b5a0b4208f1de734f9bd4f8c43548ced3f82c0c529da65025a5a4802371a6ac53942b2ba857106332a66eee56ee1241cbb3de4066c47a2f4abf448b4927e26387b6f9fc3ef1060dc80af4b2d9e13b05465d64d43b262f2f61d6c7041a35984e92ddd90cc7837d6430c2c13165c4f3e863628dc7915877f6c9703f3c06e1ea64f1908732a273905fb1c6d2f649ac1386b6f1f5a0e6796a6baf9974613101184b217d1a02d2843bc2c223920893f14c86a15fdbc1ed093124d7ac871ac2a8da37d350d3be87b1829042f28b85f511388b67304bc37fb7ded65be80e570c2100d93f3d3c7bdaf00181098451edc6d946ce0a160c7767657fedb2c8768e5729d638b29f924812aeac15892d28a7323808fbbe805b838a84581a9f84caceee42b7670b06d9b78d3250563742d7a6f8339513edf55316bcc6f2ef19af86852d0d986019e93bf4c28f3cc96491cb439f20cf72881c2896c7862aafc71dc801ef75fffdbe19c1cf2e1b1032df64f079da8ebc4a0ee265784765c3bbe7dfea1696efeadd62f37f55718afb8dd538d10aa3dfb42a2d1498d0566bf91624eeea376f2ff9b4e6c876eb7f0e6b2e127ba7c7b02953600ecda9479b893216de60497d66433150edc841ce6b366352bf813e225d6260a76991efaf5dcbcdf630169e0b40ca3d54d8b598e4da40f86c9eadde34e71999b6519e75254b062ac377ae666bb53db895ce3e435b9f6f85db2c824636da12ce9dd5848568872756017510d672ce186eedd162ca452c05774f982badee3c6f1e557cc842ed139c5f68a963d379896e16d42206ba43a5fe33e9152a80ef7562021f4d131b69d91eed2042921be9945c97b756ac5d21f4b2cf9c21ee013393e90aa49db7057f2d5f01fd1dc6689aafb1c3652f9ad2998a8ef2084e8fe5eefd406cca7621fc2bb78a479dc877b9b967811f58a8c49cadc03de326506ebb97355a7959bd13c5b44c8df2a1d0bd74be44487f4cd0f625f815c93b36ee33687361235cba0a77a80c265e95ffabc4d6d620699ee5fed95d670eeb37c7ecd21cbc914e33063e7662522116b89888cbd6934737029a33d6460e3270588522c13cefb13959bebeba6000927e9d1234e3bb497caae36fe37109a5f4d1a453244764a2c0628e9e55be63e7eb7d7bb87dce7b6c85b4cd937e9168e7c09237ba739c993818b248a11796600a274c2fc338fdc1726753708465a32ec63b102b3c6edf8bd117a6f7b87dcf34a62f100fbe9c0a8b7a8a1cdf1f732a936064a600d6c77ecd68c0c80161629d00b33040902e2eba79df9e95ab49aa2fc7dbb7f26317f6b83d71704294ccf8e98e67054b266c089674b8683a0703d92f184c3eddab9c06d95aa1969b0e67c22a0b9bc3e6dcc82f88ecff2faf239507ebf3fc09511ae1a9995921e5ffd53d3b05c358a83efa66c4d90bbd18d7e0c8f4c241a29810d32bcaeb8e250ef344dc93dec1667d750b85eaaefbe55115dfe965bdf6f52cec22d9cdc34015ae8758a646c56ad9db23511009e23de4f7f3d245c1d0b4b4ad1f2731f48b650bca39c84e095eaf430a0321372391497577e8327137a2d17a853b89c9fc098907355dc8c6c40455e73ad9e2ab344c265e9968e65a43cc2899d736be46c24574885877c6e4066fc183f2902c0c6b59a575ec0b085ffeada351be73a5329b21356cd4ec9c756fb30e4f343f46a4d1da91c0511961b5a291139cc9784dfbb72842ff560efef245cbdea32dbd46fef425c03e396681fe588fd53cb8774515cb8b34ff2c278826b8fd42872d243640c4286ac98c65a89f19b9715d133dfa2b82ad46fe745972a76d6e8bda5efa05b47b7b3c13b8e59da8bf62609321e1a82a4d2f5cd54430efd22b5a2a866d4fd4e8b216cdf1aa710d1d2a3770f4f26b1b38b88e3c95d210d2fcc99798b1a7c54d4bd2844deb9ed5d26b9112038f1c33865de1e03a0061756632894c48bf73efad1d11ee6ae8b85680c33b84218e1c6277a89a9d8671f3b09f37c3f6c68ad5df85272e6af72ce5a966eb0b8f04e7ac7fcf17eb66f87460e2de2cb280cf84aaf2b0f2f19d3ebce43a1389c05cc29463fcea3049cf703db442bc8fdb8ec06644ba72124bb9a08c6f793e2843ce10ccb89f41075e5ee502364f88afb7f11397de6d98d2e60dc4a994a306709532d6a54d73b190da3be7d06457c1af6e277a5106a5d033ef7c66d252a4518bb74e75a310f4f659a3fbe5c508e5dc7b15ead8c19225dd8aa7259699c6a9cb21546ecdbbd0a5dde874d7f8b9422fbd45905c5e9b439fedd93f5960485fb660ff3a21f960d21d7dbb324ba90913147693743abba7027061c883f93160abb1e6cd644b320db19d55264624abc24e73b2f0d4027e3da31acb4d634743deddc2b22325926182ab409195a4ed4519f54d3e4a75bf10e4e08bb624e7ef447c085fdf0ccf0578516fbad90147de1901e82a0532256fae94f4431a07a385004d7dbe67089890eec65429a9016f95525f3b8e79970db3fac1625e274cc04fa1013045e4c57e348e33474ad6578e2ebad5055d9d9cbb6c84dc908fee91fb502db49cf9288aab227476ce218bef4dcccebd1b5cef7d69ee6c9de8fc595314e47bde88f2a142baf95fb41a9198c8c3c8fe65e32c1d9e5d255e2edd30d99b985d50de470c911f9ea12e029d660f3662113b7a9b837dffbd97acd6038c2b2e1287d9b37cf6b07cb8fdc21cc96b0d4cd9583cf796018e21c7bc82674a6bf37f4b960c7887bab8be313e271fc31615b76bc2e8e885491ec1b3518071a61440aea3a150d1f85fd586e1b596ea75b2b52cbf8c261672e3e4cb74b9cccaf85d7769af07a5d4b353c694c1e269c5206d2daa5f904229ed62a3066ca2e45da7af78af684ce05d8438681d10fe1bb206bc7df646eaaa669fdf2897ceeaf79f848c79049ec13bd1582924c0dc9a09f5b0c6ba816005ebf59167561bf1df37612b8b8ed7a6405b176ced06c2e6ebe6e5878f2e0cc4ca3933a9a2741142004d20e6d069b2bb1c866415f56ff8f46bc23057b160bc41bd6091f46aaee1e71713ea485360b6914b2640ceaf30ada436fecc93303e64fd20eecb2237df552a962c23b09d6052be907322fd507d76da99a433aec55ba1901529e179bf82145c5539879751a17946cd215713a7da8d4bdf6717f46379167c6c886a959ba69fd6c1e27c8f8d10a7f8c1b392352c8d97c3b45631cda26586751c5f626b38d2bdb136fcc1eaec00445460474c50f6baaee831217db0cab37dba7d6364de68f039cc6989ab514a49f70def47b728330403f016239e0f05807ee80250259689ac984c218100af497ce252bd75c2be13b7c886d020b14ce3b77efdd96a8351856d73ce8ee19cf0c9ec5ef62db1c91f022cbda0d9865f39d696ec68cb0ad73da8280e88da0a7411a0e7d9e9ece79f70fbd7a5641cd32939342cfcdc6ee9f0cf4d6fc5463872ae44e7a308f98b72bf6240ba8bbdf5d8e58ceecd4010dab38e74ad0732d8ebeecbcc11c8f1099f85b622bb14e94245ebfcea2a12c35d3680174409728c77cb32b96822b19b0ac6c55d35e0f5de31e8d0a4ec7035b08e6778412cc408a1368a99d4f3e4db18f8233a032270a10ab057c10fb8c800e1c86c44ce18622a0662e930dd7a28a0df50add684a7e546ffc2c3238734064f3434c382611f10a91f62fcab27f64729629495f0008edbab49b3310830a3927122e8c3becf51f5c356b89f152890048db601a9891c780f917aa24d3e3492d8e2994b4ae9316f552092d849f3953ee039b18e5794ead7a2f32f2fb0e8ed615d2e2cd8c77dd01eebcc0be232294d8c3b1e6562c6ee0d60a425dbb0c2286ecf9053a394e2db43855da06704fb086572eed2e5facbfac11563020ed376553e999904a10553a92c8e1302a6bbd9657dea44226fba4edb34d74071a115dd429e0e526e3633f30a8d20ba3e6f2851deff24f8a94ee9790e29332b17a1cd04e84080df638460dca6a15f9b7f32e4d96dee654581e5f075cad4e97a18ac03fbd19106db953319f7180c3f98aee40c5725db29d4efe8c190f8b6527ea610ec35696cb50da6c7385e917872558c454c81b2dda026505750392763ba21afa7845ec2971cdf59ff032d5fd7d1b5096907a25f9b7dec42dc659b89489ea59f8ba50f2bc6a261615aa494028c0cc1d6ed1d84c9dfb7d1a547196260900d07eada5160f75ef1fe26e502a526bd5672453c0853bc55e1c5ae329afd4debb842700e34503317274c91a2eb1dcb16cf868e71c1025e68f91f3cbd5b211097f06082ebf6d36dacaf127a5b5af3868785d077e1d195e3b543527c9292044f3386156a7a8ff94c1682cdfe631e9f6a4c143d781e4bbbbc4a5446276c7140c6c193260a12e3ca7a389765266602476700a48b3895f73608254336b5d3a16d35d22b45b053302b9d957fb7aa4596430e467f4c99a4e24943e4e5a38adaab51c1881e3ec3cdf7c64b5e6b92c3e2c8ebf7e09f7ec0a4804b7fc8bc42ced0624e81db0ba37e23c4272e008a613a54acea4b562a2618c521c83ccef68fb1f0a1ec9cf8e1465bf2d445ad830767bea48d9920bb2a9d898fc52eaa0230f0d8d6f4d872e3ea13a50bde149cc332b5b5872431960baeb332b54540ffaecbec5486a9fabbbe9dad76d30396359706c4910fdb93f0927325509229b1f9e5439616aa955338f8cca41e697d4a9e2c1ff13ff14c0c278a93d762dd3f9eb9391e1d4edef6c141c3e115b7d50409d75caeb03e07fd215861b0727ed45742589c31bd13519ca84aad05a5582d0e9cf1b96f6a72222121070b5ee123ee12dbab5eabe94a7ed537e2fda353d85d49bdbf7a11e4a26a8acb5b4d6d86f48cc0a6104d98bf1a8c70b802081798b33c70f2b189017a2e5ac5a640c010a93583b647037acfa5615b9db9069d213008c0c372e85a6bb0fcbea88f33f62586963215eaf029285a4693d23f2f45a7fd18f38dd8e5d8c106bb3b44c5d840732a9955a0f66cb7674bfec8f61c9b47240aa7e2b3abfabd71ce4a33b3bb8338732598f7d3d199fb605087d8f66d940f6f10f973d72ea3a3d5009d52bfa2632e7355a1a4a71be37bad113d32ac4d9292cc1f71768ee32953210a9b1eaaa129792f46c683c9ad1a3cce4bfadeef31bfcd1386858b12c3f7f2c31dc79041ee9ba690291cdc4c9ba5aa04235c5e50bc327a5a952934bc413ce215a252aade5673e24f257024dcdadbecd2c8d866af12fc1033e4ca79c61ba7ed1dc98c989672d3a8cfacfbce186c999705ce0c7cb2229ebb70201a0e4d28ccc8459a1ab02563729a3b3528a9ab43c74c61980f8acd0baed01a3234283bfa7eba4a1bbab2e759bab5a0b80e2aa58c634a9b14d5a7bda28ab27bbea1dc733bd131441b1b768b18352e94800dff810c41fa18264c31cb99a37f6d12d55cc1f42dd9d42c83f815340d2829783f9942c12526a4d2879159acb691a9883f8a1955cdafaceb90526a5be515c5f8c1a9a5ce9a50ea0266879552265bf6fe4d3d75ede6661090c9acc4450012cddd8c8f0a08ed92075250d8762748fe95063866610a24869ba2aecb22ec65f5d4e29df31695f5533719bb3f46c202e3de574d3603686999538816e9d8fd10e8519880129940d6d20eebbf38906143b20f436b270ec23289ba19fe243b65cd0b5f782262463bfce8461053e21f0607f5da0ce1a67ffc627949ab891a58797f02504e1f9a61d66719469e41dbc7719b3e7028748d2f92659b5eab5c814c4bde91754ff7e43fbc1310ed3a7b3ce00146ab09df400d218e3cfa86a72beafab67dd1dc2dd955d4b75e446ee43dc6f5e1b394816c3c6c0a20ae1eb6d9f1d5d308e1490a86050a0bffe15b1d395a89b5530578f42356092ee97b62a31506022c9ea29f401203583699974bad6bfa340ffccc0131c8fd77ace2a71a28626860dd64e55ee6a7d63f8281835667063b8238a3e322dbfd9072fe67e3e8a5397e7664c01bb0998892aebefa4a4af493572c7420b42e82df9ca70bfc52d4f3ed2496b907b4b48c0671f10ef962af5ba3091f45d39e721954b69dce68800aa35e8b257a6d21c77e530a526f517f2bfc50c7b673ca5963ca6a0bac3309fbc48a32cce865f9fec8197f3d0e05f0494bd0958e2c63df9bd02b913e3d606e575ec7becd743999075aa0664df161fa6a8cc423004c82c745748286e5e398c9672900c0ef04d023ba60414d48695ff27b63b97f896a441f4a63390cca866cbca26ecf0b81408ac6434ea51b14b03079626214da31bd5831766ea2a5c1319d76d14a4e634be80296ee34e1e19c659df79c383555d35f9accd7155577c994be74fa7dddb0b8f6dd38fc6041c43b6b4b150f3eafb1fa26603926aea3f8f9937460e3a808c7c7ab35a3ea53e3238a33108c4f423a78623a3269d8b54fe371457dbacb2301081650bce5494bccc019dd8ad1da7ccd758f4dea91787601e1dfee214ed6359bfe74eb4f9dc7e85baa352ebca8219006e149ecf8ae26cc35f6386a00d6ddd265682428ef9d4e4ac196282296daa6b646e05bed9da0b04092c7170804886dcb1659e419f54598483cd1753c88a364b88e1938deb889852e35e9af71e1f0dbae8336187731418988226f18570e16bc61c0d91daa29ab409a9dceda3f1896b22486976767f2f44381b9d3910f85fa2458a38af3b75d9c3fb21bd746f13e344d74db5b2ffa711470840cb5656412382598e7fdec3916f7e3d767efd51cde518dc7294b9168e65384299d4b074c7f2920da207b22a32962b182ca42b420371dc2a65003e06e5ed77db780f3cb69cd71784a37e5f36bbb1012dc332b4b2078076738ff53502df9b05b23fb64251c23928d3de9471bc44bf0ecdd8cd4cedb8ff7c2bace197bb0d373b70fa0e398e33ec2d60af162a6690c5281d83ca36874712f6b343c55d95de6a2533f74202c5ca6ae4d0e4f9994f8397e065ef9b2652b68cc92224</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Operating System Engineering#0 Booting a PC</title>
      <link href="/posts/mit-os-0/"/>
      <url>/posts/mit-os-0/</url>
      
        <content type="html"><![CDATA[<p><em>最近在学MIT的OS课程，lab绝对业界良心。<br />XJTU的操作系统课就是写一个系统调用，改下进程软中断通信的代码，代码量不足500。。。<br />MIT上课用xv6来教学，lab是做一个完整的小型操作系统JOS。</em></p><hr /><h2 id="配置环境">配置环境</h2><p>虽然没什么技术含量，但是这真的是令人头疼的事。附：<ahref="https://blog.csdn.net/eye_water/article/details/80638463">图文教程</a><br />需要一台x86机器，一般的Linux发行版应该都可以，可以使用<code>unabenlme -a</code>查看，如果显示<code>xxx GNU/Linux</code>就行，MIT的学生可以使用配置好的远程Server。<br />本来打算白嫖下Harvard的服务器，但是没有<code>root</code>权限，只能可怜巴巴地在Win环境用虚拟机。<br />平台：Vmware Player15，<ahref="http://old-releases.ubuntu.com/releases/14.04.5/">Ubuntu-14.04.5-desktop-i386.iso</a></p><ul><li>检验编译链<br /><code>objdump -i</code>：第二行显示elf32-i386；<br /><code>gcc -m32 -print-libgcc-file-name</code>：打印出/usr/lib/gcc/i686-linux-gnu/4.8/libgcc.a</li><li>安装git：<code>sudo apt-get install git</code></li><li>下载qemu<br />建议不要作死，安装MITPatch过的版本：<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code></li><li>安装依赖库<br />官方说要装5个库，但其实libtool-bin好像找不到，不过不影响后续：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install libsdl1.<span class="number">2</span><span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libglib2.<span class="number">0</span><span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libz<span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libpixman<span class="literal">-1</span><span class="literal">-dev</span></span><br></pre></td></tr></table></figure></li><li>配置qemu<br />切到qemu目录，<code>./configure --disable-kvm --disable-werror --target-list="i386-softmmu x86_64-softmmu"</code><br /><code>[--prefix=PFX]</code>可选参数是选择安装路径，这里就默认在<code>/usr/local</code></li><li>安装qemu：<code>sudo make &amp;&amp; sudo make install</code></li><li>下载实验代码<br />根目录下新建6.828目录，切到该目录，<code>git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</code>，切到<code>lab</code>目录，<code>make</code>就可以了。</li></ul><h2 id="pc-bootstrap">PC Bootstrap</h2><p>物理地址空间：<br /><img src="https://img-blog.csdnimg.cn/20200523082913317.png"alt="在这里插入图片描述" /><br />以前的PC内存只有1MB，Low Memory是PC唯一能用的RAM。VGADisplay是VGA缓冲区和固件，BIOS以前都在ROM中，不过现今都在闪存中，做完系统初始化（PCI总线等重要设备），寻找bootable设备(硬盘)，读取bootloader加载OS，将控制权转OS。后来内存远远超过1MB，可用的也就有ExtendedMemory，不过为了后向兼容，还是保留了LowMemory，这样可用的RAM就被分为了两部分。如果64位系统，那么内存更大，这样为了兼容，32-bitmemory mapped devices还是要保留，就又被割裂了。</p><h2 id="the-boot-loader">The Boot Loader</h2><p>硬盘的第一个分区存放启动程序，包括一个汇编文件<code>boot/boot.S</code>和一个C文件<code>boot/main.c</code>，启动程序将CPU从实模式转为32位保护模式，通过特殊的I/O指令读取内核。</p><h2 id="the-kernel">The Kernel</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Proxy</title>
      <link href="/posts/web-proxy/"/>
      <url>/posts/web-proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>WebProxy是浏览器和服务器的中间人：浏览器访问网页时，将请求发给代理，由代理将该请求发给服务器；服务器返回结果时，先发送给代理，由代理发给浏览器。之所以这么做，是因为可以在Proxy这做一些事情：</p><ul><li>防火墙: 比如伟大的GFW, 访问国外服务器必须先被GFW的代理审查一波</li><li>匿名器：代理可以隐藏浏览器的信息，使其对服务器匿名</li><li>缓存：暂存服务器返回结果，加快访问速度</li></ul><p>本项目要实现一个简单的Web Proxy，支持以下Features：</p><ul><li>中间人功能</li><li>并发</li><li>缓存</li></ul><h2 id="background-knowledge">Background Knowledge</h2><ul><li><p>HTTP/1.0 GET<br />当用户在浏览器输入URL<code>http://www.cnblogs.com/EIMadrigal</code>并按下回车后，浏览器会向代理发送HTTP请求，请求行可能如下：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.cnblogs.com:8080/EIMadrigal HTTP/1.1</span><br></pre></td></tr></table></figure></p></li></ul><p>代理要将这个请求解析为主机名<code>www.cnblogs.com</code>、端口<code>8080</code>和路径<code>/EIMadrigal</code>，之后代理可以尝试连接<code>www.cnblogs.com</code>并且向服务器发送新的HTTP请求，请求行如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /EIMadrigal HTTP/1.0</span><br></pre></td></tr></table></figure><ul><li>Request Header <img src="1.png" alt="在这里插入图片描述" /><br />请求头可能有多行，每行的基本组成就是头部字段名和值，需要注意的是：HTTP请求的每一行都以<code>\r\n</code>结束，并且整个请求是以空行<code>\r\n</code>结束。<br />项目要求：<strong>对于浏览器自带的requestheader，代理应该原封不动地转发</strong>。但必须将以下4项补齐，即如果自带的请求头包含以下4项之一，就按照自带请求头转发；否则按照下面的默认值转发。对于自带的其它请求头，直接转发即可：</li></ul><p>Host：服务器主机名，如果浏览器自带，直接转发；否则使用请求行里解析出的hostname。<br />User-Agent：用户的操作系统/浏览器等信息。<br />Connection：第一次请求/响应完成后，当前连接是否keep alive。<br />Proxy-Connection：同上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host: www.cnblogs.com</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (X11; Linux x86_64; rv:<span class="number">10.0</span><span class="number">.3</span>) Gecko/<span class="number">20120305</span> Firefox/<span class="number">10.0</span><span class="number">.3</span></span><br><span class="line">Connection: close</span><br><span class="line">Proxy-Connection: close</span><br></pre></td></tr></table></figure><ul><li>端口<br />请求端口：URL中的可选字段，如果用户输入时指定，代理应该连接指定端口，否则使用默认端口80。<br />监听端口：代理应该在该端口监听用户的连接请求，由命令行参数给出。可以是1024~65536之间的未被其他进程占用的任意值。</li></ul><h2 id="sequential-web-proxy">Sequential Web Proxy</h2><p>代理首先要接收浏览器HTTP请求，将浏览器的标准请求解析，转换为自己的请求发送。<br />这里的实现不难，只要模仿TinyServer在一个死循环中监听来自浏览器的请求，接收之后在<code>void doit(int fd)</code>里完成解析请求行、请求头、将处理后的请求发送给server、接收server的响应并写回浏览器。<br />一些比较方便的函数：<br /><code>int accept(int listenfd, struct sockaddr *addr, int *addrlen)</code>：在<code>listenfd</code>等待连接请求，将client的socket信息和长度存入<code>addr</code>和<code>addrlen</code>；<br /><code>int Open_clientfd(char *hostname, char *port)</code>：Openconnection to server at &lt;hostname, port&gt;, return a socketdescriptor ready for reading and writing.<br />读写时可以使用提供的RIO包。</p><p>这里需要注意的是请求的解析：思路是在proxy这里整合所有的请求行和请求头信息，对于所有浏览器发来的请求头的内容，原封不动保存到<code>reqHeader</code>里；对于默认的4个请求头，缺少几个，就按照规定内容增加进去。<br />还要注意：因为规定<code>Connection</code>和<code>Proxy-Connection</code>都有Connection这个单词，所以用<code>strstr</code>查找的时候：如果浏览器自带的请求头没有<code>Connection</code>但是有<code>Proxy-Connection</code>，这时程序就可能误判为有<code>Connection</code>，所以最好用函数<code>strncmp</code>或者<code>memcmp</code>。</p><p>要写一个非常robust的URI解析器还是挺繁琐的，由于C没有正则表达式（也许可以用其他语言写好编译成库，然后C程序调用？），需要考虑的情况很多。<br />首先明确URI的格式：一般由4部分组成：protocol://hostname:[port]/path/[parameters][?query][#fragment]<br />协议目前只支持HTTP和HTTPS，其它一律不合法。<br />因为一旦和服务器建立连接后，protocol和hostname就没用了，只需要path以及后面的query和fragment，为了方便起见，将/也放入path字段，因为其表示根目录，但是对于query和fragment，没有放?和#，因为找到请求内容的位置后，一些具体的搜索/片段直接用关键字即可，与?和#没关系，只有/特殊一些。</p><h2 id="multiple-concurrent-requests">Multiple Concurrent Requests</h2><p>对于Iterative Server，同时只能处理一个连接请求：<img src="2.png"alt="在这里插入图片描述" /><br />当第二个客户试图去连接：调用<code>connect</code>会正常返回，但Server不会<code>Accept</code>该请求，会用TCPListenBacklog技术将该请求入队；调用<code>rio_writen</code>也会正常返回，Server会把写入的数据存入缓存；调用<code>rio_readlineb</code>会阻塞，因为Server没有发送任何的response。</p><p>解决方法就是并发处理，我们的代理要能同时处理多个请求，具体的方法很多：多进程、I/O多路复用、预线程化（类似生产者-消费者问题，先创建n个线程，相当于n个缓冲区），最直接的方式就是专门有一个线程负责监听，每收到一个连接请求，就开一个新线程去进行读写。这里要采用<strong>可分离</strong>的线程模型：当其终止时，内存资源会被系统自动回收。</p><p>这部分本来很简单，但是写完后测试发现挂了： <img src="3.png"alt="在这里插入图片描述" /><br />这很可能是NOPServer出了问题，这个Server是用Python写的，我去启动了一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nop-server.py <span class="number">15000</span></span><br></pre></td></tr></table></figure><p>发现： <img src="4.png" alt="在这里插入图片描述" /><br />这个问题是Python的版本不匹配，把<code>nop-server.py</code>第一行的<code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python3</code>即可，指定用python3的解释器执行脚本。</p><p>并发这块也妥了： <img src="5.png" alt="在这里插入图片描述" /><br />这里的测试逻辑是这样的：Client1通过proxy连接到nop-server，这个服务器永远不会发送response，也就是这条连接一直保持；Client2通过proxy连接到Tiny，看看能不能从Tiny取个文件回来，如果能，说明并发是ok的，如果不能，说明不支持并发。之所以要用nop-server，是因为这东西可以一直连接，比较方便。如果Client1也是通过proxy连Tiny，那么可能很快就执行完了，这时Client2再去连接，很可能就不是并发的访问了，失去了测试的意义。</p><p>做第三部分之前，先实际测试下proxy的健壮性。用FireFox浏览器试试，先升级到最新版本，然后设置浏览器的代理方式：<img src="6.png" alt="在这里插入图片描述" /><br />在8080端口运行proxy，然后找个HTTP网站<code>http://csrankings.org/</code>试一下，现在网站基本都是HTTPS，看来后续的Features要支持HTTPS了（先挖个坑）。</p><p>运行proxy之前，画风是这样的： <img src="7.png"alt="在这里插入图片描述" /> 运行proxy之后： <img src="8.png"alt="在这里插入图片描述" /><br />通过代理访问该网页时，页面只能加载一部分，收到59420B数据后，会<code>segmentation fault</code>，最后发现主要原因是<code>init_cache()</code>时空间分配写错了，但是修改后又出现了如下错误：<img src="9.png" alt="在这里插入图片描述" /><br />是<code>memcpy</code>时候数组越界，处理buffer时候要千万小心。</p><p>这里要改下<code>csapp.c</code>中的错误处理，里面都是直接<code>exit(0)</code>，但是作为一个服务器，不能随便终止，所以我们注释掉所有Error-handlingfunctions里的<code>exit()</code>，如果在读数据或者什么时候遇到错误，<code>return</code>即可：<code>exit()</code>是系统调用级别的，结束整个进程；<code>return</code>是函数级别的，返回给调用者，当然在<code>main()</code>里<code>return</code>也就是<code>exit(0)</code>。</p><h2 id="caching-web-objects">Caching Web Objects</h2><p>HTTP协议本身就实现了缓存机制, 目的是为了减小网络传输的开销,只需要通过URI和请求端口就可以判断是否请求的同一对象.缓存可以说是整个项目的难点, 需要考虑的问题比较多.为了模块化，将这一部分单独写作<code>cache.c/cache.h</code>,并修改<code>Makefile</code>.</p><p>首先, 由于内存有限,因此代理的缓存大小<code>MAX_CACHE_SIZE</code>也是有限的. 另外,为了避免太大的web对象占据太多缓存空间, 减小其他对象的被缓存几率,对web对象的大小<code>MAX_OBJECT_SIZE</code>也是有要求的.</p><p>难点有2个：</p><ol type="1"><li>多线程同步：对于cache的访问应当是线程安全的，多个线程可以同时读，但只有一个线程可以写，这就是典型的读者-写者问题;<br /></li><li>替换策略：cache块的数量是有限的，没有空间时就需要换出换入。一般来讲都是采用LRU方式，一个单线程的严格的LRUCache可以参考<ahref="https://leetcode.com/problems/lru-cache/">leetcode146题</a>。</li></ol><p>我们首先来解决问题一:保证线程安全最简单的方法就是给<strong>整个cache</strong>加一个大大的排他锁(exclusivelock), 效率当然会低到无法接受. 一个直观的改进就是将cache分区,细化锁的粒度, 用读写锁进行保护.<br />读者写者问题可以有读优先和写优先2种方案: 读优先指来了一个读进程,除非有一个写进程正在访问, 否则读者直接去读, 可能导致写进程饥饿.写优先指有进程读时, 如果来了写进程, 那么禁止后续读进程请求,现有进程读完后, 写进程立即去写, 可能导致读进程饥饿.<br />写优先实现起来稍微麻烦一些, 并且一般读操作频率高于写操作,所以这里采用读优先. 这里就不自己实现读者写者了,使用读写锁<code>pthread_rwlock_t</code>, 确保不会死锁.</p><p>接着来解决问题二: 要实现多线程并发LRUCache，由于C实现双向链表和Hashtable有点繁琐，所以项目要求<strong>近似LRU</strong>即可：我们可以为每一个cache块附加一个时间戳，每当该块被访问时，就更新时间戳。需要替换时，换出时间戳最小的块即可。这样带来的问题就是：读的时候也需要更新时间戳，但更新时间需要加写锁，如果其他线程占用写锁，那么读进程就无法更新时间戳，也就不是严格的LRU了。</p><p>Cache的实现既可以像malloclab一样采用分级的思想，也可以直接均分所有空间，整体流程如下：</p><ul><li>初始化</li><li>查Cache</li><li>如果miss，寻找可用位置</li><li>找到可用块，缓存满足大小条件的Object</li><li>更新时间戳</li></ul><p>最大的缓存对象是100KB，一共的空间1MB，平均可以缓存10个Object，这样大的对象占用太多空间，降低cache命中率，所以采用分级的方法：<br />100KB * 5块 = 500KB<br />50KB * 6块 = 300KB<br />20KB * 5块 = 100KB<br />10KB * 10块 = 100KB<br />1KB * 24块 = 24KB<br />接着来构思下存储结构，<strong>设计数据结构</strong>和<strong>类（函数）接口</strong>是我认为做一个工程最难的部分，当然还有最后的效率优化问题：<br />一个cacheline最基本的构成需要存储URI和OBJ，因为下次用户请求时代理需要知道请求的是哪个网站的什么内容（通过URI确定），进而如果查找到，将内容OBJ直接返回给用户。同时还需要一个时间戳以及用于同步的读写锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *uri;</span><br><span class="line">    <span class="keyword">char</span> *obj;</span><br><span class="line">    <span class="keyword">int</span> objSize;</span><br><span class="line">    <span class="keyword">int64_t</span> time;</span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> rwlock; </span><br><span class="line">&#125; cache_line;</span><br></pre></td></tr></table></figure><p>一共有5种类型的cache，每种类型有一个number，还有一个指向该种cache第一块的指针p，p指向该种的第一小块，p+1指向该种的第二小块，以此类推：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> numOfLine;</span><br><span class="line">    cache_line *cachep;</span><br><span class="line">&#125; cache_type;</span><br></pre></td></tr></table></figure><p>数据结构设计完后，需要设计函数接口，cache的操作有初始化、查找、写入（替换）和释放：<br />初始化需要为cacheblock分配空间，将每一块的时间戳置0，表示该块没有存储内容；<br />查找时需要遍历所有的type，再在该type中遍历所有的block，如果时间戳不为0，比对浏览器需要访问的URI与当前块的URI是否相等，相等则表示cachehit，直接写回给相应的fd；更新时间戳时，粒度越细越好，这里用<code>gettimeofday</code>精确到微秒级别；读取时如果能申请到写锁，就更新时间，否则就不更新；<br />写入时需要先计算object大小，寻找空闲的cacheblock，没有需要替换，满足要求后存入cache，并且将结果返给浏览器。这里要注意寻找空闲块时要<strong>从小往大</strong>，否则很可能一个很小的object占用了一块很大的block，造成严重浪费，类似于操作系统内存管理动态分配中的最佳适应算法。<br />那么这种分级的方式的缺点是：每种类型的cache块<strong>大小固定</strong>，很可能50KB的块只存了10KB内容，造成浪费，类似于固定分区分配。<br />关于替换，我们采取<strong>局部置换</strong>策略：即需要换入的object大小如果是30KB，我们只用50KB这种类型去存储，如果50KB的块用完了，就需要换出一块50KB，即使此时100KB的块有空闲，也仍然完成置换过程。</p><p>写完cache后，需要修改<code>Makefile</code>，在<code>proxy.c</code>中增加cache的部分。运行完以后，可以用<code>make clean</code>清除目录下多余的垃圾文件，比如<code>.o</code>文件等。</p><h2 id="test">Test</h2><p>测试的方式一共有3种：</p><ul><li>自动化测试利用课程提供的脚本<code>driver.sh</code>自动进行，执行之前，需要安装一些工具：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure><p>做完所有内容后，先用<code>driver.sh</code>进行测试，发现cache部分没分。。。得，开始debug吧！我觉得GDB好难用啊，所以都是通过<code>printf</code>de的。</p><p>用curl先通过proxy发个请求，然后看看proxy有没有缓存服务器返回的内容。<br />最后发现在<code>write_cache</code>时需要用到URI，但是之前解析时候把URI改了，一定注意URI最好不要改，设置为<code>const</code>比较保险。</p><p>完了以后，cache满分了，basic又错了一个，fetch可执行对象文件tiny时：<img src="10.png" alt="在这里插入图片描述" /><br />一开始怀疑是tiny太大了，某个数组爆掉了。看了下tiny有36000+B，缓存空间足够，但是可能写入时候有些bug。tiny是二进制文件，可能比较特殊？很奇怪的是：明明<code>objSize</code>是36000+，但是<code>strlen(obj)</code>只有100，怀疑文件中可能有<code>\0</code>，提前终止了<code>strlen</code>的计数。</p><p>解决方案是<code>write_cache</code>参数不仅要有<code>uri</code>和<code>obj</code>，还要有<code>obj</code>的长度<code>len</code>，否则直接用<code>strlen</code>获取长度可能就挂了。后来修改以后就满分了，一定要注意，如果用<code>char*</code>传参，一定要附带参数<code>len</code>，因为不一定读取的是字符串，还有可能是二进制文件，<code>\0</code>也就是<code>0</code>很容易出现，用<code>strlen</code>大概率会爆掉。</p><p>最终测试结果如下： <img src="11.png" alt="在这里插入图片描述" /> <imgsrc="12.png" alt="在这里插入图片描述" /></p><ul><li>利用<code>curl</code>工具<br /><code>curl</code>可以用来生成HTTP请求：假设Sever在端口15213监听，代理在端口15214监听，那么可以通过下面命令经由代理发送请求：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --proxy http:<span class="comment">//localhost:15214 http://localhost:15213/home.html</span></span><br></pre></td></tr></table></figure><p>我们用该工具测试下Sequential Web Proxy：<br />首先启动Tiny Web Server和Proxy：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./tiny 15213</span><br><span class="line">./proxy 15214</span><br></pre></td></tr></table></figure><p>然后执行<code>curl</code>命令： <img src="13.png"alt="在这里插入图片描述" /><br />说明基本功能是OK的！！</p><ul><li>实际浏览器测试<br />满分之后，万里长征走了一半吧，因为要在实际浏览器测试，不断增强程序的<strong>鲁棒性</strong>。测试之前，先禁用浏览器自带的cache，清空之前的缓存。 测下内存泄漏：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --leak-check=full --show-leak-kinds=all ./proxy 8080</span><br></pre></td></tr></table></figure><h2 id="code-reference">Code &amp; Reference</h2><p><ahref="https://github.com/EIMadrigal/15-213/tree/master/Web%20Proxy">codehere</a><br /><a href="http://csapp.cs.cmu.edu/3e/labs.html">reference here</a></p><h2 id="todo">TODO</h2><p>接下来的工作可拓展的还有很多，包括但不限于：</p><ul><li>增加对HTTPS的支持（看起来并不简单）</li><li>Cache这里还有很多可优化的地方（分配策略、置换策略...）</li><li>目前只支持GET方式，还可以拓展到POST方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给我未来的孩子</title>
      <link href="/posts/for-my-children/"/>
      <url>/posts/for-my-children/</url>
      
        <content type="html"><![CDATA[<p>读诗之前，先澄清一点：这首诗原作者是作家张梅女士，收录于20世纪90年代出版的个人散文集《木屐声声》。至于流传甚广的余光中先生的《写给未来的你》，完全是某些出版物杜撰的，17年余先生去世时，大家读着这篇别人的文章以为纪念，不知道算不算一种悲哀。</p><p>如果读过余光中的作品，他的文风绝对不会像这首诗这么直白，当然也不会如此鸡汤。</p><p>说回这首诗，有一次搜索「理想主义者」时偶然读到，虽然有些道理比较宏大，但是整体来看都是作者阅历的总结，如果结合自身经验去读相信一定收获颇丰，当然作为育儿经也是不错的~</p><hr /><p>孩子，我希望你自始至终都是一个理想主义者。</p><p>你可以是农民，可以是工程师，可以是演员，可以是流浪汉，但你必须是个理想主义者。</p><p>童年，我们讲英雄故事给你听，并不是一定要你成为英雄，而是希望你具有纯正的品格。</p><p>少年，我们让你接触诗歌、绘画、音乐，是为了让你的心灵填满高尚的情趣。这些高尚的情趣会支撑你的一生，使你在最严酷的冬天也不会忘记玫瑰的芳香。</p><p>理想会使人出众。</p><p>孩子，不要为自己的外形担忧。</p><p>理想纯洁你的气质，而最美貌的女人也会因为庸俗而令人生厌。</p><p>通向理想的途径往往不尽如人意，而你亦会为此受尽磨难。</p><p>但是，孩子，你尽管去争取，理想主义者的结局悲壮而绝不可怜。</p><p>在貌似坎坷的人生里，你会结识许多智者和君子，你会见到许多旁人无法遇到的风景和奇迹。</p><p>选择平庸虽然稳妥，但绝无色彩。</p><p>不要为蝇头小利放弃自己的理想，不要为某种潮流而改换自己的信念。</p><p>物质世界的外表太过复杂，你要懂得如何去拒绝虚荣的诱惑。</p><p>理想不是实惠的东西，它往往不能带给你尘世的享受。</p><p>因此你必须习惯无人欣赏，学会精神享受，学会与他人不同。</p><p>其次，孩子，我希望你是个踏实的人。</p><p>人生太过短促，而虚的东西又太多，你很容易眼花缭乱，最终一事无成。</p><p>如果你是个美貌的女孩，年轻的时候会有许多男性宠你，你得到的东西太过容易，这会使你流于浅薄和虚浮；如果你是个极聪明的男孩，又会以为自己能够成就许多大事而流于轻佻。</p><p>记住，每个人的能力有限，我们活在世上能做好一件事足矣。</p><p>写好一本书，做好一个主妇。</p><p>不要轻视平凡的人，不要投机取巧，不要攻击自己做不到的事。</p><p>你长大后会知道，做好一件事太难，但绝不要放弃。</p><p>你要懂得和珍惜感情。</p><p>不管男人女人，不管墙内墙外，相交一场实在不易。</p><p>交友的过程会有误会和摩擦，但想一想，诺大世界，有缘结伴而行的能有几人？</p><p>你要明白朋友终会离去，生活中能有人伴在身边，听你倾谈，倾谈给你听，就应该感激。</p><p>要爱自己和爱他人，要懂自己和懂他人。</p><p>你的心要如溪水般柔软，你的眼波要像春天般明媚。</p><p>你要会流泪，会孤身一人坐在黑暗中听伤感的音乐。</p><p>你要懂得欣赏悲剧，悲剧能丰富你的心灵。</p><p>希望你不要媚俗。</p><p>你是个独立的人，无人能抹杀你的独立性，除非你向世俗妥协。</p><p>要学会欣赏真，要在重重面具下看到真。</p><p>世上圆滑标准的人很多，但出类拔萃的人极少。而往往出类拔萃又隐藏在卑琐狂荡之下。</p><p>在形式上我们无法与既定的世俗争斗，而在内心我们都是自己的国王。</p><p>如果你的脸上出现谄媚的笑容，我将会羞愧地掩面而去。</p><p>世俗的许多东西虽耀眼却无价值，不要把自己置于大众的天平上，不然你会因此无所适从，人云亦云。</p><p>在具体的做人上，我希望你不要打断别人的谈话，不要娇气十足。</p><p>你每天至少要拿出两小时来读书，要回信写信给你的朋友。</p><p>不要老是想着别人应该为你做些什么，而要想着怎么去帮助他人。</p><p>借他人的东西要还，不要随便接受别人的恩惠。</p><p>要记住，别人的东西，再好也是别人的；自己的东西，再差也是自己的。</p><p>孩子，还有一件事，虽然做起来很难，但相当重要，这就是要有勇气正视自己的缺点。</p><p>你会一年年地长大，会渐渐遇到比你强、比你优秀的人，会发现自己身上有许多你所厌恶的缺点。这会使你沮丧和自卑。</p><p>但你一定要正视它，不要躲避，要一点点地加以改正。</p><p>战胜自己比征服他人还要艰巨和有意义。</p><p>不管世界潮流如何变化，但人的优秀品质却是永恒的：正直、勇敢、独立。</p><p>我希望你是一个优秀的人。</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bit Manipulation</title>
      <link href="/posts/bit-manipulation/"/>
      <url>/posts/bit-manipulation/</url>
      
        <content type="html"><![CDATA[<p>位操作可以使得我们细粒度地控制数据，但是很多技巧显得非常tricky，需要做一些总结。</p><h2 id="basics">Basics</h2><p>常见的操作有：与、或、非、异或和移位。</p><ul><li><code>n &amp; (n - 1)</code>：将n的二进制表示中最低位的<code>1</code>改为<code>0</code></li><li><code>a ^ b = b ^ a</code>，<code>(a ^ b) ^ c = a ^ (b ^ c)</code>，<code>a ^ 0 = a</code>，<code>a ^ a = 0</code></li><li><code>n &amp; (-n)</code>或<code>n &amp; (~n + 1)</code>：lowbit操作，将最低位的1及后面的0代表的数字转为十进制</li><li><code>&amp;</code>只会递减/不变</li><li><code>a = a | (1 &lt;&lt; i)</code> 将a的第i位设为1</li></ul><h2 id="examples">Examples</h2><ol type="1"><li>计算二进制中<code>1</code>的个数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>判断整数是否为2的幂</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v; <span class="comment">// we want to see if v is a power of 2</span></span><br><span class="line"><span class="keyword">bool</span> f;         <span class="comment">// the result goes here </span></span><br><span class="line"></span><br><span class="line">f = (v &amp; (v - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">f = v &amp;&amp; !(v &amp; (v - <span class="number">1</span>));  <span class="comment">// v=0特判</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>整数相加</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// a^b: a+b without carry</span></span><br><span class="line">        <span class="comment">// a&amp;b: the carry</span></span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum(a ^ b, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>将n中第i~j位置0</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">    mask |= (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br><span class="line">mask = ~mask;</span><br><span class="line">n = n &amp; mask;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><ahref="https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary:-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently">Asummary: how to use bit manipulation to solve problems easily andefficiently</a><br /><a href="http://graphics.stanford.edu/~seander/bithacks.html">BitTwiddling Hacks</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Library Functions Implementation</title>
      <link href="/posts/library-functions-implementation/"/>
      <url>/posts/library-functions-implementation/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">void</span>* des, <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!src || !des)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (des &gt; src &amp;&amp; (<span class="keyword">const</span> <span class="keyword">char</span>*)src + cnt &lt; (<span class="keyword">char</span>*)des) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* srcB = (<span class="keyword">const</span> <span class="keyword">char</span>*)src + cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* desB = (<span class="keyword">char</span>*)des + cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">            *desB = *srcB;</span><br><span class="line">            --desB;</span><br><span class="line">            --srcB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* srcF = (<span class="keyword">const</span> <span class="keyword">char</span>*)src + cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* desF = (<span class="keyword">char</span>*)des + cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">            *desF = *srcF;</span><br><span class="line">            ++desF;</span><br><span class="line">            ++srcF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将original中的子串substr替换为replace</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strReplace</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* original, <span class="keyword">const</span> <span class="keyword">char</span>* substr, <span class="keyword">const</span> <span class="keyword">char</span>* replace)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!original || !substr || !replace) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(original);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* newStr = <span class="built_in">malloc</span>((len + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(newStr, original, (len + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* p = <span class="built_in">strstr</span>(newStr, substr);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, replace, <span class="built_in">strlen</span>(replace));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector">vector</h2><p>比较高频的问题：为什么<code>push_back()</code>的平均时间复杂度是<spanclass="math inline">\(O(1)\)</span>？<br />假设倍增因子是<span class="math inline">\(m\)</span>，vector当前有<spanclass="math inline">\(n\)</span>个元素，那么扩容过程大致为：<spanclass="math inline">\(0,1,m,m^2,...,m^{log_mn}\)</span>，每次扩容的复杂度等于当时的元素个数，无需扩容时插入的时间复杂度为<spanclass="math inline">\(O(1)\)</span>，所以总的复杂度为： <spanclass="math display">\[1+m+m^2+...+m^{log_mn}=\frac{mn-1}{m-1}\]</span>如果<span class="math inline">\(m=2\)</span>，那么均摊到<spanclass="math inline">\(n\)</span>个元素，插入每个元素的操作复杂度就是<spanclass="math inline">\(O(1)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">class myvector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">push_back</span>(T&amp; x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="built_in">broad</span>(<span class="number">2</span> * capacity + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        obj[size++] = x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">broad</span><span class="params">(<span class="keyword">int</span> newCap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newCap &lt; size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        T* tmp = obj;</span><br><span class="line">        obj = <span class="keyword">new</span> T[newCap];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            obj[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    T* obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Invalid input!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*str == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;+&#x27;</span> || *str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*str &lt; <span class="string">&#x27;0&#x27;</span> || *str &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Invalid input!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        value = value * <span class="number">10</span> + *str - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign * value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(mn)，可以用KMP优化为O(m+n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; haystack.<span class="built_in">size</span>() &amp;&amp; j &lt; needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - j + <span class="number">1</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - needle.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tiny Shell</title>
      <link href="/posts/tiny-shell/"/>
      <url>/posts/tiny-shell/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>本项目要实现一个简易版Shell，支持以下Features： -命令提示符<code>tsh&gt;</code> -若用户输入的命令第一个单词是内置命令，在当前进程tsh(TinyShell)执行命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span>   列出运行/挂起的后台job</span><br><span class="line"><span class="built_in">bg</span> &lt;job&gt;   通过发送SIGCONT信号重启进程，将后台挂起的job设为在后台运行，&lt;job&gt;可以是PID或%JID</span><br><span class="line"><span class="built_in">fg</span> &lt;job&gt;   通过发送SIGCONT信号重启进程，将后台运行/挂起的job设为在前台运行，&lt;job&gt;可以是PID或%JID</span><br><span class="line"><span class="built_in">kill</span> &lt;job&gt;   结束&lt;job&gt;</span><br><span class="line">quit   退出tsh</span><br></pre></td></tr></table></figure> -若用户输入的命令第一个单词是可执行文件路径，后续单词是命令行参数，tsh会fork一个子进程，在子进程运行- 支持jobcontrol（前后台切换），改变进程状态（running/stopped/terminated） -支持管道<code>|</code>和I/O重定向<code>&lt;</code><code>&gt;</code>(TODO)</p><h2 id="background-knowledge">Background Knowledge</h2><ul><li>Shell<br />shell是一个交互式的命令行解释器，可以执行用户输入的指令，显示计算结果。<br />用户输入既可以是内置命令，也可以是可执行文件路径。<br />用户既可以在前台运行，也可以在后台运行。后台job可以在命令最后加一个<code>&amp;</code>，否则视为前台。比如<code>/bin/ls -l -d &amp;</code>表示在后台执行<code>ls</code>程序。前台job只能有1个，后台job则可以有多个。</li><li>Signals<br />信号机制的作用就是允许进程/内核打断其他进程运行，是进行进程间通信的一种方式。<br />Linux的常用信号有： <imgsrc="https://img-blog.csdnimg.cn/20200719145450179.png"alt="在这里插入图片描述" /></li></ul><h2 id="implementation">Implementation</h2><p>整体的思路是：父进程读取命令行输入，通过系统调用<code>fork()</code>创建子进程执行这些输入。对于前台命令，父进程必须等待子进程完成才能继续读取下一条命令；对于后台命令，父进程和子进程则是并发执行。</p><ul><li>useful functions<br /><code>int fork(void)</code>：父进程创建一个子进程，在子进程中返回0，父进程中返回子进程的PID。<br /><code>int kill(pid_t pid, int sig)</code>：进程向其它进程（包括自己）发送信号，成功返回0，错误返回-1。可以通过改变参数<code>pid</code>调整发送目标：<code>pid&gt;0</code>，给该进程发信号；<code>pid==0</code>，给包括自己在内的当前进程组发信号；<code>pid&lt;0</code>，给pgid=|pid|的进程组的每个进程发信号。<br /><code>int execve(char *filename, char *argv[], char *envp[])</code>：在当前进程的上下文环境中装载并运行新的程序，成功不返回，失败返回-1。<code>filename</code>可以是可执行目标文件或脚本文件，会覆盖原进程的data/code/stack，会保留原进程的PID/openfiles/signal context。<br /><code>pid_t waitpid(pid_t pid, int *status, int options)</code>：指定进程终止父进程会进行回收，否则等待。内核会将子进程的退出状态传给父进程，之后清除子进程。<code>options=WNOHANG | WUNTRACED</code>时，如果waitset中没有终止/暂停的子进程，立即返回0；否则返回任意一个子进程的PID。<br /><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)</code>：<code>how=SIG_BLOCK</code>将<code>set</code>中的信号加入阻塞向量；<code>how=SIG_UNBLOCK</code>将<code>set</code>中的信号从阻塞向量中移除；<code>how=SIG_SETMASK</code>将阻塞向量设置为<code>set</code>。如果<code>oldset!=NULL</code>之前的阻塞向量就存储在<code>oldset</code>中。<br /><code>handler_t *signal(int signum, handler_t *handler)</code>：改变信号的默认行为。</li><li>step by step<br />--整体结构：除了测试文件和Makefile外，全部实现都在<code>tsh.c</code>中，<code>main</code>函数有一个死循环，不停调用<code>eval()</code>实现命令的解析、执行。<br />-- <code>eval(char* cmdline)</code><br />接收到用户输入后，第一件事就是解析。解析是通过<code>int parseline(const char* cmdline, char** argv)</code>完成，将<code>cmdline</code>解析到<code>argv</code>中，如果用户要求后台运行就返回1，否则返回0。<br />解析后，我们需要通过<code>int builtin_cmd(char** argv)</code>判断是否为内置命令。如果是内置命令，就在<code>builtin_cmd</code>里立刻执行；否则需要创建子进程执行，这里需要区分前后台进程：如果是前台，需要等待terminate才能返回并接受新的输入；如果是后台，则可以立即接收新输入。</li><li>key point 1<br />父进程在<code>fork</code>子进程之前，要用<code>sigprocmask</code>阻塞<code>SIGCHLD</code>信号。否则由于父子进程执行顺序不确定，可能导致：<br />子进程首先执行完毕，内核向父进程发送<code>SIGCHLD</code>信号；<br />从内核态切换到用户态时，检测到<code>SIGCHLD</code>信号并且执行<code>sigchld_handler</code>，删除该job；<br />父进程执行<code>addjob</code>操作，显然删除和添加顺序反了。<br />如果我们正确阻塞了<code>SIGCHLD</code>信号，还是按照上面的顺序：<br />子进程首先执行完毕，内核向父进程发送<code>SIGCHLD</code>信号；<br />从内核态切换到用户态时，由于父进程阻塞了<code>SIGCHLD</code>信号，所以不会执行<code>sigchld_handler</code>；<br />父进程添加该job，解除<code>SIGCHLD</code>信号的阻塞，下一次contextswitch时删除job。</li><li>key point 2<br />用户从键盘输入ctrl-c时，内核给shell进程发<code>SIGINT</code>信号（默认的signalhandler是终止shell进程），一般有以下几种方式处理：</li></ul><ol type="1"><li>忽略该信号</li><li>使用默认的signal handler</li><li>实现一个单独的signal-handling函数</li></ol><p>在<code>main</code>里面安装handler，在<code>sigint_handler</code>中处理：终止所有的前台进程及其子进程；<br />用户从键盘输入ctrl-z时，内核给shell发<code>SIGTSTP</code>信号（默认暂停当前进程直到收到<code>SIGCONT</code>），在<code>main</code>里面安装handler，在<code>sigtstp_handler</code>中处理：暂停所有的前台进程及其子进程。- key point 3<br />默认情况下，<code>fork</code>出来的子进程和他爹属于同一个进程组。当我们在机器上运行TinyShell时，程序运行在前台进程组中，这时如果TinyShell创建一些子进程，这些子进程也会同属于这个前台进程组，用户输入ctrl-c会终止所有前台进程，包括TinyShell，这显然不是我们想要的。<br />解决方案是：<code>fork</code>之后，子进程调用<code>setpgid(0,0)</code>将其放到一个新的进程组里，这个组的groupid和PID相同。这样就可以确保前台进程组里只有TinyShell一个进程，用户输入ctrl-c时，就可以在<code>sigint_handler</code>中调用<code>kill()</code>终止特定的前台job。- key point 4<br />当子进程终止或者暂停，内核会给父进程发送<code>SIGCHLD</code>信号，我们在<code>sigchld_handler</code>中根据子进程的状态做相应的处理：<br /><code>WIFEXITED(status)</code>：子进程通过<code>exit</code>或<code>return</code>正常终止；<br /><code>WIFSIGNALED(status)</code>：子进程通过信号终止；<br /><code>WIFSTOPPED(status)</code>：子进程暂停；<br /><code>WTERMSIG(status)</code>：当<code>WIFSIGNALED()</code>为真，返回造成子进程终止的信号ID；<br /><code>WSTOPSIG(status)</code>：当<code>WIFSTOPPED()</code>为真，返回造成子进程暂停的信号ID。- key point 5<br />对于前台进程，需要一直等待其执行完毕，然后回收，可以在<code>waitfg()</code>中调用<code>sigsuspend</code>完成；但对于后台进程，由于不用等待其完成，所以为了避免其成为zombie，需要在其执行完毕或者暂停时通知父进程，这个机制就是signal，具体的就是我们的<code>sigchld_handler</code>做的事情。</p><p>如果子进程因为收到了未能捕获的信号(如SIGKILL)而终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，那么该子进程就成为僵尸进程。</p><p>处理僵尸进程有2种方法： -杀死其父进程，子进程变为孤儿进程，进而被系统回收 -<code>wait</code>函数</p><h2 id="test">Test</h2><p>一方面通过提供的脚本测试，共有16个脚本测试文件，测试通过<code>make test01</code>~<code>make test16</code>进行；<br />另一方面通过实际执行去测试各项功能。</p><h2 id="code-reference">Code &amp; Reference</h2><p><ahref="https://github.com/EIMadrigal/15-213/tree/master/Tiny%20Shell">codehere</a><br /><a href="http://csapp.cs.cmu.edu/3e/labs.html">reference here</a></p><h2 id="todo">TODO</h2><ul><li>IO重定向<br />https://www.cnblogs.com/weidagang2046/p/io-redirection.html</li><li>管道<br />https://panqiincs.me/2017/04/19/write-a-shell-redirect-and-pipeline/</li><li><ahref="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L1">xv6-riscv/sh.c</a></li><li>history：支持快速访问最近的若干条命令</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seam Carving</title>
      <link href="/posts/seam-carving/"/>
      <url>/posts/seam-carving/</url>
      
        <content type="html"><![CDATA[<p>这是CS 61B的HW5，具体实现<ahref="https://github.com/EIMadrigal/CS61B/tree/master/hw5">在这里</a>。## Intro 这个项目是要实现一种基于内容的图像缩放算法SeamCarving。Seam分为垂直（自上而下每行取一个像素点）和水平（自左向右每列取一个像素点）。<br />下图是一张505*287的图像：<br /><img src="https://img-blog.csdnimg.cn/20200707090755919.png"alt="在这里插入图片描述" /><br />移除150条垂直seam，得到一张比原图窄30%的新图：<br /><img src="https://img-blog.csdnimg.cn/2020070709085251.png"alt="在这里插入图片描述" /><br />与传统的内容不可知的方法（裁剪、缩放）相比，seamcurving可以保留原图的大多数重要特征。<br />图像处理中的坐标表示与常见的笛卡尔坐标系不同：<br /><img src="https://img-blog.csdnimg.cn/20200707094310172.png"alt="在这里插入图片描述" /><br />每个像素的颜色采用RGB空间，与<code>java.awt.Color</code>一致。算法的过程分为3步：</p><ul><li>Energy calculation<br />因为是内容感知算法，所以需要一个指标衡量每个像素的<strong>重要程度</strong>，这个指标我们叫做该像素点的能量：能量越高越重要，就不太会被当做seam的一部分剔除。<br />我们选择双梯度能量函数来计算能量。对于上面的冲浪图，计算后的灰度图如下：<br /><img src="https://img-blog.csdnimg.cn/20200707095021383.png"alt="在这里插入图片描述" /><br />可以看到：高能量像素对应颜色发生巨变的地方，比如冲浪者和大海的边界、天际线等，并且颜色更白。处理过程中就是要避免移除这些关键信息。</li><li>Seam identification<br />计算出每个像素点的能量值后，就要找出一条能量值总和最小的seam，垂直seam从顶行的某像素点开始到最后一行某点结束。但是如果(x,y)位于seam，下一行只能选(x-1,y+1),(x,y+1), (x+1,y+1)之一，可能是为了保证图像的连贯。</li><li>Seam Removal<br />移除找到的seam。</li></ul><h2 id="implement">Implement</h2><p>三个步骤的实现都在<code>SeamCarver</code>中，我们逐个来看： -单像素能量计算<br />采用对偶梯度能量函数<span class="math inline">\(\Delta_x^2(x, y) +\Delta_y^2(x, y)\)</span>，x梯度的平方<spanclass="math inline">\(\Delta_x^2(x, y) = R_x(x, y)^2 + G_x(x, y)^2 +B_x(x, y)^2\)</span>，<span class="math inline">\(R_x(x, y), G_x(x, y),B_x(x, y)\)</span>是左右两个像素点(x+1, y)和(x-1,y)的红、绿、蓝之差的绝对值；类似地，对于y的梯度，就是要求上下两个像素点的差。对于边界的处理，采取循环方式，即如果某侧不存在，就取反方向的点。<br />举例来看： <img src="https://img-blog.csdnimg.cn/20200707155708977.png"alt="在这里插入图片描述" /><br />要计算(1, 0)位置即(255, 101, 153)的能量：<br /><span class="math display">\[R_x(1, 0) = 255 − 255 = 0, G_x(1, 0) = 101− 101 = 0, B_x(1, 0) = 255 − 51 = 204\]</span><br />故<span class="math inline">\(\Delta_x^2(1, 0) = 204^2 =41616\)</span>；对于y方向，由于没有(x, y-1)，就用(x,height-1)代替：<br /><span class="math display">\[R_y(1, 0) = 255 − 255 = 0, G_y(1, 0) = 255− 153 = 102, B_y(1, 0) = 153 − 153 = 0\]</span><br />故<span class="math inline">\(\Delta_y^2(1, 0) = 102^2 =10404\)</span>，所以(1, 0)位置的能量就是<spanclass="math inline">\(41616 + 10404 = 52020\)</span>。<br />接口也很简单<code>public  double energy(int x, int y)</code>。 - FindVertical Seam<br />这个接口设计为<code>public int[] findVerticalSeam()</code>，返回的数组有H个值，第i个值对应要移除的第i行的列号。<br />要找这样一条最短路径，我们考虑用动态规划求解：<br />首先定义子问题<span class="math inline">\(M(i,j)\)</span>表示以<spanclass="math inline">\((i,j)\)</span>结尾的最短路径的成本，用<spanclass="math inline">\(e(i,j)\)</span>表示位置<spanclass="math inline">\((i,j)\)</span>的能量；<br />接着寻找状态转移方程：由于路径的左右位置绝对值不大于1，所以<spanclass="math inline">\(M(i,j)=e(i,j)+min\{M(i-1,j-1),M(i,j-1),M(i+1,j-1)\}\)</span>；<br />最后确定base case：每行的值都由上一行确定，所以base case就是<spanclass="math inline">\(M(i,0)=e(i,0)\)</span>。<br />最终结果就是在最后一行找到<spanclass="math inline">\(M\)</span>最小的像素点，逐行向上寻找三个相邻格子中<spanclass="math inline">\(M\)</span>较小的那个。 - Find HorizontalSeam<br />对于水平方向的seam，当然也可以用动态规划求解。但是为了避免代码冗余，我们考虑利用<code>findVerticalSeam()</code>：先将图像转置，然后调用<code>findVerticalSeam()</code>，最后再将其转置即可。<br />具体的：考虑如下3*2图像：<br /><img src="https://img-blog.csdnimg.cn/20200708090038977.png"alt="在这里插入图片描述" /><br />将其转置：<br /><img src="https://img-blog.csdnimg.cn/2020070809031641.png"alt="在这里插入图片描述" /><br />利用<code>findVerticalSeam()</code>得到(0,1,0)即为水平的seam，最后将图像再次转置即可。</p><h2 id="待改进">待改进</h2><ul><li>能量计算<br />每次移除一条seam，都要调用<code>findVerticalSeam()</code>，<code>findVerticalSeam()</code>中会计算所有格子的能量，这样如果我们移除20条seam，就要计算20次所有格子的能量，显然这是可以避免的。<br />最直观的方法就是空间换时间，创建能量矩阵<code>double[][]</code>存储每个格子的能量。</li><li>水平seam<br />转置矩阵耗时<spanclass="math inline">\(O(WH)\)</span>，更快一些的做法是利用一个flag记录当前是在寻找垂直还是水平seam，在计算能量时判断分类。</li></ul><h2 id="reference">Reference</h2><p><a href="https://sp18.datastructur.es/materials/hw/hw5/hw5">HW 5:Seam Carving</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫谈三毛</title>
      <link href="/posts/on-echo/"/>
      <url>/posts/on-echo/</url>
      
        <content type="html"><![CDATA[<p>三毛的书我读的不多，大概只有《撒哈拉的故事》、《梦里花落知多少》和《谈心》。<br />初识三毛，是在《谈心》中她给一个读者的回信：</p><blockquote><p>三毛女士：<br />我今年廿九岁，未婚，是一家报关行最低层的办事员，常常在我下班以后，回到租来的斗室里，面对物质和精神都相当贫乏的人生，觉得活着的价值，十分...对不起，我黯淡的心情，无法用文字来表达。我很自卑，请你告诉我，生命最终的目的何在？<br />以我如此卑微的人（我的容貌太平凡了），工作能力也有限，说不出有什么特别的兴趣，也从来没有异性对我感兴趣。<br />我真羡慕你，恨不得能够活得像你，可惜我不能，请你多写书给我看，丰富我的生命，不然，真不知活着还有什么快乐？<br />敬祝<br />春安！<br />一个不快乐的女孩上</p></blockquote><p>谈及生命的意义，这或许是大多数人都会思考的问题，然而它却不像数学题那样有什么所谓的标准答案，这是一道拥有无数种解法的题目。丝毫不需要掩饰，直至今日我仍然没有完全明晰。<br />是的，人终有一死，一切都会湮灭。生活中的很多事情从人生这一宏观角度来看根本不值一提，广而泛之，其实所有的事情都不值一提。那么生命的意义到底在哪里？不妨先了解下三毛的想法：</p><blockquote><p>不快乐的女孩：<br />从你短短的自我介绍中，看来十分惊心，二十九岁正当年轻，居然一连串的用了——最低层、贫乏、黯淡、自卑、平凡、卑微、能力有限这许多不正确的定义来形容自己。<br />以我个人的经验来说，我也反复思索过许多次，生命的意义和最终目的到底是什么，目前我的答案却只有一个，很简单的一个，那便是“<strong>寻求真正的自由</strong>”，然后<strong>享受生命</strong>。<br />不快乐的女孩，你的心灵并不自由，对不对？当然，我也没有做到绝对的超越，可是如你信中所写的那些字句，我已不再用在自己身上了，虽然我们比较起来是差不多的。<br />如果我是你，第一步要做的事是加重对自我的期许与看重，将信中那一串又一串自卑的字句从生命中一把扫除，再也不轻看自己。<br />你有一个正当的职业，租得起一间房间，容貌不差，懂得在上下班之余更进一步探索生命的意义，这都是很优美的事情，为何觉得自己卑微呢？你觉得卑微是因为没有用自己的主观眼光观看自己，而用了社会一般的功利主义的眼光，这是十分遗憾的。<br />一个不欣赏自己的人，是难以快乐的。<br />当然，由你的来信中，很容易想见你部分的心情，你表达的能力并不弱，由你的文字中，明明白白可以看见一个都市单身女子对于生命的无可奈何与悲哀，这种无可奈何，并不浮浅，是值得看重的。<br />很实际的来说，不谈空幻的方法，如果我住在你所谓的“斗室”里，如果是我，第一件会做的事情，就是布置我的房间。我会将房间粉刷成明朗的白色，给自己在窗上做上一幅美丽的窗帘，我在床头放一个普通的小收音机，在墙角做一个书架，给灯泡换一个温暖而温馨的灯罩，然后，我要去花市，仔细的挑几盆看了悦目的盆景，放在我的窗口。如果仍有余钱，我会去买几张名画的复制品——海报似的那种，将它挂在墙上……这么弄一下，以我的估价，是不会超过四千台币的，当然除了那架收音机之外，一切自己动手做，就省去了工匠费用，而且生活会有趣得多。<br />房间布置得美丽，是享受生命改变心情的第一步，在我来说，它不再是斗室了。然后，当我发薪水的时候——如果我是你，我要给自己用极少的钱，去买一件美丽又实用的衣服。如果我觉得心情不够开朗，我很可能去一家美发店，花一百台币修剪一下终年不变的发型，换一个样子，给自己耳目一新的快乐。我会在又发薪水的下一个月，为自己挑几样淡色的化妆品，或者再买一双新鞋。当然，薪水仍然是每个月会领的，下班后也有四五小时的空闲，那时候，我可能去青年会报名学学语文、插花或者其他感兴趣的课程，不要有压力的每周夜间上两次课，是改换环境又充实自己的另一个方式。<br />你看，如果我是你，我慢慢的在变了。<br />我去上上课，也许可能交到一些朋友，我的小房间既然那么美丽，那么也许偶尔可以请朋友来坐坐，谈谈各自的生活和梦想。<br />慢慢的，我不再那么自卑了，我勇于接触善良而有品德的人群（这种人在社会上仍有许多许多），我会发觉，原来大家都很平凡——可是优美，正如自己一样。我更会发觉，原来一个美丽的生活，并不需要太多的金钱便可以达到。我也不再计较异性对我感不感兴趣，因为我自己的生活一点一点的丰富起来，自得其乐都来不及，还想那么多吗？<br />如果我是你，我会不再等三毛出新书，我自己写札记，写给自己欣赏，我慢慢的会发觉，我自己写的东西也有风格和趣味，我真是一个可爱的女人。<br />不快乐的女孩子，请你要行动呀！不要依赖他人给你快乐。你先去将房间布置起来，勉强自己去做，会发觉事情没有你想象的那么难，而且，兴趣是可以寻求的，东试试西试试，只要心中认定喜欢的，便去培养它，成为下班之后的消遣。<br />可是，我仍觉得，<strong>在这个世界上，最深的快乐，是帮助他人，而不只是在自我的世界里享受</strong>——当然，享受自我的生命也是很重要的。你先将自己假想为他人，帮助自己建立起信心，下决心改变一下目前的生活方式，把自己弄得活泼起来，不要任凭生命再做赔本的流逝和伤感，起码你得试一下，尽力的去试一下，好不好？<br />享受生命的方法很多很多，问题是你一定要有行动，空想是不行的。下次给我写信的时候，署名快乐的女孩，将那个“不”字删掉了好吗？<br />你的朋友三毛上</p></blockquote><p>这篇回信给我最深印象的，就是<strong>在这个世界上，最深的快乐，是帮助他人，而不只是在自我的世界里享受</strong>。实话实说，我并没有那么高尚的境界，甚至以前很少想到这一层。不过非常幸运的是：关于寻求自由与享受生命，我与三毛达成了一致。有了思想的指导，方法自然不会成为障碍，信中提到的做法会带来改变。<br />好久前看过李健的一个访谈，他说在任何时代，自我价值的实现都是很重要的，过好自己的生活，成为生活的艺术家是最难的事情，但他一直在尝试。经常性地关注村上等人的生活状态，极度追求个人自由与价值的实现，但是忽视了thebig picture。当然村上自从《地下》以后，改变了很多。<br />这些对我个人价值观的塑造都有很大的影响（大概就是读书的好处吧），所以我一度认为生命没有意义，你做的一切，或者说人类做的一切，都没有意义。那么为什么还要去做事呢？是因为总得有事情去填充我们的时间。做好当下的事或者虚度时光，结果是迥然不同的，将来回忆起来很多事没有体验，岂不肠子都悔青了？<br />真理总是很早就学过，却很晚才明白：</p><blockquote><p>人最宝贵的是生命，生命对于每个人只有一次，这仅有的一次应当怎样度过？<br />每当回忆往事的时候，不因虚度年华而悔恨，不因碌碌无为而羞耻。</p></blockquote><p>前面说过，这是一道有着无数种解法的题目。每个个体想做的事很多，不过共同之处在于：doit，千万不要因为畏惧而放弃、拖延，当下只有一次，永不会再来。在认真体验、洒脱生活、享受酸甜苦辣的同时，记得帮助别人。<br />戏剧之处在于：如果读者只看过《撒哈拉的故事》，没人会接受三毛最终的选择。物质生活那样贫瘠的非洲，再加上常年患病的身体，都没有击垮她。相反，她将平凡的日子过得如诗一般，幸福早已溢出了文字，哪怕结婚用香菜代替鲜花她也津津乐道。就是这样一个善良自由、追求自我实现的人，荷西的死却成为她生命中无可挽回的拐点，也许浪漫的人很难有好的生活。再去看《梦里花落知多少》，你可能无法相信这出自同一个作家之手。<br />痛失挚爱，无异于晴天霹雳，但我想大多数人都会渐渐走出这份悲伤，只是时间长短不同罢了。感性的人很难自拔，会沉醉过去，也会幻想梦境：</p><blockquote><p>记得当时年纪小<br />你爱谈天<br />我爱笑<br />有一回并肩坐在桃树下<br />风在林梢鸟儿在叫<br />我们不知怎样睡着了<br />梦里花落知多少</p></blockquote><p>那种语调，并不是刻意地悲痛，好似一切都变淡了，当然也包括生死，三毛不断提醒自己要有责任心，还要照顾父母，如此目的很难维持得下去。<br />我们慨叹命运弄人，每一丝幸福，都可能是若干年后的一场悲剧，因为开始就会有结束。而且快乐往往是短暂的，就像它的字面意思一样，平淡和普通才是人生的主旋律。</p><hr /><ul class="task-list"><li><label><inputtype="checkbox" />不知怎么搞的，可能读书越来越少、手机越玩越多的缘故，也可能书单过于单一，总是看些小说滥竽充数，写一些人文类blog总是力不从心：不论是行文思路，还是写作手法，直到最后的自我表达都十分混乱，而且遣词造句多有贫瘠累赘之感，甚至还不如小时候来得自然和丰富。别无他法，只有大量阅读思考才可能改观，希望每天都能静下来读会书吧，先看看中国现代文学@-@</label></li></ul>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Garbage Collection</title>
      <link href="/posts/garbage-collection/"/>
      <url>/posts/garbage-collection/</url>
      
        <content type="html"><![CDATA[<p>垃圾回收：为了防止内存泄漏，对<strong>堆</strong>中死亡的对象进行清除，并回收相应空间的机制。<br />某些有GC机制的语言(Java,Python...)，平时不会特别在意内存的分配和释放。但是对于C/C++等语言来说，稍有不慎就会造成MemoryLeak/Double Frees/Use-after-frees等问题。</p><h2 id="garbage">Garbage</h2><p>垃圾顾名思义就是以后不再使用的对象。但是要确定一个对象是垃圾通常很难，所以我们认为不可达（没有被引用）对象就是垃圾，但是需要明确的是：许多可达对象也不再会使用，也是垃圾，但是这种垃圾我们无法回收，所以即使拥有GC机制的语言也很容易造成内存泄漏。</p><h2 id="reference-counting">Reference Counting</h2><p>C++的<code>shared_ptr</code>主要采用引用计数法，实现简单：<br />每个对象都与一个引用计数器<code>cnt</code>相关联，每当有一个引用指向该对象，<code>++cnt</code>；一个引用失效时，<code>--cnt</code>。当<code>cnt==0</code>时：Removeall outgoing references from that object，并且清理该对象。</p><p>由于每个<code>cnt</code>记录的是引用数，而不是可达的引用数，只关注自己的对象而没有全局的信息，<strong>循环引用</strong>的情况就无法被回收：<br /><img src="https://img-blog.csdnimg.cn/20200705104719124.png"alt="在这里插入图片描述" /></p><h2 id="mark-sweep">Mark-Sweep</h2><p>Lua/Ruby等主要采用Mark-Sweep算法：<br />有一些位置是明确知道可达的：全局变量、栈中的变量以及寄存器中的变量等，这些区域作为rootset，从rootset出发可达的对象视为存活对象，不可达对象视为待回收对象。</p><ul><li>mark阶段目标是找到可达对象。<br />-- 将root set中的对象放入worklist；<br />-- 当worklist不空：<br />从worklist中移除一个对象；<br />如果该对象没有标记，标记它并且把从它出发的所有可达对象加入worklist。</li><li>sweep阶段目标是回收死亡对象。<br />-- 对于<strong>所有已经分配的对象</strong>：<br />如果未标记，释放；<br />如果已经标记，为了下一次的GC，unmark。</li></ul><p>有时候确实很难想象如此简洁的设计竟然是Lua5.0之前采用的机制，不过工程上一条重要的原则就是：<strong>先完成、再完善</strong>。这个比较简单的GC实现过程可以参考<ahref="http://it.deepinmind.com/gc/2014/03/26/babys-first-garbage-collector.html">自己动手写GC</a>。<br />这种Naive的方式虽然简洁，但是却有很大的缺点：即mark和sweep阶段必须一口气执行完毕，不能分步骤进行，结果就是在进行GC时其他线程都必须挂起，也就是通常说的StopThe World。<br />原因在于：假如在mark完成后，新创建了若干对象，这些对象显然没有被标记，在本次的sweep阶段就会被清除，造成无法挽回的后果。</p><p>为了改进上述算法的时间和空间性能，Baker's algorithm应运而生：<br />每个分配的内存块只能属于四种状态之一：Marked(可达)/Enqueued(in theworklist)/Unknown(未处理)/Deallocated(已释放)，维护4个双向链表保存4个状态的对象。</p><ul><li>将root set中的所有对象移入enqueued链表；</li><li>当enqueued链表不空：<br />-- 将enqueued链表的对象移入marked链表；<br />-- 对于unknown链表中的被引用对象，移入enqueued链表。</li><li>合并unknown链表和Deallocated链表并释放，耗时<spanclass="math inline">\(O(1)\)</span>；</li><li>将marked链表中的所有对象移入unknown链表，耗时<spanclass="math inline">\(O(1)\)</span>。</li></ul><p>这样时间复杂度优化为runs in time proportional to the number ofreachable objects.</p><h2 id="generational-gc">Generational GC</h2><p>分代收集的核心思想是将内存划分为若干代，每次新的对象总是被分在新生代，新生代没有空间时，做一次迅速的GC，之后将新生代中剩余的对象移入nextgeneration，实在没有空间可用时，对整个内存进行一次GC。<br />Java的GC就是基于这种算法，新生代分为Eden和Survivor：<br /><img src="https://img-blog.csdnimg.cn/20200705145530733.png"alt="在这里插入图片描述" /><br />开始的分配都在eden中，满了之后做一次GC，将留下的对象移入survivor浅色区，具体过程可以参考文献中的200页。</p><h2 id="具体应用">具体应用</h2><ol type="1"><li>Python的GC主要结合了引用计数和分代回收2种策略，当对象的引用计数为0时立即回收该对象，如果出现循环引用，则等待分代回收算法清理该对象。</li></ol><h2 id="reference">Reference</h2><p><ahref="http://web.stanford.edu/class/archive/cs/cs143/cs143.1128/lectures/18/Slides18.pdf">GarbageCollection</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Annotated STL Sources</title>
      <link href="/posts/the-annotated-stl-sources/"/>
      <url>/posts/the-annotated-stl-sources/</url>
      
        <content type="html"><![CDATA[<h2 id="intro">Intro</h2><p>《STL源码剖析》用来了解原理性的设计没什么问题，但是这本书实在太老，所有源码基于GNU2.9；现在语言的发展飞快，而且很多地方都是考虑兼容性等因素，设计非常复杂，也并不高效，我没有时间去搞明白所有实现，更没有时间实现标准库，所以只学了一小半就停了。</p><h2 id="六大组件">六大组件</h2><p>容器、算法、分配器、迭代器、适配器、仿函数。<br /><img src="https://img-blog.csdnimg.cn/20200423140448163.png"alt="在这里插入图片描述" /></p><h2 id="allocator">Allocator</h2><p>分配器用来为容器分配内存，分配器是class，有成员函数<code>allocate</code><code>deallocate</code>，调用<code>operator new()</code>会调用<code>malloc</code>，<code>operator delete()</code>调用<code>free</code>。<br />不同编译器的分配器实现稍有区别，不建议直接使用allocators，<code>int* p = allocator&lt;int&gt;().allocate(512)</code>会创建临时对象，归还还要指定大小：<code>allocator&lt;int&gt;().deallocate(p, 512)</code>。<br />但<code>malloc</code>归还时不需要指定大小，因为<code>malloc</code>时候会有<strong>cookie</strong>保存分配的内存块大小，如果每次申请内存都包含cookie的话，开销太大，并且频繁申请内存十分耗时。<br />GNU2.9觉得allocators太傻逼，自己用的是alloc的分配器，有16个单链表，每个链表负责某个特定大小的内存块分配，比如8B（该链表串了很多8B的小内存块），16B，...，容器需要内存会被调整到8的倍数，去相应的链表找，如果链表没有小块内存，就会调用<code>malloc</code>向OS申请一块大的，切成很多小的，串起来去分配，这样<code>malloc</code>次数会变小很多，而且cookie会少很多，时间和空间开销都会变小，碎片也少了。<br />GNU4.9没有使用alloc，使用<code>std::allocator</code>，allocator继承了new_allocator，有成员函数<code>allocate</code><code>deallocate</code>，调用<code>operator new()</code>会调用<code>malloc</code>，<code>operator delete()</code>调用<code>free</code>，一夜回到解放前。。。<br />4.9有很多扩展的分配器，2.9里的alloc变为了_pool_alloc，要改变默认的分配器，可以写<code>vector&lt;string, __gnu_cxx::_pool_alloc&lt;string&gt;&gt; vec</code>。</p><h2 id="list">list</h2><p>双向环状链表，end指向一个dummy node。<br />因为非连续，所以<code>++iterator</code>要重新设计，使得指向下一个元素，而不是错误的地址。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev; <span class="comment">// 4.9 struct __list_node* prev</span></span><br><span class="line">    void_pointer next; <span class="comment">// 4.9 struct __list_node* next</span></span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="comment">// 5种associated types</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">// 4.9 typedef T* pointer</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref reference; <span class="comment">// 4.9 typedef T&amp; reference</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    link_type node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 操作符重载 */</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    <span class="comment">// 前置++</span></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        node = (link_type)((*node).next); <span class="comment">// 指向下一个结点</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置++</span></span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>; <span class="comment">// 记录原值，拷贝构造</span></span><br><span class="line">        ++* <span class="keyword">this</span>; <span class="comment">// 操作</span></span><br><span class="line">        <span class="keyword">return</span> tmp; <span class="comment">// 返回原值</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line">    <span class="comment">// typedef __List_iterator&lt;_Tp&gt; iterator; 4.9模板参数只有一个</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="vector">vector</h2><p>1.5/2倍增长。<br />迭代器只是一个指针，而不是class iterator，通过萃取机（IteratorTraits）中对类型的偏特化处理，可以回答算法提出的问题（iterator_category,value_type,difference_type,pointer,reference）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>)); <span class="comment">// 建立一个元素，并以最后一个元素作为初值</span></span><br><span class="line">        ++finish;</span><br><span class="line">        T x_copy = x;</span><br><span class="line">        <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">        *position = x_copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        iterator new_start = data_alloctor::<span class="built_in">allocate</span>(len);</span><br><span class="line">        iterator new_finish = new_start;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将原vector内容拷贝到新vector</span></span><br><span class="line">            new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">            <span class="built_in">construct</span>(new_finish, x); <span class="comment">// 新元素设为x</span></span><br><span class="line">            ++new_finish;</span><br><span class="line">            <span class="comment">// 拷贝插入点后的元素，可能被insert调用</span></span><br><span class="line">            new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">            <span class="comment">// commit or rollback</span></span><br><span class="line">            <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); <span class="comment">// 析构释放原vector</span></span><br><span class="line">        <span class="built_in">deallocate</span>();</span><br><span class="line">        <span class="comment">// 调整迭代器指向新的vector</span></span><br><span class="line">        start = new_start;</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator; <span class="comment">// T*, just a pointer, not a class iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    iterator end_of_storage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">            <span class="built_in">construct</span>(finish, x);</span><br><span class="line">            ++finish;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="deque">deque</h2><p><img src="https://img-blog.csdnimg.cn/20200424213635414.png"alt="在这里插入图片描述" /><br />The data is stored by chunks of fixed size vector, which are pointeredby a <code>map</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">    T* cur;</span><br><span class="line">    T* first;</span><br><span class="line">    T* last;</span><br><span class="line">    map_pointer node;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="comment">// BufSiz == 0表示使用默认值</span></span><br><span class="line">    <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line">class deque &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="comment">// BufSiz指每个buffer大小</span></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer; <span class="comment">// T**</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    map_pointer map;</span><br><span class="line">    size_type map_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">        <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> *tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">            <span class="built_in">push_front</span>(x);</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(x);</span><br><span class="line">            iterator tmp = finish;</span><br><span class="line">            --tmp;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cycling Summary</title>
      <link href="/posts/cycling-summary/"/>
      <url>/posts/cycling-summary/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="74966f88da0b1ad9880e60355ddb0e047d3bd247e05de9beb4d4011507e4c7c0">418fac4f173397084caccc18ab9f089ed4cc3b41a07fb777d9ddd6d7c594ab8006d22591efcd33984d37648dc6a70cbb9b06b6688388bee76945558f8e9bedb0fccc07b7f7589d74e3762391f559e58d77280f7235d29c87910ac416b8eeb4dbbf37b5223c812bff46aa60a7fcde7ea843a689d48e0d1ab9f7c05534beab1c7ba7cbacc6f5e30230ad2bf71e0dbec4926ddbe109e84ff2c0f7a874949231671afc4597fd549081fbfde54481babc0660342e297cef0f40dd5a38ead508c52a5671c87a44a4b88656e5ec82e6dea19700041465aefd40accdf24e831a630181fd33046b8c7adccbf97ffa5d061c402ce7c24f574c3eaca8d1bcb5371905d3fe0f54512963348d6a0d9bb8e93a0cce5c3a88a6000e1cafdde71bb37bd78e538c625f57e8634e8008eaca3d1fdfdcf3422d68c908bd193207ef554448b5cb1daca5e1683916330d60ae61d17bffcb1ec00db1884b17b617f22f2aa76f15dfeccdcd4ad23d76835278951e2289086460265b5ec8dd64e88301fdabe0e3c7ad703b008d7bd4439f7a6151e12bdebd7da1d4b4f8daf048515202848a0e91c4d5e539c6a5462b5388a820654364bb8a0213a56c719c9eca5404aeaee4ed7cc3ec9c579add10c3344b68d00dbbfffdd50a0753e95bb3154adff028cdcb08e9f6afc3b58ec6029964a2cbe9b3920a5f2ffd2b03d8bd4a278e9a06448fec867179c5633de429859428959e24d77be2a67a8a7d066e026d951b74cf38524594e3500666200eb68abb6e4ee10af94aa73d64f0f611bf55a04de769ec20832f5f6b4a3fb1ab182082807fde0ab6617addfb81c9fcab07e434622937223a8e09facc31bc374c533b8af04d9c9b5a3a808d2ac06952b6391f4dba590a34419bf728da966cde647a09f74177a438ff4789cc9d6273e25f199ee81a7d47a8d50091fd22c4c72e9ee9d7ff01325c99717db247532dbb505915a2e1b6507e529d464b4d2ef95698d311be977d3c4ff97f826afb4d75f1b8d72cdf42f555fc9a992818b46e1ec554e302a9fcdad75a4dca04c55567982df1e2709288aa91976aef822f67941165918d8be7f8c9f137a65ded3341b0951680c94caa6ac025ed417c2b82186c4a0693a6d40bb3d65b1f173100b6f710dafdf8082bdbf008941398b883423090bfeac2d2c4fd1bfefa499c38ba9880749976a678ff74333bc5977b5e0f66b76cfbe1c87ae97849f924758a22f8cb0a11379cadf3a9204dc3464d8554faecc73f98aaab5df29dc6ae69f8cabe446154db371bfe4ee929073a082350104abce32c1a09be9a281c77d409e4c993a2411f596e420f1e1b4b8aa8b294b8487007fa606022f0985cfe4c254c27201c0885e911fbc6ec56143f3634ecd5a7d0977c3e29d7807c45ad999abe3f9a04ad3e423c668ba7affccdaf8612e9ad0de01bdaa2b264cc9edce3fde4311b33f3a733a9fb41735ba3aecf152c31f93dde0c59b900c417981345bea4eb57ff5bf88d416e1c9f7e79bdbe100c29d4027012df4a61df4910c0b539e2a29158baa48e45c1154470132504631bfa8e1c80e8b4ed03e5b3053253138a7b7fa0869a1a0f5c96df1126a962c13017562c1cd2aa3e7a61b065f3c0a82aef4776807bbd863569db6ae5d78b393b34ff625bf675e092feef2e5aee4ebcc483dfacf3a44d3038e3144c8acd5a2660cb284c5e75117497ac2b9e0c1c3ce240f9f92200b3a3cd847e130db296a0993223932caf451b6deeacdc9683cd27bf2b9a509ec1eae446183af310ce83436c377ce2e302e373dd4519985e840fc2cc86dcd4501b4ab979ba4d4ae77a5c147277b76441c2b13eb97980be14fd0dbfc5192e4fb4d4ca4a1a1f1fa23a3cdc513c941b285e0c00780f8273bb5bf39577f0d0ba88963676612f0dd2c6bc9c6e1b76eb9d3bb57cb7695cc5fc8a297d2dcb1d1816eca8a697318c0632c7082e4796110b0907c0b8ea0872892b91aac2e8de302d215d3eac5700bd8b482db1e454c8d36f812ef95b30615c7f4578e0de3f98fd2e84380bb945e21a97bbd80086b9c2e33038e5cbb5c766bc18b52ed5ddab4a7ebd9ae958b5803986d5d75f181d7fcda2cfb95457ff3973e3c6d7002123fa210fcecb24ef58d809afd7a275609b83b90b8a8ae460c3eae5ba2c84281fb80a9e35a853113d5ab8006bf519f4d62492ab3f5fc7a9652539f7e85feaccf1acb46d8017214646ea667073f2ae2acc663d1d09cbaeb91fc667e1bfa8a4ea9058d2ee3460c2ad832173ad4d527851390f0b7f39baeda53a53ee91b9995f0b5fe603ddd7e02c026c435565b15e6c6f47f2493539445ec386e507e8666337f173be65a971ac9a068564841c27c885a7fbd39478df04574c9e55fe7d431f4be6e621a70d0a21d0a830344ff251f9a0cfebe0648ec33320ede572f1e1a67962db174fd61c2421938404ea38a4fa3da8c86f3eb21137adbcbe37d4a27d361a7e4afb9d5246dfe07e7cb4c9849a5175d6f9cd9b97c54ae643d5d23ee58a18d2a9352ee723281e95c7565b70b029cc44f29fbddf9bb6a994e67178f6ab9c211c268bc554a386e25320390642834e9f35a3cc93d032c717ff44fe6fef1a72275b49c4ecb067bd272d9360afeafd0914045c3710bfbc7ac6d4b1c54d25ae0acea9e9946b8b76317492959b4be26fcfe25423b73ef69d9f8b9f38ea91efc164867b8b08b930d4a09d06245b4c88854ff65ff7a128699b9815306a5959ebac910819b7636fcef64783328a62ef1b96f37b3f3c4813fbb12401db09de6c1feffeea4e759bb7e8ef887504939f15da3819c7f5834860476316c55d316650ec5f132282af54c8e6f3982b2671789f2e5cbb06023a4e3e6bb84641bd55f0b6bc851c7f62c9e741c8ae4ebbe2cb10745c6cfe6171304144168b3b025c142d0f22ca7ebd481a2bd4b8d11360b8d7cd7e7397d14f03a8ceda355611567e8d9ae268c40047dc751f0eafac734b50f9c86c6d980f7cd4ce2afdcba0f205dc5cfe784f5a70185a1c46008b397d83f8af731e772c1a046aa9351f9e2e038f27f9a914df035bfadab2ffa484925d9a267dff9eb381c6a2933f1231b6004bb0ccf5f97ab0b586060f0e121c4b6ad965d61a471f866d159bfb5432ce86537c86314b1e8cdef853c5ade2020536367000a0c8e659e74948f2be0bba507a120159a7750d399d98e7027d6034e3edb8dc2094b26a10f3af4c5f227886328640fdc2552a180de8428747e3a1af02e41aacb4b9f8dd8835a5d8a73e311cac9fba66f667aaa419416921cfca21b600f68681671de0dd0db6e9153fa99d62448dd1a8523586fb9b58e17dd684ae7ded761d54679070947bf563700600436e517e1985fbb691ec79531274ad0d43f8cf1c3d2214a0534fbc2035b605e1b40b10eb595907146491eb207529b6081f015163e475bdfea9c49e5302445ce37c447197a5d1fd8945191212f5e93406fa57bf4d1737aa96394801bd07209585e49e95b2be907e325b9f00f446a6ef98221d46e024fca8a1d3d838bc7f6d6967653cafc134cdec167ff36414ac8b461ad8825730efb1bddfaffea6e40bf2da24d2a9193514ec154ed5bcd8cb6d053b552d737a1d5142722a413d114cb52a205f6e620ca29634e790def3af350079aa57d65e9af66591f32e5f6a2291ba77831d303e95098f0e1fc753532fc818b356aaaad0fa55d81eac97dd95dca19e220a0a5031447262df76ee3760aff4d3144e891b2f667779eb51cb2cf0b0c06667c74357dc9b40308aab3a5472dca5692a74b65d7f0ebf9d3e348872decc717bc3029f0b87d5d56319f4043f97cb23b0544ab572f1cb3ae2dcde71ecd5e0e9933407021031618ef949761615f8926052e4907f4f048d14149db6ccbe3a5b32cc5b2a6066aeeeea7714c312ff785cd21810a3cdb97c9037af7215c00755abff035ba1c6338bcb7f3d380fa55517115e2fcd761d1a233a588da5a473d58ba46cc1317dbd6037fcc378dc715b3b9d07abbbd37a9d75f81b807ee0e6ebebc4d694183831cdcb79603b15e1627e45ea9c6b51c347a87fd3e048465424d7d542b401b58ce4ac20e41350b9ba1e4fdae654880c123a5d72e9bf8096266439826255499030770bf0411e5b77330ad8575a69beae7e98b1d56db233077ea7016d4a5828a001418969ff6e99d907b9b6d4aebfbb019161f2122735db393d4b99022fe0fc2c73f783d927e02e53f79caa614b1104c9aff277412f098f2ae29db1f8ddba356e42a67614143bdf1ee653553a95f7319f0f6cf806f90107b82cd58e5a45cb63d8898bd386e4ca0d795ae6c98e96a1967e750acf9002b8d0ef0effa4706ba496e41a05d6122f1f0364df0030f2830b3a4beaa4eb9e60dd75c2f70d23b737ecfc1bc3d5b67b5b8aadde5e42a0d9c8951b4c404d8bd0f1073f22e5abc1cff0b9abbaf974a2a6b3b71f02b7093c50dcac7537aad59e8d7f3eadfa403da28dd5f3831d73ffb86ccd9c32c8583d1406d5463297eff6d1a200a72dde40466b75b667d5e2bca0d6262b50b029b7f477ca7669fce925c12b989b03520385dad6f345ee5dbea4136936d862ce11c35b7211efb3f069111ee7df581c10ccdda63f9ba0337ba1f1a009c2f832429fa3dab4cb8f391af7cc5279cc094b91dde483f4e2e612b1046297683555cbff8debc052821974a2a10d7f0ba4acd8a84426e29e66a839cc2da0e6a66e1f2e434ebd64d9ed4d5fac6d3770f4553f5e232e8e9a92f288ce9c6f81f336e609d02e38c479eb3048add85fccd9cef3c242a2d16ad2da1a9e033f376a44c58530baccd24033891c6b0a298c833f34a498700f6825fde0d78c0ac2b7c2fc27111999c683f1cead37f3e3501b0f5c86513a78381714395fdfdd4adeda701ac660fa0848dac318c74ffcb831433478631ac42d2aee7304b1c06fe15f600d19d47d88e3119406dca92200b20122a76d04d729ef07037933b6da701a95df5599dac594422b0da15244b96d1ae9dc2cd0cd79bd7d1cb4c80c58a367ce8762d627aee0c56723ff1d45b24d092f7935345f2e9312fd26a1d7660d44443b5ca65169ac1fb9628edb9f0f9cec9d5815bbb1552402e91c224d6813c42cc43779854b573607add70ebcc3f6e94e5bfaafccf932dbd5231fa615d54754a133df35eb98a24b3ec0c5f391cf868172237153e814448802429b8893972e64662fe6244479f63486f2c939931df89e6f474da6e0bc21e42c730daee8a4fd6dc79f8c7de6bac597bd3ad8362d02fe4921b6ca7df27721386b4d12521dc7ffd67593fdbff2a491ce9bef14520302e39ed1ab356efa905140741cc1dab2e76bcfcb6f411bc387e14c4c4f16458dc2a0c5569b7babaf9e120bf688739cb0e2a5f417131a3724366b0429aa82b4ff15dbbc98db082d25e21f03f4028d5fb5817c2c95e8228e6dd2f92291de73a50b2bfc0657330821c02dda474c334fff7557fdedc1969faa1d4c88dd722581772ff95b7cf736fd15c128b941ca539df9a819e6ee4cf165994bbaa6e6c1516416b7a4b9f937960764822795e2fc5f96aa59022ed16460f43c208d69225019d32c69495071f8f3443e750fac8d7050f89996c3628c878f1707575ad8401f6bbd5bb9bf67cd0173c93ee1cea27db70d5c74a87e534f8e765a6f47de1a73f4bd605f8fbe9d8d5f0b03f8f07ecfa846c5304cb2089e50e27e2c7c671f8b159a068bfa09e31f14500f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Percolation</title>
      <link href="/posts/percolation/"/>
      <url>/posts/percolation/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>这是CS 61B的HW2，具体实现<ahref="https://github.com/EIMadrigal/CS61B/tree/master/hw2">在这里</a>。这个项目是要模拟一个渗滤系统，最终目标是要通过蒙特卡洛方法计算出渗滤系统的阈值，主要会考察对并查集的使用而非实现。<br />渗滤有很多应用，比较重要的就是复合导电材料：刚开始是绝缘体，将金属作为导电材料逐渐掺入，填充到某临界值后，金属会形成一条导电网格组成的路径，完成从绝缘体到半导体、导体的转变，该临界值就是所谓的<strong>渗滤阈值</strong>。<br />模型是一个<spanclass="math inline">\(N*N\)</span>的网格图，每个格子有打开和关闭两种状态。如果一个格子是打开的，并且可以通过相邻的某些打开的格子连接到第一行的打开格子，那么该格子的状态就是full。如果最后一行有格子是full，那么系统就会发生渗滤。对于前面的例子，如果金属材料能形成一条从上到下的导电路径，那么就发生渗滤：<br /><img src="https://img-blog.csdnimg.cn/2020061309400433.png" /><br />我们感兴趣的是：如果<spanclass="math inline">\(N\)</span>足够大，每个格子独立，并且打开的概率是<spanclass="math inline">\(p\)</span>，那么会存在一个阈值<spanclass="math inline">\(p^*\)</span>，当<spanclass="math inline">\(p&lt;p^*\)</span>时，系统几乎不可能发生渗滤；当<spanclass="math inline">\(p&gt;p^*\)</span>时，系统几乎一定发生渗滤：<br /><img src="https://img-blog.csdnimg.cn/20200613094728545.png"alt="在这里插入图片描述" /><imgsrc="https://img-blog.csdnimg.cn/20200613094740884.png"alt="在这里插入图片描述" /><br />我们的任务就是估算这个<span class="math inline">\(p^*\)</span>。</p><h2 id="渗滤系统建模">渗滤系统建模</h2><p>模型并不复杂，写一个类<code>Percolation.java</code>专门模拟该系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percolation</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Percolation</span><span class="params">(<span class="keyword">int</span> N)</span>  <span class="comment">// create N-by-N grid, with all sites initially blocked</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span>  <span class="comment">// open the site (row, col) if it is not open already</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span>  <span class="comment">// is the site (row, col) open?</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span>  <span class="comment">// is the site (row, col) full?</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfOpenSites</span><span class="params">()</span>  <span class="comment">// number of open sites</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">percolates</span><span class="params">()</span>  <span class="comment">// does the system percolate?</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>难点在于要满足规定的时间复杂度：除了构造函数是<spanclass="math inline">\(O(N^2)\)</span>，其余方法都必须是<spanclass="math inline">\(O(1)\)</span>。<br />如果采用常规方法判断是否渗滤，那么至少也要遍历最后一行看看有没有full的格子，这样时间<spanclass="math inline">\(O(N)\)</span>无法满足要求。<br />问题就在于第一行和最后一行的格子数太多，减慢了我们的判断效率。那么如果我们在最上面和最下面设置两个虚拟节点，事情就会变得OK：<br /><img src="https://img-blog.csdnimg.cn/20200613110636913.png"alt="在这里插入图片描述" /><br />virtualTop负责连接第一行所有打开的结点，virtualBottom负责连接最后一行所有打开的结点，这样我们就把<spanclass="math inline">\(N\)</span>个点浓缩成了一个点：</p><ul><li>判断某点是否full时，只需要判断该点是否和virtualTop连接；</li><li>判断是否渗滤时，只要判断virtualTop和virtualBottom是否连接。</li></ul><p>这种解决方案看似很完美，但是有一个问题Backwash：<br /><img src="https://img-blog.csdnimg.cn/20200613111558820.png"alt="在这里插入图片描述" /><br />如果已经有一条从上到下的路，那么水流可以通过virtualBottom回流到最后一行已经打开的格子，而这些格子本不应该full。<br />这个问题的解决有点tricky，开始我是想通过周围格子的状态来判断是否full，即只有周围四个格子之一是full，当前格子才是full。但是如果要在<code>isFull()</code>里递归调用去判断周围格子，那么一定会爆栈；所以要判断周围格子只能通过是否和virtualTop连接，但是只要这个打开的格子在最后一行，就一定要和virtualBottom连接，如此一来只要有其他通路，那么该格子必然还是backwash，进而就会导致其它和该格子相连的也backwash。<br />举例来说：假如右边3个蓝色格子从上至下编号123，先打开3号，3号周围四个格子都没有和virtualTop连接，因此我们认为3号没有full，这没问题；但是接着打开2号，2号下面的格子（3号在最后一行且打开，必然和virtualBottom连接，即也和virtualTop连接）是和virtualTop连接的，因此我们判断2号是full，这显然错误。</p><p>没法用逻辑优化的时候，就应该转向用空间去优化。我们可以在开一个并查集，这个集合最多只包含virtualTop和地图中的所有格子，而将virtualBottom排除在外。判断full时，只要当前格子在新并查集中与virtualTop连接，那么必然full。</p><h2 id="monte-carlo-simulation">Monte Carlo Simulation</h2><p>为了估算阈值，需要做<spanclass="math inline">\(T\)</span>次独立重复实验：</p><ul><li>所有格子都设置为关闭；</li><li>随机选取一个关闭的格子，打开它，重复直至系统渗滤。</li></ul><p>那么这次试验的<spanclass="math inline">\(p^*\)</span>就是打开格子数/总数。</p><p>取<spanclass="math inline">\(T\)</span>次实验的平均值，可以得到更加精确的阈值；标准差<spanclass="math inline">\(\sigma\)</span>展示了结果的波动程度： <spanclass="math display">\[\mu = \frac{x_1 + x_2 + … + x_T}{T},\sigma^2 = \frac{(x_1 - \mu)^2 +(x_2 - \mu)^2 + … + (x_T - \mu)^2}{T-1}\]</span> 当<span class="math inline">\(T\)</span>足够大，<spanclass="math inline">\([\mu - \frac{1.96\sigma}{\sqrt{T}}, \mu +\frac{1.96\sigma}{\sqrt{T}}]\)</span>提供了95%的置信度。</p><p>这部分的实现很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercolationStats</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PercolationStats</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> T, PercolationFactory pf)</span>  <span class="comment">// perform T independent experiments on an N-by-N grid</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mean</span><span class="params">()</span>  <span class="comment">// sample mean of percolation threshold</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">stddev</span><span class="params">()</span>  <span class="comment">// sample standard deviation of percolation threshold</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceLow</span><span class="params">()</span>  <span class="comment">// low endpoint of 95% confidence interval</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceHigh</span><span class="params">()</span>  <span class="comment">// high endpoint of 95% confidence interval</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>痛撞南墙才回头---高考五年记</title>
      <link href="/posts/thoughts-over-five-years/"/>
      <url>/posts/thoughts-over-five-years/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">0 前言</h2><p>距离2015年高考已经过去了整整5年，这段日子埋藏着太多不堪。尽管现如今我已经开始了全新的生活，但仍想把自己曾经的问题和思考展示出来，一来当作对过去的告别，二来也希望这些教训能给境遇类似的人一些启发。</p><p>这篇文章字字血泪、句句属实，我不想熬制鸡汤或者贩卖焦虑。文中的一些想法都是通过亲身经历、思考、与前辈同学交流得到的，可能不太成熟，欢迎大家批评指正。</p><hr />认真去划决定命运的小船，却不知道未来会漂向哪里。<p align="right">——题记</p><h2 id="高中故事">1 高中故事</h2><p>文章题目虽然是高考五年记，但其实主题与高考并没有多大关系，而且上大学以后，我很少主动提起高考这档子事，只是为了故事完整，就从高中时代讲起。</p><p>高中三年是在一所县城高中，高考压力很小，学习也是波澜不惊。我并没有像传说中那么拼命学习，努力程度连初中都不如。相反，我的高中自在安逸，回想起来让人有些后怕。作为典型的“小县城学霸”，由于比较轻松就能考到前几名，所以我将大把大把的课余时间拿去运动，以至于已经主次不分。</p><p>做题总是很无聊，而我不知道是因为骄傲，还是因为懒散，遇到难题总是放弃思考、看看答案了事，看不懂就去睡觉，每天做些简单题（毫无必要）保持自信。事实上，我隐约知道外面有更大的世界，但却不知道那个世界是什么样子。那时我几乎没有可以追赶的目标（不像初中），这也许是高考失败的一个原因吧。自负、虚荣以及平日的偷懒终于在高三时酿成了苦果，那几次大型模考理综难度激增，跟平时训练完全不是一个套路。理综彻底被完爆的我后来再也没得过第一，化学甚至长期徘徊在及格边缘。看到这，你也许以为我会发奋努力上演逆袭神话，但现实永远是残酷的。实际上我并没有多少改变：该踢球踢球，该偷懒偷懒，甚至在四五月份时我都打算放弃物理，想着随便混几分算了。高考的目标也变得无所谓起来，反正那一直都是挂在墙上终将被戳破的泡沫罢了。到最后我干脆抱着爱考哪考哪的弃疗心态，只希望尽快毕业。</p><p>我之前对于“小县城学霸”这个词一直嗤之以鼻，即使高中物理老师曾经不止一次强调过我们只是一个县城中学。不过当时我觉得学霸就是学霸（现在显然我自己并不是），厉害的人到哪都那么厉害，哪有什么小县城不小县城。不过后来当这类人的思维方式深深影响我的时候，才发现原来老一辈人的说法未必都是错的，“不听老人言，吃亏在眼前”这句古语也并非空穴来风。</p><p>2015年的高考和往年一样平淡无奇，出分后我异常平静（要是没上600该多好，那我就坚持复读了）。我想学物流管理或者工商管理，前者是因为我喜欢看到井井有条的交通运输网，最终将东西错落有致地归位，后者则纯粹是因为高大上。不过很不幸，这些想法并没有得到亲戚父母的支持，他们说那些专业虚无缥缈，毕业后不好找工作。</p><p>信息的闭塞使得我（包括那些已经工作的亲朋）并不了解各个专业的细节以及未来可能的职业轨迹，我甚至搞不清电子信息与计算机之间的关系。<strong>18岁前的我们只知道读书，习以为常的主流价值观就是“努力学习，考高分，上好大学”，在这样主流价值观的裹挟下，很多人相信“一分耕耘，一分收获”，彷佛只要足够拼命学习，一切都会迎刃而解。然而这种简单的线性的思维方式完全是对真实生活的一种片面归纳，强行被灌输的这些价值观念是否契合当代社会真实的发展轨迹，甚至是否正确，都有待商榷。也许当某一天我们突然发现自己的世界观无法解释见识到的种种现象时，才会在深夜里辗转反侧痛哭流涕的同时，试图去打破曾经的桎梏，而人生信条的崩塌和重塑无疑会是极具撕裂感的、漫长的过程。</strong></p><p>此时的我们对社会的认知极度匮乏，高中也完全没有相关的职业指导教育，盲目地填报志愿，这是当时很多人的通病，我也不例外。在西工大三航学院、厦大经济学和西安交大的来回纠结中，最后一天将交大的专业大致按照历年录取分的高低依次填进志愿表，这在现在看来是多么不可思议的一件事，而我，最后就是这么干的。就这样，稀里糊涂地来到了交大电子信息类。</p><h2 id="懵懂时光">2 懵懂时光</h2><p>到大学后，集体住宿搞得我很不适应，晚上总是很晚才睡着，早上起个大早去跑操，结果就是几乎所有早上的课我都一睡而过。那些课程我也着实提不起兴趣，考试总是随缘突击，结果就是期末挂了一门工程制图，那种空间想象能力我差到不可救药。我个人对新环境的适应一直都很慢，所以进入一个崭新的阶段，开始时总是做得十分差劲。</p><p>不过好在我并非一个一成不变的人，于是开始尝试去改变。由于迟迟找不到方向所在，试错的过程持续了将近两年半的时间。选修了一门职业规划的课程，想借此明确未来的打算，弥补这本该是很早前就完成的人生必修课，不过这门课与大学物理一样无趣；参加了数模比赛，虽然得了奖，但除了提升软件安装和论文写作技能以外，并没有什么新奇之处；参加了社团的支教，这是我当时唯一觉得价值非凡的事情，这段经历也对我后来的想法产生了重大影响，可是这并没有从本质上解决我的问题：<strong>我未来到底想干嘛</strong>？辅修了金融学，也不过帮助我提早排除了一个未来可能从事的行业而已；去奶茶店进行所谓的“创业”，半年后店铺出租，我“失业”了；甚至于无聊到搞了一个公众号，想看看自己有没有自媒体运营方面的喜好，最后也是无功而返。</p><p>说来倒也有些矛盾，除了少数大神一直都有明确的方向或者可以兼顾方方面面以外，我们大多普通人，大学里如果一直不停尝试各种方向去试图寻找兴趣，那必然会分散精力，成绩不够好带来的代价就是后期通过更多时间和精力去弥补。可是如果很少尝试，一条道走到黑，那后果也是可想而知。两种决定都会付出代价，只是时间早晚而已。</p><p>我想既然这些都无济于事，就先提高绩点吧。于是从大二下学期直到毕业，我都在认真学习。即使信号与系统、模电数电那些专业课依然没有学懂，但我发现考试与学没学懂关系并没有那么密切，我居然拿到了在大学的第一个100分。欣喜之余，我隐约觉得这里面有什么问题，但是也懒得思考。</p><p><strong>生活就是这么奇妙，收获的成果有时并不与你的付出成正比</strong>。很快我就发现即使我再努力学习，平均分最高也不过89，全系排名好的时候30多，差的时候50多，那时我才初步意识到<strong>人与人的差距有时候不是通过努力就可以弥补的</strong>。</p><p>成绩上不去，我就想试着去开发一下自己的科研禀赋。于是大三寒假我报了ML方向的一个组，不过我压根没有见过报名的那个教授本人，而是被直接分在了一个副教授手下，并进而被分给了他的一个博士。见不到leader本人我完全不觉得惊讶，毕竟IEEEFellow怎么可能去带一个本科生？但令我不能理解的是我明明报的是ML，但平时的工作却完全是网络通信方向，又是讨厌的信号和从未搞懂的相位。看了一个寒假的论文，帮助他们测试实验数据，在组会上讲论文，尽管我还不知道自己想做什么，但却知道自己厌恶什么。随着时间推移，我愈发觉得自己正在南辕北辙，加之实验室不在一个校区，后来也就主动退出了，科研初探随即宣告失败。</p><p>到此为止，能想到的方式我都一一尝试，可是收效甚微。那段时间我时常在球场散步，一圈又一圈，脑子里就想着两个问题：<strong>我到底喜欢做什么？我未来到底要干嘛？</strong></p><p>人生总有想不明白的问题，苦苦思索不得其解，只能先搁置起来。事情在大三下学期出现了转机，我们系开放了两门CS的课：OS和微机原理，加上ACM大佬们的影响，我开始发现计算机课程的乐趣，那是我第一次认认真真、彻彻底底搞懂了一门课，甚至于我竟然乐意废寝忘食去完成课程的Project。正反馈也来得恰到好处，两门课我都拿到了90+的成绩，那时我隐约有了转CS的想法。顺便要纠正一下，很多人误以为通信转CS很容易，事实上除了三四门相同的专业课以外，通信与CS本科期间学习的东西就像是两条平行线，通信转CS和转金融没什么差别。可能是听到太多科班CS大佬的故事，我始终觉得自己与科班出身的差距无异于一条鸿沟，以至于敬畏到忘记自己该学些什么，尽管后来发现事实并非如此，<strong>人有时候总是自己吓唬自己</strong>。</p><p>说到这就难免谈到劝退的话题，生/化/环/材被黑的体无完肤，大家都要去金融/CS，有时候我也会想：作为所谓的名校学生，我们享受了比较优质的教育资源，然而却少有人愿意投身基础科学研究，这才是科技兴盛的基石，过去不久的华为中兴就是典型的正反例。也难怪有人戏谑“中国只有互联网，没有计算机科学”，我们的互联网公司都在模仿美帝，腾讯学习ICQ，百度学习Google，阿里学习eBay，可是我们却没有看到美帝不仅有这些应用层的公司，还有Intel，Apple，Qualcomm等一大批芯片硬件厂商作为基石，而我们的BAT又有谁做基石呢？一股脑转去高薪行业，这会不会有些太过自私了呢？曾经的理想主义色彩淡薄了许多，我是否也变成了所谓的“精致的利己主义者”，而忽略了对社会的那份责任？但转念又一想，如果一个社会逼得许多人转去金融/CS，那是不是这个社会本身出现了问题呢？遇到一些不顺心的事，千万不要想不开，很多时候不是你的问题，而是整个社会的运行机制出现了偏差。</p><p>由此也可以看出：<strong>世俗意义上的成功更重要的决定因素是历史的进程，选择远远比努力重要得多，而信息和自我定位则会很大程度上左右你的选择。某些情况下努力可能只占1分，而成长环境、家境状况、历史进程、个人选择、贵人相助甚至运气则可能占9分，甚至99分。</strong></p><h2 id="曲折岁月">3 曲折岁月</h2><p>时间飞逝，一转眼三年已如白驹过隙。大一的成绩太差，总成绩大概只落在了全系40多名，掐指一算就知道在保研边缘，如果出国的大佬比较多，我也许会有机会。所以我不敢怠慢，两手准备，保研自然最好，若是失败也不能耽误考研。</p><p>大概是8月份回校的，那阵就看数学，没什么状态，大概心里还是侥幸着能够保送，也不知道专业课该看计算机还是通信的。9月大家人心惶惶，有出国考T考G的，有各种保外保内的，还有穿着西装到处参加面试的，大家也都比较焦虑，放弃考研的也大有人在。浑浑噩噩就到了9月中旬，保研名额给到了第42名，而我是第45名。颇具戏剧性的是，之前坊间传言会有20多个专硕名额，搞得人心惶惶，我还幻想着保专硕算了，后来也不了了之。</p><p>这下本以为彻底死心，考虑到自己当时备考效率极低，根本看不进去书，加上周围的同学纷纷拿到了offer，我下定决心找工作。于是就完善简历，练练编程的题目，投了华为、中兴、网易等几个公司的研发岗，差不多耗了一个礼拜，也收到了陆陆续续的笔面试通知。没想到生活总是会有<del>意外的惊喜</del>，系里通知有一个国防科大的普通生定向保送名额，在我前面的2个人都放弃了，再加上军校的缘故，我竟然没怎么思考就选择了放弃，这该是第一波坑操作。</p><p>后来不知怎么滴，也许是和老师朋友聊了很多，也许觉得自己还是太菜，莫名其妙又想读研了，稀里糊涂就推掉了所有的面试，一是不够自信，二来不想分心。又把书重新拿了起来，滚去复习。奇怪的是：这次竟然可以静下心来，仔仔细细做题了。这该死的第二波坑操作，事实证明：<strong>秋招远比春招重要并且容易得多</strong>，这一点我会在后面解释。</p><p>时间来到了9月底，这下终于可以安心复习了。出于对通信专业课的阴影，我还是选了CS，还有是因为大三时几门计算机的课学的还不错，倒也饶有兴趣。</p><p>那，选哪个学校好呢？我心想，既然要考研了，本科比不过他们，研究生的学校可不能输给他们。殊不知这就是典型的“高中生心态”，<strong>没有根据自己的定位和当前的规划去做出恰当的选择，而是冲着高大上的标签去做决定，这样的决定显然是冲动并且幼稚的</strong>。清北太难了，比XJTU好的就ZJU、SJTU、FDU、NJU，最想去的是SJTU，查了之后才知道2018年SJTUCS就招了两个学硕、10几个专硕，我想难度太大了，遂杀掉（题外，2019SJTUCS难度蛮低的）。之后查了这几所之后，发现NJU分数又低、招人又多，就开始复习NJU的专业课。</p><p>专业课一共有5门，很难，每天看的头昏眼花。屋漏偏逢连夜雨，10月招生简章出来后，NJU的名额还是和往年一样多，结果过了差不多一个礼拜，官网突然把名额杀了一半，剩20几个了。我想，这也变难了，再加上群里大家信誓旦旦的样子，和朋友商量后，我在来回纠结和迷之自信中又换了学校（题外，我的分去年上NJU没啥问题）。就剩ZJU和FDU了，FDU虽然好考，但专硕却不提供住宿，还恰是从这一年开始，ZJU就这样成了唯一的选择。结果表明，复习时间真的太过紧张，尤其是专业课。408的难度相信都有所耳闻，时而做对，时而连着错很多，心情也像过山车似的起起伏伏，无数次都有撕掉卷子的冲动。我只能死马当作活马医，其实直到最后，我甚至连习题集都没有做完，很多知识点也是一知半解。这该死的第三波骚操作。</p><p>当时和几个出国狗一起自习，看过他们托福考出来的欣喜，也见过GRE310的落寞，当然还有那一起吃饭时互吐的苦水。我说考完的日子就舒服了，说我已经列好了长长的TODOList。他们说，其实你有没有想过，这本身就是人生啊！</p><p>12月的日子很难熬，临近考试，觉得自己不是在查漏补缺，而是在女娲补天。心情总是飘忽不定，仿若过山车一般，题目全对了会喜上眉梢，英语阅读5错4时又觉人生无望，揉过的专业课卷子冷静下来还是只能乖乖去看。</p><p>说来我算是一个乐观主义者，或许是<strong>人总是愿意相信对自己有利的事情</strong>。寒假可能有一丝落榜的焦虑，但大部分时间我还是在准备机试，每天都在做算法题（题外，这大概是唯一正确的事了，春招用上了）。</p><h2 id="折戟沉沙">4 折戟沉沙</h2><p>出成绩后就得知没有过线，我顿觉失望与惶恐。稍一比较，才发现别人的生活多姿多彩，自己反而是一直学习却连考试都考不好的傻逼。当天的我十分慌张，立刻去查找调剂信息。得知中科大软院收校外调剂，心情才稍稍舒缓了些。虽然学费贵点，但去中科大读个硕士还是不错的。</p><p>看着94分的专业课，我一时语塞。有些不甘心的我一遍又一遍回忆着这大半年发生的事情:本科通信、三跨浙大、备考也算不上充分，落榜也实属正常。我一直尝试重新认识自己，可现在愈发地不认识，像是一个完完全全的陌生人。刚开学后的那两天我处于弃疗状态，觉得什么都无所谓了，爱咋咋滴吧，调去差点的也行，随便找份工作也行。</p><p>冷静了几天，又觉得这些挫折并非坏事，现在受挫总比将来走向社会好。况且成年人应当为自己的错误付出代价，不论是选择出了问题，还是不够努力。挫折对于我而言绝对谈不上财富，只是希望让我这个转变缓慢的人长点教训。我不是一个一蹶不振的人，也不是度量狭小，只是受了打击，犯了错，总得学点什么，不是吗？积极的心态很重要，凡事总要向前看，过去的就过去吧。工作要好好找，调剂也要努力争取，解决好当下，求一份心安。</p><p>鸡蛋不能放在同一个篮子里，我又迅速确定了其它几个调剂的学校，排除了调剂本校和浙大相关专业的可能。后来也在老师和同学的推荐下了解了一些研究所，但大多是军工性质，我并不想去。很无聊的名校情节以及差强人意的总分使我把比本科差的学校都直接排除，最后就确定了3个：科软、山东大学、中科院成都所。</p><p>我想着这3个再差也能去一个吧，但是<strong>现实远比想象的更加要命</strong>。直到3月10几号才知道科软从今年开始不收校外生；接着是山大，学硕调剂有3个名额，专硕有11个，我想着报个人多的，却不知再次选择出错：专硕的分数高的吓人，没有拿到复试资格，而学硕反而分数低的多。拖了最长时间的就是中科院，预调剂很早就填了，我甚至都填完了政审表，傻傻地把这个当成最后的救命稻草，直到3月底没看到名单，我还是相信会来的，这大概因为我实在想要这个硕士吧。到了4月10日，我对比了去年的招生人数和今年一志愿人数，发现可能不会再有调剂了（之前发邮件问了但没有回信）。</p><p>期间也不敢落下春招，当时想得太简单：不能既没学上，又没工作。一口气投了十几份简历，所幸除了冲突和放弃的之外，都拿到了笔面试通知。因为我是半路CS，再加上春招已经没有大公司的职位，所以也投了一些非技术岗。</p><p>说个题外话，找工作一定要在秋招，因为春招只是秋招的补录，名额少、难度大。拿我作为反例，春招想要投递大公司（BAT），都已经没了HC，错过这一次你就再也不是应届生了，自然也就没了校招的待遇。我后来才了解到：阿里巴巴光是实习生转正和提前批就已经占掉了绝大部分HC，甚至于秋招都已经没什么机会了。</p><p>那段时间我几乎没怎么休息，也没心思去休息，只希望3月底可以确定去处，未来的不确定对人真是煎熬。认真去准备的有五家：TP、OPPO、浦发总行、华为和字节跳动。前三家都给了offer，华为没有了消息，字节跳动则是笔试挂掉了。后来突然发现自己跪在了哪里，华为这种公司，或者说几乎所有公司，都需要你来好好干活。但我的致命错误就在于太老实，而没有学会伪装。我甚至在主管面说自己还是想继续深造，如此愚蠢的错误我接连犯了很多次，这是学会的第一课。</p><p>我其实很讨厌面试时看重忠心的公司，现代企业本来就该是我付出劳动力、你付给我报酬，我当然会把份内的事做好，你也不要占用我其他时间。情怀不能当饭吃，这种忽悠我觉得非常小儿科，甚至不是现代企业所需要的管理方式。</p><p>找工作的心态一直在“卧槽，我还挺牛B的”/“唉，我真傻B”之间来回切换：某司HR主动打电话问我要不要去；那么简单的题目竟然不会做；某司竟然直接免掉了高管面；我怎么问了那么傻X的问题……唯一的共同点在于N轮面试真的会把人榨干。</p><p>后来拒了TP，其实OPPO也没签，一直在等菊厂的结果，直到打听到别人已经拿到了offer，才确认自己凉了。这时OPPO已经快要截止，唯一庆幸的就是自己联系了一起去面试的同学，这才没有傻等下去。虽然我知道不能以偏概全，但OPPO的HR在招聘过程中展现出来的专业素养比某为不知道高到哪里去了，“店大欺客”的道理是明摆着的。</p><p>一步一步把一手好牌打成了今天这个样子，我终于体会到其实<strong>人生的道路是由很多因素共同决定的，并且很多机会都是转瞬即逝</strong>。另外，自己也就是中人之资、半吊子水平而已。</p><p>尽管如此，起初拿到offer后，看着协议上的薪资，我有些兴奋：虽然package不大，但就我了解的情况，也算是比较好的待遇了。我庆幸自己搭上了CS的末班车，还被邀请给下一届分享找工作的经验，甚至开始早早谋划起在另一个城市的生活......</p><h2 id="痛定思痛">5 痛定思痛</h2><p>草草签约以后，我总觉得哪里不对劲，却说不上来。<strong>我发现自己比之前进步一点的是遇到不明白的问题，会去思考、去交流、去尝试得到一个答案，尽管这个答案不甚完美，甚至在上帝视角下都不一定正确，但这也比敷衍了事强上一万倍。</strong></p><p>考研失败就像压垮骆驼的最后一根稻草，让我开始跳出虚荣的怪圈，真正重新认识、评估自己。是不是一切从开始就错了呢？为什么在给予别人建议时头头是道，到了自己就非得撞得头破血流呢？万千世界，大家虽然所处位置不同，但每个人都在寻找自己的局部最优，而且结果好像都不错。唯独我，好像学习率太大，损失函数竟有些发散，距离最优点也越来越远。<strong>那种疼痛感，就像从崖边跌落，远比在平地上摔倒更令人刻骨铭心。</strong></p><p>我像过电影般一遍遍回忆这几年的事情，也时常和各种背景的人聊天（徐老师的<ahref="https://eimadrigal.github.io/posts/past-seven-years/">文章</a>给了我很大启发，我也和徐老师交流过，人很nice）。我逐渐开始发现自己的问题：周围都是IT的同学，大多都想着高薪买房，目前看来的确不错，但或许正是在这种<strong>单线程思维</strong>的浸染以及<strong>同质化的比较</strong>下，我也在不知不觉中迷失了自我，这种象牙塔带来的禁锢总有一天要被打破。更加本质的原因在于我自己<strong>本身没有一个清晰的定位并且没有明确的职业规划，哪怕只是五年、十年的规划</strong>。兜兜转转又回到了那个熟悉而又陌生的问题：我未来到底想做什么？媒体软文总是告诉我们要不忘初心、坚持梦想，却从来不告诉我们怎样寻找初心？怎样选择梦想？</p><p>与在国内互联网公司实习的同学交流后，我看到了高薪背后的挣扎：长时间的加班使得很多人到一定年龄后只能主动退出。以前我从来没有想明白：为什么某为每年从各大高校招聘那么多人，企业利润总是有限的，招那么多人怎么能消化呢？某为又不像国企，政府有命令必须帮助国家解决就业，国家养活完全可以理解。后来当我某一天突然看到了某为的离职率，才明白其实不过是数量巨大的新人换旧人而已。很多年轻人几乎没有自己的生活，疲惫而又无奈。这才是普通大众的真实情况，我们不该只看到某某大佬创业成功去纳斯达克敲钟，某某大佬又融到了C轮，这种“<strong>幸存者偏差</strong>”掩盖了“<strong>一将功成万骨枯</strong>”的现实，也让我重新审视自己：你愿意一直从事这样的职业吗？显然，答案是否定的，因为我始终觉得工作不该成为生活的主旋律，还有很多更有意义的事情等着我去完成。</p><p>顺便插一句：如果你不确定自己要干嘛，<strong>趁早去实习</strong>，接触真实的工作环境远比在象牙塔里意淫要实在得多，提早打破学校里单一价值评价体系带来的桎梏。此外，实习的好处也自不必多说，牛逼公司的实习永远都是简历上最耀眼的闪光点，甚至于在互联网，实习经历大于其它GPA、获奖、社团所带来的价值之和。</p><p>被碾压的感觉与证明自己的情绪混在一起，使得我对自己没有明确的定位。而选择上的失误更多的不是来自于信息的匮乏，而是选择的依据出现了问题：<strong>没有基于未来的职业规划来做出决定，反倒是冲着高大上的标签或者亲朋好友的期待，这样的选择能有多少理智的成分呢</strong>？扪心自问，之前那一连串的操作都是基于一个错误而又功利的方向进行，真正想要的和你实际做的完全是两码事，两者间的夹角至少也有80度，甚至可能是钝角，量出这个角度我花了整整一年，而有的人则花了五年、十年甚至一辈子，这样无头苍蝇乱撞般的努力毫无意义，甚至可能起到反作用。</p><p>是的，之前的选择出了很大的问题，现在的锅确实也得背着。可是这并不是彻底击倒我的理由，换句话说，我应该去纠正之前的错误，而不是一蹶不振。之前说过：选择比努力重要，但<strong>通过交流、经历、思考不断纠正方向的能力则比选择还要重要</strong>，这样才会带来螺旋式的上升而不是断崖式下降。</p><p>明白了错误的主要原因和以后的职业规划后，再一次重新做出的选择看起来那么自然和水到渠成。再强调一遍：<strong>你对自己的定位评估会影响你的选择，而选择却远比努力更重要。你的定位应该取决于你对自己未来的规划，而不是那些高大上的标签或者亲戚朋友的看法，这会让你失去对自己的准确判断，德不配位，必然撞墙。</strong></p><p>不撞南墙不回头，这一年撞得头破血流，跟自己的无知、幼稚、局限斗争了一年。同样，也成长了一年，甚至比以往任何时候都成长地更快。有时候回过头去想，如果这一路很顺利的话，现在又会是怎样一番景象？如果当初选择了保送，如果选择了秋招工作，如果没有选择ZJU计算机，如果调剂到地球科学系，如果去工作了，如果……可惜没如果，所以从过去汲取教训后，最好向前看。盗用一句台词：</p><blockquote><p>You have got to put the past behind you before you can move on.</p></blockquote><h2 id="自食其果">6 自食其果</h2><p>放弃这个比较有诱惑力的工作而去赌一个未知的将来，要说没有压力肯定没人相信，但我当时的决定却相当清晰，即使违约的事情还没有谈妥，即使二战期间的食宿还没有着落。因为我在用未来的职业规划当作决策目标，不再过多考虑暂时的收益，因此决定不再是冲动的。我一直以为自己是悲惨的，大四的最后才确定初步的生涯规划，但实际上我又是幸运的，因为还有一大批人甚至中年以前都没有明白。</p><p>真的要感谢我有一对开明的父母，当我不停地自我怀疑和否定之前的观点与行为，他们总会给予无限的鼓励与支持。</p><p>度过了煽情的毕业季，处理完违约的事情，考完驾照后，我便开始逐渐矫正自己的生活，为过去的错误买单。又是8月回校，心境却大有不同，坚定目标后，事情也不是一帆风顺。记得李健有一句歌词：等待和耕耘，谁更辛苦？我的答案是等待，那段时间我偶有焦虑，填补焦虑最好的方式就是找些事情做，可是闲下来之后，<strong>等待的日子却最是难熬</strong>。</p><p>每段崭新的日子一开始总是来不及悲伤。尽管我十分讨厌把相同的事情做两次以上，但或许是因为新鲜感，刚去的几周学习状态感觉还不错。逐渐理顺了生活之后，最难熬的一段日子在9月底10月初到来。接下来的几周我严重失眠：经常是晚上8/9点睡觉，躺床上思考很多事情，凌晨2/3点才入睡，然后就一直睡到大中午才起床，接着去吃饭学习，生物钟彻底陷入混乱。虽然我不止一次告诉自己：几个月很快就会过去，也明白路该怎么走，但是<strong>心病难医</strong>，还是会经常抱怨Whyalways me/Why always the wronganswer。我希望时光过得快一些，每天复习都数着日子。虽然看起来还算正常，但我有些担心会不会在哪一瞬间突然崩溃。我尝试了很多种方法试图让自己平静，回归正常的作息。</p><p>由于学校很傻逼的支付系统，扫码吃饭可供选择的窗口少得可怜，不过比物质上的单一更加要命的是心理上的波动。那段日子我真真切切感受到了人生的艰难：每天和活人说话不超过10句，我擅长独处，但还是一度怀疑自己能否忍受这样的孤独？能否坚持下去？接下来的日子又该如何度过？</p><p>幸好我有自己的日常爱好和排遣方式。除了正常的复习时间，我尝试用音乐、文学和足球去填补漫长的空闲：去看各种人物的访谈，从李健到村上春树；去听各种风格的音乐，从钢琴曲到摇滚乐，后来我惊讶地发现自己一年里竟然听了8000多首歌；去了解各种军事话题，从二战到伊拉克战争；去看各式各样的人生轨迹，从职业选择到人生理想。那段时间最开心的事情就是写博客、听音乐和刷评论，那就像是我自己的避风港。每隔一段时间我就会迷上一个大师：从RichardClayderman到Beethoven, 从石进到周杰伦，从JoeHisaishi到Maksim，从李健到Akina，甚至无聊到去扒一些<ahref="https://www.cnblogs.com/EIMadrigal/p/11421473.html">抄袭的作品</a>、在足球APP上和人撕逼。</p><p align="center"></p><center class="half"><img src="2021050914403540.jpg" height="25%" width="25%"/>图片更新于2021.5.9</center><p>为了调整生物钟，我决定用早起对抗失眠，学了很多<ahref="https://zhuanlan.zhihu.com/p/34952593">快速入睡</a>的技巧。深夜自我怀疑的时候，就去回想毕设导师对我能力的认可，她告诉我不能因为一次失误就这样自暴自弃，甚至在毕设答辩时，其他老师问我将来什么打算，我回答工作，老师仍然在表达惋惜。为了避免枯燥，我试图在每天晚上为第二天制定计划，并在完成小小的目标后奖励自己一顿美食（每隔一段时间都会去某个固定的小店吃饭）。后来不知是因为生活的惯性还是出于对第二人生的追求，我的效率渐渐提高，并养成了程序化的一天：早餐、学习、午饭、午休、学习、晚饭、学习、跑步、洗澡、沙雕视频（美食/老剧）、维护博客、睡觉。不可否认的是，尽管有时候仍然觉得自己像个可笑的小丑，但情况一直在好转。这种井井有条的生活给予了我长期的专注，使我得以脱离苦海。<img src="20200528111916687.png" alt="在这里插入图片" />于是从10月下旬直到考前，我都变得异常平静。<strong>在那段低谷的日子里，收到了许多老师、前辈、同学以及食堂大叔的照顾和鼓励，也包括那些远在网络彼岸的未曾谋面的陌生人，在此一并感谢~</strong></p><p>我原本坚定地以为，高考考成那个鬼样子是因为没有认真去学，去复读一年肯定会有巨大的提高。不过经历了那几个月，现在我觉得结果真的未可知：心态、压力等等因素共同作用下导致的结果可能会谬之千里。</p><p>在这一年里，我听到过太多的诉苦：工作后的同学又想回来读研，而且固执地认为研究生的待遇好、升职快；还遇到了许多正在读研的学长学姐后悔自己没有早早去工作挣钱，积累社会经验。两种想法没有对错，还是那句老掉牙的话：因人而异。不置可否的是，<strong>人都是有损失厌恶的，比较必然带来不快，乃至伤害</strong>。以前我总是转不过这个弯来，或者更确切地说，潜意识里不想让自己转过这个弯。如果放眼整个社会，你会发现，<strong>人生从来就不是什么公平的游戏</strong>，别人比你少读几年书、多挣一些钱根本就是没什么大不了的事。有一大堆人压根不需要读书、打工挣钱，就可以家财万贯，你奋斗一辈子可能都无法到达别人的起点，难道我们就放弃生活了吗？大家都是普通人，甚至夸张一些，都是社会最底层的人，没有谁比谁高贵或卑微，为什么要比来比去互相伤害呢？</p><p>将读研作为缓冲的人无非两种情况：不知道自己要做啥；知道了要做什么但时间已经不足以得到理想的结果，别无选择。对我个人而言，如果去工作，可能以后选择的权利会少一些。三年的缓冲一是为了弥补之前犯下的错误，二是为了让自己将来有一些小小的选择权，不用一直996。基于职业规划的前提下，我想该怎么做也已经非常明确了。当然这只是我自己的情况，其他人，比如本科时已经积攒够了资本，那大可以直接工作；对于立志进入学术界的同学，那继续出国深造才是最好的选择，所以才说因人而异。</p><p>初试后我压根没有对答案，只是小小放松了一下，庆祝这段岁月的结束，也是迎接下一段更加艰难的旅程。终于松了口气，不为别的，只为有时间做自己的事情了，<strong>自由的感觉真好</strong>。</p><p>回家后，一边等待成绩，一边准备实习。找实习的过程并没有比这半年的生活轻松多少，本来打算3月份复试后立即找实习，拿到录取资格就可以算是在校生。结果人算不如天算，没想到疫情居然持续了这么久，2/3月的时候遥遥无期，也不知道什么时候复试，如果复试拖到4/5月，结束后就只剩6/7/8这3个月，很多公司都是至少实习3个月，这样找实习的时间几乎没有。所以从2月份开始，通过各位前辈和同学的内推，大大小小投了国内外几十家互联网企业：网易、字节、华为、深信服、微软、依图、百度、腾讯、小米、Amazon、IBM、Intel、广联达......起初我觉得非常奇怪，除了2家公司打电话了解情况后，其他的都杳无音讯，唯一的机会来自于网易，不过我的面试实在糟糕。后来特意查了一下，发现非在读生签实习协议违反劳动合同法。知道这事以后，我也就基本放弃，不再强求，如意算盘再一次落空。</p><h2 id="重新起跑">7 重新起跑</h2><p>2月中旬看到初试成绩后，我觉得应该没什么问题，复试准备得很放松，把更多时间用来思考问题、夯实基础以及整理散落的片段。</p><p>复试虽然延期了2个月，但一切顺利。感谢我交的老师，面试时仍然在鼓励我，问的最多的就是去年的经历，告诉我不要以为没去ZJU就亏了，告诉我XJTU也不差，结束时说欢迎我来交大的确有些感动。在打趣的过程中，我能感觉到老师们那种不服气的精神，但同时我也明白品质和实力几无关系，就像托尔斯泰说的：<strong>只有伟大的作品，没有伟大的作家</strong>。我十分清醒，自己的水平目前确实很low，只有按照计划踏踏实实去做。</p><p>初试成绩公布后，我就联系了一堆老师，除了直接拒绝的，剩下某老师告诉我复试后才能确定名额，拟录取名单公布后，该老师问我是否读博，在得到否定的回答后，告诉我2天后跟他确认。但实际上，学硕名额非常紧张，有几个老师主动联系，我也意识到再等下去无济于事，赶快联系想跟的其他老师，很不幸的是：学硕名额几乎全都告罄。剩下一些不太想做的方向，出于无奈，只能群发了5个老师碰一碰运气。只要能实习、人品不至于太难以言表，是否push我都没什么问题，因为我只是要个学位证而已，即使这样也还是从下午3点找到晚上10点。</p><p>一年多的时间，我个人也变得更加平静，所以早早联系的老师一直吊着我，最后放我鸽子，我也无所谓。甚至看到自己出现在拟录取名单的第一行时，我也少有欣喜，脑子里想的只是烟酒生期间去哪实习，经济独立要怎么做，能不能早点拿到毕业证。</p><p>实习无望，只有做些其它事来消耗日子：拿到王道的助教资格，可能是这几个月为数不多的好消息。</p><p>人在回顾前一阶段的自己时，大多会觉得幼稚，正如现在翻看几年前的朋友圈，尴尬癌就会复发，所谓的成长究竟是好事还是坏事呢？<strong>随机漫步的人生又有谁说的清楚</strong>？甚至一年前我都从来没想过会是今天这个局面，顺便推荐一本有点虚无主义色彩的书《随机漫步的傻瓜》，看完后你可能会发现运气和概率竟然在人生中扮演了如此重要的角色。</p><p><strong>喜欢什么，就放手去做吧。人生的许多问题，只有自己亲身经历过，才能够给出回答</strong>。如雷军在<ahref="https://v.qq.com/x/page/m0857uh1apx.html">采访</a>中所说：</p><blockquote><p>雷布斯：人生不要太多的勉强，不要强迫自己做什么。我觉得做自己喜欢的事情，可能是最佳的选择。因为你喜欢这个方向，喜欢做这件事情，我觉得爱好比什么强迫都管用。</p><p>主持人：如果不知道自己喜欢什么呢？</p><p>雷布斯：那就看直觉。</p><p>主持人：也没有直觉？</p><p>雷布斯：那就撞上什么干什么，这些冥冥之中姻缘注定的，反正撞到什么是什么。人生就是这样的一场经历嘛。你撞到这个事情，你不知道自己喜不喜欢，你先干了再说，你不喜欢还可以改。不要怕选择，你不喜欢可以改。</p><p>主持人：可能大家总是怕选错吧，走弯路吧？</p><p>雷布斯：这个选错是必然的事，每个人都会做很多很多的选择，我觉得选择一定会出错。关键是提高选对的成功率，而不是说怕选错。每个人一辈子，可能做了一千个选择、一万个选择，怎么让你重要的选择不出错，或者少出错，这是关键，那些小的选择，无所谓对与错。</p></blockquote><p>人啊，总是逃不过真香定律：本科时黑的最起劲的一个地方，迟到了一年，几个月后又将重新去往。不过这次与五年前不同的是：我知道了<strong>Whoam I</strong>，也弄清了<strong>Where am Igoing</strong>，以及大致明白了<strong>How to get there</strong>。</p><h2 id="小结">8 小结</h2><p>折腾了这么多，成长的阵痛依然历历在目。有些时候道理就在那里，可是不痛撞南墙就是明白不了。撞得头破血流才体会到了下面这些道理（不保证正确，只是我现在的看法，每个人都会有局限，仅供参考）：</p><ol type="1"><li><strong>选择比努力更重要，你的当前状态就是由之前的每一步决定和行为导致的。获取足够的信息是做出正确决定的前提，多和不同背景的人交流（多约饭）是获取信息的一种方式；</strong></li><li><strong>做决定时多考虑未来的职业规划，少考虑沉没成本，更不要冲着高大上的标签或者亲朋好友的期待；</strong></li><li><strong>独立思考和自我纠错会是极其重要并且稀缺的品性，这种能力的提高都需要亲身实践（跳几次坑就明白了）；</strong></li><li><strong>世俗意义下的成功评价标准与你在哪所学校读书、成绩有多好、科研多牛逼并不是强相关，所以非名校的同学完全没有必要自暴自弃，主动获取信息并做出明智的决定，最后比名校学生优秀的大有人在，我已经亲身见识过很多这类人了；</strong></li><li><strong>对于名校同学，千万不要沉迷于学校牌子、竞赛获奖这些光环带来的麻醉中，个人差异远比学校和专业的差异大得多，趁早找到自己的生涯规划：多去申请实习或者通过其他方式进而提前排除错误选项，越早付出的代价越小；</strong></li><li><strong>不要用战术上的勤奋掩盖战略上的失败，做事前先想明白Why，再去考虑How；</strong></li><li><strong>一尘不染的事情是没有的，完美只存在于梦境中，认清过去的错误，面对当下的现实，未来重新做人；</strong></li><li><strong>综上，想要避免痛苦，就要尽早认清自己曾经、现在、将来一直都是loser的事实，每天做个乐呵呵的傻逼，也挺好。</strong></li></ol><p>伏案涕零，不知所言！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#7 Applications</title>
      <link href="/posts/mit-linear-algebra-7/"/>
      <url>/posts/mit-linear-algebra-7/</url>
      
        <content type="html"><![CDATA[<h2 id="图和网络">图和网络</h2><p>图是一些工程问题的抽象，比如电路网络：<br /><img src="https://img-blog.csdnimg.cn/20200525210820863.png"alt="在这里插入图片描述" /><br />我们可以用<spanclass="math inline">\(A_{54}\)</span>表示图中的信息，每行代表一条边，每列代表一个结点，1表示电流流入，-1表示流出：<span class="math display">\[A=\begin{bmatrix}   -1 &amp; 1 &amp; 0 &amp; 0 \\   0 &amp; -1 &amp; 1 &amp; 0 \\   -1 &amp; 0 &amp; 1 &amp; 0 \\   -1 &amp; 0 &amp; 0 &amp; 1 \\   0 &amp; 0 &amp; -1 &amp; 1 \\  \end{bmatrix}\]</span> <spanclass="math inline">\(edge3=edge1+edge2\)</span>，前三行线性相关，在图中表现为形成环路。<br />我们比较关注<spanclass="math inline">\(A\)</span>的零空间，也即如何组合各列以得到零列<spanclass="math inline">\(Ax=0\)</span>，即： <span class="math display">\[Ax=\begin{bmatrix}   x_2-x_1\\   x_3-x_2\\   x_3-x_1\\   x_4-x_1\\   x_4-x_3\\  \end{bmatrix}=\begin{bmatrix}   0\\0\\  0\\  0\\   0\\  \end{bmatrix}\]</span> 根据前面的学习，<spanclass="math inline">\(dim(N(A))=n-r(A)=4-3=1\)</span>，并且可以求出零空间：<spanclass="math inline">\(x=c\begin{bmatrix}   1\\1\\  1\\  1\\  \end{bmatrix}\)</span>，如果<spanclass="math inline">\(x_i\)</span>表示<strong>结点<spanclass="math inline">\(i\)</span>的电势</strong>，那么从结果可以看出来四个点等电势，一旦确定某个点的电势(接地为0)，即可确定其余各点。</p><p>再研究一下<span class="math inline">\(A\)</span>的左零空间，即<spanclass="math inline">\(A^Ty=0\)</span>，<spanclass="math inline">\(dim(N(A^T))=m-r(A)=5-3=2\)</span>，不妨看看转置后的鬼样子：<span class="math display">\[\begin{bmatrix}   -1 &amp; 0 &amp; -1 &amp; -1 &amp; 0 \\  1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 1 &amp; 1 &amp; 0 &amp; -1 \\  0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\  \end{bmatrix}\begin{bmatrix}   y_1\\   y_2\\  y_3\\y_4\\y_5\\  \end{bmatrix}=\begin{bmatrix}   0 \\0 \\0 \\  0 \\  \end{bmatrix}\]</span> 变为简化行阶梯<spanclass="math inline">\(R\)</span>就会发现：pivotcol是第一列、第二列和第四列，对应到图中的三条边，可以看到是没有环路的，实际上是一棵<strong>最小生成树</strong>。如果用<spanclass="math inline">\(y_i\)</span>表示<strong>边<spanclass="math inline">\(i\)</span>的电流值</strong>，不妨写出这个方程组：<span class="math display">\[\begin{cases}-y_1-y_3-y_4=0&amp; \text{结点1流出之和为0}\\y_1-y_2=0&amp; \text{结点2流入流出相等}\\y_2+y_3-y_5=0&amp; \text{...}\\y_4+y_5=0&amp; \text{...}\end{cases}\]</span> 类似地，可以求出这个左零空间的一组基： <spanclass="math display">\[\begin{bmatrix}   1\\1\\  -1\\  0\\   0\\  \end{bmatrix}、\begin{bmatrix}   0\\0\\  1\\  -1\\   1\\  \end{bmatrix}\]</span>这组基对应到图中也是很明确的：第一个向量对应回路1(边1/2/3)的电流，第二个向量对应回路2(边3/4/5)的电流，当然也可以选择大的回路作为基的一个组成。<br />由此也可以看出：<spanclass="math inline">\(dim(N(A^T))=m-r=\#loops=\#edges-(\#nodes-1)\)</span>，这也就是著名的欧拉公式：<spanclass="math inline">\(\#nodes-\#edges+\#loops=1\)</span>。</p><p>回顾整个过程：</p><ul><li>通过电势求得电势差：<span class="math inline">\(Ax=e\)</span>；</li><li>通过欧姆定律<spanclass="math inline">\(y=Ce\)</span>可以求得结点间的电流值<spanclass="math inline">\(y_i\)</span>；</li><li>通过<span class="math inline">\(A^Ty=0\)</span>验证了Kirchhoff'scurrent law。</li></ul><p>如果有外接电流源，那么整个过程可以描述为<spanclass="math inline">\(A^TCAx=f\)</span>。</p><h2 id="马尔可夫矩阵">马尔可夫矩阵</h2><p>马尔可夫模型最初是研究人口迁徙的模型，马尔可夫矩阵有2个特点： - <spanclass="math inline">\(a_{ij}&gt;0\)</span> - 每一列和为1</p><p>我们要研究随着时间变化，人口最终的分布情况，即稳态。根据一阶差分<spanclass="math inline">\(u_k=A^ku_0=c_1\lambda_1^kx_1+c_2\lambda_2^kx_2+...\)</span>，<strong>马尔可夫矩阵有一个特征值为1</strong>，其余的绝对值都小于1，那么最终的稳态就是<spanclass="math inline">\(c_1x_1\)</span>。<br />举例来看： <span class="math display">\[\begin{bmatrix}   u_{cal}\\   u_{mass}\\  \end{bmatrix}_{t=k+1}=\begin{bmatrix}   0.9 &amp; 0.2\\  0.1 &amp; 0.8\\  \end{bmatrix}\begin{bmatrix}   u_{cal}\\   u_{mass}\\  \end{bmatrix}_{t=k},u_0=\begin{bmatrix}   0\\   1000\\  \end{bmatrix}\]</span> 矩阵表示加州的人有0.9留在加州，0.1迁徙到麻省。求得<spanclass="math inline">\(A\)</span>的特征值和特征向量，再用<spanclass="math inline">\(u_0\)</span>求得系数<spanclass="math inline">\(c\)</span>，就可以得到<spanclass="math inline">\(u_k\)</span>。</p><h2 id="傅里叶级数">傅里叶级数</h2><p>我们知道，向量空间内任意向量都可以表示为一组标准正交基的线性组合：<span class="math display">\[v=x_1q_1+x_2q_2+...+x_nq_n=Qx,x=Q^{-1}v=Q^Tv\]</span> 那么对于任意的函数<spanclass="math inline">\(f(x)\)</span>，也可以表示为一组正交基的线性组合：<span class="math display">\[f(x)=a_0*1+a_1cosx+b_1sinx+a_2cos(2x)+b_2sin(2x)+...\]</span> 这组基<spanclass="math inline">\(1,cosx,sinx,cos(2x),sin(2x),...\)</span>是正交的，即：<span class="math display">\[f^Tg=\int_0^{2\pi} f(x)g(x) dx=0\]</span> 要求得级数得系数，比如<spanclass="math inline">\(a_1\)</span>，只要等式两边同乘<spanclass="math inline">\(cosx\)</span>并积分即可： <spanclass="math display">\[\int_0^{2\pi} f(x)cosx dx=\int_0^{2\pi} a_1cos^2(x) dx\]</span></p><h2 id="复矩阵">复矩阵</h2><p>复向量<span class="math inline">\(Z=\begin{bmatrix}   z_1\\...\\   z_n\\  \end{bmatrix}\)</span>的模<span class="math inline">\(||Z||^2=\barZ^TZ=||z_1||^2+...+||z_n||^2\)</span>，内积也变为共轭转置<spanclass="math inline">\(\bar y^Tx\)</span>。<br />复数意义下的对称是<span class="math inline">\(\barA^T=A\)</span>，也叫Hermitian矩阵；<br />复数意义下的正交是<span class="math inline">\(\barq_i^Tq_j=\begin{cases}0,i\neq j\\1,i=j\\\end{cases}\)</span>，这样组成的正交阵<span class="math inline">\(\barQ^TQ=I\)</span>，<spanclass="math inline">\(Q\)</span>也叫unitary矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#6 Linear Transformations</title>
      <link href="/posts/mit-linear-algebra-6/"/>
      <url>/posts/mit-linear-algebra-6/</url>
      
        <content type="html"><![CDATA[<h2 id="线性变换">线性变换</h2><p>顾名思义，所谓线性变换即某种变换满足线性性质： <spanclass="math display">\[\begin{cases}T(v+w)=T(v)+T(w)&amp; \text{}\\T(cv)=cT(v)&amp; \text{}\\\end{cases}\]</span>投影变换、旋转变换满足线性，这种映射可以通过左乘矩阵完成。<br />如果要知道对整个空间的线性变换，只需要知道对基的变换结果即可，因为任意向量都可表示为基的线性组合：<spanclass="math inline">\(v=c_1v_1+c_2v_2+...+c_nv_n\)</span>，<spanclass="math inline">\((c_1,c_2,...,c_n)\)</span>是该向量在这组基下的<strong>坐标</strong>，那么<spanclass="math inline">\(T(v)=c_1T(v_1)+...+c_nT(v_n)\)</span>。</p><p>线性变换可以用矩阵表示，不同基下对应的矩阵是不同的，如果要求该矩阵：<br />假设输入基是<spanclass="math inline">\(v_1,...v_n\)</span>，输出空间的基是<spanclass="math inline">\(w_1,...w_m\)</span>，<strong><spanclass="math inline">\(A\)</span>的第一列就是<spanclass="math inline">\(T(v_1)\)</span>在<spanclass="math inline">\(w\)</span>下的坐标</strong>，因为输入<spanclass="math inline">\(v_1\)</span>，其在<spanclass="math inline">\(v\)</span>下的坐标就是<spanclass="math inline">\(\begin{bmatrix}   1\\   0\\   ...\\   0  \end{bmatrix}\)</span>，<spanclass="math inline">\(A\)</span>乘以该坐标就是取<spanclass="math inline">\(A\)</span>的第一列，同理可得其他列。<br />容易验证<spanclass="math inline">\(T=\frac{d}{dx}\)</span>也是线性变换，输入基如果选择<spanclass="math inline">\(1,x,x^2\)</span>，输入是<spanclass="math inline">\(c_1+c_2x+c_3x^2\)</span>，那么输出是<spanclass="math inline">\(c_2+2c_3x\)</span>，输出基是<spanclass="math inline">\(1,x\)</span>，那么用矩阵表示就是： <spanclass="math display">\[A\begin{bmatrix}   c_1\\   c_2\\   c_3\\  \end{bmatrix}=\begin{bmatrix}   c_2\\   2c_3\\  \end{bmatrix}\]</span> 当然可以用上面的方法求矩阵，这里比较简单<spanclass="math inline">\(A=\begin{bmatrix}   0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 2\\  \end{bmatrix}\)</span>。</p><h2 id="基变换">基变换</h2><p>选择合适的基，可以对图像进行压缩：<br />对于原始信号<spanclass="math inline">\(x\)</span>，可以通过基变换得到另一组基下的坐标<spanclass="math inline">\(c\)</span>，这一步是无损的，这些系数里可能含有大量的0，通过去掉这些项可以压缩大小，这一步是有损的，即<spanclass="math inline">\(\hat x=\Sigma \hat c_iv_i\)</span>。<br />目前比较好的有Fourier基和小波基，都是将原始图片分割为若干小块处理。<br />8<em>8Fourier基： <span class="math display">\[\begin{bmatrix}   1 &amp; 1 &amp;... &amp; 1 \\   1 &amp; w&amp;... &amp; w^{n-1} \\   ... &amp; ... &amp; ...\\    1 &amp; w^{n-1}&amp;... &amp; w^{(n-1)^2} \\  \end{bmatrix}\]</span> 8</em>8小波基： <span class="math display">\[W=\begin{bmatrix}   1 &amp; 1 &amp;1 &amp; 0 &amp; 1&amp;0&amp;0&amp;0\\   1 &amp; 1 &amp;1 &amp; 0  &amp; -1&amp;0&amp;0&amp;0\\   1 &amp; 1 &amp;-1 &amp; 0 &amp;0&amp;1&amp;0&amp;0\\  1 &amp; 1 &amp;-1 &amp; 0 &amp;0&amp;-1&amp;0&amp;0\\  1 &amp; -1 &amp;0&amp; 1 &amp;0&amp;0&amp;1&amp;0\\  1 &amp; -1 &amp;0 &amp; 1 &amp;0&amp;0&amp;-1&amp;0\\  1 &amp; -1 &amp;0 &amp; 1 &amp;0&amp;0&amp;0&amp;1\\  1 &amp; -1 &amp;0 &amp; 1 &amp;0&amp;0&amp;0&amp;-1\\  \end{bmatrix}\]</span> 标准基下的像素值在基变换后： <span class="math display">\[p=\begin{bmatrix}   p_1\\   ...\\   p_8\\  \end{bmatrix}=W\begin{bmatrix}   c_1\\   ...\\   c_8\\  \end{bmatrix}=Wc\]</span> 所以在新的基下的坐标是<spanclass="math inline">\(c=W^{-1}p\)</span>。<br />就性能而言：我们需要<spanclass="math inline">\(W^{-1}\)</span>可以快速求得，这一点<spanclass="math inline">\(W^{-1}=W^T\)</span>；另外还要求只需要少量基向量就可以逼近原始信号。</p><h2 id="左右逆伪逆">左右逆/伪逆</h2><p>对于满秩的情况<spanclass="math inline">\(r=m=n\)</span>，左逆和右逆都存在，即<spanclass="math inline">\(AA^{-1}=I=A^{-1}A\)</span>；<br />对于列满秩<span class="math inline">\(r=n&lt;m\)</span>，比如<spanclass="math inline">\(\begin{bmatrix}   1 &amp; 2\\   1 &amp; 3\\   2 &amp; 4\\  \end{bmatrix}\)</span>，<spanclass="math inline">\(A_{left}^{-1}=(A^TA)^{-1}A^T\)</span>；<br />对于行满秩<span class="math inline">\(r=m&lt;n\)</span>，<spanclass="math inline">\(A_{right}^{-1}=A^T(AA^T)^{-1}\)</span>；<br />对于不满秩的情况<spanclass="math inline">\(r&lt;m,r&lt;n\)</span>，这样<strong>不论<spanclass="math inline">\(A^TA\)</span>还是<spanclass="math inline">\(AA^T\)</span>都是奇异的</strong>，所以不可能有左逆或者右逆。这种情况在统计学上多次出现，就提出了伪逆的概念，记作<spanclass="math inline">\(A^+\)</span>。<br />找伪逆可以通过SVD，<span class="math inline">\(A=U\SigmaV^T\)</span>，这里我们的特征值是不完整的，即<spanclass="math inline">\(\Sigma_{mn}=\begin{bmatrix}   \sigma_1 &amp; ... &amp; 0&amp;0 \\   ... &amp; ... &amp; ...&amp;0\\    0 &amp; ... &amp; \sigma_r &amp;0\\    ...\\    0 &amp; ... &amp; 0&amp;0 \\  \end{bmatrix}\)</span>，那么<spanclass="math inline">\(\Sigma_{nm}^+=\begin{bmatrix}   1/\sigma_1 &amp; ... &amp; 0&amp;0 \\   ... &amp; ... &amp; ...&amp;0\\    0 &amp; ... &amp; 1/\sigma_r &amp;0\\    ...\\    0 &amp; ... &amp; 0&amp;0 \\  \end{bmatrix}\)</span>，这样<spanclass="math inline">\(A^+=V\Sigma^+U^T\)</span>。</p><h2 id="作业">作业</h2>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#5 Eigenvalues and Eigenvectors</title>
      <link href="/posts/mit-linear-algebra-5/"/>
      <url>/posts/mit-linear-algebra-5/</url>
      
        <content type="html"><![CDATA[<h2 id="特征值特征向量">特征值/特征向量</h2><p>矩阵作用于列向量<span class="math inline">\(x\)</span>得到列向量<spanclass="math inline">\(Ax\)</span>，矩阵的作用相当于函数，对于大部分列向量<spanclass="math inline">\(Ax\)</span>，其方向是不同于<spanclass="math inline">\(x\)</span>的，我们感兴趣的是其中<strong>平行于</strong><spanclass="math inline">\(x\)</span>的：<spanclass="math inline">\(Ax=\lambda x,x\neq0\)</span>。即：向量<spanclass="math inline">\(x\)</span>在矩阵<spanclass="math inline">\(A\)</span>的作用下，方向不变，只进行比例系数为<spanclass="math inline">\(\lambda\)</span>的伸缩。<br />特征向量所在直线上的向量都是特征向量，并且包含了所有特征向量，组成了特征空间。如果我们不断左乘矩阵<spanclass="math inline">\(A\)</span>，得到的列向量会越来越贴合最大特征值对应的特征空间（只对实数而言）。<br />对于二阶投影矩阵<span class="math inline">\(P\)</span>而言：如果<spanclass="math inline">\(x\)</span>已经在列空间的平面上，那么<spanclass="math inline">\(Px=x,\lambda=1\)</span>；如果<spanclass="math inline">\(x\)</span>垂直于列空间的平面，则<spanclass="math inline">\(Px=0,\lambda=0\)</span>，除此之外， 没有任何<spanclass="math inline">\(x\)</span>可以在投影后与原<spanclass="math inline">\(x\)</span>平行。<br />若<span class="math inline">\(A\)</span>是奇异阵，那么<spanclass="math inline">\(Ax=0\)</span>必有非零解，所以<spanclass="math inline">\(\lambda=0\)</span>必是一个特征值。<br />特征值还有两条简单的性质： <spanclass="math display">\[\Sigma_{i=1}^{n}\lambda_i=trace(A),\lambda_1...\lambda_n=det(A)\]</span>有了理解后，求解<span class="math inline">\(\lambda,x\)</span>也很自然：<span class="math display">\[(A-\lambda I)x=0有非零解，A-\lambdaI必奇异\]</span> <span class="math display">\[特征方程det(A-\lambdaI)=0\]</span> 解出<spanclass="math inline">\(\lambda\)</span>，进而求出<spanclass="math inline">\((A-\lambda I)x=0\)</span>的零空间即可。<br />举个交换阵的例子：<span class="math inline">\(A=\begin{bmatrix}   0 &amp; 1 \\   1 &amp; 0\\  \end{bmatrix}\)</span>，从物理意义上，交换<spanclass="math inline">\(x_1=\begin{bmatrix}   1\\   1\\  \end{bmatrix}\)</span>的两行仍然与原向量平行，此时<spanclass="math inline">\(\lambda=1\)</span>；类似地，交换<spanclass="math inline">\(x_2=\begin{bmatrix}   1\\   -1\\  \end{bmatrix}\)</span>的两行仍然与原向量平行，只是变成了相反向量，此时<spanclass="math inline">\(\lambda=-1\)</span>。<br />如果再看<span class="math inline">\(A+3I=\begin{bmatrix}   3 &amp; 1 \\   1 &amp; 3\\  \end{bmatrix}\)</span>，特征值变为了<spanclass="math inline">\(\lambda+3=2,4\)</span>，特征向量没有改变。<br />接着可以看看特征值不为实数的例子：对于<strong>反对称</strong>矩阵<spanclass="math inline">\(\begin{bmatrix}   0 &amp; -1 \\   1 &amp; 0\\  \end{bmatrix}\)</span>，<spanclass="math inline">\(\lambda=i,-i\)</span>，从几何上看：该矩阵的作用是将向量旋转90度，旋转之后的向量不可能与之前的平行，所以也就没有实数特征值。</p><h2 id="对角化">对角化</h2><p>这一节的前提是<span class="math inline">\(A\)</span><strong>有<spanclass="math inline">\(n\)</span>个线性无关的特征向量</strong>，这样后面由<strong>特征向量组成的矩阵</strong><spanclass="math inline">\(S\)</span>才可逆。<br />对于满足前提的矩阵： <span class="math display">\[AS=A\begin{bmatrix}x_1&amp;...&amp; x_n \\\end{bmatrix}=\begin{bmatrix}\lambda_1x_1&amp;...&amp; \lambda_nx_n \\\end{bmatrix}=\begin{bmatrix}x_1&amp;...&amp; x_n \\\end{bmatrix}\begin{bmatrix}   \lambda_1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \lambda_n \\  \end{bmatrix}=S\Lambda\]</span> 这样<spanclass="math inline">\(S^{-1}AS=\Lambda\)</span>。<br />如果<spanclass="math inline">\(A\)</span>的所有特征值互异，必可对角化；如果有重复特征值，那么<strong>不一定</strong>有<spanclass="math inline">\(n\)</span>个线性无关的特征向量，也不一定可以对角化。</p><p><span class="math inline">\(A\)</span>可以被分解为<spanclass="math inline">\(A=S\Lambda S^{-1}\)</span>。由此不难得到<spanclass="math inline">\(A\)</span>的幂：<spanclass="math inline">\(A^K=S\Lambda^KS^{-1}\)</span>，特征值加倍，但特征向量不变。<br />当<spanclass="math inline">\(K\rightarrow+\infin\)</span>，如果所有<spanclass="math inline">\(|\lambda_i|&lt;1\)</span>，那么<spanclass="math inline">\(A^K\rightarrow0\)</span>。<br /><span class="math inline">\(A\)</span>的幂有一个应用：一阶差分方程<spanclass="math inline">\(u_{k+1}=Au_k\)</span>，通过递推不难发现<spanclass="math inline">\(u_k=A^ku_0\)</span>，如果直接用<spanclass="math inline">\(A^K=S\Lambda^KS^{-1}\)</span>求解，求逆开销是不可忽视的，所以我们换一种方式：<br />我们知道，线性无关的特征向量可以作为基表示其它向量： <spanclass="math display">\[u_0=c_1x_1+...+c_nx_n=Sc,Au_0=S\LambdaS^{-1}u_0=S\Lambda S^{-1}Sc=S\Lambda c\]</span> <spanclass="math display">\[A^ku_o=c_1\lambda_1^{k}x_1+...+c_n\lambda_n^{k}x_n=S\Lambda^{k}c\]</span>很清楚地看到：<span class="math inline">\(u_k\)</span>的增长速度由<spanclass="math inline">\(\Lambda\)</span>决定，并且越大的特征值起的作用越大。<br />因此求解差分方程需要三步：</p><ol type="1"><li>求解矩阵<spanclass="math inline">\(A\)</span>的特征值和特征向量；</li><li>将<spanclass="math inline">\(u_0\)</span>在特征向量上展开，求出向量<spanclass="math inline">\(c\)</span>；</li><li>按照<spanclass="math inline">\(u_k=S\Lambda^{k}c\)</span>计算即可。</li></ol><p>这里非常经典的例子就是<ahref="https://www.cnblogs.com/EIMadrigal/p/11478906.html">斐波那契数列</a>。</p><h2 id="微分方程">微分方程</h2><p>我们知道：对于常系数线性微分方程<spanclass="math inline">\(\frac{dy}{dt}=\lambda y\)</span>，其解为<spanclass="math inline">\(y(t)=Ce^{\lambdat}\)</span>。现在要研究的是未知函数是向量的情况：<spanclass="math inline">\(\frac{du}{dt}=Au\)</span>，不难验证<spanclass="math inline">\(u(t)=e^{\lambdat}x\)</span>是特解，并且微分方程组满足线性性质。<br />举例来看： <span class="math display">\[\begin{cases}\frac{du_1}{dt}=-u_1+2u_2&amp; \text{}\\\frac{du_2}{dt}=u_1-2u_2&amp; \text{}\\\end{cases},u(0)=\begin{bmatrix}   1\\   0\\  \end{bmatrix}\]</span> <span class="math inline">\(A=\begin{bmatrix}   -1 &amp; 2 \\   1 &amp; -2\\  \end{bmatrix}\)</span>，求解出<spanclass="math inline">\(\lambda=0,-3\)</span>，从特征值可以看出：<spanclass="math inline">\(\lambda=-3\)</span>的项会随着<spanclass="math inline">\(t\)</span>的增加而消失，<spanclass="math inline">\(\lambda=0\)</span>的项最终会是稳态。 特征向量<spanclass="math inline">\(x_1=\begin{bmatrix}   2\\   1\\  \end{bmatrix},x_2=\begin{bmatrix}   1\\   -1\\  \end{bmatrix}\)</span>，这样可以写出通解： <spanclass="math display">\[u(t)=c_1e^{\lambda_1 t}x_1+c_2e^{\lambda_2t}x_2=\frac{1}{3}\begin{bmatrix}   2\\   1\\  \end{bmatrix}+\frac{1}{3}e^{-3t}\begin{bmatrix}   1\\   -1\\  \end{bmatrix}\]</span> 当<spanclass="math inline">\(t\rightarrow+\infin\)</span>，<spanclass="math inline">\(\frac{1}{3}\begin{bmatrix}   2\\   1\\  \end{bmatrix}\)</span>这一项将是稳态。 因此从特征值的角度，<spanclass="math inline">\(||e^{(-3+6i)t}||=e^{-3t}\)</span>，<spanclass="math inline">\(||e^{6it}||=1\)</span>，在单位圆上运动，所以最终的状态取决于特征值的实部：</p><ul><li><span class="math inline">\(Re(\lambda)&lt;0,e^{\lambdat}\rightarrow0,u(t)\rightarrow0\)</span></li><li>某个特征值为0，其余实部小于0，最终收敛于常量</li><li><span class="math inline">\(Re(\lambda)&gt;0\)</span>，无法收敛</li></ul><p>回头去看上述的微分方程，<spanclass="math inline">\(u_1\)</span>和<spanclass="math inline">\(u_2\)</span>耦合在一起，下面我们尝试用特征向量<strong>解耦</strong>：<br />令<span class="math inline">\(u=Sv\)</span>，则微分方程变为<spanclass="math inline">\(S\frac{dv}{dt}=ASv,\frac{dv}{dt}=S^{-1}ASv=\Lambdav\)</span>，那么： <span class="math display">\[\begin{cases}\frac{dv_1}{dt}=\lambda_1v_1&amp; \text{}\\\frac{dv_2}{dt}=\lambda_2v_2&amp; \text{}\\...\end{cases}\]</span> 换种思路，如果直接求解<spanclass="math inline">\(\frac{dv}{dt}=\Lambdav\)</span>，那么类似于标量的答案<spanclass="math inline">\(v(t)=v(0)e^{\Lambda t},u(t)=Sv(t)=Se^{\Lambdat}S^{-1}u(0)=e^{At}u(0)\)</span>，这里就得到了一个新的概念：<strong>矩阵指数</strong><spanclass="math inline">\(e^{At}\)</span>。<br />如果你还记得高数里的泰勒展开： <span class="math display">\[\frac{1}{1-x}=\sum\limits_{n=0}^{\infin}x^n,e^x=\sum\limits_{n=0}^{\infin}\frac{x^n}{n!}\]</span> 那么矩阵指数同样可以展开： <span class="math display">\[(I-At)^{-1}=I+At+(At)^2+...,e^{At}=I+At+\frac{1}{2}(At)^2+...+\frac{(At)^n}{n!}+...\]</span> <spanclass="math inline">\(e^{At}\)</span>一定是收敛的，因为阶乘的增长速度远远大于其它运算，接着将它写成矩阵形式：<span class="math display">\[e^{At}=I+S\Lambda S^{-1}t+\frac{1}{2}S\Lambda^2S^{-1}t^2+...=Se^{\Lambdat}S^{-1}\]</span> <span class="math inline">\(e^{\Lambdat}\)</span>也是一个矩阵指数，可以写作<spanclass="math inline">\(\begin{bmatrix}   e^{\lambda_1t} &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; e^{\lambda_nt} \\  \end{bmatrix}\)</span>，这里也可以有相似的收敛性：</p><ul><li>对于矩阵指数<span class="math inline">\(e^{\Lambdat}\)</span>，若<spanclass="math inline">\(Re(\lambda)&lt;0\)</span>，则收敛；</li><li>对于矩阵幂<span class="math inline">\(A^K=S\Lambda^KS^{-1}\)</span>，若<spanclass="math inline">\(||\lambda||&lt;1\)</span>，则收敛。</li></ul><p>微分方程也可以像上一节一样，将二阶<spanclass="math inline">\(y&#39;&#39;+by&#39;+ky=0\)</span>转为一阶，构造：<span class="math display">\[\begin{cases}y&#39;&#39;+by&#39;+ky=0&amp; \text{}\\y&#39;=y&#39;&amp; \text{}\\\end{cases}\]</span> 令<span class="math inline">\(u=\begin{bmatrix}   y&#39;\\   y\\  \end{bmatrix}\)</span>，则<spanclass="math inline">\(u&#39;=\begin{bmatrix}   y&#39;&#39;\\   y&#39;\\  \end{bmatrix}=\begin{bmatrix}   -b &amp; -k \\   1 &amp; 0\\  \end{bmatrix}\begin{bmatrix}   y&#39;\\   y\\  \end{bmatrix}=Au\)</span>。</p><h2 id="实对称阵正定阵">实对称阵/正定阵</h2><p><strong>实对称矩阵的特征值必为实数，特征向量正交</strong>。证明略。对于复矩阵，只有<spanclass="math inline">\(A=\bar A^T(共轭转置)\)</span>，性质才成立。<br />上一节我们知道：如果<span class="math inline">\(A\)</span>有<spanclass="math inline">\(n\)</span>个线性无关的特征向量，那么可以被分解成<spanclass="math inline">\(A=S\Lambda S^{-1}\)</span>。对于正交阵而言<spanclass="math inline">\(Q^T=Q^{-1}\)</span>，故<spanclass="math inline">\(A=Q\Lambda Q^{-1}=Q\LambdaQ^{T}\)</span>，如果进一步计算： <span class="math display">\[A=\begin{bmatrix}q_1&amp;...&amp; q_n \\\end{bmatrix}\begin{bmatrix}   \lambda_1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \lambda_n \\  \end{bmatrix}\begin{bmatrix}   q_1^T\\   ...\\   q_n^T\\  \end{bmatrix}=\lambda_1q_1q_1^T+...+\lambda_nq_nq_n^T\]</span> <spanclass="math inline">\(q_iq_i^T\)</span>是投影矩阵，实对称矩阵可以由投影矩阵线性组合而来，这些投影矩阵我个人感觉非常像矩阵的基，也就是说实对称阵可以完全由其特征值和特征向量确定。</p><p>接着我们来看正定阵，<strong>正定阵的前提是对称阵</strong>，有3个充要条件：</p><ul><li><span class="math inline">\(\lambda_i&gt;0\)</span></li><li><span class="math inline">\(pivot_i&gt;0\)</span></li><li>所有子行列式为正</li></ul><p>实际上，<spanclass="math inline">\(\#正主元=\#正特征值\)</span>，并且<spanclass="math inline">\(\Pi pivot=\Pi\lambda_i=det(A)\)</span>。<br />利用正定阵可以研究二次型的最小值：<br /><span class="math display">\[f(x,y)=x^TAx=ax^2+2bxy+cy^2\]</span>如果<span class="math inline">\(A\)</span>正定，那么<spanclass="math inline">\(除(0,0)外,f(x,y)&gt;0\)</span>。<br />取<span class="math inline">\(A=\begin{bmatrix}   2 &amp; 6 \\   6 &amp; 20\\  \end{bmatrix}\)</span>，那么<spanclass="math inline">\(f(x,y)=2x^2+12xy+20y^2\)</span>，配方<spanclass="math inline">\(f(x,y)=2(x+3y)^2+2y^2&gt;0\)</span>，注意各项的系数：两个平方项前的系数是<spanclass="math inline">\(A\)</span>的两个<strong>主元</strong>，括号中的3是矩阵消元时所用的<strong>乘数</strong>。如果把<spanclass="math inline">\(A\)</span>做LU分解会看得更清楚：<spanclass="math inline">\(A=LU=\begin{bmatrix}   1 &amp; 0 \\   3 &amp; 1\\  \end{bmatrix}\begin{bmatrix}   2 &amp; 6 \\   0 &amp; 2\\  \end{bmatrix}\)</span>。<br />从几何上看，<spanclass="math inline">\(f(x,y)\)</span>就像是一个<strong>碗</strong>的形状，在<spanclass="math inline">\((0,0)\)</span>处取极小值0，<spanclass="math inline">\(f(x,y)=1\)</span>则是椭圆截面。<br />对于三阶的情况：<span class="math inline">\(A=\begin{bmatrix}   2 &amp; -1 &amp; 0 \\  -1 &amp; 2 &amp; -1 \\0 &amp; -1 &amp; 2 \\  \end{bmatrix}\)</span>，可以求得<spanclass="math inline">\(\lambda=2-\sqrt2,2,2+\sqrt2\)</span>，那么此时<span class="math display">\[f=x^TAx&gt;0\]</span>这在几何上已经上升到四维，必然有3个轴，并且轴的方向由相应的特征向量决定，轴的长度由特征值决定，<spanclass="math inline">\(f=1\)</span>是一个椭球。</p><p>最后，如果<spanclass="math inline">\(A_{mn}\)</span>的各列线性无关，那么<spanclass="math inline">\(A^TA\)</span>必然正定，证明可以从<spanclass="math inline">\(x^TAx&gt;0\)</span>入手。</p><h2 id="相似阵">相似阵</h2><p>前面我们见过<spanclass="math inline">\(S^{-1}AS=\Lambda\)</span>，那么<spanclass="math inline">\(A\sim\Lambda\)</span>。比较正式的说法是：存在可逆阵M，使得<spanclass="math inline">\(B=M^{-1}AM\)</span>，则称<spanclass="math inline">\(A\simB\)</span>。相似阵可以看作一个家族，这个家族的共同点就是<strong>特征值相同</strong>。<br />之前我们知道：如果<span class="math inline">\(A\)</span>有<spanclass="math inline">\(n\)</span>个不同的特征值，那么必可相似对角化。如果有重复的特征值，未必可以对角化：<br />现在考虑<spanclass="math inline">\(\lambda_1=\lambda_2=4\)</span>的情况，满足条件的矩阵有很多，比如<spanclass="math inline">\(A=\begin{bmatrix}   4 &amp; 0 \\   0 &amp; 4\\  \end{bmatrix}\)</span>，但如果我们去找<spanclass="math inline">\(A\)</span>的相似阵，我们尝试用<spanclass="math inline">\(M^{-1}AM=A\)</span>，无论任何<spanclass="math inline">\(M\)</span>，最终的结果都是<spanclass="math inline">\(A\)</span>自己，不会增加任何新的矩阵，矩阵<spanclass="math inline">\(A\)</span>单独组成了一个家族。<br />如果去看其余满足条件的矩阵，比如<spanclass="math inline">\(B=\begin{bmatrix}   4 &amp; 1 \\   0 &amp; 4\\  \end{bmatrix},C=\begin{bmatrix}   4 &amp; 0 \\   17 &amp; 4\\  \end{bmatrix}...\)</span>，这些只有1个特征向量的矩阵虽然不能对角化，但是我们可以找一个<strong>最接近对角阵</strong>的，也就是<spanclass="math inline">\(B\)</span>，称为Jordan Form。<br />对于<span class="math inline">\(\begin{bmatrix}   0 &amp; 1 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 1 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\   0 &amp; 0 &amp; 0 &amp; 0 \\  \end{bmatrix}和\begin{bmatrix}   0 &amp; 1 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1 \\   0 &amp; 0 &amp; 0 &amp; 0 \\  \end{bmatrix}\)</span>，尽管特征值全为0，但并不相似。只有2个线性无关的特征向量，所以就有2个JordanBlock，每个Jordan Block长这样： <span class="math display">\[J_i=\begin{bmatrix}   \lambda_i &amp; 1 &amp;...&amp; 0 \\  0 &amp; \lambda_i  &amp; 1 &amp; ...\\  ...&amp;...&amp;...&amp;...\\  0 &amp; 0 &amp; \lambda_i  &amp; 1 \\   0 &amp; 0 &amp; 0 &amp; \lambda_i  \\  \end{bmatrix}\]</span> 每个块只能有1个特征向量，这样做的意义在于任意的矩阵<spanclass="math inline">\(A\)</span>，即使不能相似对角化，但是都有<spanclass="math inline">\(A\sim J=\begin{bmatrix}   J_1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; J_d \\  \end{bmatrix}\)</span>。</p><h2 id="svd分解">SVD分解</h2><p>假设我们在行空间有一组标准正交基<spanclass="math inline">\(v_1,v_2,...,v_r\)</span>，左乘矩阵<spanclass="math inline">\(A\)</span>进入列空间，将结果表示为列空间中的一组标准正交基<spanclass="math inline">\(u_1,u_2,...,u_r\)</span>： <spanclass="math display">\[AV=A\begin{bmatrix}v_1&amp;...&amp; v_r \\\end{bmatrix}=\begin{bmatrix}u_1&amp;...&amp; u_r \\\end{bmatrix}\begin{bmatrix}   \sigma_1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \sigma_r \\  \end{bmatrix}=U\Sigma\]</span> 故<span class="math inline">\(A\)</span>可以分解为<spanclass="math inline">\(A=U\Sigma V^T\)</span>。 如果<spanclass="math inline">\(A=\begin{bmatrix}   4 &amp; 4 \\   -3 &amp; 3\\  \end{bmatrix}\)</span>，试着分解下，关键问题就是如何求得等式右边的3个矩阵。<br />先来搞定<span class="math inline">\(V\)</span>，最好能去掉<spanclass="math inline">\(U\)</span>，我们的技巧是用<spanclass="math inline">\(A^TA\)</span>： <span class="math display">\[A^TA=V\Sigma^TU^TU\Sigma V^T=V\begin{bmatrix}   \sigma_1^2 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \sigma_r^2 \\  \end{bmatrix}V^T\]</span> 由于<spanclass="math inline">\(A^TA\)</span>实对称，所以我们得到了<spanclass="math inline">\(Q\Lambda Q^{T}\)</span>的形式，接下来只要搞定<spanclass="math inline">\(A^TA\)</span>的特征值和特征向量即可得到<spanclass="math inline">\(V\)</span>和<spanclass="math inline">\(\Sigma\)</span>；<br />同样地，为了求<span class="math inline">\(U\)</span>，最好先搞掉<spanclass="math inline">\(V\)</span>： <span class="math display">\[AA^T=U\Sigma V^TV\Sigma^TU^T=U\begin{bmatrix}   \sigma_1^2 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \sigma_r^2 \\  \end{bmatrix}U^T\]</span> 只要求得<spanclass="math inline">\(AA^T\)</span>的特征值和特征向量即可得<spanclass="math inline">\(U\)</span>。</p><h2 id="作业">作业</h2><p>Suppose we have the rank-r svd of a rank 1 matrix <spanclass="math inline">\(A = U\Sigma V^T\)</span>. Describe the nullspaceof <span class="math inline">\(A\)</span> in terms of possibly <spanclass="math inline">\(U\)</span>, <spanclass="math inline">\(Σ\)</span>, and <spanclass="math inline">\(V\)</span>.<br />Answer: The nullspace of <span class="math inline">\(A\)</span> is thesame as the nullspace of <span class="math inline">\(V^T\)</span>. Since<span class="math inline">\(A\)</span> is rank 1, <spanclass="math inline">\(V\)</span> is a vector. So the nullspace of <spanclass="math inline">\(V^T\)</span> is a hyperplane given by <spanclass="math inline">\(V^Tx=0\)</span>, i.e., the space of all thevectors that are perpendicular to <spanclass="math inline">\(V\)</span>.</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#4 Determinants</title>
      <link href="/posts/mit-linear-algebra-4/"/>
      <url>/posts/mit-linear-algebra-4/</url>
      
        <content type="html"><![CDATA[<p>行列式本质上是要通过一个数字反应矩阵的某些信息，目前看来不是很重要，快速过一遍。## 性质 引入是通过3个基本性质：</p><ol type="1"><li><span class="math inline">\(det(I)=1\)</span></li><li>交换两行，行列式的值变号：置换矩阵<spanclass="math inline">\(det(P)=\begin{cases}1&amp; \text{交换偶数次}\\-1&amp; \text{交换奇数次}\\\end{cases}\)</span></li><li><span class="math inline">\(\left|\begin{array}{cccc}ta &amp; tb\\c &amp; d\\\end{array}\right|=t\left|\begin{array}{cccc}a &amp; b\\c &amp; d\\\end{array}\right|,\left|\begin{array}{cccc}a+a&#39; &amp; b+b&#39;\\c &amp; d\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; b\\c &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}a&#39; &amp; b&#39;\\c &amp; d\\\end{array}\right|\)</span></li></ol><p>由3个基本性质可以推出若干：</p><ol type="1"><li>若两行相等，则<span class="math inline">\(det(A)=0\)</span><br />交换相等的2行，矩阵不变，行列式的值不变，根据性质2：<spanclass="math inline">\(det(A)=-det(A)\)</span>，得证。</li><li>初等行变换不改变行列式的值 <span class="math display">\[\left|\begin{array}{cccc}a &amp; b\\c-la &amp; d-lb\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; b\\c &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}a &amp; b\\-la &amp; -lb\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; b\\c &amp; d\\\end{array}\right|\]</span></li><li>有一行全为0，行列式为0</li><li><strong>上三角矩阵的行列式等于主对角线元素之积</strong>：<spanclass="math inline">\(det(U)=d_1d_2...d_n\)</span><br />对于任意矩阵，通过初等行变换可以得到<spanclass="math inline">\(U\)</span>，接着向上消元并提出对角线的因子，可以得到<spanclass="math inline">\(I\)</span>。<br />这也是Matlab求行列式的方法。</li><li><span class="math inline">\(det(A)=0\LeftrightarrowA是奇异矩阵(消元后有全0行)\)</span><br /><span class="math inline">\(det(A)\neq0\Leftrightarrow A可逆\RightarrowU\Rightarrow d_1d_2...d_n\neq0\)</span></li><li><span class="math inline">\(det(AB)=det(A)*det(B) \Rightarrowdet(A^{-1})=\frac{1}{det(A)}\)</span></li><li><spanclass="math inline">\(det(A^T)=det(A)\)</span>，可以通过LU分解去证，这也意味着对行成立的性质对列也成立。</li></ol><h2 id="计算方法">计算方法</h2><p>上一节中介绍了消元化上三角求行列式的方法，本节介绍2种不常用的方法，所有计算都可以通过上一节的3个基本性质获得：<br />对于二阶，拆解后有2个非零项： <span class="math display">\[\left|\begin{array}{cccc}a &amp; b\\c &amp; d\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; 0\\c &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}0 &amp; b\\c &amp; d\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; 0\\c &amp; 0\\\end{array}\right|+\left|\begin{array}{cccc}a &amp; 0\\0 &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}0 &amp; b\\0 &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}0 &amp; b\\c &amp; 0\\\end{array}\right|=ad-bc\]</span> 对于三阶，拆解后有6个非零项： <span class="math display">\[\left|\begin{array}{cccc}a_{11} &amp; a_{12} &amp; a_{13}\\a_{21} &amp; a_{22} &amp; a_{23}\\a_{31} &amp; a_{32} &amp; a_{33}\\\end{array}\right|=\left|\begin{array}{cccc}a_{11} &amp;  &amp; \\&amp; a_{22} &amp; \\&amp;  &amp; a_{33}\\\end{array}\right|+\left|\begin{array}{cccc}a_{11} &amp;  &amp; \\&amp;  &amp; a_{23}\\&amp;  a_{32}&amp; \\\end{array}\right|+\left|\begin{array}{cccc}&amp;a_{12}  &amp; \\a_{21}&amp;  &amp; \\&amp;  &amp;a_{33}\\\end{array}\right|+\left|\begin{array}{cccc}&amp;a_{12}  &amp; \\&amp;  &amp;a_{23} \\a_{31}&amp;  &amp;\\\end{array}\right|+\left|\begin{array}{cccc}&amp;  &amp;a_{13} \\a_{21}&amp;  &amp; \\&amp;a_{32}  &amp;\\\end{array}\right|+\left|\begin{array}{cccc}&amp;  &amp;a_{13} \\&amp;a_{22}  &amp; \\a_{31}&amp;  &amp;\\\end{array}\right|\]</span> 接着可以通过交换行得到对角阵并求得结果。<br />如果我们观察每一项：从第一行到最后一行，<strong>列下标</strong>是<spanclass="math inline">\((1,2,3)\)</span>的某个全排列，因此可以知道展开以后非零项一共有<spanclass="math inline">\(n!\)</span>项(第一行有<spanclass="math inline">\(n\)</span>种选择，第二行有<spanclass="math inline">\(n-1\)</span>种选择...)，于是可以得到第二种计算行列式的方法：<span class="math display">\[det(A)=\Sigma_{n!项}\pma_{1x}a_{1y}...a_{1w},(x,y,...w)是(1,n)的某个全排列\]</span> 正负号取决于交换了几次得到<spanclass="math inline">\((1,2,3...)\)</span>这种朴素的排列。<br />举例来看： <span class="math display">\[\left|\begin{array}{cccc}0 &amp; 0 &amp; 1 &amp; 1\\0 &amp; 1 &amp; 1 &amp; 0\\1 &amp; 1 &amp; 0 &amp; 0\\1 &amp; 0 &amp; 0 &amp; 1\\\end{array}\right|\]</span> 可以先取<spanclass="math inline">\((1,3)\)</span>位置，接着只能取<spanclass="math inline">\((2,2)\)</span>，接着<spanclass="math inline">\((3,1)\)</span>，最后<spanclass="math inline">\((4,4)\)</span>，所以列的排列是<spanclass="math inline">\((3,2,1,4)\)</span>，交换一次可得<spanclass="math inline">\((1,2,3,4)\)</span>，故有一非零项-1；<br />还可以先取<span class="math inline">\((1,4)\)</span>，接着<spanclass="math inline">\((2,3)\)</span>，<spanclass="math inline">\((3,2)\)</span>，最后<spanclass="math inline">\((4,1)\)</span>，列的排列是<spanclass="math inline">\((4,3,2,1)\)</span>，交换2次可得<spanclass="math inline">\((1,2,3,4)\)</span>，故有一非零项1，除此以外，没有别的选择，所以行列式的值是0。</p><p>如果我们对上述拆解三阶行列式的结果提取公因子： <spanclass="math display">\[det(A)=a_{11}(a_{22}a_{33}-a_{23}a_{32})+a_{12}(-a_{21}a_{33}+a_{23}a_{31})+a_{13}(a_{21}a_{32}-a_{22}a_{31})\]</span> 我们穷举了第一行的3种可能的选择<spanclass="math inline">\(a_{11},a_{12},a_{13}\)</span>，对于每种选择，当前行与当前列都不能再用，括号中的式子叫做<strong>代数余子式</strong><spanclass="math inline">\(C_{ij}\)</span>：去掉<spanclass="math inline">\(a_{ij}\)</span>所在行列的<spanclass="math inline">\(n-1\)</span>阶行列式，并且正负号取决于<spanclass="math inline">\(i+j\)</span>的奇(-)偶(+)。<br />这样我们得到了求行列式的第三种方法： <span class="math display">\[det(A)=a_{11}C_{11}+a_{12}C_{12}+...+a_{1n}C_{1n}\]</span> 举例来看，对于三对角行列式： <span class="math display">\[\left|\begin{array}{cccc}1 &amp; 1 &amp; 0 &amp; 0\\1 &amp; 1 &amp; 1 &amp; 0\\0 &amp; 1 &amp; 1 &amp; 1\\0 &amp; 0 &amp; 1 &amp; 1\\\end{array}\right|\]</span> 容易知：<spanclass="math inline">\(det(A_1)=1,det(A_2)=\left|\begin{array}{cccc}1 &amp; 1\\1 &amp; 1\\\end{array}\right|=0,det(A_3)=\left|\begin{array}{cccc}1 &amp; 1 &amp; 0\\1 &amp; 1 &amp; 1\\0 &amp; 1 &amp; 1\\\end{array}\right|=-1\)</span>。<br />对于四阶，我们<strong>按第一列展开</strong>：<spanclass="math inline">\(det(A_4)=1*det(A_3)-1*det(A_2)=-1\)</span>，此式可以推广：<spanclass="math inline">\(det(A_n)=det(A_{n-1})-det(A_{n-2})\)</span>，可以发现上述三对角行列式是以6为周期的。</p><h2 id="应用">应用</h2><ul><li>求逆矩阵<br />记得当年矩阵求逆教了一种伴随矩阵的方法：<spanclass="math inline">\(A^{-1}=\frac{1}{det(A)}C^T\)</span>，不知为何物？<br />只要证明<span class="math inline">\(AC^T=det(A)I\)</span>即可： <spanclass="math display">\[\left[\begin{array}{cccc}a_{11} &amp; ... &amp; a_{1n}\\... &amp;  &amp; ...\\a_{n1} &amp; ... &amp; a_{nn}\\\end{array}\right]\left[\begin{array}{cccc}C_{11} &amp; ... &amp; C_{n1}\\... &amp;  &amp; ...\\C_{1n} &amp; ... &amp; C_{nn}\\\end{array}\right]=\left[\begin{array}{cccc}det(A) &amp; ... &amp;0\\... &amp;  &amp; ...\\0 &amp; ... &amp; det(A)\\\end{array}\right]\]</span> 对于主对角线上的元素：<spanclass="math inline">\(a_{11}C_{11}+...+a_{1n}C_{1n}=det(A)\)</span>；<br />对于其它元素：<spanclass="math inline">\(a_{11}C_{n1}+...+a_{1n}C_{nn}=\left|\begin{array}{cccc}a_{11} &amp; ... &amp; a_{1n}\\... &amp;  &amp; ...\\a_{11} &amp; ... &amp; a_{1n}\\\end{array}\right|=0\)</span>。</li><li>求解<span class="math inline">\(Ax=b\)</span><br />求解：<spanclass="math inline">\(x=A^{-1}b=\frac{1}{det(A)}C^Tb\)</span>，那么考虑<spanclass="math inline">\(x_1=\frac{1}{det(A)}(b_1c_{11}+..+b_nc_{n1})\)</span>，<spanclass="math inline">\(b_1c_{11}+..+b_nc_{n1}\)</span>其实是将矩阵<spanclass="math inline">\(A\)</span>的第一列换为<spanclass="math inline">\(b\)</span>，按照第一列展开求行列式的值即可，同理可以求得其它<spanclass="math inline">\(x_i\)</span>，这种差到没人用的方法竟然被国内教材奉为圭臬。</li><li>求体积<br /><spanclass="math inline">\(det(A)\)</span>的绝对值可以定义为一个平行六面体的体积，正负表示左手系还是右手系。<br />将三阶矩阵<spanclass="math inline">\(A\)</span>的每行(列)当作平行六面体的一条边，如果<spanclass="math inline">\(A=I\)</span>，我们得到一个标准的单位立方体；如果<spanclass="math inline">\(A=Q\)</span>，我们得到一个旋转过的单位立方体，体积仍然为1，可以通过<spanclass="math inline">\(Q^TQ=I\)</span>验证。<br />如果是二维情况，那么<spanclass="math inline">\(det(A)\)</span>的绝对值就是平行四边形的面积：<span class="math display">\[S=\left|\begin{array}{cccc}a &amp; b\\c &amp; d\\\end{array}\right|=ad-bc\]</span> 那么三角形的面积就是<spanclass="math inline">\(\frac{1}{2}S\)</span>，推广到向量的起始位置不在<spanclass="math inline">\((0,0)\)</span>的情况： <spanclass="math display">\[S_{三角形}=\frac{1}{2}\left|\begin{array}{cccc}x_1 &amp; y_1 &amp; 1\\x_2 &amp; y_2 &amp; 1\\x_3 &amp; y_3 &amp; 1\\\end{array}\right|\]</span> 可以通过平移到原点去证明。</li></ul><h2 id="作业">作业</h2><p>A Hadamard matrix H is a matrix with entries ±1 and orthogonalcolumns. What is the determinant of H as a function of n? (Hadamardmatrices are conjectured to exist for every n that is a multiple of 4,but nobody knows if there is such a matrix even for n=668).<br />由于<span class="math inline">\(H\)</span>各列正交，故<spanclass="math inline">\(H^TH=cI\)</span>；又<spanclass="math inline">\(H\)</span>的元素只有±1，故<spanclass="math inline">\(c=n\)</span>。所以<spanclass="math inline">\(det(H)^2=n^n,det(H) =\pm\sqrt{n^n}\)</span>，即<spanclass="math inline">\(n\)</span>阶Hadamard矩阵的行列式既可以为正，也可以为负。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#3 Orthogonality</title>
      <link href="/posts/mit-linear-algebra-3/"/>
      <url>/posts/mit-linear-algebra-3/</url>
      
        <content type="html"><![CDATA[<h2 id="正交向量">正交向量</h2><p>初中时候我们学过勾股定理，现在用<strong>向量</strong>的形式表示：<span class="math display">\[|x|^2+|y|^2=|x+y|^2\]</span> 模长的平方也可以表示为<spanclass="math inline">\(x^Tx\)</span>，做一些计算，就有两个向量正交的判断条件<spanclass="math inline">\(x^Ty=0\)</span>。</p><p>向量正交有些简单，让我们上升到子空间正交。一个比较直观的<strong>错误</strong>的例子就是地板和墙壁的关系，两者并<strong>不正交</strong>，因为子空间正交要求子空间<spanclass="math inline">\(S\)</span>中的每个向量都和子空间<spanclass="math inline">\(T\)</span>中每个向量正交。根据定义，任意两个子空间若相交于某非0向量，那么两者必然不正交。<br />将正交的概念应用于前面学过的四个基本子空间：<br />对于零空间<span class="math inline">\(Ax=0\)</span>，我们有<spanclass="math inline">\(\begin{bmatrix}  row1\\  ...\\  rowm  \end{bmatrix}x=\begin{bmatrix}  0\\  ...\\  0  \end{bmatrix}\)</span>，<spanclass="math inline">\(x\)</span>和每一行都是正交的，那么<spanclass="math inline">\(x\)</span>和各行的线性组合也正交，由此可见<strong>零空间和行空间是正交的</strong>。<br />我们还知道：在<span class="math inline">\(R^n\)</span>中，需要<spanclass="math inline">\(n\)</span>个基向量张成整个空间，<spanclass="math inline">\(dim(C(A^T))=r,dim(N(A))=n-r\)</span>，这两个正交的子空间将<spanclass="math inline">\(R^n\)</span>一分为二，有个专门的术语<strong>正交补</strong>就描述了这种关系，意即零空间包含了所有垂直于行空间的向量。<br />类似地，可以证明<span class="math inline">\(C(A)\)</span>和<spanclass="math inline">\(N(A^T)\)</span>也是正交补的关系，将<spanclass="math inline">\(R^m\)</span>一分为二。<br />最后，我们为下一节留一个引子：考虑<spanclass="math inline">\(Ax=b\)</span>，当方程个数<spanclass="math inline">\(m\)</span>大于未知数个数<spanclass="math inline">\(n\)</span>，方程组很可能无解，那么怎么找到一个最为近似的解呢？听起来可能有些难理解，举个例子来看：<span class="math display">\[\begin{bmatrix}   1 &amp; 1\\   1 &amp; 2\\   1 &amp; 5\\  \end{bmatrix}\begin{bmatrix}   x_1\\   x_2\\  \end{bmatrix}=\begin{bmatrix}   b_1\\   b_2\\     b_3\\  \end{bmatrix}  \]</span> <span class="math inline">\(A\)</span>的列空间是<spanclass="math inline">\(R^3\)</span>中的一个平面，但是向量<spanclass="math inline">\(b\)</span>极有可能不在列空间中，此时方程组无解。但是我们想找到<spanclass="math inline">\(b\)</span>在列空间的<strong>投影</strong>，进而求出最为近似的解。<br />做法是在<span class="math inline">\(Ax=b\)</span>两边同乘<spanclass="math inline">\(A^T\)</span>，求解<spanclass="math inline">\(A^TA\hat x=A^Tb\)</span>，<spanclass="math inline">\(\hatx\)</span>即是要求的近似解。这里牵涉到一个非常重要的矩阵<spanclass="math inline">\(A^TA\)</span>，它是对称阵，并且<spanclass="math inline">\(N(A^TA)=N(A),r(A^TA)=r(A)\)</span>，如果<spanclass="math inline">\(A\)</span>的各列线性无关，那么<spanclass="math inline">\(A^TA\)</span>就是可逆的。这样做的原因后面会逐渐揭晓。</p><h2 id="子空间投影">子空间投影</h2><p>这一节非常重要。上一节的最后我们说到：在<spanclass="math inline">\(Ax=b\)</span>无解的情况下，我们要将<spanclass="math inline">\(b\)</span>微调成最靠近<spanclass="math inline">\(C(A)\)</span>的某个向量<spanclass="math inline">\(p\)</span>，从而求解<spanclass="math inline">\(A\hat x=p\)</span>，<spanclass="math inline">\(p\)</span>就是<spanclass="math inline">\(b\)</span>在列空间的<strong>投影</strong>。</p><p>我们首先看看<span class="math inline">\(R^2\)</span>的情况：<br /><img src="https://img-blog.csdnimg.cn/20200526204930131.png"alt="平面上有向量a,b，" /><br />从图中可以看到：<spanclass="math inline">\(e=b-p=b-xa\)</span>，再由正交关系：<spanclass="math inline">\(a^Te=a^T(b-xa)=0\)</span>，可以计算出乘数<spanclass="math inline">\(x=\frac{a^Tb}{a^Ta}\)</span>，进而可以将投影<spanclass="math inline">\(p\)</span>表示为<spanclass="math inline">\(p=xa=\frac{aa^T}{a^Ta}b=Pb\)</span>，这里的<spanclass="math inline">\(P=\frac{aa^T}{a^Ta}\)</span>即投影矩阵。<br /><span class="math inline">\(r(P)=1\)</span>，<spanclass="math inline">\(P\)</span>的列空间即为过<spanclass="math inline">\(a\)</span>的直线。此外，投影矩阵还有两条性质：<spanclass="math inline">\(P^T=P,P^2=P\)</span>，从几何上解释即投影2次和投影1次效果完全一样。</p><p>接着看看<span class="math inline">\(R^3\)</span>的情况：<br />两个<strong>线性无关</strong>的列向量<spanclass="math inline">\(a_1,a_2\)</span>生成的列空间是一个平面，令<spanclass="math inline">\(A=\begin{bmatrix}   a_1 &amp; a_2\\  \end{bmatrix}\)</span>。类似地，<spanclass="math inline">\(p\)</span>是向量<spanclass="math inline">\(b\)</span>在平面上的投影，<spanclass="math inline">\(e=b-p\)</span>垂直于平面。<strong>因为<spanclass="math inline">\(p\)</span>在<spanclass="math inline">\(A\)</span>的列空间中</strong>，所以可以表示为<spanclass="math inline">\(p=A\hat x=\hat x_1a_1+\hatx_2a_2\)</span>，我们就是要找到<span class="math inline">\(\hatx\)</span>。</p><p>根据<spanclass="math inline">\(e\)</span>和平面的垂直关系，可以得到： <spanclass="math display">\[\begin{cases}a_1^T(b-A\hat x)=0&amp; \text{}\\a_2^T(b-A\hat x)=0&amp; \text{}\end{cases}\]</span> 写出矩阵形式： <span class="math display">\[\begin{bmatrix}   a_1^T\\   a_2^T\\  \end{bmatrix}\begin{bmatrix}  b-A\hat x \\  \end{bmatrix}=\begin{bmatrix}   0\\   0\\  \end{bmatrix}  \]</span> 即<span class="math inline">\(A^T(b-A\hatx)=0\)</span>，<strong>这里<span class="math inline">\(b-A\hatx=e\)</span>在<spanclass="math inline">\(N(A^T)\)</span>中</strong>，故<spanclass="math inline">\(e\)</span>垂直于<spanclass="math inline">\(C(A)\)</span>。<br />接着化简，我们<strong>得到了上一节中同乘<spanclass="math inline">\(A^T\)</span>的原因</strong>：<spanclass="math inline">\(A^TA\hat x=A^Tb\)</span>，继续：<spanclass="math inline">\(\hatx=(A^TA)^{-1}A^Tb\)</span>。这里注意不能继续化简，因为<spanclass="math inline">\(A\)</span>不是方阵，<spanclass="math inline">\(A^{-1}\)</span>不存在。<br />得到组合系数<span class="math inline">\(\hatx\)</span>后，就可以写出投影<span class="math inline">\(p=A\hatx=A(A^TA)^{-1}A^Tb\)</span>，同样地，投影矩阵<spanclass="math inline">\(P=A(A^TA)^{-1}A^T\)</span>，可以验证，<spanclass="math inline">\(P^T=P,P^2=P\)</span>仍然成立。</p><p>最后我们考虑极端一些的情况：</p><ul><li>若<span class="math inline">\(b\)</span>在<spanclass="math inline">\(A\)</span>的列空间中，投影后仍然是<spanclass="math inline">\(b\)</span>自己：<spanclass="math inline">\(b=Ax-&gt;Pb=PAx=Ax=b\)</span>；</li><li>若<span class="math inline">\(b\)</span>垂直于<spanclass="math inline">\(A\)</span>的列空间，投影后是<spanclass="math inline">\(0\)</span>：<spanclass="math inline">\(b\)</span>在<spanclass="math inline">\(N(A^T)\)</span>中，<spanclass="math inline">\(A^Tb=0-&gt;Pb=0\)</span>。</li></ul><p>换句话说，<span class="math inline">\(b\)</span>被分解为<spanclass="math inline">\(p\)</span>和<spanclass="math inline">\(e\)</span>，<spanclass="math inline">\(p\)</span>在<spanclass="math inline">\(C(A)\)</span>中，<spanclass="math inline">\(e\)</span>在<spanclass="math inline">\(N(A^T)\)</span>中，并且<spanclass="math inline">\(b=p+e=Pb+(I-P)b\)</span>。</p><h2 id="最小二乘法">最小二乘法</h2><p>这是投影的一个应用，主要用来拟合直线，举例来看：<br /><img src="https://img-blog.csdnimg.cn/20200526221325518.png"alt="在这里插入图片描述" /><br />有三个点，需要找到一条最佳拟合直线，方程组形式： <spanclass="math display">\[\begin{cases}C+D=1&amp; \text{}\\C+2D=2&amp; \text{}\\C+3D=2&amp; \text{}\\\end{cases}\]</span> 矩阵形式： <span class="math display">\[Ax=\begin{bmatrix}   1 &amp; 1\\   1 &amp; 2\\   1 &amp; 3\\  \end{bmatrix}\begin{bmatrix}   C\\  D\\  \end{bmatrix}=\begin{bmatrix}   1\\   2\\     2\\  \end{bmatrix}=b  \]</span> 显然是无解的，要找到最优拟合系数<spanclass="math inline">\(CD\)</span>，就要用到投影：清除outlier(离群值)后，定义每个点的误差：<spanclass="math inline">\(|e|^2=|Ax-b|^2\)</span>，那么优化目标变为最小化：<spanclass="math inline">\(e_1^2+e_2^2+e_3^2=(C+D-1)^2+(C+2D-2)^2+(C+3D-2)^2\)</span>，如何找到<spanclass="math inline">\(\hat x=\begin{bmatrix}  C\\D\\  \end{bmatrix}\)</span>?<br />求偏导当然是一种方法，从线性代数的角度，回顾下上节中<spanclass="math inline">\(A^TA\hatx=A^Tb\)</span>，我们已经证明，<strong>这样解得的<spanclass="math inline">\(\hat x\)</span>可以微调<spanclass="math inline">\(b\)</span>使其最靠近<spanclass="math inline">\(C(A)\)</span></strong>，也就是我们要的最优估计。<br />所以我们有： <span class="math display">\[A^TA\hat x=\begin{bmatrix}   3 &amp; 6\\   6 &amp; 14\\  \end{bmatrix}\begin{bmatrix}   C\\  D\\  \end{bmatrix}=\begin{bmatrix}   5\\   11\\  \end{bmatrix}=A^Tb  \]</span> 这样就得到了所谓的Normal Equation： <spanclass="math display">\[\begin{cases}3C+6D=5&amp; \text{}\\6C+14D=11&amp; \text{}\\\end{cases}\]</span> 解得<spanclass="math inline">\(C=\frac{2}{3},D=\frac{1}{2}\)</span>，我们的最佳拟合直线即为<spanclass="math inline">\(b=\frac{2}{3}+\frac{1}{2}t\)</span>。</p><p>最后要注意的一点：<span class="math inline">\(\hatx\)</span>可解的前提是<spanclass="math inline">\(A^TA\)</span>可逆，只要<spanclass="math inline">\(A\)</span>的各列线性无关，这点即可满足。<br />不妨做一些证明：<br />要证明<span class="math inline">\(A^TA\)</span>可逆即证明<spanclass="math inline">\(A^TAx=0\)</span>只有零解；<br /><span class="math inline">\(x^TA^TAx=0,(Ax)^TAx=0,Ax=0\)</span>，<spanclass="math inline">\(A\)</span>的各列线性无关意即<spanclass="math inline">\(Ax=0\)</span>只有零解，得证。</p><h2 id="正交化">正交化</h2><p>我们都知道，对于<strong>标准正交向量</strong>，有： <spanclass="math display">\[q_i^Tq_j=\begin{cases}0&amp; \text{$i\neq j$}\\1&amp; \text{$i=j$}\\\end{cases}\]</span> 正交矩阵写作<span class="math inline">\(Q=\begin{bmatrix}   q_1 &amp; q_2 ... &amp; q_n\\  \end{bmatrix}\)</span>，很容易验证： <span class="math display">\[Q^TQ=\begin{bmatrix}   q_1^T\\   ...\\     q_n^T\\  \end{bmatrix}\begin{bmatrix}   q_1 &amp; ... &amp; q_n\\  \end{bmatrix}=I\]</span> 如果<span class="math inline">\(Q\)</span>是方阵，那么<spanclass="math inline">\(Q^T=Q^{-1}\)</span>。正交矩阵的例子有很多：以前学习过的置换矩阵、<spanclass="math inline">\(\begin{bmatrix}   cos\theta &amp; -sin\theta\\   sin\theta &amp; cos\theta\\  \end{bmatrix}\)</span>，还有一种叫做Adhemar的系列矩阵也是正交阵：<spanclass="math inline">\(\frac{1}{\sqrt{2}}\begin{bmatrix}   1 &amp; 1\\   1 &amp; -1\\  \end{bmatrix}\)</span>、<spanclass="math inline">\(\frac{1}{2}\begin{bmatrix}   1 &amp; 1 &amp; 1 &amp; 1\\   1 &amp; -1 &amp; 1 &amp; -1\\   1 &amp; 1 &amp; -1 &amp; -1\\   1 &amp; -1 &amp; -1 &amp; 1\\  \end{bmatrix}\)</span>...<br />有了这些了解后，就可以解答为什么需要正交矩阵：<br />还记得上一节中的投影矩阵<spanclass="math inline">\(P\)</span>吗？将矩阵<spanclass="math inline">\(A\)</span>变为正交阵<spanclass="math inline">\(Q\)</span>后，这时再把<spanclass="math inline">\(b\)</span>投影到<spanclass="math inline">\(C(Q)\)</span>中，投影矩阵就变为了<spanclass="math inline">\(P=Q(Q^TQ)^{-1}Q^T=QQ^T\)</span>，如果<spanclass="math inline">\(Q\)</span>是方阵，那么<spanclass="math inline">\(P=QQ^T=I\)</span>，这也非常好解释：<spanclass="math inline">\(Q\)</span>是方阵必然可逆，<spanclass="math inline">\(C(Q)\)</span>就是整个空间，<spanclass="math inline">\(P=I\)</span>相当于没有进行投影。<br />还有我们在求最优估计时用到的<span class="math inline">\(A^TA\hatx=A^Tb\)</span>变为了<span class="math inline">\(Q^TQ\hatx=Q^Tb\)</span>，即<span class="math inline">\(\hatx=Q^Tb\)</span>，求解<span class="math inline">\(\hatx_i\)</span>就简化为了<span class="math inline">\(\hatx_i=q_i^Tb\)</span>。</p><p>所以接下来的问题就是如何将各列线性无关的<spanclass="math inline">\(A\)</span>变为正交阵<spanclass="math inline">\(Q\)</span>，这项工作就是Gram-Schmidt正交化，先从两个向量的情况开始：<br /><img src="https://img-blog.csdnimg.cn/20200527120631653.png"alt="在这里插入图片描述" /><br />工作分2步进行：</p><ul><li>由线性无关的2个向量<spanclass="math inline">\(a,b\)</span>得到2个正交的向量<spanclass="math inline">\(A,B\)</span>： 这一步主要是改变方向，<spanclass="math inline">\(A=a\)</span>即可，<spanclass="math inline">\(B=e=b-p=b-\frac{A^Tb}{A^TA}A\)</span>。</li><li>将<span class="math inline">\(A,B\)</span>变为标准正交向量<spanclass="math inline">\(q_1,q_2\)</span>： 这一步主要是改变长度，<spanclass="math inline">\(q_1=\frac{A}{|A|},q_2=\frac{B}{|B|}\)</span>。</li></ul><p>如果是3个线性无关的向量，必然生成整个三维空间，<spanclass="math inline">\(A,B\)</span>不会变，<spanclass="math inline">\(C\)</span>其实是垂直于<spanclass="math inline">\(AB\)</span>子空间的那个<spanclass="math inline">\(e\)</span>，即减去在<spanclass="math inline">\(A,B\)</span>两个方向的投影(可以用三支笔模拟)，故<spanclass="math inline">\(C=c-\frac{A^Tc}{A^TA}A-\frac{B^Tc}{B^TB}B\)</span>。<br />观察上述工作，可以发现：我们所有的工作都是在<strong>同一个列空间</strong>中进行，只是开始的线性无关的基计算量太大，我们想要一组更加简化计算的互相垂直且长度为1的基。<br />正因为是在一个空间中进行，所以必然存在<spanclass="math inline">\(q\)</span>的线性组合可以得到<spanclass="math inline">\(a\)</span>，即<spanclass="math inline">\(A=QR\)</span>，并且<spanclass="math inline">\(a_1\)</span>只与<spanclass="math inline">\(q_1\)</span>有关、<spanclass="math inline">\(a_2\)</span>只与<spanclass="math inline">\(q_1,q_2\)</span>有关、<spanclass="math inline">\(a_3\)</span>只与<spanclass="math inline">\(q_1,q_2,q_3\)</span>有关，故<spanclass="math inline">\(R\)</span>必为<strong>上三角矩阵</strong>，也即：<span class="math display">\[\begin{bmatrix}   a_1 &amp; a_2 &amp; a_3\\  \end{bmatrix}=\begin{bmatrix}   q_1 &amp; q_2 &amp; q_3\\  \end{bmatrix}\begin{bmatrix}   q_1^Ta_1 &amp; q_1^Ta_2 &amp; q_1^Ta_3\\   0 &amp; q_2^Ta_2 &amp; q_2^Ta_3\\   0 &amp; 0 &amp; q_3^Ta_3\\  \end{bmatrix}\]</span> 这里<span class="math inline">\(R=Q^TA\)</span>。</p><h2 id="作业">作业</h2><p>Suppose a square <span class="math inline">\(A\)</span> has an LUfactorization <span class="math inline">\(A=LU\)</span> where <spanclass="math inline">\(L\)</span> and <spanclass="math inline">\(U\)</span> are invertible. If <spanclass="math inline">\(A=QR\)</span>, what is <spanclass="math inline">\(r_{11}\)</span> in terms of possibly elements of<span class="math inline">\(L\)</span> and <spanclass="math inline">\(U\)</span>?<br />在QR分解中，<spanclass="math inline">\(r_{11}=q_1^Ta_1=\frac{a_1}{||a_1||}a_1=||a_1||\)</span>，即<spanclass="math inline">\(A\)</span>第一列的模；第一列即<spanclass="math inline">\(L\)</span>各列的线性组合，系数是<spanclass="math inline">\(U\)</span>的第一列(只有<spanclass="math inline">\(U_{11}\)</span>一个元素)，所以<spanclass="math inline">\(r_{11}=U_{11} \sqrt{\sum_iL_{i1}^2}\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#2 Vector Spaces and Subspaces</title>
      <link href="/posts/mit-linear-algebra-2/"/>
      <url>/posts/mit-linear-algebra-2/</url>
      
        <content type="html"><![CDATA[<h2 id="向量空间">向量空间</h2><p>向量空间对于该空间内任意向量的线性组合(数乘/加法)都是封闭的，并且必然包含零向量(数乘0)。<br /><spanclass="math inline">\(R^2\)</span>本身就是一个向量空间，它的子空间有下面几种：</p><ul><li>过原点直线；</li><li>零向量。</li></ul><p><spanclass="math inline">\(R^3\)</span>本身也是一个向量空间，它的子空间：</p><ul><li>过(0,0,0)的平面；</li><li>过(0,0,0)的直线；</li><li>零向量。</li></ul><p>从矩阵构造的角度来看，假设<spanclass="math inline">\(A=\begin{bmatrix}   1 &amp; 3\\   2 &amp; 3\\   4 &amp; 1  \end{bmatrix}\)</span>，<spanclass="math inline">\(A\)</span>的每一列属于<spanclass="math inline">\(R^3\)</span>，<spanclass="math inline">\(A\)</span>的col1和col2的所有线性组合构成了一个向量空间，称作<strong>列空间</strong>，记作<spanclass="math inline">\(C(A)\)</span>。<br />从列空间的角度重新来看<span class="math inline">\(Ax=b\)</span>： <spanclass="math display">\[A=\begin{bmatrix}   1 &amp; 1 &amp; 2\\   2 &amp; 1 &amp; 3\\   3 &amp; 1 &amp; 4\\   4 &amp; 1 &amp; 5  \end{bmatrix}\]</span> <spanclass="math inline">\(A\)</span>的所有列向量的线性组合构成了<spanclass="math inline">\(R^4\)</span>的一个子空间，<spanclass="math inline">\(Ax\)</span>恰是<spanclass="math inline">\(A\)</span>的所有列向量的线性组合，即列空间<spanclass="math inline">\(C(A)\)</span>，故只有<spanclass="math inline">\(b\)</span>在<spanclass="math inline">\(C(A)\)</span>中时方程组才有解。<br />3列无论怎样线性组合，都无法充满整个4维空间，同时注意到<spanclass="math inline">\(col1+col2=col3\)</span>，即使去掉第三列，仍然可以生成原来的列空间，<spanclass="math inline">\(col3\)</span>与<spanclass="math inline">\(col1\)</span>和<spanclass="math inline">\(col2\)</span>是<strong>线性相关</strong>的，所以实际上矩阵<spanclass="math inline">\(A\)</span>的列空间只是<spanclass="math inline">\(R^4\)</span>中的2维子空间。</p><p>再来看看<span class="math inline">\(Ax=0\)</span>，所有解<spanclass="math inline">\(x\)</span>构成了<spanclass="math inline">\(A\)</span>的<strong>零空间</strong>，记作<spanclass="math inline">\(N(A)\)</span>。 <span class="math display">\[Ax=\begin{bmatrix}   1 &amp; 1 &amp; 2\\   2 &amp; 1 &amp; 3\\   3 &amp; 1 &amp; 4\\   4 &amp; 1 &amp; 5  \end{bmatrix}\begin{bmatrix}  x_1\\  x_2\\  x_3  \end{bmatrix}=\begin{bmatrix}  0\\  0\\  0\\  0  \end{bmatrix}\]</span> 虽然<span class="math inline">\(A\)</span>的每一列都属于<spanclass="math inline">\(R^4\)</span>，但是零空间研究的是<spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(x\)</span>属于<spanclass="math inline">\(R^3\)</span>。<br />傻子都看得出来<spanclass="math inline">\((0,0,0)\)</span>是一组解，此前我们知道<spanclass="math inline">\(col1+col2=col3\)</span>，所以<spanclass="math inline">\(c(1,1,-1)\)</span>也是一组解，所有解其实就是<spanclass="math inline">\(R^3\)</span>中的一个子空间，一条直线而已，也就是<spanclass="math inline">\(A\)</span>的零空间<spanclass="math inline">\(N(A)\)</span>。<br />如果<span class="math inline">\(Ax=b\)</span>中<spanclass="math inline">\(b\neq0\)</span>，那么<spanclass="math inline">\(x\)</span>是不能构成子空间的，因为其中没有零向量。</p><p>由此我们可以得到构造子空间的两种方法：</p><ul><li>矩阵各列的所有线性组合；</li><li>方程组满足特定条件，让<spanclass="math inline">\(x\)</span>生成子空间。</li></ul><h2 id="求解零空间">求解零空间</h2><p>在上一节中我们知道，求解<spanclass="math inline">\(A\)</span>的零空间其实就是求解<spanclass="math inline">\(Ax=0\)</span>，还是要用到高斯消元。 <spanclass="math display">\[A=\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2\\   2 &amp; 4 &amp; 6 &amp; 8\\   3 &amp; 6 &amp; 8 &amp; 10  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2\\   0 &amp; 0 &amp; 2 &amp; 4\\   0 &amp; 0 &amp; 0 &amp; 0  \end{bmatrix}=U\]</span> 很显然，主元(每一行中第一个非零元素)是<spanclass="math inline">\(U(0,0)=1\)</span>和<spanclass="math inline">\(U(2,3)=2\)</span>，pivotcol是第一列和第三列，第二列和第四列是free col，也可知<spanclass="math inline">\(rank(A)=\#pivots=2\)</span>，<spanclass="math inline">\(\#自由变量=n-rank(A)\)</span>，于是写出化简后的方程组：<span class="math display">\[\begin{cases}x_1+2x_2+2x_3+2x_4=0&amp; \text{}\\2x_3+4x_4=0&amp; \text{}\end{cases}\]</span> 对自由变量<spanclass="math inline">\(x_2\)</span>和<spanclass="math inline">\(x_4\)</span>，一般取<spanclass="math inline">\((0,1)\)</span>和<spanclass="math inline">\((1,0)\)</span>，所以特解(<strong>零空间的一组基</strong>)为：<span class="math display">\[\begin{bmatrix}  -2\\  1\\  0\\  0  \end{bmatrix}、\begin{bmatrix}  2\\  0\\  -2\\  1  \end{bmatrix}\]</span> 两个特解的线性组合即是整个零空间，也即是<spanclass="math inline">\(Ax=0\)</span>的全部解： <spanclass="math display">\[x=c\begin{bmatrix}  -2\\  1\\  0\\  0  \end{bmatrix}+d\begin{bmatrix}  2\\  0\\  -2\\  1  \end{bmatrix}\]</span> 其实矩阵<spanclass="math inline">\(U\)</span>还可以变得更加简单，可以化为简化行阶梯<spanclass="math inline">\(R=\begin{bmatrix}   1 &amp; 2 &amp; 0 &amp; -2\\   0 &amp; 0 &amp; 1 &amp; 2\\   0 &amp; 0 &amp; 0 &amp; 0  \end{bmatrix}\)</span>，即主元全部为1。<br />仔细观察矩阵<span class="math inline">\(R\)</span>，如果将pivotcol全部移到左边，将free col移到右边，我们可以得到<spanclass="math inline">\(R\)</span>的一般形式：<spanclass="math inline">\(R=\begin{bmatrix}   I &amp; F\\   0 &amp; 0\\  \end{bmatrix}\)</span>，由此得出<spanclass="math inline">\(x\)</span>的一般形式：<spanclass="math inline">\(x=\begin{bmatrix}   -F\\   I\\  \end{bmatrix}\)</span>。</p><h2 id="求解axb">求解Ax=b</h2><p>上一节中我们求解了<spanclass="math inline">\(Ax=0\)</span>，接着看看更加复杂的情况： <spanclass="math display">\[[A\ b]=\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\   2 &amp; 4 &amp; 6 &amp; 8 &amp; b_2\\   3 &amp; 6 &amp; 8 &amp; 10 &amp; b_3  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\   0 &amp; 0 &amp; 2 &amp; 4 &amp; b_2-2b_1\\   0 &amp; 0 &amp; 0 &amp; 0 &amp; b_3-b_2-b_1  \end{bmatrix}\]</span> 我们知道，当<span class="math inline">\(b\)</span>属于<spanclass="math inline">\(C(A)\)</span>时方程组有解，不妨设<spanclass="math inline">\(b=(1,5,6)\)</span>，那么化简的矩阵为<spanclass="math inline">\(\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2 &amp; 1\\   0 &amp; 0 &amp; 2 &amp; 4 &amp; 3\\   0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \end{bmatrix}\)</span>，求解过程有3步：</p><ul><li>特解：一般令自由变量取0，即<spanclass="math inline">\(x_2=x_4=0\)</span>，求主变量： <spanclass="math display">\[\begin{cases}x_1+2x_3=1&amp; \text{}\\2x_3=3&amp; \text{}\end{cases}\]</span> 所以特解<spanclass="math inline">\(x_p=\begin{bmatrix}  -2\\  0\\  1.5\\  0  \end{bmatrix}\)</span></li><li>求零空间，即<span class="math inline">\(Ax=0\)</span>的解<spanclass="math inline">\(x_{null}\)</span>；</li><li>所有解<span class="math inline">\(x=x_p+x_{null}\)</span>。<br />因为<span class="math inline">\(Ax_p=b, Ax_{null}=0\)</span>，故<spanclass="math inline">\(A(x_p+x_{null})=b\)</span>。</li></ul><p>对于矩阵<span class="math inline">\(A_{mn}\)</span>，我们知道<spanclass="math inline">\(r(A)=\#pivots\)</span>，所以<spanclass="math inline">\(r\leq m\)</span>，<spanclass="math inline">\(r\leq n\)</span>。<br />先看看<strong>列满秩</strong>的情况：每列都有主元，<spanclass="math inline">\(r=n&lt;m\)</span>，没有自由变量，零空间只有零向量：<br />举例来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 3\\   2 &amp; 1\\   6 &amp; 1\\   5 &amp; 1  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0\\   0 &amp; 1\\   0 &amp; 0\\   0 &amp; 0  \end{bmatrix}=\begin{bmatrix}   I\\   0\\  \end{bmatrix}\]</span> 如果特解恰好存在，有1个解，否则无解。<br />接着看看<strong>行满秩</strong>的情况：每行都有主元，<spanclass="math inline">\(r=m&lt;n\)</span>，<strong>自由变量有<spanclass="math inline">\(n-r=n-m\)</span>个</strong>，零空间有<spanclass="math inline">\(n-m\)</span>个基，<spanclass="math inline">\(Ax=b\)</span>有无穷多解：<br />举例来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 2 &amp; 6 &amp; 5\\   3 &amp; 1 &amp; 1 &amp; 1  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0 &amp; a &amp; b\\   0 &amp; 1 &amp; c &amp; d  \end{bmatrix}=\begin{bmatrix}   I &amp; F\\  \end{bmatrix}\]</span> 还有<strong>满秩</strong>的情况：<spanclass="math inline">\(r=m=n\)</span>，没有自由变量，零空间只有零向量，必有唯一的特解：<br />举例来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 2\\   3 &amp; 1\\  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0\\   0 &amp; 1\\  \end{bmatrix}=I\]</span> 最后一种情况就是<strong>不满秩</strong>：<spanclass="math inline">\(r&lt;m\)</span>，<spanclass="math inline">\(r&lt;n\)</span>，<spanclass="math inline">\(R=\begin{bmatrix}   I &amp; F\\   0 &amp; 0\\  \end{bmatrix}\)</span>，如果特解存在，就有无穷多解；否则无解。</p><h2 id="线性相关基维数">线性相关/基/维数</h2><p>我们知道，对于矩阵<spanclass="math inline">\(A_{mn}(m&lt;n)\)</span>，因为有<spanclass="math inline">\(n-r\geqn-m\)</span>个自由变量，将这些自由变量赋一些非零值，即可解得主元，所以<spanclass="math inline">\(Ax=0\)</span>必有非零解。<br />对于一组向量<span class="math inline">\(x_1, x_2...,x_n\)</span>，除了系数全0以外，没有其他的线性组合可以得到零向量，那么这组向量<strong>线性无关</strong>，即<spanclass="math inline">\(c_1x_1+c_2x_2+...+c_nx_n\neq0(c_i不全为0)\)</span>。<br />举例来看：二维空间中的三个向量必然线性相关： <spanclass="math display">\[A=\begin{bmatrix}   2 &amp; 1 &amp; 3\\   1 &amp; 2 &amp; -1\\  \end{bmatrix}\]</span> 因为<spanclass="math inline">\(n-r&gt;0\)</span>，故必然有自由变量，所以<spanclass="math inline">\(Ax=0\)</span>必有非零解，即线性相关。<br /><strong>基</strong>也是一组向量<span class="math inline">\(v_1, v_2...,v_d\)</span>，不过要满足2个条件：</p><ul><li>线性无关；</li><li>可以生成整个空间。</li></ul><p><strong>空间维度</strong>即可以生成该空间的<strong>基向量的个数</strong>，前面我们知道：<spanclass="math inline">\(r(A)=\#pivot\ cols\)</span>，所以<spanclass="math inline">\(dim(C(A))=r(A)\)</span>，因为只需要pivotcol就能生成整个列空间，并且列空间属于<spanclass="math inline">\(R^m\)</span>，因为每个基向量都有<spanclass="math inline">\(m\)</span>个元素。<br />对于零空间来说，特解的个数就是自由变量的个数，也就是基向量的个数，即<spanclass="math inline">\(dim(N(A))=\#自由变量=n-r(A)\)</span>，并且零空间属于<spanclass="math inline">\(R^n\)</span>，因为每个解向量都有<spanclass="math inline">\(n\)</span>个元素。</p><h2 id="四个基本子空间">四个基本子空间</h2><p>前面我们学习了列空间和零空间，很自然地，就会有行空间和<spanclass="math inline">\(A^T\)</span>的零空间：<br />行空间，顾名思义，即是矩阵行向量的所有线性组合生成的向量空间，其实就是<spanclass="math inline">\(C(A^T)\)</span>，<spanclass="math inline">\(dim(C(A^T))=r(A)\)</span>，属于<spanclass="math inline">\(R^n\)</span>；<br /><span class="math inline">\(A^T\)</span>的零空间，即<spanclass="math inline">\(A^Tx=0\)</span>的所有解向量生成的向量空间，即<spanclass="math inline">\(N(A^T)\)</span>，<spanclass="math inline">\(dim(N(A^T))=m-r(A)\)</span>，属于<spanclass="math inline">\(R^m\)</span>。<br />回忆消元的过程，我们不停地进行初等行变换，这个过程中，行空间没有改变，列空间改变，最终的行空间就是<spanclass="math inline">\(R\)</span>矩阵的前<spanclass="math inline">\(r(A)\)</span>行生成的向量空间。<br />对于<span class="math inline">\(N(A^T)\)</span>，即<spanclass="math inline">\(A^Ty=0\)</span>，转置即有<spanclass="math inline">\(y^TA=0\)</span>，所以<spanclass="math inline">\(N(A^T)\)</span>又叫<strong>左零空间</strong>。<br />学习消元时我们知道，左乘一系列的初等阵可以将<spanclass="math inline">\(A\)</span>化为<spanclass="math inline">\(R\)</span>： <span class="math display">\[E\begin{bmatrix}   A_{mn} &amp; I_{mm}\\  \end{bmatrix}-&gt;\begin{bmatrix}   R_{mn} &amp; E_{mm}\\  \end{bmatrix}\]</span> 矩阵<spanclass="math inline">\(E\)</span>记录了我们的变换过程，举例来看： <spanclass="math display">\[EA=\begin{bmatrix}   -1 &amp; 2 &amp; 0\\   1 &amp; -1 &amp; 0\\   -1 &amp; 0 &amp; 1  \end{bmatrix}\begin{bmatrix}   1 &amp; 2 &amp; 3 &amp; 1\\   1 &amp; 1 &amp; 2 &amp; 1\\   1 &amp; 2 &amp; 3 &amp; 1  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0 &amp; 1 &amp; 1\\   0 &amp; 1 &amp; 1 &amp; 1\\   0 &amp;  0&amp; 0 &amp; 0  \end{bmatrix}=R\]</span> <spanclass="math inline">\(dim(N(A^T))=m-r(A)=3-2=1\)</span>，左零空间中唯一一个基向量即<spanclass="math inline">\(E\)</span>的最后一行，因为<spanclass="math inline">\(\begin{bmatrix}   -1 &amp; 0 &amp; 1  \end{bmatrix}A=0\)</span>。</p><h2 id="矩阵空间">矩阵空间</h2><p>前面我们研究了若干向量生成的空间，上升一个高度，若干矩阵也可以构成一种特殊的向量空间，即矩阵空间。<br />所有的三阶矩阵构成矩阵空间<spanclass="math inline">\(M\)</span>，也就是<spanclass="math inline">\(R^{3*3}\)</span>。<br /><span class="math inline">\(M\)</span>的子空间有上三角矩阵<spanclass="math inline">\(U\)</span>和对称矩阵<spanclass="math inline">\(S\)</span>(可以用封闭性验证)。明确了空间后，就要研究该空间的维数和基向量。<br /><spanclass="math inline">\(dim(M)=9\)</span>，因为需要9个矩阵构成一组基，而且我们可以写出一组基：<span class="math display">\[\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 0 &amp; 1\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0  \end{bmatrix}  ...\begin{bmatrix}   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}\]</span> <spanclass="math inline">\(dim(S)=6\)</span>，因为需要对角线的3个元素和对角线下面(上面)3个元素；<br /><spanclass="math inline">\(dim(U)=6\)</span>，因为需要对角线的3个元素和对角线上面3个元素。<br />再来看看<span class="math inline">\(S\bigcapU\)</span>，既是上三角矩阵又是对称矩阵，其实就是对角阵，<spanclass="math inline">\(dim(S\bigcap U)=3\)</span>；<br />那么<span class="math inline">\(S\bigcupU\)</span>呢？属于上三角或者对称，很显然这无法构成子空间；<br />那么<spanclass="math inline">\(S+U\)</span>呢？对应元素求和，实际上这就是<spanclass="math inline">\(M\)</span>。<br />由此我们得到一个性质： <span class="math display">\[dim(S)+dim(U)=dim(S\bigcap U)+dim(S+U)\]</span> 对于向量空间和基，不应局限于线性代数中，例如熟悉的微分方程：<span class="math display">\[\frac{d^2y}{dx^2}+y=0\]</span> 它的所有解<spanclass="math inline">\(y=c_1cosx+c_2sinx\)</span>也构成零空间，那么<spanclass="math inline">\(cosx\)</span>和<spanclass="math inline">\(sinx\)</span>就是一组基，并且解空间的维数是2。</p><p>最后看一种很有趣的矩阵，秩为1的矩阵：<br />对于这种矩阵，有<spanclass="math inline">\(dim(C(A))=dim(C(A^T))=r=1\)</span>，不妨举个例子：<span class="math display">\[A=\begin{bmatrix}   1 &amp; 4 &amp; 5\\   2 &amp; 8 &amp; 10  \end{bmatrix}=\begin{bmatrix}   1\\   2\\  \end{bmatrix}\begin{bmatrix}   1 &amp; 4 &amp; 5\\  \end{bmatrix}=uv^T\]</span> 用一个例子作为结尾： 在<spanclass="math inline">\(R^4\)</span>中，<spanclass="math inline">\(v=\begin{bmatrix}   v_1\\   v_2\\   v_3\\   v_4  \end{bmatrix}\)</span>，<spanclass="math inline">\(s\)</span>是满足<spanclass="math inline">\(v_1+v_2+v_3+v_4=0\)</span>的所有<spanclass="math inline">\(v\)</span>，那么<spanclass="math inline">\(s\)</span>显然是子空间，并且可以写成矩阵形式<spanclass="math inline">\(Av=\begin{bmatrix}   1 &amp; 1 &amp; 1 &amp; 1\\  \end{bmatrix}v=0\)</span>，接着看看<spanclass="math inline">\(A\)</span>的四个基本子空间：</p><ul><li>零空间：<spanclass="math inline">\(dim(N(A))=n-r=4-1=3\)</span>，给每个自由变量赋值后，得到一组特解(基)：<span class="math display">\[\begin{bmatrix}-1\\1\\0\\0  \end{bmatrix}、\begin{bmatrix}-1\\0\\1\\0  \end{bmatrix}、\begin{bmatrix}-1\\0\\0\\1  \end{bmatrix}\]</span></li><li>列空间：<spanclass="math inline">\(dim(C(A))=r=1\)</span>，基可以取任意一列；</li><li>行空间：<spanclass="math inline">\(dim(C(A^T))=r=1\)</span>，基向量即第一行；</li><li>左零空间：<spanclass="math inline">\(dim(N(A^T))=m-r=0\)</span>，基向量只有零向量。</li></ul><h2 id="作业">作业</h2><p>Under what possible conditions is the matrix <spanclass="math inline">\(A=uv^T+wz^T\)</span> not of rank 2?<br />对于<span class="math inline">\(uv^T=\begin{bmatrix}   a\\   b\\   c\\  \end{bmatrix}\begin{bmatrix}   v_1&amp;v_2&amp;v_3\\  \end{bmatrix}\)</span>，结果就是<spanclass="math inline">\(u\)</span>的线性组合<spanclass="math inline">\(\begin{bmatrix}   v_1u&amp;v_2u&amp;v_3u\\  \end{bmatrix}\)</span>，所以<span class="math inline">\(C(uv^T)\subsetC(u)=xu,x\in R\)</span>；同样地，<spanclass="math inline">\(C(wz^T)\subset C(w)=yw,y\in R\)</span>，如果<spanclass="math inline">\(u\)</span>和<spanclass="math inline">\(w\)</span>共线，那么<spanclass="math inline">\(C(A)=xu\)</span>，即<spanclass="math inline">\(r(A)\leq1\)</span>；<br />从行向量组合的角度：<span class="math inline">\(uv^T=\begin{bmatrix}   av^T\\   bv^T\\   cv^T\\  \end{bmatrix}\)</span>，故<spanclass="math inline">\(uv^T\)</span>的行空间<spanclass="math inline">\(\subset v^T\)</span>的行空间<spanclass="math inline">\(=xv^T\)</span>，<spanclass="math inline">\(wz^T\)</span>的行空间<spanclass="math inline">\(\subset z^T\)</span>的行空间<spanclass="math inline">\(=yz^T\)</span>，所以如果<spanclass="math inline">\(v\)</span>和<spanclass="math inline">\(z\)</span>共线，那么行空间就可以合并，即<spanclass="math inline">\(r(A)\leq1\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#1 Solving Linear Equations</title>
      <link href="/posts/mit-linear-algebra-1/"/>
      <url>/posts/mit-linear-algebra-1/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵消元">矩阵消元</h2><p>求解三元一次方程组<spanclass="math inline">\(Ax=b\)</span>的方法就是<strong>消元</strong>：<span class="math display">\[\begin{cases}x+2y+z=2&amp; \text{E1}\\3x+8y+z=12&amp; \text{E2}\\4y+z=2&amp; \text{E3}\end{cases}\]</span> 用<spanclass="math inline">\(E2-3*E1\)</span>，再用<spanclass="math inline">\(E3-2*E2\)</span>，增广矩阵的变化： <spanclass="math display">\[\begin{bmatrix}   A &amp; b\\  \end{bmatrix}=\begin{bmatrix}   1 &amp; 2 &amp; 1 &amp; 2\\   3 &amp; 8 &amp; 1 &amp; 12\\   0 &amp; 4 &amp; 1 &amp; 2  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 1 &amp; 2\\   0 &amp; 2 &amp; -2 &amp; 6\\   0 &amp; 4 &amp; 1 &amp; 2  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 1 &amp; 2\\   0 &amp; 2 &amp; -2 &amp; 6\\   0 &amp; 0 &amp; 5 &amp; -10  \end{bmatrix}=\begin{bmatrix}   U &amp; c \\  \end{bmatrix}\]</span> 注意到变换过程中<spanclass="math inline">\(A\)</span>的pivots(主对角线元素)均不为0。<br />接着可以得到消元后的方程组： <span class="math display">\[\begin{cases}x+2y+z=2&amp; \text{}\\2y-2z=6&amp; \text{}\\5z=-10&amp; \text{}\end{cases}\]</span>从最后一个方程解起，并不断<strong>回代</strong>，就可以求得<spanclass="math inline">\((x,y,z)\)</span>的值。</p><p>如果回顾刚才的变换过程，并且用矩阵形式去表示：<br />第一步：将<span class="math inline">\((2,1)\)</span>位置的值变0，即<spanclass="math inline">\(E2-3*E1\)</span>： <span class="math display">\[E_{21}A=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   -3 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}\begin{bmatrix}   1 &amp; 2 &amp; 1\\   3 &amp; 8 &amp; 1\\   0 &amp; 4 &amp; 1  \end{bmatrix}=\begin{bmatrix}   1 &amp; 2 &amp; 1\\   0 &amp; 2 &amp; -2\\   0 &amp; 4 &amp; 1  \end{bmatrix}  \]</span> 其实这个过程就是对单位阵做相同的行变换得到<spanclass="math inline">\(E_{21}\)</span>，<spanclass="math inline">\(E_{21}\)</span>的第一行乘以<spanclass="math inline">\(A\)</span>本质上就是<spanclass="math inline">\(A\)</span>的各行的线性组合：<spanclass="math inline">\(1*row1+0*row2+0*row3=[1\ 2\1]\)</span>；同样的，<spanclass="math inline">\(E_{21}\)</span>的第二行乘以<spanclass="math inline">\(A\)</span>本质上还是<spanclass="math inline">\(A\)</span>的各行的线性组合：<spanclass="math inline">\(-3*row1+1*row2+0*row3=[0\ 2\ -2]\)</span>...<br />第二步：将<span class="math inline">\((3,2)\)</span>位置的值变0，即<spanclass="math inline">\(E3-2*E2\)</span>： <span class="math display">\[E_{32}(E_{21}A)=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0\\   0 &amp; -2 &amp; 1  \end{bmatrix}\begin{bmatrix}   1 &amp; 2 &amp; 1\\   0 &amp; 2 &amp; -2\\   0 &amp; 4 &amp; 1  \end{bmatrix}=\begin{bmatrix}   1 &amp; 2 &amp; 1\\   0 &amp; 2 &amp; -2\\   0 &amp; 0 &amp; 5  \end{bmatrix}  \]</span> 这个过程就是对单位阵做相同的行变换得到<spanclass="math inline">\(E_{32}\)</span>，<spanclass="math inline">\(E_{32}\)</span>的第三行乘以<spanclass="math inline">\((E_{21}A)\)</span>本质上就是<spanclass="math inline">\((E_{21}A)\)</span>的各行的线性组合：<spanclass="math inline">\(0*row1+(-2*row2)+1*row3=[0\ 0\ 5]\)</span>；所以整个变换过程用矩阵形式表示：<br /><spanclass="math display">\[E_{32}(E_{21}A)=U-&gt;(E_{32}E_{21})A=U(矩阵乘法结合律成立，交换律不成立)\]</span><br />非常重要的结论就是<strong>左行右列</strong>： <spanclass="math display">\[\begin{bmatrix}   1 &amp; 2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}  row1\\  row2\\  row3  \end{bmatrix}=1*row1+2*row2+7*row3(矩阵左乘向量即行向量的线性组合)  \]</span> <span class="math display">\[\begin{bmatrix}   col1 &amp; col2 &amp; col3\\  \end{bmatrix}\begin{bmatrix}  3\\  4\\  5  \end{bmatrix}=3*col1+4*col2+5*col3(矩阵右乘向量即列向量的线性组合)  \]</span><strong>线性组合</strong>的思想也是矩阵乘法的核心，再举一例： <spanclass="math display">\[\begin{bmatrix}   0 &amp; 1\\   1 &amp; 0\\  \end{bmatrix}\begin{bmatrix}   a &amp; b\\   c &amp; d\\  \end{bmatrix}=\begin{bmatrix}   c &amp; d\\   a &amp; b\\  \end{bmatrix}  \]</span> 结果的第一行即：<span class="math inline">\(0*[a\ b]+1*[c\d]\)</span>，第二行即：<span class="math inline">\(1*[a\ b]+0*[c\d]\)</span>，交换行。<br />类似的，交换列(<strong>列向量的线性组合</strong>)： <spanclass="math display">\[\begin{bmatrix}   a &amp; b\\   c &amp; d\\  \end{bmatrix}\begin{bmatrix}   0 &amp; 1\\   1 &amp; 0\\  \end{bmatrix}=\begin{bmatrix}   b &amp; a\\   d &amp; c\\  \end{bmatrix}  \]</span></p><h2 id="乘法和逆矩阵">乘法和逆矩阵</h2><p>回顾上一节的内容，对于<spanclass="math inline">\(AB=C\)</span>：<br /><span class="math inline">\(C\)</span>的第<spanclass="math inline">\(i\)</span>列是<spanclass="math inline">\(A\)</span>的列向量的线性组合，组合系数即是<spanclass="math inline">\(B\)</span>对应的列<spanclass="math inline">\(col_i\)</span>，即：<spanclass="math inline">\(A*col_i\)</span>；<br /><span class="math inline">\(C\)</span>的第<spanclass="math inline">\(i\)</span>行是<spanclass="math inline">\(B\)</span>的行向量的线性组合，组合系数即是<spanclass="math inline">\(A\)</span>对应的行<spanclass="math inline">\(row_i\)</span>，即：<spanclass="math inline">\(row_i*B\)</span>。<br />从这点出发，对于任意的矩阵乘法，都可以有： <spanclass="math display">\[AB=\Sigma(col_A*row_B)\]</span> 举例来看： <spanclass="math display">\[\begin{bmatrix}   2 &amp; 7\\   3 &amp; 8\\   4 &amp; 9  \end{bmatrix}\begin{bmatrix}   1 &amp; 6\\   0 &amp; 0\\  \end{bmatrix}=\begin{bmatrix}   2\\   3\\   4  \end{bmatrix}\begin{bmatrix}   1 &amp; 6  \end{bmatrix}+\begin{bmatrix}   7\\   8\\   9  \end{bmatrix}\begin{bmatrix}   0 &amp; 0  \end{bmatrix}  \]</span> 再来看看<span class="math inline">\(A=\begin{bmatrix}   1 &amp; 3\\   2 &amp; 6\\  \end{bmatrix}\)</span>，能否找到一个<strong>非零向量</strong><spanclass="math inline">\(x\)</span>，使得<spanclass="math inline">\(Ax=0\)</span>呢？<br />答案是肯定的，因为<spanclass="math inline">\(A\)</span>是不可逆的。<br />解决不可逆这种特殊情况之前，先搞定足够好(可逆)的矩阵： <spanclass="math display">\[AA^{-1}=\begin{bmatrix}   1 &amp; 3\\   2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}   a &amp; c\\   b &amp; d\\  \end{bmatrix}=\begin{bmatrix}   1 &amp; 0\\   0 &amp; 1\\  \end{bmatrix}=I  \]</span> 要求出<spanclass="math inline">\(A^{-1}\)</span>，从列向量线性组合的角度： <spanclass="math display">\[\begin{bmatrix}   1 &amp; 3\\   2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}   a\\   b\\  \end{bmatrix}=\begin{bmatrix}   1\\   0\\  \end{bmatrix}，\begin{bmatrix}   1 &amp; 3\\   2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}   c\\   d\\  \end{bmatrix}=\begin{bmatrix}   0\\   1\\  \end{bmatrix}  \]</span>此时又回到了消元法解方程组，不过这里我们可以偷个懒，用Gauss-Jordan一次解出2个方程组：<span class="math display">\[\begin{bmatrix}   A &amp; I\\  \end{bmatrix}=\begin{bmatrix}   1 &amp; 3 &amp; 1 &amp; 0\\   2 &amp; 7 &amp; 0 &amp; 1\\  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0 &amp; 7 &amp; -3\\   0 &amp; 1 &amp; -2 &amp; 1\\  \end{bmatrix}=\begin{bmatrix}   I &amp; A^{-1}\\  \end{bmatrix}  \]</span>再次回顾上一节的内容：消元过程中所作的变换都可以通过<strong>左乘初等阵</strong>实现，将变换过程中所有初等阵的乘积记作<spanclass="math inline">\(E\)</span>，我们得到了一个激动人心的求解逆矩阵的方法：<span class="math display">\[E\begin{bmatrix}   A &amp; I\\  \end{bmatrix}=\begin{bmatrix}   I &amp; A^{-1}\\  \end{bmatrix}  \]</span> 因为经过变换，<spanclass="math inline">\(EA=I\)</span>，所以<spanclass="math inline">\(E=A^{-1}\)</span>，比国内的伴随矩阵不知道好到哪里去了。</p><h2 id="a的lu分解">A的LU分解</h2><p>在了解为什么进行LU分解之前，我们先来看看高斯消元的时间复杂度：<br />回想整个过程，如果矩阵<span class="math inline">\(A\)</span>有<spanclass="math inline">\(n\)</span>个元素，不难发现耗费的时间<spanclass="math inline">\(n^2+(n-1)^2+...+1^2\approx\frac{n^3}{3}\)</span>，即<spanclass="math inline">\(O(n^3)\)</span>；对于右侧的列向量<spanclass="math inline">\(b(有m个元素)\)</span>，耗费<spanclass="math inline">\(O(m^2)\)</span>。<br />在很多时候，求解<span class="math inline">\(Ax=b\)</span>时矩阵<spanclass="math inline">\(A\)</span>是不变的，只有<spanclass="math inline">\(b\)</span>在变化，如果每次都用消元法去解，每次的复杂度都会是<spanclass="math inline">\(O(n^3)\)</span>，那么如果采用LU分解<spanclass="math inline">\(A=LU\)</span>，只要预先准备好<strong>下三角矩阵</strong><spanclass="math inline">\(L\)</span>和<strong>上三角矩阵</strong><spanclass="math inline">\(U\)</span>，这一步复杂度<spanclass="math inline">\(O(n^3)\)</span>，以后求解时：<spanclass="math inline">\(Ax=LUx=b\)</span>，只要求解：</p><ul><li><span class="math inline">\(Ly=b\)</span>，得到<spanclass="math inline">\(y\)</span>，<spanclass="math inline">\(O(n^2)\)</span>；</li><li><span class="math inline">\(Ux=y\)</span>，得到<spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(O(n^2)\)</span>。<br />以后每次求解只需要<spanclass="math inline">\(O(n^2)\)</span>，大大提高了效率。</li></ul><p>明白了原因后，我们看看具体的过程：<br />我们知道，消元过程中矩阵<spanclass="math inline">\(A\)</span>可以通过左乘矩阵<spanclass="math inline">\(E\)</span>变为上三角矩阵<spanclass="math inline">\(U\)</span>，即<spanclass="math inline">\(EA=U\)</span>，那么<spanclass="math inline">\(A=E^{-1}U=LU\)</span>。<br />举例来看：<br />如果<span class="math inline">\(E_{32}E_{21}A=U\)</span>，那么<spanclass="math inline">\(A=E_{21}^{-1}E_{32}^{-1}U=LU\)</span>，假设<spanclass="math inline">\(E_{32}=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0\\   0 &amp; -5 &amp; 1  \end{bmatrix}\)</span>，<spanclass="math inline">\(E_{21}=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   -2 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}\)</span>，那么求<spanclass="math inline">\(L\)</span>即是求<spanclass="math inline">\(E_{21}^{-1}和E_{32}^{-1}\)</span>，当然可以通过上一节中的拼单位阵来求解，但是对于初等阵，可以不用这么麻烦，以<spanclass="math inline">\(E_{21}^{-1}\)</span>为例：<br />这个变换是<spanclass="math inline">\(row2-2*row1\)</span>，那么<strong>逆矩阵就是要undo这个操作</strong>，即<spanclass="math inline">\(row2+2*row1\)</span>，所以<spanclass="math inline">\(E_{21}^{-1}=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   2 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}\)</span>，同理可得<spanclass="math inline">\(E_{32}^{-1}=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0\\   0 &amp; 5 &amp; 1  \end{bmatrix}\)</span>，按照<strong>列线性组合</strong>的思想，<spanclass="math inline">\(L=E_{21}^{-1}E_{32}^{-1}=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   2 &amp; 1 &amp; 0\\   0 &amp; 5 &amp; 1  \end{bmatrix}\)</span>。</p><h2 id="置换">置换</h2><p>前面的消元过程中，当主元为0时，可能需要<strong>交换行</strong>来使消元继续下去，交换行的操作可以通过左乘置换矩阵实现，即<spanclass="math inline">\(PA=LU\)</span>，前提是<spanclass="math inline">\(A\)</span>可逆，否则再怎么交换，都会有零行。<br />3阶矩阵的置换可以有<span class="math inline">\(3!=6\)</span>种： <spanclass="math display">\[\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}、\begin{bmatrix}   0 &amp; 1 &amp; 0\\   1 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}、\begin{bmatrix}   0 &amp; 0 &amp; 1\\   0 &amp; 1 &amp; 0\\   1 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 1\\   0 &amp; 1 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1\\   1 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 0 &amp; 1\\   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0  \end{bmatrix}\]</span> 置换矩阵一个重要性质是：<spanclass="math inline">\(P^T=P^{-1}\)</span>。</p><h2 id="作业">作业</h2><p>Suppose <span class="math inline">\(A = \begin{pmatrix} a &amp; b \\c &amp; d \end{pmatrix}\)</span> is factored into a 2x2 rotation <spanclass="math inline">\(Q=\begin{pmatrix} \cos \theta &amp; -\sin \theta\\ \sin \theta &amp;\cos \theta \end{pmatrix}\)</span> times a 2x2 lowertriangular matrix <span class="math inline">\(L=\begin{pmatrix} x &amp;0\\ y &amp; z \end{pmatrix}\)</span>. Write <spanclass="math inline">\(x,y,z\)</span> and <spanclass="math inline">\(θ\)</span> in terms of <spanclass="math inline">\(a,b,c\)</span> and <spanclass="math inline">\(d\)</span>.<br />这道题不难，但容易漏解：<br />容易得到：<span class="math inline">\(\begin{pmatrix}x\cos{\theta}-y\sin{\theta} &amp; -z\sin{\theta} \\x\sin{\theta}+y\cos{\theta} &amp; z\cos{\theta} \end{pmatrix} =\begin{pmatrix} a &amp; b\\ c &amp; d \end{pmatrix}\)</span>，故<spanclass="math inline">\(b^2+d^2 = z^2\)</span>。对于旋转矩阵，<spanclass="math inline">\(0\leq\theta\leq2\pi\)</span>。</p><ul><li><span class="math inline">\(z = \sqrt{b^2+d^2}\)</span>：<spanclass="math inline">\(\cos{\theta} =\frac{d}{\sqrt{b^2+d^2}},\sin{\theta} =-\frac{b}{\sqrt{b^2+d^2}}\)</span> 因为<spanclass="math inline">\(L=Q^{-1}A\)</span>： <span class="math display">\[\begin{pmatrix} \cos{\theta} &amp; \sin{\theta} \\ -\sin{\theta} &amp;\cos{\theta}\end{pmatrix}\begin{pmatrix} a &amp; b\\c &amp;d\end{pmatrix} = \begin{pmatrix}a\cos{\theta}+c\sin{\theta} &amp;b\cos{\theta}+d\sin{\theta} \\ -a\sin{\theta}+c\cos{\theta} &amp;-b\sin{\theta}+d\cos{\theta} \end{pmatrix} = \begin{pmatrix} x &amp; 0\\ y &amp; z\end{pmatrix}\]</span> 所以有： <span class="math display">\[x = \frac{ad - bc}{\sqrt{b^2+d^2}}, y = \frac{ab+cd}{\sqrt{b^2+d^2}},\theta = \begin{cases}\arccos\frac{d}{\sqrt{b^2+d^2}},b\le0\\\\\arccos{\frac{d}{\sqrt{b^2+d^2}}}+\pi, b&gt;0\end{cases}\]</span> <spanclass="math inline">\(\arccos\theta\)</span>的值域是<spanclass="math inline">\([0,\pi]\)</span>。</li><li><span class="math inline">\(z = -\sqrt{b^2+d^2}\)</span>：<spanclass="math inline">\(\cos{\theta} =-\frac{d}{\sqrt{b^2+d^2}},\sin{\theta} =\frac{b}{\sqrt{b^2+d^2}}\)</span> <span class="math display">\[x = \frac{- ad + bc}{\sqrt{b^2+d^2}}, y = -\frac{ab+cd}{\sqrt{b^2+d^2}},\theta = \begin{cases}2\pi-\arccos\frac{d}{\sqrt{b^2+d^2}},b\le0\\\pi-\arccos{\frac{d}{\sqrt{b^2+d^2}}}, b&gt;0\end{cases}\]</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra 0 Introduction to Vectors</title>
      <link href="/posts/mit-linear-algebra-0/"/>
      <url>/posts/mit-linear-algebra-0/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><em>前言</em></h4><p><em>线性代数应该是大部分工科和商科同学的必修课，然而很不幸的是：国内的线代教学简直一团糟。如同国内大学的其他课一样，一上来就是一堆不知所云的概念、定义和性质，然后是没有什么道理的计算技巧训练，期末考完试一切结束。如果你有时间看看MIT的18.06，相信绝对会刷新你对这个学科的认知，GilbertStrang完美遵循了现实生活中遇到了什么问题、为什么会有这些问题、该如何解决、更好的方法这一教学链条。循循善诱、环环相扣，你会觉得上课、学习数学是一种享受。</em></p><h4 id="方式"><em>方式</em></h4><p><em>这门课我强烈建议去看Gil老爷子的视频，2020年的Lecture真心觉得不太良心，看完视频可以做做20版的作业加深理解。<br />我会在Blog中专门记录这门课的笔记和理解，并且覆盖一些有趣的作业题。废话不多说，开始吧~</em></p><hr /><h2 id="笔记">笔记</h2><p>课程的引入是通过初中的二元一次方程组： <span class="math display">\[\begin{cases}2x-y=0&amp; \text{}\\-x+2y=3&amp; \text{}\end{cases}\]</span> 从几何上来看：就是二维平面上两条直线相交于<spanclass="math inline">\((1,2)\)</span>。<br />从Row Picture来看：可以很直观地写作： <span class="math display">\[\begin{bmatrix}   2 &amp; -1 \\   -1 &amp; 2  \end{bmatrix}\begin{bmatrix}   x \\   y  \end{bmatrix}=\begin{bmatrix}   0 \\   3  \end{bmatrix}\]</span>这种思考方式也是国内灌输的，第一行乘以第一列得到0，第二行乘以第一列得到3，但其实更重要的是从<strong>向量(列)的线性组合</strong>角度去考虑：<span class="math display">\[x\begin{bmatrix}   2 \\   -1  \end{bmatrix}+y\begin{bmatrix}   -1 \\   2  \end{bmatrix}=\begin{bmatrix}   0 \\   3  \end{bmatrix}\]</span> 这样从几何上解释就是：有两个向量<spanclass="math inline">\(\begin{bmatrix}   2 \\   -1  \end{bmatrix}\)</span>、<span class="math inline">\(\begin{bmatrix}   -1 \\   2  \end{bmatrix}\)</span>，要找到某个组合<spanclass="math inline">\((x,y)\)</span>可以得到向量<spanclass="math inline">\(\begin{bmatrix}   0 \\   3  \end{bmatrix}\)</span>。<br />类似地，三元一次方程组也可以从列向量线性组合的角度考虑，几何上扩展到三维空间。<br />由此推广到更加一般的情形：<spanclass="math inline">\(Ax=b\)</span>，自然而然地，我们想知道：是否对于任意的<spanclass="math inline">\(b\)</span>，此方程都有解？或者换句话：对于三元一次方程组，<strong>列向量的线性组合是否能充满整个三维空间？</strong><br />如果三个向量共面，那么最多只能生成一个平面，也就是不能保证可以生成任意的<spanclass="math inline">\(b\)</span>(有解)。后面会知道，有解的条件就是<spanclass="math inline">\(A\)</span><strong>可逆</strong>。<br />这节课最重要的一点就是要用<strong>Column Picture去思考<spanclass="math inline">\(Ax=b\)</span></strong>，为了加深理解，再举例：<span class="math display">\[\begin{bmatrix}   2 &amp; 5 \\   1 &amp; 3  \end{bmatrix}\begin{bmatrix}   1 \\   2  \end{bmatrix}=1*\begin{bmatrix}   2 \\   1  \end{bmatrix}+2*\begin{bmatrix}   5 \\   3  \end{bmatrix}=\begin{bmatrix}   12 \\   7  \end{bmatrix}\]</span></p><h2 id="作业">作业</h2><ol type="1"><li>Draw two non-colinear vectors v and w, and the region that consistsof all combinations cv+dw where 0 ≤ c ≤ 1 and 0 ≤ d ≤ 1. Now considerthe linear transformation of the unit square (all points (c,d) with 0 ≤c ≤ 1 and 0 ≤ d ≤ 1) by the 2x2 matrix with first column v and secondcolumn w. Are these two regions the same?<br />答：两个区域相同。 对<spanclass="math inline">\((c,d)\)</span>做线性变换，也即 <spanclass="math display">\[\begin{bmatrix}   v&amp;w \\  \end{bmatrix}\begin{bmatrix}   c \\   d  \end{bmatrix}=cv+dw(矩阵乘以列向量，即矩阵各列的线性组合)\]</span></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变态的高等教育</title>
      <link href="/posts/abnormal-higher-education/"/>
      <url>/posts/abnormal-higher-education/</url>
      
        <content type="html"><![CDATA[<p>作为一个局内人，经历了四年的本科教育，后来接触了美帝学校的课程，对比之下越发觉得差距天大。丝毫不夸张地说，随便找一门美帝TOP50学校的公开课，质量都可以吊打国内99%的学校课程。</p><h2 id="重蹈覆辙">重蹈覆辙</h2><p>一届又一届的学生进入高校，被统一的流程加工几年之后扔进市场，工厂会召回次品，但没人会为学生负责，这样的故事仍然在不断上演，以我所在的EE为例：</p><ul><li>四年中要上若干门思政课，并且浪费很多时间去写作业、开会讨论、做pre。XJTU的这些课期末考试都是闭卷，君不见考前的图书馆走廊，到处都是拿着《毛概》笔记认真背书的同学，我曾经也是其中的一员，看似司空见惯的事情现在想来真的非常荒诞。</li><li>每学期动辄10几门课、30几个学分。大三的第一学期堆积了5门硬核专业课，外加电设和FPGA实验，以及不知道为什么存在的金工实习，更遑论还有选修课。这样的培养方案使得学生根本没有时间和精力仔细钻研，能应付完平时作业、大作业和期末考已经不易。</li><li>更为严重的是：专业课上时常可以见到PPTReader般的老师，往往这类老师对签到这种事情非常在乎，好像在维护自己的权威，除了这些，看不出他/她对课程有什么见解。PPT往往都是10几年前的版本，排版、错别字惨不忍睹，就这样一代代流传下来，还是在EE/CS这样更新极快的学科中。至今记忆犹新的微机原理的某个女老师，上课总是在炫耀自己去THU学习人家的计组课程，要做一台计算机云云...这位老师上课时竟然将汇编程序的后缀写作<code>.acm</code>。。。</li><li>关于实验课，更是无力吐槽，你的成绩基本取决于实验报告的长度，所以内卷之风日益兴起，甚至一个小小的物理实验，有同学写出了20多页的报告。。。试想如果老师仔细评阅每份报告，自然不会按照长度打分，但是老师还要忙着做很多重要的事情，怎么会有时间呢？</li></ul><p>这样的结果就是本科学的东西考完试就还回去了，下次要用还得重新学，浪费几倍的时间重新学习，这也是我最讨厌的地方。</p><h2 id="追根溯源">追根溯源</h2><p>曾经我觉得：本科教育的失败只是某个学校做的不好，也可能只是西部高校做得不够好，可是随着很多很多不可思议的事情发生，我开始怀疑即使是顶尖大学也会烂到一塌糊涂。如果你有兴趣搜索这些内容，你会看到哪怕THU、SJTU这些国内名校也是如此，只是恶劣的程度有所不同而已。所以我一直觉得交大在我黄金般的4年里没起到什么作用，甚至起的是负面作用，我没有斯德哥尔摩情节，不会感谢学校提供了如此巨大的阻力，是为了锻炼学生。</p><ul><li>本科教育并不会影响职称评定，没有相应的考核要求，不如灌paper、拉项目来的实在。教学评估也是可笑，只会评估课堂出勤率高不高、实验报告写得长不长，压根不会有领导在乎课堂质量。</li><li>钱，还是钱：我上过Harvard的计算机导论课，整个课程有70+TA，还有Amazon的计算资源免费支持，这样精心设计的课程怎么可能不是翘楚？</li></ul><h2 id="惩前毖后">惩前毖后</h2><p>怪不得在《上海交通大学学生生存手册》中，有学长疾呼：</p><blockquote><p>国内绝大部分大学的本科教育，不是濒临崩溃，而是早已崩溃。</p></blockquote><p>我自己意识到这一点实在太晚，穷屌丝也读不起master::&gt;_&lt;::<br />我很感谢国家的政策，让我掏很少的钱就能接触到大学教育。但是希望赶路者能意识到：国内的高等教育就是shit，如果按照学校的计划走下来，进社会迟早被安排地明明白白，越努力，越傻逼。</p><p>Sad buttrue，研究生的教育只会更加差劲，我不想再被继续残害下去，说说自己的打算(在达到毕业要求的前提下)：</p><ul><li>我不否认有大神可以从课堂上学会关键知识，但是对于我们普通人来说，只能把有限的时间用来做出最好的选择。适合自己的方式才是最好的。</li><li>能不去的课就不去了，尽量选水课(不签到/考试水/给分高)。用尽可能多的<strong>自由支配时间</strong>学习更加优质的教学资源。</li><li>和老师交流要看情况，主要还是科研方向问题。</li></ul><h2 id="他山之石">他山之石</h2><p>我只列举一些我看到过的观点，并不代表个人看法。</p><ul><li><ahref="http://www.houxiaodi.com/assets/misc/manual.pdf">《上海交通大学学生生存手册》</a></li><li><ahref="https://blog.csdn.net/wangkechuang/article/details/8125062">清华梦的粉碎——写给清华大学的退学申请</a></li><li><ahref="https://www.zhihu.com/question/60444527/answer/267271327">西安交通大学和其它几所2+7相比有什么优势和不足？</a></li></ul><blockquote><p>本来不想来打扰准备昏睡至死的人。</p><p>如果只是XJTUer来知乎自问自答寻求廉价的满足感，我从来不会浪费自己的时间来反驳他们。毕竟他们抱着发霉的C9头衔和上世纪的择校观念自娱自乐开心就好。</p><p>但是看到题主只是一名高中生，并且已经成功意识到了XJTU既存的缺陷（我当年为什么没有获得这些信息？！），应该是一位相当重视自己未来并且希望它最优的人。实在不希望那些高票回答毁人不倦。</p><p>不错，你确实应该对排名有一个清醒的认识：不要再拿XJTU和清北华五以及华科北航等学校比，它不配。生源/就业质量/出国率这些硬参数XJTU全方面垫底。这时候会有XJTUer跳出来说三大奖排名才是货真价实的比较，那么根据<ahref="https://www.sohu.com/a/154387981_111981">近五年各大高校国家“三大奖”</a>中国农大排名11名，中科大排名19落后于苏州大学江南大学等高校，请问这个排名货真价实在哪里？每种排名都有一些对应的“利好高校”，三大奖之于XJTU，类似武书连排名之于WHU。就算前者更客观，也只不过是一方面。更何况WHU都不拿武书连说事儿了，XJTU还在西部一隅拿三大奖自慰呢！</p><p>XJTU的腐朽、低效、没落，就算是孜孜不倦来洗地的各位，想必也是深有体会吧。彩虹楼甲醛、彭康楼甲醛、女生宿舍和主楼女厕偷窥偷拍事件、xx书院房顶掉落，还有很多我暂时没回忆起来的，以上这些，XJTU官方有过任何一个让人满意的答复吗？可笑的是，很多XJTUer作为受害者身边的人甚至受害者自身，还在试图说服自己去对XJTU“培养一种满足和自豪感”。就我个人来说，很多小事都折射着XJTU的低效和颓败。</p><p>1）上学期办英文成绩单，学校教务处的人告知要先在哪里开原始成绩单，然后找谁和谁签字，等费劲周折终于完成，回来盖章的时候，又说按规定今天不行，下周一下午来吧。结果又浪费了好几天（后来才知道，给教务处那个负责盖章的求求情就能立刻完成，呵呵）。</p><p>2）大三的暑期实习答辩，基本水出天际，只要你的实习盖章签字没问题。同期去XJTU钦定的陕西鼓风机动力集团和渭河电厂打扑克玩手机的同学，答辩就算千篇一律漏洞百出，照样稳过。当时本人没有去学校“偏好”的公司实习，答辩被刁难了近一个月。据我所知还有机械那边的学长大三暑假在DJI实习，结果回来学院死活不认可，被迫大四暑假补上XJTU认证的不知道在干嘛的实习。那些响应XJTU号召去签约的野鸡公司划水的乖乖同学们，能不能通过DJI面试都是问题。以及有大神翘课去MSRA科研，期末考的也很好，但是XJTU不给登成绩的事就不细说了。</p><p>3）老师们绝大部分都是重科研轻本科教学，时不时会遇到PPT朗读员般的极品老师。不过这个貌似是中国高校通病，XJTU具有也是理所当然？？XJTUer，你们是这么认为的吗？另外，科研也不是你想象的那样，50%以上是论文灌水+项目拉钱，极少数是高质量研究。</p><p>4）本学期老师给的一门CS相关课程的PPT，拿到一看，最后修改时间2007年，十年过去了，连页脚的日期，正文的错别字都没有变，就这样年复一年的给陕西省一流大学的学生们使用着，而且还是CS这种更新极快的课程方向，让人忍俊不禁...</p><p>5）XJTU大部分老师都是本校本硕博一条龙的教育。一个开放的、优秀的、吸引人才的大学，这种情况不会这么严重。不信可以去美国的大学任何一个系的facultylist看一看，以及去中国东部的排名靠前的学校官网看看。另外，XJTU很多老师根本就不更新自己的主页，publications停留在几年前，甚至一些英文论文标题都有错词，总之不知道他们每天都在做些什么。</p><p>关于“XJTU这些年已经止颓了，正在稳步上升，你看创新港建的多好”这类说法，我只想说我们都是普通人，只能力争用有限的时间做出最优的选择。你不能把自己四年最宝贵的时间赌在一个未知数上。建了一堆大楼就改善了对本科生个体的关怀，也不现实。走出家乡去发达地区拥抱更多的机会和更广阔的视野，就算上了一个看起来不如XJTU的学校（也只是看起来不如而已），比起在知乎上埋头洗地的XJTUer来，你已经优秀太多了。</p><p>如果非要客观地介绍一下XJTU屈指可数的优势：</p><p>1.机械能动材料等传统工科科研实力强势（与本科生关系并不大，本科发顶会paper的是极少数）。如果确实热爱这方面的科研并且愿意忍受相对较低的工资，同类高校请选择XJTU。CSEE相关工科，选择北航北邮华科这些学校，不要选择XJTU。</p><p>2.目前还算在市中心，生活和交通便利。</p><p>最后的最后，你的选择权由你的高考成绩/自招成绩决定。</p></blockquote><ul><li><ahref="https://www.zhihu.com/answer/437601713">如何评价西安交大计算机系？</a></li></ul><blockquote><p>看到很多人的批评，还是想多说两句，表达我的想法：</p><p>我从来都很感激西安交大，学校的补贴让我不用花钱出国交流，好心的老师给我写推荐信，学校的名声让我的简历能进入全国的大公司，2W元四年的学费让我收获了自认为超过100万的好处。</p><p>但是这都是我对学校本身的感激和爱戴，是学校或者是国家的好政策培养了我。而不是那些搞小山头的老师，僵化的管理人员，不尊重学生的制度。这些人现在越来越多，我认为并不配代表西安交大。我对这些毒瘤的批评也并不能代表对交大的否定。</p><p>交大计算机的培养计划确实存在着很大的问题，说交大计算机本科毕业不会写代码，我觉得完全没毛病，95%的学生四年下来写过的代码不会超过1000行，一半是for循环。剩下一半是在纸上写的。</p><p>其次我不同意也不想反驳如下的论点：“你来了交大就别BB，BB不如去复读”，“母校只允许自己黑，不能让别人说半句不是“，这基本等同于“你对政府不满就出国，不然老老实实受着”。</p><p>很多人都只是挑了西交计算机的缺点，这是十分有偏见的，本着为校争光的原则，在此列举一些西交计算机的优点：</p><p>1。西交计算机系的编程作业很少，给了学生们充分的自学时间。众所周知，计算机是一门自学的专业，很多三本的大神都是自学成才。而学校领导和老师们充分认识到了这一点，作业能出原题就出原题，能用笔写绝不用电脑，能让助教改绝不机考。比如一个下午就能写完一学期的C++作业，看了一学期mooc的数据结构，上机不到10个学时的操作系统。这对学生的自学能力提出了很高的要求，极大地提升了同学们的自学能力。</p><p>2。重视经典和原创。上课的教材能用本校就用本校的，能自己编就自己编，充分地体现了很多老师本人的风格和只可意会的专业水平。甚至体育都有自己本校的教材，印象中有太极拳等等，为了防止学生练武走火入魔，学校可谓用心良苦。PPT也都极其经典，有10年前的，5年前的，表现了尊重经典，坚持传统的精神。</p><p>3。必修很多看似与计算机无关的课，比如工程制图和生物实验等等。虽然国内很多知名高校，比如清华计算机是不修的，但是世界一流大学MIT，Caltech都是有生物必修课。这充分表现了西交与国际接轨，争做世界一流大学的决心。要知道生物作为21世纪的专业，可谓前途无量。虽然西交除了生化实验班之外的生物系学生大多转行了，但未来需要的是计算机和生物的交叉人才，正需要计算机系的学生去开拓和发展。</p><p>4。计算机系经常受到自动化某所的强烈关怀和支持。前任校长郑南宁深刻地意识到，集中力量才能办大事。于是常年把电信学院的经费奋力拨到自动化系，通过自动化系的发展反过来带动计算机系，正契合了天朝早年“先富带动后富”的理念。可以预料，通过院系之间的互帮互助，计算机系必将获得长足的发展和进步。</p><p>5。上课严格考勤。除了某些特殊关照班级之外基本不能出去实习／科研，这充分体现了学校领导关心同学的心。要知道西交计算机教学水平一流，出去实习能学到什么？对于拿到了某些实习offer的同学，学校就会百般刁难，参见<ahref="https://www.zhihu.com/question/281289820">如何看待西安交通大学不断地被黑?</a>某回答，这充分锻炼了同学们艰苦奋斗，逆境求生的品质，而这种精神在同学毕业之后几十年的人生都是非常重要的，凸显了领导眼光的长远。</p><p>6。在编程作业很少的同时，实验和考试则是非常硬核的。楼上有人提到计算机课程电类太多，其实有点狭隘，不才在清华计算机系学习过一年，模电下半学期的电路分析和数电的“数字点亮人生”实验也都十分繁重，而信号与系统是计算机一小半研究方向的必须基础之一，不学就开玩笑了，所以说并没有黑到点子上。而西交的考试要求则更高，动辄成吨的概念题，对记忆力的要求极高，这不仅体现了学校希望将计算机这门学科文科化的创新精神，更是锻炼了同学们的背诵能力。试想别的学校同学还在对着C++官方文档写代码的时候，西交的同学们已经背完了文档，这必将极大地提升同学们写代码的速度和水平。</p><p>7。新任教师基本是本校博士，充分体现了学校的团结。参考<ahref="http://jfzx.xjtu.edu.cn/info/1006/3210.htm">最近三年的新入职教师</a>，之前三年的计算机系，软院的老师多为本校土博，在现在很多二本都要求海归博士的大背景下，西交还能有如此魄力，团结一心，不崇洋媚外，这是何等难能可贵的精神！</p><p>8。在以上这些令人振奋的进步之余，西交的创新港也在如火如荼地建设着。2个月前据某前去规划建设的老师称，一共近5000亩地租出去了3200亩，剩下1800亩尚在建设之中。不得不说学校领导眼光之长远，懂得把经济利益放在第一位，先赚钱再建设，这样才有长远的发展。可想而知，假以时日创新港必将成为下一个曲江校区，为西交之崛起增光添彩。</p><p>以上只列举了西交计算机众多优点中的几个，还有太多可圈可点之处，在计算机学科蓬勃发展的今天，西交计算机必将成为国内一流，享誉世界！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
            <tag> Education </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通货膨胀</title>
      <link href="/posts/inflation/"/>
      <url>/posts/inflation/</url>
      
        <content type="html"><![CDATA[<p>虽然以前辅修过金融学，但是对于许多内容还是一知半解，也很难形成体系。最近又看了一些资料，就作为笔记记录在此。</p><h2 id="定义">定义</h2><p>Wikipedia对于通货膨胀的定义是：</p><blockquote><p>In economics, inflation is a sustained increase in the general pricelevel of goods and services in an economy over a period of time. Whenthe general price level rises, each unit of currency buys fewer goodsand services; consequently, inflation reflects a reduction in thepurchasing power per unit of money - a loss of real value in the mediumof exchange and unit of account within the economy.</p></blockquote><p>直观来看，就是因为货币发行量大于实际流通中所需的货币量，单位货币购买力下降，<strong>物价持续上升</strong>。<br />那么印多少钱合适呢？有这样一个式子： <spanclass="math display">\[流通中所需的货币量=\frac{商品价格总额}{流通次数}\]</span>举例来看：A用1元买了B的面包，B用这一元买了C的牛奶，C用这一元买了A的水果。面包、牛奶、水果的价格总额是3元，流通了3次，所以实际只需要1元就够了。</p><h2 id="作用">作用</h2><p>适当的通胀率(可以用CPI衡量)是可以促进经济发展的，比如适当的物价上涨，你当然希望立即就去购买商品，而不是等它涨价之后再去购买，这样就刺激了经济发展。<br />相反，如果通胀很严重(一般认为大于2%)，尤其是想要通过货币超发刺激经济(货币型通胀)，控制不好就可能成为下一个津巴布韦。<br />再来看看国内的一些例子：2008年全球经济危机，中国为了保持经济高速增长，向市场投放4万亿，货币供给大量增加，所以我总感觉08年之后物价就涨得有点快~地方政府为了拉动GDP，房价一路飙升。大家买不起？没关系，首付少一些，银行多放些贷款，过量放贷导致物价上升。</p><h2 id="例子">例子</h2><p>我们都知道：商品买的人越多，越火，价格也就越高。投机商就会借机涌入市场，因为即使不是刚需，我也可以买一些，等以后涨了再卖出去，这样就可以赚取差价套利。<br />随着刚需和投机商的大量涌入，需求持续增加，远远大于供给，价格继续增长。<br />涨到很多人凭个人收入都买不起，不论刚需还是投机者钱都不够了，怎么办？<br />贷款。<br />银行钱也不够了，怎么办？<br />开印钞机，大家需求这么旺盛，拉动经济的大好机会。<br />大家都有了钱，泡沫持续繁荣，价格越来越高，自己腰包里的钱没有涨，怎么办？只能自己少出一点，多向银行借点，这样等到超出个人的偿还能力，就是<strong>次贷</strong>。<br />地方政府、开发商和投机者赚得盆满钵满，大家一看，卧槽这么赚钱，都把钱扔进了房地产，制造业被挤压的没有生存空间。<br />当房价到顶，大家都绝望的时候，投机商就开始抛售，供给增加，需求减少，价格下跌，这很可能引发经济断崖式下跌，GDP没有了，银行的贷款无法收回，完蛋。<br />那么所谓的软着陆是什么？<br />银行不准借给投机者，刚需的如果不还钱，加入黑名单。还要多把钱借给刚需，如果价格下跌，刚需的钱一定可以收回来。限购令、交税都是为了限制投机商进入。<br />但是房价还不能跌得太快，怎么办？刺激刚需：买房有补贴，首付继续降低。什么？这样还不买，好，不买房的不给上户口，子女不能上学，于是就只能为国接盘，谁的利益受到了损害，这是很明显的事情。这部分需求填补了投机者退出去的那部分，需求还在，就不会暴跌。渐渐地，泡沫消失，一切回归正常。但是这损害了未来的消费能力，再加上老龄化社会到来，前景不容乐观。</p><p><ahref="https://www.zhihu.com/question/19894997/answer/123847049">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Finance </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Economics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image Filter and Recover</title>
      <link href="/posts/image-filter-and-recover/"/>
      <url>/posts/image-filter-and-recover/</url>
      
        <content type="html"><![CDATA[<p>这是CS50的第四次大作业，顺便学习了图像的入门知识。 ## 基础黑白图(bitmap)的每个像素点只能取值0/1，1代表白色，0代表黑色。<br />常见的图片格式有JPEG/PNG/BMP，这些格式都支持RGB，每个像素点可以用多个bit表示，常见的是24-bit，红、绿、蓝分别由8bit表示，范围0~255。<br />BMP图的开始位置有两个header，第一个叫<code>BITMAPFILEHEADER</code>，14B；第二个叫<code>BITMAPINFOHEADER</code>，40B。接下来的每个像素点是按照BGR的顺序存储的。</p><h2 id="过滤器">过滤器</h2><p>ImageFilter就是对原图的像素点的像素进行操作，得到一幅新图。主要有下面几种：</p><ul><li>Grayscale<br />将RGB图变为灰度图。将每个像素点的R/G/B的值改为相同，值越大，亮度越大。一般取三色的平均值。</li><li>Sepia<br />比较像怀旧滤镜，有很多算法可以做，主要就是对3种颜色乘一些系数，做一些加减运算。</li><li>Reflection<br />左右翻转。</li><li>Blur<br />图像模糊，对每个像素点的每种颜色，取其周围3*3格子的平均值。</li><li>Edges<br />边缘检测，可以用Sobel Operator去做：<br />Blur是对周围的格子取平均，Sobel是求一个加权和，对于x和y方向，有两个kernel：<br /><imgsrc="https://img-blog.csdnimg.cn/20200502165239931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br />对每个像素点的每种颜色，用周围3*3格子的对应颜色分别去乘Gx/Gy，得到加权和sumx/sumy。<br />以x为例，如果左右两边差不多，那么加权和接近0，否则得到一个大正数/负数，说明很有可能是<strong>两个物体的分界</strong>。<br />综合考虑x和y方向，取<spanclass="math inline">\(\sqrt{sumx^2+sumy^2}\)</span>，再四舍五入到0~255之间。<br />对于边缘的格子，可以做padding，围一圈全黑(0)的格子，相当于不用计算。</li></ul><h2 id="图片恢复">图片恢复</h2><p>JPEG的前三个字节分别是<code>0xff, 0xd8, 0xff</code>，第四个字节的前四位是<code>1110</code>，这些可以唯一标识JPEG文件。<br />记忆卡上所有图片是连续存储的，最小单位每块512B，不到一块的后面补0，不影响显示，每张图片可能占若干块。<br />可以每次读512B扔到buffer里，如果是jpeg，就将其写入新文件、继续读512B，直到遇到下一个jpeg。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computational Geometry</title>
      <link href="/posts/computational-geometry/"/>
      <url>/posts/computational-geometry/</url>
      
        <content type="html"><![CDATA[<h2 id="线段重叠">线段重叠</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start1 &lt;= end2 &amp;&amp; end1 &gt;= start2</span><br></pre></td></tr></table></figure><h2 id="矩形重叠面积">矩形重叠面积</h2><p>看过某司一道笔试题：给<spanclass="math inline">\(n\)</span>个矩形左下和右上坐标（不能斜放），求重叠最多处矩形个数。<br />这道题本身不难：可以遍历所有矩形边界组成的点，计算<strong>该点被多少矩形包围</strong>，从而选出最大值。<br />由此引申出一个问题：<strong>判断两个矩形重叠</strong>。</p><ul><li>如果正向思考，会有很多种情况：包含、重叠某个角、交叉...</li></ul><p>那么如果逆向思考：什么情况两个矩形不重叠？无非就是<spanclass="math inline">\(A(p_1, p_2)\)</span>在<spanclass="math inline">\(B(p_3, p_4)\)</span>的上下左右： <spanclass="math display">\[(p_1.y&gt;=p_4.y)\vee(p_3.y&gt;=p_2.y)\vee(p_3.x&gt;=p_2.x)\vee(p_1.x&gt;=p_4.x)\]</span>取反后用De Morgan's law化简就是重叠的情况： <spanclass="math display">\[(p_1.y&lt;p_4.y)\wedge(p_3.y&lt;p_2.y)\wedge(p_3.x&lt;p_2.x)\wedge(p_1.x&lt;p_4.x)\]</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">crossArea</span><span class="params">(point p1, point p2, point p3, point p4)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不重叠</span></span><br><span class="line">    <span class="keyword">if</span> (p1.y &gt;= p4.y || p3.y &gt;= p2.y || p3.x &gt;= p2.x || p1.x &gt;= p4.x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右上下边界</span></span><br><span class="line">    <span class="keyword">int</span> x1 = <span class="built_in">max</span>(p1.x, p3.x);</span><br><span class="line">    <span class="keyword">int</span> x2 = <span class="built_in">min</span>(p2.x, p4.x);</span><br><span class="line">    <span class="keyword">int</span> y1 = <span class="built_in">min</span>(p2.y, p4.y);</span><br><span class="line">    <span class="keyword">int</span> y2 = <span class="built_in">max</span>(p1.y, p3.y);</span><br><span class="line">    <span class="keyword">return</span> (x2 - x1) * (y1 - y2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段交点">线段交点</h2><p>联立方程组求解当然没问题，也可以用几何的方法解：<br /><imgsrc="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDQvMTI2MDU4MS0yMDIwMDQyMDA5Mjk1NTI0OS05MzA1Nzg4NjkucG5n?x-oss-process=image/format,png" /><br />易知，<spanclass="math inline">\(\frac{AO}{BO}=\frac{AE}{BF}=\frac{S_{ACD}}{S_{BCD}}\)</span>，两个三角形面积可以用叉积求得，又<spanclass="math inline">\(\vec{AO}=\frac{AO}{AB}\vec{AB}=\frac{AO}{AO+BO}\vec{AB}\)</span>，所以<spanclass="math inline">\(\vec{O&#39;O}=\vec{O&#39;A}+\vec{AO}\)</span>，即可求得<spanclass="math inline">\(O\)</span>点坐标。</p><h2 id="线段覆盖">线段覆盖</h2><p>有若干线段<spanclass="math inline">\([l_i,r_i]\)</span>以及目标线段<spanclass="math inline">\([a,b]\)</span>，需要用尽可能多的线段去覆盖目标线段，且线段之间不相交，线段长度之和最小。<br />直观上看：我们的策略首先以长度为准则：显然不妥，选了黑的就不是最优<br /><img src="https://img-blog.csdnimg.cn/20200729213724839.png"alt="在这里插入图片描述" /><br />按照起始点：<br /><img src="https://img-blog.csdnimg.cn/20200729213754372.png"alt="在这里插入图片描述" /><br />按照结束点：最优<br /><img src="https://img-blog.csdnimg.cn/20200729213857178.png"alt="在这里插入图片描述" /><br />从前向后取区间，最小化对后面的影响，选择最早结束的区间。</p><h2 id="向量旋转">向量旋转</h2><p><imgsrc="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDQvMTI2MDU4MS0yMDIwMDQyMDA5NDU1Mzg4My0xOTgxNzI0NjU3LnBuZw?x-oss-process=image/format,png" /><br />三角变换可得： <span class="math display">\[\vecb=(xcos\alpha-ysin\alpha,ycos\alpha+xsin\alpha)\]</span></p><h2 id="多边形面积">多边形面积</h2><p><imgsrc="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDQvMTI2MDU4MS0yMDIwMDQyMDEwMTQxNjU5NC0xMjc1OTkyNDExLnBuZw?x-oss-process=image/format,png" /><br />三角剖分： <spanclass="math display">\[S_{ABCDEF}=\frac{\vec{OA}\times\vec{OB}+\vec{OB}\times\vec{OC}+...+\vec{OF}\times\vec{OA}}{2}\]</span>即： <span class="math display">\[S=A_n\timesA_1+\sum_{i=1}^{n-1}A_i\timesA_{i+1}=x_ny_1-y_nx_1+\sum_{i=1}^{n-1}x_iy_{i+1}-y_ix_{i+1}\]</span></p><h2 id="凸包">凸包</h2><p>包围所有给定点并且周长最小的多边形。</p><p><imgsrc="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229164832081-268323827.jpg"alt="image" /><br />直接求不好算，需要旋转坐标轴：<br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229164921157-1565408775.png"alt="image" /><br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229164931460-670765424.png"alt="image" /> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloest</span>(<span class="params">self, x, y, l, w, yaw</span>):</span></span><br><span class="line">        <span class="comment"># 原始坐标系逆时针旋转theta = yaw - 90得到坐标系(xx,yy)</span></span><br><span class="line">        theta = math.radians(yaw - <span class="number">90</span>)</span><br><span class="line">        xx = x * math.cos(theta) + y * math.sin(theta)</span><br><span class="line">        yy = -x * math.sin(theta) + y * math.cos(theta)</span><br><span class="line"></span><br><span class="line">        points = [(xx + w / <span class="number">2</span>, yy + l / <span class="number">2</span>), (xx - w / <span class="number">2</span>, yy - l / <span class="number">2</span>), (xx + w / <span class="number">2</span>, yy - l / <span class="number">2</span>), (xx - w / <span class="number">2</span>, yy + l / <span class="number">2</span>)]</span><br><span class="line">        dis = [a ** <span class="number">2</span> + b ** <span class="number">2</span> <span class="keyword">for</span> a, b <span class="keyword">in</span> points]</span><br><span class="line">        ans = points[dis.index(<span class="built_in">min</span>(dis))]</span><br><span class="line">        ans_x = ans[<span class="number">0</span>] * math.cos(theta) - ans[<span class="number">1</span>] * math.sin(theta)</span><br><span class="line">        ans_y = ans[<span class="number">0</span>] * math.sin(theta) + ans[<span class="number">1</span>] * math.cos(theta)</span><br><span class="line">        <span class="keyword">return</span> ans_x, ans_y</span><br></pre></td></tr></table></figure></p><hr /><p><em>reference</em> <em><ahref="https://zhuanlan.zhihu.com/p/68617952">洛谷日报#142计算几何初步</a></em></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 5</title>
      <link href="/posts/interview-5/"/>
      <url>/posts/interview-5/</url>
      
        <content type="html"><![CDATA[<h2 id="笔试">笔试</h2><p>150min，3题，每题100分，自己果然还是个蒟蒻呢~<br />最近状态好差，虽然做了一些题，但还是考得稀烂，大概有几点需要加强：</p><ul><li><strong>独立</strong>做题，不要一边看板子一边写代码，更不要一开始就看题解；</li><li>对之前研究过的一些<strong>专项模板</strong>，要非常熟练敲出来；</li><li>“题海”战术要继续，薄弱算法要<strong>专项练习</strong>：即使内推，也免不了笔试，保持手感很重要。</li></ul><p>先补下题：</p><h2 id="no.-1">No. 1</h2><p><img src="https://img-blog.csdnimg.cn/20200413151415498.png"alt="在这里插入图片描述" /> Pass 90%开始觉得BFS可以做，但不知道怎么写，于是转去从<code>(x-l,y-l)</code>遍历到<code>(x+l,y+l)</code>，写了一下发现<code>l</code>会变，下一轮循环遍历范围可能增大，不知道怎么写下去，又转去DFS，因为DFS每一次递归都可以自动更改<code>l</code>的值，不知道为毛没有AC。其实只要每一次都搜索整个图，去吃满足条件的补给品，直到<strong>剑的长度不变</strong>。<br />我TM竟然没想到用长度作为终止条件，而且暴力时候太谨慎，不敢把整个图过一遍(只有500*500的数据范围啊，蠢哭了)，自己给自己增加难度~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> m, l;</span><br><span class="line">        cin &gt;&gt; m &gt;&gt; l;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(m, vector&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                cin &gt;&gt; g[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l != ans) &#123;</span><br><span class="line">            ans = l;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g[i][j] &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">dist</span>(x, y, i, j) &lt;= l) &#123;</span><br><span class="line">                        l += g[i][j];</span><br><span class="line">                        g[i][j] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="no.-2">No. 2</h2><p><img src="https://img-blog.csdnimg.cn/20200413151429730.png"alt="在这里插入图片描述" /> Pass 10%<br />并查集都能写挂，真无语了。。。唉，菜是原罪<br />后来发现是自己模板有问题，结果一直T：<strong>大多数情况下T的原因不在于输入输出，而在于算法</strong>，血的教训。。。<br />回头看以为是个裸题，但是涉及到并查集的删除操作，索性直接用<code>vector&lt;int&gt;</code>存每个元素到其集合的映射关系，这样看来更是简单(一看到题就陷入树结构的并查集。。。)：<br />做题要看<strong>数据范围</strong>！！！<spanclass="math inline">\(10^7\)</span>普通并查集<spanclass="math inline">\(O(n)\)</span>可以过！！！而且题目很明显涉及到<strong>删除</strong>和<strong>求集合中元素个数</strong>的操作，在树结构的并查集中实现复杂！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            setNum.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (setNum[x] != setNum[y]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; setNum.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (setNum[i] == setNum[y]) &#123;</span><br><span class="line">                    setNum[i] = setNum[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getOut</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>(x) != <span class="number">1</span>) &#123;</span><br><span class="line">            setNum[x] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; setNum.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (setNum[x] == setNum[i]) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; setNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="function">UF <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> op, x, y;</span><br><span class="line">            cin &gt;&gt; op;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">                uf.<span class="built_in">unio</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                uf.<span class="built_in">getOut</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                cout &lt;&lt; uf.<span class="built_in">size</span>(x) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="no.-3">No. 3</h2><p><img src="https://img-blog.csdnimg.cn/2020041315143877.png"alt="在这里插入图片描述" />开始就知道暴力过不了，想着骗点分算了，枚举A的所有错排<spanclass="math inline">\(\{B_1,B_2...\}\)</span>，计算A与B的最小距离即可，不知道为什么WA，结果爆零。。。<br />贴下暴力代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span>  <span class="comment">// INT_MAX</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; w[a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[i]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = <span class="built_in">find</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b[i]) - a.<span class="built_in">begin</span>() - i;</span><br><span class="line">                    cur += w[b[i]] * <span class="built_in">abs</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较正派的做法我有想到一点，不过当时第2题没过，心情有点烦躁，净想着骗分去了~<br />要使<code>dist</code>最小，就要求错排的每个位置移动尽可能少，使得<code>pos</code>之差尽可能小。<br />如果n是偶数，相邻位置两两互换，<code>pos</code>之差为1；<br />如果n是奇数，会多一个奇数位置的坑(有点贪心的意思)，这样必然要有一个奇数位置的数移动2次，当然选择权值最小的那个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">            sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[i] &lt; w[minIdx]) &#123;</span><br><span class="line">                    minIdx = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += w[minIdx];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试">面试</h2><p>收到面试通知很意外，唯一一个机会，还是面的完爆了呢。<br />这几天一直在看面经，说实话不难，而且很多人都没手撕代码，就有了侥幸心理。。只看了面经的代码，easy的题目都没有做出来。<br />第一次真正面试中写代码，紧张情绪下与平时状态完全不一样，第一次理解错题意，也没有确认就开始写，写完后才发现搞错了。。。<br />不知道是面试官表达能力有问题，还是我理解能力有问题，从一开始的基础知识、到后来的智力题、再到编程题，五次三番误解他的意思，总之聊的很不愉快！！！面试有时候也看运气吧~<br />简单做个总结吧：</p><ul><li>回答问题、手撕代码前一定要问清楚！！！！确认函数签名等细节，还可以先描述下自己的思路；</li><li>只看面经不行，复习范围很局限，还是要系统学习、疯狂练习，平时有100%状态，面试才可能有70%状态；</li><li>多参加面试，锻炼下高压下的思路和码力，任何时候都要冷静分析。</li></ul><p>很难过了，后面应该还会再投一些公司吧。</p><p><ahref="https://www.zxpblog.cn/2020/04/11/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E7%AC%94%E8%AF%95-2020-4-11/">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TOP-K Problems</title>
      <link href="/posts/top-k-problems/"/>
      <url>/posts/top-k-problems/</url>
      
        <content type="html"><![CDATA[<h2 id="最小的k个数">最小的K个数</h2><ul><li>直接数组排序，取出前K个。复杂度<spanclass="math inline">\(O(nlogn)\)</span>。</li><li>分治<br />此题只要求出最小的K个数，并不要求这K个数有序。<br />我们可以借鉴快排中的<code>partition</code>做法，将比第K个数小的都放前面，其余都放后面，即得到答案，但是这种方法会<strong>改变原有数组</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">        <span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                end = index - <span class="number">1</span>;</span><br><span class="line">                index = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                start = index + <span class="number">1</span>;</span><br><span class="line">                index = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(<span class="built_in">begin</span>(nums), <span class="built_in">begin</span>(nums) + k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>() || l &lt; <span class="number">0</span> || r &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> pivotIndex = <span class="built_in">randomNum</span>(l, r);</span><br><span class="line">        <span class="built_in">swap</span>(nums[pivotIndex], nums[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> smaller = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[r]) &#123;</span><br><span class="line">                ++smaller;</span><br><span class="line">                <span class="built_in">swap</span>(nums[smaller], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++smaller;</span><br><span class="line">        <span class="built_in">swap</span>(nums[smaller], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> smaller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));  <span class="comment">// use system time as seed</span></span><br><span class="line">        <span class="keyword">return</span> x + <span class="built_in">rand</span>() % (y - x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以得到递归关系：<spanclass="math inline">\(T(n)=T(n/2)+n\)</span>，由主定理可知复杂度<spanclass="math inline">\(O(n)\)</span>。<br />与快排不同的是：快排要处理2个子问题，故为<spanclass="math inline">\(T(n)=2T(n/2)+n\)</span>，复杂度<spanclass="math inline">\(O(nlogn)\)</span>。<br />关于复杂度，还可以用代入法证明： <spanclass="math display">\[T(n)=T(n/2)+n=T(n/4)+n/2+n=T(n/8)+n/4+n/2+n=...\]</span>重复k次后： <spanclass="math display">\[T(n)=T(n/2^k)+n/2^{k-1}+...+n/2+n\]</span>故：<span class="math inline">\(T(n)=n+n/2+n/4+...+1=2n+1\)</span></p><ul><li>堆/红黑树<br />主要思路是用容器存储K个数，之后不断更新：如果当前值小于容器最大值，替换最大值。<br />用最大堆作为容器，删除及插入<spanclass="math inline">\(O(lgk)\)</span>，故总复杂度<spanclass="math inline">\(O(nlgk)\)</span>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// max heap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">priority_queue&lt;<span class="keyword">int</span>&gt; <span class="title">topKMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(*it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.<span class="built_in">top</span>() &gt; * it) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">push</span>(*it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然也可以使用红黑树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        multiset&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; ms;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ms.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                ms.<span class="built_in">insert</span>(*it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (*ms.<span class="built_in">begin</span>() &gt; * it) &#123;</span><br><span class="line">                    ms.<span class="built_in">erase</span>(ms.<span class="built_in">begin</span>());</span><br><span class="line">                    ms.<span class="built_in">insert</span>(*it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(ms.<span class="built_in">begin</span>(), ms.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之所以说这种解法适用于海量数据，是因为很多时候不能一次性把数据读入内存处理，这种解法可以从硬盘一次读一个，判断是否放入容器即可，只需要在内存中存储容器即可。</p><h2 id="最常出现的k个数">最常出现的K个数</h2><ul><li>统计出现频率，按频率排序后取出前K个。复杂度<spanclass="math inline">\(O(nlgn)\)</span>。</li><li>小根堆。维护K个数，如果新数的频率大于堆顶，替换之。复杂度<spanclass="math inline">\(O(nlgk)\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ++cnt[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : cnt) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(p.second, p.first);</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;++i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().second);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>快速选择。</p></li><li><p>桶排。用很多桶记录不同频率到对应数字的映射。时间<spanclass="math inline">\(O(n)\)</span>，空间<spanclass="math inline">\(O(n)\)</span>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxFre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            maxFre = <span class="built_in">max</span>(maxFre, ++cnt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; bucket;  <span class="comment">// freq -&gt; nums</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : cnt) &#123;</span><br><span class="line">            bucket[p.second].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = maxFre;i &gt; <span class="number">0</span>;--i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a : bucket[i]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(a);</span><br><span class="line">                <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Egg Dropping Puzzle</title>
      <link href="/posts/egg-dropping-puzzle/"/>
      <url>/posts/egg-dropping-puzzle/</url>
      
        <content type="html"><![CDATA[<h2 id="the-two-egg-problem">The Two Egg Problem</h2><p>曾经是Google的一道经典题。<br />题意：有一个百层高楼，鸡蛋在<spanclass="math inline">\(L\)</span>层及以下扔都不碎，在<spanclass="math inline">\(L\)</span>层以上都会碎。现在某人有<spanclass="math inline">\(k\)</span>个鸡蛋，问在<strong>最坏情况下</strong>，至少扔多少次(用<spanclass="math inline">\(m\)</span>表示)可以确定<spanclass="math inline">\(L\)</span>的值。<br />分析：先来考虑<spanclass="math inline">\(k=1\)</span>的情况。只有1个鸡蛋，为了得到一个确定的<spanclass="math inline">\(L\)</span>，只能从第一层开始，逐渐尝试增加楼层高度，因此<spanclass="math inline">\(m=100\)</span>时，无论<spanclass="math inline">\(L\)</span>的值是多少，都可以被确定。<br />再来考虑<spanclass="math inline">\(k=\infty\)</span>的情况。这种情况就变为了binarysearch的问题，先拿一个在50层扔，如果碎，则在25层扔；如果不碎，则在75层扔...即<spanclass="math inline">\(m=7\)</span>。<br />最后来考虑<span class="math inline">\(k=2\)</span>的情况。因为<spanclass="math inline">\(k=1\)</span>只能一层一层试，所以第一个鸡蛋应该尽可能缩小搜索空间，但是如果第一个鸡蛋的楼层间隔太小(比如在2层、4层...)，无疑会增加<spanclass="math inline">\(m\)</span>。不妨取第一个鸡蛋在10层、20层...，共10次；假如第一个在10层没碎，在20碎了，那么第二个鸡蛋可以尝试11、12...19，共9次；故<spanclass="math inline">\(m=19\)</span>。<br />上面方案的问题在于：如果临界楼层比较高，那么第二个鸡蛋的次数是确定的，但第一个就需要多试几次，总次数就会增加。<br />那么如何使得不论临界楼层在哪，<spanclass="math inline">\(m\)</span>的值都不会波动呢？<br />很简单，只要第一个多扔一次，确定的范围(第二个要试的次数)减小，总次数就会均衡。<br />对于第一个鸡蛋，第一次在<spanclass="math inline">\(a\)</span>层扔，如果不碎，第二次向上增加<spanclass="math inline">\(a-1\)</span>层...直到最后只向上增加<spanclass="math inline">\(1\)</span>层：<spanclass="math inline">\(a+(a-1)+...+1\geq100\)</span>，故<spanclass="math inline">\(a\geq13.7\)</span>。<br />鸡蛋一：在14层、27层、39层、50层、60层、69层、77层、84层、90层、95层、99层、100层扔，共12次；<br />鸡蛋二：如果蛋一在14层碎了，蛋二要扔13次，共14次；如果蛋一在27层碎了，蛋二要扔12次，共14次...故<spanclass="math inline">\(m=14\)</span>。</p><h2 id="super-egg-problem">Super Egg Problem</h2><p>对于<spanclass="math inline">\(k=2\)</span>，我们有了一个比较好的解决方案。那么现在有<spanclass="math inline">\(k\)</span>个鸡蛋，楼高<spanclass="math inline">\(n\)</span>层，<ahref="https://leetcode.com/problems/super-egg-drop/">问题</a>(记作<spanclass="math inline">\(m(k,n)\)</span>)又该如何解决？<br /><span class="math inline">\(k=1\)</span>和<spanclass="math inline">\(n=1\)</span>的情况比较简单： |n1|2|3|4|...||--|--|--|--|--|--| |1|1|1|1|1| |2|2| |3|3| |...| |那么如果我们递归地思考：任选一层<spanclass="math inline">\(h\)</span>扔第一个鸡蛋，无非有碎和不碎2种情况：<br />碎：临界楼层在1~h之间，问题规模缩小为<spanclass="math inline">\(m(k-1,h-1)\)</span>；<br />不碎：临界楼层在h~n之间，问题规模缩小为<spanclass="math inline">\(m(k,n-h)\)</span>。<br />所以：<span class="math inline">\(m_h(k,n)=1+max\{m(k-1,h-1),m(k,n-h)\}\)</span>。<br />对于<spanclass="math inline">\(h\)</span>，可以采用枚举的方法，计算<spanclass="math inline">\(m_h(k,n)\)</span>，在其中选出一个最小的值，故问题得到解决：<span class="math display">\[m(k,n)=min\{m_h(k,n)\},h=1,2,...n\]</span>Base Case就是<span class="math inline">\(k=1\)</span>和<spanclass="math inline">\(n=1\)</span>。<br />时间复杂度<span class="math inline">\(O(KN^2)\)</span>，空间复杂度<spanclass="math inline">\(O(KN)\)</span>。<br />记忆化递归：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">memo</span>(K + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(K, N, memo);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[K][N]) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[K][N];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;++i) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">superEggDrop</span>(K - <span class="number">1</span>, i - <span class="number">1</span>), <span class="built_in">superEggDrop</span>(K, N - i)));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[K][N] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述最直观的解法复杂度太高，无法通过Leetcode的数据。如何优化呢？<br /><spanclass="math inline">\(m(K,N)\)</span>表示该问题的解，如果鸡蛋数<spanclass="math inline">\(K\)</span>固定，随着楼层数<spanclass="math inline">\(N\)</span>增加，问题的解一定是增加的。<br />我们又把问题分解为了2个子问题<spanclass="math inline">\(m(k-1,h-1)\)</span>和<spanclass="math inline">\(m(k,n-h)\)</span>，<spanclass="math inline">\(m(k-1,h-1)\)</span>随<spanclass="math inline">\(h\)</span>单调递增，<spanclass="math inline">\(m(k,n-h)\)</span>单调递减(<ahref="https://zhuanlan.zhihu.com/p/92288604">图源</a>)：<br /><imgsrc="https://img-blog.csdnimg.cn/20200319150302530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br />此时<spanclass="math inline">\(min(max(...))\)</span>就是求中间的折点，可以使用BinarySearch，时间复杂度降为<spanclass="math inline">\(O(KNlgN)\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">memo</span>(K + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(K, N, memo);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[K][N]) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[K][N];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = N + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> broken = <span class="built_in">helper</span>(K - <span class="number">1</span>, m - <span class="number">1</span>, memo), noBroken = <span class="built_in">helper</span>(K, N - m, memo);</span><br><span class="line">            <span class="keyword">if</span>(broken &gt; noBroken) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="number">1</span> + broken);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="number">1</span> + noBroken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        memo[K][N] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，此题还有<spanclass="math inline">\(O(KN)\)</span>的做法，甚至还有一种数学做法可以达到<spanclass="math inline">\(O(KlgN)\)</span>的时间复杂度和<spanclass="math inline">\(O(1)\)</span>的空间复杂度，由于本人水平实在有限，就不再探索。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>风雨混沌 曙光难觅</title>
      <link href="/posts/where-is-dawn/"/>
      <url>/posts/where-is-dawn/</url>
      
        <content type="html"><![CDATA[<p>懵懵懂懂的少年，夏日刺眼的阳光，还有，操场飘飞的国旗~</p><blockquote><p>我志愿加入中国共产主义青年团</p><p>坚决拥护党的领导</p><p>遵守团的章程，执行团的决议</p><p>履行团员义务，严守团的纪律</p><p>勤奋学习，积极工作</p><p>吃苦在前，享乐在后</p><p>为共产主义事业而奋斗！</p></blockquote><p>那时的我，有着初中生独特的稚气，涉世未深，但满怀激情。</p><p>并不太理解口中的誓词，但仍然高举右拳。声音高亢洪亮，目光笃定坚毅。</p><p>虽渺小，却坚定。我相信，风雨永远阻挡不了彩虹！</p><p>可是，成长了七年之后，我却愈发难以判断这个世界的真伪！</p><p>因为我的认知已经被完全颠覆 <imgsrc="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200320115313972-500146240.png"alt="img" />一个无数青年向往的团体，千千万中国学子的梦想源地，究竟都在做些什么？</p><p><strong>或许这再也不是我熟悉的那个共青团了，永远都不是了。</strong></p><p>北京，中产，却连自己的孩子都保护不了。</p><p>祖国的花朵还不曾来得及绽放，就已烙下了深深的童年阴影。不久后，事情不了了之的时候，那些所谓的“叔叔医生、爷爷医生”会逍遥法外（如果还有法律的话），继续它们的生活，仿佛从未出现一样......可是受伤的心灵又由谁来抚慰呢？</p><p>【我有一个长长的望远镜，一直能伸到你的家里，你说什么话做什么事，我都知道。】</p><p>略显艺术的欺骗，让人恐怖、胆寒。</p><p>长长的望远镜难道不应该用来看星星吗？</p><p>事后，有人冷眼相望，有人造谣撞骗，有人疯狂洗地......</p><p>很欣慰的是：<strong>正义永远不会缺失。</strong></p><p>很多媒体人，顶着压力去探求真相；很多明星，站出来追问谴责；很多你我一样的普通人，持续关注着后续进展，尽力去捍卫孩子们的权益。</p><p>我说，很温暖，谢谢你，谢谢你们！ <imgsrc="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200320115322124-352552867.png" />前苏联总理Nikolai Rizhkov在反省苏联垮台时曾说：</p><blockquote><p>我们监守自盗，行贿受贿，无论在报纸、新闻还是在讲台上，都谎话连篇，我们一面沉溺于自己的谎言，一面为彼此佩戴奖章。而且所有人都在这么干，从上到下，从下到上！</p></blockquote><p>很失望，很愤怒。</p><p>但我想，重要的是：</p><p>在洞透人性的善恶后，我们依然渴望曙光，那是对生命的尊重！</p><p align="right">写于2017年11月29日，知乎</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Volunteer Teacher</title>
      <link href="/posts/a-volunteer-teacher/"/>
      <url>/posts/a-volunteer-teacher/</url>
      
        <content type="html"><![CDATA[<p>“支教是我一直以来一个小小的梦想，我渴望告诉孩子们外面的世界，渴望让他们学会感恩，学会如何去爱。”</p><p>大一暑假，爱心社面试中，我如是说道。</p><p>之所以对支教有如此深的执念，大概是由于我真切地体会过教育资源的不公，体会过乡镇学校与城市学校巨大的差距吧。</p><p>抛开师资以及硬件设施，单就视野而言，乡镇的学生就已经错失了很多机会，也许你在某一方面有些天赋，但却没有触碰的可能。有的人已经凭借出色的OI成绩保送时，我却不知道什么是信息学竞赛；有的人通过自主招生降分录取时，我才发现自己无处准备，乏善可陈。</p><p>而现在，我一定尽力把精彩的世界展现给他们，用“科技之光”和“趣味地理”两个主题唤起孩子们的向往，激励他们去努力。</p><p>对我而言，支教的目的并不在于教会孩子们每道题目的解法，而是要在他们幼小的心里埋下一颗种子，一颗梦想、未来与希望的种子。哪怕将来只有一粒种子生根、发芽，我也觉得不枉此行。</p><p>我从未思考“支教有意义吗”这样的问题，因为</p><p><strong>很多事情需要你亲身经历，才能找到其中的意义。</strong></p><hr /><p>回来之后写的总结</p><h2 id="心之所向-即是光亮">心之所向 即是光亮</h2><blockquote><p>——XXX初中支教总结</p><p>此去有泪，了无遗憾。转眼就是三天，此刻，在透亮舒心的图书馆，我一遍遍忆起你们的样子，也回味着自己的影子，我想用最华丽的篇章来写下属于我们的故事。</p><p>能一步步走到今天，得感谢曾在我生命中闪亮、发光的每个人。他们有的，我清楚地知道是谁，什么关系，而有的我甚至都叫不上名字，留下的也许只有一抹瞬间，一个背影。他们闯进你的生命里，然后转身匆匆就走。颇具戏剧性的是，我可能连偿还他们的机会都不曾有过。所以我唯一可以做的就是：怀着一颗感恩的心，将这份爱心传承下去，这大概就是人生的意义所在了吧。</p><p>幸运的是，上天没有辜负我的心愿；而我，亦没有辜负自己。</p><p>史乡虽小，却足够温馨。我们自己“筑巢”，赶集买菜；掐着手表上课，生怕错过每一分的精髓；笑着和你们打闹，生怕留下一丢丢的隔阂……</p><p>素质拓展，我体验到了如此强大的班级凝聚力。扬起的灰尘，只是我们荡漾青春的背景；燥热的酷夏，带给我们永无止境的激情。一站到底，我感受到了如此强烈的知识渴求。能载着你们遨游知识的海洋，领略大千世界，很欣慰，很幸福。联欢会，我无语凝噎，只好用心倾听，倾听你们欢歌下隐藏的淡淡的哀伤。</p><p>所幸，我见证了一切。见证了史乡之夜，你们那么努力地写下自己的心愿，载着孔明灯，渐飞向那天际。你们可曾知道：用梦想点缀的夜空有多么浪漫吗？见证了细雨之下，我们那么温馨地挤入同一把小伞，漫步在湿滑的街边。你们可曾知道：这么温情的陪伴有多么感人吗？见证了篝火晚会，我们那么嘶哑地唱着班歌，伴着声声蝉鸣，飘向广阔的麦田。你们又可曾知道：这么真实的倾诉有多么难得吗？</p><p>故事很多，却不敢一一道来，因为我怕自己陷入回忆的漩涡而难以自拔。短暂的时光，我甚至不曾来得及想象别离。不知道我的心愿是否给你们带去了哪怕一丝丝光亮，史乡的我们很幸福，但我不想只是怀念你们那时的笑靥，我更渴望看到你们未来的欢喜。</p><p>我讨厌离别，但故事却终将结束。如果，这段相遇的过往是岁月的恩赐，那么，你们，一定是上苍派来的最美的天使。虽然我从未见过天使，但我想，你们就是她在人间的名字。当最后，我们的眼泪不约而同地掉落，我许下了承诺：不久就重逢。愿那时，也遇到同样美好的你们。</p><p>生命的长度很难去拓展，但宽度却由我们自己决定。支教不过一个小小的心愿，但其蕴含的精神震撼却挥之不去，深深烙在了脑海。</p><p>“真正的平静，不是远离车马喧嚣，而是在心中修篱种菊。”这短暂而又漫长的生活，当生活赋予无限的压力时，当痛苦悄然降临时，愿我也能守住自我，守住内心。对我而言，公益的脚步从未停止，我想趁着年轻，尽情绽放！</p></blockquote>支教期间写的推送：<br /><ahref="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929900&amp;idx=2&amp;sn=6e36434e4664cd3e82912240136679f7&amp;mpshare=1&amp;scene=1&amp;srcid=1027ug4p7BJeIVmoWGS73wpX#rd">【弦歌史乡】许你夜空中最亮的星</a><br /><ahref="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929882&amp;idx=1&amp;sn=4ae30cb4c297a7abac52c2b9a2ecbaef&amp;mpshare=1&amp;scene=1&amp;srcid=10270FdciDePyzqf4Fu4wD8T#rd">【弦歌史乡】许你夜空中最亮的星</a><br />小伙伴们写的 <ahref="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929840&amp;idx=2&amp;sn=633f9339c32983a3cee2004e63bef309&amp;mpshare=1&amp;scene=1&amp;srcid=1031zCbbE172mOWeZKj4vUId#rd">【手拉手系列】弦歌史乡</a><br /><ahref="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929845&amp;idx=1&amp;sn=2550b5901dcbcf939132c8314d83fb5d&amp;mpshare=1&amp;scene=1&amp;srcid=1031SLclYWY2gEysGRqYqkZ0#rd">【弦歌史乡】惟愿给你们最缤纷的万花筒</a><br /><ahref="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929855&amp;idx=1&amp;sn=e3526c7cea74f4e29f1946c0d50fd109&amp;mpshare=1&amp;scene=1&amp;srcid=1031Q7f8QOZm9TskDsELKKHD#rd">【弦歌史乡】放眼看世界</a><br /><ahref="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929858&amp;idx=1&amp;sn=94eed8f13d7b6e3445c7e677377c58e3&amp;mpshare=1&amp;scene=1&amp;srcid=1031tbnwMYimOjyxMvigSkg6#rd">【弦歌史乡】《哥哥姐姐们，请你们不要再来支教了》之问</a><br /><ahref="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929873&amp;idx=1&amp;sn=89047f782ca2d10d4954cc2aba42d3b6&amp;mpshare=1&amp;scene=1&amp;srcid=1031YjO6PqJX7cik00q5zMZ4#rd">【弦歌史乡】风雨无阻，我们陪你们回家</a><br /><ahref="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929900&amp;idx=1&amp;sn=eb3445881fe1d1a13662ae097afcb0de&amp;mpshare=1&amp;scene=1&amp;srcid=1031KbjExxgjiPZrkIhPqgVD#rd">【弦歌史乡】如果我们不曾相遇</a><br /><ahref="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929904&amp;idx=1&amp;sn=efb1e2807e0527791e101435a74b2bb8&amp;mpshare=1&amp;scene=1&amp;srcid=1031dPimn6zynOREw3CoOA3r#rd">【弦歌史乡】离而欢歌</a><br /><p align="right">写于2017年11月1日，知乎</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Football Memory</title>
      <link href="/posts/football-memory/"/>
      <url>/posts/football-memory/</url>
      
        <content type="html"><![CDATA[<p><img src="1.png" />以前，觉得自己是因为单纯喜欢足球这项运动，所以才会一直坚持去踢。</p><p>后来，逐渐处于“半退役”状态时，才体会到“兄弟”一词于我的意义。</p><p>高一开始接触足球，然而并没有一见钟情，只是当做普通的体育课去完成。</p><p>那年巴西世界杯，用手机看文字直播，糟心极了。也说不清喜欢哪个队，只知道德国和西班牙很厉害。</p><p>高二下学期，偶然的机会，从乒乓石台偷偷遛到球场，落日的余晖下，打进一球，彻底点燃了我对足球的热情，从此一发不可收拾，结下了难解之缘。<img src="2.png" alt="美妙的足球场" />曾在滂沱的大雨中，注视着足球，卷带着雨水，缓缓窜进球门，我们相佣而呼，忘情庆祝；也曾在似火的的骄阳里，与汗水共舞，祈求一丝微风，带走难耐的酷热……</p><p>念念不忘那场7:1的巅峰，横扫高三四班的荣耀。上场前的不自信，场边的呐喊助威，场上的互相呼应，整个班级凝聚得令人生畏，我们不惜体力地跑动围抢，仿佛是用生命在战斗。</p><p>进球的场景已经略显模糊，只记得中场有一脚逆天的左脚吊射，让所有人瞠目；</p><p>我通过一粒点球上演了“职业生涯”第一次帽子戏法，7:0。</p><p>老师在最后时刻接门将长传，禁区角左脚凌空爆射破门，一脚“天外飞仙”将比分定格为了7:1，那粒进球被我们啧啧称道了整整一年，直至毕业以后。</p><p>比赛结束以后，我很激动，前所未有的激动，很想去拥抱兄弟们，感谢他们的努力。之后的生物课根本没怎么听课，脑子里全是胜利的喜悦。<img src="3.png" alt="仅存的足球记忆" />那些简单而又纯粹的岁月里，买不起专业的球鞋，也没有华丽的配合，比赛中踢出一个简单的二过一都会回味很久很久。突破、盘带、射门，都没有系统地训练，我们有的，只是一腔热血。<img src="4.png" alt="当年的球鞋" />旺盛的精力至今想来都很可怕，我们可以不吃不喝，从中午12点一直踢到晚上9点。传球、射门、分边，下底传中、突破过人，浪费了好机会之后，也会“开飞机”谢罪，丝毫感受不到疲倦。</p><p>一年多的时间里，玩坏了好几个球，足球几乎是那个时候最爱的放松活动。</p><p>很难形容喜爱到了什么程度，晚上睡觉都在想着该怎么传球。早操后最喜欢讨论的不是数理题目，而是国际足坛谁最厉害。</p><p>也曾通宵去看西班牙国家德比，三个人挤在一张床上，巴萨2:1赢了皇马，感慨苏亚雷斯的强大以及布拉沃的神勇，第二天早起昏昏沉沉去吃早饭的样子还历历在目。</p><p>总是在班级的报纸上寻找关于足球的新闻，仅有的几本足球杂志不知道翻了多少遍，成为了午饭时唯一的消遣。</p><p>后来无数次想要重拾那感觉，却再也找不回来了。不论是重回高中的球场，亦或是穿上高端的球鞋，还是拥有高水平的队友……<img src="5.png" alt="重回高中球场" />后来快要毕业之际，我们买了四件皇马球衣，两黑两白，甚是吸引目光。</p><hr /><p>我们，也曾少年！</p><p>唉！这tmd的青春啊！</p><p>不由得又想起了之前的一个故事</p><blockquote><p>十多年前，我读高中，同桌是个安静漂亮的姑娘，很是喜欢我，但也许是启蒙过晚的原因，我对她熟视无睹，我唯一的爱好就是踢球，而她唯一的爱好就是看我踢球......</p><p>我当时非常喜欢德国队，不厌其烦地向她灌输金色轰炸机如何厉害，哈斯勒如何牛逼，虽然她听不懂，但还是安安静静地看着我，眼含笑意。</p><p>时光荏苒，当德国队折戟法国世界杯的那个夏天，我高三已经快毕业了，临别那天，我送了一张克林斯曼的明信片给她，她满心欢喜，毕竟三年来我第一次送她东西......</p><p>慢慢的，克林斯曼从球员变成了教练，我大学毕业、工作、应酬，整日在推杯换盏中虚与委蛇，不知不觉间很多人和事情都已淡忘，只有看球的时候偶尔也会想起当年同桌的她。</p><p>去年春节回家，无事可做，决定去踢踢球，结果没跑几步就气喘吁吁，索性坐在场边看其他人踢，看了一会儿，视线被一个身穿德国队18号球衣的孩子吸引了，感觉这孩子盘带、传球很有章法，趁那孩子休息的时候，我主动过去和他攀谈起来。</p><p>“踢得不错嘛，几岁了？”</p><p>“8岁了。”</p><p>“踢这么好，平时没少踢吧？”</p><p>“平时没怎么踢，我爸爸不喜欢我踢球，说踢球没用。”</p><p>我一愣，顿时接不上话，气氛显得有些沉闷，我换了个话题。</p><p>“你喜欢德国队？”</p><p>“嗯。”</p><p>“那你最喜欢德国队哪个球星？”</p><p>“克林斯曼。”他不假思索地回答道。</p><p>“嘿，你也知道克林斯曼啊？”我顿时来了兴致。</p><p>他骄傲地回答：“当然了，我妈妈有一张他的明信片，她说克林斯曼是金色轰炸机......”</p></blockquote><p align="right">写于2018年1月20日，知乎</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Senior Year</title>
      <link href="/posts/senior-year/"/>
      <url>/posts/senior-year/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="03390f4d269e1e34c9267c1542cf0506065c9af650aa2dbfb3f77f181f726b5c">c172f4ee74b2b6d246b20cbfdc0b877ed71a37ad3f3dc5c83807f39da0639778285ce6c8953780dda0003c3ae6e46404b484c83d52214fe291ecb618e22e87c3a4a9151beb371c63500725c8c540eaceb89628e679f98babba0660c82f6118ec74977b1961d1c5e926029346925c4b6f2b76a2ffdd2e5be9cb5da96fb5ef1623ae75f571a19eadc2b1147b36608fa7bec03cd81c230e77b3ef3d68b4a009c1bc9caaa970505d4e0e78df64e21cafabd0f9e64f110d7935d1ffbe99178d426f422f2112216e691d4dd830d0b05054d024da40adab5df2c523fdbf33c084f63514ded2166f7cba980479cbe3df4626a3948fbe8de1da8d635b05ee27727c72fbcdb86609d343c9285a02af29ae94a3331e270e380caf9b345323d2e14565ee6307921ac48304048e7a9a0a4d601b2b69d62ed76eae443a4236963b3e390b0a4deeb9b3e334478a830b87d53ab7f42b24ce828d303584b049d0a752a30cf06c6824ab9ec7c12c42ade026e04af427491fec61f9416df61df88cdd05dd9def8758fcf427a2ccaafa21393346af45471a65f409adb60627221999b2c9f71fbfaac769800fe1d12cf140d4b639b43f684713d5db0aab2d530b679789d01002befcd08b0ccd8aadccbe1e3589b053211ef05004c224bf96bc6c82691d202ed03ab6ce48e19183b2c3f118c0c63089cd91d7b7e747cf58395019d029cc1ccb1e3e2aa8c29a62ebc2449494830cf46a8ef11f1b3643ba0ee3dda370fa5a4f4e3f9fc2471d68f44ca9ae697d79efd33dd3ddf71f096b99d5941e3ab56680313a99b9e4b92123d992f0ec6393a1a19cda4b2a3295900f30e811eda87f0a036c5f29e6a2a04b18cdae931f168c86c41837826847489f981c346b31054dbc3312ec9363c17f673d37b930385682ac5420d6e39499b40e00c7a029f00c4c18e59942e0ffd91008df3492f1026f365b821defabf5c9429eeeb4c28668cc2e5d4ef96391e446986b5c1bc116938a153d9b8a0ed5525cb8df8b4b31b29b44f577dff7433162ff264f1915c293546eae53a7367dd9738d626cba0f51271552ab718660dde9a70d061d8c2ef27e4f739c0ad0ea36a0cf6fafc94812449da1bab50e67652370bae7104dcf9087eca9606527f88efdb3dccc2b63e7035d8507b9ef34609a547ebb91bc9ba102f47c876937fef1001d3289c634bcc0c08dde8470d917e1956856802f184cedbc09febb3105bad0788fb2c3ca3ad3f36dfeaea2b78caaf5e60dc71169cdcfe175bfea5bd559a7f6b676afbff0350e61eb39cd33285b93624699a158076a64b97336a8623a1e32deecae0b24b2d24a9f891b5bf9a362d382b261af9f87849f0cbf2b58487a72a4351e75cb8e819c6a9193e2ac85c22f0072753e9d6f14fe7a068ac0603f45c95e257198a4b9ea9ad3bcad702a699ef164bcb13d45e17999e5c16a853a5c5f521dc4e0690db21580477ae9de7418e7e2324ea6d87fcb580ab2bf53f918a327b9013ec2ab2c690ea4fa3261bd0ae364bbb094374fdc68a83639500690f6728aca28a3a789fa06de1d33723fad6f8486c90ee0bba55542daeacc05b77f4ba1937f917c83cc1e290b0cd2187d234d9b386f6aae7e725341840deee428037290c3e192e99a35354dec276af8850b67aad26eb32d1ac51f93d86309972e930ff2e3135b9b5f4a1bfdb483f3c0303a8760910dab1c46d993ca374f3fbe073568a2f9c9849327a41602c4ec3940b4b48a2320789fba61c0ca97b4e7b186c5bf963c62b5cc8b583e5d689f0c83f34c0a92333aa53093492e067b30ba571c46d0e194dfd1da82539b8e77d406c6df24fb64204376017431f55c6a6099cb695af165170dad0c57a5977b94076cdbd5b238bc566d3773d192bbd4688dd3a9e4c717323407036624d61bae4f82299717ef4db2beafe6c09a51e2982a3b71a9317e5489486a6bd01f6923156e0dfc6f04e874c287534efb52f8bda0b428d309e5c0c7a308867e1c251748d9e6fa4ba1cd494564f7f670fe2119790cd1c5094c4596bbecbc1004a6f22321cf121e16c2362738d053ec12decb06198a10cbec7c038e7d953a4e133ee451f00c523e292372b9bd2cfc06ea52ce0f4d15cb59071204b0d9609433c5ab270e9b39f54679bf3f4d41c4c257daa706d13832c48439ef4d16d1bd964d30e2fede7c962494e70c75b3505a0168f687f70a38cd8a0c4367a38dd00b7f120a4af9ca0605d1d1e4b31bad205b7cc4f3d77a116f6cca14c46ff0a225b995eec456760cd2c2b85402aa49d24c6142dcc2f9fa4ad76b4d56e47e89d3139044e27454002b9208e114f2ad8b5c1c3edd52467ad9a65e01957217d6012c0810062f1b65b98e2d010807855ac2b8a09d7637f00fdec8295e704a6f8b5b3804bc70427a821bcb068f961553c76b22536d0ebeb89b671d88ac9a49f8643f717605cb0a8ad9b5d539444e5fa123ec227b9ac5dc204e604d30fab8f5fc5eb91c32110d0eb6c3bc02f24a8c60ab74df2c1b0ae2fef5040663d1f6182030984428633aa2bd60650b08a1ade6e2e547054dd0ec7b687d997b251bec063b856430a19f698552dd3f65b79029315e486e334b83cfc45e208c7a6cc85db83add8a11d28367a0e94836879e531cc916dc33d7839a92e3c537770e2774f4711487cdc263c2916f6a09f0bd23d390a3f3f113e84af944aff13d4193444be1dc0da89c46cede7b7a2225cb31bfb3fd5519e2716efe996939ba27369af8f8837a2a3413f945b37814c97c6c690b05663d74905fd6b3585889891192a7995d76a6087d251a83dc8243ee1785c3a56e871f0394eb78ca543f9f93f86372785b117b97fc095302dbaed1409eb1d8531b8880aabad074da66f72f8ca6e7370e23f92c9a01973d2f1997a3cd7ffc7f70e1080e09886f7054ad9bc4ea338114b581141a549b1d8124178ac8e964219e56f23daf4038d89e8b4d96e5d79e4642b468c308d6c7ea78f850aed8a41ade1471415423adcf132d88622247d2632f702fb7300fa6ad14b0528a3e9a6838a99cada8d156b035ed081767a477c9ea4df50a8a6957f8af1f7ba0cd82ba3a4f28eceb5c3a90201d13788f100f291f48805de5c1a4c9fe38320cf860cf432aa5dd6b3dd0386d45e1e9978c0c1c8f67351855c5ac8861d1ad2f006d4257e6aa62cf4bed0dd28d8a4f017e962a97886c120444de31d886353e34b27d4fbe0270c0f0ed498fe4ad422455b24a4adf5ead5788050dc2763e2b7be6f39fa51a3dedbecda609d75bf7f6414a10c6c2f35fba7a929993aca918a1ebde4d8dc59200a3d4df283a34d123cb2cc895513b31a4d3b5e93ed82ab8cc0db6cb05400efeff88f9b15a559bfa9103e9cda9e191fac788855bc6e3a788997dfb9da92008c69088938c90852c7118312bb57715f5a4c08909584120424df923787f3d81e341cd29c152af0c4387b6d16eb77aeddbeee37627ef4fc204149ca623f2e138039186ea220f1976246f2bc410f43d7f6ffab6f1f9c8b94bc297eb6831b02a8e395667ab0d8ff763c42cc6288fdf9303b368b20ddb6963865127dd5b6935c75348a284e3b2025d818ea74364fab2ee0ccf96d2bee0ea0aa87a5764709037eca4e048db2512b698cde7e405c0aea4d084c54ef7f7e5a656cf54933a50b629af6998ef18f5fdc03c0c6ba107de59f8f2277b8e31222024a5c59af1db1b6ddbe0733f6b1f128113ce08e805469292166c8d8db7a4c916cfa83dc029a9fc33d51e37f953564d05fe35c89571af02a7a07f737a2ef055b43286006710c4217a7693d6dea76463a9194b4eb542cae16b4eca53362b829ba839c4efdff48bb0f11d0493fdf3c90682c874a95f13f5c8d39fc7123b979e37cf623228cb91354df584e0ed84e025045f8d6c3ce55fe43c70678159872e23ab305d5b78776d4eaeeb0cf0a891f5b16890fb5f62cd61a0ba2bb34a6801d014fafb587847bafa86f58c2704559b6e9eca26b15c6641c7dc4b762a01fc81820c5d6a036a15a66ce6fa3334e839ded114d6ccf8bd55a240cd8a7fd63f62602b8149276727efb31c11fccc2e46c5d50de03c2671932b8d3a1323685eead2824a259bd3186d1bce1d3e4d7ca25419378771d61af6fa6ca208dd66cb35d15141efb179cd2fb528e79eb076773332130c7f35cad455ef808e96926623094b4a016c289047de2a95aad9b34cdccbe4161e9414251ee0d761511c13142d4fcc8c753d4a45c334b8906a80488331fec46b851d649ffdc2393cc89bda068fb2519a57b740e86f93bec55fc0bffc8403efbc4a72ff6da3c460cbc8578127b911de446616bc64cab2f5aca6c19640ea4a347f20d9294380b57639e686b0eb5bb256535362149f5291fe5cc6eea38485ea1fb724c2f65cda53c1e4d043108cf9cb9cae69c8721f596052aca63ef2ee28e651bb3bb6cb56a0a05b35a2c1663e2d41b909229f7a699f10b7312456f8e6bb44f58215c00fe2540fa8e40da0309a3e53b1c55cd16f8b65c2fc71eb0cd387d055d52a8823260fda82b990ca6602f3b74aff8c54ff4a700a74ca6ab4ad8bed9d75571f8ca7310ff2ab97fe2ac99ec591ebdbf7f58a532b68caed0f632ab5404765c466f3067ccfc134f8db834523c21d9334c7bd52dd57eb45d86bf6901cccbc5be6f78baac3e5865901444ae4c69116ea9e7cff09edcab37d555ad79dec5aea907a5dbb8c06e4fe17085657644a271324355bec77e856a776a9672f1f54f1f81dd1dd84fd44573d15a03bdf334e03a4b868796970616d884670b67ac42853fefc93d3d14e909f6d6a894d479fb28736804b149a886dc4225715a5765f59e881512d4e22624c04116e734a47be2a5796f9bc7bd7d635cea4ad35588f268ee4b103343aed76d0983c8f5d63b0d4ba688574afcb99fc842239e49496ce137f4282e35c972cef8f22a228a4a9914995bd161ac516da66aa43a6f02ac96f129b79063fcbaaaa42d5fcfb3f7238ab0fe39c73b88c24c600fa20d1b135062c837b207df830efea3550f1a2aabc3f66df3a99669e6c5426cc02767b5616ef27cef35c9816d635414d98181bb330201f08fe5b48a05847d809e85035385e8edc0cd8af8b02f52d66e5f82a60027a7333a9b332dd21dcffae7e9b4f8ddb99c527b15cf8af08b268f59dd6c4a3171bc8f15cd4e04f4d6a63b761a4aa6173679ab9652d1be03bce9af117a50351dc9f48d4116c856d3fcbe1863b7d9ebdd59d04fe4462c3b50b0199b0af00bd3b900fde88b25f50bef942784e60c4677e18cc563fb7369f5a8e7f7b51daa8325b4a4c106c5d641d2d72692431158db79ae091f2bc37d1bfc6c8b202b0c26727407c0a27459fd26dafe7fdce585c928003dde0dfb64cf0895bf093a4dd34b699921dcd2c3544e5a34687adf8e846ba0f09f70cb4d022dcd5e094e7008c5f016b92e053c15e5715cf674f8d4c60d8210bc60434269a9cc553e8dd79b678e943feb01b8cb2a8a44978401b5646bc44ff18de8a03c92791357305b10cb335dc5149c538f1511c087f60d4c161cf55ee1d65912f32fa0a4041d701ce17a6cad0f69031346e6fcf7ab0f3ab882aac03f1967fa8938f47b8c271074a96d51de39abc636331bbd3bf5fc608649d95dfac7948418036e439a95e54454961fa78647fe571418c51fed0f348f888b1ca96e1732b3aa2d0dc26182779a506a50eb4bbe4046de7fa55cf69742f7405a585d5d3240803ef7c461153fa42dd9e45978e52a6b56e67f3623903eaaf43a701d4ee94fc9ac4acf1bcc2b86081495697b8984708f10140b544e56bbe82af1eefbfcb23ad39348cdf96f2e1d29fd34126de7ac78e6029bd166539576f2c2ac187abd3de6b2fff60451abc4e9ccaede658fbba864485c4bd4e49927bc336d06c9aa14ab348c92fdc3e04aeb26a84797f7463345fa0a3df99c2452ff4da636220834e312fc18e59e4547e0b10cb6ebf5197b46046cd097dd23df43ea002b41ee35fd96286eb27ba686e9d085dcbc99df141963ce06a1477fb8cccc8063d75515a7f7805f2d0515da2c82d12c1182a50e85a4ee20e505482296190cb7d735c3db2b160765e15163fed774c4c885b9e89214b2f269ed80ed4f5a0aa99fbf697bfd9dd2f9cabd7fcbbde356faf6512f8cbb77c65bd2beb6248613cab596c0464263feee785cca1b5689f10bdd261d8ab4bcb3702f3a537a5edc9a48f64304c473e632bb24558c16a3b91c0867d4af33c29bd3335b1726ca56fd8163e0ef2ab333b89bf2863371f3b82603f5a0e27d56ac08f83c982d9001be6824d025814e8a0045cc2564cf8eaa01eaadee3595806847147ac15203195b4b37f2ebe5a8111f83e5f5aec8afee4dee661bd30db0cb5cceefdf94f6de4eacbab7c31058330c2b43dcf2d9e75f95d2fadb5458bb68796a534106fcf47827fa3bfcef5ed33f983974ea9661f3ec7b85f282b5f976567689aff2b8ac4528f5ef28297eb01f2a5787ea945606cdabca270e4dd6bd995bbb87aa0db97fd84cebbdf85902c68821ac526bae95e4af1c9ced36f57b63a6f993a2203fcb824194f9b9c47d8125f5b1b56e3bec7641c3bfe2be669d1f27eda6df11ed5f666e939a0f99870db3bf8eb90f7f8b6247a2d2b40d5eb7aebbf16777f3475079012d709851432deb113335d5ee4ac9be1419e15fc4a018fda90b12064fe56b96b41ec2b672d186fc3d21cb8f465524a14330823997bc1a60345d7f0c85c4705f39d2686ac07333011b8630a2b4f431abad5eedc8497fa8e6acdab079a19d0b860a777aac2644b6e085b528900736f3cbc386a40c8587639b2419e4ab3570362ba52421cbfe68bf89cc678cd66241d5b0ba93a4f55d311d40788a9ce293cb805377abf3bd9885851cd4f46bf4a5016141333959164fbd3b102275536fd267d629e06f4c8d96018c4e9b62468764b746b2546089e04a19626d03f50697ae18fbad35108c05ee5e4298544f08fb6997ac35ea841a49593fee7829190a1351dfe8f882f5b3f8d5ac13429d107c38bdc165d115b4216bd12c37710646d814c271efb5b7d5001ba96f0621df430ee72b7754ec5146efa1b0a899f9217346d6cf699127df4ba312c72c542611dc086f031d074212d7d3b8e302a6d01b43020af5ec928b524814350216fdc1db6b4b91ad44e05ff052136a687f1f6043fed0df02387987f7bd9e547503f894e14ec20981bcbed846dfe29afa543327e575fea40fdc84dde006d600492a2669abeb2d770136028b05bfe398a2a3047904b17c4f1713cf43af9a98b0b05599d0fc763024ddb30333bbca23c0ca72d4691b184b767f1300512fb32ee02415608dbeadf9d9c04970e897ac7911e8799d768a50b9c05e07d64ec260a011bf7836c9161c8984560e04f50d51c241481b505fa5fa44d9e7dab69f07ca8e4962fa0eb82d3452b7ff2a12e251b449e8080ab8ddeb25761b13518ea26fa002a3e441b6f259a123f7d148c68a868b3707f5d2e44ba1e1475b79711a6bdea10edea636cac578a3185ef0818f6f9adc3b9e43b54b52c4db4f509073ca6381fe32299b276436d75ea234be5e279d9ea15e660c36e262db5153cc07f6c076516aa88b4feab7b07e8193fed3173a1db063782b7462843e2b1dbe6bacefd8df1d1c956d7c7a8b4af3a27b4a01074f25dd7164d5a25ee13971fb6cf4a3a47072b2d1d1f7661d82562c47a442a2d05be82c9ed0b3a1f3cde98d293bf409de587fb21a662c0bdb7d0653e4277b4bc649f98d42ccd8f203b11f8ef25c2093816e487861f441c99da68304400a7664225e181bb2e0ad7ba66f7b4e9ddd08d08298e9c2caa45e052488e2b96fe554de7b6f77cc0188bae6a77a771f649c9b435d01070d10c8f5ab40a0d4b29252ac4bd6a27eeeffc1ab0a2e6d33c76802a626a7d105daa5a5511769f5cfb8a0a62e6fda10fcfe9978f1c91d3417ee2114ad5f634d4cb650b7afcd1a56e413a342898fbb47e7d8ce5892b838e0d6ad6945a34f16d3f691e71ac35c43193dbb16905c8e70af03f78bc3a442b3dce001ca974012f2fe43cae8dc5af467392d07843fe35f0b38266c6a817cbac100cbc62d127731b3dd491f79f2bbec62c0d4de4fe3a7bb9b33a757d54336ba6008bfc89aabc0a5fe07c4968f9a6d90f5af5504b0a4c1e5662a7e20f1a6668b20996af5c4627e97ba6cdcb6ae5e774c42249d61d6cc1e97c0b8b375ff1b7de8edb19454220ba20301b27e3236e34fe6e9ec360decc052d67ec85c8c9ba2fd9e340758840db268f40cc4d7845786e7e9f671f703d8927a16aecd934004f0d69d9aa519bf041ee2b0528e08acd2a4460cfc8d5a9ef2b9501476b7261451944d3567b3ef4a7cc68bddd7e5747978a726720d3be79de1827fdf10842935bbd7d9954b563b0f0c220c67e52313e30e2844ed5606e4d41cc7bbef84b635b68a9fbaf3ea38982e64e4b5db8db32d2c20f397e1c18e8b8220b1ab930cc3ec53e21f4dfd2ea0005ef431694d25592449c2d74bd93b5edbd7a58dca2c653c55cc2de77fb035e34ddc6e829c49121e104a99bf15768d070c6d5275db586d834374e992d55fd353d01dcad820c6acad79834f2e03b60ba333352c09e8766346a9b67422fc434c764ea839a92a8213c76ce77b0aaf4ca299da4921f734c97d757156a5eaa0f95e92f0b9db67eeb36d041faf4ec94288fd01b3631260b73f11e3436b04134de88e3eb1a21acfe210fa9b78ecce0e10b02a0a3c607234b8d8344a28e8c518796c228d92e437a81ab9c34481ccc638295a3f10d291a30b8851442a037091ec7ce7d975a55d9784e87069710ade5c55feb1c54f5ab1836b078cead1bb9b4d4e506613fefd3b56b926ef4379154cc83636651c34780e4eba91c322b39378401d259da02202924e7943523f5e955a37fb5f057bfab83abd5dbac980d00a4b69eef69d1db6f44e8e36376244c0c5b548c626c516615521be61cf3caf427d78be805314bee60f3d5e3479c4a4c0289fd1e3192947668aae9070650f6a0431a2358eed62ecd216322cc58bfa017e595202eca869f34681704500df65b33c1fe7d3635141842318d70ad37865a81615d01c22825af9e7855294098043dfd7f1e7c0c7f214852b1c6dd3993f99f56cd3e9c11a7a3005cd72cf128f6fe9ac3db1273f1385a8744450a2a12208dcf8a77ca2833a9f8cade273141916dbc0283a93d9a2970aa3f7d8b665c83bde848276ae2a567b57f02a613ff163fb8a71865c245f1c3d96bfbf9228479f81be1382eb9f8e3fde249e9adce69565d9d66b7fe2968943ca482df222869fdd7a46ae31cdd9c5eeeaa4bfcaf6a3bc70e79769cfdff20faf1aa3ce3ae2555f3ce0f809bf17faaa66c78c5c2c5335895811c3e53665bfab6d2667e5bcadf2f3e6b7d381fb77ab8bdab60805b8cf161cdf78da6b7d636b965508cf84a4f7fffa263fc6794df8c0b5b7450e745343fd89f74817b7905c3fcc26c84744b19ff01cc0d7e6478ee61ac5005ba89fb992d6fc139082b283ee534cdae3650fbc37e3bda6350bf6d95f9e9a9d0aa1be51b74207efbd0c222af47c6fe4c182972b89d163863f3613901277907c9ae79c8bf91030bf12e4918a1fed650b104b7c42ffc5012ad84f4ea9451368fb2f798be1d95751cde33bb1207a6da6d091c7973118f575e071c121bb963fa11450337b1e1576a6b4117aa831934e3a1389f9eceaf1ad58c01e2cf90616383d33b8cf0fd8fc0a1bc8f8e682294579e606d4b2e5395d6643102cd18c017225dd051ccedd98efea0b8e4263d93dccfd25d9a97562fc6e5609c476adc4403eeb19641ecb26698eec70302bef2b613309b2dbdc5f27d6366a4b82a4cf97cdab4578b30c20816d09b732d848e69af6f106bb65ff8aef18c1c5f8ce8bade366c37ca61aaf59a6cee06bbf4d02f8edfef45209da620ce0a02e893f1673d8efa34620fd06bd0896a582ed7de6c0adefad7ff50473eca9a19334cd159458ce08cd166dc62d044e2aa5339ba10e2f0395631b2934c25e04fd4bbb7e7a3de6faf788fadf481350371c7ba72f512ced10dac55a369ab19258820ea9ea9c704ec3456884a003662c2852a348572bffaa301729174ad0816c1ec5ee6cab3388963d01402c4bd48dcbdf87934b6225227a099975350a44ce2b462173443f9a03a4f5f9a62eda9ad2e9afb6ba2087c3869c71f0338f56cf9466622f215d0fe9f8d8d1d163e5e223c418bfb4edfdc58d7887fa52924d263debad20024e1bfc47e09cb2b1477b09b453f17731ca53bdab4d999a0dab8366cb8f225b12f3f5efcca4ca28a33d7c45f9500037b195f5b2d60b70378474b66e16b89983db071ae66ad67a8980ba8bc10b94a056d258d85d738cf7f5c7b463613347c7417b031e2fd799cad2fa0956c36828e71a487d903160e343b63420fb7a3310aad220e0392885d14ae92c6660f53d7358b584700cb0e72cb7f809a1455ac30ff6a4a5ebe6c96861ed9c37e9ab31925f1c69880141ec25a3f6cb51f7a220e057b9a112e00e30efcf07d7dfc961f1fd99f36c35095cbd89a02a7edbd892e5be42bac40f9d4af5d554a72ae3cd2ac15ecb69c0e6041a0852a88e010eee2a77088981c08fa3612d3d4677a385216881652a3e235bc27f6d1f1f0d42f0017eb13e229bdbc749f2d41bf42a57de85270bc9138680e50c1b46e4f09d0081a8b583821d79f1247c96be85cfaecff46d329641cd33037013657b74f806dc13ba12dafd51a8b8e081f29c22f72c63aea564af1e1f87c131cfabe21bd7c3abf3736bed9bdea67d20f4fe1f7b5cffde3edb8ad5ed4c83492781413ff09363ce58b84e47d6a0973bc61c866ff617c336b2d05a4bf581deaa6e7cf98ba84ea22a9645b52d7f623c4ce297827e737fe28a9e6e12c6e42024b90783ddeaec17d55d0c0cd8c87e3438b60bb6dfb866cc33d9a3e19f7795524c0351dec746a07812af580c5570c0827d252166d3baf74980e162852d680473084fe541297ff965acd12887d7e72f752e7db36abc72f512cd489722f178296528c24bceb26b3f4c89027b511ed847dc4d270663d4222f106e9ee6c573afbbde3775692a81fd55d819f138b0eb26f3a5e0a9a2a7de5492af9136e2cf9e82a43ee078cbf5dedbbefab4f41720bb7158efd1ac330643a8171e6485d4a99ab93251990e6170dbfdc7b86debfe487af960ce157d3325d9fe0e24eb2722b702005b43150a9c0edb2f1d510d14cf4cbde779b1531e0b634320b5cb8ef7ac1a6ad4351b0d91502f0891f10455c72cddeb5423c995e6eb46829c49a3f809c106c6458464a83116c72dbe46ccbe65572c820ac7fe49c511dd4db616952517d943c660fa75b8a9bad501c164f87dd3d0d0d22451ce94e54c69786c94937c89788e274db7202fd8dcd1ab2729bd9647ff0c95b998e9f9a79042105d6635b74abb48cf13f997ac48739cedd5ede61da416f2628ff45c866b6b2a7584d4c745898e3a924613b190aa7f851b7b5c2166a4d1bb524c858ad2ebc609665c2a728e6c6d8714e0eee22e05cf5a3c6f9cb2844e7beb32707f374636b230bae229540f2340711297285eea700199c0238bad2dea9669b3a171bb91983ab6cddabd414c2a381c3faf44d72a1b6a7bccf5fa6bab09303b1969ae506d58d742746d617d651d1828070052d7bb45b9b3d1eac4967c870b3374bd4a3af7a9f77ccbfdda9a59e81c0d001ebc41a91b3e92829c5cbe093b5cf6a0953fae7935390481c954c4e737ce3c9395917e9ef293174c8269cd4f0a8b3b20f94f4ce734acfe826f0cc3d430bc2fe07f40903ec83891b89b66197891d4fc7b2650c62390271f2db4a685740e7978c84ba074ee0a25a40975497c558ce7c85ef502c28ce27a7a7cdb6398827bc5f51bd1ddba604c2d5dc3090c1b34af52ea3e85476b0593bc3a8df3982cb28c85cfca4f2b93496d089b8a809697c799e05336903655c091a1add7728c3c1f7e733b40eb12466fe6682d9b1149e1ce30f04bc7e8a6620072e677d143f2ccc5a2bfd3060ac86ed43f46694ebee474979d641606f7127dcc5de4983b03c2119ec3dcbd655fa91c952f36b71074a1d75570ed7bbdda45b219b2a24e7bc3c89f7500fa0ba7403c95085d0a8e1272092c3c2d6580ce12926f4edc9b838dd8913d8dafae7d2d6a6a08adbb0180b18b3afa65b0086edc138e05c1466eeeac36460bf473389e99a0e2ade2169433473964472290cf5f6b2721dec3474922d3ee295586aaf598c672129799d727f812bb5565f71b2d28a6c1ec546b45a08febca7dc3caa0d88ab51bdf383cf21c7e250eb3bfa7dc7ec181c5f709aa8147c6325aec89bfe0ab4fe5782e2d6909ade7591f15fce3cc621fc90c0a294dcfea180ff557240de217605e4726a6fd99d57f112cc8321e4b5bf9950a017bcf5a87d815c63257e4718a286ca0a317f4f59cf18c70a39073f1bf257caa7eff21238c8e5e273915dfff8c0338bda582974199aef58c968640b74271a63dde971a0b40b5436413578169326287cc8cb18f472374ca5068935768dcc556e04aa5849eb7fe04a59ccbeef48b2cc923d7aedb84f3b57005003da4cfa6fbc05069a70569764bc1a99b45d89ca0ff277f46ea0e72de6e96c2bd7fc2355e9c7e1245c3d178c7c2f9ca8cf2dcd8b7d4c012557695d4b505741d5cd84105c1a70ff9b9f83cd067e359a484699e1a0618f5e31146cbfb4de6cc3545fcd56e170d96d2d47873858ba6aefb3664b3ea089396358b3c4ebe96e9a91d0b03618cf5973ffde87f782974c3658f9cd5b09c56015c36c3c0fa17cfe47e17d8c02415d46363dff1009baf25fab60ec334da952e28f008a9a76ed5e9eee5ee717e7553e485ee02a3b3dd1d30421eb5b8f3fd6a63ad686880b7e3f4f6d027a77e658e6708f74699221190e39713fccbe883e1c66ff7c88b376c527d02e7fef0d018606fec064a2a6dd0af2ec13679d02403cd0a7af3c84202005940f03f1458d166ae680ef67a0269d0a9f999f9556d77c96187acb9d9e45841d8562589b5fd1e11328055e7bff4fc64c3303a356229715d3cd60bd677627edaef8fd06a4f81ff6c89c1559a05c9bd188f2d0496e5ca7f9d9185ea7b4382da58640534d4b312f28057b7565678006514f4296bfd334731490628c22e4804e6e242e95526070adc4e0fe6f6edf947a5181c93f083ded1794d68ad129412e5c63cfde880f229fabd4a7029938e84a1a305f92b2f6a67a3fd5fed19e625446ac7c7e8c5a8b294423ad7e1ad6cacc3c184956f39cc8261719377f05d11633d639237c701b78b8825c576579520003d0dc954b59b982ca8f20f023cc241f59681925e3a5c50f09961a8c2b90c060eb2dbbff72ebcabdd66ae193b7c2f127d093d627311ff888e4edd5d856e544d842f045ae7018d53ca66be4646f7712421b7a4bd75cfc765cc5f8c6a59124a6fc481fae0320bc0005e7ee95f102f01bab78407057ed82855115dbac11df22ea56d1476c1a4f3214793e610a32b7116c0aa26320c6e808cc8b6a14aeea16b80295fb112531afd7b5bdebd8c438bd353decb93ffe353dd5cd11bd0001ab07ccd8f9b2834771d8898931959d0d3a6be04035f838963c5e7ab3e377a25e98cb1164a3046b68b0c912bf072a9ba047603ebc3cff25a197491486aa24cc7372252e14329089946807c21c3ce6085b652a94ecf019fbd835055ebcf1aa37560758f9292e8664650abeb0b70621f9f8a9bd3e7c57ee80ea3cb2c918a8056ce1cacdf0237e42ae256c657613afdf3f4ab207e9c6938e913672ece343f9045b6cb5182500ce906b9abf7cf6ea741aeab56074fd4e44e00f5ded615be37dab8795238dc76ef3c43ed7d6616f77f1b3b72eb3966edc4ec57b4c4f1a0894a6b70e18e4c3ce120c4b9da6c3744f09a594083373b00bca8364d4ec31c5c233e6c2d9203c4d89dffada9e2ea53303eab63e01b2d56db1707664a1941672b1ab76a365dd4b01bfe2dde8cc4c6b271666252fb152a6253a6eeb1268fd61d8435236479fd73f290fb6b569095ba11d6494c8ae472a68dff814cd2339d38c226129058c25e8975039aa171f29a318f68b77eabba715eaa2b167bfdba4076213e9d11ea19629ef218c9a28cf3e6f0ae94fa8e6c4ea4ea36e5ba8d3928fbb6db8063790f259b59c5c999df2d776f62ab0648d6f353c8db9b9c34ed61cc615fdf64d3b65552a99d07e39eb1084cb17ef09e0ffa79bb8dc9ed73c2aa27d8bf1539a189aaa6e50f8d2f8ccd2224932e11570c267f7f80fb475701716f79deb15c4fa78ac2b0027e95a4993924289a47ac8cbb58b33cb85632be8a0ced06022c06d9e89bf9ccc41bcc8d5d404c198e6ae70bb196bf9b092acad0fb7c7b95eaf9feab18137732a444c60b20c2d16e528b083db73ef084f2a92cf9fd7680730ea70680f868b4c9e81ae5cc924a8e104296a626c8a3644ee4ea309679302679fd0ff0270b305cef6a57aa8266a173eb43c3330af4d46918776865ccdc9b47d6f2ee579e487e73dfc6f015ed66ccaed4dc055fb85e1cce06bd51f7f7641a2a751bcb9703e8d9bf3e55f63e673e401d7a296ab4c2bfcadbbaab698d5febcbb3f643aa2dbcb2d1457b641d3a0913685608286eac92c920976979bea851f8ce3c13f2b488c176387e3d1f01d4654596e1f201f430bc3418fdebfa8d099ead47d8f72aa3577e8d6f903121cf945aba46af070019f20aff6173d838bd55e96e4ff385e6fc7fabd5a194ceb114f2bf6cf3203af41c4c8d5fb25b744b9f62b870eb49e91da75d1221643c6cc218efc01bb37338a3e1ad953c870297f7df83f2a385bfaf641dbe3fed38849b48c55b6b4e89467df5436530e4edfe37054d7aa2b5304b279c4594e67654b8967716a8084595d5231c629db22a5c4a4c31e723963053d6ba432830fda0d0236b50c7a6d0c5a01d48984875c30fe84e0ef6f7dc4570d758e92a4655defa31605cc0b3e67034c14fe32126a3b622e116d178741953ae10eaeb66c97146c851ef1f3ffaf7af8eaf95f21b3830d0c5070861c5e13445cc1f6804bd4ffa2ce85d4f56a2279d64e0ff6eea90b7385b921c1f8e147048c511e3650f23d0fca12378c77cacb0b5973a38c31d8fa91f73a60f1d710aeb596b791509954d60485385cbb418defd082f2da49660dc86ec351a9e812728a45e310692a9e969864968def75db4c1bd65651301ceec3b806cd25b5ffefd4ac2777582ad470f0016836f7b9bff0a6b6789f1308148aa05ae3ea5d9aa5b4098b04b8e4815d4257bd15c83e1d9ff37fe6db2920d0875f3f8c01de099c037f05e668e111a1fa02050b386fd52036934fc4c2dc60a09a2a261fb86ae74051979d1baf68598f5eefb9c8984e10466cf117d9a18d3ceb18d39a2ba3209f49eb074f6d9e32d5af0608aaccc096ad6dc94ea219fc47be6e72b2b6259546bdae0dd78fc9acf79210c645fb5bec3693ec4b38a7630218c19ea209a1554fb1ed085f49d2fa02cf44cf472fa8219d8392d28168b7fffbb91a3da2d9f5a670dd2763d8b0b6c1014ddd6ab742ea998dbbd03ffe143da283f629424d95000dabe87cc6bb461b295bff7564526d02fae68f0c9b6564e0d51417edee4f190ce0e8f173165637134bd95b2d3caaa7c33b4c8ab5f455b16b1bdea2954d09e803634240f8c480bf303854c0bebba65e8b0ec9b8f00487c925ba0b77de530fc02e46a5b890b9463925f8ac02b3da2d14d69a2106b97afd3a3e95bee256977b845239efbe048b49d9c1424eccf1b5d9b2ab223b501908380cc652c1827cf58cedd9fbe1361534eb57dce655a1da5a5162b0b60e48ee26ba3f0dfb9a73f6333fbf97d73e588bce52fb7faa17ba625b51ea1362eed87d3e66613b5a57ab2f8a0c2e7b43f2c5234f0862141191d9451ceee26bbaf0f9c48e6da06a98852e33036e34395af1695c3164d9a348d164b35ca39973f9bf318fc759f36ac966a9ef5cbdd86ae0abd61ffb10dbdd3bf6ad582644c5b68539fa31c63974a68cb3aefca588870fa7ae41cacafbf14933b224c5d409e110f551e5edac1f14e15cc30cf0d7850ec284e342ff9ecfebf21b7aef72cab1ff172fdf6ebb74600eb472f9a49ee4cc5950cb2700d63eed00a95980ab3400a4cd0b44f837d87ab70d59b0686f567d4c23e43b754f85f16123e58fca59653a171f7b4cf545153042cfc031d1878fbb0c9313ef21d367d9f42e7ed2d34145d6702be4e5c6dd3bc84fa2ce9d6ce926a467cb0b38ff151811d0b802c8d9935ea48d12a9d4457b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>High School Memory</title>
      <link href="/posts/high-school-memory/"/>
      <url>/posts/high-school-memory/</url>
      
        <content type="html"><![CDATA[<p>无数的回忆，却不知怎么讲起。</p><p>生命中黄金般的三年留在了那里，留在了教室、食堂，留在了操场、水房。丁香台的幽怨、风范楼的纪念……时间逝去的了无痕迹。<br />暮去朝来，脑海里的记忆渐成碎片，模糊，远去……可青春残存的余温却不时袭来，让人不知所措。<br />难吃的饭菜，打水的长队，漫长的台阶，无尽的作业，这被吐槽的一切，我该怎样留住？</p><p>恍惚的日子里，我们沐浴着初春的阳光，穿着蓝白色的校服，三三两两，去清扫校门口的垃圾，飞舞的塑料袋好像永远都跟你作对，高一的卫生红旗班总也不是我们。<br />刚入学的我们难脱稚气，宿舍的卧谈会不知道开到了几点，三国杀也总是通宵通宵地玩。体育课后的历史课，简直是睡觉的天堂，老师略显无奈，不过并没有人care。</p><p>二年级的教室并没有变化，我一度觉得无聊。清洁区变到了教室后面，仲夏的中午拿着笤帚，扫扫松针，偶尔会有几片落叶，倒也非常惬意呢！<br />学习任务貌似重了一些，感觉大家更加熟悉和融洽了。让我印象颇深的两件事：一是教师节那天，国旗下的演讲。莫名其妙地成了要演讲的人，没见过那么大场面，所以提前一周就在准备，演讲稿不知道背了几百遍，周天的晚自习啥也没干，盯着看了两节课，手心直冒汗。第二天上台慷慨激昂地背完了稿子，也算是没给班级丢人；二是期中考试后的家长会，教室装扮着气球，彩带，音乐竟然是“爸爸去哪了”，老师，家长，学生共处一室，感觉其乐融融，真的很温馨。。。<br />搬出了宿舍，租房子住倒也安静。不过院里大部分都认识，还是会经常“联谊”。<br />之后文理分科，学业考试，有走的人，也有来的。下学期有了竞赛培训，很喜欢翘掉晚自习，溜出教室去听数学竞赛。</p><p>高三搬到了更靠近后花园——骊山的风范楼，体育课很方便咯。大家时间紧张，所以楼后面的空地自然成了最佳锻炼地。课间的羽毛球，足球，跳绳略显疯狂啊！<br />学校要求冬天早晨跑早操，真的是感人肺腑，无语凝噎。纵然好多领导（LuXiang，WangJian）监督，还是有人去厕所或者蹲着系鞋带。。。跑完冻如狗，回到异常温暖的教室，再吃点夹馍，零食什么的，早读只能睡过去了。<br />相对来说，我更喜欢广播体操。悠闲的大课间，上个厕所，晃到操场，晒晒太阳，活动一下筋骨。下来时候还能聊聊天，打打闹闹，也算是“偷得浮生半日闲”了。</p><p>每次考完试，操场就变为了乐园，火爆程度超乎想象。在球场奔跑，听着风的声音，跑累了就躺下来看天，看云，看夕阳，考试的阴影一扫而光，那是我最开心的时刻之一。大家会一起玩到很晚，“下山”去吃东西。<br />很喜欢坐在教室靠窗的位置，呼吸几口新鲜的空气，压抑感瞬间消失，上课扭过头就是小树小花。下雪的日子还可以赏景，雪景可美了！<br />贴几张喜欢的～<br /><img src="1.png" /><br /><img src="2.png" /><br /><img src="3.png" /><br /><img src="4.png" /><br />毕业之后，学校就升级成陕西省示范高中了（也算是没有辜负我们为了迎接检查，频繁打扫卫生啊）。<br />虽然实力有限，水平不高，经费不足，饭菜难吃（母校就是我们自己随便黑，却决不允许外人说一句闲话的神奇地方），但进步可见，未来可期！<br />给帅气无敌，宛若天仙的母校再次打call～<br /><img src="5.png" /><br /><img src="6.png" /><br /><img src="7.png" /><br /><img src="8.png" /><br /><img src="9.png" alt="快毕业喽" /><br /><img src="10.png" /><br />纵观这三年，奋斗的时光恍如昨日。从学习结果的角度来说，我无疑是失败的。但论人格的成熟，收获的友谊，价值观的塑造，我又觉得自己是无比幸运的。很多老师的教诲至今仍然记忆犹新，也许会受益终身：</p><blockquote><p>1，不被嘲笑的梦想不值得被实现。<br />2，高考并不会决定什么，但它必定会成为你人生当中的分水岭。<br />3，......</p></blockquote>逝去的岁月没有人能抓住，不论你多么眷恋，亦或有多少遗憾，都要藏在心底，因为前路漫漫！<br />以后若有人问起你的青春，你大可以掰着手指，细数学校曾经的沧桑，拾起被风吹落的故事，那是你私藏的幸福！<br /><p align="right">写于2017年10月16日，知乎</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>士兵突击随想</title>
      <link href="/posts/thoughts-on-soldiers-sortie/"/>
      <url>/posts/thoughts-on-soldiers-sortie/</url>
      
        <content type="html"><![CDATA[<p>这部2006年上映的作品豆瓣评分9.3，时至今日仍然有人乐此不疲地讨论剧情和启发，我想称之为经典应该不算过分。<br />这部剧我至少完整看过3遍，随着阅历增加，对某些角色的体会也变得更深刻。</p><h2 id="许三多">许三多</h2><p>许三多是幸福的。从老马、史今到袁朗，他的成长，总有贵人相助，再加上自身近乎于偏执地努力，成为“兵王”并非意外。<br /><strong>每个开始，总会艰难一些。</strong><br />初来乍到，面对自家坦克，他举手投降，连长怒了。于是，红三连，五班。<br />就像初入社会，没什么朋友，周围的东西和我们格格不入，许三多的境遇大抵如此了。<br />那个“无数班长的坟墓，所有孬兵的天堂”，他活得很简单、很纯粹：负重跑步、整理内务，日日如此，还为连队修了条路。<br /><strong>无人问津的地方，你有得选择。</strong>你可以放弃，可以混日子；也可以认真，可以努力。<br />重回钢七连，仍然没有人相信他，除了班长，那个有过承诺的班长。<br />说实话，那个时候，我讨厌许三多。讨厌他的愚笨，讨厌他不争气，最讨厌的，他拖垮了史今。<br />史今的心思全部倾注给了许三多，那么优秀的班长，在天安门前抱头痛哭，怎叫人不心疼！<br />有人说，史今给许三多打好了地基，袁朗则在地基上盖好了房子。<br />是的，没有史今，就不会有后来的许三多。<br />333个腹部绕杠，许三多开始了自己的蜕变。<br />七连改编，他又把“不抛弃，不放弃”诠释到了极致。<br />不焦虑，耐得住寂寞。<br /><img src="https://img-blog.csdnimg.cn/20200316141449843.png"alt="在这里插入图片描述" /><br />在最绝望的情况下，在完全失去理想和希望的情况下，也会尽自己最大的努力。<br />失手杀掉毒贩，他也怀疑过自己，怀疑过这支部队，因为他相信人性本善，每个人都可以好好活。<br />不过历经波折，最终还是艰难地完成了心智的转变。<br />无意批评，许三多是好兵，但他绝非将才。可能与他成长的家庭有关，父亲的教育方式让他绝对服从、勇于认错，但他缺乏思考。<br />没有思考，就没有大局观；没有大局观，自然不能指挥别人。</p><h2 id="吴哲">吴哲</h2><p>吴哲我比较喜欢，尽管被塑造得稍稍理想了些。<br />年少有为，技术出众。<br />他对自己有着清醒的认识，对这个世界同样如此。<br />一如演习后他对袁朗所说：</p><blockquote><p>我成为不了他，而他亦取代不了我。</p></blockquote><p>不会畏惧权威，永远坚持理想。<br />当他发现现实环境与期望之所相距甚远，他会质疑、会抗议，会去维护自己的理想。<br />理想让他仰望星空，“平常心”使他脚踏实地。<br /><img src="https://img-blog.csdnimg.cn/20200316141511696.png"alt="在这里插入图片描述" /><br />附上袁朗的点评</p><blockquote><p>我不会践踏你们的理想和希望，我不能，因为那是我最珍惜的部分，也是我选择你们的第一要素，我只是想，你们在没有这些东西的情况下也能生存，在更加真实和残酷的环境里还能生存。<br />我敬佩一位老军人，他说他费尽心血却不敢妄谈胜利，他只想他的部下能在战场上少死几个，他说这是军人的人道。<br />这个人略显轻浮，但心理稳重。坚持自己的原则，充满希望和乐观。重要的是，他能跟许三多这样的兵交朋友，这一点，就不会毁于他很容易产生的优越感。</p></blockquote><h2 id="袁朗">袁朗</h2><p>最完美的人，也是无数人想成为的人。<br />他似乎总是站在上帝视角，洞悉一切，指点迷津。<br />军事素养拔尖，一举枪，便打掉了成才的狙击梦。<br />有能力、有思想，也有情义。<br />老A选拔的最后，伍六一放弃，我明明看到了袁朗强忍的泪水。许三多决定复员，他并不是强行挽留。给他钱，给他假，给他自由，我想，这么做，他心里是有底的。<br />演习评估的剧情，异常精彩。袁朗手术刀般精准地评价了每个人，他看得透他们。<br />“不抛弃，不放弃”，他理解的深刻得多。正因为如此，他给了成才第二次机会；也正因为如此，才有了许三多坠落后，他对成才说的话：</p><blockquote><p>百万大军数年心血，人走人留，抛家舍业，一切数据和非数据的结果都要在这几天检验，最后得不出一个公平的结果，因为我的战士要在战场上和他的朋友重拾友谊。<br />你开始珍惜，可你真懂珍惜了吗？不抛弃，不放弃，你倒记住了，你也这样告诉许三多，那么先想想，做到这六个字的人抛弃了什么，放弃了什么。想吧，现在。</p></blockquote><p>初次看这段，我也一脸懵逼。<br />后来才知，许三多为了胜利付出了鲜血，他创造的机会才是真正值得珍惜的，抓住机会获取胜利、为军队改革提供经验，远比立刻抢救队友意义重大的多。<br />他循循善诱，告诉成才一个指挥官应该做什么，告诉他战场上应该怎样取舍。<br />袁朗说自己年轻时最像成才，比吴哲更专心，比成才更知道自己想要什么。<br />我想，袁朗最终也算是给自己找到了接班人吧。<br /><img src="https://img-blog.csdnimg.cn/20200316140043328.png"alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/2020031614005371.png"alt="在这里插入图片描述" /></p><h2 id="成才">成才</h2><p>相比之下，成才的路的确坎坷的多。<br />经历了荣光，也熬过了低谷，最后做到了出众。<br />这个人物塑造地很真实，他会为了个人利益抛弃战友，但也会在需要理智时做出正确选择，而许三多感情用事更多一些，这在战场上是致命的，尤其对于指挥官而言。<br /><img src="https://img-blog.csdnimg.cn/202003161416111.png"alt="在这里插入图片描述" /><br />袁朗曾经对他寄予厚望，但演习后一切似乎又戛然而止：</p><blockquote><p>你老把一切当成你的对立，总想征服一切，费了这么大的力，我们只想在你们没有战争的时候，就经历第一场战争。战争中伤亡最重的总是新兵，因为没有心理经历，没有适应时间。<br />理由你太见外，任何个人和团体很难在你的心里占到一席之地。你很活跃，也很有能力，但你很封闭，你总是在自己的世界里，想自己的，做自己的。成才，我们这伙人不只是为了对抗，你的战友，甚至你的敌人，需要你去理解、融洽和经历。<br /><strong>你经历的每个地方、每个人、每件事，都需要你付出时间和生命，可你从来没付出感情，你总是冷冰冰的把它们扔掉，那你的努力是为了什么？为一个结果虚耗人生？</strong>你该想的不是怎么成为一个特种兵，是善待自己做好普通一兵。<br />七连只是你的一个过路的地方，如果再有更好的去处，这儿也是你过路的地方，我们不敢跟这样的战友一起上战场。<br />我对你很失望，我一直在想，这么一个优秀的兵，为什么不能把我们当成他的战友。从那天起我开始对你失望，你们是团队的核心、精神、唯一的财富，其它都是虚的，我无法只看你们的表现，我更看重的是人。<br />我终于发现这世界上还有你在意的人，可这并不能说明你就学会了珍惜。</p></blockquote><p>很多时候，觉得世界并非纯粹的黑白，每个人的选择，也不能简单地用对错衡量。<br />第一次收看的时候，我十分讨厌这个家伙：自私、虚伪、圆滑，为了成绩不顾一切。他被淘汰出局时，观众看得很解气。作为对比，许三多单纯、团结、向上，虽然早期经历挫折，但后期军旅之路愈发风顺，这也是观众喜闻乐见的情节。<br />但随年岁增长，我们会发现许三多这样的人几乎不存在，而早期的成才则比比皆是。<br />能从五班重新走回老A，大多数人看到了他超乎寻常的冷静和神乎其神的枪法，却少有人关心他在五班的日子是怎么渡过的。要知道：从山峰跌落，要远比在平地上摔倒疼的多。唯一关心他的只有许三多（有这样的朋友，真是不知道交到什么好运气了）：</p><blockquote><p>你说他逃避了你设计的经历，这个你在意，可他真实经历了什么，你根本就不在意。你设计的几个小时，难道比他过的这段日子还要难吗？你要是去过五班就不会这样。</p></blockquote><p>后来他说自己只是草原上一个跑丢了的兵。草原五班的这段经历弥足珍贵，成才学着知足常乐、学着善待别人，他真的后悔了。<br />浴火重生，他真该感谢袁朗，让他重新起跑，而且跑得不算太晚。<br />最后的演习，很显然，他唯一的机会了。<br />这次没有让袁朗失望：</p><blockquote><p>你像个指挥员开始思考问题了。 吴哲领路，我不在的时候成才领队。</p></blockquote><p>事实上，这就是对成才的肯定。<br />袁朗故意暴露，一是掩护行动，二可能也想培养成才吧。</p><blockquote><p>你的路还很长，比许三多要长的多，同时你的迷茫要比他多得多，如果这是你的路，你愿意来老A吗？</p></blockquote>成才可算成才了~<br /><p align="right">写于2018年8月28日，知乎</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest XXX</title>
      <link href="/posts/longest-xxx/"/>
      <url>/posts/longest-xxx/</url>
      
        <content type="html"><![CDATA[<h2 id="longest-common-substring">Longest Common Substring</h2><ul><li>Brute Force<br />遍历<code>a</code>和<code>b</code>所有位置的组合，向后延伸，直到遇到两个不同的字符，复杂度是<spanclass="math inline">\(n^3\)</span>级别。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回所有结果</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">longestCommonSubstring</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                string cur;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = i, n = j; m &lt; a.<span class="built_in">size</span>() &amp;&amp; n &lt; b.<span class="built_in">size</span>(); ++m, ++n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[m] != b[n]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur += a[m];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.<span class="built_in">size</span>() &amp;&amp; cur.<span class="built_in">size</span>() &gt;= maxLen) &#123;</span><br><span class="line">                    maxLen = cur.<span class="built_in">size</span>();</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>DP<br />暴力解有很多重复计算：比如以<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>为起点去向后延伸，我们可能需要比较<spanclass="math inline">\(i+1\)</span>和<spanclass="math inline">\(j+1\)</span>、<spanclass="math inline">\(i+2\)</span>和<spanclass="math inline">\(j+2\)</span>...而以<spanclass="math inline">\(i+1\)</span>和<spanclass="math inline">\(j+1\)</span>为起点时，仍然要比较<spanclass="math inline">\(i+2\)</span>和<spanclass="math inline">\(j+2\)</span>，<strong>重叠子问题</strong>给动态规划带来了可能。<br />暴力做法是将每个<span class="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>作为起点，现在我们考虑将<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>作为终点，令<spanclass="math inline">\(L(i,j)\)</span>表示text1[0...i]和text2[0...j]中的最长子串的长度（不是非要以<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>作为结尾）： <spanclass="math display">\[L(i,j)=\begin{cases}1+L(i-1,j-1)&amp; \text{a[i]=b[j]}\\0&amp; \text{a[i]!=b[j]}\end{cases}\]</span> 为了简便，假设下标从1开始，那么边界条件：<spanclass="math inline">\(L(0,j)=0,L(i,0)=0\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">L</span>(<span class="number">1</span> + a.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> + b.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    L[i][j] = <span class="number">1</span> + L[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    L[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen, L[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显然时间降为<spanclass="math inline">\(O(n^2)\)</span>，空间升为<spanclass="math inline">\(O(n^2)\)</span>。仔细观察，计算<spanclass="math inline">\(L(i,j)\)</span>只需要左上方<spanclass="math inline">\(L(i-1,j-1)\)</span>的信息，所以我们按照斜线方向计算，可以将空间优化到<spanclass="math inline">\(O(1)\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// from the up-right corner</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; a.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = row, j = col; i &lt; a.<span class="built_in">size</span>() &amp;&amp; j &lt; b.<span class="built_in">size</span>(); ++i, ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                    ++curLen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    curLen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen, curLen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (col &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                --col;  <span class="comment">// 斜线左移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++row;   <span class="comment">// 斜线下移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(TODO)输出所有的最长公共子串</p><h2 id="longest-common-subsequence">Longest Common Subsequence</h2><p>实现见<ahref="https://github.com/EIMadrigal/LeetCode/blob/master/DP/%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97.md">Github</a></p><ul><li>Brute Force<br />找到<code>a</code>的所有子序列，判断是否是<code>b</code>的子序列，指数级复杂度，也就没有写出来的必要了。</li><li>DP<br />重叠子问题很明显，而且LCS具有最优子结构，令<spanclass="math inline">\(L(i,j)\)</span>表示text1[0...i]和text2[0...j]的LCS长度（不是非要以<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>作为结尾）： <spanclass="math display">\[L(i,j)=\begin{cases}1+L(i-1,j-1)&amp; \text{a[i]=b[j]}\\max\{L(i-1,j),L(i,j-1)\}&amp; \text{a[i]!=b[j]}\end{cases}\]</span> 为了简便，假设下标从1开始，那么边界条件：<spanclass="math inline">\(L(0,j)=0,L(i,0)=0\)</span>。</li></ul><p>时间和空间都是<spanclass="math inline">\(O(mn)\)</span>。类似的，<spanclass="math inline">\(L(i,j)\)</span>依赖于左上角<spanclass="math inline">\(L(i-1,j-1)\)</span>、左边<spanclass="math inline">\(L(i,j-1)\)</span>、上边<spanclass="math inline">\(L(i-1,j)\)</span>，可以只存储上一行和当前行的<spanclass="math inline">\(L\)</span>。进一步考虑：可以只存储当前行的<spanclass="math inline">\(L\)</span>，外加一个变量<spanclass="math inline">\(pre\)</span>存储左上角<spanclass="math inline">\(L(i-1,j-1)\)</span>，空间可以优化到<spanclass="math inline">\(O(min(m,n))\)</span>：</p><h2 id="longest-increasing-subsequence">Longest IncreasingSubsequence</h2><p>具体实现见Github</p><ul><li>DP<br /><spanclass="math inline">\(dp[i]\)</span>表示从左向右扫描直到以a[i]元素结尾的序列所形成的LIS的长度，且子序列包含a[i]：<span class="math display">\[dp[i]=max\{dp[i],1+dp[j]\}, 0\leq j&lt;i,a[i]&gt;a[j]\]</span></li></ul><p>最终答案即是<span class="math inline">\(dp\)</span>数组的最大值：时间<span class="math inline">\(O(n^2)\)</span>，空间<spanclass="math inline">\(O(n)\)</span>。</p><ul><li>DP+Binary Search<br />遍历数组的过程中，不停填充<spanclass="math inline">\(dp\)</span>数组，维护<spanclass="math inline">\(dp\)</span>数组使得其存储递增序列：<br />如果<span class="math inline">\(nums[i]&gt;dp[-1]\)</span>，将<spanclass="math inline">\(nums[i]\)</span>加入dp数组；<br />否则，在dp数组中二分查找<spanclass="math inline">\(nums[i]\)</span>的位置，并将<code>lower_bound</code>位置更新为<code>nums[i]</code>,增大后续递增的可能性.<br />举例来说，<span class="math inline">\(nums=[0,8,4,12,2]\)</span>，<spanclass="math inline">\(dp\)</span>数组：<br /><span class="math inline">\([0]\)</span><br /><span class="math inline">\([0,8]\)</span><br /><span class="math inline">\([0,4]\)</span><br /><span class="math inline">\([0,4,12]\)</span><br /><span class="math inline">\([0,2,12]\)</span><br />虽然<spanclass="math inline">\(dp\)</span>数组最终存储的不是LIS，但长度确是LIS的长度.时间<span class="math inline">\(O(nlogn)\)</span>，空间<spanclass="math inline">\(O(n)\)</span>。</li></ul><h2 id="longest-palindromic-substring">Longest PalindromicSubstring</h2><ul><li>Brute Force<br />枚举每个子串的起始和结束位置，判断是否回文。时间<spanclass="math inline">\(O(n^3)\)</span>，空间<spanclass="math inline">\(O(1)\)</span>。</li><li>DP<br />假设输入<code>ababa</code>，如果我们已经判断了<code>bab</code>是回文的，那么<code>ababa</code>就不需要再扫描一遍，因为两端都是<code>a</code>。所以一个很直观的动规： 令<spanclass="math inline">\(dp(i,j)\)</span>去<strong>记忆</strong><spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>之间的串是否回文，那么转移方程： <spanclass="math display">\[dp(i,j)=dp(i+1,j-1)\&amp;\&amp;s[i]=s[j]\]</span>边界条件<spanclass="math inline">\(dp(i,i)=true,dp(i,i+1)=(s[i]=s[i+1])\)</span>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充方向：由边界条件dp(i,i)向其他地方扩展，只需要填充j&gt;i的三角形部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">length</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">length</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                    end = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][i + <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; s.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j] &amp;&amp; maxLen &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                        start = i;</span><br><span class="line">                        end = j;</span><br><span class="line">                        maxLen = end - start + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(n^2)\)</span>，空间<spanclass="math inline">\(O(n^2)\)</span>。 - Expand Around Center<br />回文串都是镜像对称的，可以遍历整个串，从当前位置向两边延伸，直到遇到不相等的字母。这里要考虑字符串长度的奇偶：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = <span class="built_in">expandCenter</span>(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = <span class="built_in">expandCenter</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">max</span>(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start + <span class="number">1</span>) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandCenter</span><span class="params">(string s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.<span class="built_in">length</span>() &amp;&amp; s[start] == s[end]) &#123;</span><br><span class="line">            --start;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end - start - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(n^2)\)</span>，空间<spanclass="math inline">\(O(1)\)</span>。</p><ul><li>Manacher's Algorithm（待填）<br />时间<span class="math inline">\(O(n)\)</span>。</li></ul><h2 id="longest-palindromic-subsequence">Longest PalindromicSubsequence</h2><ul><li>DP<br />令<span class="math inline">\(dp(i,j)\)</span>表示介于<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>间的LPS的长度，那么状态转移方程： <spanclass="math display">\[dp(i,j)=\begin{cases}2+dp(i+1,j-1)&amp; \text{s[i]=s[j]}\\max\{dp(i+1,j),dp(i,j-1)\}&amp; \text{s[i]$\neq$s[j]}\end{cases}\]</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; n;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(n^2)\)</span>，空间<spanclass="math inline">\(O(n^2)\)</span>。<br />同样，空间可以优化到<span class="math inline">\(O(n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i) &#123;</span><br><span class="line">            pre = dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; n;++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                    dp[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                    dp[j] = pre + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = tmp;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oliver Twist</title>
      <link href="/posts/oliver-twist/"/>
      <url>/posts/oliver-twist/</url>
      
        <content type="html"><![CDATA[<p>对于济贫院那些绅士们而言，贫民好吃懒做、贪得无厌。他们消耗的食物即是对教区最大的威胁。</p><p>绅士们的利益得不到满足时，孤儿们只能被驱之而后快，甚至被“加价出售”。</p><blockquote><p>然而，眼泪这种东西根本无法触及Bumble先生的灵魂，他的心是防水的。</p></blockquote><p>小Oliver被卖到棺材店做学徒，受尽欺凌，却从未忘记反抗。<br /><img src="https://img-blog.csdnimg.cn/2020030720431780.png"alt="Oliver Twist" /><br />逃离了魔窟，迎来的并非光明，而是欺骗。</p><p>骗他少不更事，骗他无依无靠，差点把他骗成了小偷。</p><blockquote><p>与其说这是白昼的诞生，不如说是黑夜的死亡。</p></blockquote><p>全书随处可见反讽口吻，英国的很多社会问题跃然纸上。</p><p>Oliver很幸运，Brownlow先生收留了他，照顾他，让他拥有了第一段短暂而又美妙的时光——小孩子应得的时光。</p><p>可是那种社会，善总是被恶击败。</p><p>无奈，重入贼巢。</p><blockquote><p>诡计多端的老犹太已经使这孩子误入歧途，他用孤独与忧郁去熏陶奥利弗的心，让他感到在这样一个阴森凄凉的地方，无论与谁为伍都比独自一人沉浸在忧愁苦恼中好受一些，他现在正将毒汁缓慢地注入Oliver的灵魂，企图熏染他，将那颗心变黑，永远改变它的颜色。</p></blockquote><p>他曾寄希望于Nancy，而Nancy亦没有辜负他。</p><p>先是保护他免遭毒打，后又不顾危险，报信给Brownlow先生。</p><p>幸运女神再一次光顾了小Oliver，枪伤让他与死神擦肩而过，来到希望的田野。</p><p>就这样开始了第二段毫无忧虑的时光。</p><blockquote><p>在睡梦中的孩子发出微笑，彷佛这些怜悯的表示唤醒了某种令人愉快的梦境，那里有他从未领略过的爱心与温情。有的时候，一支亲切的乐曲，一处幽静地方的潺潺水声，一朵花的芳香，甚而只是说出一个熟悉的字眼，会突然唤起一些模糊的记忆，那是一些不曾出现过的场景，它们会像微风一样飘散，彷佛刹那间唤醒了某种久以别离的、比较快乐的往事，而这种记忆单靠苦思冥想是怎么也想不起来的。</p></blockquote><p>Nancy是悲惨的，明明有机会逃离苦海，却因为不合时宜的爱情（也许是爱情吧）葬送了自己。</p><blockquote><p>她觉得自己积重难返，难以抛弃过去的生活，即使她讨厌它。</p></blockquote><p>天真地以为Bill会和她一起去过一些“干净”的日子。</p><p>恶的外表下隐藏着善，这无疑是可悲的，令人唏嘘的。</p><p>或许她的死亡是在救赎过去犯下的罪，是一种解脱，也是她很好的归宿了吧。</p><p>善恶终有报。</p><p>Bill杀人后疯狂地救火，不过只是掩饰自己犯下的罪行、求得一丝可怜的心理安慰而已，繁忙过后，留给他的只有煎熬和无尽的苦痛。</p><p>至于Fagin，那个恶魔</p><blockquote><p>这是他的最后一夜，一种意识到自己已经濒临绝境的幻灭感正向他那晦暗的灵魂全力袭来。</p></blockquote><p>抠抠索索一辈子，绞刑架确是他最终的栖息地。</p><p>如书中所言，</p><blockquote><p>在生活中我们不是置身事外的观众，而是粉墨登场的演员。</p></blockquote><p>降生后的角色是上帝赋予的，我们无能为力。</p><p>能做的，只是像小Oliver一样，永怀希望与感恩。</p><p align="right">写于2018年8月26日，知乎</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Knapsack Problem</title>
      <link href="/posts/knapsack-problem/"/>
      <url>/posts/knapsack-problem/</url>
      
        <content type="html"><![CDATA[<figure><imgsrc="https://img-blog.csdnimg.cn/824d4e63a6e34090847dac97a84a3806.png"alt="背包问题分类" /><figcaption aria-hidden="true">背包问题分类</figcaption></figure><h2 id="背包">0-1背包</h2><ul><li>描述：N件物品，第i件的重量是w[i]，价值v[i]。有一个容量为W的背包，求将哪些物品放入背包可使总价值最大。每件物品可以用<strong>0或1次</strong>。</li><li>分析：根据题意，可以写出表达式： <spanclass="math display">\[max(\Sigma v_ix_i), s.t. \Sigma w_ix_i&lt;=W,x_i\in\{0, 1\}\]</span>最直接的思路就是：对于每件物品，都有yes/no两种选择，尝试所有的组合，记录每个组合的价值，选出满足重量条件的最大价值。时间复杂度<spanclass="math inline">\(O(2^n)\)</span>，空间复杂度<spanclass="math inline">\(O(n)\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// backtracking</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">knapsack01</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v, string&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="function">string <span class="title">cur</span><span class="params">(w.size(), <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, W, w, v, cur, ans);</span><br><span class="line">        <span class="keyword">return</span> maxV;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> curW, <span class="keyword">int</span> curV, <span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v, string&amp; cur, string&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 到达叶子结点，得到一个解，所以在这里更改最终结果</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= w.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxV &lt; curV) &#123;</span><br><span class="line">                ans.<span class="built_in">assign</span>(cur);</span><br><span class="line">                maxV = curV;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// as for goods s, two choices</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            cur[s] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curW + i * w[s] &lt;= W) &#123;</span><br><span class="line">                curW += i * w[s];</span><br><span class="line">                curV += i * v[s];</span><br><span class="line">                <span class="built_in">dfs</span>(s + <span class="number">1</span>, curW, curV, W, w, v, cur, ans);</span><br><span class="line">                curW -= i * w[s];</span><br><span class="line">                curV -= i * v[s];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxV = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的程序可以通过剪枝进行优化，下来换一种思路：<br />令<code>dp[i][j]</code>表示有前i件物品可选，背包容量为j时具有的最大价值，问题转化为求<code>dp[N][0...W]</code>的最大值，边界条件：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一列全0，第一行取决于物品0体积与背包大小关系</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(w.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = w[<span class="number">0</span>]; j &lt;= W; ++j) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = v[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 假设3件物品，<spanclass="math inline">\(w=\{1,1,2\}\)</span>，<spanclass="math inline">\(v=\{1,2,4\}\)</span>，<spanclass="math inline">\(W=2\)</span>，先用递归形式分析，每件物品只有yes/no两种状态：<img src="https://img-blog.csdnimg.cn/20200223185930802.png"alt="在这里插入图片描述" />可以看到，求解过程中有很多<strong>重叠子问题</strong>，故可以采用记忆化递归求解，时间复杂度即为子问题数量<spanclass="math inline">\(O(NW)\)</span>，空间复杂度<spanclass="math inline">\(O(NW)\)</span>。<br />记忆化递归可以写成自底向上的动态规划，状态转移方程： <spanclass="math display">\[dp[i][j]=max\{dp[i-1][j],v[i]+dp[i-1][j-w[i]]\}\]</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp-&gt;space complexity O(NW)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">knapsack01</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], v[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>前i件物品只依赖于前i-1件物品，<spanclass="math inline">\(dp\)</span>数组的更新方向为： <imgsrc="https://img-blog.csdnimg.cn/20200223200829966.png"alt="在这里插入图片描述" /><br />所以可以使用滚动数组降低空间复杂度为<spanclass="math inline">\(O(W)\)</span>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp-&gt;space complexity O(W)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">knapsack01</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="comment">// iterate j reversely, avoid dp override</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= w[i - <span class="number">1</span>]; --j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], v[i - <span class="number">1</span>] + dp[j - w[i - <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>01背包有一些细节需要注意：</p><ul><li>两个for循环的先后：核心在于当前值取决于其正上方的值和上一行前面的某个值，二维中行优先和列优先都可以保证更新当前值之前其需要的两个值已经更新，故可以颠倒；一维中列优先是不可以的，因为上一行前面的某个值会被覆盖</li><li>二维和一维j的遍历顺序：二维正反都可以；一维只能反向，否则会被覆盖</li></ul><p>有一道比较类似的题目<ahref="https://leetcode.com/problems/target-sum/">TargetSum</a>，分析下此题顺便再练习下DP的套路。<br />题意是这样：给定一些<strong>非负</strong>数字，可以给每个数字添上<code>+</code>或<code>-</code>号，使得添加后的所有数字之和等于<code>S</code>。数组大小不超过20，<code>S</code>大小不超过1000。<br />我第一次做感觉这是个纯暴力DFS，枚举所有可能，复杂度<spanclass="math inline">\(O(2^n)\)</span>。这道题和0/1背包不同之处在于：数组里的所有数字都必须用到。</p><p>接着我们试着做一些优化：<br />换种方式看问题：在这堆数字中选一些作为正数集合<spanclass="math inline">\(P\)</span>，剩下作为负数集合<spanclass="math inline">\(N\)</span>，那么有<spanclass="math inline">\(sum(P)-sum(N)=S\)</span>，<spanclass="math inline">\(sum(P)+sum(N)+sum(P)-sum(N)=sum(nums)+S=2*sum(P)\)</span>，故<spanclass="math inline">\(sum(P)=(sum(nums)+S)/2\)</span>，同时注意到<spanclass="math inline">\(sum(nums)+S\)</span>是偶数。<br />所以问题转化为在数组中寻找一些数作为正数，使得这些数的和为<spanclass="math inline">\((sum(nums)+S)/2\)</span>，求这样的组合有多少种。这就转化为了0/1背包问题。</p><p>我们用<spanclass="math inline">\(dp(i,j)\)</span>表示从前i个数中选出和为j的方案数目，有状态转移方程<spanclass="math inline">\(dp(i,j)=dp(i-1,j)+dp(i-1,j-nums[i])\)</span>，如果纯粹暴力递归，有很多重叠子问题（类似背包问题的那个图）。BaseCase就是，<spanclass="math inline">\(dp(0,0)=1\)</span>，即选出和为0的方案，就是每个都不选一种；否则当<code>i = 0 || j &lt; 0</code>时，<spanclass="math inline">\(dp(i,j)=0\)</span>。</p><p>所以先用记忆化搜索：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">memo</span>(<span class="number">21</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">1001</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> sum &lt; S || (sum + S) &amp; <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">cnt</span>(nums, memo, nums.<span class="built_in">size</span>(), (sum + S) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp;memo, <span class="keyword">int</span> idx, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!idx &amp;&amp; !sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!idx || sum &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (memo[idx][sum] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[idx][sum];</span><br><span class="line">        memo[idx][sum] = <span class="built_in">cnt</span>(nums, memo, idx - <span class="number">1</span>, sum) + <span class="built_in">cnt</span>(nums, memo, idx - <span class="number">1</span>, sum - nums[idx - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> memo[idx][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改一下Bottom-Up的形式，更新方向从左到右、从上到下，注意这里j不能从<code>nums[i - 1]</code>开始，否则j的前半部分无法更新到正确的值，后面如果用到就是错误的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S || (sum + S) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">21</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">1001</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 不能for (int j = nums[i - 1]; j &lt;= (sum + S) &gt;&gt; 1; ++j)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= (sum + S) &gt;&gt; <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()][(sum + S) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后来优化空间：<spanclass="math inline">\(dp(i,j)\)</span>取决于<spanclass="math inline">\(dp(i-1,j)\)</span>和<spanclass="math inline">\(dp(i-1,j-num[i-1])\)</span>，所以只要用一个一维数组<spanclass="math inline">\(dp(j)\)</span>记录上一行的所有值即可，这里必须反向更新，因为如果正向，上一行的j-num[i-1]位置已经被新值覆盖，计算结果出错。如果反向：上一行需要的2个位置都没有被覆盖：<spanclass="math inline">\(dp(j)=dp(j)+dp(j-nums[i-1])\)</span>。<br />初始时候(0,0)位置为1，即<spanclass="math inline">\(dp(0)=1\)</span>，以后<spanclass="math inline">\(dp(0)\)</span>会不断更新。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt; S || (S + sum) &amp; <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">numSubsetSum</span>(nums, (S + sum) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubsetSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">/* 等价写法</span></span><br><span class="line"><span class="comment">        for (int j = target; j &gt;= 0; --j)&#123;</span></span><br><span class="line"><span class="comment">if (j - nums[i] &gt;= 0)</span></span><br><span class="line"><span class="comment">dp[j] += dp[j - nums[i]];</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line">            <span class="comment">// 只有j&gt;=nums[i]才更新，否则沿用上一行的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i]; --j) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="完全背包">完全背包</h2><ul><li>每件物品可以使用<strong>任意多次</strong>。</li><li>一个Naive的思路：虽然题目描述每件物品可以使用任意多次，但实际上由于W的限制，每件物品最多使用<spanclass="math inline">\(\lfloor W/w[i]\rfloor\)</span>次。这样我们可以将每件物品拆为<spanclass="math inline">\(\lfloor W/w[i]\rfloor\)</span>件，问题就转化为了0-1背包。子问题仍然有NW个，但是求解每个子问题需要<spanclass="math inline">\(O(W/w[i])\)</span>，总的时间复杂度<spanclass="math inline">\(O(\Sigma (W/w[i])*W)\)</span>，也即<spanclass="math inline">\(O(W*拆后物品件数)\)</span>。</li><li>更tricky的做法：W无法改变，只能改变<strong>拆后物品件数</strong>。这里可以使用二进制的思想：假设我们某件物品可以使用<spanclass="math inline">\(10=8+2\)</span>次，原本需要复制出10件，现在只要复制出2件，价值和重量是原来的8倍和2倍，这样就降低了复杂度。</li><li>完全背包有<span class="math inline">\(O(NW)\)</span>的算法</li></ul><p><spanclass="math inline">\(dp(i,j)=max\{dp(i-1,j-kw[i])+kv[i]\},0\leqkw[i]\leq j\)</span><br />为了得到更加简洁的表示，考虑： <span class="math display">\[dp(i,j-w[i])=max\{dp(i-1,j-w[i]-aw[i])+av[i]\},0\leq aw[i]\leqj-w[i],a\geq 0 \\=max\{dp(i-1,j-(a+1)w[i])+av[i]\},0\leq aw[i]\leq j-w[i],a\geq 0 \\=max\{dp(i-1,j-kw[i])+(k-1)v[i]\},0\leq (k-1)w[i]\leq j-w[i],k\geq 1 \\=max\{dp(i-1,j-kw[i])+kv[i]\}-v[i],0\leq (k-1)w[i]\leq j-w[i],k\geq 1\]</span> 因此当<span class="math inline">\(k\geq 1\)</span>时有<spanclass="math inline">\(max\{dp(i-1,j-kw[i])+kv[i]\}=dp(i,j-w[i])+v[i]\)</span><br />综上有<spanclass="math inline">\(dp(i,j)=max\{dp(i-1,j),dp(i,j-w[i])+v[i]\}\)</span>，状态<spanclass="math inline">\(dp(i,j-w[i])\)</span>包含了第i件物品被选择若干次后的最大价值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsackUnbounded</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], v[i - <span class="number">1</span>] + dp[i][j - w[i - <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsackUnbounded</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i - <span class="number">1</span>]; j &lt;= W; ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], v[i - <span class="number">1</span>] + dp[j - w[i - <span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完全背包两个for循环的顺序也可以颠倒，但是j的遍历只能而且应该正向。</p><h2 id="多重背包">多重背包</h2><ul><li>每件物品最多可以使用<spanclass="math inline">\(num[i]\)</span>次。</li><li>同样，Naive的思路就是将每件物品都复制<spanclass="math inline">\(num[i]\)</span>次，问题转化为0-1背包，复杂度<spanclass="math inline">\(O(\Sigma nums[i]*W)\)</span>。</li><li>将<spanclass="math inline">\(num[i]\)</span>用二进制表示，价值和重量变为原来的相应倍，降低复杂度。</li></ul><h2 id="future">Future</h2><p>后续还有混合背包、二维费用的背包等，详情可以学习<ahref="https://comzyh.com/upload/PDF/Pack-PDF-Comzyh.pdf">背包九讲</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shortest Path</title>
      <link href="/posts/shortest-path/"/>
      <url>/posts/shortest-path/</url>
      
        <content type="html"><![CDATA[<h2 id="dijkstra">Dijkstra</h2><p>BFS可以用来求无权图的最短路径，Dijkstra是<strong>单源最短路径</strong>算法，<ahref="https://www.zhihu.com/question/21620069">一般的DIJ算法不能用于含负权边的图</a>，本质上还是贪心思想：</p><ol type="1"><li>将所有结点分为两类：已经确定最短路径的点集<spanclass="math inline">\(u\)</span>、未确定最短路径的点<spanclass="math inline">\(v\)</span>；</li><li>初始化<spanclass="math inline">\(dis[start]=0\)</span>，其余结点<spanclass="math inline">\(dis\)</span>设为无穷大；</li><li>找出一个<span class="math inline">\(dis\)</span>最小的<spanclass="math inline">\(v\)</span>中的点<spanclass="math inline">\(x\)</span>，将其标记为<spanclass="math inline">\(u\)</span>，遍历<spanclass="math inline">\(x\)</span>的所有<strong>邻接点</strong><spanclass="math inline">\(y\)</span>，若<spanclass="math inline">\(dis[y]&gt;dis[x]+w[x][y]\)</span>，则更新<spanclass="math inline">\(y\)</span>点到源点的最短路径长度<spanclass="math inline">\(dis[y]=dis[x]+w[x][y]\)</span>；</li><li>重复，直到所有点都在<span class="math inline">\(u\)</span>中。</li></ol><p>邻接矩阵版，适合顶点比较少的图，复杂度<spanclass="math inline">\(O(2V^2)\)</span><br />邻接表版，复杂度<span class="math inline">\(O(V^2+E)\)</span></p><p>寻找点<spanclass="math inline">\(x\)</span>的循环可以用堆来优化，使得复杂度降为<spanclass="math inline">\(O(VlogV+E)\)</span>。</p><p>堆的优化要注意2点:</p><ul><li>小根堆要按照<spanclass="math inline">\(dis\)</span>组织，但是在调整时要保证<spanclass="math inline">\(dis\)</span>到顶点索引的映射关系，所以堆存储<spanclass="math inline">\((index,dis)\)</span></li><li>松弛时堆里已经有某些顶点，这些顶点更新后的新值也要压入堆，原先堆里的顶点既无法更新，也无法删除。所以我们允许堆里出现相同的顶点，但是对于<code>marked</code>标记过的点直接<code>pop+continue</code>即可。</li></ul><p>C++实现在这里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = g.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 寻找未访问点中dis最小的</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = <span class="number">-1</span>, minDis = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; minDis) &#123;</span><br><span class="line">                minDis = dis[j], minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩余的点与起点不连通</span></span><br><span class="line">        <span class="keyword">if</span> (minIdx == <span class="number">-1</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vis[minIdx] = <span class="literal">true</span>;  <span class="comment">// 锁死当前的最小点</span></span><br><span class="line">        <span class="comment">// 以minIdx为中介试图优化dis[j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="comment">// 未锁死、j可达、路过minIdx可以使dis[j]更优</span></span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; g[minIdx][j] != INT_MAX &amp;&amp; dis[minIdx] + g[minIdx][j] &lt; dis[j])</span><br><span class="line">                dis[j] = dis[minIdx] + g[minIdx][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;&amp; g, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = g.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 寻找未访问点中dis最小的</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = <span class="number">-1</span>, minDis = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; minDis) &#123;</span><br><span class="line">                minDis = dis[j], minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (minIdx == <span class="number">-1</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vis[minIdx] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 直接获得minIdx能到达的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[minIdx].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = g[minIdx][j].first, id = g[minIdx][j].second;</span><br><span class="line">            <span class="keyword">if</span> (!vis[id] &amp;&amp; dis[minIdx] + w &lt; dis[id])</span><br><span class="line">                dis[id] = dis[minIdx] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表 + 堆优化</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;p&gt;&gt;&amp; g, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = g.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(n, INT_MAX)</span>, <span class="title">parent</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIdx = pq.<span class="built_in">top</span>().second, minDis = pq.<span class="built_in">top</span>().first;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[minIdx]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[minIdx] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> adj : g[minIdx]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[adj.second] &amp;&amp; dis[minIdx] + adj.first &lt; dis[adj.first]) &#123;</span><br><span class="line">                dis[adj.first] = dis[minIdx] + adj.first;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;dis[adj.first], adj.second&#125;);</span><br><span class="line">                parent[adj.second] = minIdx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    pq = []</span><br><span class="line">    heapq.heappush(pq, (<span class="number">0</span>, s))</span><br><span class="line"></span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    parent = &#123;s : <span class="literal">None</span>&#125;</span><br><span class="line">    dis = &#123;s : <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g:</span><br><span class="line">        <span class="keyword">if</span> v != s:</span><br><span class="line">            dis[v] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(pq) &gt; <span class="number">0</span>):</span><br><span class="line">        pair = heapq.heappop(pq)</span><br><span class="line">        cur_dis = pair[<span class="number">0</span>]</span><br><span class="line">        cur_vertex = pair[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur_vertex <span class="keyword">in</span> marked:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        marked.add(cur_vertex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur_vertex].keys():</span><br><span class="line">            <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked <span class="keyword">and</span> cur_dis + g[cur_vertex][adj] &lt; dis[adj]:</span><br><span class="line">                heapq.heappush(pq, (cur_dis + g[cur_vertex][adj], adj))</span><br><span class="line">                parent[adj] = cur_vertex</span><br><span class="line">                dis[adj] = cur_dis + g[cur_vertex][adj]</span><br><span class="line">    <span class="keyword">return</span> parent, dis</span><br></pre></td></tr></table></figure><h2 id="bellman-ford">Bellman-Ford</h2><p>可以计算含有负权的边，检测是否存在一个从源结点可以到达的权重为负值的环路（负权环）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellmanFord</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edge, vector&lt;<span class="keyword">int</span>&gt;&amp; dis, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == start)</span><br><span class="line">            dis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dis[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edge.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            dis[edge[j][<span class="number">1</span>]] = <span class="built_in">min</span>(dis[edge[j][<span class="number">1</span>]], dis[edge[j][<span class="number">0</span>]] + edge[j][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> negCycle = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (dis[edge[i][<span class="number">1</span>]] &gt; dis[edge[i][<span class="number">0</span>]] + edge[i][<span class="number">2</span>]) &#123;</span><br><span class="line">            negCycle = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> negCycle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度<span class="math inline">\(O(VE)\)</span>。</p><h2 id="floyd-warshall">Floyd-Warshall</h2><p>多源最短路径算法。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> k = <span class="number">0</span>;k &lt; m.<span class="built_in">size</span>();++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; m.<span class="built_in">size</span>();++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// m不能用INT_MAX初始化，会溢出，用0x3f3f3f3f</span></span><br><span class="line">                <span class="keyword">if</span> (m[i][k] + m[k][j] &lt; m[i][j])</span><br><span class="line">                    m[i][j] = m[i][k] + m[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>不能用于有累加和为负的环的图</strong>，这种图不存在最短路径。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompressIt</title>
      <link href="/posts/compress-it/"/>
      <url>/posts/compress-it/</url>
      
        <content type="html"><![CDATA[<h2 id="结构">结构</h2><p>压缩软件的核心在于压缩算法。基于Huffman编码的压缩算法思路：</p><ol type="1"><li>以<strong>二进制方式</strong>读取源文件，按照每8bits作为一个字符；</li><li>统计每个字符的出现频率即为叶子结点的权值，按照Huffman算法得到每个叶子的编码；</li><li>对源文件的每个字符，将新的编码组合为二进制流，按照每8bits一个单位写入压缩文件。</li></ol><p>举例来看：<br />假设我们有待压缩源文件<code>hello</code>，<code>h</code>的ASCII码为<code>01101000</code>，同理可得整个文件的二进制形式<code>0110100001100101011011000110110001101111</code>，共5B，40bits。<br />根据Huffman算法：得到<code>h</code>的编码为<code>00</code>，同理可得整个文件的Huffman编码为<code>0001111110</code>，末尾不够8bits，采用补0的方法可得<code>0001111110000000</code>，按照每8bits一个单位，写入压缩文件的是<code>31</code>和<code>255</code>对应的字符，共2B，16bits。<br />解压缩流程是压缩的逆过程：</p><ol type="1"><li>以<strong>二进制方式</strong>读取压缩文件；</li><li>每次取1bit，从Huffman树的根结点出发，找到某个叶子即为源字符。</li></ol><h2 id="效果">效果</h2><p>做一个简单的比较：</p><table><thead><tr><th>压缩软件</th><th>测试文件</th><th>压缩率</th><th>测试文件</th><th>压缩率</th></tr></thead><tbody><tr><td>CompressIt</td><td>txt(840B)</td><td>70.4%</td><td>png(282KB)</td><td>101%</td></tr><tr><td>WinRaR</td><td>txt(840B)</td><td>14.4%</td><td>png(282KB)</td><td>100%</td></tr></tbody></table><p>压缩率和压缩时间和专业软件没法比。之所以出现压缩文件大于源文件，是因为压缩文件中还存储了Huffman树等信息，为解压所需。<br />对于不同内容的文件，得到的压缩文件大小也不尽相同，这主要与Huffman编码的性质有关。</p><h2 id="理论分析">理论分析</h2><p>Huffman编码依赖于信源的统计特征，其背后的原理在于为出现频率高的字符分配尽可能短的码长，这样就可以降低平均码长：<span class="math display">\[L=\Sigma p_il_i\]</span> 使得<spanclass="math inline">\(L\)</span>最短的编码就是最优编码，可以证明Huffman编码是一种最优编码。<br />同时Huffman编码还是前缀码，简化了解码过程。<br />假设一种理想情况：源文件长<spanclass="math inline">\(len\)</span>很大，共有<spanclass="math inline">\(m\)</span>种不同字符，每个字符用8bits表示，并且每种字符出现频率<spanclass="math inline">\(\frac{len}{m}\)</span>相同，忽略掉存储Huffman树等信息所需的空间。<br />这棵完全二叉树共有结点<spanclass="math inline">\(n=2*m-1\)</span>个，那么树深度为<spanclass="math inline">\(h=1+\lfloor log_2n\rfloor\)</span>，每个字符的压缩长度为<spanclass="math inline">\(h-1=\lfloor log_2n\rfloor\)</span>，故压缩后的串长度为<spanclass="math inline">\(\frac{(h-1)*len}{8}\)</span>，可得压缩率<spanclass="math inline">\(\frac{h-1}{8}\)</span>，即： <spanclass="math display">\[\alpha=\frac{\lfloor log_2(2*m-1)\rfloor}{8}\]</span> 源文件中不同字符种类<spanclass="math inline">\(m\)</span>越小，即源文件分布越集中，压缩效果越好。<br />如果和定长编码比较，可以得到压缩率： <spanclass="math display">\[\alpha=\frac{\lfloor log_2(2*m-1) \rfloor}{\lceillog_2(m) \rceil}\]</span> <spanclass="math inline">\(m\)</span>取值256时，Huffman树是一棵满二叉树，压缩率为100%，并不比8位固定长度编码更高效。</p><h2 id="收获">收获</h2><ul><li><code>EOF</code>和<code>feof()</code><code>EOF</code>是一个定义在<code>cstdio</code>头文件中的宏，一般为-1：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOF (-1)</span></span><br></pre></td></tr></table></figure><p>但是如果按照二进制读取文件，对于文件中的-1又该如何处理？<br />阮一峰的博客说：</p><blockquote><p>在Linux系统之中，EOF根本不是一个字符，而是当系统读取到文件结尾，所返回的一个信号值（也就是-1）。至于系统怎么知道文件的结尾，资料上说是通过比较文件的长度。</p></blockquote><p>我们通常会写出下面程序来读取文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = <span class="built_in">fgetc</span>(fp)) != EOF) &#123;</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>fgetc()</code>在到达文件结尾和发生读取错误的情况下都会返回<code>EOF</code>，所以上述代码不严谨，采用<code>feof()</code>函数来判断文件结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">feof</span>(fp)) &#123;</span><br><span class="line">    ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是采用<code>feof()</code>也有一个问题：读取最后一个字符后，<code>feof()</code>仍然返回0，进入循环，<code>fgetc()</code>再向后读取一个字符，<code>feof()</code>才返回1，这样程序会多循环一次。<br />所以比较安全的写法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line"><span class="keyword">while</span> (ch != EOF) &#123;</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">    ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">feof</span>(fp))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End-of-File reached.&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Something went wrong.&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>虚析构函数<br />基类的析构函数一般写成虚函数，做个测试：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>() &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor in base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f in base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derive</span> :</span><span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">derive</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">derive</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor in derive&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f in derive&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">base* p = <span class="keyword">new</span> derive;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f in derive</span><br><span class="line">destructor in derive</span><br><span class="line">destructor in base</span><br></pre></td></tr></table></figure><p>如果基类的析构函数不是虚函数，输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f in derive</span><br><span class="line">destructor in base</span><br></pre></td></tr></table></figure><p>结果并没有调用派生类的析构函数，造成内存泄漏。<br />所以基类的虚析构函数的作用是：<strong>当一个基类指针删除一个派生类对象，确保调用派生类的析构函数</strong>。- 二进制文件<br />在压缩过程中，对于不同格式源文件的读取都是采用二进制方式<code>rb</code>。<br />实际上二进制文件和文本文件并没有本质区别，你所看到的内容取决于打开文件的软件对二进制流的解释方式，文件扩展名帮助计算机知道应该用哪种解释方式，通常的文本文件的解释方式有ASCII码和Unicode码。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Union-Find</title>
      <link href="/posts/union-find/"/>
      <url>/posts/union-find/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>并查集是一种用来维护集合的数据结构，底层通过<code>parent</code>数组实现，每个集合只有唯一的根结点，并将其作为该集合的标志。</p><p>并查集有两个基本操作：</p><ol type="1"><li>并：合并两集合；</li><li>查：查询某元素的父结点。</li></ol><p>初始化所有元素都是一个独立的集合： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> parent[MAXN];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    parent[i] = i;    <span class="comment">// i元素的父结点初始化为自己，也可以初始化为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="合并与查找">合并与查找</h2><ul><li>Find<br />查找某个元素属于哪个集合（如果单独成集就返回自己），返回该集合的代表元素（即parent为-1的那个元素/parent为自身的那个元素）。<br />查找的同时可以通过<strong>路径压缩</strong>来将均摊复杂度降低为<spanclass="math inline">\(O(1)\)</span>。查找某个结点时，将其经过的全部结点直接连到根结点，这样下次的查询次数就会急剧减小。</li><li>Union<br />合并时可以遵循<strong>按秩合并</strong>原则，将秩小的树合并到秩大的树，降低合并时路径压缩的开销。<br />将两个不同的集合合并，只要将其中一个集合的根结点的<code>parent</code>指向另一个集合的根结点即可。<br />对于属于同一个集合的两个元素的合并没有意义，所以我们一般只对两个不同的集合进行合并，这样避免同一个集合成环，因此并查集的每个集合都是一棵树。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parents_;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ranks_;</span><br><span class="line">    <span class="keyword">int</span> setsCnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="keyword">int</span> n) : <span class="built_in">setsCnt</span>(n) &#123;</span><br><span class="line">        <span class="comment">// 是否等于n取决于index从0开始还是从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            parents_.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            ranks_.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the root of x</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// path compression</span></span><br><span class="line">        <span class="keyword">if</span> (x != parents_[x]) &#123;</span><br><span class="line">            parents_[x] = <span class="built_in">find</span>(parents_[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parents_[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge set u and v</span></span><br><span class="line">    <span class="comment">// false -&gt; u and v are already in one set</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootu = <span class="built_in">find</span>(u);</span><br><span class="line">        <span class="keyword">int</span> rootv = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (rootu == rootv)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// merge low rank to high rank</span></span><br><span class="line">        <span class="keyword">if</span> (ranks_[rootu] &lt; ranks_[rootv]) &#123;</span><br><span class="line">            parents_[rootu] = rootv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ranks_[rootu] &gt; ranks_[rootv]) &#123;</span><br><span class="line">            parents_[rootv] = rootu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parents_[rootu] = rootv;</span><br><span class="line">            ++ranks_[rootv];</span><br><span class="line">        &#125;</span><br><span class="line">        setsCnt--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSetCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> setsCnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并查集可以将均摊复杂度变为<spanclass="math inline">\(O(1)\)</span>，但如果涉及到删除元素、计算每个集合元素个数等操作时，实现会有些复杂；<br />好吧！计算每个集合元素个数以及统计有多少个集合并不复杂，计算元素个数可以开一个数组cnt初始全为1，每次merge都更新cnt即可，cnt[i]即为根为i的集合包含的元素个数<br />统计多少个集合遍历所有元素，遇到不同的根结点就更新ans。</p><p><ahref="https://www.zxpblog.cn/2020/02/17/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%AD%97%E5%85%B8%E6%A0%91%E5%92%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/">最原始的并查集</a>虽然复杂度稍差，但是可以完成的功能比较多。<br /><ahref="https://www.cnblogs.com/EIMadrigal/p/12693959.html">原始并查集实现</a></p><p>一道例题：<ahref="https://www.luogu.com.cn/problem/P1551">亲戚</a><br />不做路径压缩可以求<ahref="https://www.nowcoder.com/profile/135924065/codeBookDetail?submissionId=83987857">最小环长</a></p><h2 id="无向图判环">无向图判环</h2><p>并查集可以用来检测无向图是否有环.<br />初始时认为每个节点都是独立的集合, 如果在加入边<spanclass="math inline">\((i,j)\)</span>之前节点<spanclass="math inline">\(i\)</span>和节点<spanclass="math inline">\(j\)</span>已经同属一个集合, 意味着节点<spanclass="math inline">\(i\)</span>和节点<spanclass="math inline">\(j\)</span>必然有某条其他路径连通, 该路径和边<spanclass="math inline">\((i,j)\)</span>必然构成环. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;  <span class="comment">// edge list</span></span><br><span class="line">g.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">g.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">g.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> rootx = <span class="built_in">Find</span>(g[i].first);</span><br><span class="line">        <span class="keyword">int</span> rooty = <span class="built_in">Find</span>(g[i].second);</span><br><span class="line">        <span class="keyword">if</span> (rootx == rooty) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Union</span>(rootx, rooty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="种类并查集todo">种类并查集（TODO）</h2><p>普通并查集的特点就是只有一个集合，比如上述例题只有亲戚一个集合。如果涉及到多个集合，就需要种类并查集。<br />假如有n个集合，常用的手法就是开一个n倍大小的并查集。<br /><a href="https://www.luogu.com.cn/problem/P2024">食物链</a><br /><a href="https://www.luogu.com.cn/problem/P1892">团伙</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List-3</title>
      <link href="/posts/linked-list-3/"/>
      <url>/posts/linked-list-3/</url>
      
        <content type="html"><![CDATA[<p>第一篇<ahref="https://www.cnblogs.com/EIMadrigal/p/12130882.html">终结LinkedList（一）</a>、<ahref="https://www.cnblogs.com/EIMadrigal/p/12130892.html">终结LinkedList（二）</a>主要讲了单链表的基础知识，接下来的第二篇主要讲一些比较经典的问题。</p><h2 id="一count">一、<code>Count()</code></h2><p>给一个单链表和一个整数，返回这个整数在链表中出现了多少次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Given a list and an int, return the number of times </span><br><span class="line">that int ocucurs in the list.</span><br><span class="line">*/</span><br><span class="line">int Count(struct node* head,int searchFor)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    struct node* cur = head;</span><br><span class="line"></span><br><span class="line">    while (cur != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (cur-&gt;data == searchFor)</span><br><span class="line">            cnt++;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用<code>for</code>循环实现。</p><h2 id="二getnth">二、<code>GetNth()</code></h2><p>给一个单链表和一个index，返回index位置上的数值，类似<code>array[index]</code>操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Given a list and an index, return the data in the nth</span><br><span class="line">node of the list. The nodes are numbered from 0.</span><br><span class="line">Assert fails if the index is invalid (outside 0..length - 1).</span><br><span class="line">*/</span><br><span class="line">int GetNth(struct node* head,int index)</span><br><span class="line">&#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    struct node* cur = head;</span><br><span class="line"></span><br><span class="line">    while (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        if (len == index)</span><br><span class="line">        &#123;</span><br><span class="line">            return cur-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(0);  //如果走到这一行，表达式的值为假，断言失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三deletelist">三、<code>DeleteList()</code></h2><p>给一个单链表，删除所有节点，使<code>head</code>为<code>NULL</code>。删除链表<code>&#123;1,2,3&#125;</code>的示意图：<br /><imgsrc="https://img-blog.csdnimg.cn/201904071952350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void DeleteList(struct node** headRef)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* cur = *headRef;  //deref headRef to get the real head</span><br><span class="line"></span><br><span class="line">    while (*headRef)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = *headRef;</span><br><span class="line">        *headRef = cur-&gt;next;</span><br><span class="line">        free(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四pop">四、<code>Pop()</code></h2><p>给一个链表，删掉头节点，返回头节点的数据。<br />内存示意图：<br /><imgsrc="https://img-blog.csdnimg.cn/20190407230157807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">The opposite of Push().Takes a non-empty list and </span><br><span class="line">remove the front node, and returns the data which was in that node.</span><br><span class="line">*/</span><br><span class="line">int pop(struct node** headRef)</span><br><span class="line">&#123;</span><br><span class="line">    assert(*headRef != NULL);</span><br><span class="line">    int ans = (*headRef)-&gt;data;  //pull out the data before the node is deleted</span><br><span class="line"></span><br><span class="line">    struct node* cur = *headRef;</span><br><span class="line">    *headRef = (*headRef)-&gt;next;   //unlink the head node for the caller</span><br><span class="line">    free(cur);    //free the head node</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五insertnth">五、<code>InsertNth()</code></h2><p>可以在<code>[0,length]</code>的任意位置插入指定元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">A more general version of Push().</span><br><span class="line">Given a list, an index &#x27;n&#x27; in the range 0..length,</span><br><span class="line">and a data element, add a new node to the list so that</span><br><span class="line">it has the given index.</span><br><span class="line">*/</span><br><span class="line">void InsertNth(struct node** headRef,int index,int data)</span><br><span class="line">&#123;</span><br><span class="line">    //position 0 is a special case</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(headRef, data);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        struct node* cur = *headRef;</span><br><span class="line"></span><br><span class="line">        while (cnt &lt; index - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            assert(cur != NULL);   //if this fails, the index was too big</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert(cur != NULL);    //tricky:you have to check one last time</span><br><span class="line"></span><br><span class="line">        Push(&amp;(cur-&gt;next), data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码坑有点多，可以通过<strong>画图</strong>或者<strong>单步跟踪</strong>的方法调试。<br /><code>InsertNthTest()</code>可以用来测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void InsertNthTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;   //start with the empty list</span><br><span class="line">     </span><br><span class="line">    InsertNth(&amp;head, 0, 13);   //&#123;13&#125;</span><br><span class="line">    InsertNth(&amp;head, 1, 42);    //&#123;13,42&#125;</span><br><span class="line">    InsertNth(&amp;head, 1, 5);     //&#123;13,5,42&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六sortedinsert">六、<code>SortedInsert()</code></h2><p>给定一个有序链表和一个节点，将该节点插入到合适的位置。 共有三种方法：1、Uses special case code for the head end <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void SortedInsert(struct node** headRef,struct node* newNode)</span><br><span class="line">&#123;</span><br><span class="line">    //Special case for the head end</span><br><span class="line">    if (newNode-&gt;data &lt;= (*headRef)-&gt;data || *headRef == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        newNode-&gt;next = *headRef;</span><br><span class="line">        *headRef = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //Locate the node before the point of insertion</span><br><span class="line">        struct node* cur = *headRef;</span><br><span class="line">        while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;data &lt; newNode-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2、Dummy nodestrategy for the head end用<code>dummy node</code>这种方法一般不需要处理特殊情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void SortedInsert2(struct node** headRef,struct node* newNode) &#123;</span><br><span class="line">    struct node dummy;</span><br><span class="line">    struct node* cur = &amp;dummy</span><br><span class="line">    dummy.next = *headRef;</span><br><span class="line"></span><br><span class="line">    while (cur-&gt;next &amp;&amp; newNode-&gt;data &gt;= cur-&gt;next-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;next = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = newNode;</span><br><span class="line"></span><br><span class="line">    *headRef = dummy.next;  //头指针永远指向dummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Local references strategy for the head end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void SortedInsert3(struct node** headRef,struct node* newNode)</span><br><span class="line">&#123;</span><br><span class="line">    struct node** curRef = headRef;</span><br><span class="line"></span><br><span class="line">    while (*curRef &amp;&amp; (*curRef)-&gt;data &lt;= newNode-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        curRef = &amp;((*curRef)-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;next = *curRef;  //Bug:(*curRef)-&gt;next  is incorrect</span><br><span class="line"></span><br><span class="line">    *curRef = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表反转">链表反转</h2><p>链表反转的题目都是套路, 如果要反转<spanclass="math inline">\([l,r)\)</span>内的部分, 需要记录l的前一个结点.让<code>cur = l, prev = r</code>, 循环次数等于<spanclass="math inline">\([l,r)\)</span>内的结点数, 每次循环都是标准操作:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp = cur.next  </span><br><span class="line">cur.next = prev  </span><br><span class="line">prev = cur  </span><br><span class="line">cur = tmp </span><br></pre></td></tr></table></figure></p><p>最终<code>cur</code>指向r,<code>prev</code>指向反转后的第一个结点即原链表的r - 1.<br />头结点主要看你是反转整个链表还是一部分，反转整个链表就没必要了，因为l直接指向头结点<br />92题可以直接按照上述方法做，但是开始要把r指向正确的位置，相当于多走了一遍，因此开始把prev设置为None，反转结束先通过l前一个结点修正l的指针指向cur，再让l前一个结点指向prev</p><p>25题因为要分组反转，所以需要判断剩余的结点够不够k个，因此r必然需要向后走一遍去判断，因此[l,r)肯定要走2遍。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimum Spanning Tree</title>
      <link href="/posts/minimum-spanning-tree/"/>
      <url>/posts/minimum-spanning-tree/</url>
      
        <content type="html"><![CDATA[<p>最小生成树算法用来在<strong>无向带权图</strong>中寻找一组边的集合,该边集使得图中所有顶点连通, 没有环路并且权值和最小.常见的MST算法包括Kruskal和Prim.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, weight;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Edge&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight == x.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeHash</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> Edge&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.from * <span class="number">2</span> + x.to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">unordered_set&lt;Edge, EdgeHash&gt; <span class="title">kruskalMST</span><span class="params">(<span class="keyword">int</span> vertex_num, vector&lt;Edge&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;Edge, EdgeHash&gt; ans;</span><br><span class="line">    std::<span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), [](<span class="keyword">const</span> Edge&amp; a, <span class="keyword">const</span> Edge&amp; b) &#123;<span class="keyword">return</span> a.weight &lt; b.weight;&#125;);</span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(vertex_num)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (Edge&amp; cur : g) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = uf.<span class="built_in">find</span>(cur.from), v = uf.<span class="built_in">find</span>(cur.to);</span><br><span class="line">        <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(cur);</span><br><span class="line">            uf.<span class="built_in">merge</span>(u, v);</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">size</span>() == vertex_num - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vertex_num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (uf.<span class="built_in">find</span>(i) != uf.<span class="built_in">find</span>(i + <span class="number">1</span>))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;不连通&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">unordered_set&lt;Edge, EdgeHash&gt; <span class="title">primMST</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;Edge, EdgeHash&gt; ans;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Edge&amp; a, <span class="keyword">const</span> Edge&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 解锁边进入小根堆</span></span><br><span class="line">    priority_queue&lt;Edge, vector&lt;Edge&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">smallq</span>(cmp);</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; nodeset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    nodeset.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; g.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[<span class="number">0</span>][j] != INT_MAX)</span><br><span class="line">            smallq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, j, g[<span class="number">0</span>][j]&#125;);  <span class="comment">// 解锁该点的边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!smallq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Edge cur = smallq.<span class="built_in">top</span>(); smallq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> to_node = cur.to;  <span class="comment">// 可能新点</span></span><br><span class="line">        <span class="keyword">if</span> (nodeset.<span class="built_in">find</span>(to_node) == nodeset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">insert</span>(cur);</span><br><span class="line">            ++cnt;</span><br><span class="line">            nodeset.<span class="built_in">insert</span>(to_node);</span><br><span class="line">            <span class="keyword">if</span> (cnt == g.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[to_node][j] != INT_MAX &amp;&amp; nodeset.<span class="built_in">find</span>(j) == nodeset.<span class="built_in">end</span>())</span><br><span class="line">                    smallq.<span class="built_in">push</span>(&#123;to_node, j, g[to_node][j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeset.<span class="built_in">find</span>(i) == nodeset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;不连通&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">primMST</span><span class="params">(vector&lt;vector&lt;p&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; vis;</span><br><span class="line">    priority_queue&lt;p, vector&lt;p&gt;, greater&lt;p&gt;&gt; smallq;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    vis.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[<span class="number">0</span>].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        smallq.<span class="built_in">push</span>(g[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!smallq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        p cur = smallq.<span class="built_in">top</span>(); smallq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis.<span class="built_in">find</span>(cur.second) == vis.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ans += cur.first;</span><br><span class="line">            vis.<span class="built_in">insert</span>(cur.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[cur.second].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis.<span class="built_in">find</span>(g[cur.second][i].second) == vis.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                smallq.<span class="built_in">push</span>(g[cur.second][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis.<span class="built_in">find</span>(i) == vis.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;不连通&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小生成森林</span></span><br><span class="line"><span class="function">unordered_set&lt;Edge, EdgeHash&gt; <span class="title">primMSForest</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Edge&amp; a, <span class="keyword">const</span> Edge&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.weight &gt; b.weight;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 解锁边进入小根堆</span></span><br><span class="line">    priority_queue&lt;Edge, vector&lt;Edge&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">smallq</span>(cmp);</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; nodeset;</span><br><span class="line"></span><br><span class="line">    unordered_set&lt;Edge, EdgeHash&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodeset.<span class="built_in">find</span>(i) == nodeset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            nodeset.<span class="built_in">insert</span>(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; g[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] != INT_MAX)</span><br><span class="line">                    smallq.<span class="built_in">push</span>(&#123;i, j, g[i][j]&#125;);  <span class="comment">// 解锁该点的边</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!smallq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                Edge cur = smallq.<span class="built_in">top</span>(); smallq.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> to_node = cur.to;  <span class="comment">// 可能新点</span></span><br><span class="line">                <span class="keyword">if</span> (nodeset.<span class="built_in">find</span>(to_node) == nodeset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    ans.<span class="built_in">insert</span>(cur);</span><br><span class="line">                    nodeset.<span class="built_in">insert</span>(to_node);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (g[to_node][j] != INT_MAX &amp;&amp; nodeset.<span class="built_in">find</span>(j) == nodeset.<span class="built_in">end</span>())</span><br><span class="line">                            smallq.<span class="built_in">push</span>(&#123;to_node, j, g[to_node][j]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kruskal">Kruskal</h2><p>将所有边的权值递增排序, 如果选择权值最小的边加入后不构成回路,则将该边加入MST, 直到MST中有<spanclass="math inline">\(n-1\)</span>条边或<spanclass="math inline">\(n\)</span>个顶点.</p><p>那么如何判断加入边是否构成回路呢? 方法有很多啦,<strong>并查集</strong>是一个不错的选择. 每次加边时如果该边的两顶点<spanclass="math inline">\(u\)</span>和<spanclass="math inline">\(v\)</span>在同一个集合, 就判断下条边,否则将该边加入答案并合并<span class="math inline">\(u\)</span>和<spanclass="math inline">\(v\)</span>.</p><p>遍历完成后, 所有顶点都同属一个集合, 因此可以通过判断顶点<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(i+1\)</span>是否同属一个集合,进而判断该图是否连通.</p><p>用<strong>边集</strong>表示图比较方便, 复杂度<spanclass="math inline">\(O(ElogE)\)</span>, 适合边稀疏而顶点相对多的图.</p><h2 id="prim">Prim</h2><p>Prim算法的思想是:</p><ol type="1"><li>整个顶点集为<spanclass="math inline">\(V\)</span>，初始选一个起点<spanclass="math inline">\(s\)</span>，令集合<spanclass="math inline">\(U=\{s\}, V=\{\}\)</span>;</li><li>在集合<span class="math inline">\(U\)</span>与集合<spanclass="math inline">\(V-U\)</span>中的点组成的边中，选一条权值最小的边<spanclass="math inline">\(u_0v_0\)</span>加入MST，并且将<spanclass="math inline">\(u_0\)</span>加入<spanclass="math inline">\(U\)</span>;</li><li>重复直到MST有<span class="math inline">\(n-1\)</span>条边或<spanclass="math inline">\(n\)</span>个顶点为止.</li></ol><p>因此, 需要一个<code>unordered_set</code>表示已经访问过的顶点集合<spanclass="math inline">\(U\)</span>,还需要一个<code>priority_queue</code>维护集合<spanclass="math inline">\(U\)</span>与集合<spanclass="math inline">\(V-U\)</span>之间的边权和dest.</p><p>用<strong>邻接表</strong>表示图比较方便, 复杂度<spanclass="math inline">\(O(V^2)\)</span>, 适合边稠密的图.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯学习</title>
      <link href="/posts/bayesian-learning/"/>
      <url>/posts/bayesian-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>贝叶斯概率理论是由ThomasBayes在1764年提出，采用一种概率的方式进行推理。贝叶斯学习有2个假设： -观察到的样本实例并非确定性事件，而是随机的，服从某种概率分布； -通过对观测数据样本和相关的概率特性进行推理学习能够得到最优的决策或分类。</p><p>贝叶斯学习为衡量多个假设的置信度提供了定量的方法，其依赖于贝叶斯决策理论（BayesianDecisionTheory）。贝叶斯决策理论是一种统计学上的方法，用来定量化地描述使用概率做出的不同决策以及这些决策付出的代价之间的权衡。首先假设一些概率值是已知的，然后根据这些已知概率推理一些未知情况下的概率值，最终利用这些推理的概率值进行决策。</p><p>以分类问题为例，假设有2种鱼分别是鲑鱼和鲈鱼，将w定义为观测到的鱼的类型，令<spanclass="math inline">\(w=w_1\)</span>代表鲈鱼，<spanclass="math inline">\(w=w_2\)</span>代表鲑鱼，定义<spanclass="math inline">\(P(w_1)\)</span>表示下一条鱼是鲈鱼的先验概率，<spanclass="math inline">\(P(w_2)\)</span>表示下一条鱼是鲑鱼的先验概率。先验概率反映了人们根据经验和背景知识对事物的判断，即在看到下一条鱼之前对于<spanclass="math inline">\(P(w_1)\)</span>和<spanclass="math inline">\(P(w_2)\)</span>的判断。如果没有经验上的偏好，就可以设置为均匀先验<spanclass="math inline">\(P(w_1)=P(w_2)\)</span>；如果有诸如海域因素、时间等背景，便可以为<spanclass="math inline">\(P(w_1)\)</span>和<spanclass="math inline">\(P(w_2)\)</span>设置不同的先验概率。另外假设只有这2种鱼，即<spanclass="math inline">\(P(w_1)+P(w_2)=1\)</span>。在仅有先验概率的情况下，选择先验概率大的作为最终决策，这种情况下决策错误的概率为<spanclass="math inline">\(min\{P(w_1),P(w_2)\}\)</span>。</p><p>贝叶斯决策理论是很多重要的学习算法的基础，例如朴素贝叶斯分类器、贝叶斯信念网络以及EM算法等。另外，贝叶斯决策理论为许多非贝叶斯的学习算法提供了很好的数学和框架性理论基础，对某些学习任务而言，贝叶斯学习是最实用的方法之一。</p><p>贝叶斯学习有以下特点： -每个观测到的训练样本都可以很小程度上增大或减小某个假设正确的概率； -先验知识可以和观测数据结合起来决定某个假设的最终概率，可以计算显式的假设概率；- 新实例的预测可以结合多个假设输出概率的加权值； -通常需要一些背景知识或先前经验来确定先验概率，选出贝叶斯最优分类器计算代价比较大。</p><h2 id="贝叶斯定理">贝叶斯定理</h2><p>贝叶斯定理是贝叶斯学习的基石，给定训练数据集D，在假设空间H中寻找最优的假设h，最优假设可以定义为给定数据集D以及H中不同假设的先验概率条件下的最可能的假设。利用贝叶斯定理，在已知假设的先验概率、观测数据以及给定假设下观测到特定数据的概率就可以计算出最有可能的假设。</p><p>给定数据集D以及假设空间H，定义如下记号： -先验概率P(h)：没有训练数据前假设h的初始概率，反映了根据人们的相关认知背景，假设h成为正确假设的概率，如果没有先验知识，可以将每一个候选假设的先验概率设置为相同的。-先验概率P(D)：训练数据D的先验概率，即不知道哪个假设成立的前提下观测到D的概率。- 观测数据的条件概率P(D|h)：在假设h成立的条件下观测到数据集D的概率。 -后验概率P(h|D)：给定观测到的训练数据集D时假设h成立的概率，反映了观测到的训练数据是D时h成立的置信度。</p><p>利用贝叶斯定理可以计算给定训练数据集D下任一假设的后验概率： <spanclass="math display">\[P(h|D)=\frac{P(D|h)P(h)}{P(D)}\]</span></p><p>贝叶斯推理得到的结果很大程度上依赖于先验概率，并且不是完全接受或拒绝假设h，而是给出假设为真的可能性。因此可以计算每个假设的概率，输出其中概率最大的，称为最大后验概率准则（MaximumA Posteriori）。</p><p><span class="math display">\[h_{MAP}=\underset{h\in H}{\operatorname{\argmax}}\ P(h|D) \\=\underset{h\in H}{\operatorname{\argmax}}\ \frac{P(D|h)P(h)}{P(D)} \\=\underset{h\in H}{\operatorname{\argmax}}\ P(D|h)P(h)\]</span></p><p>如果假设空间中每个假设的先验概率都是相同的，即<spanclass="math inline">\(P(h_i)=P(h_j),\forall h_i\in H \wedge \forallh_j\inH\)</span>，那么只需要考虑给定假设h下数据D的似然P(D|h)，这样最大后验概率准则就变为了最大似然估计（MaximumLikelihood）： <span class="math display">\[h_{ML}=\underset{h\in H}{\operatorname{\argmax}}\ P(D|h)\]</span></p><h2 id="最小描述长度原则">最小描述长度原则</h2><p>根据奥卡姆剃刀原则，其它条件相同时选择最简单的假设，最简单的假设可以定义为描述长度最小的假设，即给定假设空间H和数据集D，应该寻找一个假设或者假设组合使得D被最大程度地压缩。定义<spanclass="math inline">\(L_{C}(x)\)</span>表示在编码机制C下编码x需要的最少的比特数为编码机制C下的x的描述长度。<span class="math display">\[h_{MDL}=\underset{h\in H}{\operatorname{\argmin}}\L_{C_1}(h)+L_{C_2}(D|h)\]</span></p><p><spanclass="math inline">\(L_{C_1}(h)\)</span>是假设的描述长度即比特数，反映了模型的复杂程度；<spanclass="math inline">\(L_{C_2}(D|h)\)</span>是当采用假设h编码后数据的描述长度，反映了错误的数目。通常会发现：一个非常复杂的假设（<spanclass="math inline">\(L_{C_1}(h)\)</span>大）会有一个比较好的拟合（<spanclass="math inline">\(L_{C_2}(D|h)\)</span>小），反之一个非常简单的假设（<spanclass="math inline">\(L_{C_1}(h)\)</span>小）会有比较差的拟合（<spanclass="math inline">\(L_{C_2}(D|h)\)</span>大）。因此希望寻找一个假设：既不会过于复杂同时还可以对数据有比较好的拟合。</p><p>如果对MAP的公式进行变形： <span class="math display">\[h_{MAP}=\underset{h\in H}{\operatorname{\argmax}}\ P(D|h)P(h) \\=\underset{h\in H}{\operatorname{\argmax}}\ log_2P(D|h)+log_2P(h) \\=\underset{h\in H}{\operatorname{\argmin}}\ -log_2P(h)-log_2P(D|h) \\\]</span></p><p>可以看到：第一项<spanclass="math inline">\(-log_2P(h)\)</span>对应了最优编码机制<spanclass="math inline">\(C_1\)</span>下h的描述长度<spanclass="math inline">\(L_{C_1}(h)\)</span>，第二项<spanclass="math inline">\(-log_2P(D|h)\)</span>对应了最优编码机制<spanclass="math inline">\(C_2\)</span>下数据的描述长度<spanclass="math inline">\(L_{C_2}(D|h)\)</span>。两者的优化目标是一致的。</p><h2 id="贝叶斯最优分类器">贝叶斯最优分类器</h2><p>通过MAP准则可以求出在给定训练数据下的最有可能的假设，那么如何求出给定训练集下一个新实例的最优预测呢？可以对新实例使用MAP准则，求得最大的假设然后进行分类。</p><p>但是最优的结果应该是结合所有假设的预测结果对新实例进行分类，结合的方法是通过后验概率加权：<span class="math display">\[\underset{v_j\in V}{\operatorname{\argmax}}\ \sum_{h_i\inH}P(v_j|h_i)P(h_i|D)\]</span></p><p>V表示所有可能的预测结果，<spanclass="math inline">\(v_j\)</span>是其中一种预测分类。<spanclass="math inline">\(P(v_j|h_i)\)</span>表示假设<spanclass="math inline">\(h_i\)</span>将新实例预测为<spanclass="math inline">\(v_j\)</span>的概率大小，<spanclass="math inline">\(P(h_i|D)\)</span>表示假设<spanclass="math inline">\(h_i\)</span>的后验概率。</p><p>例如假设空间<spanclass="math inline">\(H=\{h_1,h_2,h_3\}\)</span>，可能的预测结果<spanclass="math inline">\(V=\{+,-\}\)</span>，对于一个新实例假设有： <spanclass="math display">\[P(h_1|D)=0.4, P(-|h_1)=0, P(+|h_1)=1 \\P(h_2|D)=0.3, P(-|h_2)=1, P(+|h_2)=0 \\P(h_3|D)=0.3, P(-|h_3)=1, P(+|h_3)=0 \\\]</span></p><p>那么有： <span class="math display">\[\sum_{h_i\in H}P(+|h_i)P(h_i|D)=0.4 \\\sum_{h_i\in H}P(-|h_i)P(h_i|D)=0.6 \\\]</span> 因此最终选择将新实例分类为-。</p><p>可以看到：贝叶斯最优分类器最大化了新实例被正确分类的概率，在使用相同假设空间和先验知识的条件下，没有其他方法比贝叶斯最优分类器的平均效果好，最终的预测结果可能对应一个不包含于<spanclass="math inline">\(H\)</span>的假设。</p><p>虽然效果很好，但是贝叶斯最优分类器计算代价非常大： -需要遍历假设空间中的所有假设； -当假设空间非常大时这种方式是不可行的。</p><p>因此可以通过吉布斯算法（Gibbs）解决。吉布斯算法根据假设的后验概率分布随机选取一个假设对新实例进行分类。可以证明：在特定条件下，该方法的期望误差最多是贝叶斯最优分类器的两倍。还可以通过采样多个假设并求其预测结果的平均值来提高吉布斯算法的性能，例如可以使用马尔科夫蒙特卡洛采样（MCMC）。</p><h2 id="bagging分类器">Bagging分类器</h2><p>虽然可以使用吉布斯算法来降低计算代价，但是从后验概率分布P(h|D)采样是比较困难的：- P(h|D)的计算本身就比较困难 -对于不是基于概率的分类器例如SVM等P(h|D)是无法计算的 -当假设空间很大时P(h|D)计算结果会很小</p><p>为了解决上述问题，引入Bagging的思想，通过对训练样本的采样实现对后验分布P(h|D)的采样。假设给定的数据集D包含m个样本，自助采样法（Bootstrapsampling）步骤如下： - 从D中有放回地采样m个样本构成数据集<spanclass="math inline">\(D^i\)</span> - D中大约有37%的样本不会被采样到</p><p>Bagging算法步骤如下： - 创建k个自助采样的数据集<spanclass="math inline">\(D^1,D^2,...,D^k\)</span> - 在每个数据集<spanclass="math inline">\(D^i\)</span>独立训练分类器<spanclass="math inline">\(h_i\)</span> -通过相等权重的投票法来对新实例进行分类：</p><p><span class="math display">\[c^*(x)=\underset{c}{\operatorname{\argmax}}\ \sum_{i=1}^{k}P(c|h_i,x)\]</span>由于自助采样法几乎和直接从后验概率分布P(h|D)采样相同，因此Bagging产生的分类器也近似于贝叶斯最优分类器。通常Bagging产生的分类器效果要优于单独的分类器，因为其有效地降低了模型的方差。</p><h2 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h2><p>假设训练集D中的每条实例x均可以被n个属性的组合<spanclass="math inline">\(&lt;a_1,a_2,...,a_n&gt;\)</span>描述，并且<spanclass="math inline">\(v(x)\inV\)</span>是一个有限的集合。那么贝叶斯方法对于新实例的分类是选择一个最有可能的目标值：<span class="math display">\[v_{MAP}=\underset{v_j\in V}{\operatorname{\argmax}}\P(v_j|a_1,a_2,...,a_n)\]</span></p><p>通过贝叶斯定理进行变形： <span class="math display">\[v_{MAP}=\underset{v_j\in V}{\operatorname{\argmax}}\\frac{P(a_1,a_2,...,a_n|v_j)P(v_j)}{P(a_1,a_2,...,a_n)}\]</span></p><p>那么要如何计算<span class="math inline">\(P(v_j)\)</span>和<spanclass="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>呢？ - <spanclass="math inline">\(P(v_j)\)</span>可以通过每个目标值<spanclass="math inline">\(v_j\)</span>在训练数据中出现的频率来估算 -在训练数据集很小的情况下，<spanclass="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>的估算是不可能的，不同的<spanclass="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>的数目等于所有可能的目标值的数量与所有可能的样本数目的乘积。</p><p>为了解决上述问题，提出了朴素贝叶斯假设，即在给定目标值下样本属性之间是条件独立的：<span class="math display">\[P(a_1,a_2,...,a_n|v_j)=\prod_{i}P(a_i|v_j)\]</span></p><p>因此朴素贝叶斯分类器即为： <span class="math display">\[v_{NB}=\underset{v_j\in V}{\operatorname{\argmax}}\P(v_j)\prod_{i}P(a_i|v_j)\]</span></p><p>其中，<spanclass="math inline">\(v_{NB}\)</span>是朴素贝叶斯分类器的预测输出，<spanclass="math inline">\(P(a_i|v_j)\)</span>是训练数据中目标值<spanclass="math inline">\(v_j\)</span>时属性<spanclass="math inline">\(a_i\)</span>的频率。不同的<spanclass="math inline">\(P(a_i|v_j)\)</span>的数目等于不同的目标值数量与属性数量的乘积，该数值远小于不同的<spanclass="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>的数目。</p><p>下面举一个朴素贝叶斯分类器的例子，假设训练数据如下： <imgsrc="https://img-blog.csdnimg.cn/286e8b45687d4d259b1ef6ba87433c2f.png"alt="在这里插入图片描述" /></p><p>需要对于一个新实例{Outlook=sunny, Temperature=cool, Humidity=high,Wind=strong}进行分类，所有可能的目标值是{yes, no}。因此分类器为： <spanclass="math display">\[v_{NB}=\underset{v_j\in \{yes,no\}}{\operatorname{\argmax}}\P(v_j)\prod_{i}P(a_i|v_j)\]</span></p><p>从训练数据可知，<spanclass="math inline">\(P(v_j)\)</span>即不同目标值的概率为： <spanclass="math display">\[P(yes)=9/14=0.64, P(no)=5/14=0.36\]</span></p><p>条件概率<span class="math inline">\(P(a_i|v_j)\)</span>为： <spanclass="math display">\[P(Wind=strong|yes)=3/9=0.33 \\P(Wind=strong|no)=3/5=0.60 \\...\]</span></p><p>因此可以计算： <span class="math display">\[P(yes)P(sunny|yes)P(cool|yes)P(high|yes)P(strong|yes)=0.0053 \\P(no)P(sunny|no)P(cool|no)P(high|no)P(strong|no)=0.0206 \\\]</span></p><p>故最终的预测结果为no。</p><h2 id="贝叶斯信念网络">贝叶斯信念网络</h2><p>贝叶斯最优分类器应用起来代价太大，朴素贝叶斯分类器虽然使用条件独立假设降低了代价，但是很多情况下条件独立假设都难以满足。因此，贝叶斯信念网络做了一个折衷，允许对属性集合的子集应用条件独立假设。</p><p>贝叶斯信念网络是一种概率图模型，通过有向无环图（DAG）来表示一系列变量及它们的条件依赖关系和变量集合的联合概率分布。通常用结点表示变量，可以是观测变量、隐藏变量、未知参数和假设等等；用边表示结点间的依赖关系；条件概率表的每个元素对应图中唯一的结点，存储该结点对于其所有直接前驱结点的联合条件概率。</p><p>贝叶斯信念网络一条非常重要的性质是：每个结点在其直接前驱结点的值给定后，该结点条件独立于其所有非直接前驱结点。条件独立的定义是：在给定Z的条件下X的概率分布与Y的取值无关，即：<span class="math display">\[\forall x_i,y_j,z_k\ P(X=x_i|Y=y_j,Z=z_k)=P(X=x_i|Z=z_k)\]</span></p><p>条件独立的定义可以扩展到多个变量的情形：即在给定变量<spanclass="math inline">\(Z_1,...,Z_n\)</span>的条件下，变量集合<spanclass="math inline">\(X_1,...,X_l\)</span>的概率分布与变量集合<spanclass="math inline">\(Y_1,...,Y_m\)</span>的取值无关： <spanclass="math display">\[P(X_1,...,X_l|Y_1,...,Y_m,Z_1,...,Z_n)=P(X_1,...,X_l|Z_1,...,Z_n)\]</span></p><p>朴素贝叶斯分类器即使用了条件独立假设使得<spanclass="math inline">\(P(X,Y|Z)=P(X|Y,Z)P(Y|Z)=P(X|Z)P(Y|Z)\)</span>。</p><p>贝叶斯网络也可以看作是表示变量之间因果性的因果图，可以进行原因推理或结果预测。例如，假设草坪是湿的记作变量W，那么有多大概率是因为下雨（记作变量R）造成的？那么可以利用贝叶斯网络进行原因推理：<span class="math display">\[P(R|W)=\frac{P(W|R)P(R)}{P(W)}=\frac{P(W|R)P(R)}{P(W|R)P(R)+P(W|\simR)P(\sim R)}\]</span></p><p>同样可以进行结果的预测，假设洒水器打开记作事件S，那么有多大概率草坪是湿的是因为S导致的？即洒水器和下雨都可能导致草坪是湿的：<span class="math display">\[P(W|S)=P(W|R,S)P(R|S)+P(W|\sim R,S)P(\sim R|S) \\=P(W|R,S)P(R)+P(W|\sim R,S)P(\sim R)\]</span></p><p>随着贝叶斯网络的结点与边的增加，可以进行更加复杂的因果推断。</p><h2 id="总结">总结</h2><p>贝叶斯学习为基于先验知识的概率学习方法提供了理论基础，在先验知识的基础上，根据观测数据修正先验知识，计算出每个假设的后验概率进而进行预测。可以选择出在给定观测数据下的最有可能的假设即MAP假设，贝叶斯最优分类器通过后验概率的加权结合了所有可能假设的预测结果去得到新实例的最有可能的预测结果。朴素贝叶斯分类器通过条件独立假设增强了其实用性，在很多实际应用中表现很好。贝叶斯信念网络提供了一种条件独立的变量之间更强大的表示方法，使得其可以有更加广泛的应用场景。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Segment Tree</title>
      <link href="/posts/segment-tree/"/>
      <url>/posts/segment-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="引言">引言</h2><p><ahref="https://leetcode.com/problems/range-sum-query-mutable/">Leetcode307</a>这道题如果没有优化,那么单次query的时间复杂度<span class="math inline">\(O(n)\)</span>,单次update复杂度<span class="math inline">\(O(1)\)</span><br />如果用前缀和数组, 那么单次query的时间复杂度<spanclass="math inline">\(O(1)\)</span>, 单次update复杂度<spanclass="math inline">\(O(n)\)</span>,因为update(i)会使得前缀和数组i以后的元素均更新</p><p>因此如果query和update非常多次, 上面的2种方式效率都比较低.</p><p>这道题除了使用树状数组，还可以使用线段树。<br />线段树是一种平衡二叉树，支持快速区间查找<spanclass="math inline">\(O(lgn+k)\)</span>和更新<spanclass="math inline">\(O(lgn)\)</span>。</p><h2 id="线段树">线段树</h2><p><ahref="https://github.com/EIMadrigal/Recap/blob/main/Templates/Advanced/segment_tree.cpp">具体实现在这里</a>线段树核心思想是叶子结点负责保存原始信息，非叶结点负责其孩子表示范围的union，可以是求和、最值等：<img src="https://img-blog.csdnimg.cn/20200115103411544.png"alt="在这里插入图片描述" />对于每个结点，需要存储起始点、终止点、值、左右指针：</p><p>建树可以通过递归方式进行：</p><p>对于<strong>更新</strong>操作，只要找到叶子结点，一路向上更新至根结点，复杂度<spanclass="math inline">\(O(lgn)\)</span>：</p><p>对于<strong>查询</strong>操作，查询范围有三种情况：</p><ol type="1"><li>范围正好和根结点负责的范围一致，直接返回；</li><li>范围由某个下层结点负责，找到该结点返回其值；</li><li>范围由两个下层结点组合负责，返回两个结点的sum。</li></ol><p>查询最好情况复杂度<spanclass="math inline">\(O(1)\)</span>，最坏情况<spanclass="math inline">\(O(lgn+k)\)</span>，<spanclass="math inline">\(k\)</span>是某层结点的数目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">        <span class="built_in">TreeNode</span>(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val) : <span class="built_in">start</span>(l), <span class="built_in">end</span>(r), <span class="built_in">val</span>(val), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        ~<span class="built_in">TreeNode</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (left) &#123;</span><br><span class="line">                <span class="keyword">delete</span> left;</span><br><span class="line">                left = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right) &#123;</span><br><span class="line">                <span class="keyword">delete</span> right;</span><br><span class="line">                right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start, end, val;  <span class="comment">// val can be sum, min, max...</span></span><br><span class="line">        TreeNode* left, *right;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(l, r, nums[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* lef = <span class="built_in">buildTree</span>(nums, l, m);</span><br><span class="line">        TreeNode* rig = <span class="built_in">buildTree</span>(nums, m + <span class="number">1</span>, r);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(l, r, lef-&gt;val + rig-&gt;val);</span><br><span class="line">        root-&gt;left = lef, root-&gt;right = rig;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(TreeNode* root, <span class="keyword">int</span> i, <span class="keyword">int</span> newVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;start == i &amp;&amp; root-&gt;end == i) &#123;</span><br><span class="line">            root-&gt;val = newVal;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = root-&gt;start + (root-&gt;end - root-&gt;start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= m) &#123;</span><br><span class="line">            <span class="built_in">update</span>(root-&gt;left, i, newVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">update</span>(root-&gt;right, i, newVal);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;val = root-&gt;left-&gt;val + root-&gt;right-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(TreeNode* root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == root-&gt;start &amp;&amp; r == root-&gt;end) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = root-&gt;start + (root-&gt;end - root-&gt;start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= m) &#123;  <span class="comment">// 查询范围完全落在左子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(root-&gt;left, l, r);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; m) &#123;  <span class="comment">// 查询范围完全落在右子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(root-&gt;right, l, r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(root-&gt;left, l, m) + <span class="built_in">query</span>(root-&gt;right, m + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><ul><li><ahref="https://zxi.mytechroad.com/blog/sp/segment-tree-sp14/">花花酱Segment Tree 线段树 SP14</a></li><li><ahref="https://www.cnblogs.com/TenosDoIt/p/3453089.html">一步一步理解线段树</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Indexed Tree</title>
      <link href="/posts/binary-indexed-tree/"/>
      <url>/posts/binary-indexed-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="引言">引言</h2><p><ahref="https://leetcode.com/problems/range-sum-query-mutable/">LeetCode307</a>这道题给一个<strong>可修改</strong>的数组，需要进行频繁的区域和检索。<br />一个naive的做法是，每次查询都从<spanclass="math inline">\(i\)</span>累加到<spanclass="math inline">\(j\)</span>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        nums_ = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        nums_[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k)</span><br><span class="line">            ans += nums_[k];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>这种方法每次更新的复杂度为<spanclass="math inline">\(O(1)\)</span>，<strong>单次查询</strong>的复杂度为<spanclass="math inline">\(O(n)\)</span>。</p><h2 id="树状数组">树状数组</h2><p>树状数组可以在<spanclass="math inline">\(O(lgn)\)</span>时间复杂度内完成上述两个操作：</p><ol type="1"><li>单点更新</li><li>计算前缀和并进行区间查询</li></ol><p>BIT并不需要定义树的结点和指针，而是维护了一个特殊的前缀和数组<code>prefix_sum_</code>，下面的例子均是1-indexed，调用BIT时需要传入原始索引+1。填充<code>prefix_sum_</code>的过程是这样的：<imgsrc="https://img-blog.csdnimg.cn/259f7f2172354cdd86e4283efaa79e14.png"alt="在这里插入图片描述" /> 1.按照索引的二进制表示，先看最低位，将所有最低位为1的数值直接存入T 2.再看次低位为1的（即10结尾的），将该数和前一个数（共2个数）的和存入T 3.再看以100结尾的，将该数及之前的3个数（共4个数）的和存入T 4.再看以1000结尾的，将8个数的和存入T，以此类推...</p><p>填充好<code>prefix_sum_</code>后，就可以查询原始数组的前缀和并且更新原始数组。</p><h2 id="查询">查询</h2><p>假设要求前缀和A[1]+...+A[7]即<code>query(7)</code>，只需要<code>query(7)+query(6)+query(4)</code>即可，从二进制来看就是<code>query(00111)+query(00110)+query(00100)</code>，即每次将最后一位1翻转然后累加直到i变为0。</p><h2 id="更新">更新</h2><p>假设要更新A[4]即<code>update(4, 10)</code>，需要更新T[4]和T[8]，即<code>00100</code>和<code>01000</code>，即每次将最后一位1左移直到i超出数组长度，移位过程中更新相应的T[i]。</p><p>填充<code>prefix_sum_</code>可以直接调用<code>update</code>。</p><p>那么我们的tree： <imgsrc="https://img-blog.csdnimg.cn/20200113151522944.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /> 0是dummynode，将结点的二进制表示的最后一个1翻转，就能得到其父结点。</p><p>下来填充这棵树： <spanclass="math inline">\(1=0+2^0\)</span>，存储从下标0开始的前1个数的和：3（0，0）；<spanclass="math inline">\(2=0+2^1\)</span>，存储从下标0开始的前2个数的和：5（0，1）；<spanclass="math inline">\(3=2^1+2^0\)</span>，存储从下标2开始的前1个数的和：-1（2，2）；<spanclass="math inline">\(4=0+2^2\)</span>，存储从下标0开始的前4个数的和：10（0，3）；<spanclass="math inline">\(5=2^2+2^0\)</span>，存储从下标4开始的前1个数的和：5（4，4）；<spanclass="math inline">\(6=2^2+2^1\)</span>，存储从下标4开始的前2个数的和：9（4，5）；<spanclass="math inline">\(7=2^2+2^1+2^0\)</span>，存储从下标6开始的前1个数的和：-3（6，6）；<spanclass="math inline">\(8=0+2^3\)</span>，存储从下标0开始的前8个数的和：19（0，7）；<spanclass="math inline">\(9=2^3+2^0\)</span>，存储从下标8开始的前1个数的和：7（8，8）；<spanclass="math inline">\(10=2^3+2^1\)</span>，存储从下标8开始的前2个数的和：9（8，9）；<spanclass="math inline">\(11=2^3+2^1+2^0\)</span>，存储从下标10开始的前1个数的和：3（10，10）；填充后的tree： <imgsrc="https://img-blog.csdnimg.cn/20200113154240511.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" />接下来就可以根据这棵树来计算<code>prefixSums_</code>： 假如要计算<spanclass="math inline">\(0-5\)</span>的和，从下标6出发，一直加到dummynode，得到<code>prefixSums_[6]=9+10=19</code>； 要计算<spanclass="math inline">\(0-9\)</span>的和，从下标10出发，一直加到dummynode，得到<code>prefixSums_[10]=9+19=28</code>。 以计算<spanclass="math inline">\(0-9\)</span>的和为例，结点10存储的是（8，9）的<strong>部分和</strong>，结点8存储的是（0，7）的<strong>部分和</strong>，所以加起来就是<spanclass="math inline">\(0-9\)</span>的和。</p><h2 id="快速实现">快速实现</h2><p>上面求结点的父结点、将下标拆解为二进制去填充树的方式很慢，来看一种稍快的方式。<strong>查询</strong>时，我们需要计算从某结点到dummynode的和，这就涉及计算该结点的parent：假如要求结点7的parent，7的二进制原码为<code>111</code>，-7的补码为<code>001</code>，将原码和补码按位与得<code>001</code>，用原码减去<code>001</code>，得<code>110=6</code>，即7的父结点是6。<strong>更新</strong>时，我们需要更新所有包含该结点的部分和结点：假如更新了结点1，1的二进制原码为<code>001</code>，-1的补码为<code>111</code>，将原码和补码按位与得<code>001</code>，用原码加上<code>001</code>，得<code>010=2</code>，即还要更新结点2，更新了结点2，还要更新结点4......最后来看下非常简洁的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; prefix_sum_;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BIT</span>(<span class="keyword">int</span> n) : <span class="built_in">prefix_sum_</span>(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; prefix_sum_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            prefix_sum_[i] += delta;</span><br><span class="line">            i += <span class="built_in">lowbit</span>(i);  <span class="comment">// add last set bit</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute nums[0] + nums[1] + ... + nums[i - 1]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += prefix_sum_[i];</span><br><span class="line">            i -= <span class="built_in">lowbit</span>(i);  <span class="comment">// flip the last set bit</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BIT</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n) : <span class="built_in">prefix_sum_</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = i; x &lt; prefix_sum_.<span class="built_in">size</span>(); x += <span class="built_in">lowbit</span>(x))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = j; y &lt; prefix_sum_[<span class="number">0</span>].<span class="built_in">size</span>(); y += <span class="built_in">lowbit</span>(y))</span><br><span class="line">                prefix_sum_[x][y] += delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = i; x &gt; <span class="number">0</span>; x -= <span class="built_in">lowbit</span>(x))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = j; y &gt; <span class="number">0</span>; y -= <span class="built_in">lowbit</span>(y))</span><br><span class="line">                ans += prefix_sum_[x][y];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; prefix_sum_;  <span class="comment">// 一维维护的是一个前缀和数组，二维维护一个前缀和矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) : <span class="built_in">matrix_</span>(matrix), <span class="built_in">tree_</span>(matrix.<span class="built_in">size</span>(), matrix[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                tree_.<span class="built_in">update</span>(i + <span class="number">1</span>, j + <span class="number">1</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        tree_.<span class="built_in">update</span>(row + <span class="number">1</span>, col + <span class="number">1</span>, val - matrix_[row][col]);</span><br><span class="line">        matrix_[row][col] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree_.<span class="built_in">query</span>(row2 + <span class="number">1</span>, col2 + <span class="number">1</span>) + tree_.<span class="built_in">query</span>(row1, col1) - tree_.<span class="built_in">query</span>(row1, col2 + <span class="number">1</span>) - tree_.<span class="built_in">query</span>(row2 + <span class="number">1</span>, col1);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; matrix_;</span><br><span class="line">    BIT tree_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumMatrix numMatrix(matrix);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(0, 1, 2, 3);</span></span><br><span class="line"><span class="comment">// numMatrix.update(1, 1, 10);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(1, 2, 3, 4);</span></span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><a href="https://youtu.be/CWDQJGaN1gY">Fenwick Tree or Binary IndexedTree</a><br /><ahref="https://zxi.mytechroad.com/blog/sp/fenwick-tree-binary-indexed-tree-sp3/">花花酱Fenwick Tree / Binary Indexed Tree SP3</a><br /><a href="youtube.com/watch?v=uSFzHCZ4E-8">Fenwick Tree</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search</title>
      <link href="/posts/binary-search/"/>
      <url>/posts/binary-search/</url>
      
        <content type="html"><![CDATA[<h2 id="基本型">基本型</h2><p>对于一个<strong>有序</strong>数组，查找某个元素，存在返回其index，否则返回-1。<br />二分查找有4个地方容易混淆：</p><ol type="1"><li><code>l</code>和<code>r</code>的初始化，即区间定义。可以是<spanclass="math inline">\([l,r]\)</span>，也可以是<spanclass="math inline">\([l,r)\)</span></li><li><code>while</code>的循环条件：可以是<code>&lt;</code>/<code>&lt;=</code></li><li><code>l</code>和<code>r</code>的更新：可以是<code>mid</code>/<code>mid+1</code>/<code>mid-1</code></li><li>返回值：可以是<code>l</code>/<code>r</code>/<code>mid</code>/其他值</li></ol><p>如果区间初始化为左闭右闭，循环条件就应该是小于等于，因为等于时待检查区间还有1个元素，需要继续；并且r的更新应该是mid-1，因为已经确定mid不是target且右边界是闭的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果区间定义为左闭右开，此时循环条件小于，等于时表示区间为空；当mid&gt;target时r应该为mid，因为mid不是target且右边界开，即下一次不会考虑mid。这种情况如果没找到最终必然有l==r</p><p>我最常用的板子是左闭右开<code>[l, r)</code>，因为这种方式保留了所有的可能性，比如在l位置插入或者在r位置插入，保留了r位置成为答案的可能。</p><p>一些隐晦的问题都隐藏着<strong>单调性</strong>，需要发掘最大值最小化/最小值最大化，或者说当你按顺序尝试每个可能的解并且要在其中找到最小或最大的时候，就考虑二分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[m]) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[m]) l = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微扩展一些的题目有<code>lower_bound()</code>和<code>upper_bound()</code>:<br />对于<code>lower_bound()</code>，即查找满足<spanclass="math inline">\(x\geq target\)</span>的最小index：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[m]) l = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变形为查找最后一个小于<spanclass="math inline">\(target\)</span>的数：即<spanclass="math inline">\(l-1\)</span>。<br />对于<code>upper_bound()</code>，即查找满足<spanclass="math inline">\(x&gt;target\)</span>的最小<spanclass="math inline">\(x\)</span>的index：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[m]) l = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变形为查找最后一个小于等于<spanclass="math inline">\(target\)</span>的数：即<spanclass="math inline">\(l-1\)</span>。</p><p>Leetcode 704/35/34/69/367</p><h2 id="rotated-sorted-array"><ahref="https://leetcode.com/problems/search-in-rotated-sorted-array/">RotatedSorted Array</a></h2><p>Find the index of the target if it is in the array, else return -1.All values of the array are <strong>unique</strong>.</p><p>We can find that at least half of the elements are sorted, so weshould find out whether it's on the left or the right.</p><p>Let's see an example: [0,1,2,3]{all sorted}, [3,0,1,2]{right},[2,3,0,1]{left or right}, [1,2,3,0]{left}.<br />Another example: [0,1,2,3,4]{all sorted}, [4,0,1,2,3]{right},[3,4,0,1,2]{right}, [2,3,4,0,1]{left}, [1,2,3,4,0]{left}. It isimportant to know that the sorted side is <strong>at least half of thearray</strong> (longer). So the mid is in this side.</p><p>We can compare nums[mid] with nums[left] (or nums[right]) to decidewhich side is sorted. If <code>nums[mid]&gt;nums[left]</code>, then lefthalf is sorted, else right is sorted.</p><p>The second step is to compare the target with nums[mid] to narrowdown the range.</p><ul><li>Left half is sorted.<br />If target&gt;nums[mid], it must lie in the right interval. So we canmake left pointer forward left = mid + 1.<br /><img src="https://img-blog.csdnimg.cn/20210303220721888.png"alt="在这里插入图片描述" /><br />If target&lt;nums[mid], there exists 2 situations:<br /><img src="https://img-blog.csdnimg.cn/20210303214903684.png"alt="在这里插入图片描述" /><br />The first graph means target is less than mid but bigger than or equalto left, we move the right pointer toward left right = mid.<br />The second graph means target is less than left, thus we move the leftpointer towards right left = mid + 1.</li></ul><p>Finally if nums[mid]==nums[left], it means that left and mid arepointing to the same element due to the distinct values. In this caseright must be mid or mid + 1. Where is the target? It must be on theright side of mid (actually nums[right]) or it do not exist. So we canmove the left pointer by 1 to see nums[right] is equal to target ornot.</p><ul><li>Right half is sorted. You can analysis this by yourself.</li></ul><p>We can write the following code based on the previous discussion:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[m]:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]: <span class="comment"># left side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &gt; nums[m]:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &gt;= nums[l]:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]: <span class="comment"># right side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &lt; nums[m]:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt;= nums[r]:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="rotated-sorted-array-ii"><ahref="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">RotatedSorted Array II</a></h2><p>It is the same as the last one except that the array may contains<strong>duplicates</strong>. And you do not need to find the index butreturn true or false.</p><p>The code is the same except that you should return T or F.</p><p><ahref="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">FindMinimum in Rotated Sorted Array</a> shares the same idea:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, nums[m])</span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[l])</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[m])</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="rotated-sorted-array-yyds"><ahref="https://leetcode-cn.com/problems/search-rotate-array-lcci/">RotatedSorted Array yyds</a></h2><p>In this case you should return the index of the target in aduplicated array. If you do not know the idea above, this will be alittle harder to solve since there are many corner cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[m]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, m)</span><br><span class="line">                r = m - <span class="number">1</span> <span class="comment"># do not return since there might be smaller index</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]: <span class="comment"># left side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &gt; nums[m]:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &gt;= nums[l]:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]: <span class="comment"># right side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &lt; nums[m]:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; nums[r]:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> target &gt; nums[r]:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> target == nums[l]:</span><br><span class="line">                            ans = <span class="built_in">min</span>(ans, l)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ans == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regular Expression</title>
      <link href="/posts/regular-expression/"/>
      <url>/posts/regular-expression/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p></blockquote><p>先看一个判断Email地址是否合法的例子： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\\w+@\\w+(\\.\\w&#123;2,3&#125;)*\\.\\w&#123;2,3&#125;&quot;</span></span><br></pre></td></tr></table></figure>一般Email地址的格式为：<code>X@X.com</code>，<code>X</code>表示一个或多个字符，<code>.com</code>后面可能还会跟有<code>.cn</code>等。总结这些规律，我们用上述的regex来匹配。<br />当然，这种匹配可能会遗漏某些特殊的Email地址，想要更大范围的覆盖，还需要更为复杂精巧的设计。<br />接着解释下上面的regex：<br /><code>\\w</code>表示匹配字母/数字/下划线/汉字；<br /><code>+</code>表示字符可以出现一次/多次；<br /><code>(\\.\\w&#123;2,3&#125;)*</code>表示类似<code>.edu</code>格式的字符串可以出现零次/多次。<br /><code>\</code>在计算机科学中一般表示转义，形如<code>\w</code>的叫做<strong>元字符</strong>，类似的还有：</p><table><thead><tr><th>元字符</th><th>意义</th></tr></thead><tbody><tr><td>.</td><td>除换行符外任意字符</td></tr><tr><td>数字</td><td></td></tr><tr><td></td><td>字母/数字/汉字/下划线</td></tr><tr><td>单词的开始/结束</td><td></td></tr><tr><td>^</td><td>字符串的开始</td></tr><tr><td>$</td><td>字符串的结束</td></tr></tbody></table><p>还可以通过<code>[]</code>表示元字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;[abc]23&quot;</span></span><br></pre></td></tr></table></figure><p>这样<code>a23</code>，<code>b23</code>，<code>c23</code>都是匹配的字符串。<br />形如<code>+</code>，<code>*</code>叫做<strong>修饰限定符</strong>，用来控制某类串重复多少次：</p><table><thead><tr><th>修饰限定符</th><th>意义</th></tr></thead><tbody><tr><td>*</td><td>0次/多次</td></tr><tr><td>+</td><td>1次/多次</td></tr><tr><td>？</td><td>0次/1次</td></tr><tr><td>{n}</td><td>n次</td></tr><tr><td>{n,}</td><td>n次/更多次</td></tr><tr><td>{n,m}</td><td>n~m次</td></tr></tbody></table><p>很多语言和文本编辑器都集成了正则表达式引擎，以Java为例来测试下上述例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regex = <span class="string">&quot;\\w+@\\w+(\\.\\w&#123;2,3&#125;)*\\.\\w&#123;2,3&#125;&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;hello@stu.edu.cn&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.matches(regex))</span><br><span class="line">            System.out.println(<span class="string">&quot;Valid Address!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述内容只是最最基本的关于正则表达式的知识，还有零宽断言、递归匹配等更加复杂的内容有待挖掘~</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/posts/dynamic-programming/"/>
      <url>/posts/dynamic-programming/</url>
      
        <content type="html"><![CDATA[<p>DP是算法学习中非常重要的一种思想，关于动态规划的解释，可以参考<ahref="https://www.zhihu.com/question/23995189/answer/613096905">这篇文章</a>。</p><h2 id="概念">概念</h2><p>使用DP三个条件：</p><ol type="1"><li>最优子结构：待解决的问题可以被分解为若干子问题，并且递归地找到子问题的最优解，从而得到全局最优解；</li><li>重叠子问题：在解决子问题的过程中，很多子问题都会被求解多次，第一次计算后存储该子问题的解，以后就可以直接使用，即降低了时间复杂度。如果子问题没有重叠，那么这就是<strong>分治</strong>的问题；</li><li>无后效性：子问题的最优解是确定的，完全可以用来解决更大的子问题。</li></ol><p>DP一般有两种形式：</p><ul><li>Top-down/memoization: 记忆化递归可能stackoverflow</li><li>Bottom-up：迭代计算</li></ul><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;  <span class="comment">// memory dict</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(i, j, ...)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">base_case</span><span class="params">(i, j)</span></span></span><br><span class="line"><span class="function"><span class="keyword">return</span> ...</span>;</span><br><span class="line">    <span class="keyword">if</span> (i, j) <span class="keyword">not</span> in hash</span><br><span class="line">        hash[(i, j)] = <span class="built_in">f</span>(...);</span><br><span class="line">    <span class="keyword">return</span> hash[(i, j)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">f</span>(n, m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DP</span></span><br><span class="line"><span class="keyword">int</span> dp[][];   <span class="comment">// need padding sometimes</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = ...;   <span class="comment">// base case</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j =  <span class="number">0</span>;j &lt; m;++j)</span><br><span class="line">        dp[i][j] = ...  <span class="comment">// 状态转移</span></span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br></pre></td></tr></table></figure><h2 id="分类">分类</h2><ul><li>基础题：LeetCode 509/70/746/62/63/343/96/<ahref="https://www.cnblogs.com/EIMadrigal/p/11478906.html">Fibonacci</a></li><li>背包问题：<ul><li><a href="https://www.cnblogs.com/EIMadrigal/p/12345051.html">0/1Knapsack</a>：LeetCode 416/1049/494/474</li><li><ahref="https://www.cnblogs.com/EIMadrigal/p/12345051.html">UnboundedKnapsack</a>：LeetCode 518/377/70/322/279/139</li></ul></li><li>House Thief：LeetCode 198/213/337</li><li>股票问题：LeetCode 121/122/123/188/309/714</li><li>Longest Common Substring/Subsequeunce：LeetCode300/1143/1035/674/718/53/392/115/583/72/647/516</li></ul><h2 id="步骤">步骤</h2><p>一般来讲，都是通过暴力-&gt;记忆化递归-&gt;Bottom-up三部曲，当然熟悉后可以快速判断这是一个DP问题，然后直接写出Bottom-up的解法。<br />我个人认为最难的一步在于判断出你的暴力解法满足DP的性质（你要能认出来这是一个DP问题），可以用DP去优化暴力解法。</p><ul><li>确定问题分类</li><li>确定状态：需要几个变量来跟踪目前的状态，一般来讲至少需要index，因为这决定了我们已经考虑过了哪些值，没考虑哪些值，正在考虑哪些值。选定的变量组合要能唯一确定一个状态</li><li>状态转移：为了达到basecase，当前状态怎么才能由之前的状态得到。也就是Top-down逐渐分解问题，每一次递归调用都会分解一下</li><li>base case：一般比较简单，不废话了</li><li>code：思路清楚了，也不难</li><li>优化：一般优化空间复杂度</li></ul><h2 id="ref">Ref</h2><p><ahref="https://leetcode.com/problems/target-sum/discuss/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions.">DPIS EASY! 5 Steps to Think Through DP Questions.</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是P问题、NP问题和NPC问题</title>
      <link href="/posts/p-np-npc/"/>
      <url>/posts/p-np-npc/</url>
      
        <content type="html"><![CDATA[<p>很久之前观看WJMZBMR特奖答辩时听到了<spanclass="math inline">\(P!=NP\)</span>，一直似懂非懂，看了Matrix67的<ahref="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a>，<del>特意作文纪念</del>。</p><p>一张图就可以解释三者间的关系：<imgsrc="https://img-blog.csdnimg.cn/20190728150856295.png"alt="在这里插入图片描述" /></p><h2 id="什么是p问题np问题和npc问题">什么是P问题、NP问题和NPC问题</h2><p>这或许是众多OIer最大的误区之一。<br />你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是NPC问题是一个多大的错误。</p><p>还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有<spanclass="math inline">\(O(1)\)</span>的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是<spanclass="math inline">\(O(n)\)</span>，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于<spanclass="math inline">\(O(n^2)\)</span>的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是<spanclass="math inline">\(O(a^n)\)</span>的指数级复杂度，甚至<spanclass="math inline">\(O(n!)\)</span>的阶乘级复杂度。不会存在<spanclass="math inline">\(O(2*n^2)\)</span>的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，<spanclass="math inline">\(O (n^3+n^2)\)</span>的复杂度也就是<spanclass="math inline">\(O(n^3)\)</span>的复杂度。因此，我们会说，一个<spanclass="math inline">\(O(0.01*n^3)\)</span>的程序的效率比<spanclass="math inline">\(O(100*n^2)\)</span>的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终<spanclass="math inline">\(O(n^3)\)</span>的复杂度将远远超过<spanclass="math inline">\(O(n^2)\)</span>。我们也说，<spanclass="math inline">\(O(n^{100})\)</span>的复杂度小于<spanclass="math inline">\(O(1.01^n)\)</span>的复杂度。</p><p>容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是<spanclass="math inline">\(O(1),O(log(n)),O(n^a)\)</span>等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是<spanclass="math inline">\(O(a^n)\)</span>和<spanclass="math inline">\(O(n!)\)</span>型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p><p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(UndecidableDecision Problem)。The HaltingProblem就是一个著名的不可解问题，在我的Blog上有过专门的介绍和证明。再比如，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p><p>下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。哪些问题是P类问题呢？通常NOI和NOIP不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。</p><p>接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。</p><p>之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。</p><p>很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。</p><p>NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。</p><p>目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p><p>为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。</p><p>简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(TravellingSalesmanProblem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。</p><p>“问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。</p><p>很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。</p><p>现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。</p><p>当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-timeReducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p><p>好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p><p>NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</p><p>既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p><p>顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p><p>不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。下文即将介绍它。</p><p>下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。</p><p>逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。<br />什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。<br /><img src="https://img-blog.csdnimg.cn/20190728155740104.png"alt="在这里插入图片描述" /><br />这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。</p><p>有输出无论如何都不可能为True的逻辑电路吗？有。下面就是一个简单的例子。<br /><img src="https://img-blog.csdnimg.cn/20190728155803196.png"alt="在这里插入图片描述" /><br />上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。</p><p>回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。</p><p>逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。</p><p>有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pointers and Memory</title>
      <link href="/posts/pointers-and-memory/"/>
      <url>/posts/pointers-and-memory/</url>
      
        <content type="html"><![CDATA[<p><em>Stanford CS Education Library #102</em> ## Basic Pointers指针主要有两个用途：使不同的代码段共享信息、方便链表（树）的处理。<br />指针示意图：<br /><img src="https://img-blog.csdnimg.cn/2019041619200938.png"alt="在这里插入图片描述" /><br /><code>dereference</code>操作会根据指针的值去找到它的<code>pointee</code>。<br /><code>NULL</code>是一个特殊的指针值（一般是地址0），表示这个指针不指向任何<code>pointee</code>。<br /><img src="https://img-blog.csdnimg.cn/20190416193109659.png"alt="在这里插入图片描述" /><br />指针的赋值会使得两个指针指向相同的<code>pointee</code>，但<code>pointee</code>本身不会改变：<br /><img src="https://img-blog.csdnimg.cn/20190416192708547.png"alt="在这里插入图片描述" /><br />传指针vs传值：<br /><img src="https://img-blog.csdnimg.cn/20190416193445969.png"alt="在这里插入图片描述" /><br />定义一个指针后，这个指针是没有被初始化的：<br /><img src="https://img-blog.csdnimg.cn/2019041619372662.png"alt="在这里插入图片描述" /><br />这时候如果进行<code>dereference</code>操作会发生Runtime Error.<br />对于Java、LISP等语言，当定义一个指针时，系统会将其设置为<code>NULL</code>，并且会在<code>dereference</code>操作时检查其值，这也是Java比较慢的原因之一。<br /><img src="https://img-blog.csdnimg.cn/20190416194404553.png"alt="在这里插入图片描述" /><br />一个比较典型的指针错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BadPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p;  <span class="comment">//allocate the pointer, but not the pointee</span></span><br><span class="line">    *p = <span class="number">42</span>; <span class="comment">//serious RE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>*p</code>时：<br /><img src="https://img-blog.csdnimg.cn/20190416195104100.png"alt="在这里插入图片描述" /></p><h2 id="local-memory">Local Memory</h2><p>函数开始运行时，会为局部变量分配内存，结束运行会回收内存。<br />看一个错误的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TAB -- The Ampersand Bug function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">TAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">return</span> (&amp;temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Victim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ptr;</span><br><span class="line">    ptr = TAB();</span><br><span class="line">    *ptr = <span class="number">42</span>;    <span class="comment">//The pointee was local to TAB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于<code>TAB()</code>返回了一个局部变量的地址，但这个局部变量的空间已经被回收，<code>ptr</code>指针没有<code>pointee</code>。</p><h2 id="reference-parameters">Reference Parameters</h2><p>传值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> worth)</span> </span>&#123;</span><br><span class="line">    worth++;</span><br><span class="line">    <span class="comment">// T2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> netWorth = <span class="number">55</span>;  <span class="comment">//T1</span></span><br><span class="line">    B(netWorth);</span><br><span class="line">    <span class="comment">// T3 -- B() did not change netWorth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190416203356234.png"alt="在这里插入图片描述" /><br />传指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>* worthRef)</span> </span>&#123;</span><br><span class="line">    (*worthRef)++;</span><br><span class="line">    <span class="comment">// T2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> netWorth = <span class="number">55</span>;  <span class="comment">//T1</span></span><br><span class="line">    B(&amp;netWorth);</span><br><span class="line">    <span class="comment">// T3</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190416203939385.png"alt="在这里插入图片描述" /><br />传指针在c++中可以通过<strong>传引用</strong>的方式实现：<br /><img src="https://img-blog.csdnimg.cn/20190416205349526.png"alt="在这里插入图片描述" /></p><h2 id="heap-memory">Heap Memory</h2><p>分配示意图：<br /><img src="https://img-blog.csdnimg.cn/20190416205821650.png"alt="在这里插入图片描述" /><br />释放示意图：<br /><img src="https://img-blog.csdnimg.cn/20190416210059909.png"alt="在这里插入图片描述" /><br />释放后，指针虽然还在，但却不可以在使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size以字节为单位，分配成功返回指针，失败返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要size，因为heap manager之前已经记录过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* heapBlockPointer)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190416211219354.png"alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20190416211242340.png"alt="在这里插入图片描述" /><br />一个<code>StringCopy()</code>的例子：<br /><img src="https://img-blog.csdnimg.cn/20190416211900707.png"alt="在这里插入图片描述" /><br />对于分配的堆内存，只有一个负责释放的，要么是<code>caller</code>，要么是<code>callee</code>：<br /><img src="https://img-blog.csdnimg.cn/20190416212610387.png"alt="在这里插入图片描述" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List-2</title>
      <link href="/posts/linked-list-2/"/>
      <url>/posts/linked-list-2/</url>
      
        <content type="html"><![CDATA[<h2 id="三编码技巧">三、编码技巧</h2><p><strong>1、遍历链表</strong><br />先将<code>head</code>指针赋值给一个局部变量<code>current</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//return the number of nodes in a list (while-loop version)</span><br><span class="line">int Length(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    struct node* current = head;</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (current = head; current != NULL; current = current-&gt;next) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>2、通过传递<code>reference pointer</code>改变某个指针</strong><br />看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Change the passed in head pointer to be NULL</span><br><span class="line">//Uses a reference pointer to access the caller&#x27;s memory</span><br><span class="line">void ChangeToNull(struct node** headRef)  //takes a pointer to the value of interest</span><br><span class="line">&#123;</span><br><span class="line">    *headRef = NULL;//use * to access the value of interest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ChangeCaller()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head1;</span><br><span class="line">    struct node* head2;</span><br><span class="line"></span><br><span class="line">    ChangeToNull(&amp;head1);//use &amp; to compute and pass a pointer to</span><br><span class="line">    ChangeToNull(&amp;head2);//the value of interest</span><br><span class="line">    //head1 and head2 are NULL at this point</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块的思想是和（一）中的<code>Push()</code>类似。<br />内存示意图：<br /><imgsrc="https://img-blog.csdnimg.cn/20190330151133187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br /><strong>3、通过<code>Push()</code>建立链表（头插法）</strong>这种方式的优点是速度飞快，简单易行，缺点是得到的链表是逆序的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct node* AddAtHead()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;head, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //head == &#123;5,4,3,2,1&#125;;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、尾插法建立链表</strong>这种方法需要找到链表最后一个节点，改变其<code>.next</code>域：<br /><imgsrc="https://img-blog.csdnimg.cn/20190330155111506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /></p><ul><li>插入或者删除节点，需要找到该节点的前一个节点的指针，改变其<code>.next</code>域；</li><li>特例：<strong>如果涉及第一个节点的操作，那么一定要改变<code>head</code>指针。</strong></li></ul><p><strong>5、特例+尾插法</strong>如果要构建一个新的链表，那么头节点就要单独处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithSpecialCase()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line">    struct node* tail;</span><br><span class="line">    </span><br><span class="line">    //deal with the head node here, and set the tail pointer</span><br><span class="line">    Push(&amp;head, 1);</span><br><span class="line">    tail = head;</span><br><span class="line"></span><br><span class="line">    //do all the other nodes using &quot;tail&quot;</span><br><span class="line">    for (int i = 2; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;(tail-&gt;next), i);   //add node at tail-&gt;next</span><br><span class="line">        tail = tail-&gt;next;     //advance tail to point to last node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head;    //head == &#123;1,2,3,4,5&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、临时节点建立</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithDummyNode()</span><br><span class="line">&#123;</span><br><span class="line">    struct node dummy;   //dummy node is temporarily the first node</span><br><span class="line">    struct node* tail = &amp;dummy;   //build the list on dummy.next</span><br><span class="line"></span><br><span class="line">    dummy.next = NULL;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;(tail-&gt;next), i);</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //the real result list is now in dummy.next</span><br><span class="line">    //dummy.next == &#123;1,2,3,4,5&#125;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、本地指针建立</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithLocalRef()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line">    struct node** lastPtrRef = &amp;head;   //start out pointing to the head pointer</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(lastPtrRef, i);  //add node at the last pointer in the list</span><br><span class="line">        //advance to point to the new last pointer</span><br><span class="line">        lastPtrRef = &amp;((*lastPtrRef)-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head;  //head == &#123;1,2,3,4,5&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块可能有些抽象：<br />1）<code>lastPtrRef</code>开始指向<code>head</code>指针，以后指向链表最后一个节点中的<code>.next</code>域；<br />2）在最后加上一个节点；<br />3）让<code>lastPtrRef</code>指针向后移动，指向最后一个<strong>节点的<code>.next</code>域</strong>。<code>(*lastPtrRef)-&gt;next</code>可以理解为<code>*lastPtrRef</code>指针指向的节点的<code>next</code>域。<br /><imgsrc="https://img-blog.csdnimg.cn/20190403193507385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /></p><h2 id="四代码示例">四、代码示例</h2><p><strong>1、AppendNode()</strong> 1)不使用<code>Push()</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct node* AppendNode(struct node** headRef, int num)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = *headRef;</span><br><span class="line">    struct node* newNode;</span><br><span class="line"></span><br><span class="line">    newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">    newNode-&gt;data = num;</span><br><span class="line">    newNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //special case for length 0</span><br><span class="line">    if (current == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        *headRef = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //Locate the last node</span><br><span class="line">        while (current-&gt;next != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>使用<code>Push()</code>函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct node* AppendNode(struct node** headRef, int num)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = *headRef;</span><br><span class="line"></span><br><span class="line">    //special case for length 0</span><br><span class="line">    if (current == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(headRef, num);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //Locate the last node</span><br><span class="line">        while (current-&gt;next != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Build the node after the last node</span><br><span class="line">        Push(&amp;(current-&gt;next), num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、CopyList</strong><br />用一个指针遍历原来的链表，两个指针跟踪新生成的链表（一个<code>head</code>，一个<code>tail</code>）。</p><ol type="1"><li>不使用<code>Push()</code>函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* newList = NULL;   //head of the new list</span><br><span class="line">    struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (newList == NULL)    //special case for the first new node</span><br><span class="line">        &#123;</span><br><span class="line">            newList = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">            newList-&gt;data = current-&gt;data;</span><br><span class="line">            newList-&gt;next = NULL;</span><br><span class="line">            tail = newList;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            tail-&gt;data = current-&gt;data;</span><br><span class="line">            tail-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 内存示意图：<br /><imgsrc="https://img-blog.csdnimg.cn/20190407094454488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /></li><li>使用<code>Push()</code>函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList2(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* newList = NULL;   //head of the new list</span><br><span class="line">    struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (newList == NULL)    //special case for the first new node</span><br><span class="line">        &#123;</span><br><span class="line">            Push(&amp;newList, current-&gt;data);</span><br><span class="line">            tail = newList;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Push(&amp;(tail-&gt;next), current-&gt;data);   //add each node at the tail </span><br><span class="line">            tail = tail-&gt;next;       //advance the tail to the new last node;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>使用<code>Dummy Node</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList3(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line">    struct node dummy;            //build the new list off this dummy node</span><br><span class="line"></span><br><span class="line">    dummy.next = NULL;</span><br><span class="line">    tail = &amp;dummy;      //start the tail pointing at the dummy</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;(tail-&gt;next), current-&gt;data);   //add each node at the tail</span><br><span class="line">        tail = tail-&gt;next;                    //advance the tail to the new last node</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>使用<code>Local References</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList4(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* newList = NULL;   //head of the new list</span><br><span class="line">    struct node** lastPtr;           </span><br><span class="line"></span><br><span class="line">    lastPtr = &amp;newList;      //start off pointing to the head itself</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(lastPtr, current-&gt;data);   //add each node at the lastPtr</span><br><span class="line">        lastPtr = &amp;((*lastPtr)-&gt;next);    //advance lastPtr</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想是使用<code>lastPtr</code>指针指向每个节点的<code>.next</code>域这个指针，而不是指向节点本身。</p><ol start="5" type="1"><li>使用<code>Recursive</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList5(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;</span><br><span class="line">    if (head == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        struct node* newList = (struct node*)malloc(sizeof(struct node));  //make one node</span><br><span class="line">        newList-&gt;data = current-&gt;data;</span><br><span class="line"></span><br><span class="line">        newList-&gt;next = CopyList5(current-&gt;next);    //recur for the rest</span><br><span class="line">        return newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List-1</title>
      <link href="/posts/linked-list-1/"/>
      <url>/posts/linked-list-1/</url>
      
        <content type="html"><![CDATA[<p>链表一直是面试的重点问题，恰好最近看到了Stanford的一篇<ahref="http://cslibrary.stanford.edu/">材料</a>，涵盖了链表的基础知识以及派生的各种问题。<br />第一篇主要是关于链表的基础知识。</p><h2 id="基本结构">基本结构</h2><p><strong>1、数组回顾</strong><br />链表和数组都是用来存储一堆数据的集合，其中单个元素的类型可以有很多种。<br />通过数组下标可以直接访问数组中的元素，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ArrayTest()</span><br><span class="line">&#123;</span><br><span class="line">    int scores[100];</span><br><span class="line"></span><br><span class="line">    //初始化前3个元素</span><br><span class="line">    scores[0] = 1;</span><br><span class="line">    scores[1] = 2;</span><br><span class="line">    scores[2] = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的是：整个数组被分配了一整块内存：<br /><img src="https://img-blog.csdnimg.cn/2019032615150057.png" /><br />数组元素之所以能被快速访问，原因在于其地址的计算是通过首地址加上偏移值得到的，只有一次乘法和一次加法运算而已。<br />数组的缺点在于：</p><ul><li>数组的大小是固定的：数组的规模在编译时就被确定，当然你可以在运行时通过<code>malloc</code>在堆中改变数组的大小，不过很麻烦；</li><li>由于上述原因，所以很多人就会定义一个很大的数组，不过这又会导致两个问题：<br />1）数组的大部分空间可能被浪费掉；<br />2）如果程序需要更大的空间，就会崩溃。</li><li>在数组前面插入元素代价很大，需要移动很多元素。<br />链表也有自己的优缺点，只不过和数组刚好互补：链表会在需要时为每个节点单独分配内存。<br /><strong>2、指针回顾</strong><br />指针存储了变量的地址，如果指针的值是<code>NULL</code>（c/c++中<code>NULL</code>可以表示逻辑<code>false</code>），那么该指针不指向任何变量。<br />在c/c++中，没有初始化的指针就是野指针，对野指针进行<code>dereference</code>操作可能导致程序崩溃。<br />两个指针的赋值结果就是都指向相同的内存区域。<br /><code>malloc()</code>函数用来在堆中申请一块内存，并且返回一个指向该块的指针，如果申请失败，会返回<code>NULL</code>，使用后，需要用<code>free()</code>去释放。这些堆函数原型都在<code>stdlib.h</code>头文件中声明。<br /><strong>3、链表</strong><br />一个包含<code>&#123;1,2,3&#125;</code>三个元素的链表：<br /><img src="https://img-blog.csdnimg.cn/20190326161911717.png"alt="在这里插入图片描述" /><br />空链表的<code>head</code>的值是<code>NULL</code>，<strong>编程时要考虑到这种边界情况</strong>。</li></ul><p>节点的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指向节点的指针类型是<code>struct node*</code>。<br />接着看看上图中的链表是怎么建立的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Build the list &#123;1,2,3&#125; in the heap and store</span><br><span class="line">its head pointer in a local stack variable.</span><br><span class="line">Returns the head pointer to the caller.</span><br><span class="line">*/</span><br><span class="line">struct node* BuildOneTwoThree()</span><br><span class="line">&#123;</span><br><span class="line">    //there are three pointers in the stack, but pointer assignment link the list.</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line">    struct node* second = NULL;</span><br><span class="line">    struct node* third = NULL;</span><br><span class="line"></span><br><span class="line">    //allocate 3 nodes</span><br><span class="line">    head = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">    second = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">    third = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    head-&gt;data = 1;    //setup first node</span><br><span class="line">    head-&gt;next = second;   //note:pointer assignment rule</span><br><span class="line"></span><br><span class="line">    second-&gt;data = 2;    //setup second node</span><br><span class="line">    second-&gt;next = third;</span><br><span class="line"></span><br><span class="line">    third-&gt;data = 3;    //setup third node</span><br><span class="line">    third-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //at this point, the linked list referenced by &quot;head&quot;</span><br><span class="line">    //matches the list in the drawing.</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何求链表中的元素个数呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Given a linked list head pointer, compute </span><br><span class="line">and return the number of nodes in the list.</span><br><span class="line">*/</span><br><span class="line">int Length(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，传递进函数的只是头指针，这样调用者和被调用者都有了头指针，但是却共享了整个链表。</p><ul><li><code>current</code>指针占据的空间会被自动释放，但是堆中的链表仍然保留；</li><li><code>while</code>循环已经考虑了空链表的情况；</li><li><code>current</code>最后的值会是<code>NULL</code>。<br />调用<code>Length()</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void LengthTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* myList = BuildOneTwoThree();</span><br><span class="line">    int len = Length(myList);    //results in len == 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用<code>Length()</code>之前：<br /><img src="https://img-blog.csdnimg.cn/20190326172043909.png"alt="在这里插入图片描述" /></li><li>执行<code>Length()</code>过程中：<br /><img src="https://img-blog.csdnimg.cn/20190326172354519.png"alt="在这里插入图片描述" /></li></ul><h2 id="链表建立">链表建立</h2><p>用<code>BuildOneTwoThree()</code>函数来建立链表未免有些古板，下面用头插法建立链表：</p><p>1、分配节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct node* newNode;</span><br><span class="line">newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">newNode-&gt;data = data_client_wants_stored;</span><br></pre></td></tr></table></figure><p>2、让新节点的<code>next</code>指向当前链表的第一个节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newNode-&gt;next = head;</span><br></pre></td></tr></table></figure><p>3、让<code>head</code>指针指向链表的第一个节点： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = newNode;</span><br></pre></td></tr></table></figure>整理下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void LinkTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();  //suppose this builds list &#123;2,3&#125;</span><br><span class="line">    struct node* newNode;</span><br><span class="line"></span><br><span class="line">    newNode = (struct node*)malloc(sizeof(struct node));  //allocate</span><br><span class="line">    newNode-&gt;data = 1;</span><br><span class="line">    </span><br><span class="line">    newNode-&gt;next = head;   //link next</span><br><span class="line"></span><br><span class="line">    head = newNode;   //link head</span><br><span class="line"></span><br><span class="line">    //now head points to the list &#123;1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图： <img src="https://img-blog.csdnimg.cn/20190326205401503.png"alt="在这里插入图片描述" /><br /><em>先看一个错误的示范：</em> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void WrongPush(struct node* head,int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    head = newNode;    //NO this line does not work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WrongPushTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();  </span><br><span class="line">    </span><br><span class="line">    WrongPush(head, 1);    //try to push 1 on front -- doesn&#x27;t work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这个问题就在于C语言的<strong>值传递</strong>，在<code>WrongPush()</code>中对<code>head</code>指针的改变不会影响到<code>WrongPushTest</code>中的我们需要的<code>head</code>指针。<br />这个问题传统的解决方案是传递当前值的指针给函数而不是传递一份当前值的拷贝，即：<br />要改变调用者中<code>int</code>的值，就传一个<code>int*</code>给被调用者。在这个例子中，要改变<code>struct node*</code>，就要传递<code>struct node**</code>。也即：<code>head</code>的类型是<code>pointer to a struct node</code>，想要改变这个指针，就需要传一个指向该指针的指针<code>pointer to a pointer to a struct node</code>。<br /><strong>规则就是：<code>to modify caller memory, pass a pointer to that memory.</code></strong></p><p><em>所以正确的代码如下：</em> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Takes a list and a data value.</span><br><span class="line">Creates a new link with the given data and pushes it</span><br><span class="line">onto the front of the list.</span><br><span class="line">The list is not passed in by its head pointer.</span><br><span class="line">Instead the list is passed in as a &quot;reference&quot; pointer</span><br><span class="line">to the head pointer -- this allows us to modify the caller&#x27;s memory.</span><br><span class="line">*/</span><br><span class="line">void Push(struct node** headRef,int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = *headRef;//the * to dereferences back to the real head </span><br><span class="line">    *headRef = newNode;    //ditto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PushTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();//suppose this returns the list &#123;2,3&#125;</span><br><span class="line">    </span><br><span class="line">    Push(&amp;head, 1);    //note the &amp;</span><br><span class="line">    Push(&amp;head, 13);</span><br><span class="line"></span><br><span class="line">    //head is now the list &#123;13,1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 内存示意图：<br /><img src="https://img-blog.csdnimg.cn/20190330143627528.png"alt="在这里插入图片描述" /><br />如果是C++，那么可以用<strong>引用</strong>完成上述工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Push in C++ -- We just add a &amp; to the right hand side of the head parameter type,</span><br><span class="line">and the compiler makes that parameter work by reference. So this code changes the </span><br><span class="line">caller&#x27;s memory, but no extra uses of * are necessary -- we just access &quot;head&quot; directly,</span><br><span class="line">and the compiler makes that change reference back to the caller.</span><br><span class="line">*/</span><br><span class="line">void Push(struct node*&amp; head,int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = head;//No extra use of * necessary on head -- the compiler</span><br><span class="line">    head = newNode;    //just takes care of it behind the scenes.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PushTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();//suppose this returns the list &#123;2,3&#125;</span><br><span class="line">    </span><br><span class="line">    Push(head, 1);    //No extra use &amp; necessary -- the compiler </span><br><span class="line">    Push(head, 13);   //takes care of it here too. Head is being changed by these calls. </span><br><span class="line"></span><br><span class="line">    //head is now the list &#123;13,1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据处理</title>
      <link href="/posts/big-data-process/"/>
      <url>/posts/big-data-process/</url>
      
        <content type="html"><![CDATA[<h2 id="ip白名单系统">IP白名单系统</h2><p>设计一个10亿级别的IP白名单系统，支持增删改查。</p><p>如果用string存储每个IP，那么大约需要15GB的内存；如果直接将每一位看作十进制的数，用int存储，但是单个int无法存储255.255.255.255这么大的数；</p><p>如果将每个小段都用二进制表示，那么所有的IP地址都可以用32位的unsignedint表示。</p><p>所以采用<spanclass="math inline">\(2^{32}-1\)</span>大小的bit数组来映射所有的IP地址，大约需要内存512MB。</p><p>首先看增加操作，将IP地址转为unsignedint后，将bit数组中对应位置1即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> byte = ip / <span class="number">8</span>, bit = ip % <span class="number">8</span>;</span><br><span class="line">    arr[byte] = arr[byte] | <span class="number">1</span> &lt;&lt; (<span class="number">7</span> - bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看查找操作，只需判断该IP地址对应位置是否为1即可： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> byte = ip / <span class="number">8</span>, bit = ip % <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> arr[byte] &amp; <span class="number">1</span> &lt;&lt; (<span class="number">7</span> - bit) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后续还有IP地址转unsigned int以及非法判断，并发处理等问题。</p><h2 id="找众数">找众数</h2><p>一个文件包含40亿个32位的无符号整数，使用内存限制1GB找到众数。</p><p>32位无符号数范围是<span class="math inline">\(0\sim2^{32}-1(4,294,967,295)\)</span></p><p>傻白甜做法就是用一个Hashmap统计每个数的频率，key是4B，value是4B，一条记录8B，最差情况下40亿个数都不同，共需40亿*8B大约32GB。</p><p>哈希分割+多线程</p><p>https://www.bilibili.com/video/BV13g41157hK?p=11 29min</p><p>10亿IP地址bitmap?原理？把IP转为unsigned int，用bitset0</p><h2 id="spark">Spark</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老实人的摸索与反思---写在高考七年后</title>
      <link href="/posts/past-seven-years/"/>
      <url>/posts/past-seven-years/</url>
      
        <content type="html"><![CDATA[<p><em>说明：本文是徐国曦老师写于2018年6月，我第一次看到此文是在2019年4月中旬。鉴于我当时状态很糟糕，此文给了我极大的震撼与启发，每每读来都有不同的感受，遂摘录于此。附：<ahref="https://zhuanlan.zhihu.com/p/37859452">原文链接</a></em></p><hr /><p>说明：上篇《老实人的归国与失身》获得了超过预想的关注，文中虽声明“本故事纯属虚构”，但实际上真实情况与艺术加工大约各占一半。上篇文章想要表达的主题可能并不十分清楚，不同人看到的东西会有极大不同。因此在今天这篇文章中我将详细讲一下这些年来发生的事情以及自己的一些思考，本文句句事实，不说一句大话、假话、空话，不贩卖焦虑，不灌任何鸡汤和毒鸡汤。我也不讳言自己身上出现的问题，曾经的生活充满不堪，有些遮蔽在眼前的玻璃滤镜总要有需要被打破的一天。</p><p>时至今日，我也是时候与过去的自己告别，开始新的第二人生了。我也希望将自己的经历写出来，给境遇相似的人提供一些可能的思考或警示。几年折腾下来，不敢说积累了多少人生经验，但是讲教训我这里是有很多的，这篇文章的目的也在于用亲身经历指出我自己及处境相似的年轻人思维和行动上的误区。其中的一些个人想法可能不完善或者不成熟，也欢迎批评指教。</p><hr />认真投决定命运的硬币，却不知道最后要去哪里。<p align="right">——题记</p><h2 id="section">0</h2><p>在文章开始之前，先放几篇在某段时间内引发广泛讨论的微信文，读者们或多或少可能看过其中一些：</p><ol start="0" type="1"><li><ahref="https://www.zhihu.com/question/277691008">《老实人的归国与失身》</a>作者是我自己</li><li><ahref="https://www.zhihu.com/question/50766928">《T大本科舍友阶级分化实录，该何去何从？》</a></li><li><ahref="https://www.zhihu.com/question/44186681">《凭什么我辛苦二十年，现在却比别人差那么多？》</a></li><li><a href="https://www.zhihu.com/question/52031149">《我上了985211才发现自己一无所有》</a></li><li><ahref="https://www.zhihu.com/question/65098412">《一个月就辞职，一个北大女生的求职悲欢》</a></li></ol><p>这些文章可能可以或多或少的反映当前包括我在内部分名校学生所面临的现实问题与认知偏差。也因此，因为视角有限，必然不代表整个年轻人群体的普遍现象，更不能说契合多数人的价值观，请带着批判的眼光看到上面提到的所有文章，也包括我这篇。</p><h2 id="section-1">1</h2><p>好了废话不多说，开始讲故事，十年经历，尽在此篇。如果觉得故事过长，请直接看最后的结论。</p><p>美西时间2018年6月6日下午，我上完了学生时代的最后一节课程，只待最后的考试、毕业、回国、入职。打开朋友圈，看到大家都在怀念当年的高考，作为一个上了大学后就基本没再怎么提起高考这茬事的人，突然觉得这个事情好遥远。不过从尘埃落定以来我也一直想找个机会分享一下我个人几年来遇到的事情，就索性在高考七年之后学生时代临近结束的时候，进行一次彻底的总结，向过去的自己说再见，轻装迎接未知的未来。这篇的主题其实和高考本身没有多大关系，不过还是像上篇一样，从高中时代讲起。</p><p>如同《老实人的归国与失身》当中讲到的那样，我十年之前升入一个高考大省省会的重点高中，虽然管理并非变态到监狱式的程度，但是由于升学压力的缘故，大部分学生的日子还是过得相对波澜不惊。在一个在郊区住校，一两周回一趟家，手机都不一定人手一部，诺基亚N95就能称霸，上QQ空间可能是最好的娱乐活动的时代，我们的日常生活也不像十年之后的今天有着各种各样的诱惑。如同我现在看到快手抖音和知乎上的00后们接受着我们从没想过的信息，做着我们想追求却曾经不敢去做的事情，18岁的他们姿势水平可能完爆25岁的自己，就觉得时代的发展如同车轮一般，而90后已经成了被冲在沙滩上的前浪。</p><p>而在那样的环境下，可想而知，学生当中最受欢迎的群体并不是只知道好好学习的书呆子（虽然我自己可能并不是），而永远都是绯闻缠身的帅哥靓女们，家里有一些背景考到一本线就能上本地985的关系户，手机一周一换的富二代，carry大家打游戏的大咖，带着些许叛逆的所谓不良少年，甚至高中时代成熟的早偷尝禁果还顺便能给朋友们性启蒙的人。虽然当我之后见到更大的世界之后发现这都不算什么，但放在当时，这些现象还是对很多十五六岁经历一片空白的少男少女有着一定杀伤力的。</p><p>在这些人面前，我竟有些自卑，说不清楚自己除了成绩稍微好一些之外还有什么优点，更何况成绩根本没好到可以完爆他们的程度。而我个人的课余生活就更是单调，<strong>上晚自习看《萌芽》追连载小说得到的快乐，可能并不亚于几年之后在国际期刊发表一作文章的快乐</strong>。人在成长过程中都是这样，小时候得到个玩具就能高兴好几天，可是长大之后很有可能金钱和权力等这些世俗成功标准的降临都带不来一样的感动了。人的阈值总是随时间而增长的，这是好事还是坏事呢？</p><p>我在这所高中成绩比较稳定位于年级中上，课余和寒暑假的时间都用来搞竞赛，虽然略吃力但也有所收获。正常情况下单凭高考考到中等985学校没问题，如果竞赛保送可以去前十学校。我自己高中时候的目标是上清华北大，但由于从当时的情况看来过于不切实际，因此也很少跟别人提起。到了高三，竞赛获了省一拿到了保送资格，报了清华和另外一所华五学校，清华没考过线，另外一所学校过了录取线却把我调剂到了法医专业。由于实在是不想读这个专业，不得不放弃保送资格强行拼高考。高三一年各次模拟考试我的成绩稳定在六百三四十（虽然事后看来，模拟题和高考真题完全不是一个路数），即便加上竞赛加分，离梦想的学校也相距太远。以至于到了高三的五月，我竟觉得“就这样吧，考到哪算哪”。</p><p>于是高考前最后的一个月我连作业都懒得做了，每天用几乎全部的时间研究历年高考真题，琢磨里面的规律。2011年高考的三天也波澜不惊的过去了，甚至高考之后答案都懒得去对，抱着出了分之后随便报个志愿的弃疗态度就去睡了十五天大觉。结果出乎意料的是超常发挥了近三十分，莫名其妙的考到了全市前五全省前五十，竟然可以真的报清北了。</p><p>鉴于当时的确不知道自己喜欢什么和适合什么专业，当天急急忙忙的就和清华签了约，而专业也是招生老师推荐给我的，我想都没想就接受了，身边的长辈也全都给我说：</p><p><strong>“你都上了清华了，学什么专业不重要”。</strong></p><p>那个时候自己对未来的想法只有：<strong>“我想做一个科学家”</strong></p><p>（然而可能连什么是科学家都不甚清楚），看到是个理工科专业，就糊里糊涂接受了。这就是一个典型的战术上勤奋战略上懒惰的例子。</p><p>我本人并非小县城出身，与“学霸”这个词更是八竿子打不着。但是，可能时至今日我自己身上仍然还有一些小县城学霸思维方式的残余。尤其在高考大省，我们很多人在18岁之前除了学习什么都不懂，而工人阶级或者知识分子的父母从小告诉我们的就是“<strong>读书改变命运</strong>”甚至是“<strong>考个好大学什么都不用愁了</strong>”。</p><p>固然在他们那个时代可能是这样，但是如今，这样的“<strong>努力就能得到回报</strong>”、“<strong>一分耕耘一分收获</strong>”的单线程的、线性的思维方式在更大程度上是对生活的一种不完全归纳甚至是片面归纳。从小地方考入最高学府，必须承认眼界和见识必然比不过一部分同龄人：2017年夏天我在斯坦福带过一个国内初中生组成的所谓“游学团”，平均年龄十三四岁，平均去过十几二十个国家，有的甚至是来美国开独奏会的，聊天当中处处被教做人，甚至有白比他们年龄长一倍的感觉，这样的眼界和见识怎么比？</p><p>事实上，比无头苍蝇乱撞般瞎努力更重要的是选择，比选择更重要的是信息，还有历史行程、社会形势、贵人相助以及运气等因素。<strong>有时候必须承认人与人的差距可能努力程度占三分，而其他因素，占七分，甚至九十七分</strong>。也因此，小县城学霸以及我这样的伪“小县城学霸”到了顶尖名校之后不可避免会有一定失落感，这也是现实存在的一个问题。</p><h2 id="section-2">2</h2><p>从这一刻起，没有金刚钻却强行揽了瓷器活的日子开始了。德不配位，必会撞墙。不过话说回来，如果没有当年的撞墙也不会有如今的成长。下面所有的故事，可以称为“<strong>一个名校（主流价值观中的）差生的试错与教训</strong>”。整个过程，也就是跟自己的局限、幼稚与无知斗争的过程。</p><p>虽然从考上清华那一刻开始自己就隐隐约约感觉到，高考一次的成功不能说明太多问题，更没有一劳永逸的感觉，然而现实永远比想象的更加要命。大一第一学期我和高三的辛苦程度差不多，但是期中考试的成绩竟然是（大约）年级倒数前三（年级100人左右），有一门差点没及格。看到成绩的时候我突然懂得了很多事情，而大学四年的目标，也由在本领域做出点成绩变成了安全毕业。</p><p>我当时的想法就是，既然学术（单说成绩方面）这条路走不通，那索性就去多试试别的。于是我从那之后几乎每学期都选35-40学分的课，想拓展自己的视野，找找自己可能能行的方面究竟在哪里。同时加了学生会，加了社团，认识了一些从当时看来闪闪发光的牛人，甚至还有过做了个互联网信息平台差点创业的经历。故事发展到这里，从外界看来似乎我的大学生活将要过得风生水起，然而似乎并没这么简单。</p><p>到了大二，我逐渐认识到自己对本专业并没有像自己想象的那般兴趣，而且学习也越来越吃力。带着困惑，我去咨询了一些前辈，前辈给的建议都是“好好学专业课，好好做科研，当你用到你所学的知识的时候你自然会喜欢的”（这是我唯一能得到的信息，尽管帮助着实有限）。于是我进了实验室（这在当时已经算起了个大早），然而发现根本不知道自己学的知识能够如何用到科研当中。此时此刻，同年级里有的同学已经开始接独立课题，有的同学已经有文章发表（非一作，不过放到现在，大二发一作的也已经不计其数了）。我在想，成绩拼不过不要紧，科研别输给他们。</p><p>终于在大三的时候，换过好几个实验室，我在一个交叉学科方向找到了自己的兴趣，而且这个方向一做就是四年。至于成绩，好的时候年级倒数1/3，差的时候年级倒数1/6，已经不在乎了。凭这样的成绩直接申国外博士几乎是不可能的，保研本系或者本校也差一点，于是不得不通过读硕士找个跳板，试图积累成绩以外的其他资源。其实在这个阶段，我也想过未来发展的其他可能性，但苦于真的不知道该去哪寻找信息（甚至那个时候大部分出国党都不知道有暑期研修这东西存在，反观今日，没个海外研修都不好意思出国），周围以我的眼界所能听到的声音也是“万般皆下品，唯有科研高”这样的价值观占主导，所以我并不觉得这里面有什么问题，或者并不知道自己选择这条路有多少是出于自己真心所想，而又有多少是出于随大流或者生活的惯性。</p><p>于是我算是在两眼一抹黑的情况下申请出国，匆匆忙忙准备申请材料，运气还算好，也拿到了较为不错的录取，还提前联系好了将来想跟的导师和实验室。再加上大四一年拼命科研，虽然到最后成绩仍然在倒数1/4，但国内国际期刊均有论文收获，这对于大学四年没得过任何荣誉（如果课余参加的一些数学物理方面的竞赛不算的话，只算官方荣誉）没拿过任何奖学金甚至很少受到赏识的自己来说也觉得没白来一遭。四年来受到的自信心打击太多，甚至到了最后已经被碾压到心如止水了，也越来越觉得有些时候人与人的差距不是通过努力能够追上的。即便如此，最后也涉险毕业，准备去美国开始一段新的人生，虽然直到本科毕业，我连一次出国经历也都没有。</p><h2 id="section-3">3</h2><p>在另一段“没有金刚钻却强行揽了瓷器活”的经历开始之前，我觉得这里有必要评价一下<strong>名校学渣</strong>这种客观存在且无数人经历过或正在经历的状态。</p><p>曾经知乎上有个问题，叫“在清华大学当学渣是种怎样的体验？”，回答者甚众，甚至在我本科时代的周围，包括我自己在内，都有很多人实实在在的经历过这样的挫折。很多时候当我们分享起自己被碾压的经历，会换来别人的不理解，甚至是“何不食肉糜”。然而这里面的痛苦却是真实的，我也见过有人因为学习成绩跟不上，退学的有之，休学的有之，抑郁的有之，甚至自杀的都存在。<strong>在很多情况下成绩成了衡量一个人唯一或者最重要的标准，赢者通吃，而在这一评价体系下没有胜出的人就很难得到主流舆论体系的承认。</strong></p><p>本科毕业之后我曾经跟一些这种处境的学弟学妹聊过，看到他们的迷茫我似乎也看到了当年自己的影子。那种自卑、焦虑、挫折、不被承认的感觉是的的确确困扰着我们当中很多人的，更何况名校学生对自己的期待和现实很难不产生心理落差。</p><p>由于人与人的痛苦是不共通的，每个人的解决方案也不尽相同。放在我身上，当我被学习成绩打击的时候，我当时的选择是在学生会做好事情，去实验室做好科研，而身边一些人可能是通过外出实习、体育运动、恋爱等方式排解。当被主流评价体系打击到怀疑自己存在的价值和意义时，我现在能给出的建议是，<strong>出去申请实习（甚至完全不必是自己对口行业的实习）</strong>，真正接触一下工作是怎样的，破除单一价值观带来的禁锢（不管这种单一价值观是外界强加的还是自己想象的），你会发现原来自己还能做出这样的贡献。我们在学校里的跑道只有一条，但实际上现实生活中的跑道有无数条。树挪死人挪活，换个环境很多时候都会带来不错的发挥。</p><p>现在，我想提出这样一个问题：<strong>如果读者作为名校毕业生，在大学四年过去之后，享受了较好的教育资源，你认为在什么方面自己应该具有一定优势</strong>？文章的最后我将谈一下自己对这个问题的看法。</p><h2 id="section-4">4</h2><p>2015年夏天，我仍然是在两眼一抹黑的情况下来到了美国。清华四年的经历虽然洗刷掉了我所有的骄傲和大部分的自信心，让我明白自己其实实力也就是中人之资，但还是模模糊糊抱着一个想当科学家的梦想。可是此时，我面临的主要矛盾已经变成了看到了更大的世界和自己内心可怜的信息量和姿势水平之间的矛盾。</p><p>本科期间我对象牙塔里的这一些规则或者体系有了一定的了解，但对社会的认知其实比刚入大学的时候并没有多少长进。在国内的时候，本身和其他背景的人交流就不多，科研压力也让我每天都在闷头向前赶，却很少抬起头来想想为什么，或者看看周围更广阔的风景。结果就是，到了美国，当不得不睁眼看世界的时候，发现身边的人一个比一个生活多姿多彩光鲜亮丽，而自己就像一个只知道埋头干活反而连活都干不好的傻B。</p><p>诸位别笑，这的确是我来到美国的第一感觉。一个见识有限的人突然到了一个大环境当中，不可避免有一种刘姥姥进了大观园的感觉。很多人的经历也让我大开眼界，有好的也有坏的，好的让我觉得“我大学期间都错过了什么”，而不好的让我觉得“原来还有这样的人存在，服气服气”。也因此，来到美国一两个月，我的三观就几乎被刷新了一遍。</p><p>在科研领域遇到的挫折（实际上什么都没做出来）让我发现这条路并非这么容易，生活中遇到过不靠谱的人和事太多我也只能说自己曾经太傻太天真。经历了刚出国换环境的阵痛，我再次陷入了不知道将来想做什么的困惑当中。但是所不同的是，这一次，我知道的信息更多，有一定可以选择的余地，也做好了试错的准备。</p><p>但是主业也容不得耽误，于是匆匆忙忙填完了博士申请，结果在关键时刻一篇投往顶级期刊的一作文章被拒，唯一可以拿得出手的砝码丢了，拿到的是隔壁学校降转硕士的录取（按照当时的情况留本校可能可以拿到博士，但在当时的环境下过得实在是太不开心，加之所在的研究方向不喜欢，不想一直这样下去）。</p><p>虽然不甘心但是也没办法，实力不济加上运气不好，只能接受现实，第一时间联系好了自己想做的方向的导师，因为正常情况下做得好是能留下来读博的。同时我利用这当中的空闲时间，投过咨询机构的实习，尝试了他们的思维方式。之后又投了几家金融业的实习，虽然做的也并不愉快。我试图通过这个，去弥补本科期间，甚至更早的时候，对这个社会，对各个将来可能从事的行业认知的缺失。然而事实告诉我，你还是太年轻，想的太简单。</p><p>说到这里，我想谈一下我们很多年轻人对这个社会认知的问题。我们在真正独立走上社会之前，接受的宣传是通过主流价值观为主的。但即使这样，这样的信息也难免偏颇，很多时候我们只看到了事物的A面，而没有看到B面，甚至可能还有S面。就单说科研领域，社会告诉我们的是做出成果无尽荣光，可是却不会告诉我们一将功成万骨枯，以及很多领域象牙塔和工业界存在脱节。金融领域我们看到从业者西装革履光鲜亮丽，但是背后却有朝八晚三不为人知的辛酸。创业圈更是这样，有人ICO，IPO一夜暴富，可更多的却是亏完了钱打水漂睡沙发的窘迫。</p><p>打个比方，我所在的城市高楼林立科技发达，然而当夜幕降临在一些不为人知的角落，也存在流浪者、大麻甚至是枪击。很多时候我们带着有色的，甚至可能是带着粉红泡泡的眼镜去看待社会，这个滤镜是我们了解社会的为数不多的途径，即便它存在失真。因此初出茅庐的人很容易去带着单纯的心态去相信A面是社会的全貌，然而当撞到南墙的时候，可能会遭到这样的批评：“<strong>你对社会的认知存在偏差，这锅你不背谁背</strong>？”你总觉得哪里不对，却无法反驳。</p><p>确实我们在往上攀登和向广阔的未知天地进发的时候，每一步都在离开自己的舒适区，这也就意味着我们在小圆内对世界的认知是没法向外延拓的。每一步都存在风险，每一步都在跳未知的坑，再加上人生不如意十之八九，难免怀疑人生，其实到最后不管是焦虑还是佛系，都是挣扎之后的结果。打碎面前的云山雾罩似乎很容易，但是人总愿意去相信事物对自己有利的一面，而潜意识的厌恶可能存在的风险。到了这里，闭关自守也罢，虚无主义也罢，随着这样的恶性循环慢慢成了我们挥之不去的绊脚石。也因此，很多时候虽然道理就在那里摆着，但唯有撞南墙尝苦果，才能让我们冲破这层人性原罪的束缚，去认知更大的更全面的新世界。</p><h2 id="section-5">5</h2><p>如果说刚刚出国的时候的情况是两眼一抹黑，那么一年之后的状态就是面前摆着几条道路，每条似乎都通向光明的前途，你却根本不知道该选哪一条。所幸导师对我很好，不管是在学术方面还是在生活方面都给了我很多人生经验和指引，让我有一种发自内心的因为受到知遇之恩所以必须要好好干活的感觉。受到这样的激励，我也立志在科研领域做出自己的一份贡献，然而由于接触的世界越来越大，我开始听到了很多不同的声音，而这些声音是我从来没有想象过的。</p><p>就比如说2016年很火的两篇帖子<ahref="https://www.zhihu.com/question/50766928">《T大本科舍友阶级分化实录，该何去何从？》</a>与<ahref="https://www.zhihu.com/question/44186681">《凭什么我辛苦二十年，现在却比别人差那么多？》</a>。从局外人的角度看来，我们可以说里面的主人公书生气过重，博士快要毕业了仍然没有认清楚一个事实，即你的学习成绩和学术成果和你将来在世俗评价标准下的成功只有很弱的相关性。可是话说回来，这样的谴责虽然道理正确，但并无助于解决问题，而且难免有一种站着说话不腰疼的感觉。更重要的是，久居象牙塔中的我们（包括我在内，也曾具有上述的思维误区），<strong>跟社会的接触少了，就很容易用这种单一的线性的价值观去评判自己和他人，尤其是和别人一比较，各种不如意便会纷至沓来</strong>。而且还是那个问题，人总愿意去相信对自己有利的观点，这就很容易用战术上的勤奋去掩盖战略上的懒惰（即便我在很长时间的科研当中也是如此，没仔细想why就去想how并亲身实践了无数种错误的how，结果自然是充满了无用功和南辕北辙）。</p><p>从上面这个现象引申出来另一个现象，即对部分存在产学研脱节现象学科的劝退，想必大家都了解了许多。如今信息比以前通畅得多，大学新生选择专业以及高校毕业生选择行业的时候比几年之前更懂得去参考历史的行程决定个人的发展方向，其实也未尝不是个好事。我个人曾经也是一个劝退者，但是如今，我觉得更应该做的是，消除信息不对称，也就是让了解信息有限的人们不仅认识到学术这条路的A面，更要了解其B面，对将来可能面临的风险有一个充分的估计，想明白自己追求的是什么。<strong>经过深思熟虑之后做出的选择，要比冲着高大上的标签或者七大姑八大姨的期待做出的选择，要更加理性</strong>。在这个方面，我自己就是活生生的目标不明确东一榔头西一棒子乱打的反例。</p><p>不得不承认做科研的经历是有一定痛苦的（其实任何事情都这样，不存在既高大上又光鲜亮丽的事情）。在自己的课题研究过程中，无数次遇到解不出来的公式，跑不出来的程序，和理论不一样的实验结果，以及各式各样用尽世间已有知识解释不了的问题。与此同时，周围的很多人在积极谋求转行，而金融和互联网成为了转行的首选。在这样的气氛中，除非是自己心里有明确目标且能塌下心来坐得住的人，否则包括我在内的很多人也难免被舆论影响，盖因心里虽然有目标但目标根本不坚定。此时此刻，我再次陷入迷茫，经常思考两个问题：1.我为什么要来这里？2. 我将来到底想做什么？</p><h2 id="section-6">6</h2><p>时间到了2017年，在社会经历着指数型的科技发展浪潮的过程当中，一种名为勃学的新思潮发展的如火如荼。简而言之，勃学基于失败学，我们每个人都有自己的失败，我们要对自身的失败有清醒的认识。从外界看来，取得了一定世俗成就的人本应是成功的，这样的失败是不是何不食肉糜呢？但是确实，这种思潮确实反映了一部分通过自我奋斗达到一定高度，所看到的世界却灰暗了许多的人们的认同感，尤其是名校毕业生和中产人士。为什么明明已经得到了很多，它们却带来了无尽的挫败感呢？</p><p>这里不谈阶级固化、精英主义等高大上的话题，只想举一个例子。我们的祖辈可能一生都没有走出过小镇，日出而作日落而息生活简单而充实。我们每个人都有那种小学初中同学，早早离开学校进入社会，在我本人朋友圈里看到的一些例子是，他们没有离开家乡，在家乡做着一些相对低收入低技术含量的工作，例如摆摊开店，大部分已经结婚生子，看起来十分快乐，现世安稳岁月静好。而我们很多人，从高考的残酷竞争中杀出来进入名校，可能还出国见了更大的世界，或是找到了高收入的工作，可为什么得不到他们的那种快乐呢？</p><p>我们或许可以这样思考，古人提出过人生三境界，如果我们永远不走出自己的舒适区，那么就是“<strong>看山是山看水是水</strong>”，或者说“我未入过繁华之境，未听过喧嚣的声音，未见过太多生灵，未有过滚烫心情，所以也未觉大洋正中有多么安静”。也因此，对客观世界的认知符合自己的常识，可以很轻易的通过自己的常识得到快乐。</p><p>然而到了第二境界，“<strong>看山不是山看水不是水</strong>”，当我们见了更大的世界，发现自己的一套体系已经不足以解释自己看到的世界，就比如苦心孤诣探索学术十几年，主观上做出了足够的努力，却在客观上收获不了自己想要的“书中自有黄金屋，书中自有颜如玉”，认知崩塌陷入对自己的怀疑，不管归因于“错的是我”抑或是“错的是世界”，价值观就会解体重塑。无论是打破幻影还是打破枷锁，这个过程都是十分痛苦的。</p><p>然而大部分人终其一生也很难达到第三境界，“<strong>看山还是山看水还是水</strong>”，没有一定经历和成就，这一层是连想都很难想象到的。即便是”众里寻他千百度；蓦然回首，那人却在灯火阑珊处“的”啊，原来你也在这里“，不经历一番”昨夜西风凋碧树，独上高楼，望尽天涯路“和”衣带渐宽终不悔，为伊消得人憔悴“的苦痛挣扎也是无法实现的。由于我自己远远没有达到这一境界，因此不多赘述。但总之，”你所认为的世界运行的规律“和”世界真实的运行规律“两者之间大部分情况下存在夹角，甚至有时候夹角还是钝角。因此，你不得不不断地调整自己对世界的认知，而这里面的阻力和惯性，以及调整之后与之前状态的错位，就容易让人怀疑自己所想所做到底对不对。</p><p>曾经有两篇阅读量极高的文章，<ahref="https://www.zhihu.com/question/52031149">《我上了985211才发现自己一无所有》</a>和<ahref="https://www.zhihu.com/question/65098412">《一个月就辞职，一个北大女生的求职悲欢》</a>。虽然和勃学并未有联系，但反映的问题却是共通的。有些人对这种现象的批评，包括”无病呻吟“也罢，”庸俗矫情“也罢，其实仔细想想是站不住脚的，由于痛苦不共通，这就像问抑郁症的人为啥要自杀一样缺乏同理心，更何况我相信每个人都有过这样的怀疑和纠结，只是程度不同而已。人生对每个人都只有一次，进入社会见到更大的世界，必然面临着自我和世界的冲突，而处在冲突当中的个人，很容易将自己遇到的问题放大，陷入痛苦，就像小时候辛苦搭好的积木倒塌之后仿佛失去了全世界一样。从这个意义上来说，我倒是觉得同为年轻人的自己和这里面提到的主人公有一定共鸣。同是天涯沦落人，相逢何必曾相识？不过话说回来，该类文章其实反映了一个问题，就是“<strong>学区房值钱（个人奋斗几十年都不一定买得起）</strong>”和“<strong>学历不值钱（名校毕业生的世俗成就达不到内心期望）</strong>”之间的矛盾。所以，这个错位背后，是哪里错了呢？（这个问题我也没有想明白）。</p><h2 id="section-7">7</h2><p>人生总有想不明白的哲学问题，就像科研也永远不能一路顺风一样。2017年发生过太多的事情，以至于刚脱胎换骨一遍的三观又被现实撕得粉碎。其间遇到了转博被拒的挫折，认识了硅谷科技界上百的IT工作者，回国看到了祖国翻天覆地的变化，也经历了对自己价值的彻底怀疑，人际关系的全面崩溃，甚至无数次夜不能寐在凌晨四点的帕罗奥图的天空下失声痛哭。</p><p>然而，冥冥之中总有个声音对我说：</p><p>“<strong>你得到今天的这一切，本来就是运气眷顾，你还想要什么呢</strong>？”</p><p>对啊，能走到今天，我所拥有的东西本来就不是和自己的能力匹配的，你是不是太贪得无厌了？</p><p><strong>“将寄托于花朵的思念用言语来表达出来，我丝毫不想伤害这个世界，如果没有聆听者的话，你就可以放任自己为所欲为吗？</strong></p><p><strong>然而，然而，你却把打算摘给别人的花留下，然后看到他的时候，却为了能得到赞扬把花送给他。</strong></p><p><strong>能找到这么漂亮的花，我是个好孩子吧。我来告诉你怎样去摘这朵花吧！</strong></p><p><strong>像这样假装亲切，好好炫耀一番。以花为借口亲近他，伪君子。”</strong></p><p align="right">——《School Days》 清浦刹那</p><p>我真的问心无愧吗？</p><p>我的初心是什么？为什么扭曲成了现在这个鬼样子？你看重的东西真的不是虚无缥缈的吗？</p><p>是不是一开始一切都错了呢？</p><p>为什么在给别人建议的时候从未失手，到自己身上就撞南墙撞得头破血流了呢？</p><p><strong>为什么会这样呢？？？</strong></p><p>2017年的冬天格外寒冷，在无尽的挣扎当中，整个冬天不仅科研没有进展，甚至什么都没干，极端的时候甚至想用安眠药一了百了。<strong>（题外话：我知道很多人曾经有过这样的想法，但是在这种时候，请一定一定去找自己信得过的人倾诉，或者去找专业的人员帮助解决心理问题</strong>。如果没有，我本人愿意做一个倾听者，也承诺保密所了解到的一切信息，毕竟我曾经在这样的痛苦中挣扎过。这种情况的人，我彻夜长谈过的，至少有三个，他们现在都已走出了内心的阴影，重获了生活的快乐。）</p><p>人们对于坏消息的第六感往往是非常准确的，尤其是在人生境遇处在低谷的时候。当转博被拒的时候我就觉得有些一厢情愿的事情可能就要到头了。于是我通过各种途径联系了外校的部分教授，硬着头皮再次投了一次博士申请，但是越来越觉得我想要的东西和我正在做的事情已经完全南辕北辙了。</p><p>2017年12月，由于对人生的怀疑和对现实的弃疗，我时常和各种人聊天，谈论各种各样的迷茫及困苦。与三十五岁恋爱都没谈过的博后促膝长谈，也与四十几岁孤身一人漂泊美国的研究员对月举杯。这就是我曾经想做的事情的B面，可是如果换成我，我愿意去赌这一个未知的未来吗？扪心自问，答案是否定的。</p><p><strong>“差一点骗了自己骗了你</strong></p><p><strong>爱与被爱不一定成正比</strong></p><p><strong>我知道被疼是一种运气</strong></p><p><strong>但我无法完全交出自己”</strong></p><p align="right">——《可惜不是你》 梁静茹</p><p>所以，你确定自己不是叶公好龙吗？</p><p>这条路上所需要的努力（1分）、热情（3分）、运气（6分），你一个也没有。</p><p>你的初心可能没错，但是你所做的所想的，和你所追求的东西，完全是两个不同的方向。</p><p>这场持续三年的梦境，是时候该落幕了。</p><p>转过头来2018年到了，雨神似乎笼罩了湾区，终日不见阳光，让人的心情不由得也变得压抑。但是，梦醒了，是时候该回到原点重新开始了。</p><p>留下来读博做不到我不惊讶，联系好的教授放了我鸽子我也不惊讶，反正已经习惯了，起了个大早赶了个晚集的人又不止一个。然而收到第一个offer的时候我心里却五味杂陈。</p><p>一月的寒风中我前所未有的点上了一根烟让自己冷静下来（虽然我这25年来抽过的烟用两只手都能数过来）。烟雾中幻化出无数个平行世界，平行世界A中的我读完博士拿到教职走上人生巅峰令人艳羡，BCD中的我费了九牛二虎之力读完博士转行拿到了和别人本科毕业一样的工作，EFG……而平行世界XYZ中的自己，一生碌碌不得志，最后变成了MITBBS上的戾气溢出屏幕的精神已经不正常的中年loser。</p><p>路是自己选的，将来不管收获的是果，还是锅，也都是自己的。人生没有后悔药，做决策的时候多想想未来，而不要考虑沉没成本。</p><p><strong>“在终于释怀的那一刻</strong></p><p><strong>找回了久违的快乐”</strong></p><p align="right">——《我决定》 梁静茹</p><p>自己辛苦追寻的金刚钻终究没有得到，瓷器活也只能另请高明了。</p><h2 id="section-8">8</h2><p>2018年3月，我来到洛杉矶参加了一场学术会议，算是亲手给自己的追寻（本专业的）学术成就之路画下一个句号。讲完自己海报的一刻，突然有一种神清气爽的感觉，来不及放下东西，直奔加州理工去拜访几个多年未见的好朋友。此时此刻，我终于彻底想明白了一个道理，“<strong>科研和世俗成功两者之间即便不是垂直，夹角也至少有88°</strong>”。有人问88°是怎么得来的，我说用量角器量出来的。量出这个角度，我花了三年，而另一些人，甚至是十三年，三十年。饭桌上跟几个博士在读的朋友聊过，发现原来他们这等神人也有世俗的烦恼（虽然这是废话，但我的思维始终没有转过这个弯来）。家家有本难念的经，我们都是普通人，为什么要互相比较一些有的没的来给自己增加不必要的烦恼呢？求仁得仁，想要什么，就冲着那个方向放手一搏吧。</p><p>于是在几个月的刷题和几年来积累的计算机方面的知识、能力和项目经历的基础上，3月下旬的某一天我一夜之间通过各路朋友的内推向国内互联网公司投了五十份简历。虽然自己这几年来学术上不敢说有所收获，但是人脉和软实力上所积累的一切是我至今不悔留美三年的一个很重要的原因。虽然自己的知识体系必然不系统，但是我个人觉得自己的水平和科班CS大三大四的水平还是比较相当的（除了没有相关科研及实习经历以外）。闻道有先后，术业有专攻，如是而已，终究亡羊补牢也没晚多少。由于名校牌子的加成，整个求职过程还算顺利，连轴面试将近一个月，国内最后拿到4个offer，美国这边也投了几个小公司并都走到了最后一面，由于国内的offer到了，加之我个人在这里实在是过得不快乐，所以就没再继续面下去。本着此心安处是吾乡的原则，选完城市，再选公司，兜兜转转回到了最熟悉的五道口，加入一家蒸蒸日上的创业公司。（题外话：在五道口的前辈和友人们欢迎到时找我约饭。）</p><p>由于我实力有限加上并非走的正常校招流程，具体的求职细节就不在这里讲了，以防班门弄斧。如果同为转专业且对这个过程有兴趣将来可以私聊。当然不得不承认，由于求职始于匆忙，中间各种问题也出过不少，还出过一个差点没法毕业的乌龙，不过最终的结果还算不错，经过了几年的尝试，用了无数次排除法，在此刻虽然我也不敢说自己一定喜欢做什么，但是有把握说自己不喜欢做什么。这就像一个深度优先搜索一样，撞了南墙再回头，虽然有时候走了不少冤枉路撞了不少南墙，比别人晚到了目的地，可是看到的东西也更多了。</p><p>我曾经想过，如果高中多搞一门竞赛会怎样，大学选择一个不同的专业会怎样，研究生期间年年暑假出去实习会怎样，再仔细一想，在没有信息的情况下有多少人能做出这样的选择，而从最终结果看起来也不过是小的得失而已。有些事情放在当时看，重要吗？的确重要。可是从更长远的时间看来，什么都不是。如同幼儿园丢了个小红花，中学错过了喜欢的人，高考失利，求职遇挫，每个人都会对此做出应激反应，可是几年之后回首，也不过是饭桌上的一件谈资而已。</p><p>在上篇《老实人的归国与失身》中我曾经提到，求职过程中受到高中同学的内推，文中提到的高中同学本科位于家乡普通一本，通过考研来到了北京，积累了无数的实习经历最终在另一家独角兽企业独当一面。文中结尾提到的“明明是我先来的，为什么会变成这样呢？”本来是一个出自《白色相簿2》的梗，招致了一些不懂背景的人的误会。什么叫做线性思维/学生思维？这就是。早起的人不一定能赶上集，生活本来也没有先来后到。更何况别人在另一些方面比自己先来，比如工业界经验，比如对社会的认知，这都是象牙塔本身所给不了自己的。该篇文章中的主人公可能也是幸存者偏差的产物。</p><p>前段时间和朋友讨论，说到了不同的人在不同阶段所做的努力和承受的痛苦。从高考大省杀出来固然需要拼命，但从考研大省逆袭何尝不需要努力，而且艰苦程度也是非亲历者不能想象。我们能看到的例子是通过个人奋斗逆袭走上人生巅峰的人们，可是在这背后的B面，多少人在这一过程中折戟撞墙，最终成为了默默无闻的普通人，他们的故事又如何去表达出来呢？</p><p>什么是幸存者偏差？2018年高考全国二卷的作文就很能说明问题。</p><p><img src="20191202223556152.png" alt="在这里插入图片描述" />2018年6月，在即将离开美国的时候，我与科研大佬聊过他们申请教职当中的悲与喜，与硅谷科技从业者谈到科技下一步的发展方向，与现在的牛人本科生讨论他们的梦想，与00后一代学习他们的价值体系和处世方式，也与在国内的本科同学们交流不同行业的求职经历，以及当前日新月异的一线城市。曾经的自己只顾脚下的一条路，以为这就是整个世界，到头来路越走越窄以至于痛撞南墙。而抬起头来，发现参差多态乃是幸福本源，生活的跑道比自己想象的还要多得多。而这个时代恰恰也是信息量爆炸的时代，每个人都在追寻自己的梦想，就看谁能把握住这里面的机会。</p><p><strong>“回想起历往云烟终于让我全都看透</strong></p><p><strong>闭着眼低头走过那份温柔”</strong></p><p align="right">——《涙の理由》 栗林美奈实</p><p>总之，运气眷顾，在一个新的领域，我在不知道自己有没有金刚钻的情况下又接下了瓷器活。可如今最大的不同就是，即便没有金刚钻，我也知道如何去获得它。即便无法获得，我也知道如何打磨现有的资源使之无限接近真正的金刚钻。几年的摸索告诉了我这样的方法论，也算是不虚此行了。感谢一路上遇到的前辈和同辈，感谢他们给我的指引和人生经验，感谢遇到的挫折使我想明白自己内心深处究竟想要的是什么，感谢命运待我还算不薄。路还很长，所以更要心无旁骛望着远方。</p><p>最后放一张图，描述在这么多年来我”想当一名科学家“的这个愿望的强烈程度是如何变化的。虽然走到现在，这条路上的追寻暂时鸣金收兵了，但失之东隅收之桑榆，我也看到了更广阔的风景，开始了另一条路上新的追寻。</p><figure><img src="20191202223756684.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="section-9">9</h2><p>时光飞逝，我自己的学生时代即将结束。清华四年经历告诉了我自己的能力是有局限的，而美国三年经历告诉了我天有多高地有多厚。虽然初心只是自己幼稚时候的一厢情愿，但人在长大的过程中都会变的，甚至在半年之前我都没有料到今天是这样的结局，计划永远赶不上变化，而未知的未来可能信息量更大。有时候我在思考一个问题：我一路以来享受了最好的教育资源，可是有没有做出相符的成绩和贡献呢？如果没有的话，我从中积累了什么优势呢？眼界，人脉，还是对更大的世界的认知，对自己较为全面的评价？</p><p>如果限制我们的成就的是外在因素，很多时候我们只会惋惜命运待人不公。就如同如果基础教育能够普及，广袤的非洲能走出多少科学家？可是这里面无数的聪明人就因为食不果腹而终其一生无法为人类的发展做出贡献。而我自己，出身明明优于90%的同辈人，享受着最好的教育资源，不缺天时地利人和，想要找到贵人相助也不难，在人生的重要选择关口也不乏运气垂青，理应有着更大的使命，为这个世界做出自己更大的贡献。然而，有时候事情的发展偏离了预想的轨道，现实情况和自我期待出现错位，明明自己能力达不到却不得不去努力争取，明明追寻的东西就在眼前看似唾手可得但就是得不到，那种失落和不甘心，如同差一点爬到高峰又狠狠摔下，带来的痛苦就要比在平地上跌倒要强烈得多。</p><p>我的经历和反思讲完了，在最后，我觉得有必要给出一些简单的结论：</p><p><strong>（0）选择正确的方向比努力更重要，而信息的通畅是做出明智选择的保证。将获取信息的能力从1提到2，边际效应要远远胜过努力程度由9提到10。</strong></p><p><strong>（1）对于名校同学，有时候我们自身带着一种骄傲，但在校内评价体系下受到的打击会令我们自卑，两者叠加在一起会让我们很难对自己有准确的定位。然而，既然享受着资源优势，而且终究都要走出象牙塔走向社会（即便是立志从事科研工作也不能免除与更大的世界打交道），不如早点接触真实的工作环境，在找到自己价值所在的同时，提前排除错误选项或者选定正确选项，不至于到最后赢在了成绩却输在了社会经验。</strong></p><p><strong>（2）对于非名校同学，高考、毕业学校这些东西和将来的成绩的相关度是很弱的，通过主动获取信息做出明智的选择，避免无头苍蝇一般的无效努力，进而比名校学生优秀的也大有人在。没有那种小心翼翼瞻前顾后患得患失，反而更大胆去试错和总结经验，这些都不是从书本上能够学到的。</strong></p><p><strong>（e）(e=2.718281828)综上所述，高考考的如何和去什么学校读书真的没那么重要，在需要努力的时候尽力而为，但永远记得仅仅是努力本身是没有价值的。打怪升级获得的奖励，从来都不是和打怪的难度成正比。</strong></p><p><strong>（3）老实人们会习惯性认为，努力读书、努力工作等等才是能力，然而，真相却是，“不老实”可能是一种比个人奋斗更重要的能力。</strong></p><p><strong>（π）(π=3.141592654)因此，老实，其实并不是一个好事。</strong></p><p>满纸荒唐言，一把辛酸泪。</p>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Predecessor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 590</title>
      <link href="/posts/cf-round-590/"/>
      <url>/posts/cf-round-590/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1234">Round#590</a><br />题目答案：<ahref="https://codeforces.com/blog/entry/70233">官方Editorial</a>、<ahref="https://github.com/EIMadrigal/CF">My Solution</a></p><h2 id="a.-equalize-prices-again">A. Equalize Prices Again</h2><p>签到题还WA了一发，向上取整有点问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my wrong code, 1.0 * sum返回double</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">1.0</span> * sum / n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//right code</span></span><br><span class="line">(<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="number">1.0</span> * sum / n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ceil()原型</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p><code>float</code>能保证6位精度（有效数字），<code>double</code>能保证15位精度。但是<code>float</code>和<code>double</code><strong>默认都只显示6位有效数字</strong>，所以一旦<code>1.0 * sum / n</code>大于6位，函数返回的<code>double</code>就显示不全，造成精度损失（比如结果应该是<code>5336844</code>，但返回<code>5.33684e+006</code>），故进行强制类型转换。</p><h2 id="b1.-social-network-easy-version">B1. Social Network (easyversion)</h2><p>题意：屏幕可以容纳<spanclass="math inline">\(k\)</span>条短信，有若干朋友发来<spanclass="math inline">\(n\)</span>条短信。如果某个朋友已经在屏幕上，不做改变；否则将其他朋友下移，新收到的朋友置顶。求最终自顶向下显示在屏幕上的朋友。<br />思路：按照题意模拟，我搞得有些繁琐（用<code>queue + set</code>来考虑是否将新来的短信放入屏幕，再用<code>queue.size()</code>和<spanclass="math inline">\(k\)</span>判断是否需要将旧短信<code>pop()</code>，最后将队列中的元素逆序输出）。</p><h2 id="b2.-social-network-hard-version">B2. Social Network (hardversion)</h2><p>数据量变到了<spanclass="math inline">\(10^5\)</span>级别，官方题解和我在B1中的思路一致。不过最后输出我是先压栈，题解是先存入<code>vector</code>，再用<code>reverse()</code>函数逆序，复杂度<spanclass="math inline">\(O(nlogk)\)</span>。</p><h2 id="c.-pipes">C. Pipes</h2><p>模拟题：比赛时候发现了既然可以无限旋转，那么管道一共有2类：<spanclass="math inline">\(12\)</span>一样，<spanclass="math inline">\(3456\)</span>一样。<br />水流到<spanclass="math inline">\(12\)</span>这类，只能水平向右流；<br />流到<spanclass="math inline">\(3456\)</span>这类，那么另一行对应的位置也必须是<spanclass="math inline">\(3456\)</span>类，水就会换一行流动（异或即可换行），否则水没法继续流动。<br />最后判断水能否流到第二行第<span class="math inline">\(n\)</span>列。</p><h2 id="d.-distinct-characters-queries">D. Distinct CharactersQueries</h2><p>题意：给一字符串和<spanclass="math inline">\(q\)</span>次查询，查询分为两类：一类是替换字符串中某个字母，另一类是求子串中非重复字符的个数。<br />比赛时的思路是：遇到第一类查询就按规则替换，第二类先拿到子串，依次把子串的每个字符放入<code>set</code>中，最后返回<code>set.size()</code>即是非重复字符个数。<br />此题的教训就是要学会根据数据量级猜算法：1s/2s时限，C++运算次数大约在<spanclass="math inline">\(10^7\)</span>，本题的数据范围<spanclass="math inline">\(10^5\)</span>，我傻傻地把<spanclass="math inline">\(O(n^2)\)</span>的算法交了三次，TLE了三次，我还以为是<code>cin</code>的问题。。。<br />参考下大佬经验：<ahref="https://www.acwing.com/blog/content/32/">由数据范围反推算法复杂度</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 587</title>
      <link href="/posts/cf-round-587/"/>
      <url>/posts/cf-round-587/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1216">Round#587</a><br />题目答案：<ahref="https://codeforces.com/blog/entry/69954">官方Editorial</a>、<ahref="https://github.com/EIMadrigal/CF">My Solution</a></p><h2 id="a.-prefixes">A. Prefixes</h2><p>题意：给一字符串，只含有<code>'a'</code>或<code>'b'</code>，需要改变某些位置（<code>'a'</code>变<code>'b'</code>或<code>'b'</code>变<code>'a'</code>），使得该字符串任意偶数长度前缀中<code>'a'</code>和<code>'b'</code>个数相等，求改变的最少次数以及更改后的字符串。</p><p>题解：遍历，判断<code>s[2i]</code>和<code>s[2i+1]</code>是否相等。如果相等，需要一次更改，并将其中一个改为不同字母。</p><h2 id="b.-shooting">B. Shooting</h2><p>题意：给<span class="math inline">\(n\)</span>个编号<spanclass="math inline">\(1\)</span>~<spanclass="math inline">\(n\)</span>的射击目标，每个目标有不同的耐久度，假设已经击倒了<spanclass="math inline">\(x\)</span>个目标，将要射击第<spanclass="math inline">\(i\)</span>个目标，那么需要<spanclass="math inline">\(a_i*x+1\)</span>次才可以击倒该目标，<spanclass="math inline">\(a_i\)</span>为第<spanclass="math inline">\(i\)</span>个目标的耐久度。求击倒所有目标的最少射击次数以及射击次序。</p><p>题解：贪心。想要射击次数最少，就要先射击耐久度大的目标，所以按照耐久度由大到小排序，同时记录对应的目标序号。</p><h2 id="c.-white-sheet">C. White Sheet</h2><p>题意：给定三个矩形，两黑一白，判断两个黑色矩形是否可以完全覆盖白色矩形，不能完全覆盖输出<code>YES</code>。</p><p>题解：分两种情况，记白色矩形面积为<spanclass="math inline">\(S_w\)</span>，一个黑色矩形与白色矩形交叉面积为<spanclass="math inline">\(S_{wb1}\)</span>，另一个黑色矩形与白色矩形交叉面积为<spanclass="math inline">\(S_{wb2}\)</span>，两黑色矩形交叉面积为<spanclass="math inline">\(S_{bb}\)</span>：<br />1、两黑色矩形无交叉：只要<spanclass="math inline">\(S_{wb1}+S_{wb2}&lt;S_w\)</span>，就可以看到白色矩形；<br />2、两黑色矩形有交叉：如果<spanclass="math inline">\(S_{wb1}+S_{wb2}-S_{bb}&lt;S_w\)</span>，可以看到白色矩形。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Recursion and Backtracking</title>
      <link href="/posts/recursion-and-backtracking/"/>
      <url>/posts/recursion-and-backtracking/</url>
      
        <content type="html"><![CDATA[<p>DFS是一种图的遍历算法:</p><ol type="1"><li>从任意结点v开始</li><li>将v标记为已访问</li><li>递归访问v的所有未访问过的邻居</li></ol><p>对于树而言, 有向无环, 不用担心结点被访问2次, 因此不需要标记.无向图可以看作双向有向图, 因此始终是有环的, 也需要标记.</p><h2 id="tree-recursion">Tree Recursion</h2><p>递归是计算机科学中一个非常重要的概念，对于斐波那契那种比较简单的递归，分析起来比较容易，但是由于二叉树涉及指针操作，所以模拟下遍历过程中系统栈的情况。<br />以二叉树中序遍历为例演示： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 中序遍历的递归实现：<br /><img src="https://img-blog.csdnimg.cn/20190915232047750.png"alt="在这里插入图片描述" /><br />假设二叉树如图所示： <imgsrc="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDE5MDkvMTI2MDU4MS0yMDE5MDkxNTIzMTQyMDE5MS0xMTMxOTk2Nzc2LnBuZw?x-oss-process=image/format,png" /><br />其中序遍历序列为<spanclass="math inline">\(2413\)</span>，可以在VS中用单步调试的方法跟踪相应的变量：<br />当<code>root==NULL(root指向2的左孩子)</code>时，此时的系统栈（将1和2都压栈，因为中序遍历需要先访问左孩子）：<br /><img src="https://img-blog.csdnimg.cn/20190916223229149.png"alt="在这里插入图片描述" /><br />这时<code>if</code>不成立，执行83行的<code>return</code>语句，接着退栈，回到78行，此时的<code>root指向2(因为此时程序已经来到了新的栈顶)，并且向这个新栈顶返回了一个空的seq</code>：<br /><img src="https://img-blog.csdnimg.cn/20190916223847870.png"alt="在这里插入图片描述" /><br />接着执行79行(因为这是上一个函数<code>return</code>的，所以不会再一次执行78行)，将2存入<code>seq</code>中；<br />执行80行（<code>root</code>指向4），进而执行78行，<code>root</code>指向4的左孩子，此时的系统栈（很明显可以看到从<strong>栈底到栈顶依次存放根结点到当前<code>root</code>结点的路径</strong>上的结点）：<br /><img src="https://img-blog.csdnimg.cn/20190916225924483.png"alt="在这里插入图片描述" /><br />同样，执行<code>return</code>语句，退栈，将<code>seq</code>(里面只有2)返回到这一层，这一层的<code>root</code>指向4，接着将4存入<code>seq</code>；<br />到80行，调用<code>inOrder()</code>使得<code>root</code>指向4的右孩子，右孩子为空，所以返回并退栈，<code>root</code>重新指向4，此时80行执行完毕，整个<code>if</code>执行完毕，返回<code>seq</code>并退栈，<code>root</code>返回到了2，以2为根结点的子树中序遍历完毕，系统栈：<br /><img src="https://img-blog.csdnimg.cn/20190916230804141.png"alt="在这里插入图片描述" /><br />继续执行，return到78行，<code>root</code>指向1，将1存入seq，以此类推，就可以得到整个的遍历序列。</p><p>最关键的是：之所以要递归调用<code>inOrder</code>，就是因为现在还不想访问当前的结点（对于中序，要先找到最左边的结点），所以通过递归的方式将当前暂时不想访问的结点压入系统栈，找到了想访问的结点后，访问它并利用退栈操作返回父结点。<br />有关树的问题，有一些通用的模板： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one root</span></span><br><span class="line"><span class="function">func <span class="title">solve</span><span class="params">(root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)  <span class="keyword">return</span> ...</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">f</span>(root) <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">solve</span>(root-&gt;left);</span><br><span class="line">    r = <span class="built_in">solve</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(root, l , r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// two roots</span></span><br><span class="line"><span class="function">func <span class="title">solve</span><span class="params">(p, q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == null &amp;&amp; q == null)  <span class="keyword">return</span> ...</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">f</span>(p, q)  <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">solve</span>(p.child, q.child);</span><br><span class="line">    r = <span class="built_in">solve</span>(p.child, q.child);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(p, q, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典递归">经典递归</h2><p>除了树这种本身就是递归定义的结构外，还有一些search的问题也可以通过递归解决：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">length</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>] == s[s.<span class="built_in">length</span>() - <span class="number">1</span>] &amp;&amp;</span><br><span class="line">        <span class="built_in">isPalindrome</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>, s.<span class="built_in">length</span>() - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NotFound = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSearch</span><span class="params">(vector&lt;string&gt;&amp; v, <span class="keyword">int</span> start, <span class="keyword">int</span> stop, string key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; stop) <span class="keyword">return</span> NotFound;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (start + stop) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == v[mid])</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; v[mid])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSearch</span>(v, mid + <span class="number">1</span>, stop, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSearch</span>(v, start, mid - <span class="number">1</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == k || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C</span>(n - <span class="number">1</span>, k) + <span class="built_in">C</span>(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(string soFar, string rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            string next = soFar + rest[i];</span><br><span class="line">            string remaining = rest.<span class="built_in">substr</span>(<span class="number">0</span>, i) + rest.<span class="built_in">substr</span>(i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">permute</span>(next, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无重复值</span></span><br><span class="line"><span class="comment">// call stack只有该层所有for循环结束才回退 因此不能传vector&lt;int&gt; path</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; used, vector&lt;<span class="keyword">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">permutation</span>(nums, used, path, ans);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对数组a的[l, r]做全排列</span></span><br><span class="line"><span class="comment"> * 每个数字都要充当第一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[l], a[i]);  <span class="comment">// 第i个元素充当第一个</span></span><br><span class="line">        <span class="built_in">perm</span>(a, l + <span class="number">1</span>, r);  <span class="comment">// 剩余元素全排列</span></span><br><span class="line">        <span class="built_in">swap</span>(a[l], a[i]);  <span class="comment">// 恢复状态，保证下个做第一个元素的状态正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200704153124426.png"alt="在这里插入图片描述" /> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">com</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == d) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">com</span>(nums, n, d + <span class="number">1</span>, i + <span class="number">1</span>, cur, ans);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsets</span><span class="params">(string soFar,string rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// add to subset, remove from rest, recur</span></span><br><span class="line">        <span class="built_in">subsets</span>(soFar + rest[<span class="number">0</span>], rest.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// do not add to subset, remove from rest, recur</span></span><br><span class="line">        <span class="built_in">subsets</span>(soFar, rest.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200704153731705.png"alt="在这里插入图片描述" /><br />从递归树可以看到：Permutation和Subsets都是关于<em>选择</em>的问题，树的深度代表选择的次数，每层的宽度代表每次决定时的选项。这种都是ExhaustiveRecursion，所以复杂度很高。</p><h2 id="backtracking">Backtracking</h2><figure><imgsrc="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211129144559235-1738742177.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>主要可以解决<strong>组合问题</strong>、<strong>排列问题</strong>、<strong>子集问题</strong>、<strong>字符串切割问题</strong>、<strong>棋盘问题</strong>，这些问题都可以抽象为<strong>多叉树的搜索问题</strong></p><figure><imgsrc="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211129090136628-461210128.png"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>回溯用来搜索选择性问题（a series ofchoices）的所有/部分解，每做一次选择，就递归一次，如果约束条件不满足，需要<strong>回退到上一层递归的参数状态</strong>。通常在返回上层之前，要将本层节点的状态还原。<br />通过约束条件的剪枝可以避免对整个搜索空间的穷举，从而提高效率。</p><p>三个关键点：</p><ol type="1"><li>Choice<br />明确要做的决定，<strong>每次递归代表一次决定，每次的决策结果都保存在这一层的callstack中</strong>。<br />eg.遍历二叉树时，当处在某一层的某结点时，下一次递归调用是向左还是向右。</li><li>Constraints<br />怎样剪枝，当前状态已经invalid，不必再从该状态继续搜索，直接返回。</li><li>Goal<br />找到target后，就要回溯到上一层，进行其它可能性的搜索。</li></ol><p>Pattern： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// backtracking</span></span><br><span class="line"><span class="keyword">bool</span>/<span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(configuration conf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (no more choices)  <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> (conf is goal state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (all available choices) &#123;</span><br><span class="line">        <span class="keyword">try</span> one choice c:</span><br><span class="line">        <span class="comment">// solve from here, if works out, you are done</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(conf with choice c made))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        unmake choice c;   <span class="comment">// explore other solutions</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// tried all choices, no soln found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>几个例子：</p><ol type="1"><li>N-Queens<br />对照N皇后问题，明确三个关键点：<br />1）对于每一列，要做的决定是将Q放在哪一行，每次递归都会进入下一列的决策；<br />2）约束条件：不能出现在同一行、同一列、同一斜线；<br />3）目标：当在最后一列成功放置Q后，就可以回溯到上一层去探索其它解。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(grid&lt;<span class="keyword">bool</span>&gt;&amp; board, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (col &gt;= board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rowToTry = <span class="number">0</span>; rowToTry &lt; board.<span class="built_in">size</span>(); ++rowToTry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSafe</span>(board, rowToTry, col)) &#123;</span><br><span class="line">            <span class="built_in">placeQueen</span>(board, rowToTry, col);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(board, col + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">removeQueen</span>(board, rowToTry, col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>Sudoku<br /><img src="https://img-blog.csdnimg.cn/20200704162901848.png"alt="在这里插入图片描述" /><br />将1-9放入格子，要求每行、每列、每块不能有重复数字。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(Grid&lt;<span class="keyword">int</span>&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the gird to check, we should check all the grids</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all grids assigned successfully</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">findUnassigned</span>(grid, row, col)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; ++num) &#123; <span class="comment">// options are 1-9</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">noConflict</span>(grid, row, col, num)) &#123;</span><br><span class="line">            <span class="built_in">grid</span>(row, col) = num; <span class="comment">// try assign</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(grid)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">grid</span>(row, col) = UNASSIGNED; <span class="comment">// undo and try again</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明白了回溯的基本流程，那么一个问题呼之欲出，什么时候需要回溯，什么时候不需要？</p><p>之所以需要回溯，是因为来到<spanclass="math inline">\((x,y)\)</span>这个状态后，我们不清楚是否要选择该状态，因此先尝试去选择该状态<code>vis(x,y)=True</code>，然后继续向后搜索<code>dfs(x+i,y+j)</code>。如果发现这样的选择无法得到正确的结果，就尝试不选择该状态<code>vis(x,y)=False</code>，看看能否获得期望的结果。</p><p>从实践的角度，当某个状态可能被多条DFS共同访问时（如全排列问题），通常完成一条DFS后需要回溯。当状态只需要访问一次就可以获取最终的结果（如岛屿数量问题），那么无需回溯，这种情况下回溯通常会导致错误的重复计算。</p><h2 id="主定理">主定理</h2><p>子问题规模相等 <span class="math display">\[T(N)=aT(\frac{N}{b})+O(N^d)\]</span></p><ul><li><span class="math inline">\(log_ba&lt;d\rightarrowO(N^d)\)</span></li><li><span class="math inline">\(log_ba&gt;d\rightarrowO(N^{log_ba})\)</span></li><li><span class="math inline">\(log_ba=d\rightarrowO(N^dlogN)\)</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>球员归化</title>
      <link href="/posts/chinese-foreign-players/"/>
      <url>/posts/chinese-foreign-players/</url>
      
        <content type="html"><![CDATA[<h2 id="历史时刻">历史时刻？</h2><p>2019年9月10日，2022年卡塔尔世界杯亚洲区预选赛，马尔代夫对阵中国。归化球员Elkeson身披11号球衣，代表中国男足首发出战。不久之前，Elkeson加入中国国籍，甚至连自己中文名字（艾克森）还不会写、国歌都不会唱，却成为了国家队的一员。</p><h2 id="福还是祸">福还是祸？</h2><p>我个人一直是坚定地反对无血缘归化，可是舆论好像支持的比较多。回顾历史，国足只在2002年打进过一次世界杯。受到零几年黑球、假球的影响，我们的足球人才出现了严重的断档，自然国家队的水平也长期徘徊在亚洲二三流。长期无缘世界杯让我们的球迷焦躁不安，更是由于老大喜欢足球，并且多次在公开场合表示要把中国足球搞上去，中国足协出了各种各样的奇葩政策：</p><ol type="1"><li>高薪聘请国外教练：里皮、阿里汉、卡马乔，解约卡马乔时支付5000万违约金；</li><li>在中超联赛施行U23政策，俱乐部也是上有政策、下有对策：U23球员的出场时间非常可怜，只是满足足协最低要求而已；</li></ol><p>可惜，就是不把主要精力放在青训上，总想着捷径：当然，这也是官僚一贯的急功近利作风，前人栽树后人乘凉的事想都不要想。中超联赛踢得如火如荼，可是没有跑道的专业球场屈指可数；外援垄断了射手榜和关键位置，国内球员只是陪跑；如果静下心来踏踏实实做好青训，规范我们的联赛，开展俱乐部各级梯队的比赛，做好校园足球的普及和推广，就像姚明对中国篮球的改革一样，那么我们10年后一定可以打进世界杯，可惜领导从来不会有这样的耐心。其实我们的目标只是打进世界杯而已，从来就不是提高中国足球的水平。围绕这个任务，所有的一切也都得到了非常合理的解释：在恒大建立国家集训队、无血缘归化......有人说归化可以带动中国足球水平的提高，让越来越多的孩子走上职业联赛，并且归化和青训可以同时进行。。。就足协那个尿性，一旦从归化中尝到了甜头，还有谁愿意冒着风险、付出成本去做青训？我对Elkeson并不反感，从2013年亚冠就开始看他的比赛。在俱乐部层面，他给中国足球带来了亚冠冠军；平时生活中对中国文化也很尊重；加入中国国籍可能有对于这个国家的热爱，但是背后是8~9位数的薪资以及复杂的利益纠缠，否则怎么会那么轻易主动放弃自己祖国国籍？Elkeson只是第一个，后面可能还有高拉特、费尔南多、阿洛伊西奥......这就是恒大许老板所谓的“全华班”？这样即使打进世界杯，看着巴西人组成的前锋线，球迷心里真的还会有那份民族自豪感吗？另外，归化对于联赛的公平运作也是毁灭性的打击。其他俱乐部的外援都去恒大，足协钦定的政策谁敢不从？喊了这么多年联赛职业化，可惜中超的职业化只是政治因素下的可笑的玩物！曾经，国家队的每场比赛我都不会错过：赢了我激动地欢呼，输了我会难过好几天。见过它的高光，也陪伴它走过低谷。这次我是真的失望到无法接受：从今天开始，我不会再关注中国足球的任何消息，这潭泛着恶臭的死水已经开始恶心到我了！以后就看看梅西、阿森纳和西班牙就行了~</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Football </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高墙与鸡蛋</title>
      <link href="/posts/high-walls-and-eggs/"/>
      <url>/posts/high-walls-and-eggs/</url>
      
        <content type="html"><![CDATA[<h2 id="村上在耶路撒冷">村上在耶路撒冷</h2><p>2009年春天，村上春树获得了“耶路撒冷文学奖”。当时巴勒斯坦和以色列之间的冲突愈演愈烈，很多人都劝阻村上不要去以色列领奖，何况村上其实对公开场合发表演讲、接受采访这些事是比较排斥的。他最终还是决定出席（原因他在演讲时解释了），并且发表了极为精彩的演说--“高墙与鸡蛋”。全文还是不太好找，不过最终在林少华先生的博客中找到了中文版（林少华先生是村上小说很重要的翻译家）：<ahref="http://blog.sina.com.cn/s/blog_48f36ce00100e3qd.html">原文链接</a></p><blockquote><p>我作为一个小说家，换句话说，作为以巧妙说谎为职业的人来到这里、来到耶路撒冷市。</p><p>当然，说谎的不都是小说家。诸位知道，政治家屡屡说谎，外交官和军人说谎，二手车推销员、肉铺和建筑业者也说谎。但小说家说谎和他们说谎的不同之处在于：小说家说谎不受道义上的谴责。莫如说谎说得越大越高明，小说家越能得到人们的赞赏和好评。为什么呢？</p><p>这是因为，小说家能够通过巧妙说谎、通过栩栩如生的虚构而将真相拽到另一场所投以另一光照。以其固有的形式捕捉真相并予以准确描述在许多情况下是不可能的。惟其如此，我们才要把真相引诱出来移去虚构地带，通过将其置换为虚构形式来抓住真相的尾巴。但为此必须首先在自己心底明确真相的所在，这是巧妙说谎所需要的重要资格。</p><p>可是今天我不准备说谎，打算尽可能说实话。一年之中我也有几天不说谎，今天恰好是其中的一天。</p><p>实话实说好了。关于此次来以色列接受耶路撒冷文学奖，不少人劝我最好拒绝。甚至警告说如果前来，将开展不买我的书的运动。无须说，理由在于加沙地区的激战。迄今为止，已不止一千人在被封锁的城区丧生，据联合国报告，大多数是儿童、老人等手无寸铁的平民。</p><p>接到获奖通知以来，我本人也一再自问：这种时候来以色列接受文学奖果真是妥当的行为吗？不会给人以支持作为纷争当事者一方、拥有占绝对优势的军事力量并积极行使的国家及其方针的印象吗？那当然不是我所希望的。我不认可任何战争，不支持任何国家。同时，自不待言，我的书在书店被人拒买也不是我所希求的。</p><p>然而，经过深思熟虑，我重新坚定了来这里的决心。原因之一，就在于有那么多人劝我最好别来。或许我有一种大部分小说家都有的“犟脾气”--别人叫我“别去那里”、“别干那个”、尤其那样警告我的时候，我就偏偏想去或想干，此乃小说家的nature（天性）。为什么呢？因为小说家属于这样一种人：无论刮怎样的逆风，也只能相信自己实际目睹、自己实际手摸的东西。</p><p>正因如此，我才出现在这里。较之不来，选择了来；较之什么也不看，选择了看点儿什么；较之什么也不说，选择了向诸位说点儿什么。</p><p>有一句话（message）请允许我说出来，一句个人性质的话。这句话在我写小说时总在我脑袋里挥之不去。它并非写在纸上贴在墙壁，而是刻于我的脑壁。那是这样一句话：</p><p><strong>假如这里有坚固的高墙和撞墙破碎的鸡蛋，我总是站在鸡蛋一边。</strong></p><p>是的，无论高墙多么正确和鸡蛋多么错误，我也还是站在鸡蛋一边。正确不正确是由别人决定的，或是由时间和历史决定的。假如小说家站在高墙一边写作--不管出于何种理由--那个作家又有多大价值呢？</p><p>那么，这一隐喻到底意味什么呢？在某种情况下它是简单明了的。轰炸机、坦克、火箭、白燐弹、机关枪是坚硬的高墙。被其摧毁、烧毁、击穿的非武装平民是鸡蛋。这是这一隐喻的一个含义。</p><p>但不仅仅是这个，还有更深的含义。请这样设想好了：我们每一个人都或多或少分别是一个鸡蛋，是具有无可替代的灵魂和包拢它的脆弱外壳的鸡蛋。我是，你们也是。再假如我们或多或少面对之于每一个人的坚硬的高墙。高墙有个名称，叫作体制（System）。体制本应是保护我们的，而它有时候却自行其是地杀害我们和让我们杀人：<strong>冷酷</strong>地、高效地、而且系统性地（Systematically）。</p><p>我写小说的理由，归根结底只有一个，那就是为了让个人灵魂的尊严浮现出来，将光线投在上面。经常投以光线，敲响警钟，以免我们的灵魂被体制纠缠和贬损。这正是故事的职责，对此我深信不疑。不断试图通过写生与死的故事、写爱的故事来让人哭泣、让人惧怕、让人欢笑，以此证明每个灵魂的无可替代性--这就是小说家的工作。我们为此而日复一日地认真编造故事。</p><p>我的父亲去年夏天去世了，活了九十岁。他是个退休教师，也是个兼职佛教僧侣。在研究生院就读期间被征召入伍，参加了中国大陆的战斗。我小的时候，他每天早上都在饭前向佛坛献上长长的深深的祈祷。一次我问父亲为什么祈祷，他回答为了在战场死去的人，为了在那里--无论友方敌方--失去性命的人。每次看见父亲祈祷的身姿，我都觉得那里似乎漂浮着死亡的阴影。</p><p>父亲去世了，其记忆--还没等我搞清是怎样的记忆--也彻底消失了。但是，那里漂浮的死亡气息仍留在我的记忆中。那是我从父亲身上继承的少数然而宝贵的事项之一。</p><p>我在这里想向诸位传达的只有一点：我们都是超越国籍、种族和宗教的一个一个的人，都是面对体制这堵高墙的一个一个的蛋。看上去我们毫无获胜的希望。墙是那么高那么硬，那么冰冷。假如我们有类似获胜希望那样的东西，那只能来自我们相信自己和他人的灵魂的无可替代性并将其温煦聚拢在一起。</p><p>请这样想想看。我们每一个人都有可以拿在手中的活的灵魂，体制则没有。不能让体制利用我们，不能让体制自行其是。不是体制创造了我们，而是我们创造了体制。</p><p>我想对诸位说的仅此一点。</p><p>荣获耶路撒冷奖，我很感谢。感谢世界很多地方都有看我书的人。我要向耶路撒冷的每一位读者致以谢意。毕竟是因了你们的力量我才出现在这里的。但愿我们能够共同拥有什么--非常有意义的什么。我很高兴得以来此向诸位讲话。</p></blockquote><p>村上的小说一直强调个人的自由，他也一直希望每个个体都能拥有独特的生活方式、活出自我，而不是被体制化（Institutionalization）。其实发表演讲时，如果不是因为战争的背景以及村上的解释，那么我对于<strong>永远站在鸡蛋一边</strong>是无法苟同的：试想如果鸡蛋（弱势者）的行为的确非常过分，那么如此绝对地站队是不是有些混淆是非呢？不过村上的浅层隐喻是在讽刺战争对平民的伤害，更深层次的是对体制的搏斗以及自由的向往，这些观点足以让我信服。</p><h2 id="hard-boiled">Hard-Boiled</h2><p>这篇演说比较有趣的地方在于：村上这个系统建构狂魔为读者解释了他的一本小说的名字（这个我也是从杨照老师那里了解的）：《世界末日与冷酷仙境》。这本小说本来是直接用英语命名，把英语写成日语外来语起名。原来叫做Hard-BoiledWonderland and the End of the World，Wonderland比较明显出自于Alice'sAdventures inWonderland（爱丽丝梦游仙境），但是Hard-Boiled只看字面意思的话，很难理解为什么会翻译成冷酷，应该是沸腾加热这种意思才对啊~Hard-Boiled一般就只用在美国人吃早餐时候：服务员会问你要的eggs是要soft-boiledor hard-boiled？全熟的蛋也不能叫做冷酷吧？美国在上世纪有一类流行小说叫做Hard-Boiled DetectiveStory，村上一直受西方文学影响，而且很喜欢这种类型的小说。所谓硬汉侦探小说，其实并不是大家想象中的那种超级英雄：无坚不摧、拯救世界。这种Hard-Boiled“硬汉”其实只是看起来很酷，戴个墨镜，实际上只是在逞强而已，他们是在社会上摸爬滚打多年、不断受挫，内心很柔弱、很受伤的一群人，成为侦探是因为他们和罪犯有着相似的生活经历，所以了解他们。这种类型的硬汉虽然不会轻易认输，但是其实也是在苦苦支撑而已，就像是早餐店里那种Hard-Boiledeggs，以为自己成熟了，但是如果这种蛋碰到墙上，那么破碎的必然是蛋，而高墙不会有任何损失。即使这样，村上也还是会<strong>永远站在鸡蛋一边，无论高墙多么正确和鸡蛋多么错误。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
            <tag> Haruki Murakami </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻唱与抄袭</title>
      <link href="/posts/cover-and-plagiarism/"/>
      <url>/posts/cover-and-plagiarism/</url>
      
        <content type="html"><![CDATA[<h2 id="缘由">缘由</h2><p>曾经，《老男孩》风靡一时，无数人热泪盈眶，我也感动得一塌糊涂。筷子兄弟也凭借此歌迅速走红，获得无数粉丝青睐。我起初对日本音乐了解甚少，平时也不太接触。偶然听到山口百惠、中森明菜等一些昭和时代歌姬的演唱之后，才逐渐开始欣赏日本音乐。毫不夸张地说，日本音乐在亚洲绝对顶级水准。这也造就了一大批靠翻唱、抄袭日本曲目成名的歌手，以及一些我们曾经为之泪流满面的歌曲。当然，拿到原创的允许进行翻唱无可厚非，但是没有版权、重新填词并公开商演又是一种怎样的行为呢？</p><h2 id="ありがとう">ありがとう</h2><p>大桥卓弥的《ありがとう》（谢谢），就是《老男孩》的原曲。 <ahref="https://b23.tv/av22011510">原曲</a>关于亲情的MV非常感人。</p><p>筷子兄弟在没有授权的情况下填词发布，后来面临起诉时才购买版权。这种“先上车后补票”的行为并不少见，据说《父亲》的旋律是把福山雅治的《milktea》副歌部分和宫本笑里的《stay withme》副歌部分拼凑到一起的，不过并没有实锤。有人戏谑（ありがとう网易云热评）：“在知道老男孩是翻唱的之后，我一点也不好奇为什么筷子兄弟的曲风一下从老男孩变成了小苹果”。</p><h2 id="反思">反思</h2><p>很多网友戏称：中岛美雪养活了大半个华语音乐圈。很不幸，国内许多歌手的代表作都是翻唱美雪阿姨的：任贤齐的《伤心太平洋》、王菲的《容易受伤的女人》......刘若英的《后来》是翻唱Kiroro的《未来へ》，《很爱很爱你》也是翻唱这个组合的同一张专辑......再看最近，自称“原创歌手”的花粥代表作《盗将行》、《出山》都涉嫌抄袭； <ahref="https://b23.tv/av45107069">《出山》原曲</a> 附上<ahref="https://b23.tv/av45298740">左右声道对比</a></p><p>神曲《起风了》也是翻唱高桥优的《ヤキモチ》（吃醋），附上<ahref="https://b23.tv/av23618612/p1">MV链接</a>真的太多太多了，我曾经在贴吧看过一个统计，国内知名歌手翻唱日本歌手的歌曲一共列了好几十个页面......说这些不是为了引战，我们要正视差距，填词都很不错，优秀的作曲真的太少太少，所以周杰伦才那么难能可贵。反观日本，几乎每个歌手都是创作者，作品的旋律也非常优美，能把人深深吸引进故事里，而不是写一些口水歌。唱功再好，最多就是个singer，成为不了musician~</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Norwegian Wood</title>
      <link href="/posts/norwegian-wood/"/>
      <url>/posts/norwegian-wood/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>《挪威的森林》是村上春树很有名的一部小说，但我想大多数人阅读的时候都只是把书名当作一个符号，而不是作为故事去追究。我国台湾知名文学评论家杨照先生说过：村上的书里有太多太多典故，如果你只是把这些典故当作符号看待，那么会少很多阅读的乐趣。你探寻这些典故越深，就越能体会村上想要表达的意思。那么《挪威的森林》是怎么来的？</p><h2 id="the-beatles">the Beatles</h2><p>了解村上的人都知道：他生命中最重要的几件事就是写作、听音乐、长跑和翻译。Norwegian Wood(This Bird HasFlown)是Beatles在1965年发行的歌，这首歌的歌词非常简单：</p><blockquote><p>I once had a girl Or should I say she once had me She showed me herroom Isn't good Norwegian wood?</p></blockquote><blockquote><p>She asked me to stay And she told me to sit anywhere So I lookedaround And I noticed there wasn't a chair I sat on a rug biding mytime</p></blockquote><blockquote><p>Drinking her wine We talked until two and then she said "It's timefor bed" She told me she worked In the morning and started to laugh Itold her I didn't And crawled off to sleep in the bath</p></blockquote><blockquote><p>And when I awoke I was alone This bird had flown So I lit a fireIsn't it good Norwegian wood?</p></blockquote><p>歌词的寓意很明显：这个女孩喜欢男孩，想和他滚床单，男孩激动地陪她喝酒聊天。等他早上醒来的时候，发现女孩已经走了，本来在他手里的鸟飞走了，好似喝醉后的一场梦，转瞬无影踪。可是Norwegian wood为什么莫名其妙出现在这里？</p><h2 id="故事">故事</h2><p>这首歌基本上是John Lennon完成的，歌词原本是<strong>Isn't good?Knowing she would</strong>创作完成后，唱片公司觉得歌词的意味太明显，在60年代这样的歌词有些太过直白。唱片公司要求John修改歌词，调皮的John就利用谐音把<strong>Knowing shewould</strong>改成了<strong>Norwegian wood</strong>改完之后，起初录音时候他还是唱<strong>Knowing shewould</strong>，于是唱片公司下了最后通牒：如果还这样唱，那这首歌不能收录。就这样，John Lennon唱出了<strong>Norwegianwood</strong>，村上听着<strong>Norwegianwood</strong>写出了<strong>Norwegian wood</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
            <tag> Haruki Murakami </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog Customization</title>
      <link href="/posts/blog-customization/"/>
      <url>/posts/blog-customization/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>从大二开始写博客，主要为了记录自己学习过程中的问题。尝试使用过CSDN、博客园等公共服务，也用Githubpages搭建过自己的博客，但效果都不令人满意。CSDN广告太多，界面乌烟瘴气，而且很多博客内容都是抄袭而来；博客园模板比较单一，而且对Markdown的支持不友好；Githubpages很自由，但是搭建以及发布文章比较麻烦。<ahref="https://eimadrigal.blogspot.com/">blogspot</a>对国内用户很不友好。</p><p>后来在网上浏览别人的博客园时，才发现原来是可以自己定制博客的，遂写此文。</p><h2 id="皮肤">皮肤</h2><p>皮肤也就是博客的背景，博客园提供了一些模板，可以在管理-&gt;设置-&gt;博客皮肤中选择。<br />如果你对于CSS比较熟悉，那完全可以自己写一个网页的样式，然后勾选禁用模板默认CSS。<br /><imgsrc="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825184956989-1010438394.png"alt="img" /><br />如果你不熟悉Web开发，可以找一些别人写好的页面定制代码，复制到页面定制CSS代码框中。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Monokai Sublime style. Derived from Monokai by noformnocontent http://nn.mit-license.org/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">pre &#123;</span><br><span class="line">    <span class="comment">/*控制代码不换行*/</span></span><br><span class="line">    <span class="attribute">white-space</span>: pre;</span><br><span class="line">    <span class="attribute">word-wrap</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cnblogs-markdown</span> <span class="selector-class">.hljs</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1.3em</span> <span class="number">2em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#272822</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFF</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">700px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs</span>,</span><br><span class="line"><span class="selector-class">.hljs-tag</span>,</span><br><span class="line"><span class="selector-class">.hljs-subst</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f8f8f2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-strong</span>,</span><br><span class="line"><span class="selector-class">.hljs-emphasis</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#a8a8a2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-bullet</span>,</span><br><span class="line"><span class="selector-class">.hljs-quote</span>,</span><br><span class="line"><span class="selector-class">.hljs-number</span>,</span><br><span class="line"><span class="selector-class">.hljs-regexp</span>,</span><br><span class="line"><span class="selector-class">.hljs-literal</span>,</span><br><span class="line"><span class="selector-class">.hljs-link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ae81ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-code</span>,</span><br><span class="line"><span class="selector-class">.hljs-title</span>,</span><br><span class="line"><span class="selector-class">.hljs-section</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-class</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#a6e22e</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-strong</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-emphasis</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-keyword</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-tag</span>,</span><br><span class="line"><span class="selector-class">.hljs-name</span>,</span><br><span class="line"><span class="selector-class">.hljs-attr</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f92672</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-symbol</span>,</span><br><span class="line"><span class="selector-class">.hljs-attribute</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#66d9ef</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-params</span>,</span><br><span class="line"><span class="selector-class">.hljs-class</span> <span class="selector-class">.hljs-title</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f8f8f2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-string</span>,</span><br><span class="line"><span class="selector-class">.hljs-type</span>,</span><br><span class="line"><span class="selector-class">.hljs-built_in</span>,</span><br><span class="line"><span class="selector-class">.hljs-builtin-name</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-id</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-attr</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-pseudo</span>,</span><br><span class="line"><span class="selector-class">.hljs-addition</span>,</span><br><span class="line"><span class="selector-class">.hljs-variable</span>,</span><br><span class="line"><span class="selector-class">.hljs-template-variable</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#e6db74</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-comment</span>,</span><br><span class="line"><span class="selector-class">.hljs-deletion</span>,</span><br><span class="line"><span class="selector-class">.hljs-meta</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#75715e</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 黑色主题makedown代码结束 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*makedown行间代码样式 */</span></span><br><span class="line"><span class="selector-class">.cnblogs-markdown</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#c7254e</span>;</span><br><span class="line">    <span class="attribute">border</span>: none <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f9f2f4</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: sans-serif <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*引言样式*/</span></span><br><span class="line"><span class="selector-tag">blockquote</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*博客顶部容器包括标题、副标题、导航栏*/</span></span><br><span class="line"><span class="comment">/* 博客标题和副标题 */</span></span><br><span class="line"><span class="selector-id">#blogTitle</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blogTitle</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blogTitle</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*博客导航栏 */</span></span><br><span class="line"><span class="selector-id">#navList</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#navList</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.blogStats</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*sideBar博客侧边栏容器*/</span></span><br><span class="line"><span class="selector-id">#sideBar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.newsItem</span>, <span class="selector-class">.catListComment</span>, <span class="selector-class">.catListEssay</span>, <span class="selector-class">.catListView</span>, <span class="selector-class">.catListFeedback</span>,</span><br><span class="line"><span class="selector-id">#blog-calendar</span>, <span class="selector-id">#sidebar_postcategory</span>, <span class="selector-id">#sidebar_postcategory</span>, <span class="selector-id">#sidebar_postarchive</span>, <span class="selector-id">#sidebar_search</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">2px</span> <span class="number">3px</span> <span class="number">#A7A8AD</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sideBarMain</span> <span class="selector-tag">h3</span>, <span class="selector-class">.newsItem</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">0.5em</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">http://www.cnblogs.com/skins/red_autumnal_leaves/images/titlebg.png</span>) no-repeat left center <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sideBarMain</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-left-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-right-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sideBarMain</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*侧边栏公告*/</span></span><br><span class="line"><span class="selector-id">#blog-news</span> &gt; <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="comment">/*头像*/</span></span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#profile_block</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#profile_block</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*公告结束*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日历 */</span></span><br><span class="line"><span class="selector-id">#blog-calendar</span>, <span class="selector-id">#calendar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">td</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#59a020</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">table</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#59a020</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">    <span class="attribute">background</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">table</span> u &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*日历结束*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置背景色和字体大小*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*mainContent主体内容容器*/</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">95%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#mainContent</span> <span class="selector-class">.forFlow</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">310px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#mainContent</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">310px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#post_detail</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标题title样式 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#topics</span> <span class="selector-class">.postTitle</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cb_post_title_url</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: left center;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主体内容样式 */</span></span><br><span class="line"><span class="selector-class">.postBody</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="comment">/*标题h2*/</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#d6dbdf</span>8a;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> <span class="selector-tag">h4</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#topics</span> <span class="selector-class">.postDesc</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 个性签名 */</span></span><br><span class="line"><span class="selector-id">#MySignature</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">8px</span> <span class="number">1px</span> <span class="number">10px</span> <span class="number">#989898</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#FFF</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">17px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: solid <span class="number">5px</span> <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#F3F3F3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">50%</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">2.4</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">40px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#MySignature</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#4183c4</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#MySignature</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#MySignature</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关注收藏等几个按钮 */</span></span><br><span class="line"><span class="selector-id">#green_channel</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#green_channel</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>: none;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 禁用下划线 */</span></span><br><span class="line"><span class="selector-class">.postBody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-class">.postBody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>, <span class="selector-class">.postBody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上一篇下一篇 */</span></span><br><span class="line"><span class="selector-id">#post_next_prev</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#535353</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*底部隐藏作者，隐藏推荐和反对*/</span></span><br><span class="line"><span class="selector-id">#author_profile</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#div_digg</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*隐藏广告*/</span></span><br><span class="line"><span class="selector-id">#ad_t2</span>, <span class="selector-id">#cnblogs_c1</span>, <span class="selector-id">#under_post_news</span>, <span class="selector-id">#cnblogs_c2</span>, <span class="selector-id">#under_post_kb</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*评论*/</span></span><br><span class="line"><span class="comment">/*评论列表*/</span></span><br><span class="line"><span class="selector-id">#blog-comments-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.feedback_area_title</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">//www.cnblogs.com/skins/red_autumnal_leaves/images/titlebg.png</span>) no-repeat left center <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*侧边评论*/</span></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-class">.recent_comment_body</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交评论按钮 */</span></span><br><span class="line"><span class="selector-id">#btn_comment_submit</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#fd6d0d</span>d1 <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fd6d0d</span>d1 <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="标题和导航栏">标题和导航栏</h2><figure><imgsrc="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825185903232-1879765133.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>标题和子标题的修改也在管理-&gt;设置中；<br />导航栏的控件在管理-&gt;选项中勾选，这里还包含侧边栏的控件，可以根据需要自行选择。<br /><imgsrc="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825190124197-141259783.png"alt="img" /></p><h2 id="侧边栏公告">侧边栏公告</h2><figure><imgsrc="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825190343070-1772796324.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这部分的修改也在管理-&gt;设置中，不过修改前需要发邮件给博客园后台申请JS权限。<br />这里主要有3点：<br />一、动态时钟<br />这个我是copy了<ahref="https://www.cnblogs.com/jingmoxukong/p/7826982.html">详谈如何定制自己的博客园皮肤</a>；<br />二、背景音乐<br />背景音乐的添加需要进入网易云音乐网页后，找到喜欢的音乐，生成外链播放器，然后复制那段HTML代码到侧边栏公告即可。<br /><imgsrc="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825191108110-1169449336.png"alt="img" /><br />这里要注意：博客园不支持iframe插件，所以只能采用flash插件！<br />三、访客统计<br /><imgsrc="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825191224704-336517055.png"alt="img" /><br />这个功能可以去<ahref="http://www.flagcounter.com/">flagcounter</a>完成，同样复制HTML代码到侧边栏公告即可。我的博客把这个放到了页脚html代码中，所以可以看到这个在左下角显示。<br />完整的博客侧边栏公告代码，注意：其中的网易云音乐和访问人数需要自己生成外链！<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!---  自定义侧边栏  ---&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mySideBar&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p_b_follow&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;follow(&#x27;ca5022e9-4171-4a38-e168-08d4ef52ecb5&#x27;)&quot;</span>&gt;</span>+Follow Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>student@XJTU<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Email：andrew_ren@163.com<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--- 动态时钟  ---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">wmode</span>=<span class="string">&quot;transparent&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://files.cnblogs.com/files/jingmoxukong/honehone_clock_tr.swf&quot;</span> <span class="attr">quality</span>=<span class="string">&quot;high&quot;</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#FDF6E3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;240&quot;</span> <span class="attr">height</span>=<span class="string">&quot;110&quot;</span> <span class="attr">name</span>=<span class="string">&quot;honehoneclock&quot;</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">allowscriptaccess</span>=<span class="string">&quot;always&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/x-shockwave-flash&quot;</span> <span class="attr">pluginspage</span>=<span class="string">&quot;http://www.macromedia.com/go/getflashplayer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--- 网易云音乐  ---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;//music.163.com/style/swf/widget.swf?sid=26511658&amp;type=2&amp;auto=1&amp;width=320&amp;height=66&quot;</span> <span class="attr">width</span>=<span class="string">&quot;340&quot;</span> <span class="attr">height</span>=<span class="string">&quot;86&quot;</span>  <span class="attr">allowNetworking</span>=<span class="string">&quot;all&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--- 访问人数  ---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://info.flagcounter.com/myYT&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s01.flagcounter.com/count2/myYT/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_4/viewers_0/labels_1/pageviews_1/flags_0/percent_0/&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Flag Counter&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--- 导入js库  ---&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"> <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;c_n4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;860&quot;</span> <span class="attr">height</span>=<span class="string">&quot;968&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: fixed; top: 0px; left: 0px; z-index: -1; opacity: 0.5;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure> 最后点击保存即可。</p><h2 id="自适应手机屏幕">自适应手机屏幕</h2><p>博客园的模板并没有自适应手机屏幕，可以参考<ahref="https://www.cnblogs.com/lvdabao/p/5245247.html">这篇博文</a>修改CSS中的参数，就可以得到自适应移动设备的网页。</p><h2 id="reference">Reference</h2><p>当前使用的是在<ahref="https://github.com/Summertime-Wu/make_cnblogs_better">这个</a>基础上做了一些魔改。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Front-End </tag>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/design-pattern/"/>
      <url>/posts/design-pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式">单例模式</h2><p>顾名思义就是某些类全局只需要一个实例。</p><ol type="1"><li><p>饿汉模式只要系统开始运行便创建实例，不管是否需要，需要时直接调用。</p></li><li><p>懒汉模式</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 禁止外部构造、析构、拷贝、赋值</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; s);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp; s);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Singleton* instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式">简单工厂模式</h2><h2 id="reference">Reference</h2><p><ahref="https://www.zhihu.com/question/308850392/answer/1324509357">如何学习设计模式</a><br /><ahref="https://www.cnblogs.com/ccdev/archive/2012/12/19/2825355.html">线程安全的单例模式</a><br /><ahref="https://immortalqx.github.io/2022/02/04/cpp-notes-5/">C++单例</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Naïve Bayes</title>
      <link href="/posts/naive-bayes/"/>
      <url>/posts/naive-bayes/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><h2 id="details">Details</h2><h2 id="example">Example</h2><h2 id="implementation">Implementation</h2><h2 id="properties">Properties</h2><p>NBC有坚实的数学基础，稳定的分类效率，超参数少（先验），对缺失数据不敏感，算法简单。<br />如果属性较多且相关性比较大，决策树优于NBC，否则NBC性能很好。</p><p>垃圾邮件分类器<br />事先做一个vocabulary存放常用的单词，如果邮件中包含vocabulary的第j个单词，特征向量中<spanclass="math inline">\(x_j=1\)</span><br />朴素贝叶斯假设给定标签前提下各个属性是独立的（条件独立）： <spanclass="math inline">\(P(x_1,...,x_d|y)=P(x_1|y)P(x_2|y,x_1)...P(x_d|y,x_1,...,x_{d-1})=P(x_1|y)P(x_2|y)...P(x_d|y)\)</span><br /><span class="math inline">\(P(x_2|y,x_1)\)</span>表示在<spanclass="math inline">\((y,x_1)\)</span>的条件下<spanclass="math inline">\(x_2\)</span>发生的概率<br /><spanclass="math inline">\(P(junk|D)=\frac{P(junk)P(D|junk)}{P(D)},P(normal|D)=\frac{P(normal)P(D|normal)}{P(D)}\)</span><br />P(junk)/P(normal)根据邮件库的比例即可<br />P(D|junk)=P(word1,word2,...,wordn|junk)，联合概率分布的数据是稀疏的，在垃圾邮件集合中出现与当前邮件相同的邮件概率。<br />P(word1|junk)P(word2|word1,junk)P(word3|word2,word1,junk)...<br />如果条件独立假设成立，<br />P(word1|junk)P(word2|junk)P(word3|junk)...只要统计垃圾邮件中每个单词的频率</p><p>拼写纠正<br />max P(猜测用户希望输入的单词|实际输入单词) <spanclass="math inline">\(P(h_1|D),P(h_2|D)\)</span><br /><span class="math inline">\(P(h|D)\propto P(h)P(D|h)\)</span><br />对给定的观测数据，一个猜测的好坏正比于先验和这个猜测生成观测数据的可能性大小（似然）</p><p>假设实际输入D=thew,h1=the,h2=thaw<br /><spanclass="math inline">\(P(h_1|D)=\)</span>the本身在词典中的出现概率及输入the前提下输thew的可能</p><p>ID3（Iterative Dichotomiser 3）迭代二叉树3代，启发式算法<br />以信息增益做属性选择，选择分裂后信息增益最大的属性进行分裂</p><ol type="1"><li>top-down贪心遍历可能的决策树空间</li><li>核心问题在于如何选择划分属性</li><li>按照信息增益选择分类能力最好的属性</li><li>属性的每个值产生一个分支，将训练数据放在合适的分支，不回溯考虑之前的选择</li></ol><p>都知道熵用来衡量随机变量的不确定性，在这里就是刻画数据集的不纯度<br />条件熵是指在某个条件下，随机变量的不确定性<br />信息增益即熵-条件熵，即某条件下信息不确定性减少的程度<br />举例来看：明天下雨的熵为2，阴天条件下下雨的熵是0.01（即阴天下雨的可能性很大，所以不确定性很小），信息增益=2-0.01=1.99，获知阴天后，下雨的不确定性减少了很多，信息增益很大，所以阴天对下雨这一推断很重要，意味着这个特征很关键。</p><p>IG衡量给定属性区分训练样例的能力<br /><spanclass="math inline">\(Entropy(S)=\sum_{i=1}^{c}-p_ilog_2p_i\)</span>，c表示该属性有c个取值，Pi表示子集中样例占总数的比例。介于[0,1]之间，所有样例属于1类，最纯，熵为0；平分熵最大为1</p><p>一个属性的IG意味着用该属性分割样例导致的熵减的期望，<br /><spanclass="math inline">\(IG(S,A)=E(S)-\sum_{i=1}^{c}\frac{|S_i|}{|S|}E(S_i)\)</span></p><p>C4.5用信息增益率作为属性选择的依据，构造过程中会进行剪枝（不考虑只有几个元素的结点，避免过拟合）<br />率即用相对性衡量（10经过10s到20，1经过1s到2，虽然前者的增益大，但如果用速度增加率即加速度衡量是一样的）</p><p>可以处理非离散数据和不完整数据</p><p>当前数据集S，当前属性A有c个取值，S需要被分割为c个子集 <spanclass="math inline">\(GainRatio(S,A)=\frac{IG(S,A)}{SplitInfo(S,A)}\)</span><spanclass="math inline">\(SplitInfo(S,A)=-\sum_{i=1}^{c}\frac{|S_i|}{|S|}log_2\frac{|S_i|}{|S|}\)</span><br />如果A能完全分割，那么splitinfo=0；如果对半分，那么=1，即splitinfo阻碍选择值均匀分布的属性<br />如果splitinfo=0，可以先计算每个属性的信息增益，选择增益&gt;平均值的属性再去应用增益比率，因为如果splitinfo=0，即A能完全分割，意味着信息增益=0，不可能&gt;平均值</p><p>实际中决策树的过拟合是比较严重的，C4.5克服了ID3用IG选择属性时倾向选择取值多的属性的不足。</p><p>马尔可夫随机过程：<br />s1：名词<br />s2：动词<br />s3：形容词<br />转移矩阵A=0.3 0.5 0.2;0.5 0.3 0.2;0.4 0.20.4即A11表示s1后面跟着s1的概率</p><p>若某段话第一个词为名词s1，那么该句子是“名动形名”的概率是多少？<br /><spanclass="math inline">\(P(s1,s2,s3,s1|model)=P(s1)P(s2|s1)P(s3|s2)P(s1|s3)=1*A12*A23*A31=0.004\)</span>？？？马尔科夫链：转移弧上有概率的非确定有限状态自动机，圈代表状态，每个结点的出度加起来是1<br />隐马尔可夫模型HMM：状态转换是不可观察的</p><p>EM（expectation maximization）<br />假设数据点是围绕k个核心点的k个正态分布源产生，目标是根据已知点推断正态分布的核心及参数，这也是一个贝叶斯问题</p><p>矛盾之处在于：蛋与鸡的问题<br />只有已知哪些点属于同一个圈，才能预测参数<br />只有参数靠谱，才能知道哪些点属于哪个圈</p><p>解这种问题，一般要先随机给蛋或鸡，随便猜一个参数，计算每个点属于哪个圈，接着重新评估参数，直至最后参数基本不变，有点kmeans那味。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week7 Neural Networks Learning</title>
      <link href="/posts/Neural-Networks-Learning/"/>
      <url>/posts/Neural-Networks-Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="一cost-function-and-backpropagation">一、Cost Function andBackpropagation</h2><p>神经网络的损失函数： <span class="math display">\[J(\Theta) = -\frac{1}{m} \sum_{i=1}^m \sum_{k=1}^K \left[y^{(i)}_k \log ((h_\Theta(x^{(i)}))_k) + (1 - y^{(i)}_k)\log (1 - (h_\Theta(x^{(i)}))_k)\right] +\frac{\lambda}{2m}\sum_{l=1}^{L-1} \sum_{i=1}^{s_l} \sum_{j=1}^{s_{l+1}}( \Theta_{j,i}^{(l)})^2\]</span><br /><img src="https://img-blog.csdnimg.cn/20190520213954195.png"alt="在这里插入图片描述" /><br />这个cost function是在logisticregression基础上演变而来，只是神经网络有很多输出结点，而logisticregression只有一个输出结点，所以这个costfunction只是把所有的K个输出结点的损失函数进行累加。</p><p>得到cost function后，为了寻找使得<spanclass="math inline">\(J(\theta)\)</span>最小的那组参数<spanclass="math inline">\(\theta\)</span>，我们需要知道<spanclass="math inline">\(J(\theta)\)</span>关于每个<spanclass="math inline">\(\theta\)</span>的偏导数，而后向传播算法可以帮助我们计算偏导数：<br /><imgsrc="https://img-blog.csdnimg.cn/20190520215248992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br />对于每个训练样本，先利用forward propagation计算每一层的<spanclass="math inline">\(a\)</span>：<br /><imgsrc="https://img-blog.csdnimg.cn/20190520215514406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br />接着利用样本真实标签<spanclass="math inline">\(y^{(t)}\)</span>计算最后一层的误差值；</p><p>之后从右向左计算每一层（输入层除外）的误差：<br /><img src="https://img-blog.csdnimg.cn/20190520215848578.png"alt="在这里插入图片描述" /><br />这样每个样本一次正向、一次反向来更新误差矩阵：<br /><img src="https://img-blog.csdnimg.cn/20190520220141936.png"alt="在这里插入图片描述" /><br />向量化表示：<br /><img src="https://img-blog.csdnimg.cn/2019052022020666.png"alt="在这里插入图片描述" /><br />最后，就可以得到偏导数：<br /><img src="https://img-blog.csdnimg.cn/20190520220255255.png"alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20190520220307411.png"alt="在这里插入图片描述" /></p><h2 id="二backpropagation-in-pratice">二、Backpropagation inPratice</h2><p>为了使用<code>fminunc</code>等高级的优化方法来求得costfunction的最小值，所以将<spanclass="math inline">\(\theta\)</span>这个矩阵展成向量传入<code>fminunc</code>，完成后可以通过<code>reshape</code>从向量中提取<spanclass="math inline">\(\theta^{(1)}、\theta^{(2)}\)</span>等：<br /><imgsrc="https://img-blog.csdnimg.cn/20190521193802355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /></p><p>为了确保我们使用Backpropagation求得的偏导数的正确性，可以使用GradientChecking（<strong>很慢</strong>）来检验：<br />根据偏导数定义： <spanclass="math display">\[\dfrac{\partial}{\partial\Theta_j}J(\Theta)\approx \dfrac{J(\Theta_1, \dots, \Theta_j + \epsilon, \dots, \Theta_n)- J(\Theta_1, \dots, \Theta_j - \epsilon, \dots,\Theta_n)}{2\epsilon}\]</span> <spanclass="math display">\[一般\epsilon=10^{-4}\]</span>通过将这种方式计算的偏导数与之前Backpropagation求得的偏导数比较，即可得知Backpropagation的正确性。</p><p>之前在Linear Regression和LogisticRegression，我们可以用全0来初始化<spanclass="math inline">\(\theta\)</span>，但在神经网络中，这样做会有问题，所以采用<strong>随机初始化</strong>：<br /><imgsrc="https://img-blog.csdnimg.cn/20190521195045220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br />最后，从整体捋一遍流程：<br />1、选择网络结构： <imgsrc="https://img-blog.csdnimg.cn/20190521195351245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br />2、训练神经网络：</p><p>对每一个训练样本：<br /><imgsrc="https://img-blog.csdnimg.cn/20190521195432613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multilayer Perceptron</title>
      <link href="/posts/multilayer-perceptron/"/>
      <url>/posts/multilayer-perceptron/</url>
      
        <content type="html"><![CDATA[<h2 id="non-linear-hypotheses">Non-linear Hypotheses</h2><p>线性回归和逻辑回归在特征很多时，计算量会很大。<br />一个简单的三层神经网络模型： <span class="math display">\[a_i^{(j)} =\text{&quot;activation&quot; of unit $i$ in layer $j$}\]</span><spanclass="math display">\[\Theta^{(j)} = \text{matrix of weightscontrolling function mapping from layer $j$ to layer $j+1$}\]</span><img src="https://img-blog.csdnimg.cn/20190519144739691.png"alt="在这里插入图片描述" /><br />其中：<span class="math display">\[a_1^{(2)} = g(\Theta_{10}^{(1)}x_0 +\Theta_{11}^{(1)}x_1 + \Theta_{12}^{(1)}x_2 +\Theta_{13}^{(1)}x_3)\]</span><span class="math display">\[a_2^{(2)} =g(\Theta_{20}^{(1)}x_0 + \Theta_{21}^{(1)}x_1 + \Theta_{22}^{(1)}x_2 +\Theta_{23}^{(1)}x_3)\]</span><span class="math display">\[a_3^{(2)} =g(\Theta_{30}^{(1)}x_0 + \Theta_{31}^{(1)}x_1 + \Theta_{32}^{(1)}x_2 +\Theta_{33}^{(1)}x_3)\]</span><span class="math display">\[h_\Theta(x) =a_1^{(3)} = g(\Theta_{10}^{(2)}a_0^{(2)} + \Theta_{11}^{(2)}a_1^{(2)} +\Theta_{12}^{(2)}a_2^{(2)} + \Theta_{13}^{(2)}a_3^{(2)})\]</span></p><h2 id="vectorized-implementation">vectorized implementation</h2><p>将上面公式中函数<span class="math inline">\(g\)</span>中的东西用<spanclass="math inline">\(z\)</span>代替： <spanclass="math display">\[a_1^{(2)} = g(z_1^{(2)})\]</span><spanclass="math display">\[a_2^{(2)} = g(z_2^{(2)})\]</span><spanclass="math display">\[a_3^{(2)} = g(z_3^{(2)})\]</span> 令<spanclass="math inline">\(x=a^{(1)}\)</span>： <spanclass="math display">\[z^{(j)} = \Theta^{(j-1)}a^{(j-1)}\]</span> 得到：<span class="math display">\[\begin{aligned}z^{(j)} = \begin{bmatrix}z_1^{(j)} \\ z_2^{(j)} \\ \cdots\\z_n^{(j)}\end{bmatrix}\end{aligned}\]</span></p><p>这块的记号比较多，用例子梳理下：<br />实现一个逻辑与的神经网络：<br /><img src="https://img-blog.csdnimg.cn/20190321105245428.png"alt="在这里插入图片描述" /><br />那么：<br /><img src="https://img-blog.csdnimg.cn/20190321105438230.png"alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20190321105453184.png"alt="在这里插入图片描述" /><br />所以有：<br /><img src="https://img-blog.csdnimg.cn/20190321105628787.png"alt="在这里插入图片描述" /><br />再来一个多层的，实现XNOR功能（两输入都为0或都为1，输出才为1）：<br /><img src="https://img-blog.csdnimg.cn/20190321110644318.png"alt="在这里插入图片描述" /><br />基本的神经元：</p><ul><li>逻辑与<br /><img src="https://img-blog.csdnimg.cn/2019032111133091.png"alt="在这里插入图片描述" /></li><li>逻辑或<br /><img src="https://img-blog.csdnimg.cn/20190321111355954.png"alt="在这里插入图片描述" /></li><li>逻辑非<br /><img src="https://img-blog.csdnimg.cn/20190321111411429.png"alt="在这里插入图片描述" /><br />先构造一个表示后半部分的神经元：<imgsrc="https://img-blog.csdnimg.cn/20190321111519333.png"alt="在这里插入图片描述" /><br />这样的：<br /><img src="https://img-blog.csdnimg.cn/20190321111806888.png"alt="在这里插入图片描述" /><br />接着将前半部分组合起来：<br /><img src="https://img-blog.csdnimg.cn/20190321112023420.png"alt="在这里插入图片描述" /></li></ul><h2 id="multiclass-classification">Multiclass Classification</h2><figure><img src="https://img-blog.csdnimg.cn/20190321165848893.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h2 id="motivation">Motivation</h2><h2 id="implementation">Implementation</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> FashionMNIST</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>():</span></span><br><span class="line">    <span class="comment"># My data is in ../data/FashionMNIST/raw &amp; ../data/FashionMNIST/processed</span></span><br><span class="line">    train_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    test_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    train_iter = DataLoader(train_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    test_iter = DataLoader(test_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> train_iter, test_iter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">W1 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (num_inputs, num_hiddens)), dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">b1 = torch.zeros(num_hiddens, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">W2 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (num_hiddens, num_outputs)), dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">b2 = torch.zeros(num_outputs, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># W1 = nn.Parameter(torch.randn(num_inputs, num_hiddens, requires_grad=True) * 0.01)</span></span><br><span class="line"><span class="comment"># b1 = nn.Parameter(torch.zeros(num_hiddens, requires_grad=True))</span></span><br><span class="line"><span class="comment"># W2 = nn.Parameter(torch.randn(num_hiddens, num_outputs, requires_grad=True) * 0.01)</span></span><br><span class="line"><span class="comment"># b2 = nn.Parameter(torch.zeros(num_outputs, requires_grad=True))</span></span><br><span class="line">params = [W1, b1, W2, b2]</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">    param.requires_grad_(requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="keyword">return</span> torch.<span class="built_in">max</span>(<span class="built_in">input</span>=X, other=torch.zeros(X.shape))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">X</span>):</span></span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>(<span class="params">X</span>):</span></span><br><span class="line">    X = X.reshape((-<span class="number">1</span>, num_inputs))</span><br><span class="line">    H = relu(torch.matmul(X, W1) + b1)</span><br><span class="line">    output = torch.matmul(H, W2) + b2</span><br><span class="line">    <span class="keyword">return</span> softmax(output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span>(<span class="params">y_predict, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> -torch.log(y_predict[<span class="built_in">range</span>(<span class="built_in">len</span>(y_predict)), y])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sgd</span>(<span class="params">params, lr, batch_size</span>):</span></span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.data -= lr * param.grad / batch_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy</span>(<span class="params">net, data_iter</span>):</span></span><br><span class="line">    acc_sum, n = <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        acc_sum += (net(X).argmax(dim=<span class="number">1</span>) == y).<span class="built_in">float</span>().<span class="built_in">sum</span>().item()</span><br><span class="line">        n += y.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> acc_sum / n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, batch_size=<span class="number">256</span>, lr=<span class="number">0.1</span>, params=<span class="literal">None</span>, optimizer=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_loss_sum, train_acc_sum, n = <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            y_predict = net(X)</span><br><span class="line">            l = cross_entropy(y_predict, y).<span class="built_in">sum</span>()</span><br><span class="line">            l.backward()</span><br><span class="line">            sgd(params, lr, batch_size)</span><br><span class="line"></span><br><span class="line">            W1.grad.data.zero_()</span><br><span class="line">            b1.grad.data.zero_()</span><br><span class="line">            W2.grad.data.zero_()</span><br><span class="line">            b2.grad.data.zero_()</span><br><span class="line"></span><br><span class="line">            train_loss_sum += l.item()</span><br><span class="line">            train_acc_sum += (y_predict.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().item()</span><br><span class="line">            n += y.shape[<span class="number">0</span>]</span><br><span class="line">        test_acc = evaluate_accuracy(net, test_iter)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch %d, loss %.4f, train_acc %.4f, test_acc %.4f&#x27;</span></span><br><span class="line">              % (epoch + <span class="number">1</span>, train_loss_sum / n, train_acc_sum / n, test_acc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span></span><br><span class="line">    train_iter, test_iter = load_data()</span><br><span class="line">    train(net, train_iter, test_iter, cross_entropy, <span class="number">10</span>, lr=<span class="number">0.1</span>, params=params)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.init <span class="keyword">as</span> init</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> FashionMNIST</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>():</span></span><br><span class="line">    <span class="comment"># My data is in ../data/FashionMNIST/raw &amp; ../data/FashionMNIST/processed</span></span><br><span class="line">    train_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    test_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    train_iter = DataLoader(train_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    test_iter = DataLoader(test_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> train_iter, test_iter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_inputs, num_outputs, num_hiddens</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.l1 = nn.Linear(num_inputs, num_hiddens)</span><br><span class="line">        self.relu1 = nn.ReLU()</span><br><span class="line">        self.l2 = nn.Linear(num_hiddens, num_outputs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        X = X.view(X.shape[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line">        o1 = self.relu1(self.l1(X))</span><br><span class="line">        o2 = self.l2(o1)</span><br><span class="line">        <span class="keyword">return</span> o2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_params</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> self.parameters():</span><br><span class="line">            init.normal_(param, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy</span>(<span class="params">net, data_iter</span>):</span></span><br><span class="line">    acc_sum, n = <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        acc_sum += (net(X).argmax(dim=<span class="number">1</span>) == y).<span class="built_in">float</span>().<span class="built_in">sum</span>().item()</span><br><span class="line">        n += y.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> acc_sum / n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, batch_size=<span class="number">256</span>, lr=<span class="number">0.1</span>, params=<span class="literal">None</span>, optimizer=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_loss_sum, train_acc_sum, n = <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            y_predict = net(X)</span><br><span class="line">            l = loss(y_predict, y).<span class="built_in">sum</span>()</span><br><span class="line">            l.backward()</span><br><span class="line"></span><br><span class="line">            optimizer.step()</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">            train_loss_sum += l.item()</span><br><span class="line">            train_acc_sum += (y_predict.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().item()</span><br><span class="line">            n += y.shape[<span class="number">0</span>]</span><br><span class="line">        test_acc = evaluate_accuracy(net, test_iter)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch %d, loss %.4f, train_acc %.4f, test_acc %.4f&#x27;</span></span><br><span class="line">              % (epoch + <span class="number">1</span>, train_loss_sum / n, train_acc_sum / n, test_acc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">net = Net(num_inputs, num_outputs, num_hiddens)</span><br><span class="line">net.init_params()</span><br><span class="line"></span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    train_iter, test_iter = load_data()</span><br><span class="line">    train(net, train_iter, test_iter, loss, <span class="number">10</span>, optimizer=optimizer)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advice for applying ML &amp; ML System Design</title>
      <link href="/posts/applying-ML/"/>
      <url>/posts/applying-ML/</url>
      
        <content type="html"><![CDATA[<h2 id="一the-problem-of-overfitting">一、The Problem ofOverfitting</h2><p><imgsrc="https://img-blog.csdnimg.cn/20190320163616569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br /><imgsrc="https://img-blog.csdnimg.cn/20190320164216967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br />欠拟合（high bias）：模型不能很好地适应训练集；<br />过拟合（highvariance）：模型过于强调拟合原始数据，测试时效果会比较差。<br />处理过拟合：<br />1、丢弃一些特征，包括人工丢弃和算法选择；<br />2、正则化：保留所有特征，但减小参数的值。</p><h2 id="二cost-function">二、Cost Function</h2><p>过拟合一般是由高次项引起，那么我们可以通过增加某些项的cost，来降低它们的权重。<br />在梯度下降过程中，要使损失函数变小，那么<spanclass="math inline">\(\theta\)</span>就会变得很小，所以假设函数中的<spanclass="math inline">\(\theta\)</span>就会变小，该项的权重就会降低。</p><p>如果不知道要惩罚哪些特征，可以一起惩罚（除了<spanclass="math inline">\(\theta_0\)</span>）。<br />将代价函数改为：<br /><img src="https://img-blog.csdnimg.cn/20190320165635129.png"alt="在这里插入图片描述" /><br /><span class="math inline">\(\lambda\)</span>是正则化参数。<br />如果<spanclass="math inline">\(\lambda\)</span>过大，那么所有的参数都会最小化，那么假设就会变为<spanclass="math inline">\(h_\theta(x)=\theta_0\)</span>，造成欠拟合。</p><h2 id="三regularized-linear-regression">三、Regularized LinearRegression</h2><p><spanclass="math inline">\(\theta_0\)</span>没有正则化处理，所以梯度下降要分情况：<br /><imgsrc="https://img-blog.csdnimg.cn/20190320170642494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br />化简下：<br /><img src="https://img-blog.csdnimg.cn/20190320170825316.png"alt="在这里插入图片描述" /><br />可以看到：<br />正则化后的参数更新比原来多减小了一个值。</p><p>再看线性回归的另外一个工具：常规方程。<br /><img src="https://img-blog.csdnimg.cn/20190320171502423.png"alt="在这里插入图片描述" /><br />推导过程省略......</p><h2 id="四regularized-logistic-regression">四、Regularized LogisticRegression</h2><p>对于逻辑回归的代价函数，同样增加一个正则化表达式：<br /><img src="https://img-blog.csdnimg.cn/2019032019010815.png"alt="在这里插入图片描述" /><br />梯度下降算法与线性回归相同，不过<spanclass="math inline">\(h_\theta(x)\)</span>不同。<br /><imgsrc="https://img-blog.csdnimg.cn/20190320190430424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /></p><h2 id="一evaluating-a-learning-algorithm">一、Evaluating a LearningAlgorithm</h2><p>训练后测试时如果发现模型表现很差，可以有很多种方法去更改：</p><ol type="1"><li>用更多的训练样本；</li><li>减少/增加特征数目；</li><li>尝试多项式特征；</li><li>增大/减小正则化参数<spanclass="math inline">\(\lambda\)</span>。</li></ol><p>那么该怎么去选择采用哪种方式呢？<br />一般将70%的数据作为训练集，30%的数据作为测试集。<br />先用训练集最小化<spanclass="math inline">\(J_{train}(\Theta)\)</span>，得到一组参数值<spanclass="math inline">\(\Theta\)</span>；<br />然后计算测试集误差<spanclass="math inline">\(J_{test}(\Theta)\)</span>：<br />对于<strong>线性回归</strong>：<br /><img src="https://img-blog.csdnimg.cn/20190603210422113.png"alt="在这里插入图片描述" /><br />对于<strong>逻辑回归</strong>：<br /><img src="https://img-blog.csdnimg.cn/20190603210631921.png"alt="在这里插入图片描述" /><br />测试集的平均误差（分类错误的比率）：<br /><img src="https://img-blog.csdnimg.cn/20190603210807680.png"alt="在这里插入图片描述" /><br />假设要选择用几次多项式<spanclass="math inline">\(d\)</span>去作为假设函数，那么做法就是不断尝试<spanclass="math inline">\(d\)</span>，选择一个在测试集上损失最小的<spanclass="math inline">\(d\)</span>，以此作为模型泛化能力的衡量。但是这样是有问题的，因为<spanclass="math inline">\(d\)</span>相当于是被测试集训练的，再用测试集去测试，很不公平。所以一般将数据集分为3部分：60%训练集、20%交叉验证集、20%测试集：<br /><imgsrc="https://img-blog.csdnimg.cn/20190605102227988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /></p><h2 id="二bias-vs.-variance">二、Bias vs. Variance</h2><p>看图：<br /><imgsrc="https://img-blog.csdnimg.cn/20190719151251691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="图来自知乎" /><br /><imgsrc="https://img-blog.csdnimg.cn/20190605102435642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br />正则化和Bias/Variance的关系：<br /><imgsrc="https://img-blog.csdnimg.cn/20190605102608526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br />训练集大小与Bias/Variance的关系：<br /><imgsrc="https://img-blog.csdnimg.cn/20190605102730371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /><br /><imgsrc="https://img-blog.csdnimg.cn/20190605102745765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /></p><p>## 三、Error Analysis Andrew推荐的流程：<br /><imgsrc="https://img-blog.csdnimg.cn/20190605103603490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70"alt="在这里插入图片描述" /></p><p>## 四、Handling Skewed Data如果数据集中正负类的数据规模差距过大，只用误差衡量模型是不可靠的，此时需要查准率和召回率两个指标。<br /><img src="https://img-blog.csdnimg.cn/20190605104947575.png"alt="在这里插入图片描述" /><br />如何权衡这两个指标，一般使用<spanclass="math inline">\(F1\)</span>得分： <spanclass="math display">\[F_1=2\frac{PR}{P+R}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logistic Regression</title>
      <link href="/posts/logistic-regression/"/>
      <url>/posts/logistic-regression/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>If y only takes a finite set of discrete values such as {0,1}, thenusing Linear Regression to predict a <span class="math inline">\(\haty&gt;1/\hat y&lt;0\)</span> does not make sense at all. But fortunatelywe can fix Linear Regression to produce a value between [0,1].</p><h2 id="details">Details</h2><p>We choose sigmoid/logistic function to map the value: <spanclass="math display">\[h_\theta(x)=g(\theta^Tx),g(z)=\frac{1}{1+e^{-z}}\]</span><img src="https://img-blog.csdnimg.cn/20190516212200143.png"alt="在这里插入图片描述" /> We can assume that: <spanclass="math display">\[h_\theta(x)=P(y=1|x;\theta)\\1-h_\theta(x)=P(y=0|x;\theta)\]</span> Or more compactly: <spanclass="math display">\[p(y|x;\theta)=[h_\theta(x)]^y[1-h_\theta(x)]^{1-y}\]</span>Now we will use maximum likelihood to fit parameters <spanclass="math inline">\(\theta\)</span>, assume n training examples areindependent, then the likelihood of the parameters is: <spanclass="math display">\[L(\theta)=p(\vecy|X;\theta)=\prod_{i=1}^{n}p(y^{(i)}|x^{(i)};\theta)=\prod_{i=1}^{n}[h(x^{(i)})]^{y^{(i)}}[1-h(x^{(i)})]^{1-y^{(i)}}\]</span>To make life easier, we use the log likelihood: <spanclass="math display">\[l(\theta)=log\L(\theta)=\sum_{i=1}^{n}y^{(i)}log\ h(x^{(i)})+(1-y^{(i)})log\(1-h(x^{(i)}))\]</span> Let's first take out one example <spanclass="math inline">\((x,y)\)</span> to derive the stochastic gradientascent rule: <spanclass="math display">\[\frac{\partial}{\partial\theta_j}l(\theta)=[y\frac{1}{g(\theta^Tx)}-(1-y)\frac{1}{1-g(\theta^Tx)}]\frac{\partial}{\partial\theta_j}g(\theta^Tx)\\=[y\frac{1}{g(\theta^Tx)}-(1-y)\frac{1}{1-g(\theta^Tx)}]g(\theta^Tx)(1-g(\theta^Tx))\frac{\partial}{\partial\theta_j}\theta^Tx\\=[y(1-g(\theta^Tx))-(1-y)g(\theta^Tx)]x_j=(y-h_\theta(x))x_j\]</span>Then we can update the parameters: <spanclass="math display">\[\theta_j=\theta_j+\alpha(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}\]</span></p><p>Here we use maximum likelihood to get the update rule. Generally wewould like to minimize the object function. So we can add a negativesign to the maximum likelihood's formula, it is called <strong>logisticloss</strong>. Thus there exists another way to understand it.</p><p>The loss on a single sample can be formulated as follows: <spanclass="math display">\[cost(h_{\theta}(x),y)=\left\{\begin{aligned}-log(h_{\theta}(x))\ \ \ if\ y=1\\-log(1-h_{\theta}(x))\ \ \ if\ y=0\end{aligned}\right.\]</span> If y=1 and the prediction=1, then loss=0; else if y=1 and theprediction=0, then loss=<span class="math inline">\(+\infty\)</span> isa huge penalty for the totally wrong prediction. It is the same fory=0.</p><p>We can unify the two cases together and the loss for the wholetraining data is: <span class="math display">\[cost((h_{\theta}(x),y))=-ylog(h_{\theta}(x))-(1-y)log(1-h_{\theta}(x))\\=-\frac{1}{m}\sum_{i=1}^{m}[y^{(i)}log(h_{\theta}(x^{(i)}))+(1-y^{(i)})log(1-h_{\theta}(x^{(i)}))]\]</span> Here the reason why we don't use the MSE loss such as LinearRegression is that the <span class="math inline">\(J(\theta)\)</span> isnon-convex and very hard to optimize for the global optimum.</p><p>To make life easier again, we can write the formula as the vectorizedversion: <span class="math display">\[h = g(X\theta),J(\theta) =\frac{1}{m} \cdot \left(-y^{T}\log(h)-(1-y)^{T}\log(1-h)\right)\]</span>Then our goal is to minimize <spanclass="math inline">\(J(\theta)\)</span> and get appropriate parameters<span class="math inline">\(\theta\)</span> and use <spanclass="math inline">\(h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}\)</span> toget our predictions.</p><p>Since it is a little complex to get answer analytically, so we stilluse Gradient Descent to minimize the loss numerically. The update ruleis the same as the above one: <span class="math display">\[\theta_j=\theta_j+\alpha\frac{1}{m}\sum_{i=1}^{m}(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}\]</span> Here you should notice that all <spanclass="math inline">\(\theta_j\)</span> should be updated simultaneouslywhen you program. Again the vectorized version: <spanclass="math display">\[\theta=\theta-\frac{\alpha}{m}X^T[g(X\theta)-y]\]</span>It is the same formula as the Linear Regression except that <spanclass="math inline">\(h_\theta(x)\)</span> is different.</p><h2 id="牛顿法">牛顿法</h2><p>除了用梯度上升法去最大化<spanclass="math inline">\(l(\theta)\)</span>，牛顿迭代法也能干这件事。</p><p>普通同学都是在求方程的零点<spanclass="math inline">\(f(\theta)=0\)</span>时接触到牛顿法，其更新规则为：<spanclass="math display">\[\theta=\theta-\frac{f(\theta)}{f^{&#39;}(\theta)}\]</span>这个规则可以理解为：我们一直在用一个线性函数去近似<spanclass="math inline">\(f\)</span>，因此希望下一次迭代的<spanclass="math inline">\(\theta\)</span>就是该线性函数的零点： <imgsrc="https://img-blog.csdnimg.cn/20210616190823439.png"alt="在这里插入图片描述" /> 再结合一点高中数学，<spanclass="math inline">\(l(\theta)\)</span>极大值点处的一阶导数为0，因此只要令<spanclass="math inline">\(l^{&#39;}(\theta)=0\)</span>就能解出对应的<spanclass="math inline">\(\theta\)</span>： <spanclass="math display">\[\theta=\theta-\frac{l^{&#39;}(\theta)}{l^{&#39;&#39;}(\theta)}\]</span>由于逻辑回归中<spanclass="math inline">\(\theta\)</span>是向量而非scalar，因此需要稍稍改变下更新规则：<spanclass="math display">\[\theta=\theta-H^{-1}\nabla_{\theta}l(\theta)\]</span>其中，Hessian阵中的元素为<spanclass="math inline">\(H_{ij}=\frac{\partial^2l(\theta)}{\partial\theta_i\partial\theta_j}\)</span>。</p><p>牛顿法通常比梯度上升收敛快得多，因为利用了<spanclass="math inline">\(l(\theta)\)</span>的二阶信息，但是存储和求解<spanclass="math inline">\(H^{-1}\)</span>开销会比较大。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Regression</title>
      <link href="/posts/linear-regression/"/>
      <url>/posts/linear-regression/</url>
      
        <content type="html"><![CDATA[<h2 id="线性回归模型">线性回归模型</h2><p><spanclass="math display">\[h_{\theta}(x)=\sum_{i=0}^{d}\theta_ix_i=\theta^Tx=x^T\theta\]</span>其中，<span class="math inline">\(x_0=1\)</span>，<spanclass="math inline">\(d\)</span>表示<spanclass="math inline">\(x\)</span>的特征数量。</p><p>在给定训练集下，需要用学习算法确定参数<spanclass="math inline">\(\theta\)</span>，使得模型的预测值<spanclass="math inline">\(h(x)\)</span>与真实值<spanclass="math inline">\(y\)</span>尽可能接近。为了精确地描述这种接近程度，定义损失函数：<spanclass="math display">\[J(\theta)=\frac{1}{2}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2\]</span>问题转化为选择一组<span class="math inline">\(\theta\)</span>使得<spanclass="math inline">\(J(\theta)\)</span>最小，这里有2种求解方法：</p><ol type="1"><li>梯度下降</li><li>Normal Equation</li></ol><h2 id="梯度下降">梯度下降</h2><p>梯度下降的motivation非常直观，首先随机选择一组参数<spanclass="math inline">\(\theta\)</span>，接着沿<spanclass="math inline">\(J(\theta)\)</span>下降最快的方向更新<spanclass="math inline">\(\theta\)</span>，经过若干次迭代就有望找到令<spanclass="math inline">\(J(\theta)\)</span>收敛的参数<spanclass="math inline">\(\theta\)</span>： <spanclass="math display">\[\theta_j=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)\]</span>将<spanclass="math inline">\(J(\theta)\)</span>的偏导数代入即得到所谓的batchgradient descent更新规则： <spanclass="math display">\[\theta_j=\theta_j-\alpha\sum_{i=1}^{n}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}\]</span>其向量化表示为： <spanclass="math display">\[\theta=\theta-\alpha\sum_{i=1}^{n}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}\]</span>由于损失函数<spanclass="math inline">\(J(\theta)\)</span>是凸二次函数，因此总能收敛到唯一的全局最小值。</p><p>batch gradientdescent一次更新需要计算所有训练样本，开销较大，因此有同学提出了stochasticgradient descent，每遇到一个训练样本就进行一次参数更新： <spanclass="math display">\[\theta=\theta-\alpha(h_\theta(x^{(i)})-y^{(i)})x^{(i)}\]</span>stochastic gradient descent一般比batch gradientdescent收敛快，但是有可能在<spanclass="math inline">\(J(\theta)\)</span>的最优点附近振荡，永远无法收敛到精确最优。不过一般选择最优点附近的参数也可以接受，还可以通过递减学习率<spanclass="math inline">\(\alpha\)</span>确保其精确收敛。</p><p>值得一提的是：梯度下降算法存在“锯齿”效应，因此为了加速收敛，通常要进行归一化处理使得不同特征的尺度相近。</p><h2 id="normal-equation">Normal Equation</h2><p>除了用迭代的方式求解<spanclass="math inline">\(J(\theta)\)</span>的最小值，还可以用数学工具直接求得闭式解。</p><p>为了简洁地表示后续求导，使得人生不要太过凌乱，我们首先研究下<spanclass="math inline">\(J(\theta)\)</span>的向量表示：<br />假设训练集<span class="math inline">\(X\)</span>和对应的标签<spanclass="math inline">\(y\)</span>分别为： <spanclass="math display">\[X=\left[\begin{matrix}(x^{(1)})^T \\(x^{(2)})^T \\\vdots \\(x^{(n)})^T \\\end{matrix}\right],y=\left[\begin{matrix}y^{(1)} \\y^{(2)} \\\vdots \\y^{(n)} \\\end{matrix}\right]\]</span> 由于<spanclass="math inline">\(h_{\theta}(x^{(i)})=(x^{(i)})^T\theta\)</span>，所以有：<span class="math display">\[X\theta-y=\left[\begin{matrix}(x^{(1)})^T\theta \\(x^{(2)})^T\theta \\\vdots \\(x^{(n)})^T\theta \\\end{matrix}\right]-\left[\begin{matrix}y^{(1)} \\y^{(2)} \\\vdots \\y^{(n)} \\\end{matrix}\right]=\left[\begin{matrix}h_{\theta}(x^{(1)})-y^{(1)}  \\h_{\theta}(x^{(2)})-y^{(2)} \\\vdots \\h_{\theta}(x^{(n)})-y^{(n)} \\\end{matrix}\right]\]</span> 根据向量运算法则<spanclass="math inline">\(x^Tx=\sum_ix_i^2\)</span>，终于得到了<spanclass="math inline">\(J(\theta)\)</span>的简单点的表示： <spanclass="math display">\[\frac{1}{2}(X\theta-y)^T(X\theta-y)=\frac{1}{2}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2=J(\theta)\]</span>利用高中数学导数的知识，只要求得<spanclass="math inline">\(J(\theta)\)</span>关于参数<spanclass="math inline">\(\theta\)</span>的导数并令其为0，就大功告成了：<spanclass="math display">\[\nabla_{\theta}J(\theta)=\frac{1}{2}(X\theta-y)^T(X\theta-y)\\=\frac{1}{2}\nabla_{\theta}[(X\theta)^TX\theta-(X\theta)^Ty-y^T(X\theta)+y^Ty]=\frac{1}{2}\nabla_{\theta}[\theta^T(X^TX)\theta-y^T(X\theta)-y^T(X\theta)]\\=\frac{1}{2}\nabla_{\theta}[\theta^T(X^TX)\theta-2(X^Ty)^T\theta]=\frac{1}{2}(2X^TX\theta-2X^Ty)=X^TX\theta-X^Ty\]</span>哦，高中数学好像不太够，还要知道<spanclass="math inline">\(a^Tb=b^Ta,\nabla_{x}Ax=A^T,\nabla_{x}x^TAx=(A+A^T)x\)</span>。</p><p>结束了无聊的数学推导，所谓的Normal Equation就来了： <spanclass="math display">\[X^TX\theta=X^Ty\]</span> 我们暂时先不考虑<spanclass="math inline">\(X^TX\)</span>不可逆的情况，最终的解析解就是<spanclass="math inline">\(\theta=(X^TX)^{-1}X^Ty\)</span>。这种方法不需要做FeatureScaling，但是只能用于容易求解的模型。</p><h2 id="probabilistic-view">Probabilistic view</h2><p>当观测数据满足一些假设条件时，就可以自然而然地推导出均方误差形式的损失函数。</p><p>假设观测数据满足： <spanclass="math display">\[y^{(i)}=\theta^Tx^{(i)}+\epsilon^{(i)}\]</span>其中，<spanclass="math inline">\(\epsilon^{(i)}\)</span>表示偏差项，并且<spanclass="math inline">\(\epsilon^{(i)}\)</span>服从IID的高斯分布，即<spanclass="math inline">\(\epsilon^{(i)}\sim \mathcal{N}(0,\sigma^2)\)</span>。</p><p>在满足上述假设的条件下，给定<spanclass="math inline">\(x^{(i)}\)</span>，观测到的<spanclass="math inline">\(y^{(i)}\)</span>满足概率分布<spanclass="math inline">\(y^{(i)}|x^{(i)};\theta\sim\mathcal{N}(\theta^Tx^{(i)}, \sigma^2)\)</span>，即： <spanclass="math display">\[p(y^{(i)}|x^{(i)};\theta)=\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2 \sigma^2})\]</span>我们希望选择合适的参数<spanclass="math inline">\(\theta\)</span>，使得在整个训练集上最大化观测数据出现的概率，也就是所谓的极大似然估计：<spanclass="math display">\[\prod_{i=1}^{n}p(y^{(i)}|x^{(i)};\theta)=\prod_{i=1}^{n}\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})=L(\theta)\]</span> To make our lifeeasier，采用对数似然函数的形式去求<spanclass="math inline">\(L(\theta)\)</span>的最大值： <spanclass="math display">\[l(\theta)=log\ L(\theta)=nlog\\frac{1}{\sqrt{2\pi}\sigma}-\frac{1}{2\sigma^2}\sum_{i=1}^n(y^{(i)}-\theta^Tx^{(i)})^2\]</span>因此，最大化<span class="math inline">\(L(\theta)\)</span>与最小化<spanclass="math inline">\(J(\theta)=\frac{1}{2}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2\)</span>等价，也就证明了均方误差损失函数的合理性。</p><p>值得一提的是：上述假设并不唯一，存在其它合理的假设同样能够证明均方误差作为损失函数的合理性。</p><h2 id="局部加权线性回归">局部加权线性回归</h2><p>在朴素的线性回归中，训练模型得到的参数<spanclass="math inline">\(\theta\)</span>是固定的，对于每个要预测的点<spanclass="math inline">\(x\)</span>计算<spanclass="math inline">\(\theta^Tx\)</span>就完事了。这种参数化的学习算法在预测时不需要训练数据的支持，非常快捷。</p><p>局部加权线性回归的motivation在于：朴素线性模型强行拟合所有训练样本，因为模型简单往往欠拟合。对于任意一个样本<spanclass="math inline">\(x\)</span>，如果只根据其周围几个样本来建立局部的线性模型，且距离<spanclass="math inline">\(x\)</span>越近其在损失函数中的权值越大，就得到了所谓的LocallyWeighted Linear Regression： <spanclass="math display">\[J(\theta)=\frac{1}{2}\sum_{i=1}^{n}w^{(i)}(h_{\theta}(x^{(i)})-y^{(i)})^2\]</span>直观上看：如果一个点权值较大，其对损失函数的贡献就越大；如果权值较小，那么该点基本可以忽略不计。</p><p>权值一般会设计为指数函数： <spanclass="math display">\[w^{(i)}=exp(-\frac{(x^{(i)}-x)^T(x^{(i)}-x)}{2\tau^2})\]</span>其中，<span class="math inline">\(x\)</span>表示待测试样本，<spanclass="math inline">\(\tau\)</span>负责控制随距离增加权值的衰减快慢。</p><p>另外，与kNN类似，LWR也是一种懒惰学习算法，即只有给出测试样例时才会训练并预测。因此，这种非参数算法在预测时需要存储训练集，并且参数数量会随训练集大小线性增长。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Machine Learning Introduction</title>
      <link href="/posts/ml-introduction/"/>
      <url>/posts/ml-introduction/</url>
      
        <content type="html"><![CDATA[<p>对一个背后的pattern很复杂的问题，我们无法显式编程求解，就需要ML。如果能做到100%正确并且这个过程并不很复杂，就完全没有必要上ML。</p><p>ML我们并没有也不可能直接考虑所有可能出现的情况，然后用对应的方法解决。此时我们编写的程序其实是在操纵一个学习器，它可以根据模型参数的不同灵活应对输入的情况，并且每组参数都可以很好地处理输入的变化。</p><p>现实生活中有许多不同类型的问题，因此学习器也有很多不同的类型，不同类型的学习器针对不同的问题，当然也可以一对多或者多对一或者多对多。训练就是要根据数据获得一组表现良好的参数，下次给出相似类型的输入，我们的模型（参数固定的学习器）可以获得良好的预测表现。此外，还要有一个衡量当前这组参数表现好坏的措施，这就是objectivefunction，训练时要用algorithm去有策略地调整参数，优化objective/lossfunction。</p><p>数据的难点在于：数量要够只是基本，数据应该合理反应所有可能的类别，对于特定任务的特征选择也应该慎重，比如简历筛选时如果把历史面试结果作为一个特征，那么就很可能在无意中引入historicalinjustices。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Topological Sort</title>
      <link href="/posts/topological-sort/"/>
      <url>/posts/topological-sort/</url>
      
        <content type="html"><![CDATA[<h2 id="拓扑排序">拓扑排序</h2><p>拓扑排序将有向无环图(DAG)的所有顶点排成一个线性序列，满足</p><ul><li>每个结点只出现一次</li><li>任意两个顶点若存在有向边<span class="math inline">\(u\rightarrowv\)</span>，那么在线性序列中<spanclass="math inline">\(u\)</span>必然在<spanclass="math inline">\(v\)</span>之前</li></ul><p>非DAG图是不存在拓扑序列的.</p><p>拓扑排序的实现有BFS和DFS的方式，BFS的思想是：</p><ol type="1"><li>将所有入度为0的顶点入队；</li><li>取队首结点输出，删除所有从该结点出发的边，并将这些边到达的顶点的入度减1，若某顶点入度减为0，将其入队；</li><li>重复2，直到队列为空。若进过队的结点数为<spanclass="math inline">\(n\)</span>，排序成功，否则<strong>图中有环</strong>。</li></ol><p>时间复杂度<spanclass="math inline">\(O(V+E)\)</span>，如果需要按字典序输出，就用优先队列。</p><p>dfs version, reverse ans is the topological sequence</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS + 邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; indegree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = g.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;  <span class="comment">// 若有多个入度为0的顶点要选择编号最小的，可使用priority_queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        ++cnt;</span><br><span class="line">        cout &lt;&lt; cur &lt;&lt; endl;  <span class="comment">// 输出拓扑序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> nei : g[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--indegree[nei] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(nei);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n;  <span class="comment">// 排序成功, 否则有环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三色DFS + 邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = g.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 0 -&gt; 未访问, 2 -&gt; 已访问, 但不是当前dfs访问的</span></span><br><span class="line">    <span class="comment">// 1 -&gt; 已访问且是当前dfs访问的(u-&gt;v,v-&gt;t,t-&gt;u), 有环</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(g, vis, i))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 有环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断从u可达的图是否有环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; vis, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> nei : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[nei] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(g, vis, nei)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[nei] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u] = <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; u &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 输出拓扑序列逆序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图论判环">图论判环</h2><h3 id="无向图判环">无向图判环</h3><ol type="1"><li>DFS + parent node</li></ol><p>这里不要求无向图连通，如果无向图中的任一连通分量中有环，就说无向图中存在环。</p><p>对每个未访问过的顶点进行DFS，会在该顶点所处的连通分量上产生一棵DFStree，图中存在环当且仅当树上存在backedge，这条回边要么关联自己成为自环边（简单图不允许自环），要么关联树上该顶点的某个祖先结点。因此，如果有一条指向已经访问过的顶点的回边，就返回<code>true</code>。具体来说，对于所有邻接点，如果某个邻接点不是父结点但却被访问过，证明有环。</p><p>对于一条边关联的2个顶点，DFS时从u到邻接点v，u在树上是v的父结点，那么对v访问邻接点时需要特判u。时间复杂度<spanclass="math inline">\(O(V+E)\)</span>，空间复杂度<spanclass="math inline">\(O(V)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断从u可达的连通分量是否有环</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nei : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nei]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(nei, u)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nei != parent) &#123; <span class="comment">// 该邻接点已访问过且不是u的父结点, 有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(i, <span class="number">-1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DFS如果需要输出环路，需要在<code>dfs</code>里添加一个<code>parent</code>数组，记录顶点在DFStree上的父结点。</p><ol start="2" type="1"><li>BFS</li></ol><p>BFS的基本思想与DFS类似：对于当前访问的结点cur，将其标记，访问cur的所有邻接点adj，如果adj已经被标记为访问过但却不是cur的父结点，表明有环。</p><p>不过，BFS需要一个<code>parent</code>数组记录每个顶点的父结点，区分邻接点中<strong>环中的顶点</strong>和<strong>遍历中的父结点</strong>（只用<code>vis</code>数组无法区分），这样才不会错误判断与已访问的父结点构成环。时间复杂度<spanclass="math inline">\(O(V+E)\)</span>，也可以输出环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push</span>(u);</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nei : g[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[nei]) &#123;</span><br><span class="line">                vis[nei] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(nei);</span><br><span class="line">                parent[nei] = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nei != parent[cur]) &#123; <span class="comment">// nei被访问过且不是cur的父结点, 有环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">bfs</span>(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li><ahref="https://eimadrigal.github.io/posts/union-find/">并查集判环</a></li></ol><h3 id="有向图判环">有向图判环</h3><ol type="1"><li><p>BFS拓扑排序</p></li><li><p>DFS拓扑排序（vis + stack）</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">onStack</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    onStack[s] = <span class="literal">true</span>;  <span class="comment">// 本次dfs访问的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> adj : g[s]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[adj]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(adj)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onStack[adj]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onStack[s] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycleDirected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要找具体的环，可以用<code>prev</code>数组保存每一步的走法。</p><ol start="3" type="1"><li>DFS拓扑排序（三色vis法）</li></ol><p>之所以要用三色法标记，是为了区分不同的dfs遍历，比如1-&gt;2, 1-&gt;3,2-&gt;3这张图如果用无向图判环的方式就会误杀。</p><h2 id="有向图强连通分量">有向图强连通分量</h2><p>在有向图G中，如果两个顶点互相有路径可达，称两个顶点是<strong>强连通</strong>的。如果G中任意两个顶点都是强连通的，则G是一个<strong>强连通图</strong>。G的极大强连通子图称为G的<strong>强连通分量</strong>（stronglyconnected components）。</p><p>寻找SCC有2种常见算法，一种是Kosaraju's algorithm，另一种就是Tarjan'sSCC algorithm。</p><p>Tarjan算法中，每个结点u都有一个low-linkvalue，表示DFS时从u出发能够到达的最小的id，包括u自己。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; sccs;</span><br><span class="line"><span class="keyword">int</span> timestamp = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> cur, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; dfn, vector&lt;<span class="keyword">int</span>&gt;&amp; low, stack&lt;<span class="keyword">int</span>&gt;&amp; stk, vector&lt;<span class="keyword">bool</span>&gt;&amp; inStk)</span> </span>&#123;</span><br><span class="line">    dfn[cur] = low[cur] = ++timestamp;</span><br><span class="line">    stk.<span class="built_in">push</span>(cur);</span><br><span class="line">    inStk[cur] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nei : g[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfn[nei] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(nei, g, dfn, low, stk, inStk);</span><br><span class="line">            low[cur] = <span class="built_in">min</span>(low[cur], low[nei]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inStk[nei]) &#123;</span><br><span class="line">            low[cur] = <span class="built_in">min</span>(low[cur], dfn[nei]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[cur] == low[cur]) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; scc;</span><br><span class="line">        <span class="keyword">int</span> poped;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            poped = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">            scc.<span class="built_in">push_back</span>(poped);</span><br><span class="line">            inStk[poped] = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (poped != cur);</span><br><span class="line">        sccs.<span class="built_in">push_back</span>(scc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; g&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">0</span>,<span class="number">5</span>&#125;, &#123;<span class="number">5</span>&#125;, &#123;&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = g.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dfn</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">low</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">inStk</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfn[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(i, g, dfn, low, stk, inStk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> scc : sccs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : scc) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><a href="https://stackoverflow.com/questions/19113189/">Detectingcycles in a graph using DFS</a><br /><ahref="https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/">Tarjan’sAlgorithm to find Strongly Connected Components</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathematics for Machine Learning</title>
      <link href="/posts/math-for-ml/"/>
      <url>/posts/math-for-ml/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p><span class="math inline">\(f(\mathbf{x}) =\boldsymbol{\beta}^\top\mathbf{x}\)</span> <spanclass="math display">\[\frac{df}{d\mathbf{x}} = \begin{bmatrix}\frac{df}{dx_1} \\\vdots \\\frac{df}{dx_n}\end{bmatrix} = \begin{bmatrix}\beta_1 \\\vdots \\\beta_n\end{bmatrix} = \boldsymbol{\beta}\]</span></p><p><span class="math inline">\(\frac{d}{d\mathbf{x}}(\mathbf{x}^\top A\mathbf{x}) = (\mathbf{A} + \mathbf{A}^\top)\mathbf{x}.\)</span></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/posts/linux-commands/"/>
      <url>/posts/linux-commands/</url>
      
        <content type="html"><![CDATA[<h2 id="linux-command">Linux Command</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>  <span class="comment"># print working directoty</span></span><br><span class="line"><span class="built_in">cd</span> /  <span class="comment"># change directory 输入文件夹部分名按tab自动补全 如果文件夹名字含有空格，需要用&quot;&quot;括起来</span></span><br><span class="line">ls -l  <span class="comment"># list files</span></span><br><span class="line"></span><br><span class="line">mkdir  <span class="comment"># make directory</span></span><br><span class="line">rmdir  <span class="comment"># remove directory</span></span><br><span class="line"></span><br><span class="line">touch filename  <span class="comment"># create an empty file</span></span><br><span class="line">cp lab1/original lab2/dup  <span class="comment"># 将original复制为dup</span></span><br><span class="line">mv lab1/a.txt lab2/  <span class="comment"># 移动</span></span><br><span class="line">mv lab1/a.txt lab1/newname.txt  <span class="comment"># 重命名</span></span><br><span class="line">rm a.txt  <span class="comment"># delete file</span></span><br><span class="line"></span><br><span class="line">cat a.txt  <span class="comment"># capture</span></span><br><span class="line">less a.txt  <span class="comment"># q退出</span></span><br><span class="line">diff a.txt b.txt</span><br><span class="line">head a.txt -n 5  <span class="comment"># 查看前5行</span></span><br><span class="line">tail a.txt -n 5  <span class="comment"># 查看后5行</span></span><br><span class="line">wc -w a.txt  <span class="comment"># 查看单词数目 -l行数 -c字符</span></span><br><span class="line"></span><br><span class="line">xterm  <span class="comment"># open a new terminal window</span></span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">chmod u-r a.txt  <span class="comment"># 作者权限删掉r g-r o-r 小组和其他人删除可读权限</span></span><br><span class="line">chmod u+r a.txt</span><br><span class="line">chmod go-r a.txt</span><br><span class="line">chmod 444 a.txt  <span class="comment"># 100 100 100对应u g o的r w x权限</span></span><br><span class="line"></span><br><span class="line">grep searchword a.txt  <span class="comment"># 包含单词searchword的内容，也可正则</span></span><br><span class="line">grep ^Hello a.txt  <span class="comment"># 以Hello开头的内容</span></span><br><span class="line">grep searchword a.txt | wc  <span class="comment"># 命令组合</span></span><br><span class="line"></span><br><span class="line">ls &gt; a.txt  <span class="comment"># 重定向</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$USER</span>  <span class="comment"># global variable 当前登录用户</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可执行程序只能在当前目录下执行，如果要在其他目录执行需配置环境变量，配置后该目录下的所有可执行程序都可在任意地方执行</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/home/ubuntu/dir  <span class="comment"># 原PATH拼接新路径 不要写成PATH=/home</span></span><br><span class="line"></span><br><span class="line">zip hello.zip *  <span class="comment"># 打包所有文件</span></span><br><span class="line">zip hello.zip -r hello/*  <span class="comment"># 递归打包所有子文件夹</span></span><br><span class="line">unzip hello.zip</span><br><span class="line"></span><br><span class="line">tar -zcvf hello.tar.gz hello/  <span class="comment"># -z使用gzip压缩</span></span><br><span class="line">tar -zxvf hello.tar.gz  <span class="comment"># 解压</span></span><br><span class="line"></span><br><span class="line">wget url -O newname  <span class="comment"># 下载</span></span><br></pre></td></tr></table></figure><h2 id="shell-script">Shell Script</h2><p>脚本<code>test.sh</code>就是一坨命令，执行脚本就是按照顺序执行这些命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh test.sh  <span class="comment"># 运行脚本</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">a=10  <span class="comment"># 赋值不能加空格</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span>  <span class="comment"># 使用变量时加$ echo输出</span></span><br><span class="line">c=`expr <span class="variable">$a</span> + <span class="variable">$b</span>`  <span class="comment"># 运算符两侧必须加空格</span></span><br><span class="line">c=`expr <span class="variable">$a</span> \* <span class="variable">$b</span>`  <span class="comment"># \(\)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]  <span class="comment"># 比较大小不能用 &gt; &lt; =</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$b</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> 1 2 3  <span class="comment"># for x in &#123;1 .. 3&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">x=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$x</span> -le 10]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$x</span></span><br><span class="line">    x=`expr <span class="variable">$x</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">a=<span class="string">&quot;hello&quot;</span></span><br><span class="line">b=<span class="string">&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> a</span><br><span class="line"><span class="built_in">read</span> b</span><br><span class="line">c=`expr <span class="variable">$a</span> + <span class="variable">$b</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span> + <span class="variable">$b</span> = <span class="variable">$c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> = <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> != <span class="variable">$b</span> ]</span><br><span class="line">str3=<span class="string">&quot;$str1<span class="variable">$str2</span>&quot;</span>  <span class="comment"># 拼接</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$str1</span> ]  <span class="comment"># 是否为空 -n是否为不空</span></span><br><span class="line"></span><br><span class="line">arr=(1 2 3)  <span class="comment"># 只能用bash test.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;arr[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Random Forest</title>
      <link href="/posts/random-forest/"/>
      <url>/posts/random-forest/</url>
      
        <content type="html"><![CDATA[<h2 id="decision-tree">Decision Tree</h2><h2 id="details">Details</h2><p>决策树的发展经历了CART(Classification and Regression Tree), ID3,C4.5等多个阶段：<br />CART是一种二叉树，分类树采用基尼系数，回归树采用平方误差。<br />ID3主要用于分类，是一种多叉树结构，采用信息增益。<br />C4.5主要用于分类，是一种多叉树结构，采用信息增益比。<br />最终的模型为： <span class="math display">\[f(x)=\sum_{i=1}^{m}C_iI(x\inR_i),I(x\in R_i)=\begin{cases}1, &amp; \text{x$\in$ $R_i$}  \\0, &amp; \text{else}\end{cases}\]</span> m表示数据集被划分的子集数目，<spanclass="math inline">\(C_i\)</span>表示第i个单元的输出值 ## Example ##Implementation ## Properties</p><h2 id="motivation">Motivation</h2><p>Random Forest is some kind of ensemble learning method, just as itsname indicates. The base learner is decision tree and RF uses Bagging tointegrate. The difference mainly lies in the word 'Random'. The originaldecision tree selects the best attribute while RF has two steps toselect a split attribute for each base learner:</p><ul><li>Select k attributes from <span class="math inline">\(A\)</span>randomly;</li><li>Select the best attribute from the k attributes. If k=1 then it'stotal random selection; If k=<span class="math inline">\(|A|\)</span>then it's the same as decision tree. The recommended is <spanclass="math inline">\(k=log_2|A|\)</span>.</li></ul><p>The intuition behind this is to increase the diversity of the baselearners. In original bagging method we just use the sample disturbanceof the training data. But in RF we add the attribute disturbance thusmaking the learner generalize very well.</p><p>As you can imagine, RF's performance is worse than Bagging during theearly time of the training process. Since we just use a subset of theattributes so the base learner performs not that well. But with theincrease of the number of base learners, it will gradually use the wholeinformation and then has a low generation error. By the way, RF is oftenfaster than Bagging since we only use a subset to train the baselearners.</p><h2 id="随机森林回归">随机森林回归</h2><p>决策树回归的叶子结点代表一小片区域，落入该区域的训练样例的均值被用来作为该区域的预测值：<br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211102104210878-1445042394.png"alt="image" /><br />例如上图中右下角的叶子结点的值552.899就是落入该区域的5个样本的均值。<br />随机森林则是由若干棵决策树通过某些“随机”的方式构建而成，包括样本随机和属性随机，最终的预测结果由所有树的平均得到。<br />但是它不像线性回归那样在预测时可以外推，如果仔细观察最终参与决策的树的某一部分：<br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211102105550016-162430821.png"alt="image" /><br />可以看到：在carat&lt;0.905和z&lt;3.915这个区域共有4个训练样本，因此测试集中任意一个落入此区域的样本都会被预测为4个样本的均值2775.75，自然也就不会超过这4个样本的取值极限。<br />如果要预测某个targetvalue超出训练集极限的样例，其预测结果仍然是训练集中某些样本的均值。</p><p>缺失值处理：我在科研中见到的都是先用常数填充训练数据和测试数据，再去扔给模型训练和预测。<br />我使用sklearn中标准的RandomForestRegressor进行了尝试，如果训练数据包含缺失值，那么训练将会报错。## Example ## Implementation ## Properties ## Refs <ahref="https://neptune.ai/blog/random-forest-regression-when-does-it-fail-and-why">RandomForest Regression: When Does It Fail and Why?</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List Cycle</title>
      <link href="/posts/linked-list-cycle/"/>
      <url>/posts/linked-list-cycle/</url>
      
        <content type="html"><![CDATA[<h2 id="一单链表是否有环">一、单链表是否有环</h2><p><ahref="https://leetcode.com/problems/linked-list-cycle/">题目描述</a><br />快慢指针：若链表有环，则两指针必在将来某一时刻相遇：</p><ul><li>直观来看：本质上就是物理上的相对运动。快指针每次2步，慢指针每次1步。<br />如果没有环，快指针先到达链尾，结束；<br />如果有环，相对速度为1，即相当于慢指针静止，快指针每次1步，则必然在一圈之内相遇。</li><li>那如果快指针每次3步，4步呢？由之前的相对运动，我们知道两个指针不一定相遇。那么什么情况下可以相遇呢？<br /><img src="https://img-blog.csdnimg.cn/20200309193026391.png"alt="在这里插入图片描述" /><br />当S第一次到达环口，F可能已经在环里转了n圈。假设S的速度为<spanclass="math inline">\(v_s\)</span>，F的速度为<spanclass="math inline">\(v_f\)</span>，环长为<spanclass="math inline">\(L\)</span>，经过时间<spanclass="math inline">\(t\)</span>相遇： <spanclass="math display">\[disS=L_1, disF=L_1+L_2+nL\]</span><br />即问题转化为是否存在正整数<spanclass="math inline">\(t\)</span>，使得S和F在环内走过的路程相等： <spanclass="math display">\[v_st\%L=(L_2+nL+v_ft)\%L\]</span>根据模运算性质： <spanclass="math display">\[(L_2+nL+(v_f-v_s)t)\%L=0\]</span> 再化简： <spanclass="math display">\[(L_2+(v_f-v_s)t)\%L=0\]</span> 也就是当<spanclass="math inline">\(L_2+(v_f-v_s)t\)</span>是环长<spanclass="math inline">\(L\)</span>的整数倍，快慢指针可以相遇。<br />回头去看最简单的情形：<spanclass="math inline">\(v_f-v_s=1\)</span>，则<spanclass="math inline">\(t=mL-L_2\)</span>，取<spanclass="math inline">\(m=1,t=L-L_2\)</span>。所以经过<spanclass="math inline">\(t\)</span>步必然相遇。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 单链表定义</span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int x):val(x),next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">    if (head == NULL)</span><br><span class="line">   return false;</span><br><span class="line">  ListNode* fast = head;</span><br><span class="line">  ListNode* slow = head;</span><br><span class="line">  while (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    if(fast == slow)</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二寻找环的入口">二、寻找环的入口</h2><p><ahref="https://leetcode.com/problems/linked-list-cycle-ii/">题目描述</a><br />设链头距离环的入口距离为<spanclass="math inline">\(L_1\)</span>，<strong>相遇点</strong>距离入口距离为<spanclass="math inline">\(L_3\)</span>，环的长度为<spanclass="math inline">\(L\)</span>：<br /><img src="https://img-blog.csdnimg.cn/20200309203553400.png"alt="在这里插入图片描述" /><br />证明的本质在于求出<span class="math inline">\(L_1\)</span>与<spanclass="math inline">\(L_3\)</span>的关系。<br />在（一）中我们已经证明了S从入口到相遇只走了<spanclass="math inline">\(L-L_2&lt;L\)</span>步，即小于1圈。<br />由于快指针走过的路程是慢指针的2倍： <spanclass="math display">\[L_1+L_2+nL+2(L-L_2)=2(L_1+L-L_2)\]</span> 即：<span class="math display">\[L_1=L_2+nL\]</span> 又<spanclass="math inline">\(L_3=L-(L-L_2)=L_2\)</span>，故有： <spanclass="math display">\[L_1=nL+L_3\]</span>n表示S第一次到达入口时，快指针已经绕了<spanclass="math inline">\(n\)</span>圈。<br />也就是说：设两个指针<span class="math inline">\(p_1, p_2\)</span>，<spanclass="math inline">\(p_1\)</span>指向链头，<spanclass="math inline">\(p_2\)</span>指向相遇点，每次都走一步，则两指针必在环的入口相遇。<br />通俗理解：<span class="math inline">\(p_1\)</span>指针先走<spanclass="math inline">\(L_3\)</span>步，此时<spanclass="math inline">\(p_1\)</span>距离环入口还有<spanclass="math inline">\(L_1-L_3=nL\)</span>步，同时<spanclass="math inline">\(p_2\)</span>也走了<spanclass="math inline">\(L_3\)</span>步，刚好到环入口。接着<spanclass="math inline">\(p_1\)</span>继续走<spanclass="math inline">\(nL\)</span>步，<spanclass="math inline">\(p_2\)</span>开始绕环<spanclass="math inline">\(n\)</span>圈，必相遇。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//单链表定义</span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int x):val(x),next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* detectCycle(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        auto fast = head;</span><br><span class="line">        auto slow = head;</span><br><span class="line">        while(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if(fast == slow)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!fast || !fast-&gt;next)   //无环,fast走到尽头</span><br><span class="line">            return nullptr;</span><br><span class="line"></span><br><span class="line">        slow = head;   //一个指向链头,另一个指向相遇点</span><br><span class="line">        while(slow != fast)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;    //找到入口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Subarray</title>
      <link href="/posts/maximum-subarray/"/>
      <url>/posts/maximum-subarray/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>给定一个序列<span class="math inline">\(A_0\)</span>、<spanclass="math inline">\(A_1\)</span>、<spanclass="math inline">\(A_2\)</span>、...、<spanclass="math inline">\(A_{n-1}\)</span>，求<spanclass="math inline">\(A_i+A_{i+1}+...+A_j\)</span>的最大值。</p><h2 id="解一">解一</h2><p>暴力枚举左端点<span class="math inline">\(i\)</span>和右端点<spanclass="math inline">\(j\)</span>，之后计算<spanclass="math inline">\(A_i\)</span>和<spanclass="math inline">\(A_j\)</span>之间的和，时间复杂度<spanclass="math inline">\(O(n^3)\)</span>，很容易TLE。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define INF 0x7FFFFFFF</span><br><span class="line"></span><br><span class="line">int sub_sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int MAX = -INF;</span><br><span class="line">    for(int i = 0;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i; j &lt; n; j++)</span><br><span class="line">  &#123;</span><br><span class="line">   int temp = 0;</span><br><span class="line">   for (int k = i; k &lt;= j; k++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp += a[k];</span><br><span class="line">  &#125;</span><br><span class="line">   if (temp &gt; MAX)</span><br><span class="line">   &#123;</span><br><span class="line">   MAX = temp;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解二">解二</h2><p>输入数据时记录前缀和，预处理<span class="math inline">\(sum[i] = A[0]+ ... + A[i]\)</span>，因此<spanclass="math inline">\(A_i+A_{i+1}+...+A_j=sum[j]-sum[i-1]\)</span>，复杂度优化为<spanclass="math inline">\(O(n^2)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int sub_sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int MAX = -INF;</span><br><span class="line">    for(int i = 0;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = i;j &lt; n;j++&#125;</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = sum[j] - sum[i - 1];</span><br><span class="line">            if(temp &gt; MAX)</span><br><span class="line">                MAX = temp;</span><br><span class="line">            else</span><br><span class="line">                temp = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解三">解三</h2><p>动态规划，复杂度<span class="math inline">\(O(n)\)</span>。<br />定义状态数组<span class="math inline">\(dp[i]\)</span>，表示以<spanclass="math inline">\(A[i]\)</span>结尾的连续序列的最大和，这样就只有两种情况：<br />1，该连续序列只有<spanclass="math inline">\(A[i]\)</span>这一个元素；<br />2，该序列有多个元素，从之前的<spanclass="math inline">\(A[p]\)</span>开始，到<spanclass="math inline">\(A[i]\)</span>结束。<br />对于1，最大和就是<span class="math inline">\(A[i]\)</span>；<br />对于2，最大和是<span class="math inline">\(dp[i -1]+A[i]\)</span>，因为<spanclass="math inline">\(dp[i]\)</span>要求以<spanclass="math inline">\(A[i]\)</span>结尾，所以即使<spanclass="math inline">\(A[i]\)</span>为负数，<spanclass="math inline">\(dp[i]\)</span>仍然等于<spanclass="math inline">\(dp[i - 1]+A[i]\)</span>。<br />所以<strong>状态转移方程</strong>就是： <spanclass="math display">\[dp[i]=max{\{A[i],dp[i-1]+A[i]\}}\]</span>边界是<span class="math inline">\(dp[0]=A[0]\)</span>。<br />所以枚举<span class="math inline">\(i\)</span>，得到<spanclass="math inline">\(dp\)</span>数组，求出<spanclass="math inline">\(dp\)</span>数组最大值即可。</p><p>可以看到，每次计算<spanclass="math inline">\(dp[i]\)</span>只用到<spanclass="math inline">\(dp[i-1]\)</span>，不直接用到之前的信息，这就是状态的<strong>无后效性</strong>，只有这样，动态规划才可能得到正确结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int dp[5010];</span><br><span class="line">dp[0] = a[0];</span><br><span class="line"></span><br><span class="line">int sub_sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //状态转移方程</span><br><span class="line">        dp[i] = max(a[i],dp[i - 1] + a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int k = 0;</span><br><span class="line">    for(int i = 1;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dp[i] &gt; dp[k])</span><br><span class="line">            k = i;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免使用<spanclass="math inline">\(dp[]\)</span>数组，可以将空间复杂度优化为<spanclass="math inline">\(O(1)\)</span>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int allSum = INT_MIN, curSum = 0;</span><br><span class="line">        </span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum = max(nums[i], curSum + nums[i]);</span><br><span class="line">            if(curSum &gt; allSum)</span><br><span class="line">            &#123;</span><br><span class="line">                allSum = curSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return allSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree &amp; Graph Search</title>
      <link href="/posts/tree-and-graph-search/"/>
      <url>/posts/tree-and-graph-search/</url>
      
        <content type="html"><![CDATA[<h2 id="tree-search">Tree Search</h2><h3 id="结点定义">结点定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="built_in">Node</span>(): <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> x, Node *left, Node *right): <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层序遍历">层序遍历</h3><ol type="1"><li>二叉树的层序遍历</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">travel</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    queue&lt;Node *&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>多叉树的层序遍历</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">level_order</span>(Node* root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            Node* cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ans[depth].<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (Node* child : cur-&gt;children) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树先序中序后序morris">二叉树先序/中序/后序/Morris</h3><ol type="1"><li><p>先序遍历 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;left, vec);</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) s.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) s.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>中序遍历 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;left, vec);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">travel</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node *&gt; s;</span><br><span class="line">    Node *cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>后序遍历 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;left, vec);</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;right, vec);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代1</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">travel</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node *&gt; s;</span><br><span class="line">    Node *cur = root;</span><br><span class="line">    Node *last_vis = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; last_vis != root) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur != last_vis) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right == <span class="literal">nullptr</span> || cur-&gt;right == last_vis) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            last_vis = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代2</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_front</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) s.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) s.<span class="built_in">push</span>(cur-&gt;right);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p><ahref="https://www.bilibili.com/video/BV1NU4y1M7rF?p=14">Morris遍历0:39:00开始</a></p></li></ol><p><imgsrc="https://img-blog.csdnimg.cn/8138f0b04af941bc91e80728cdf8ea59.png"alt="在这里插入图片描述" /> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morris</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root, *mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) &#123;</span><br><span class="line">                mostRight = mostRight-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mostRight是cur左子树最右结点</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight-&gt;right) &#123;  <span class="comment">// 第一次来到cur</span></span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// mostRight-&gt;right == cur</span></span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morrisPreorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root, *mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) &#123;</span><br><span class="line">                mostRight = mostRight-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mostRight是cur左子树最右结点</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight-&gt;right) &#123;  <span class="comment">// 第一次来到cur</span></span><br><span class="line">                cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// mostRight-&gt;right == cur</span></span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morrisInorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root, *mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) &#123;</span><br><span class="line">                mostRight = mostRight-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mostRight是cur左子树最右结点</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight-&gt;right) &#123;  <span class="comment">// 第一次来到cur</span></span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// mostRight-&gt;right == cur</span></span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cur = cur-&gt;right;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morrisPostorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多叉树先根后根">多叉树先根/后根</h3><ol type="1"><li>先根遍历</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node* root, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    ans.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">for</span> (Node* child : root-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">preorder</span>(child, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cur-&gt;children.<span class="built_in">rbegin</span>(); it != cur-&gt;children.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>后根遍历</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node *child : root-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(child, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cur-&gt;children.<span class="built_in">begin</span>(); it != cur-&gt;children.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="graph-search">Graph Search</h2><p>笔试一般化为平时擅长的图表示再去做算法。</p><h3 id="图的表示及转换">图的表示及转换</h3><figure><img src="https://img-blog.csdnimg.cn/20200218153739820.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><ul><li>邻接矩阵</li></ul><table><thead><tr><th>i/j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>-1</td><td>4</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr><td>1</td><td><span class="math inline">\(\infty\)</span></td><td>0</td><td>3</td><td>2</td><td>2</td></tr><tr><td>2</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td>0</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr><td>3</td><td><span class="math inline">\(\infty\)</span></td><td>1</td><td>5</td><td>0</td><td><span class="math inline">\(\infty\)</span></td></tr><tr><td>4</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td>-3</td><td>0</td></tr></tbody></table><p>用<code>vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, INF))</code>表示，<code>g[i][j]</code>表示从顶点<spanclass="math inline">\(i\)</span>到顶点<spanclass="math inline">\(j\)</span>的权重，空间复杂度<spanclass="math inline">\(O(|V|^2)\)</span>，适用于稠密图，用的不多；</p><ul><li>邻接表：链表比较少用，基本都用动态数组。</li></ul><table><thead><tr><th>0</th><th>(1,-1)</th><th>(2,4)</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>1</td><td>(2,3)</td><td>(3,2)</td><td>(4,2)</td><td>-</td><td>-</td></tr><tr><td>2</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>3</td><td>(1,1)</td><td>(2,5)</td><td>-</td><td>-</td><td>-</td></tr><tr><td>4</td><td>(3,-3)</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>用<code>vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g</code>表示，<code>g[i][j].first</code>表示从顶点<spanclass="math inline">\(i\)</span>出发到达的顶点<spanclass="math inline">\(k\)</span>，<code>g[i][j].second</code>表示从顶点<spanclass="math inline">\(i\)</span>到顶点<spanclass="math inline">\(k\)</span>的权值，空间复杂度<spanclass="math inline">\(O(|V|+|E|)\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵转邻接表</span></span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">to_adj_list</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; adj_matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = adj_matrix.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">ans</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj_matrix[i][j] != INT_MAX)</span><br><span class="line">                tmp.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(j, adj_matrix[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表转邻接矩阵</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">to_adj_matrix</span>(vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;&amp; adj_list) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = adj_list.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, INT_MAX));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; p : adj_list[i]) &#123;</span><br><span class="line">            ans[i][p.first] = p.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>边表<br />每个三元组表示一条边，上图的所有边表示为：<spanclass="math inline">\((0,1,-1),(0,2,4),(1,2,3),(1,3,2),(1,4,2),(3,1,1),(3,2,5),(4,3,-3)\)</span>用<code>vector&lt;vector&lt;int&gt;&gt; e</code>表示，<code>e[i][0]</code>表示顶点<spanclass="math inline">\(u\)</span>，<code>e[i][1]</code>表示顶点<spanclass="math inline">\(v\)</span>，<code>e[i][2]</code>表示<spanclass="math inline">\(u\)</span>到<spanclass="math inline">\(v\)</span>的权值，空间复杂度<spanclass="math inline">\(O(|E|)\)</span>。</p></li><li><p>链式前向星<br />空间复杂度<spanclass="math inline">\(O(n)\)</span>，结合了邻接表和边表，包括边表数组<code>edge</code>和头结点数组<code>head</code>，<img src="https://img-blog.csdnimg.cn/20200725135220669.png"alt="img" />从结点2出发的边有4条，第一条边<code>head[2]=8</code>意味着该边存在<code>edge[8]</code>，下一条边存在<code>edge[6]</code>，<code>next==-1</code>表示结束。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;  <span class="comment">// 边终点to 下一条边next 权值w</span></span><br><span class="line">&#125; edge[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">1000000</span>];  <span class="comment">// head[i]表示指向i的第一条边的存储位置</span></span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// 记录edge的末尾位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">        edge[i].next = <span class="number">-1</span>;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历结点i的所有邻接点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="bfs">BFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    queue = []</span><br><span class="line">    marked = <span class="built_in">set</span>()  <span class="comment"># 避免环造成死循环</span></span><br><span class="line">    parent = &#123;s : <span class="literal">None</span>&#125;  <span class="comment"># for shortest path</span></span><br><span class="line">    queue.append(s)</span><br><span class="line">    marked.add(s)</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(queue) &gt; <span class="number">0</span>):</span><br><span class="line">        cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(cur)</span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur]:</span><br><span class="line">            <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                marked.add(adj)</span><br><span class="line">                queue.append(adj)</span><br><span class="line">                parent[adj] = cur</span><br><span class="line">    <span class="keyword">return</span> parent</span><br></pre></td></tr></table></figure><p>双向BFS <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q1, q2;</span><br><span class="line">    q1.<span class="built_in">push</span>(s), q2.<span class="built_in">push</span>(e);</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; vis1&#123;s&#125;, vis2&#123;e&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q1.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = q1.<span class="built_in">front</span>(); q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> nei : cur.neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis1.<span class="built_in">count</span>(nei)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (vis2.<span class="built_in">count</span>(nei)) <span class="keyword">return</span> res;</span><br><span class="line">                    vis1.<span class="built_in">insert</span>(nei);</span><br><span class="line">                    q1.<span class="built_in">push</span>(nei);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q2.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = q2.<span class="built_in">front</span>(); q2.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> nei : cur.neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis2.<span class="built_in">count</span>(nei)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (vis1.<span class="built_in">count</span>(nei)) <span class="keyword">return</span> res;</span><br><span class="line">                    vis2.<span class="built_in">insert</span>(nei);</span><br><span class="line">                    q2.<span class="built_in">push</span>(nei);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="dfs">DFS</h3><p>从起点出发，标记走过的点，如果发现没有走过的点，随便选一个向前走，无路可走就回退。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    stack.append(s)</span><br><span class="line">    marked.add(s)</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(stack) &gt; <span class="number">0</span>):</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        <span class="built_in">print</span>(cur)</span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur]:</span><br><span class="line">            <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                marked.add(adj)</span><br><span class="line">                stack.append(adj)</span><br></pre></td></tr></table></figure><p>很不幸的是：上面的代码是错的。举个例子：g有ABCDEF6个结点，边为AB ACBC BD CD CE DEDF，如果走ABDE的话，最终答案应该是ABDECF，但是上述代码的结果是ABDEFC，显然不是合法的DFS结果。</p><p>问题在于标记结点是否访问的时机不对，在D弹出后，直接把EF入栈并标记为已访问，下次到E时发现C已被标记，但此时C很明显并未访问。<br />不应在入栈时标记，而应该在弹出时标记。因为入栈时并没有真正地访问该节点，出栈时才真正访问。<br />可以参考<ahref="https://github.com/joepachou/NoteBook/issues/116">CS61B</a>，正确的代码如下，可能会导致重复入栈（有方法避免）：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    stack.append(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(stack) &gt; <span class="number">0</span>):</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">            marked.add(cur)</span><br><span class="line">            <span class="built_in">print</span>(cur)</span><br><span class="line">            <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur]:</span><br><span class="line">                <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                    stack.append(adj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    <span class="keyword">global</span> marked</span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    marked.add(s)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="keyword">for</span> adj <span class="keyword">in</span> g[s]:</span><br><span class="line">        <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">            dfs(g, adj)</span><br></pre></td></tr></table></figure></p><ul><li><p>判断从V出发能否走到终点 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> dfs(v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v <span class="keyword">is</span> terminal) <span class="keyword">return</span> true;</span><br><span class="line">    <span class="keyword">if</span> (vis[v]) <span class="keyword">return</span> false;</span><br><span class="line">    vis[v] = true;</span><br><span class="line">    <span class="keyword">for</span> (u <span class="keyword">in</span> adj(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(u)) <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>判断从V出发能否走到终点，若能，记录路径</p></li></ul><p>栈的作用就是在走投无路之时留给你的退路。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Node path[MAX_LEN];  <span class="comment">// MAX_LEN取节点总数即可</span></span><br><span class="line"><span class="keyword">int</span> depth;  <span class="comment">// 当前点的深度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(V)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (V为终点) &#123;</span><br><span class="line">        path[depth] = V;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (V为旧点) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    将V标记为旧点;</span><br><span class="line">    path[depth++] = V;</span><br><span class="line"></span><br><span class="line">    对和V相邻的每个节点U &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Dfs</span>(U))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --depth;   <span class="comment">//从V走不到终点，把V排除出数组,回退到V的父节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    所有点标记为新点;</span><br><span class="line">    depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dfs</span>(起点)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= depth; i++) &#123;</span><br><span class="line">            cout &lt;&lt; path[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历图上所有节点 <imgsrc="https://img-blog.csdnimg.cn/20190409225110387.png"alt="在这里插入图片描述" /></li></ul><p>邻接矩阵存储遍历复杂度<spanclass="math inline">\(O(n^2)\)</span>，因为对每个节点，都要判断其它所有节点是否相邻。邻接表遍历复杂度<span class="math inline">\(O(n+e)\)</span>。</p><p>1、<a href="http://poj.org/problem?id=1164">城堡问题</a>给一个地图以及每个格子周围的墙所代表数字之和，求该地图有多少房间，最大房间的面积。</p><p>分析：要先判断每个格子周围有什么墙，注意到1，2，4，8的二进制形式<code>0001</code>、<code>0010</code>、<code>0100</code>、<code>1000</code>，所以只要将输入数字与1，2，4，8相与，就能知道该方块周围有什么墙。把方块看作节点，相邻两个方块如果没有墙，就在这两节点之间连一条边，转换为图。房间个数：图中的极大连通子图个数<strong>极大连通子图：一个连通子图，加任意一个图中的其他点就不连通，这个子图就是极大连通子图。</strong></p><p>具体：对每个房间进行DFS，得到该房间所在的极大连通子图，染色所有能够到达的房间，最后统计共用了几种颜色以及每种颜色的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> room[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> color[<span class="number">50</span>][<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;   <span class="comment">//标记方块是否染色,初始都未被访问</span></span><br><span class="line"><span class="keyword">int</span> maxRoomArea = <span class="number">0</span>, roomNum = <span class="number">0</span>, curRoomArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span>   <span class="comment">//从i,j出发遍历极大连通子图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (color[i][j])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    color[i][j] = roomNum;   <span class="comment">//该方块染色</span></span><br><span class="line">    curRoomArea++;</span><br><span class="line">    <span class="keyword">if</span> ((room[i][j] &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i, j - <span class="number">1</span>);  <span class="comment">//没有西墙，向西走</span></span><br><span class="line">    <span class="keyword">if</span> ((room[i][j] &amp; <span class="number">2</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">if</span> ((room[i][j] &amp; <span class="number">4</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i, j + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((room[i][j] &amp; <span class="number">8</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i + <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, column;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;row, &amp;column);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;room[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!color[i][j])   <span class="comment">//找到一个新的房间</span></span><br><span class="line">            &#123;</span><br><span class="line">                roomNum++;</span><br><span class="line">                curRoomArea = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">Dfs</span>(i, j);          <span class="comment">//探索该房间（极大连通子图）</span></span><br><span class="line">            &#125;</span><br><span class="line">            maxRoomArea = <span class="built_in">max</span>(curRoomArea, maxRoomArea);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>, roomNum, maxRoomArea);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<a href="http://bailian.openjudge.cn/practice/4103">踩方格</a>递归，从<spanclass="math inline">\((i,j)\)</span>出发走n步的方案数就等于先走一步，从其它三个格子走n-1步的方案数之和。前提就是该方块没走过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isVisited[<span class="number">20</span>][<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//访问过直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isVisited[i][j])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    isVisited[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以走三个方向</span></span><br><span class="line">    ans += <span class="built_in">Dfs</span>(i - <span class="number">1</span>, j, n - <span class="number">1</span>);</span><br><span class="line">    ans += <span class="built_in">Dfs</span>(i, j - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    ans += <span class="built_in">Dfs</span>(i, j + <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回前表示当前格子可以重新被访问，以后的走法可能会访问到</span></span><br><span class="line">    isVisited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Dfs</span>(<span class="number">20</span>, <span class="number">20</span>, n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<a href="http://poj.org/problem?id=1724">ROADS</a>很多时候，并不需要一条路走到黑，这就是深搜中的<strong>剪枝</strong>。<img src="https://img-blog.csdnimg.cn/20190414173437346.png"alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储边,不需要起点,G(i)表示从i出发*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Road</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> destination, len, toll;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接表存储图*/</span></span><br><span class="line">vector&lt;vector&lt;Road&gt;&gt; <span class="built_in">G</span>(<span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, n, r;</span><br><span class="line"><span class="keyword">int</span> minLen;   <span class="comment">//探索过的最短的路径</span></span><br><span class="line"><span class="keyword">int</span> totalLen;   <span class="comment">//正在探索的最短路径</span></span><br><span class="line"><span class="keyword">int</span> totalCost;   <span class="comment">//正在探索的花费</span></span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> minL[<span class="number">110</span>][<span class="number">10010</span>]; <span class="comment">//minL[i][j]:从1走到城市i，且花了j块钱的最优路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == n)   <span class="comment">//找到了路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        minLen = <span class="built_in">min</span>(minLen, totalLen);</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">//强制结束函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = G[s].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Road r = G[s][i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*判断有没有足够的钱走到r.destination*/</span></span><br><span class="line">        <span class="keyword">if</span> (totalCost + r.toll &gt; k) <span class="comment">//钱不够，试下一条边</span></span><br><span class="line">            <span class="keyword">continue</span>;     <span class="comment">//可行性剪枝</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!visited[r.destination])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*最优性剪枝*/</span></span><br><span class="line">            <span class="comment">//当前走过的路长度已经大于之前的minLen，就没必要走下去</span></span><br><span class="line">            <span class="keyword">if</span> (totalLen + r.len &gt;= minLen)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//走到r.d时花费同样的钱走过的路长度大于之前相同花费的路长度</span></span><br><span class="line">            <span class="keyword">if</span> (totalLen + r.len &gt;= minL[r.destination][totalCost + r.toll])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            minL[r.destination][totalCost + r.toll] = totalLen + r.len;</span><br><span class="line"></span><br><span class="line">            totalLen += r.len;</span><br><span class="line">            totalCost += r.toll;</span><br><span class="line">            visited[r.destination] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(r.destination);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*不走r.destination*/</span></span><br><span class="line">            visited[r.destination] = <span class="number">0</span>; <span class="comment">//换下条边之前将访问标志清0</span></span><br><span class="line">            totalLen -= r.len;</span><br><span class="line">            totalCost -= r.toll;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从城市1开始深搜整个图，找到所有能到达n的，选最优的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;n, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> source;</span><br><span class="line">        Road r;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;source, &amp;r.destination, &amp;r.len, &amp;r.toll);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (source != r.destination)</span><br><span class="line">        &#123;</span><br><span class="line">            G[source].<span class="built_in">push_back</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    totalLen = <span class="number">0</span>, totalLen = <span class="number">0</span>;</span><br><span class="line">    minLen = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;   <span class="comment">//置为无穷大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">110</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10010</span>; j++)</span><br><span class="line">            minL[i][j] = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    visited[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);  <span class="comment">//走完了所有路</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minLen &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, minLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、<a href="http://poj.org/problem?id=1190">生日蛋糕</a> <imgsrc="https://img-blog.csdnimg.cn/20190414175732766.png"alt="在这里插入图片描述" /><imgsrc="https://img-blog.csdnimg.cn/20190414182524737.png"alt="在这里插入图片描述" /> <ahref="http://bailian.openjudge.cn/practice/2816/">练习1</a><br /><a href="http://bailian.openjudge.cn/practice/2488/">练习2</a><br /><a href="http://bailian.openjudge.cn/practice/1321/">练习3</a></p><h2 id="refs">Refs</h2><p><ahref="https://www.icourse163.org/learn/PKU-1001894005?tid=1205957211#/learn/content?type=detail&amp;id=1210422520">郭炜老师MOOC</a><br /><ahref="http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/Data_Structures/binary_tree_traversals.html">BinaryTree Traversals</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Character Array and Character Pointer</title>
      <link href="/posts/char-array-and-pointer/"/>
      <url>/posts/char-array-and-pointer/</url>
      
        <content type="html"><![CDATA[<p>最近复习数据结构实验时，碰到这么一行代码，看的有点不爽。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef char** HuffmanCode;</span><br></pre></td></tr></table></figure><p>借此梳理下数组和指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int* p; //指针变量p中存的地址代表的内存单元中的数据是整型</span><br></pre></td></tr></table></figure><p>在32位平台下，由于p存的是地址，故p的值是32位。<br />不论p指向什么类型的数据，指针变量p本身都是整型。</p><p>c中没有<code>string</code>类型，所以一般用字符数组表示字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char str[15] = &quot;Hello World&quot;;</span><br></pre></td></tr></table></figure><p>c规定数组名表示数组在内存中的首地址，就是<code>str = &amp;str[0]</code>，我们一般输出字符串时<code>printf("%s",str);</code>，首地址就可以输出整个字符串。</p><p>在c中可以这么干：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *s;</span><br><span class="line">s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure><p>一个字符串赋值给一个指针变量？？</p><p>事实上，c的编译器会给字符串常量分配内存，假设<code>"Hello"</code>的地址是<code>0x0000000000404000 0x0000000000404001 0x0000000000404002 0x0000000000404003 0x0000000000404004 0x0000000000404005</code>，（我是64位环境）<br />其实是<code>s = "Hello" = 0x0000000000404000</code>，c编译器把这个串看作首地址。</p><p>做个测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%s\n&quot;,s);</span><br><span class="line">printf(&quot;%s\n&quot;,0x0000000000404000);</span><br><span class="line">这两行的效果是一样的。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char str[10];</span><br><span class="line">char* s;</span><br></pre></td></tr></table></figure><p><code>str</code>表示首地址，<code>s</code>也保存首地址，所以可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = str;</span><br><span class="line">但是不可以 str = s;</span><br></pre></td></tr></table></figure><p>因为数组名是一个常量，不能被赋值。<br />事实上，<code>char str[10]</code>编译器会分配10个内存单元，而<code>char* s</code>只是定义了一个指针变量，32位环境下只分配4个字节，用来保存字符串首地址。</p><p>不信测试下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof(str) = 10;</span><br><span class="line">sizeof(s) = 4;   //分配四个字节来保存地址</span><br></pre></td></tr></table></figure><p>所以数组名和指针变量本质上是不同的。</p><p>接下来我们看看<code>char**与char* a[]</code>：<br />对于<code>char* a[]</code>，a实质上还是一个数组，这个数组保存的元素是<code>char*</code>类型的，<code>char*</code>也就是存着地址的变量。</p><p>所以可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* a[] = &#123;&quot;me&quot;,&quot;you&quot;,&quot;him&quot;&#125;;</span><br></pre></td></tr></table></figure><p>这时在32位环境下<code>sizeof(a) = 12</code>，因为a中的3个元素都是<code>char*</code>指针，而指针变量占4个字节。<br />可以打印出来看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%p %p %p\n&quot;,a[0],a[1],a[2]);</span><br><span class="line">printf(&quot;%p %p %p\n&quot;,&amp;a[0],&amp;a[1],&amp;a[2]);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019021915473671.png"alt="在这里插入图片描述" /><br />数组中3个元素保存了3个地址，也就是3个字符串的首地址。</p><p>对于<code>char** s</code>：<br />二级指针变量s保存一级指针<code>char*</code>的地址，我们可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = a;</span><br></pre></td></tr></table></figure><p>数组名<code>a=&amp;a[0]=62FE30</code>，而这个地址中（即a[0]）保存的是<code>404000</code>这个地址，也就是字符串<code>"me"</code>的首地址，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*s = 404000 = &quot;me&quot;;</span><br></pre></td></tr></table></figure><p>易错点1： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char** s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure> 这是错的，因为s是<code>char**</code>，而"Hello"是<code>char*</code>。<br />虽然都是地址，但是"Hello"表示的地址中内容是H，char型；s存的地址中的内容（<code>*s</code>）是<code>char*</code>型，指针类型。</p><p>易错点2： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char** s;</span><br><span class="line">*s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure>这样编译不会错，但是运行时<code>printf("%s",*s);</code>就会崩溃。</p><p>假设<code>s=0x1000</code>，在<code>0x1000</code>内存单元中存的是"Hello"的地址<code>0x2000</code>，即<code>*s = 0x2000</code>，这样执行时先找到<code>0x1000</code>，然后是<code>0x2000</code>，没有问题。</p><p>但<code>char** s;</code>，s存的是一个随机的地址，也就是野指针，<code>*s</code>就可能会崩溃。</p><p>所以要先分配一个地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char** s;</span><br><span class="line">s = (char**) malloc(sizeof(char**));</span><br><span class="line">*s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure><p>这样s就有了可用的地址。</p><p>参考：https://blog.csdn.net/liusicheng2008_liu/article/details/80412586</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见数据结构与算法分类</title>
      <link href="/posts/data-structure-and-algorithm-classification/"/>
      <url>/posts/data-structure-and-algorithm-classification/</url>
      
        <content type="html"><![CDATA[<h2 id="基础数据结构">基础数据结构</h2><ul><li>数组/栈/队列</li><li>哈希表：原地哈希</li><li>字符串</li><li>链表</li><li><ahref="https://eimadrigal.github.io/posts/sorting-algorithms/">堆</a></li><li><ahref="https://eimadrigal.github.io/posts/monotonous-stack-and-queue/">单调栈/单调队列</a></li><li><ahref="https://eimadrigal.github.io/posts/advanced-data-structures/">B树/B+树/红黑树</a></li></ul><h2 id="工程类">工程类</h2><p>设计并实现一些基础数据结构或工程组件。</p><ul><li><a href="">Cache类</a>：包括LRU、LFU。</li><li><ahref="https://eimadrigal.github.io/posts/tricks-on-algorithm-written-test/">字典树Trie</a></li><li><a href="">哈希表</a></li></ul><h2 id="排序及衍生"><ahref="https://eimadrigal.github.io/posts/sorting-algorithms/">排序及衍生</a></h2><ul><li>4种基础排序：bubble sort，selection sort，insertion sort，希尔</li><li>3种基于比较的：quick sort(quick select &amp; prefectshuffle)，堆排，merge sort</li><li>3种不基于比较的：计数，基数，桶排</li></ul><h2 id="字符串">字符串</h2><ul><li><ahref="https://eimadrigal.github.io/posts/pattern-matching/">KMP</a></li><li>Manacher</li><li>AC自动机</li></ul><h2 id="链表">链表</h2><ul><li>单链表，双链表反转</li><li>链表是否有环，环的入口</li><li>链表相交</li><li>sort list</li></ul><h2 id="二分"><ahref="https://eimadrigal.github.io/posts/binary-search/">二分</a></h2><ul><li>standard</li><li>lower_bound/upper_bound</li></ul><h2 id="贪心">贪心</h2><p>自求多福，策略太多</p><ul><li><ahref="https://mp.weixin.qq.com/s/oVtruRMuMbT4N4h8L8itqA">区间问题</a></li></ul><h2 id="树">树</h2><ol type="1"><li><ahref="https://eimadrigal.github.io/posts/tree-and-graph-search/">二叉树前序/中序/后序的递归和非递归遍历,层次遍历, Morris遍历</a></li><li>序列化和反序列化</li><li>BST问题</li><li><ahref="https://eimadrigal.github.io/posts/binary-indexed-tree/">树状数组BIT</a></li><li><ahref="https://eimadrigal.github.io/posts/segment-tree/">线段树</a></li><li><ahref="https://eimadrigal.github.io/posts/recursion-and-backtracking/">backtracking：排列，组合，子集</a></li><li>树型暴搜：<ahref="https://www.bilibili.com/video/BV1n64y1e7cr?p=13">1:20:00开始</a></li></ol><h2 id="双指针">双指针</h2><ul><li>快慢指针</li><li><a href="">滑动窗口</a></li><li>首尾指针：<br />剑指81：不要求相对位置，首尾指针/快慢指针（快排思想）<br />剑指21：要求相对位置不变，辅助数组/插入/冒泡</li></ul><h2 id="图">图</h2><ul><li><ahref="https://eimadrigal.github.io/posts/union-find/">并查集</a></li><li><ahref="https://eimadrigal.github.io/posts/tree-and-graph-search/">图的表示和转换，建图</a></li><li><ahref="https://eimadrigal.github.io/posts/tree-and-graph-search/">图的DFS/BFS遍历</a></li><li>最小生成树：<ahref="https://eimadrigal.github.io/posts/minimum-spanning-tree/">Kruskal和Prim</a></li><li><ahref="https://eimadrigal.github.io/posts/shortest-path/">最短路径</a>：Dijkstra和堆优化，Floyd-Warshall，Bellman-Ford，A*</li><li><ahref="https://eimadrigal.github.io/posts/topological-sort/">拓扑排序</a>：BFS和DFS</li><li><a href="https://eimadrigal.github.io/posts/topological-sort/">CycleDetection</a></li><li><ahref="https://eimadrigal.github.io/posts/topological-sort/">有向图强连通分量：Tarjan'sAlgorithm</a></li></ul><h2 id="动态规划">动态规划</h2><ul><li><ahref="https://eimadrigal.github.io/posts/knapsack-problem/">背包问题</a></li><li>编辑距离</li><li><ahref="https://eimadrigal.github.io/posts/longest-xxx/">LCS/LIS/最长回文子序列/子串</a></li><li>最大子序和</li><li>股票问题</li><li>区间DP</li><li>状态压缩</li></ul><h2 id="数学">数学</h2><ul><li><ahref="https://eimadrigal.github.io/posts/bit-manipulation/">位运算</a></li><li><ahref="https://eimadrigal.github.io/posts/simple-math-problems/">素数筛</a></li><li><ahref="https://eimadrigal.github.io/posts/simple-math-problems/">质因数</a></li><li><ahref="https://eimadrigal.github.io/posts/fibonacci-sequence/">快速幂</a></li><li>牛顿法</li><li>扫描线</li><li><ahref="https://eimadrigal.github.io/posts/simple-math-problems/">多个数GCD</a></li><li><ahref="https://eimadrigal.github.io/posts/computational-geometry/">计算几何</a></li><li>其他：lt 169 多数元素：hashmap/排序/摩尔投票</li></ul><h2 id="大数据">大数据</h2><h2 id="技巧">技巧</h2><ul><li><ahref="https://www.bilibili.com/video/BV1n64y1e7cr?p=10">矩阵处理，1:25:00开始</a>，矩阵旋转90/180/270，转置</li><li><ahref="https://eimadrigal.github.io/posts/tricks-on-algorithm-written-test/">前缀和</a>：原始数组不变，频繁查询区间累加和，二维前缀和</li><li><ahref="https://eimadrigal.github.io/posts/tricks-on-algorithm-written-test/">差分数组</a>：频繁对原始数组的区间进行增减</li><li><a href="https://eimadrigal.github.io/posts/file-io/">对拍</a></li><li>打表找规律：数学规律题，输入输出都很简单如<code>int</code></li></ul><h2 id="多线程"><ahref="https://eimadrigal.github.io/posts/cpp-multithreading/">多线程</a></h2><h2 id="板子">板子</h2><p><ahref="https://github.com/EIMadrigal/LeetCode">我的LeetCode系列题解</a><br /><a href="https://zhuanlan.zhihu.com/p/98065331">模板1</a><br /><ahref="https://blog.csdn.net/fuxuemingzhu/article/details/101900729">模板2</a><br /><ahref="https://greyireland.gitbook.io/algorithm-pattern/">模板3</a></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 4</title>
      <link href="/posts/interview-4/"/>
      <url>/posts/interview-4/</url>
      
        <content type="html"><![CDATA[<p>120min, 5题。本菜鸡怒跪。</p><ol type="1"><li>变身程序员 <imgsrc="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113449318-2123072016.png"alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(读取时可以按行读取，直到读到空行为止，再对读取过的所有行做转换处理)</span><br><span class="line">输出描述：</span><br><span class="line">如果能将所有的产品经理变成程序员，输出最小的分钟数；</span><br><span class="line">如果不能将所有的产品经理变成程序员，输出-1。</span><br><span class="line">示例1：</span><br><span class="line">输入：</span><br><span class="line">0 2</span><br><span class="line">1 0</span><br><span class="line">输出：</span><br><span class="line">-1</span><br><span class="line">示例2：</span><br><span class="line">输入：</span><br><span class="line">1 2 1</span><br><span class="line">1 1 0</span><br><span class="line">0 1 1</span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">示例3：</span><br><span class="line">输入：1 2</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br><span class="line">输出：</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>此题与<ahref="https://leetcode.com/problems/rotting-oranges/">rotting-oranges</a>类似。基本思想就是将所有的程序员入队，BFS所有的产品经理，最后检查是否还有产品经理存在。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy, <span class="keyword">int</span> t) :<span class="built_in">x</span>(xx), <span class="built_in">y</span>(yy), <span class="built_in">time</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> grid[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*按行读取输入*/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, str))</span><br><span class="line">    &#123;</span><br><span class="line">        col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[row][col++] = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        row++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将所有程序员入队</span></span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(i, j, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    node s;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        s = q.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*四个方向遍历*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> newx = s.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newy = s.y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没有越界并且找到一枚产品经理</span></span><br><span class="line">            <span class="keyword">if</span> (newx &gt;= <span class="number">0</span> &amp;&amp; newx &lt; row &amp;&amp; newy &gt;= <span class="number">0</span> &amp;&amp; newy &lt; col &amp;&amp; grid[newx][newy] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[newx][newy] = <span class="number">2</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(newx, newy, s.time + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li>特征提取 <imgsrc="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113606327-1298909116.png"alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">8</span><br><span class="line">2 1 1 2 2</span><br><span class="line">2 1 1 1 4 2 1 1 2 2</span><br><span class="line">2 2 2 1 4</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">说明：</span><br><span class="line">特征&lt;1，1&gt;在连续的帧中出现3次，相比其他特征连续出现的次数大，所以输出3</span><br><span class="line">备注：</span><br><span class="line">如果没有长度大于2的特征运动，返回1</span><br></pre></td></tr></table></figure><p>可以使用pair存储当前特征，使用map存储当前特征上一次出现的行数以及当前特征连续出现的长度。<del>还是对C++不熟唉</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, fea_num, res;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;M);</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>=&quot;&quot;&gt; cur;</span><br><span class="line">        <span class="comment">//当前特征上一次出现的行数以及连续出现的长度</span></span><br><span class="line">        map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>=&quot;&quot;&gt;, <span class="keyword">int</span>&gt; lastIndex, length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;fea_num);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; fea_num; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;cur.first, &amp;cur.second);</span><br><span class="line">                <span class="keyword">if</span> (lastIndex[cur] == i)</span><br><span class="line">                &#123;</span><br><span class="line">                    length[cur]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    length[cur] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIndex[cur] = i + <span class="number">1</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(res, length[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>机器人跳跃 <imgsrc="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113621644-2143156756.png"alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">3 4 3 2 4</span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">示例2：</span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">4 4 4</span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">示例3：</span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 6 4</span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">备注：</span><br><span class="line">1 &lt;= N &lt;= 10^5</span><br><span class="line">1 &lt;= H(i) &lt;= 10^5</span><br></pre></td></tr></table></figure><p><del>据说是小学数学，还想了半天。</del> 根据题意可推出：<spanclass="math inline">\(dp[k + 1] = 2*dp[k] - H[k + 1]\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">H</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;H[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>)</span></span>;  <span class="comment">//dp[k]表示从第k级开始需要的能量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="built_in">ceil</span>((dp[i + <span class="number">1</span>] + H[i + <span class="number">1</span>]) / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>毕业旅行问题 <imgsrc="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190418161743511-1863478998.png"alt="img" /> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">0 2 6 5</span><br><span class="line">2 0 4 4</span><br><span class="line">6 4 0 2</span><br><span class="line">5 4 2 0</span><br><span class="line">输出：</span><br><span class="line">13</span><br></pre></td></tr></table></figure></li></ol><p>典型的TSP问题，据说动态规划能够得到理论最优解，<del>然而本渣看不懂状态转移方程</del>。贪心算法：从某城市出发，每次在未到达的城市中选择最近的一个，直到遍历完所有城市，最后回到出发地。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1&lt;&lt;30;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m[<span class="number">20</span>][<span class="number">20</span>], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> edge_count = <span class="number">0</span>, flag[<span class="number">20</span>] = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>, next;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (edge_count &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[j] &amp;&amp; m[cur][j] &amp;&amp; m[cur][j] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                next = j;</span><br><span class="line">                min = m[cur][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += m[cur][next];</span><br><span class="line">        flag[next] = <span class="number">1</span>;</span><br><span class="line">        edge_count++;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res += m[cur][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="5" type="1"><li>过河 <imgsrc="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113646291-699967742.png"alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">4</span><br><span class="line">1 1 1 1</span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>每次过河只能2个或3个人，这种过河问题遵循<strong>能者多劳</strong>原则，即花费时间少的人折返去接其他人。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>], dp[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">        dp[<span class="number">2</span>] = a[<span class="number">1</span>], dp[<span class="number">3</span>] = a[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//前i个人过河的最短时间</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>( dp[i - <span class="number">1</span>] + a[<span class="number">0</span>] + a[i - <span class="number">1</span>],dp[i - <span class="number">2</span>] + a[<span class="number">1</span>] + a[i - <span class="number">1</span>] );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></algorithm></cstdio></cstdio></int></int></vector></cmath></cstdio>&lt;/pair&lt;int,&gt;&lt;/int,&gt;</algorithm></map></utility></cstdio></node></queue></string></algorithm></cstdio></iostream></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Simple Math Problems</title>
      <link href="/posts/simple-math-problems/"/>
      <url>/posts/simple-math-problems/</url>
      
        <content type="html"><![CDATA[<h2 id="最大公约数-最小公倍数">最大公约数 &amp; 最小公倍数</h2><p>Euclid's Algorithm：若<spanclass="math inline">\(b\neq0\)</span>，那么<spanclass="math inline">\(gcd(a,b)=gcd(b,a\%b)\)</span><br />若<span class="math inline">\(a&lt;b\)</span>，定理会先交换a和b.0和任意正整数a的gcd是a <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        res = <span class="built_in">gcd</span>(num, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度<spanclass="math inline">\(O(lgb)\)</span>，因为每次递归问题规模都会缩减一半以上。<br />最小公倍数<span class="math inline">\(lcm=\frac{a*b}{gcd}\)</span></p><ul><li>扩展欧几里得算法</li></ul><p>可以计算出满足下式的三元组<spanclass="math inline">\((d,x,y)\)</span>： <span class="math display">\[d= GCD(a, b) = ax + by\]</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extendEuclid</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == b) &#123;</span><br><span class="line">        *x = <span class="number">1</span>, *y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gcd = extendEuclid(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp - (*y) * (a / b);</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 简单证明：<br /><span class="math inline">\(b=0\)</span>是递归基，易得一组解<spanclass="math inline">\(x=1,y=0\)</span>;<br /><span class="math inline">\(b \neq0\)</span>时：<br />首先递归求解：<br /><span class="math display">\[d&#39;=gcd(b,a\%b)=bx&#39;+(a\%b)y&#39; \ \\ \ \  \ \ \ \ \ \ \ \ \ (1)\]</span> 我们知道： <spanclass="math display">\[d=gcd(a,b)=d&#39;=gcd(b,a\%b)\ \ \ \ \ \ \ \ \ \\ \ \ (2)\]</span> <span class="math display">\[a\%b=a-b*\biggl\lfloora/b \biggr\rfloor\ \ \ \ \ \ \ \ \ \ \ (3)\]</span> 将(2)(3)式带入(1)：<span class="math display">\[d=bx&#39;+(a-b\biggl\lfloor a/b\biggr\rfloor)y&#39;=ay&#39;+b(x&#39;-\biggl\lfloor a/b \biggr\rfloory&#39;)\]</span> 所以，令<span class="math inline">\(x=y&#39;\)</span>,<span class="math inline">\(y=x&#39;-\biggl\lfloor a/b \biggr\rfloory&#39;\)</span>，就可以满足<spanclass="math inline">\(d=ax+by\)</span></p><h2 id="素数">素数</h2><ul><li>判断素数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="comment">// 1不是素数，也不是合数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> square_root = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= square_root; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>打素数表</li></ul><p>第一种方法是枚举判断, <spanclass="math inline">\(O(n^{1.5})\)</span>.<br />第二种是Eratosthenes筛法，复杂度<span class="math inline">\(O(nlog\logn)\)</span>. <imgsrc="https://img-blog.csdnimg.cn/6187ce5f6b95419d907f6e8d094d163f.png"alt="image" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isprime[<span class="number">100005</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">fill</span>(isprime, isprime + <span class="number">100005</span>, <span class="literal">true</span>);</span><br><span class="line">    isprime[<span class="number">0</span>] = <span class="literal">false</span>, isprime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; <span class="number">100005</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; <span class="number">100005</span>; j += i) &#123;</span><br><span class="line">                isprime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100005</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步的优化是欧拉筛，复杂度<span class="math inline">\(O(n)\)</span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isprime[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">fill</span>(isprime, isprime + n + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i])</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isprime[p * i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分解质因子">分解质因子</h2><p>每个数都可以分解为质数的乘机, 注意1要特判.</p><p>枚举小于等于sqrt(n)内的所有质因子, 判断哪个是n的因子.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">primeBreak</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; facs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; primes[i] * primes[i] &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (n % primes[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!facs.<span class="built_in">empty</span>() &amp;&amp; facs.<span class="built_in">back</span>().first == primes[i]) &#123;</span><br><span class="line">                facs.<span class="built_in">back</span>().second += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                facs.<span class="built_in">push_back</span>(&#123;primes[i], <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            n /= primes[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        facs.<span class="built_in">push_back</span>(&#123;n, <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> facs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分数">分数</h2><p>PAT甲1088是比较经典的分数处理问题，求2个分数的和、差、积、商，输出最简形式。<br />表示、化简、运算、输出，代码阐释得很清楚。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line">        ll nume,deno;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.deno &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                a.deno = -a.deno;</span><br><span class="line">                a.nume = -a.nume;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.nume == <span class="number">0</span>) &#123;</span><br><span class="line">                a.deno = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">int</span> d = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(a.nume),<span class="built_in">abs</span>(a.deno));</span><br><span class="line">               a.nume /= d;</span><br><span class="line">               a.deno /= d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">add</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.deno;</span><br><span class="line">        res.nume = a.deno * b.nume + a.nume * b.deno;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">sub</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.deno;</span><br><span class="line">        res.nume = a.nume * b.deno - a.deno * b.nume;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">times</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.deno;</span><br><span class="line">        res.nume = a.nume * b.nume;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">divide</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.nume;</span><br><span class="line">        res.nume = a.nume * b.deno;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFrac</span><span class="params">(Fraction a)</span> </span>&#123;</span><br><span class="line">        a = <span class="built_in">reduction</span>(a);</span><br><span class="line">        <span class="keyword">if</span>(a.nume &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.deno == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a.nume);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(a.nume) &gt; <span class="built_in">abs</span>(a.deno)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld/%lld&quot;</span>,a.nume / a.deno,<span class="built_in">abs</span>(a.nume) % a.deno,a.deno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,a.nume,a.deno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.nume &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Fraction a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld%lld/%lld&quot;</span>,&amp;a.nume,&amp;a.deno,&amp;b.nume,&amp;b.deno);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; + &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(<span class="built_in">add</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; - &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(<span class="built_in">sub</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(<span class="built_in">times</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; / &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(b.nume == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Inf\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">showFrac</span>(<span class="built_in">divide</span>(a,b));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="reference">Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/100051075">素数筛</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mobile Communication</title>
      <link href="/posts/mobile-communication/"/>
      <url>/posts/mobile-communication/</url>
      
        <content type="html"><![CDATA[<p>最近面试有被问到LTE，感觉说得不太清楚，重新整理一遍。</p><h2 id="第一代移动通信系统">第一代移动通信系统</h2><p>1G，诞生于1980年左右。<strong>模拟通信系统</strong>，抗干扰性能差，使用FDMA技术，主要用来传输<strong>话音</strong>信号，最拉风的就是“大哥大”。<br />采用蜂窝组网，又叫小区制移动通信。将网络服务区划分为许多cell，每个cell设置一个基站，移动站的发送和接收都要通过基站进行。<br />1G的制式有很多种：瑞士、荷兰、俄罗斯等使用的NMT，美国、澳大利亚使用的AMPS，英国使用的TACS等。</p><h2 id="第二代移动通信系统">第二代移动通信系统</h2><p>2G是<strong>数字通信系统</strong>，因此抗干扰能力大大增强。同时引入了CDMA和TDMA技术，提供了<strong>低速数字通信</strong>（短信）服务。<br />2G的制式主要是欧洲的GSM(Global System for Mobile Communication)。<br />不久，2G就演变为了支持<strong>数据服务</strong>的2.5G（能上网）。2.5G包括了GPRS(GeneralPacket Radio Service)和EDGE(Enhanced Data rate for GSM Evolution)。</p><h2 id="第三代移动通信系统">第三代移动通信系统</h2><p>3G主要采用了CDMA技术，使用混合的交换机制（电路交换、分组交换），可以提供丰富的多媒体服务（话音、数据、视频等）。<br />3G的标准主要有三种：欧洲的WCDMA（中国联通采用）、美国的CDMA2000（中国电信使用）、中国的TD-SCDMA（中国移动使用）。<br />制定标准的过程也是利益冲突与妥协的过程，欧洲这边成立了3GPP组织，美国主导了3GPP2组织，中国当然是加入了3GPP。</p><h2 id="第四代移动通信系统">第四代移动通信系统</h2><p>国际电信联盟（ITU）提出了4G的需求，4G的大名是IMT-Advanced(InternationalMobile Telecommunications-Advanced)。<br />4G标准的制定者，一个是3GPP，一个是IEEE。<br />3GPP提出了LTE(Long-TermEvolution)和LTE-Advanced，IEEE提出了WirelessMAN-Advanced。<br />LTE是3G和4G之间的过渡技术，也被称为3.9G。由于高通放弃了3GPP2转而投向LTE的怀抱，所以LTE应用得很广泛。</p><p>LTE相比于2G/3G频率变高、频段变宽，根据香农定理，提高频谱带宽或者信噪比可以提高信道容量，但是无线通信中要提升信噪比是比较困难的。高频段频谱资源丰富，相对低频段来说比较纯净，干扰较小，可分配的带宽比较大，同频段的连续频谱进行载波聚合也比较容易。</p><p>缺点的话：高频段路径损耗大、绕射能力差，因此覆盖距离和覆盖深度都不如低频段，当然频段过低可能造成越区覆盖，进而信噪比恶化，切换失败导致掉话。因此需要频段适中来组网。</p><p>EPC(Evolved Packet Core)：<ahref="https://www.zhihu.com/question/22365275/answer/21805286">演进的分组核心网</a>是4G的核心网，</p><p>PTN(Packet TransportNetwork)：3G/4G的分组传送网，用于传输IP包和以太网帧，</p><p>数据通信网络：</p><h2 id="部分部门内网禁止访问互联网">部分部门内网禁止访问互联网</h2><p><imgsrc="https://img-blog.csdnimg.cn/b40f033d64a74b91bb7c24677814398a.png"alt="网络拓扑结构" />假设一台PC机为普通部门，可以接入外网；另一台PC机为涉密部门，不能接入外网。两台PC机与三层交换机连接，三层交换机与路由器1连接，路由器通过PTN传输与能连接公网的路由器2连接。<br />可接入外网的PC机在三层交换机当中有路由表，可以通过PTN传输与公网连接，禁止接入外网的PC机无法查到路由表，不能与公网连接。<br />配置三层交换机与两个路由器。路由器通过PTN传输与另一台能访问公网的路由器相连接。</p><p>同一部门位于相同的子网段设置为同一VLAN互通，不同的部门位于不同的网段通过三层交换机的路由功能，实现不同VLAN间互通。</p><p>在配置三层交换机与路由器R1的OSPF协议时，私密部门的网段不加入路由协议中。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Information Engineering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 3</title>
      <link href="/posts/interview-3/"/>
      <url>/posts/interview-3/</url>
      
        <content type="html"><![CDATA[<p><em>菊厂的面试本来没打算记录，因为当时投的是非技术岗（技术支持）。为了全面，就寥做记录。</em><em>菊厂的面试因为有口头保密协议，所以不能透露具体题目。</em></p><h1 id="群面">0 群面</h1><p>简历通过筛选后，会有短信通知去面试。非技术岗第一轮是所谓“集体面试”，持续1.5h，菊厂两种形式：小组讨论（6人及以下）、小组辩论（12人分2组，6人/组）。小组讨论一般是3位面试官会给一个问题，要求讨论之后给出一个解决方案；小组辩论在分好组之后，会有一个简短的自我介绍环节；接着拿到辩题，会有15~20Min左右的组内讨论时间；讨论完毕后，每组需要选一个发言人阐述本方论点（建议口才不是很好的同学不要抢这个发言人）；再下来就是针对对方的论点论据进行辩论（这时候一定要积极举手回答）；最后会让每个人选一个要淘汰的本组同学并阐明理由，之后面试官进行总结。群面结束后，没有通过的人就可以回家了。我其实比较讨厌辩论，感觉就是两组人围绕着两个极端去互相反驳对方，可是明明很多时候是完全可以trade-off的，并不是非此即彼。</p><h1 id="半技术面">1 半技术面</h1><p>之所以叫做半技术面，是因为菊厂非技术岗的二面有点XX。据说会根据你的专业背景提问，如果不太对口就不会提问技术问题。很不幸，我的面试官原来也是学通信的。简单聊了下简历上的项目之后，就开始疯狂追问网络问题，我可能没太get到他的point，交流不太顺畅，这一面表现不太好。不过不知道是不是因为长太帅了（捂脸~），这一面竟然给过了。</p><h1 id="高管面">2 高管面</h1><p>通过二面后，会把你请到一个逼格有点高的地方，等着被高管临幸。这种聊的就比较随意了，侃天侃地侃人生。你的人生有嘛规划啊，你遇到最大的挫折是嘛啊，怎么克服的啊，你了解华为公司嘛......如果要把你派到非洲，愿不愿意啊，三年你愿意，十年你愿意么？总之，华为的文化就是你要绝对服从公司的安排，不怕吃苦，不怕牺牲，为公司倾情奉献。。。最后你有什么问题的话，可以问他。</p><h1 id="英语测试">3 英语测试</h1><p>如果通过前三轮面试，最后有一个英语测试。这个不知道什么标准，反正差不多三部分：1、单选题；2、朗读句子？（记不清了）；3、给2个topic，说一段话。我这感人的口语水平，第三部分噼里啪啦自己都不知道说的啥。。。全部完成后，就可以回去等消息了。 P.s.即使四轮面试全部通过，也不意味着就能拿到offer。熟悉菊厂的同学都知道有个资源池，过面试后先进池子里泡着，公司会根据HC和前一批的违约情况从池子里分批捞人，建议不要一棵树上吊死。<em>其它菊厂面经 ：https://zhuanlan.zhihu.com/p/24427674</em></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 2</title>
      <link href="/posts/interview-2/"/>
      <url>/posts/interview-2/</url>
      
        <content type="html"><![CDATA[<p>吐槽下ZZ的面试安排：面试时间12：30不说了，周围没有饭店，中午就没吃饭。。。不像其他公司给每个人安排不同的面试时间，这样可以节约大家的时间，SPDB是把一大批人都安排在了12：30，而且面试是5个面试官对一个人，生生地把可以并行的工作给整废了，大部分时间都浪费在了无意义的等待上。</p><h2 id="机试">机试</h2><p>50min三道题，考察地很基础，基本之前都练过。利用的是<ahref="http://hustoj.com/oj/">华科的OJ</a>，IDE有Dev-C++、Eclipse、PyCharm，Dev-C++没太用过，所以调试得很慢很慢。。。</p><ol type="1"><li><ahref="http://acm.hdu.edu.cn/showproblem.php?pid=2051">十进制转二进制</a>“除基取余，逆序排列”。每次将要转换的数除以基数Q，将余数作为<strong>低位</strong>存储直到商为0，将所有位由高到低输出即可。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, num[<span class="number">40</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            num[len++] = n % <span class="number">2</span>;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>之所以用do...while循环，是因为如果输入为0，用while会直接跳出循环，结果出错。2. 求出200以内所有3的倍数的数字和 没啥好说的。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(i % <span class="number">3</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 3. <ahref="https://pintia.cn/problem-sets/994805342720868352/problems/994805415005503488">质因子分解</a>这题寒假练过，不过机考时候忘了，素数表打的好像有问题。。。幸亏测试数据弱，就手工写了一个数组存了前面20个素数，结果AC了。。。</p><ul><li>如果一个正整数n是一个合数，那么它的因子必然是在<spanclass="math inline">\(\sqrt n\)</span>左右两侧成对出现；</li><li>推广到质因子，如果n存在[2,n]内的质因子，那么这些质因子要么全部小于等于<spanclass="math inline">\(\sqrt n\)</span>，要么只有一个大于<spanclass="math inline">\(\sqrt n\)</span>，其余都小于等于<spanclass="math inline">\(\sqrt n\)</span>。</li></ul><p>所以算法是： 1）枚举1~<span class="math inline">\(\sqrtn\)</span>内的所有质因子，判断其是否是n的因子； 2）如果1）结束后<spanclass="math inline">\(n\geq 1\)</span>，那么其必然有且仅有一个大于<spanclass="math inline">\(\sqrt n\)</span>的质因子，记录该因子；3）输入是1要特判。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是int范围，数组开10足够了，</span></span><br><span class="line"><span class="comment">//因为2*3*5*7*11*13*17*19*23*29就超过int了，所以我手工写一个数组也足够了。。。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fac</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> cnt;  <span class="comment">//质因子x的个数</span></span><br><span class="line">&#125;fac[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == a)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sqr = <span class="built_in">sqrt</span>(<span class="number">1.0</span>*a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sqr; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(a % i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[maxn], num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//打素数表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primeTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            prime[num++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">primeTable</span>();  <span class="comment">//记得写，我好像没写这句。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">int</span> diffFacNum = <span class="number">0</span>;  <span class="comment">//n的不同质因子个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld=&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == n)  <span class="comment">//特判1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sqr = <span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举2~sqrt(n)的质因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; prime[i] &lt;= sqr; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % prime[i] == <span class="number">0</span>)  <span class="comment">//如果该质因子是n的因子</span></span><br><span class="line">            &#123;</span><br><span class="line">                fac[diffFacNum].x = prime[i];</span><br><span class="line">                fac[diffFacNum].cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//计算该质因子的个数</span></span><br><span class="line">                <span class="keyword">while</span> (n % prime[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fac[diffFacNum].cnt++;</span><br><span class="line">                    n /= prime[i];</span><br><span class="line">                &#125;</span><br><span class="line">                diffFacNum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必有一个大于sqrt(n)的质因子</span></span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fac[diffFacNum].x = n;</span><br><span class="line">            fac[diffFacNum++].cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diffFacNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, fac[i].x);</span><br><span class="line">            <span class="keyword">if</span> (fac[i].cnt &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;^%d&quot;</span>, fac[i].cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="面试">面试</h2><p>面试期间也被问到了一道题：大致意思就是有一个正整数n，找出一个比n大且每位数字之和=n的每位数字之和的最小数，比如输入050，那么输出104。我开始的思路是从n开始向上枚举，直到找到满足要求的数；其实更优的解法是：对于在050~099之间的数根本不用考虑，因为必然不满足每位数字之和=n的每位数字之和，这样可以提高效率。</p><h2 id="其它">其它</h2><p>1、语言：Java多态、C的数据类型；2、数据结构：链表是否有环（烂大街了）；3、操作系统：进程状态及转换、进程线程区别。</cmath></cstdio></cstdio></cstdio></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bias-Variance Analysis</title>
      <link href="/posts/bias-variance-analysis/"/>
      <url>/posts/bias-variance-analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>对于机器学习模型<spanclass="math inline">\(g\)</span>的泛化性能的分析不仅可以通过实验的方式进行评估，还可以从理论上进行分析，这也是learningtheory研究的一部分。</p><h2 id="推导">推导</h2><p>首先假设无噪，定义在训练集<spanclass="math inline">\(D\)</span>上学习到的模型<spanclass="math inline">\(g^{(D)}\)</span>的期望泛化误差为： <spanclass="math display">\[E_{out}(g^{(D)})=E_x[(g^{(D)}(x)-f(x))^2]\]</span> 先使用小学数学做点预备： <span class="math display">\[E_D[g^{(D)}(x)]=\bar g(x)\\E_D[g^{(D)}(x)^2]-\bar g(x)^2=E_D[(g^{(D)}(x)-\bar g(x))^2]=var(x)\\\bar g(x)^2-2E_D[g^{(D)}(x)]f(x)+f(x)^2=(\bar g(x)-f(x))^2=bias(x)^2\]</span> 不同的方式会生成不同的训练集<spanclass="math inline">\(D\)</span>，因此<spanclass="math inline">\(g\)</span>的总的期望泛化误差为： <spanclass="math display">\[E_D[E_{out}(g^{(D)})]=E_D[E_x[(g^{(D)}(x)-f(x))^2]]=E_x[E_D[(g^{(D)}(x)-f(x))^2]]\\=E_x[E_D[g^{(D)}(x)^2]-2E_D[g^{(D)}(x)]f(x)+f(x)^2]\\=E_x[E_D[g^{(D)}(x)^2]-\bar g(x)^2+\barg(x)^2-2E_D[g^{(D)}(x)]f(x)+f(x)^2]\\=E_x[var(x)+bias(x)^2]=E_x[var(x)]+E_x[bias(x)^2]=var+bias^2\]</span></p><p>如果数据有噪，还是用MSE推一个漂亮的分解，其他的损失函数可能没有这么好搞：<br />以下推导针对单条测试样例<spanclass="math inline">\((x,y)\)</span>，其中<spanclass="math inline">\(y=f(x)+\epsilon,E_D(\epsilon)=0,V_D(\epsilon)=\sigma^2\)</span>，噪声只需要均值为0即可，甚至都不需要是高斯分布。<span class="math display">\[E_D[(g^{(D)}(x)-y)^2]=E_D[(f(x)+\epsilon-g^{(D)}(x))^2]\\=E_D[\epsilon^2]+E_D[(g^{(D)}(x)-f(x))^2]+E_D[2\epsilon(g^{(D)}(x)-f(x))]\\=V_D[\epsilon]+E_D[\epsilon]^2+E_D[(g^{(D)}(x)-f(x))^2]+E_D[\epsilon]E_D[2(g^{(D)}(x)-f(x)]\\=\sigma^2+E_D[(g^{(D)}(x)-f(x))^2]\\=\sigma^2+E_D[g^{(D)}(x)-f(x)]^2+V_D[g^{(D)}(x)-f(x)]\\=\sigma^2+(f(x)-E_D[g^{(D)}(x)])^2+V_D[g^{(D)}(x)]\\=\sigma^2+(\bar g(x)-f(x))^2+var(x)=\sigma^2+bias(x)^2+var(x)\]</span> 其中测试样例噪声<spanclass="math inline">\(\epsilon\)</span>与<spanclass="math inline">\(f(x),g^{(D)}(x)\)</span>均独立，因此拆为乘积。</p><p>可以看到：bias表达的是所有可能的训练数据集训练出的所有模型的平均值与真实值的差异，variance表达的是同等规模的不同的训练数据集学习到的模型之间的差异。<br />当训练数据无穷多时，数据扰动对模型的泛化性能没有影响，variance就为0，此时复杂模型的bias通常更低，泛化能力也就更强。<br />训练数据较少时，复杂模型的variance很大，此时即使训练误差很低，泛化误差也会很高，即所谓的过拟合。</p><h2 id="refs">Refs</h2><p><ahref="https://nbviewer.org/github/tournami/Learning-From-Data-MOOC/blob/master/Homework%204.html">Biasand Variance</a><br /><ahref="https://engineering.purdue.edu/ChanGroup/ECE595/files/chapter4.pdf">LearningTheory</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java FAQ</title>
      <link href="/posts/java-faq/"/>
      <url>/posts/java-faq/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>Jar包本来在projectstructure中，按绿色按钮也可以执行，但从命令行就会报错：找不到对应的包。<br />Idea为了从命令行编译程序，必须将jar包的路径添加到系统变量classpath中，再在idea中projectstructure中添加该jar，重启计算机。</li></ol><h2 id="多线程">多线程</h2><p>Java有2种方式实现多线程：</p><p>继承<code>Thread</code>类</p><p>单线程程序即只有主方法的线程，该线程由JVM负责启动，其他线程由程序员负责启动。<code>Thread</code>类中实例化的对象代表一个线程，继承后重写<code>run()</code>方法，将该线程的功能实现放在<code>run()</code>方法中，调用<code>Thread</code>类中的<code>start()</code>方法启动线程，<code>start()</code>方法会调用覆盖后的<code>run()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>Runnable</code>接口</p><p>第一种方法的缺陷在于：如果程序需要继承其他类而非<code>Thread</code>类，但Java是单继承语言，此时就无法通过该方式实现多线程，此时就需要采用第二种方法。创建<code>Runnable</code>对象后，将其传递给<code>Thread</code>类的构造方法，调用<code>start()</code>方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较疑惑的地方在于：Java中接口和抽象类是不能实例化的，即<code>Runnable</code>接口是不能实例化的，但是代码中却<code>new Runnable()</code>。这里实际上首先构造了一个<code>implements Runnable</code>的匿名内部类，然后构造了该类的一个实例，接着用<code>Runnable</code>表示该类的类型。</p><p>不使用匿名内部类： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test hello = new Test();</span><br><span class="line">        Thread thread = new Thread(hello);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式</title>
      <link href="/posts/distributed-system/"/>
      <url>/posts/distributed-system/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="abf36269f07fd4565b7c0996070855a01666bb9134bd1cc32bba4fc9c2610292">418fac4f173397084caccc18ab9f089e90c7a29408af94da76702e54e165326bd836cbd2a724db6e192604b7c11ba5310b388d49b38ae00607fc677c7015fb1bfb9f5a7e46dfb88124dfa00f2714ef14</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-Nearest Neighbors</title>
      <link href="/posts/knn/"/>
      <url>/posts/knn/</url>
      
        <content type="html"><![CDATA[<p>k-NN可以做分类及回归，对新的测试实例t，在训练集中找与t<strong>最近</strong>的k个实例，用投票法决定t属于哪个类，显然这是一种懒惰学习。</p><p>既然要找最近的k个，就会涉及距离度量问题，下面以2个样本点（每个点有n个维度）间的距离为例枚举一些度量方式：</p><ol type="1"><li>Minkowski距离：<spanclass="math inline">\(\sqrt[p]{\sum_{i=1}^{n}|x_{1i}-x_{2i}|^p}\)</span>，p=1时是曼哈顿距离，p=2时是欧氏距离，<spanclass="math inline">\(p\to\infty\)</span>时是切比雪夫距离<spanclass="math inline">\(max_{i}|x_{1i}-x_{2i}|\)</span></li><li>标准欧式距离：为了克服欧氏距离各个维度数据粒度不一致对最终结果的影响，将每个维度标准化后采用欧氏距离的计算方法：<spanclass="math inline">\(y_{1i}=\cfrac{x_{1i}-u_i}{s_i}\)</span>，<spanclass="math inline">\(\sqrt{\sum_{i=1}^{n}(y_{1i}-y_{2i})^2}=\sqrt{\sum_{i=1}^{n}\cfrac{(x_{1i}-x_{2i})^2}{s_i^2}}\)</span></li><li>Mahalanobis Distance：修正了各维度之间的相关性及粒度不一致性<br />样本向量<span class="math inline">\(x\)</span>到均值向量<spanclass="math inline">\(u\)</span>之间的马氏距离：<br /><img src="https://img-blog.csdnimg.cn/20210201184937356.png"alt="在这里插入图片描述" /><br />样本向量<span class="math inline">\(x\)</span>到样本向量<spanclass="math inline">\(y\)</span>之间的马氏距离：<br /><img src="https://img-blog.csdnimg.cn/20210201185035296.png"alt="在这里插入图片描述" /><br />如果协方差矩阵是单位阵，即每个维度之间没有相关关系，即欧氏距离；如果协方差矩阵是对角阵，即标准欧氏距离</li><li>Bhattacharyya Distance：衡量概率分布的相似性， <spanclass="math inline">\(D_B(p,q)=-ln(BC(p,q)),BC(p,q)=\sum\sqrt{p(x)q(x)},BC(p,q)=\int\sqrt{p(x)q(x)}dx\)</span></li><li>余弦相似性</li><li>Jaccard Similarity Coefficient：衡量集合相似性：<spanclass="math inline">\(J(A,B)=\cfrac{|A\cap B|}{|A\cup B|}\)</span><br />Jaccard Distance：集合区分度：<spanclass="math inline">\(1-J(A,B)\)</span><br />假设有4个二值维度，样例A={0111}，B={1011}，则<spanclass="math inline">\(J=\frac{M_{11}}{M_{01}+M_{10}+M_{11}},J^{&#39;}=1-J\)</span>，<spanclass="math inline">\(M_{11}\)</span>表示A和B中均为1的维度个数</li><li>Pearson Correlation Coefficient：<br />总体Pearson系数：<spanclass="math inline">\(\rho=\frac{Cov(X,Y)}{\sqrt{DXDY}}\)</span><br />相关距离：<span class="math inline">\(1-\rho\)</span><br />样本Pearson系数：<span class="math inline">\(r=\frac{\sum(X_i-\barX)(Y_i-\bar Y)}{\sqrt{\sum(X_i-\bar X)^2\sum(Y_i-\barY)^2}}=\frac{1}{n-1}\sum(\frac{X_i-\bar X}{S_x})(\frac{Y_i-\barY}{S_y})\)</span></li></ol><p>除了距离度量，还有k的选择：k太小容易过拟合，k太大会使得与测试实例较远的训练样例也会起作用。</p><p>kNN的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearestNeighbor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">self, X, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; X is N*D &quot;&quot;&quot;</span></span><br><span class="line">        self.Xtr = X</span><br><span class="line">        self.ytr = y</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; X is N*D &quot;&quot;&quot;</span></span><br><span class="line">        num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># make sure output type matches input type</span></span><br><span class="line">        Ypred = np.zeros(num_test, dtype = self.ytr.dtype)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_test):</span><br><span class="line">            distances = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(self.Xtr - X[i,:]), axis = <span class="number">1</span>)</span><br><span class="line">            min_index = np.argmin(distances)</span><br><span class="line">            Ypred[i] = self.ytr[min_index]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> Ypred</span><br></pre></td></tr></table></figure><p>为了加快预测速度，可以使用k-dtree来存储训练集，本质上也是一种平衡二叉树：<br />建树的过程可以递归进行：</p><ul><li>确定划分域：对训练集，统计每个维度的方差，选择方差最大的属性，意味着沿着该维度数据比较分散，容易获得较高的分辨率</li><li>确定结点：将数据集按照划分域排序，正中间的点选为结点</li><li>确定左(值小于父亲)右（值大于父亲）孩子</li><li>设置左右孩子的parent域</li></ul><p>往往训练样例的维度是很高的，所以很难每个维度都去分割，所以sklearn中的kNN如果用k-dtree实现，会有一个参数<code>leaf_size</code>控制树的深度。<br />建好后，就可以快速查找测试样例的邻居。</p><p>假设训练集为<span class="math inline">\(X_{m\timesk}\)</span>，测试集为<span class="math inline">\(Y_{n\timesk}\)</span>，此时需要计算训练集中每条样本与测试集中每条样本的距离，为了加速矩阵运算，不能使用循环，最终结果为<spanclass="math inline">\(R_{m\times n}=X\circ X+Y\circY-2XY^T\)</span>，具体推导可以参考<ahref="https://zhuanlan.zhihu.com/p/146076139">NumPy之计算两个矩阵的成对平方欧氏距离</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 1</title>
      <link href="/posts/interview-1/"/>
      <url>/posts/interview-1/</url>
      
        <content type="html"><![CDATA[<h2 id="数据对齐存储">数据对齐存储</h2><p>在32位系统中：int占4Bytes，short占2Bytes，char占1Byte，加起来应该是7Bytes，但是下面这段代码输出却是8。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">short</span> y;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>计算机对于基本类型数据在内存中的存/储位置有些限制，即<strong>内存对齐</strong>。处理器取数据一般不按照单个字节，而是双字节、四字节等进行，假设这种存取粒度为4Bytes，也就是说处理器只能从首地址为4的倍数的地址读取数据。如果没有对齐存储，取数据会很麻烦，可能需要两次读取并且剔除掉无用的字节。每个编译器都有默认的对齐模数，那么<strong>有效对齐值=min{对齐模数，结构体中最长数据类型长度}。</strong><strong>规则1：第一个成员offset为0，其后成员的offset=min{有效对齐值，该类型字节数}；</strong><strong>规则2：结构体总大小必须为有效对齐值的整数倍，否则编译器会自动填充。</strong>再看前面的例子，int占0<sub>3，short占4</sub>5，char占6，总长度为7，不是4的整数倍，所以地址7是填充字节，共8Bytes。</p><h2 id="栈-堆不是数据结构中的栈和堆">栈 &amp;堆（不是数据结构中的栈和堆）</h2><ol type="1"><li>内存栈区 编译器自动进行分配和释放，存放局部变量、函数的参数等。Windows下栈向低地址扩展，大小只有几MB，如果开一个很大的局部数组，就会提示stackoverflow。</li><li>内存堆区malloc或者new返回的内存区域，使用完需要用户free或delete，否则容易内存泄漏。如果程序员不释放，那么结束时由操作系统回收。堆向高地址扩展，由于系统采用空闲链表存储空闲内存，所以是不连续的。系统在收到内存申请的请求后，会由低地址向高地址遍历空闲链表，找到第一个满足的空闲块，删除该结点，并将该块的首地址返回。如果分配的空间大于申请的，会将剩余部分重新链接回空闲链表。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Heap中开辟10Bytes，同时在Stack中压入p，p的值为10Bytes的首地址</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></li><li>常数区 存放字符串常量等，程序结束由系统回收。</li><li>静态区存放全局变量或者静态变量，初始化的和没有初始化的分别存放在不同的区域，程序结束后由系统释放。</li><li>代码区 存放程序代码。 ## 其它排序复杂度、人工智能概念、模型的建立等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程编程</title>
      <link href="/posts/cpp-multithreading/"/>
      <url>/posts/cpp-multithreading/</url>
      
        <content type="html"><![CDATA[<h2 id="threads-tasks">Threads &amp; Tasks</h2><p>多线程是指在一个进程中同时有多个线程运行, 这些线程间可能是独立的,也可能进行通信. C++多线程有2种基本方式:</p><ul><li>Threads: 用<code>std::thread</code>创建, 没有返回值</li><li>Tasks: 用<code>std::async</code>创建, 有返回值</li></ul><p>无论哪种方式, 都可以使用以下3种方法传参:</p><ul><li>pointer to function</li><li>functors</li><li>lambda function</li></ul><p>例如有一个求和函数<code>sum(int&amp; s, int l, int r)</code>,单线程可能耗时很久, 因此可以用多个线程同时计算多个部分和,最终累加部分和即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create and start each thread</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(sum, std::ref(partialSum[<span class="number">0</span>]), <span class="number">0</span>, <span class="number">1000</span>/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(sum, std::ref(partialSum[<span class="number">1</span>]), <span class="number">1000</span>/<span class="number">2</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main() gets blocked</span></span><br><span class="line">t1.<span class="built_in">join</span>();  <span class="comment">// wait for threads to end</span></span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>如果需要很多线程, 可以用数组: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(sum, std::<span class="built_in">ref</span>(partialSum[i]), i * step, (i + <span class="number">1</span>) * step));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (thread &amp;t : threads) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了函数指针, 还可以用Functor Object.仿函数是实现了<code>operator()</code>的<code>class/struct</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过仿函数传参: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sumFunctor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        _sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">            _sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    sumFunctor* functor = <span class="keyword">new</span> <span class="built_in">sumFunctor</span>();</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(std::<span class="built_in">ref</span>(*functor), i * step, (i + <span class="number">1</span>) * step));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>thread()</code>构造函数的第一个参数可以有2种选择:</p><ul><li>functor object: 后续无需使用仿函数的成员变量</li><li>ref(functor obj): 后续需要使用成员变量</li></ul><p>除了用引用搞定返回值, 还可以将其存储到成员变量中供后续使用.</p><p>第3种方式是用lambda function传参: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>([i, &amp;partialSum, step] &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * step; j &lt; (i + <span class="number">1</span>) * step; ++j) &#123;</span><br><span class="line">            partialSum[i] += j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果<code>sum</code>确实需要返回值<code>T</code>,可以使用<code>std::async</code>生成返回值<code>future&lt;T&gt;</code>:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;future&lt;<span class="keyword">int</span>&gt;&gt; tasks;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// create, start and push each task</span></span><br><span class="line">    tasks.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(sum, i * step, (i + <span class="number">1</span>) * step));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if future value not ready, main() blocks. similar to join()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : tasks) &#123;</span><br><span class="line">    total += t.<span class="built_in">get</span>();  <span class="comment">// wait for tasks to end and read return values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="mutex-conditional-variables">Mutex &amp; ConditionalVariables</h2><p>由于多个线程可能需要同时访问共享变量, 因此会产生race condition,对最终结果造成不确定性. 最经典的例子便是计数器: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(increase));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 100个线程,每个线程使得<code>cnt</code>增加100, 但是最终结果却未必是10000.核心原因在于<code>++cnt</code>不是原子操作, 可以粗略拆为3个阶段: 读取,加一, 写入. 因此2个线程的执行顺序可以是: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1: read(0)         inc  write(1)</span><br><span class="line">t2:        read(0)  inc         write(1)</span><br></pre></td></tr></table></figure> 更麻烦的是,read/write也不是原子操作: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1:    read1            read2 inc write</span><br><span class="line">t2: read     inc  write</span><br></pre></td></tr></table></figure> 另外, 从源码开始,编译器首先操作一波(reordering/loop unrolling), 接着CPU操作一波(out oforder execution/branch prediction), 接着是多级缓存(prefetch/buffering),最后才访问内存. 因此某个线程自认为的写入也许只是写到了自己的cache,其他线程并未感知.</p><p>可以发现: 核心在于多个线程需要竞争访问共享资源,并且线程间执行顺序不合法, 导致undefined behavior. 解决方案有3种:</p><ul><li>mutex and locks: mutex lock/unlock, lock_guard, unique_lock,shared_lock, scoped_lock</li><li><code>std::atomic</code>: memory models</li><li>abstraction: CSP, Actors, Map-Reduce</li></ul><p>所谓mutex(mutual exclusion),本质上还是为了在同一时间只有单个线程访问共享资源,使得共享资源的访问原子化.</p><p>所以计数器程序可以更正为: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;  <span class="comment">// mutex is shared by all threads</span></span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// shared memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        ++cnt;  <span class="comment">// critical section</span></span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上述代码虽然是正确的,但是可能出现意外:</p><ul><li>忘记<code>unlock</code>, 其他线程永远无法进入临界区</li><li>如果临界区抛出异常, 无法调用<code>unlock</code></li></ul><p>需要注意的是:<code>lock()</code>两次或<code>unlock()</code>两次都是未定义行为,应当避免.</p><p>为了减少意外,C++提供了<code>lock_guard</code>可以自动<code>lock/unlock</code>:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;  <span class="comment">// mutex is shared by all threads</span></span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// shared memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 构造时自动加锁, 析构时(如跳出作用域)自动解锁,这样上述2个问题就可以避免, 这就是所谓的RAII.</p><p><code>lock_guard</code>没有提供<code>lock/unlock</code>接口,不够灵活. 因此C++引入了<code>unique_lock</code>: <code>lock_guard</code>+ <code>lock/unlock</code>接口. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;  <span class="comment">// mutex is shared by all threads</span></span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// shared memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        ul.<span class="built_in">unlock</span>();</span><br><span class="line">        ul.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了提高并发效率, 可以让多个线程同时读取,于是就有了<code>shared_lock</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::shared_mutex mtx;</span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// shared memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;shared_mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;  <span class="comment">// unique_lock for writers</span></span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">shared_lock&lt;shared_mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;  <span class="comment">// shared_lock for readers</span></span><br><span class="line">        cout &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果需要多个互斥量, 那么要注意避免死锁: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>正确的处理是<code>lock()</code>, 通过all or nothing避免死锁:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">lock</span>(mtx1, mtx2);  <span class="comment">// lock both mutexes without deadlock</span></span><br><span class="line">        <span class="comment">// make sure the locked mutexes unlocked at the end of scope</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::adopt_lock)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上述代码虽然正确, 但很凌乱,因此C++17提供了<code>scoped_lock</code>, 仍然通过RAII的方式避免手动解锁:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">scoped_lock <span class="title">lck</span><span class="params">(mtx1, mtx2)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ok, 到此为止解决了互斥访问的问题, 接下来解决线程间通信的问题,由此引入条件变量. 线程间通信最经典的例子就是生产者-消费者问题,当准备好数据后, 生产者需要某种方式通知消费者:</p><ul><li>共享内存: 设置共享变量<code>data</code>和<code>ready</code>.生产者准备好数据后, 将<code>ready=true</code>;消费者忙等监测<code>ready</code>的状态.</li><li>条件变量: 为了提高效率, 生产者准备好数据后通过条件变量发送通知;消费者接到通知后才唤醒. It is all about sending a message.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line">data = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data = <span class="built_in">generateData</span>();</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        ul.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        ul.<span class="built_in">lock</span>();</span><br><span class="line">        cv.<span class="built_in">wait</span>(ul, []()&#123; <span class="keyword">return</span> ready == <span class="literal">false</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">// if blocked, ul.unlock() is called automatically</span></span><br><span class="line">        <span class="comment">// if unblocked, ul.lock() is called automatically</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(ul, []() &#123; <span class="keyword">return</span> ready; &#125;);</span><br><span class="line">        <span class="built_in">sample</span>(data);</span><br><span class="line">        ready = <span class="literal">false</span>;</span><br><span class="line">        ul.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        ul.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>wait</code>是需要2件事才能唤醒的:</p><ul><li>收到<code>cv</code>的通知: <code>cv.notify_one()</code></li><li><code>ready == true</code></li></ul><p>之所以仍然需要<code>ready</code>变量,是因为<code>wait</code>可能出现虚假唤醒的情况.</p><h2 id="生产者消费者">生产者消费者</h2><p>本质上是通过引入缓冲区来平衡生产速度和消费速度，包括单生产者-单消费者，单生产者-多消费者，多生产者-单消费者和多生产者-多消费者。</p><p><a href="">实现在这里</a></p><p>有几个需要注意的地方： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用<code>while</code>而不是<code>if</code>，因为<code>wait</code>从阻塞到返回并不一定是由<code>notify_one()</code>造成的，还可能由于其他原因导致，即伪唤醒，这样就会导致后续执行出错。</p><p>由于单独使用<code>mutex</code>可能导致死锁，因此选择使用<code>unique_lock</code>管理互斥锁。之所以不能用<code>lock_guard</code>，因为<code>lock_guard</code>只能是在构造时自动调用<code>lock()</code>上锁，析构时自动释放锁，即所谓的RAII(资源分配即初始化)，没有<code>lock()</code>和<code>unlock()</code>接口供程序员使用。</p><h2 id="多线程顺序打印">多线程顺序打印</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lk, [&amp;]() &#123; <span class="keyword">return</span> num == flag; &#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;A&#x27;</span> + num);</span><br><span class="line">        flag = (flag + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(print, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(print, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(print, <span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;main thread&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全的队列">线程安全的队列</h2><p>STL的<code>std::queue&lt;T&gt;</code>并不是线程安全的，举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 线程T1执行至此，T2此时将唯一的元素pop，T1继续</span></span><br><span class="line">    queue.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Queue</span>(<span class="keyword">const</span> Queue&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Queue&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Queue&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Queue</span>(Queue&lt;T&gt;&amp;&amp; other) &#123;</span><br><span class="line">        queue_ = std::<span class="built_in">move</span>(other.queue_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Queue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue_.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::optional&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        T tmp = queue_.<span class="built_in">front</span>();</span><br><span class="line">        queue_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> </span>&#123;</span><br><span class="line">        queue_.<span class="built_in">push</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; queue_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SharedQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SharedQueue</span>(<span class="keyword">const</span> SharedQueue&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SharedQueue&lt;T&gt;&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> SharedQueue&lt;T&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SharedQueue</span>(SharedQueue&lt;T&gt;&amp;&amp; other) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(other.mtx)</span></span>;</span><br><span class="line">        queue_ = std::<span class="built_in">move</span>(other.queue_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SharedQueue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> queue_.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        queue_.<span class="built_in">push</span>(item);</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::optional&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        T tmp = queue_.<span class="built_in">front</span>();</span><br><span class="line">        queue_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::optional&lt;T&gt; <span class="title">popBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lck, [&amp;] &#123; <span class="keyword">return</span> !queue_.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">        T tmp = queue_.<span class="built_in">front</span>();</span><br><span class="line">        queue_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;T&gt; queue_;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mtx;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">SharedQueue&lt;<span class="keyword">int</span>&gt; sq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        sq.<span class="built_in">push</span>(i);</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        std::<span class="built_in">printf</span>(<span class="string">&quot;[1]  -------   %d\n&quot;</span>, *sq.<span class="built_in">popBlock</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> front = sq.<span class="built_in">pop</span>();</span><br><span class="line">        std::<span class="built_in">printf</span>(<span class="string">&quot;[2]  -------   %d\n&quot;</span>, front ? *front : <span class="number">-1</span>);</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer2)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref">Ref</h2><p><a href="https://andrew128.github.io/ProducerConsumer/">The ProducerConsumer Problem in C++</a><br /><ahref="https://gist.github.com/ictlyh/f8473ad0cb1008c6b32c41f3dea98ef5">producer-consumer</a><br /><ahref="https://immortalqx.github.io/2022/02/08/cpp-notes-6/">生产者消费者模型</a><br /><a href="https://www.youtube.com/watch?v=3aqxaZsvn80">C++multithread</a><br /><ahref="https://zhuanlan.zhihu.com/p/355113813">使用C++手写线程安全队列</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ FAQ</title>
      <link href="/posts/cpp-faq/"/>
      <url>/posts/cpp-faq/</url>
      
        <content type="html"><![CDATA[<h2 id="指针和引用">指针和引用</h2><ol type="1"><li>指针是一个新的变量，存储另一个变量的地址，可以通过指针修改另一个变量；引用是一个别名，对引用的操作就是对变量本身的操作。</li><li>指针可以有多级；引用只有一级。</li><li>指针的大小一般4B；引用的大小一般取决于被引用对象大小。</li><li>指针可以为空；引用不能为空。</li><li>传参选择：传参时传引用与传指针效果相同，传引用，没有产生实参的副本，直接对实参操作，传指针，被调函数需要给形参分配空间，可读性差，需要传地址做实参，传引用更简单清晰。返回被调函数局部变量的内存时传指针，使用后及时释放避免内存泄漏；返回局部变量的引用没有意义，会自动销毁。传指针需要单独开辟内存；在对栈空间大小敏感时（如递归）传引用，无需创建临时变量，开销更小。类对象作为参数时传引用是C++传递类对象的标准方式。</li></ol><p>引用只是一个别名，不是一种数据类型，不占存储空间，不能建立数组的引用<br />引用必须初始化，指针不必<br />引用初始化后不能改变，指针可以改变指向的对象<br />不存在指向空值的引用，存在指向空值的指针</p><h2 id="空类">空类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sizeof(A) = 1</span></span><br></pre></td></tr></table></figure><p>空类的大小之所以为1，因为标准规定完整对象的大小&gt;0，否则两个不同对象可能拥有相同的地址，故编译器会生成1B占位符。那么两个对象为什么不能地址相同呢？</p><blockquote><p>There would be no way to distinguish between these two objects whenreferencing them with pointers.</p></blockquote><p>空类中到底都有什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>();  <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp;);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>();  <span class="comment">// 析构函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;);  <span class="comment">// 赋值运算符</span></span><br><span class="line">    A* <span class="keyword">operator</span>&amp;();  <span class="comment">// 取址运算符（非const）</span></span><br><span class="line">    <span class="keyword">const</span> A* <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;  <span class="comment">// 取址运算符（const）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>仅仅声明一个类，不会创建这些函数。只有当定义类的对象时，才会产生。</p><h2 id="多态polymorphism">多态Polymorphism</h2><p>OOP的特点包括封装、继承和多态。</p><p>封装的目的是将类的<strong>实现</strong>和<strong>使用</strong>分离，隐藏实现细节，保留部分接口和方法供外人使用，避免程序互相依赖，使得模块松耦合。<br />继承是为了复用基类中的属性和方法，实现了代码的可重用性。<br />多态按照字面意思：同一接口的多种不同的实现方式，同种操作作用于不同的对象可以产生不同的行为和执行结果。可以有效<strong>避免代码冗余重复，增加程序的可扩展性</strong>，重复是万恶之源！！</p><p>根据状态确定时间分为静态多态（模板多态）和动态多态，静态多态在编译时就确定了，支持某些公共的函数，类之间的定义是独立的；动态多态运行时确定。</p><p>静态多态主要包括函数重载和运算符重载，动态多态主要通过继承和虚函数实现。定义虚函数<code>f</code>，是为了用基类的引用或指针调用派生类的<code>f</code>，最终调用哪个<code>f</code>取决于对象的实际类型（基类还是派生类），即在运行时选择函数的版本，也就是所谓的<strong>动态绑定</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;animal&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal* animal = <span class="keyword">new</span> Dog;</span><br><span class="line">animal-&gt;<span class="built_in">f</span>();  <span class="comment">// 输出animal  </span></span><br></pre></td></tr></table></figure><p>将函数<code>f</code>改为虚函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;animal&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal* animal = <span class="keyword">new</span> Dog;</span><br><span class="line">animal-&gt;<span class="built_in">f</span>();  <span class="comment">// 输出dog </span></span><br></pre></td></tr></table></figure></p><p>当基类指针指向派生类对象，用该指针调用同名成员函数时，基类声明为虚函数（子类可以不写<code>virtual</code>）就会调用派生类的<code>f</code>，否则调用基类的<code>f</code>。</p><p>如果没有虚函数，管理大量的派生类对象<code>Dog/Cat</code>等就需要声明相应的指针，有虚函数的话，就可以声明为指针数组<code>Animal* animals[5]</code>指向相应的派生类对象，然后直接<code>animals[i]-&gt;f()</code>即可。</p><h3 id="构造函数和析构函数">构造函数和析构函数</h3><p>析构函数可以并且应当是虚函数，因为要确保执行相应对象的析构函数。如果基类指针指向派生类对象，会调用派生类的析构函数并释放资源，然后调用基类的析构函数。当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。否则<code>delete animal</code>时调用<code>Animal</code>的析构函数，<code>Dog</code>的资源未释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造时，先调用父类构造函数，再调用子类构造函数</span></span><br><span class="line"><span class="comment"> * 析构时，先调用子类析构函数，再调用父类析构函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 子类构造函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 调用父类构造函数</span></span><br><span class="line"><span class="comment"> *  2. 把CDerived的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  3. 初始化CDerived的成员变量</span></span><br><span class="line"><span class="comment"> *  4. 调用函数Init()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 父类构造函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 把CBase的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  2. 初始化CBase的成员变量</span></span><br><span class="line"><span class="comment"> *  3. 调用函数Init()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 子类析构函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 把CDerived的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  2. 调用函数Uninit()</span></span><br><span class="line"><span class="comment"> *  3. 调用父类CBase的析构函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 父类析构函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 把CBase的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  2. 调用函数Uninit()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造函数或析构函数中调用虚函数与普通函数调用方式一样，相当于调用CBase::Init()</span></span><br><span class="line"><span class="comment"> * 由于编译器对构造函数和析构函数做了特殊处理，因此不会多态</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 虚函数调用过程：</span></span><br><span class="line"><span class="comment"> *  1. 获取this指针的地址</span></span><br><span class="line"><span class="comment"> *  2. 通过this指针得到虚函数表地址，通常this指针指向vptr</span></span><br><span class="line"><span class="comment"> *  3. 虚函数表地址加上函数在表内偏移量得到函数地址</span></span><br><span class="line"><span class="comment"> *  4. 通过call命令调用函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 调用父类还是子类的函数，关键在于vptr指向父类还是子类的虚函数表</span></span><br><span class="line"><span class="comment"> * 构造函数和析构函数中，vptr均设置为指向当前类的虚函数表，因此均调用当前类的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;  <span class="comment">// 重写f</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();  <span class="comment">// 调用派生类的f()</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类指针<code>p</code>调用虚函数<code>f</code>，<code>f</code>作用的可能是基类对象，也可能是派生类对象，这就是多态（同样消息作用于不同类型对象产生不同的行为）的一种方式，即动态多态。正因为编译器无法确定使用哪个虚函数，所以所有的<strong>虚函数必须定义</strong>，否则编译器会报错。</p><p><strong>构造函数不能是虚函数</strong>：</p><p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。在构造一个对象时，<strong>由于对象还未创建成功，编译器无法知道对象的实际类型</strong>，是类本身还是类的派生类等。</p><p>2）虚函数的调用需要vptr，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，vptr还未初始化，无法调用构造函数了。</p><p>C++他爹Bjarne Stroustrup是这么说的：</p><blockquote><p>A virtual call is a mechanism to get work done given partialinformation. In particular, "virtual" allows us to call a functionknowing only an interfaces and not the exact type of the object. Tocreate an object you need complete information. In particular, you needto know the exact type of what you want to create. Consequently, a "callto a constructor" cannot be virtual.</p></blockquote><p>构造函数或者析构函数中调用虚函数会怎样？<br />在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式，无法<ahref="https://www.zhihu.com/question/35632207">实现多态</a>。<br />在析构函数中调用虚函数，此时调用的是子类的函数实现方式。</p><p>函数只声明不定义有什么问题？<br />类中普通函数没问题，虚函数链接时会报错<code>undefined reference to vtable for Base</code>，无法获取虚函数的地址并填充虚表。<ahref="https://python.iitter.com/other/173960.html">参考</a></p><p><ahref="https://www.geeksforgeeks.org/can-static-functions-be-virtual-in-cpp/">静态函数不能为虚函数</a></p><p>空指针调用普通的成员函数，如果函数体用到了this指针（访问了非静态变量），程序崩溃，否则可以正常调用不能调用虚函数（运行时报错），</p><h3 id="虚函数表-虚函数指针">虚函数表 &amp; 虚函数指针</h3><p>编译器处理虚函数的方法是：如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过vptr找到类中的虚函数表，找到相应的函数进行调用。</p><p>一个类的所有实例共享同一张虚表：</p><figure><img src="虚表.png" alt="虚函数表与虚函数指针" /><figcaption aria-hidden="true">虚函数表与虚函数指针</figcaption></figure><h3 id="纯虚函数">纯虚函数</h3><p>与虚函数必须定义相反，纯虚函数无须定义（要定义必须在类的外部），含有纯虚函数的类是<strong>抽象基类</strong>。抽象基类定义好接口，继承该类的其他类可以覆盖这个接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 声明纯虚函数</span></span><br></pre></td></tr></table></figure><p>之所以要引入纯虚函数，是因为很多时候基类产生对象是没有意义的。比如动物类可以派生出狗、猪等子类，但动物类生成对象毫无意义。因此，不能创建抽象基类的对象，派生类必须覆盖(override)以定义自己的<code>f</code>，否则派生类仍然是抽象基类。</p><p>用基类的指针（引用）调用虚函数时就发生动态绑定：运行时，虚函数根据绑定对象的实际类型，选择调用函数的版本。<ahref="https://www.nowcoder.com/questionTerminal/8262288d505d4fc599ebd9c8e7fd86ce">虚函数sizeof</a></p><h2 id="重载-覆盖-重写">重载 &amp; 覆盖 &amp; 重写</h2><ul><li>重载(overload)：在类内部发生。函数名相同，参数个数、参数类型、参数顺序至少有一种不同。返回值类型可以相同，也可不同；</li><li>覆盖(override)：覆盖基类的虚函数。函数名相同，参数相同，基类函数必须是虚函数；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span>B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;  <span class="comment">// 正确：f1与基类中的f1匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：B没有形如f2(int)的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：f3不是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：B没有名为f4的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>重写(overwrite)：派生类的函数屏蔽了同名的基类函数：派生类函数与基类函数同名，参数不同。不论基类函数是否为虚函数，都会被隐藏；派生类函数与基类函数同名，参数相同。基类函数不为虚函数，会被隐藏；</li></ul><p><ahref="https://www.zhihu.com/question/21455159">函数重载按照返回类型</a><br /><ahref="https://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html">C++函数重载</a></p><h2 id="关键字">关键字</h2><h3 id="static">static</h3><p>C++中<code>static</code>关键字用来<strong>声明类的成员</strong>：</p><ul><li>类的静态成员变量或函数属于类而非对象，只有一份副本，搞成虚函数也没有意义；</li><li>静态成员函数没有<code>this</code>指针，只能访问类的静态数据，无法访问类的成员vptr，所以静态成员函数不能定义为虚函数；</li><li>静态成员变量初始化<code>int Base::name = 0</code></li></ul><p>如果不是在类中声明成员，还有下面用法：</p><ul><li>隐藏作用：多文件编译时，定义的全局变量和函数都是整个工程可见的，只要使用时加上<code>extern</code>关键字即可。如果加上<code>static</code>关键字，那么该变量或函数就变为<strong>仅当前文件</strong>可见，这样我们可以在不同文件中定义同名的变量或函数而不用担心冲突。</li><li>全局生存期：<code>static</code>变量存储在静态数据区，默认值为0，<strong>只被初始化一次</strong>，即使作为局部变量，生存期也为整个程序，但作用域与普通变量相同，退出函数后即使变量存在，但不能使用。</li></ul><p>在C语言中主要有<ahref="https://stackoverflow.com/questions/572547/what-does-static-mean-in-c">2种用途</a>:</p><ul><li>函数内的<code>static</code>变量在函数结束后仍然保持其值;</li><li><code>static</code>全局变量/函数只能在其定义的文件中调用,可以用来进行访问控制和封装.</li></ul><h3 id="const"><ahref="https://zhuanlan.zhihu.com/p/110159656">const</a></h3><ul><li>定义const对象：一旦创建其值不能改变，故const对象必须初始化。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> bufSize = <span class="number">512</span>;  <span class="comment">// the same as the previous one</span></span><br></pre></td></tr></table></figure><p>由于const对象默认只在文件内有效，所以如果要在文件间共享：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp定义并初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>;</span><br><span class="line"><span class="comment">// file1.h可以仅声明，不初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;</span><br></pre></td></tr></table></figure><ul><li>常量指针（constpointer）：指针本身（存在指针中的地址）不可变，不能指向其他变量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;num;  <span class="comment">// p将一直指向num</span></span><br></pre></td></tr></table></figure><ul><li>指向常量的指针（pointer to const）：无法通过指针修改对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span>* p = &amp;pi;  <span class="comment">// 正确</span></span><br><span class="line">*p = <span class="number">4.1</span>;  <span class="comment">// 错误，不能通过p修改pi的值 </span></span><br></pre></td></tr></table></figure><ul><li>修饰成员函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 不能修改成员变量，const对象不能调用非const成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>修饰类对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A obj;  <span class="comment">// obj为常量对象，任何成员都不能被修改，任何非const成员函数都不能被调用</span></span><br><span class="line">obj.<span class="built_in">f1</span>();  <span class="comment">// 错误</span></span><br><span class="line">obj.<span class="built_in">f2</span>();  <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A* obj  = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">obj-&gt;<span class="built_in">f1</span>();  <span class="comment">// 错误</span></span><br><span class="line">obj-&gt;<span class="built_in">f2</span>();  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><ul><li>转为非const</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pc;  <span class="comment">// pc指向内容不可变</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);  <span class="comment">// 正确，但是通过p写值是未定义行为</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a和b必须是独立内存区域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inline">inline</h3><p>优点是没有函数调用开销，加快运行；缺点是增大代码体积，容易出现pagefault从而拖慢性能。<br /><ahref="https://algorithmlixuan.github.io/2018/10/11/c++lession4/">内联函数</a></p><h3 id="newdeletemallocfree">new/delete/malloc/free</h3><ul><li><code>new/delete</code>是C++运算符，需要编译器支持，所以不需要指定大小，返回相应对象类型的指针。<code>malloc/free</code>是库函数，不由编译器控制，需要显式指出大小，返回<code>void*</code>，需要强制类型转换。</li><li><code>new</code>会调用<code>operator new()</code>申请内存(用<code>malloc</code>实现)，调用构造函数初始化成员变量，返回相应指针，<code>delete</code>先调用析构函数，再调用<code>operator delete()</code>函数释放内存(用<code>free</code>实现)。</li><li>new分配失败会抛出<code>std::bad_alloc</code>异常。malloc分配失败返回<code>NULL</code>指针，无法完成对象的构造和析构。</li><li><code>new/delete/malloc/free</code>都是线程安全的，通过锁实现。但不是可重入的。</li></ul><h3 id="volatile">volatile</h3><p>编译器对加<code>volatile</code>关键字的变量的代码不进行编译器优化，保证对特殊地址的稳定访问。不能把他放在cache或寄存器中重复使用，防止优化编译器把变量从内存装入CPU寄存器。两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。总是重新从内存读取数据，即使前面的指令刚刚从该内存地址读取过。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a = i;</span><br><span class="line"><span class="keyword">int</span> b = i;</span><br></pre></td></tr></table></figure> 多任务间每个任务共享的标志应该<ahref="https://zhuanlan.zhihu.com/p/62060524">加volatile</a>。</p><h2 id="类型转换">类型转换</h2><p>类型转换分为隐式转换和显式转换。 显式转换有四种：</p><ul><li><code>static_cast</code> 没有底层const都可以，使用比较普遍。基类-&gt;派生类：不安全 主要执行非多态转换，代替C中的转换。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = &amp;d;</span><br><span class="line"><span class="keyword">double</span>* dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code> 运行时类型检查，将基类指针或引用安全转换为派生类的指针或引用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type是类，且有虚函数</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type*&gt;(e);  <span class="comment">//e是指针</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e);  <span class="comment">//e是左值</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e);  <span class="comment">//e不是左值</span></span><br></pre></td></tr></table></figure><ul><li><code>const_cast</code> 改变底层const。常量指针转为非常量指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cp;</span><br><span class="line"><span class="keyword">char</span>* q = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// wrong, static_cast不能用于底层const</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><code>reinterpret_cast</code>比较危险，不太用。处理无关类型转换，重新解释对象的比特模型。</li></ul><h2 id="智能指针">智能指针</h2><p><ahref="https://stackoverflow.com/questions/14482830/stdshared-ptr-thread-safety">线程安全问题1</a><br /><ahref="https://www.quora.com/Is-the-C-smart-pointer-a-thread-safe-design">线程安全问题2</a></p><blockquote><p>All member functions (including copy constructor and copy assignment)can be called by multiple threads on different instances of shared_ptrwithout additional synchronization even if these instances are copiesand share ownership of the same object. If multiple threads of executionaccess the same instance of shared_ptr without synchronization and anyof those accesses uses a non-const member function of shared_ptr then adata race will occur; the shared_ptr overloads of atomic functions canbe used to prevent the data race.</p></blockquote><p>避免内存泄漏或二次释放，引入智能指针：</p><ul><li><code>shared_ptr</code>允许多个指针指向同一个对象。通常与<code>make_shared</code>函数结合食用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p = make_shared&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br></pre></td></tr></table></figure><p>实现方式一般是referencecounting，在堆上申请资源并返回指针后，在堆上申请一个共享的引用计数器，每来一个指针指向该对象，++计数器。当计数器为0时，会自动释放指向的对象。<br />面试有可能被要求手撕一个：2个指针成员，一个指向对象，一个指向计数器<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySharePtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mySharePtr</span>() :<span class="built_in">refCnt</span>(<span class="literal">nullptr</span>), <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySharePtr</span>(T* res) :<span class="built_in">refCnt</span>(<span class="literal">nullptr</span>), <span class="built_in">ptr</span>(res) &#123;</span><br><span class="line">        <span class="built_in">add</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySharePtr</span>(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; p) :<span class="built_in">refCnt</span>(p.refCnt), <span class="built_in">ptr</span>(p.ptr) &#123;</span><br><span class="line">        <span class="built_in">add</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">mySharePtr</span>() &#123;</span><br><span class="line">        <span class="built_in">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lvalue is assigned, --counter</span></span><br><span class="line">    mySharePtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; that) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;that) &#123;</span><br><span class="line">            <span class="built_in">remove</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;ptr = that.ptr;</span><br><span class="line">            <span class="keyword">this</span>-&gt;refCnt = that.refCnt;</span><br><span class="line">            <span class="built_in">add</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr == other.ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">operator</span>==(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRef</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">            <span class="keyword">return</span> *refCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// if null, create counter = 1, else ++counter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">            ++(*refCnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            refCnt = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --counter, if counter = 0, free memory</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">            --(*refCnt);</span><br><span class="line">            <span class="keyword">if</span> (*refCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> refCnt;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                refCnt = <span class="literal">nullptr</span>;</span><br><span class="line">                ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* refCnt;</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>unique_ptr</code>看名字就知道，独占对象。离开<code>unique_ptr</code>对象的作用域时，自动释放资源，RAII。</p></li><li><p><code>weak_ptr</code> <ahref="https://www.cnblogs.com/yocichen/p/10563124.html">std::weak_ptr</a>不控制对象生命周期，作为观察者指向<code>shared_ptr</code>管理的对象，解决循环引用问题。</p></li></ul><h2 id="成员变量初始化顺序">成员变量初始化顺序</h2><p>初始化成员列表好处：</p><ol type="1"><li>const成员变量只能初始化不能赋值</li><li>引用只能在定义时初始化，不能重新赋值</li><li>高效：初始化列表比赋值操作少一次默认构造函数，因为程序要默认构造临时对象（等号右边）后才能赋值</li></ol><h2 id="指针函数和函数指针">指针函数和函数指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针函数: 返回类型是指针的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* s = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(a + b);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> (*func)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*func)(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*minus)(<span class="keyword">int</span>, <span class="keyword">int</span>) = sub;  <span class="comment">// minus是函数指针</span></span><br><span class="line"><span class="keyword">int</span>* m = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">operation</span>(<span class="number">3</span>, *m, minus);</span><br></pre></td></tr></table></figure><p><code>class</code>的成员变量和成员函数默认都是<code>private</code>，<code>struct</code>的成员变量和成员函数默认都是<code>public</code>。<code>class</code>的继承默认是私有继承，<code>struct</code>的继承默认是公有继承，公有还是私有取决于子类而非父类。<code>class</code>可以用作模板，<code>struct</code>不可以。</p><p>基类静态变量/全局变量：静态成员变量必须类外初始化派生类静态变量/全局变量基类成员变量：按照在类中定义的顺序，而不是初始化列表中的顺序派生类成员变量</p><p>范围for循环 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>&amp; i : nums)  <span class="comment">// allow modification in nums</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums)  <span class="comment">// access by value</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">CoordinateArea</span> &#123;</span> ONE, TWO &#125;;</span><br><span class="line">CoordinateArea a = CoordinateArea::ONE;</span><br></pre></td></tr></table></figure><h2 id="stl">STL</h2><p><ahref="https://www.jianshu.com/p/78c700c8d72d">C++11新特性</a>：自动类型推导、范围for、Lambda表达式、智能指针、### <ahref="https://www.cnblogs.com/linuxAndMcu/p/14621819.html">迭代器失效</a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> () &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="优先队列">优先队列</h3><p><ahref="https://zhuanlan.zhihu.com/p/344121142">优先队列的三种方式</a><br /><ahref="https://www.cnblogs.com/shona/p/12163381.html">自定义排序</a></p><h3 id="vector">vector</h3><ul><li><ahref="https://zhuanlan.zhihu.com/p/377186496">vector的push_back过程</a></li><li><ahref="https://yasenh.github.io/post/cpp-diary-2-reserve-resize/">std::vector::reserve</a></li><li><ahref="https://yasenh.github.io/post/cpp-diary-1-emplace_back/">push_backvs emplace_back</a></li><li>并发读是线程安全的，STL的所有容器并发写都<ahref="https://stackoverflow.com/questions/11144294/are-stdvectors-threadsafe">不是线程安全的</a>。</li><li><ahref="https://segmentfault.com/a/1190000041334904">扩容时也是线程不安全的</a>。vector扩容时，内存位置发生改变导致Segmentationfault错误。因为vector在扩容时会将内容全部拷贝到新的内存区域中，原有的内存区域被释放，此时如果有线程依然在向旧的内存区域读或写就会出问题。</li><li><code>clear</code>将size置0，不会改变capacity，不会释放内存，可以用<code>vector&lt;int&gt;().swap(vec)</code>来释放内存。</li></ul><h3 id="map">map</h3><p><ahref="https://zhuanlan.zhihu.com/p/48066839">map与unordered_map</a></p><h2 id="全局变量">全局变量</h2><p>Global variables in a single translation unit (source file) areinitialized in the order in which they are defined. The order ofinitialization of global variables in different translation units isunspecified.<br /><ahref="https://stackoverflow.com/questions/3746238/c-global-initialization-order-ignores-dependencies">ref1</a><br /><ahref="https://gamedev.stackexchange.com/questions/91958/why-it-s-recommended-to-keep-global-variable-initialization-and-the-objects-con">ref2</a></p><h2 id="内存池">内存池</h2><p>常规的动态内存申请需要系统调用，内核也是维护一个空闲块池，系统调用有开销。内存池在用户空间实现了内存申请释放，速度提升。</p><p>函数缺省： 某个参数有默认值，缺省参数仍在后边调用时如果略去一个参数传递，则略去后面所有</p><p>异常处理：抛出异常，没有被特定的catch语句捕获，函数调用堆栈会被解退（函数终止，销毁局部变量，控制权转到调用它的那个函数），并在下一个外层try..catch捕获，最后没有任何catch捕获，调用terminate，abort退出。</p><p>模板特化、偏特化</p><p>数据库缓存一致：并发操作导致不一致，本质上修改数据库和删除缓存耦合在一起，使得其他操作有可能读出脏数据解决方案：解耦，延迟双删：写-&gt;删缓存-&gt;修改数据库-&gt;延时-&gt;再次删缓存二：内存队列：写修改数据库，将数据id放入队列，消费者线程消费即可</p><p>操作系统 * 用户告诉操作系统执行hello程序 * 操作系统到硬盘找到该程序 *由编译程序将用户源程序编译成若干个目标模块 *由链接程序将目标模块和相应的库函数链接成装入模块 *操作系统分配内存，由装入程序将装入模块装入内存 *为执行hello程序创建执行环境（创建新进程） *操作系统设置CPU上下文环境，并跳到程序开始处 * 程序的第一条指令执行 *程序执行与printf对应的系统调用 * 操作系统分配设备 * 执行显示驱动程序 *窗口系统将像素写入存储映像区</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值引用与move</title>
      <link href="/posts/rvalue-and-move/"/>
      <url>/posts/rvalue-and-move/</url>
      
        <content type="html"><![CDATA[<p>事情起源于做CS144lab时，为了提升buffer的读写效率，将基于内存拷贝的方式改为基于内存所有权转移的方式大大提高了TCP的吞吐量，但自己一直对这些概念模棱两可，希望此文能做一些梳理。</p><h2 id="左值和右值">左值和右值</h2><p>顾名思义，左值指的是位于赋值号左侧，可以用<code>&amp;</code>取地址，表达式结束后依然存在的持久对象，在内存中占有确定位置的对象；右值位于赋值号右侧，无法取地址，表达式结束后不再存在的临时对象，不在内存中有确定位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;  <span class="comment">// a是左值，5是右值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a=<span class="number">5</span>) &#123;</span><br><span class="line">        a_ = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = <span class="built_in">A</span>();</span><br></pre></td></tr></table></figure><p>如果你试图<code>&amp;A()</code>，编译器会报错<code>error: taking address of temporary</code>。因为在该行直接用类生成的是一个临时对象，其生命周期在该行创建，在该行销毁，拿到该对象的地址没有意义。</p><h2 id="左值引用和右值引用">左值引用和右值引用</h2><p>引用是变量的别名，必须与某个变量绑定，传参时传递引用可以避免拷贝。</p><p>普通的左值引用只能指向左值，不能指向右值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref_a = a;  <span class="comment">// a是左值</span></span><br><span class="line"><span class="keyword">int</span>&amp; ref_aa = <span class="number">5</span>;  <span class="comment">// error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure>引用可以直接修改原对象，右值无地址也无法被修改，故左值引用无法指向右值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int&amp; ref_aa = 5;</span><br></pre></td></tr></table></figure><p>const左值引用不会修改指向的右值，故可以指向右值。因此经常见到使用const引用作为函数参数，如<code>push_back(const int&amp; val)</code>，否则就无法<code>push_back(5)</code>。</p><p>普通的右值引用只能指向右值，不能指向左值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ref_aa = a;  <span class="comment">// error: cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ref_a = <span class="number">5</span>;  <span class="comment">// 5是右值</span></span><br><span class="line">ref_a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></p><p>如果希望右值引用指向左值，需要通过<code>move</code>将左值转换为右值：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ref_aa = <span class="built_in">move</span>(a);</span><br><span class="line">cout &lt;&lt; a;  <span class="comment">// 仍然打印5</span></span><br></pre></td></tr></table></figure></p><p>好像与我们想象的<code>move</code>不太一样，本以为<code>move</code>可以将<code>a</code>中的值移动到<code>ref_aa</code>中，但是<code>a</code>的值却没有变化。所以可以看到<code>move</code>只是完成了强制类型转换<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>，使得右值引用可以指向左值，貌似与性能没什么关系。</p><p>实质上，右值引用之所以能指向右值，其实也是将右值提升为了左值，再用<code>move</code>将左值强制转为右值：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; ref_a = <span class="number">5</span>;  <span class="comment">// 等价于下面代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ref_a = <span class="built_in">move</span>(tmp); </span><br></pre></td></tr></table></figure></p><p>直接声明出来的左值引用和右值引用都是左值，但是右值引用也可以是右值，如果有名字就是左值，否则是右值（比如函数返回值）。</p><p>综上：右值引用既可以指向右值，也可以通过<code>move</code>指向左值，比较灵活；普通的左值引用只能指向左值，虽然const左值引用也可以指向右值，但是无法修改指向的变量，相比于右值引用也比较局限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;++n;&#125;  <span class="comment">// 编译失败，const左值引用不能修改指向的变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp;&amp; n)</span> </span>&#123;++n;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="使用场景">使用场景</h2><p>那么认知中的<code>move</code>可以提升性能又是咋回事呢？</p><p>如果没有右值引用，通常一个类如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数 深拷贝</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; tmp) &#123;</span><br><span class="line">        size_ = tmp.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size_; ++i) &#123;</span><br><span class="line">            data_[i] = tmp.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载 深拷贝</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; tmp) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"></span><br><span class="line">        size_ = tmp.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size_; ++i) &#123;</span><br><span class="line">            data_[i] = tmp.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* data_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>传参时已经通过左值引用避免了一次拷贝，但是深拷贝仍然还需要一次拷贝。此时移动构造函数就出来了：将源数据移动到新指针，丢弃源指针。为了和拷贝构造函数区分开，需要多一个参数<code>move</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; tmp, <span class="keyword">bool</span> move) &#123;</span><br><span class="line">    size_ = tmp.size_;</span><br><span class="line">    data_ = tmp.data_;</span><br><span class="line">    tmp.data_ = <span class="literal">nullptr</span>;  <span class="comment">// 防止tmp析构时删除data_</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>但是const左值引用无法修改<code>tmp.data_</code>，如果改为非const，那么可以去掉参数<code>move</code>（只有引用传递和指针传递可以用是否加const重载，故可以和拷贝构造区分），但是<code>Array a = Array(rvalue)</code>就无法使用，因为左值引用无法指向右值，即无法用右值的Array来移动构造。</p><p>所以右值引用就派上用场了： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(Array&amp;&amp; tmp) &#123;</span><br><span class="line">    size_ = tmp.size_;</span><br><span class="line">    data_ = tmp.data_;</span><br><span class="line">    tmp.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>即无需参数<code>move</code>，也可以使用右值来构造，也可以将左值用<code>std::move</code>转为右值再去构造。STL中的vector等均实现了以右值引用传参的移动构造函数和移动赋值重载函数，传递左值则拷贝，传递右值则移动。</p><p>例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span>&amp;&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp; args)</span></span>;</span><br></pre></td></tr></table></figure>如果需要拷贝对象，但是拷贝后源不再需要，可以使用<code>std::move</code>触发移动语义，避免不必要的内存拷贝，将对象的所有权从一个对象转移到另一个对象，优化性能。</p><h2 id="完美转发">完美转发</h2><p><code>std::forward&lt;T&gt;(u)</code>：当T为左值引用时，u被转换为T类型的左值；否则u被转换为T类型右值。</p><h2 id="reference">Reference</h2><p><ahref="https://zhuanlan.zhihu.com/p/335994370">一文读懂C++右值引用和std::move</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 0</title>
      <link href="/posts/interview-0/"/>
      <url>/posts/interview-0/</url>
      
        <content type="html"><![CDATA[<h2 id="造成网络延迟的可能原因">造成网络延迟的可能原因</h2><ol type="1"><li>WiFi所有用户上下行流量共用一个信道，当用户太多或者有人在下载大的资源时带宽不够，丢包；</li><li>线路质量不佳导致信噪比太低，比如光纤损耗太大等。</li></ol><h2 id="ipv6优势">IPv6优势</h2><ol type="1"><li>IPv4地址不够用，IPv6有<spanclass="math inline">\(2^{128}\)</span>个地址；</li><li>使用更小的路由表，转发速度更快；</li><li>扩充了DHCP协议，支持自动配置；安全性更高，有更好的头部格式，允许扩容......</li></ol><h2id="找到单向无环链表的中间元素若结点总数为偶数返回第二个元素">找到单向无环链表的中间元素，若结点总数为偶数，返回第二个元素</h2><p><ahref="https://leetcode.com/problems/middle-of-the-linked-list/">leetcode类似题目</a></p><p>只扫描一遍的做法：设两个指针，初始指向头结点，p1每次走两步，p2每次走一步，p1到达链尾，p2到达中间。假设链表带有头结点。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*单链表定义*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode * <span class="title">middle</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;amp;&amp;amp; fast-&amp;gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&amp;gt;next-&amp;gt;next;</span><br><span class="line">            slow = slow-&amp;gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2id="给出四个点坐标判断是否是凸四边形">给出四个点坐标，判断是否是凸四边形</h2><p>不妨扩展下该问题，给出任意n个点，判断<ahref="http://acm.hdu.edu.cn/showproblem.php?pid=2108">是否凸多边形</a>。</p><p>凸多边形就是所有内角均小于180°，方法有好几种，这里利用定点凹凸性判断：设当前三个连续的顶点<span class="math inline">\(P_0, P_1,P_2\)</span>，计算向量<span class="math inline">\(P_0P_1\)</span>, <spanclass="math inline">\(P_1P_2\)</span>的叉积，若结果为正，表示多边形顶点逆时针转；若结果为负，两向量夹角大于180°，则为凹多边形。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;p[<span class="number">600000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cross_p</span><span class="params">(point a, point b,point c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b.x - a.x) * (c.y - b.y) - (c.x - b.x) * (b.y - a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isConvex</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//叉积量值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cross_p</span>(p[i], p[(i + <span class="number">1</span>) % n], p[(i + <span class="number">2</span>) % n]) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isConvex</span>(n))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;convex\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;concave\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="两个位数在10万位以内的数乘法">两个位数在10万位以内的数乘法</h2><p><ahref="https://leetcode.com/problems/multiply-strings/">高精度</a></p><p>高精度乘法，模仿我们笔算的过程。每一位<spanclass="math inline">\(res[i + j]\)</span>的构成：<spanclass="math inline">\(res[i + j] + carry + a[i] *b[j]\)</span>，注意去掉结果的前导0。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">120</span>], b[<span class="number">120</span>], res[<span class="number">250</span>];</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">        <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lena = num1.<span class="built_in">size</span>(), lenb = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena; i++)</span><br><span class="line">            a[i] = num1[lena - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenb; i++)</span><br><span class="line">            b[i] = num2[lenb - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenb; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i + j] = res[i + j] + a[j] * b[i] + carry;</span><br><span class="line">                carry = res[i + j] / <span class="number">10</span>;</span><br><span class="line">                res[i + j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i + lena] = carry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len_res = lena + lenb;</span><br><span class="line">        <span class="comment">//去掉结果的前导0,若结果为0，保留一个0</span></span><br><span class="line">        <span class="keyword">while</span> (res[len_res - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; len_res &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len_res--;</span><br><span class="line">        &#125;</span><br><span class="line">        　　　　　　　<span class="comment">//使用字符串流将整数转为字符串</span></span><br><span class="line">        stringstream ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len_res - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans &lt;&lt; res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="其它">其它</h2><ol type="1"><li>操作系统：CPU调度，用户态&amp;内核态，IPC，各种锁，实时系统；</li><li>数据结构：判断有向图是否存在回路（拓扑排序、求最短路、关键路径、BFS），排序（快排、冒泡、选择、插入），链表是否有环；</li><li>计网：ARP、TCP/UDP、NAT、802.11ac协议，ping过程；</li><li>C++多态。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 FAQ</title>
      <link href="/posts/os-faq/"/>
      <url>/posts/os-faq/</url>
      
        <content type="html"><![CDATA[<h2 id="进程">进程</h2><h3 id="进程线程协程">进程线程协程</h3><p>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；<br />线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；<br />线程能减少并发执行的时间和空间开销；</p><ol type="1"><li>联系: 线程存在于进程内部, 一个进程可以有多个线程,一个线程只能属于一个进程.</li><li>区别: 进程是运行时程序的封装,是系统进行资源分配和资源调度（包括内存、打开的文件等）的基本单位;线程是进程的子任务, 是CPU分配和调度的基本单位. 进程创建需要系统分配内存,CPU和文件句柄等资源, 销毁时要进行相应的回收, 因此进程的管理开销大;线程开销小. 进程间不会互相影响; 一个线程崩溃会导致进程崩溃,从而影响其他线程.</li></ol><p>协程即微线程：协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p><p>线程：频繁创建销毁，需要大量计算，切换频繁，IO密集型<br />进程：稳定安全，CPU密集型</p><p><ahref="https://zhuanlan.zhihu.com/p/204965836">协程由来和概念</a><br /><ahref="https://www.zhihu.com/question/50185085/answer/183463734">协程诞生</a><br /><ahref="https://zhuanlan.zhihu.com/p/169426477">线程和协程的区别</a></p><h3 id="通信方式">通信方式</h3><p>进程间通信：</p><ul><li>管道</li><li>信号量</li><li>消息队列</li><li>信号</li><li>共享内存</li><li>套接字：<ahref="https://www.cnblogs.com/vonyao/p/3614320.html">本地socket</a></li></ul><p>线程间通信：</p><ul><li>锁机制：互斥锁 + 条件变量，读写锁</li><li>全局变量：在各线程共享的堆上，每个线程私有栈</li><li>事件event：有信号和无信号两种状态</li><li>Semaphore</li></ul><p>互斥锁用来保证线程间的互斥，条件变量控制线程间执行顺序。比如生产者消费者中，缓冲区作为共享资源每次只能有一个线程访问，线程只有获取互斥锁才能访问，<br />然而生产者访问并生产后，消费者并不知道何时缓冲区才有物品，故需要条件变量通知消费者，消费者无需忙等。<br />假如只有mutex没有cv，那么可能有忙等；<ahref="https://stackoverflow.com/questions/12551341/when-is-a-condition-variable-needed-isnt-a-mutex-enough">isn'ta mutex enough?</a><br />假如只有cv没有mutex，<ahref="https://stackoverflow.com/questions/2763714/why-do-pthreads-condition-variable-functions-require-a-mutex">Whycondition variable require a mutex?</a><br /><ahref="https://zhuanlan.zhihu.com/p/55123862">条件变量之稀里糊涂的锁</a></p><h3 id="zombie-orphan-process">Zombie &amp; Orphan Process</h3><p>孤儿进程：父进程先于子进程结束，内核控制其被init进程收养。并不是一种单独的状态。<br />僵尸进程：子进程先结束但是父进程并未回收，使得残留资源PCB在内核中，不能用kill杀死，状态是Z。</p><p>处理僵尸进程方法：</p><ol type="1"><li>杀死其父进程，使其成为孤儿进程</li><li>信号机制：子进程退出时向父进程发送SIGCHILD信号，父进程处理该信号，在处理函数中调用wait回收资源。</li></ol><p><ahref="https://www.scaler.com/topics/operating-system/zombie-and-orphan-process-in-os/">Zombie&amp; Orphan Process</a></p><h3 id="进程调度算法">进程调度算法</h3><ol type="1"><li>先来先服务(FCFS): 按照到达任务队列的顺序调度, 非抢占式, 易于实现,效率低性能差, 有利于CPU繁忙型作业(长作业)不利于IO繁忙型(短作业).</li><li>短作业优先(SJF): 每次从任务队列选择预计时间最短的作业运行, 非抢占式,性能最优, 平均周转时间最低, 吞吐量大, 不利于长作业, 会出现饥饿现象,完全未考虑作业的优先级, 不能用于实时系统.</li><li>最短剩余时间优先: 首先选择预计时间最短的作业运行,如果新作业服务时间小于当前作业的剩余时间, 抢占CPU.</li><li>高响应比优先: 在后备作业队列中选择响应比最高的, 非抢占式,需要计算响应比耗费资源. <spanclass="math inline">\(响应比=1+\frac{等待时间}{服务时间}\)</span></li><li>时间片轮转(RR): 可以响应所有用户的请求, 适于分时系统.</li><li>多级反馈队列: UNIX使用的调度算法. 多个不同优先级的队列按照RR调度,如果未完成就进入下一优先级, 新来进程可以根据优先级抢占.</li></ol><h2 id="死锁">死锁</h2><ol type="1"><li>原因: (1) 系统资源不足; (2) 进程推进顺序不当; (3) 资源分配不当.</li><li>必要条件: (1) 互斥访问: 一个资源每次只能被一个进程访问; (2)占有并请求: 进程因请求资源阻塞时对已占有的资源保持不放; (3) 不可剥夺:进程已经获取的资源不能被强制剥夺; (4) 循环等待:多个进程间形成资源的循环等待关系.</li><li>处理：资源按序编号分配，所有线程按照相同的顺序</li></ol><h2 id="文件系统">文件系统</h2><p>文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（VirtualFile System，VFS）。</p><p>https://zhuanlan.zhihu.com/p/183238194https://zhuanlan.zhihu.com/p/106459445https://zhuanlan.zhihu.com/p/27875337https://www.zhihu.com/question/284540952https://www.zhihu.com/question/51329419/answer/125389853</p><p>ext4 https://zhuanlan.zhihu.com/p/27875337</p><p>多线程访问某个方法，不论线程的执行顺序如何，都无需在主程序同步，最终的结果都是我们期望的，该方法线程安全</p><ol type="1"><li><p>我举了计数器<br /><ahref="https://zhuanlan.zhihu.com/p/32531445">如何写出线程不安全的代码</a></p></li><li><p>使用原子操作，加锁同步；可重入代码，thread-local存储，不可变对象，用volatile等避免过度优化<br /><a href="https://en.wikipedia.org/wiki/Thread_safety">Thread safety</a>,<ahref="https://developer.aliyun.com/article/254282">确保线程安全的几种方法</a></p></li><li><p><ahref="https://cs-fundamentals.com/tech-interview/c/difference-between-static-and-dynamic-linking">answer1</a><ahref="https://stackoverflow.com/questions/311882">answer2</a></p></li><li><p>并发和并行. <ahref="https://softwareengineering.stackexchange.com/questions/176169">Multiplethreads single-core CPU</a></p></li><li></li></ol><ul><li>开放定址法：线性探测，线性步长n探测，伪随机探测</li><li>拉链法</li><li>再哈希</li><li>建立公共溢出区</li></ul><ol start="2" type="1"><li><a href="https://stackoverflow.com/questions/20688982">Zombieprocess vs Orphan process</a></li><li><ahref="https://stackoverflow.com/questions/1656227/how-does-valgrind-work/">Howdoes valgrind work?</a></li><li><a href="https://www.pengrl.com/p/20020/">为什么内存对齐</a></li></ol><p>bit数组直接用char a[pow(2,24)]吗？ 拆分锁</p><p>假设限流阈值为1000QPS，每次访问都进行一次计数，超过的访问直接丢弃。1s结束后计数器清零，重新开始计数。<br />https://zhuanlan.zhihu.com/p/376564740</p><p>为了解决超出物理内存的大型程序的运行问题. 每个进程都有自己的地址空间,按pages组织, 每个page都是一段连续的地址. 部分页面被映射到物理内存,执行失败导致缺页中断.</p><p>TCP: 更加看重可靠性, 文件传输, 邮件, 浏览网页<br />UDP: 更加看重速度, 视频会议, 实时音视频, 游戏</p><p>在应用层实现ack和重传机制. <ahref="https://networkengineering.stackexchange.com/questions/16809/how-to-make-udp-reliable">makeudp reliable</a></p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -Og main.exe 生成调试信息，-Og介于O0和O1之间，在保持快速编译和良好调试体验的同时，提供较为合理的优化级别</span><br><span class="line">gdb main.exe</span><br><span class="line">break linenum  // 源代码某行打断点</span><br><span class="line">run  // 执行程序直到第一个断点</span><br><span class="line">continue  // 继续执行直到下一个断点或程序结束</span><br><span class="line">next  // 逐行执行</span><br><span class="line">print variable  // 打印变量值</span><br><span class="line">list  // 显示源代码的内容</span><br><span class="line">quit </span><br></pre></td></tr></table></figure></p><h2 id="事务">事务</h2><p>所有数据库的操作是不可分割的，要么全部执行成功，要么全部失败，不允许出现中间状态的数据。比如转账。</p><ol type="1"><li>Atomicity.一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。undolog（回滚日志）</li><li>Consistency.是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。持久性+原子性+隔离性</li><li>Isolation.数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。MVCC（多版本并发控制）或锁机制</li><li>Durability.事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 redolog （重做日志）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Science Roadmap</title>
      <link href="/posts/cs-roadmap/"/>
      <url>/posts/cs-roadmap/</url>
      
        <content type="html"><![CDATA[<p>有感于国内令人发指的CS教育(尤其某校的计算机基本就是一堆SB在自嗨自娱自乐而已)，决定自学为主。<br />主要资源是四大的比较完整的课程：video+reading+lab</p><ul><li><a href="https://github.com/prakhar1989/awesome-courses">Awesome CSCourses</a></li><li><a href="https://csdiy.wiki/">CS自学指南</a></li><li><ahref="https://conanhujinming.github.io/comments-for-awesome-courses/">名校公开课程评价网</a></li><li><a href="https://teachyourselfcs.com/">Teach Yourself ComputerScience</a></li><li><a href="https://github.com/huangrt01/CS-notes">RTHuang的自学笔记</a></li><li><a href="https://learn-sys.github.io/">LEARNSYS</a></li><li><a href="https://github.com/ossu/computer-science">OSSU</a></li></ul><p>video比较费时间，而且我看视频总是来不及反应，好像不太适合我，所以一般只在看不懂材料时去针对性地看看视频。(当然一些讲得非常好的视频除外)</p><h2 id="basics">Basics</h2><ul><li><strong>Programming Languages</strong>: 精通C,熟悉1~2门(Java/Python/C++/Go), 了解一门(Haskell/Rust),掌握debug技巧</li><li><strong>Tools/Frameworks</strong>:熟悉Linux系统的各项操作，最好看下源码，掌握Git等工具和框架</li><li><strong>Math</strong>:线性代数，概率论，数理统计，组合数学，离散数学，微积分. 现用现学</li><li><strong>Core Courses</strong>:DS/Algorithms/OS/Organization/Network/DB</li></ul><h2 id="coding-interview">Coding Interview</h2><p>没啥好说的，要么有天赋，要么很刻苦，经常在blog<strong>分析总结</strong>，<strong>穿透做过的题目及变种</strong>.<br />不要抱着可能撞到原题的心态去准备，反复练习提升自己的能力，需要有较多的训练量。</p><ul><li><strong>Data structure</strong>:哈希表、堆、AVL、链表动手实现一遍，B+树啥的都能扯扯~</li><li><strong>Algorithms</strong>: <ahref="https://leetcode-cn.com/problemset/lcof/">剑指offer</a>, <ahref="https://leetcode-cn.com/problemset/lcci/">Cracking the CodingInterview</a>, <a href="https://leetcode.com/">LeetCode</a><br /></li><li><strong>System design</strong>: 频率低但是也会有.</li></ul><h2 id="projectspaper">Projects/Paper</h2><p><strong>选一个前沿的、不太讨厌的方向，研究研究，做点小项目</strong>，具体的方向可以参考<ahref="http://csrankings.org/">CSRankings</a></p><ul><li>实习项目</li><li>学校大作业</li><li>兴趣项目</li><li>开源项目</li></ul><h2 id="关于面试">关于面试</h2><p>每家公司的风格不一, 不过总体上可以分为以下几块:</p><h3 id="笔试">笔试</h3><p>算法题为主, 不需要时空复杂度最优, 需要练习ACM模式. 可以通过<ahref="https://www.nowcoder.com/">牛客笔试题</a>, kickstart,codeforces等训练.</p><h3 id="做题">做题</h3><p>通常需要给出最优解, 多练习就是了.</p><ol type="1"><li>问清题目：数据范围是多少？这个数组的大小范围是多少？能不能给个样例？如果输入是这个，那输出应该是什么<br /></li><li>确认函数签名<br /></li><li>确认思路：修改输入数据<br /></li><li>确认corner case处理方式</li><li>编码过程中不断交流<br /></li><li>主动测试：写完后不要急于告诉面试官写完了，手动跑一个样例：在屏幕上写出中间变量的当前取值，然后用鼠标光标告诉面试官现在程序跑到了哪一行代码，当前各个变量的取值是多少等等<br /></li><li>主动分析复杂度<br /></li><li>讨论算法的trade-off</li></ol><h3 id="八股">八股</h3><p>没啥好说的, 多背就是了.</p><h3 id="项目">项目</h3><p>面国内大厂比较重要, 如果有岗位相关的项目就可以聊天了,不过一定要熟悉.</p><p>可以是实习项目, Paper, 自学项目等.</p><p>项目/research的背景主要包括场景、问题定义、需求、自己负责的部分扮演的角色等等,指出项目中的困难点和解决方案.</p><h3 id="软实力">软实力</h3><ul><li>GPA/数学/英语</li><li>比赛奖项</li><li>沟通交流能力:更是一次需要充满着沟通与交流的谈话，让面试官认为他/她愿意成为你的同事.虽然我不太懂，但是可以试着说一下, 说出自己的insight:cache不友好.获得监督信息与正反馈.</li><li>面经和技巧:面经是告诉你这家公司面试的时候喜欢问哪些知识，而不是告诉你他们喜欢问哪些特定的问题。锦上添花,最重要的还是及格的实力. Nothing replaces hard work.先拿一些自己不target的公司练练手. 模拟面试.</li></ul><h2 id="how-to-learn">How to learn</h2><p>It is very important to take classes around my future work. Itdoesn't matter you learn it slowly, the most important part is that you<strong>take it seriously</strong> and build a <strong>solidfoundation</strong>.<br />根据大佬们的经验，一门课大概要花150-300小时，每天2小时至少也要2个半月，所以千万千万不要着急，不要急于求成，总想着完成任务，多多反思自己到底学到了什么？真的透彻地理解了吗？又有多少内化到自身的知识体系？<br />还有就是最好按照他们的课表时间上课，同时上的课最好不要超过2门（经过血泪实践，我只能1门单线程┭┮﹏┭┮，他们课程内容实在太充实了...，然后自己还有一堆屁事...）</p><p><strong>严格遵守学术规范</strong>，独立完成之后可以参考别人，修正自己。</p><p>Recently I've changed my way to learn new things. Previously I justwanted to understand the new things and tried to memorize all thedetails of a specific problem, or just translated others' materials intomy words, which melted my brain and showed a very low efficiency. Thereason why I learn things this way (passively) is mostly due to theChinese's cramming education. But for me, heuristic teaching (actively)is more appropriate. The specific problem/model/algorithm is important,but the <strong>motivation</strong> is much more important.<strong>Everything has its motivation.</strong> So I decide to write myblogs with the following components:</p><ol type="1"><li>Motivation: What problems do we meet? Why propose this one?</li><li>Details: Mathematical derivation or tricky things.</li><li>Example: Use a handy example to illustrate.</li><li>Implementation: Code it out or use it to <strong>solve theproblem</strong>.</li><li>Properties: <strong>When</strong> should/can we use the method? Whenshouldn't/can't? <strong>Why</strong>? What's the benefits and drawbacksif we use it?</li><li>Can we make some improvements on the off-the-shelf method for aspecific problem?</li></ol><h2 id="done-list">DONE LIST</h2><p>Count the courses I've taken so far:</p><ol type="1"><li>Introduction to Computer Science. Harvard University<br />"This is CS 50". It should be the first class of CS rather than HaoqiangTan's C Programming Language.</li><li>Linear Algebra. Massachusetts Institute of Technology<br />If you want to learn Linear Algebra, just follow this one and you'll befine.</li><li>Mathematics for Computer Science. Massachusetts Institute ofTechnology<br />Very interesting course but I only took several lectures. SAD~</li><li>Data Structures. University of California, Berkeley<br />Strong recommend for Data Structure. You'll pick up Java from theinteresting projects.</li><li>Introduction to Computer Systems. Carnegie Mellon University<br />If you only want to take one system course, then select this one. But Ihaven't finished the whole lectures and labs. SAD again~</li><li>Introduction to Database Systems. Carnegie Mellon University<br />Hard for me. Just finished lab1. I'll come back one day~</li><li>Machine Learning. Stanford University<br />It's almost the first course I took after I found the true CS courses.But I forgot a lot. Sorry Andrew~</li><li>Positive Psychology. Harvard University<br />When I start to be anxious or depressed I'll go and find the lecture.Tal is an amazing teacher and I'm sure you'll become happier.</li><li>Convolutional Neural Networks for Visual Recognition. StanfordUniversity<br />High quality, especially its readings.</li><li>Introduction to Computer Networking. Stanford University<br />Lab is amazing!</li></ol>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 3-Way Handshake</title>
      <link href="/posts/tcp-3-way-handshake/"/>
      <url>/posts/tcp-3-way-handshake/</url>
      
        <content type="html"><![CDATA[<p>TCP是面向连接的协议，其数据传输过程分为建立连接、数据传送、释放连接三个阶段。</p><h2 id="建立连接">0 建立连接</h2><p>建立连接的过程也就是常说的“三次握手”：</p><ul><li>客户端向服务器端发送一个SYN报文（SYN=1表示这是一个连接请求或连接接收报文），并随机选取一个起始序号x；</li><li>服务器端应答一个SYN报文，同时ACK（确认位）置1【ACK=1时TCP报文段首部中的ack（确认号字段）才有效】，随机选取一个服务器端的起始序号y，并将ack字段设为x+1，表示已经收到客户端发来的SYN报文，期待收到序号为x+1的下一个报文；</li><li>客户端应答一个ACK报文，将序号设为x+1，并且ack字段设为y+1，表示已经收到服务器端的SYN报文，期待收到序号为y+1的下一个报文。</li></ul><p><em>注：序列号seq也称ISN(Initial Sequence Number)</em> <imgsrc="1.png" alt="图片来自百度" /><br />之所以要采用三次握手机制而不是两次或四次，要从握手机制的目的说起：<br />握手主要是为了确认<strong>双方的发送、接收能力</strong>是否正常，顺带初始化序号seq，为以后的数据传送做好准备，所以：<br />第一次握手：服务器收到客户端发来的网络包，<strong>服务器就明白</strong>客户端的发送能力、服务器的接收能力正常；<br />第二次握手：服务器发包，客户端收到后，<strong>客户端就明白</strong>服务器的发送、接收，客户端的发送、接收都是正常的；<br />二次握手后，客户端倒是全明白了，但是<strong>服务器端无法确认客户端能否正常接收、服务器是否正常发送</strong>，所以两次握手不够；<br />第三次握手：服务器收到客户端发送的网络包，服务器确认了自己上次的发送正常、客户端接收也正常，所以四次握手是多余的。</p><h2 id="补充问题">1 补充问题</h2><ul><li>序列号(ISN)之所以随机生成，是为了避免被攻击（若固定，则下一次传送的ack就显而易见）；</li><li>前两次握手不可以携带数据，第三次可以携带。第一次握手服务器端接收能力未知，如果携带数据就可能丢失。第二次客户端接收能力未知，如果携带数据也可能丢失。第三次客户端知道服务器接收正常，并且自己已经处于ESTABLISHED状态；</li><li>服务器发出SYN报文后，处于SYN-RCVD状态，此时不同的连接请求会被放在<strong>半连接队列</strong>里，三次握手完成后的连接请求被放在<strong>全连接队列</strong>里。</li></ul><h2 id="连接释放">2 连接释放</h2><p>连接释放的过程也就是常说的“四次挥手”：<br />P.S. <em>图中以客户端发起释放请求为例</em></p><ol type="1"><li>客户端发送释放请求，将FIN（终止位）置1，表示客户端已经发完数据，请求释放；</li><li>服务器发一个ACK报文，确认号ack为u+1，这时从客户端到服务器的连接被释放，处于<strong>半关闭状态</strong>；</li><li>如果服务器也要断开连接，就向客户端发送连接释放报文（FIN=1）；</li><li>客户端发送一个应答报文，序列号seq为u+1，等待一段时间（2MSL）确保服务器收到ACK报文，之后关闭连接。</li></ol><p><img src="2.png" alt="图片源自百度" /><br />客户端之所以要等待2MSL时间才关闭，有两个原因：</p><ul><li>一旦服务器没有收到ACK报文，服务器就会重发FIN报文，客户端再次收到FIN报文，就知道之前发送的ACK报文丢失，会重置时间等待计时器为2MSL并重传ACK报文。<br />如果没有这段等待时间，万一服务器没有正常接收ACK报文，接下来重传的FIN报文段就无法到达客户端，服务器无法正常关闭。</li><li>客户端发完最后一个ACK报文，经过2MSL，本次连接产生的报文都会从网络中消失，避免下一次新连接出现本次旧的连接请求报文段。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈与单调队列</title>
      <link href="/posts/monotonous-stack-and-queue/"/>
      <url>/posts/monotonous-stack-and-queue/</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈">单调栈</h2><p>对无重复元素的数组<spanclass="math inline">\([3,2,1,7,0,4,5,6]\)</span>，求左侧和右侧第一个比<code>nums[i]</code>大（小）的元素索引：<br />对于greater，左侧的答案为<spanclass="math inline">\([-1,0,1,-1,3,3,3,3]\)</span>，右侧的答案为<spanclass="math inline">\([3,3,3,-1,5,6,7,-1]\)</span>；<br />对于smaller，左侧的答案为<spanclass="math inline">\([-1,-1,-1,2,-1,4,5,6]\)</span>，右侧的答案为<spanclass="math inline">\([1,2,4,4,-1,-1,-1,-1]\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组中无重复值 first存左侧索引 second存右侧索引</span></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">monotonousStack</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// store index</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(nums.<span class="built_in">size</span>());  <span class="comment">// return index</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 求smaller. 若需greater, 改为 nums[i] &gt; nums[s.top()]</span></span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; nums[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            ans[idx].first = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">            ans[idx].second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        ans[idx].first = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        ans[idx].second = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果数组中存在重复元素，比如<spanclass="math inline">\([3,2,3,4,4,3,1]\)</span>：<br />对于greater，左侧的答案为<spanclass="math inline">\([-1,0,-1,-1,-1,4,5]\)</span>，右侧的答案为<spanclass="math inline">\([3,2,3,-1,-1,-1,-1]\)</span>；<br />对于smaller，左侧的答案为<spanclass="math inline">\([-1,-1,1,2,2,1,-1]\)</span>，右侧的答案为<spanclass="math inline">\([1,6,6,5,5,6,-1]\)</span></p><p>对于有重复元素，如果直接使用上述无重元素的代码，有以下情况：</p><ol type="1"><li><code>nums[i] &lt; nums[s.top()]</code>：左侧变为<spanclass="math inline">\([-1,-1,1,2,3,2,-1]\)</span>，即左侧第一个小于等于<code>nums[i]</code>的元素位置，不再是严格小于；右侧不变，仍然严格小于</li><li><code>nums[i] &lt;= nums[s.top()]</code>：左侧不变，仍然严格小于；右侧变为<spanclass="math inline">\([1,6,5,4,5,6,-1]\)</span>，即右侧第一个小于等于<code>nums[i]</code>的元素位置，不再是严格小于</li><li><code>nums[i] &gt; nums[s.top()]</code>：左侧变为<spanclass="math inline">\([-1,0,0,-1,3,4,5]\)</span>，即左侧第一个大于等于<code>nums[i]</code>的元素位置，不再是严格大于；右侧不变，仍然严格大于</li><li><code>nums[i] &gt;= nums[s.top()]</code>：左侧不变，仍然严格大于；右侧变为<spanclass="math inline">\([2,2,3,4,-1,-1,-1]\)</span>，即右侧第一个大于等于<code>nums[i]</code>的元素位置，不再是严格大于</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左边和右边第一个比nums[i]小(大)的元素索引 栈自底向上从小到大(从大到小)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中无重复值 first存左侧索引 second存右侧索引</span></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">monotonousStack</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// store index</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(nums.<span class="built_in">size</span>());  <span class="comment">// return index</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 求smaller. 若需greater, 改为 nums[i] &gt; nums[s.top()]</span></span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; nums[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            ans[idx].first = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">            ans[idx].second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        ans[idx].first = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        ans[idx].second = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中有重复值, 右侧可以沿用上面代码, 左侧不可</span></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">monotonousStackRepeat</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    stack&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; s;  <span class="comment">// store index, same number&#x27;s idx stores together</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(nums.<span class="built_in">size</span>());  <span class="comment">// return index</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 求smaller. 若需greater, 改为 nums[i] &gt; nums[s.top()]</span></span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; nums[s.<span class="built_in">top</span>()[<span class="number">0</span>]]) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; popIdx = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> leftSmallIdx = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>()[s.<span class="built_in">top</span>().<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> idx : popIdx) &#123;</span><br><span class="line">                ans[idx].first = leftSmallIdx;</span><br><span class="line">                ans[idx].second = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>() &amp;&amp; nums[i] == nums[s.<span class="built_in">top</span>()[<span class="number">0</span>]]) &#123;</span><br><span class="line">            s.<span class="built_in">top</span>().<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(&#123;i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; popIdx = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> leftSmallIdx = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>()[s.<span class="built_in">top</span>().<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx : popIdx) &#123;</span><br><span class="line">            ans[idx].first = leftSmallIdx;</span><br><span class="line">            ans[idx].second = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><p>单调队列主要用来解决: 数组中所有长度为<spanclass="math inline">\(k\)</span>的区间最值问题.</p><p>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求所有区间长度为k的最大值</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">monotonousQueue</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; q;  <span class="comment">// store index, front is the largest</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; i - q.<span class="built_in">front</span>() &gt;= k) &#123;</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[q.<span class="built_in">back</span>()]) &#123;  <span class="comment">// 改为 &lt; 即求区间最小</span></span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref">Ref</h2><p><ahref="https://www.bilibili.com/video/BV1sr4y1X7AN">1:34:00开始</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络FAQ</title>
      <link href="/posts/computer-networks-faq/"/>
      <url>/posts/computer-networks-faq/</url>
      
        <content type="html"><![CDATA[<h2 id="tcp和udp区别">TCP和UDP区别</h2><ul><li>TCP面向连接，提供可靠传输，收发数据前要3次握手建立连接，使用ACK对收发数据进行确认；UDP是无连接协议，不管对方是否收到或收到的数据是否正确</li><li>TCP提供流量控制和拥塞控制，UDP无</li><li>TCP对系统资源的要求高于UDP，因此速度稍慢</li><li>TCP数据包没有边界，会出现粘包问题，UDP包是独立的，没有粘包问题</li><li>应用时如果强调数据的完整性和正确性应用TCP，强调性能和速度时用UDP</li></ul><h2 id="tcp握手与挥手">TCP握手与挥手</h2><p>建立TCP连接的过程需要使用一些系统调用 <ahref="https://www.jianshu.com/p/f62390df9627">SYN攻击与预防</a></p><p><ahref="https://www.cnblogs.com/liwei0526vip/p/14587300.html">TCP握手</a></p><p>攻击者截取服务器回复的SYN和ACK，伪装成原主机继续通信</p><p>服务器超时重传，达到最大次数后发RST并关闭连接</p><p>客户端处于time_wait状态，同时源端口不可用，端口号很快耗尽</p><h3 id="time_wait状态">TIME_WAIT状态</h3><ol type="1"><li>why2MSL：确保ACK报文能够到达服务端，使服务端正常关闭连接。防止已失效的报文出现在新的连接中，导致数据错乱。</li><li></li></ol><p>双方的(IP, Socket)四元组不能被使用。</p><h2 id="tcp可靠传输">TCP可靠传输</h2><ul><li>16位校验和：伪首部 + TCP header二进制相加取反，丢弃</li><li>seq + ack：接收方按序组织，避免重复，确保收到所有Segments</li><li><ahref="https://stackoverflow.com/questions/12956685">超时重传</a>：发送方维护超时时间，没有收到ack就重传，即ARQ（包括停等，gobackN，选择重传）。RTO时间采用指数回退，重传超过一定次数（比如8次）就断开连接。</li><li>流量控制：收方告诉发方接收缓冲区大小，通过可变大小的滑动窗宽recv_win控制发方的发送速率</li><li>拥塞控制：发送方维持拥塞窗口cwnd记录网络链路的拥塞程度，发送窗口=min{recv_win,cwnd}。慢启动，拥塞避免，快速重传，快速恢复</li></ul><ol type="1"><li>慢启动<br />cwnd指数增加{1, 2, 4, 8, 16, ...}，超过阈值时开始拥塞避免算法</li><li>拥塞避免<br />cwnd线性增加</li><li>快速重传<br />要求接收方每收到一个失序的报文段后就立即发出重复确认而不是等待自己发送数据时才捎带确认发送方只要一连收到三个重复确认就立即重传对方尚未收到的报文段，而不必等待设置的重传计时器到期</li><li>快速恢复<br />当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，为了预防网络拥塞将拥塞窗口cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法TCP Tahoe版本与TCPReno版本的区别：Reno版本在快重传之后采用快恢复算法而不是采用慢开始算法</li></ol><h2 id="udp">UDP</h2><p>UDP对实时性要求高，数据准确性要求不是太高的场合、视频通话、QQ主要UDP为主，TCP为辅应用场景：实时音视频传输，DNS协议</p><ul><li>对延迟要求高，可靠性要求低，无法忍受重传，需要看到实时的图像和声音，中间丢一帧完全没事。</li><li>网络非常可靠，不需要考虑UDP丢包的问题。</li><li>NAT穿透只能用UDP</li></ul><h2 id="https"><ahref="https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">HTTPS</a></h2><p>HTTP协议存在安全问题：</p><ul><li>信息明文传输, 不提供数据加密, 可能被窃听</li><li>未验证通信双方身份, 可能伪装</li><li>未验证报文完整性, 可能篡改</li></ul><p>为了解决上述问题, HTTPS在HTTP的基础上增加了SSL/TLS传输层,进行安全传输.</p><ul><li>加密: 混合加密方式. 非对称加密传输session key, 对称加密传输信息.非对称加密需要公钥和私钥，公钥用来加密，私钥用来解密. 安全，不怕泄漏,速度慢. 常用算法包括RSA，ECC，DSA.对称加密计算量小，算法速度快，加密效率高,密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲,常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES.</li><li>认证: 数字证书验证双方身份.权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</li><li>完整性保护:</li></ul><p>具体细节可以参考<ahref="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂HTTPS的加密原理</a>和<ahref="https://www.cnblogs.com/wqhwe/p/5407468.html">HTTP与HTTPS的区别</a>.</p><p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p><ol type="1"><li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li><li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。服务器第一次传给客户端的公钥其实包含在CA对网站信息进行加密的数字证书中</li><li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li><li>Web服务器利用自己的私钥解密出会话密钥。</li><li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li></ol><p>客户端的对称加密密钥其实是三个随机数的哈希（1.客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3.客户端收到返回时的随机数）</p><h2 id="tcp异常连接"><ahref="https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html">TCP异常连接</a></h2><h3 id="什么情况发送rst包">什么情况发送RST包</h3><p>重建连接标识。当RST=1时，表明TCP连接中出现严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立连接。复位标志，用于非正常地关闭连接。它是TCP协议首部里的一个标志位。发送RST包关闭连接时，直接丢弃缓冲区的包发送RST包（这个和发FIN包不同）。而接收端收到RST包后，也不必发送ACK包来确认。</p><p>客户端和服务器TCP连接正常，突然服务器掉电重启，与客户端的TCP连接状态由于掉电而完全消失。之后，客户端发给服务器任何消息，都会触发服务器发RST作为回应。服务器之所以发RST，是因为连接不存在，通过Reset状态位，间接告诉客户端异常情况的存在。如果Reset顺利到达客户端，客户端意识到异常发生了，会立马释放该TCP连接所占用的内存资源（状态、数据）、以及端口号，且不会回复ACK</p><p>RST是客户端或服务器异常关闭tcp连接发的包，通常都是主机收到不存在的tcp通道的tcp报文，主机“被迫”回复RST告知对方tcp连接异常，收到RST的一方就会关闭这个socket，释放所有socket信息，且不会回复ACK</p><ol type="1"><li><p>连接未监听的端口：连接一个未监听的端口，则被连接方会发送一个RST。也就是说主机传输层TCP程序接收到一个SYN包，而这个SYN包目的端口并没有socket监听，那么主机的协议栈会直接回复一个RST</p></li><li><p>目的主机或网络路径中的防火墙拦截：</p></li><li><p>socket接收缓冲区Recv-Q中的数据未完全被应用程序读取时关闭该socket：接收到的数据缓存在缓冲区Recv-Q，它们等待被上层应用取走，如果缓冲区Recv-Q有数据未被应用取走，而此时调用了socket.close()方法强行关闭TCP连接，那么TCP协议程序发送的就不是FIN，而是RST</p></li><li><p>向已关闭的socket发送数据：主机传输层TCP协议程序接收到一条TCP数据报，而目的端口并没有socket监听，那么主机的协议栈会直接回复一个RST</p></li><li><p>向已关闭的连接发送FIN：主机传输层TCP协议程序接收到一条FIN，而目的端口并没有socket监听，那么主机的协议栈会直接回复一个RST</p></li><li><p>未开启TCPkeepalive，双方一直没有数据交互，客户端<strong>主机崩溃</strong>：服务器无法感知客户端崩溃，其TCP连接会一直处于<code>ESTABLISHED</code>状态，直到服务端重启进程。</p></li><li><p>未开启TCPkeepalive，双方一直没有数据交互，客户端<strong>进程崩溃</strong>：客户端OS能够感知到进程崩溃，发送FIN报文，正常进行四次挥手。</p></li><li><p>未开启TCPkeepalive，有数据交互，客户端<strong>主机崩溃</strong>，迅速重启：服务端发送的报文无法得到响应，触发超时重传机制，客户端重启完成后接收重传报文。此时如果客户端没有进程监听该报文的目标端口，客户端回复RST报文，断开连接；如果有进程监听，但是之前的TCP连接的数据结构已经丢失，客户端内核协议栈会发现找不到该TCP连接的socket结构体，回复RST报文，断开连接。</p></li><li><p>未开启TCPkeepalive，有数据交互，客户端<strong>主机崩溃</strong>，一直没有重启：服务端超时重传达到最大次数后，内核判定该连接有问题，通过socket接口通知应用程序，断开连接。</p></li></ol><h2 id="url解析">URL解析</h2><ol type="1"><li>域名解析，host使用DNS协议将URL解析为相应的IP</li><li>host与server通过三次握手建立TCP连接</li><li>浏览器发送HTTP请求</li><li>服务器响应请求</li><li>host接收响应并渲染</li></ol><p>子网中第一个地址是网络地址，最后一个地址是广播地址</p><p>RST 1. 直接丢弃缓冲区中的包发送RST 2. 收到RST包不必回复ACK包</p><p>常见的发RST的情况：https://zhuanlan.zhihu.com/p/30791159 1.SYN包试图连接一个没有任何服务监听的端口 2.收到了之前连接的包，但是该连接已经关闭</p><p>SYN泛洪攻击</p><p>服务器收到SYN连接请求后，分配缓冲区等资源，初始化连接变量。如果客户端的第三次ACK没有收到，服务器首先会重传SYNACK，多次重传后服务器通常会在1min后终止半连接状态并且回收资源。</p><p>客户端可以发送大量的SYN段耗尽服务器的资源，合法的请求得不到响应，就是一种典型的DoS(Denialof Service)攻击。</p><p>一般通过SYN cookies预防：对比第一次和第三次握手hash值是否相同</p><p>HTTP状态码<br />200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 400 - 请求无效403 - 禁止访问 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误</p><p>https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way</p><h2 id="http请求">HTTP请求</h2><ol type="1"><li>域名解析：首先在浏览器和OS的DNS缓存中查找，如果没有，向DNS服务器发起域名解析请求；</li><li>建立TCP连接；</li><li>发起HTTP请求；</li><li>服务器响应，浏览器获得并解析HTML，请求图片等资源，向用户渲染页面。</li></ol><p><ahref="https://www.runoob.com/http/http-status-codes.html">状态码分类</a></p><h2 id="icmp">ICMP</h2><p>验证网络是否畅通以及轨迹追踪，因为IP协议不提供可靠传输，如果丢包，IP并不能通知传输层是否丢包以及为何丢包，因此需要ICMP，网络层协议。</p><p>确认IP包是否成功到达目的地址<br />通知在发送过程中IP包被丢弃的原因：目标不可达、源抑制、超时</p><p>ping traceroute</p><h2 id="条件变量">条件变量</h2><p>用于多线程间状态的同步，控制其交替执行的先后顺序，条件不满足时相关线程阻塞，满足时唤醒，个人认为原理类似于线程间共享的全局变量，至于该变量如何工作还有待考究。</p><p>锁是用来保护共享资源，但是这两究竟有什么区别，为什么要同时使用，待确定。</p><p>lockguard构造时加锁，局部作用域结束析构释放锁，不够灵活。因此用uniquelock</p><p>shared和weak区别 循环引用导致内存泄漏</p><p>GET：完整请求一个资源，没有请求数据 POST：提交表单，文件等</p><p><a href="https://zhuanlan.zhihu.com/p/501400192">限流器</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notations</title>
      <link href="/posts/complexity-notations/"/>
      <url>/posts/complexity-notations/</url>
      
        <content type="html"><![CDATA[<p>下面四种记号是为了建立函数间的相对级别。 CLRS上的一张图很直观： <imgsrc="https://img-blog.csdn.net/20180517130818654"alt="这里写图片描述" /></p><h2 id="大o记号"><strong>大O记号</strong></h2><p>定义：如果存在正常数<span class="math inline">\(c\)</span>和<spanclass="math inline">\(n_0\)</span>，使得当<spanclass="math inline">\(N\ge n_o\)</span>时<spanclass="math inline">\(T(N)\le cf(N)\)</span>，记<spanclass="math inline">\(T(N)=O(f(N))\)</span>。</p><p>举个栗子： 当<span class="math inline">\(N &lt;1000\)</span>时，<span class="math inline">\(1000N\gtN^2\)</span>，但<spanclass="math inline">\(N^2\)</span>增长率更大，所以最终<spanclass="math inline">\(N^2\)</span>会更大，即<spanclass="math inline">\(O(N^2)=1000N\)</span>。</p><p>也就是说，总会存在某个点<spanclass="math inline">\(n_0\)</span>，从这个点以后<spanclass="math inline">\(cf(N)\)</span>至少和<spanclass="math inline">\(T(N)\)</span>一样大，忽略常数因子，即<spanclass="math inline">\(T(N)\)</span>的<strong>增长率</strong>小于等于<spanclass="math inline">\(f(N)\)</span>的增长率。</p><p>那么为什么这个常数因子<spanclass="math inline">\(c\)</span>可以忽略呢？ 当<spanclass="math inline">\(N\ge n_o\)</span>时，<spanclass="math inline">\(T(N)\le cf(N)\)</span>，也就是<spanclass="math inline">\(\frac{T(N)}{f(N)}\le c\)</span>。此时如果<spanclass="math inline">\(T(N)\)</span>的<strong>增长率</strong>大于<spanclass="math inline">\(f(N)\)</span>的增长率，那么<spanclass="math inline">\(\frac{T(N)}{f(N)}\)</span>不可能小于某个常数，也就是<spanclass="math inline">\(c\)</span>不存在，与我们的前提条件矛盾，所以说忽略掉常数因子后，<spanclass="math inline">\(T(N)\)</span>的<strong>增长率</strong>仍然小于等于<spanclass="math inline">\(f(N)\)</span>的增长率。</p><p>那么既然<span class="math inline">\(T(N)\)</span>是以不快于<spanclass="math inline">\(f(N)\)</span>的速度增长，也就可以说<spanclass="math inline">\(f(N)\)</span>是<spanclass="math inline">\(T(N)\)</span>的一个上界(upperbound)，即<strong>最坏情况</strong>。</p><h2 id="omega记号"><strong><spanclass="math inline">\(\Omega\)</span>记号</strong></h2><p>定义：如果存在正常数<span class="math inline">\(c\)</span>和<spanclass="math inline">\(n_0\)</span>，使得当<spanclass="math inline">\(N\ge n_o\)</span>时<spanclass="math inline">\(T(N)\ge cg(n)\)</span>，记<spanclass="math inline">\(T(N)=\Omega(g(n))\)</span>。</p><p>与上述大O的分析类似，可知： <spanclass="math inline">\(T(N)\)</span>的<strong>增长率</strong>大于等于<spanclass="math inline">\(g(N)\)</span>的增长率，<spanclass="math inline">\(g(N)\)</span>是<spanclass="math inline">\(T(N)\)</span>的一个下界(lowerbound)，即<strong>最好情况</strong>。</p><h2 id="theta记号"><strong><spanclass="math inline">\(\Theta\)</span>记号</strong></h2><p>定义：当且仅当<spanclass="math inline">\(T(N)=\Omega(h(n))\)</span>、<spanclass="math inline">\(T(N)=O(h(n))\)</span>时， <spanclass="math inline">\(T(N)=\Theta(f(n))\)</span>。</p><p>那么这个就是说<spanclass="math inline">\(T(N)\)</span>的<strong>增长率</strong>等于<spanclass="math inline">\(h(N)\)</span>的增长率，即<strong>最坏情况和最好情况相同</strong>。</p><h2 id="小o记号"><strong>小o记号</strong></h2><p>定义：若<span class="math inline">\(T(N)=O(p(n))\)</span>且<spanclass="math inline">\(T(N)\neq\Theta(p(n))\)</span>时， <spanclass="math inline">\(T(N)=o(f(n))\)</span>。</p><p>与大O不同，小o表示<spanclass="math inline">\(T(N)\)</span>的<strong>增长率</strong>小于<spanclass="math inline">\(p(N)\)</span>的增长率，不包括等于。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nakamori Akina</title>
      <link href="/posts/nakamori-akina/"/>
      <url>/posts/nakamori-akina/</url>
      
        <content type="html"><![CDATA[<p>听过中森明菜的歌以后，一直想写点什么。恰好前段时间看过她的一个<ahref="https://b23.tv/av13810011">访谈</a>，节目里已经39岁左右的明菜看着已经有些衰老，但是那份属于她的天真却好像要溢出屏幕。</p><p>节目里主持人问她为什么不用手机还在用电话卡，像是昭和时代穿越来的一样，她回答说自己没什么朋友去联系，一个人也不怎么去其他地方。看到这，我马上想到了《难破船》的热评：</p><figure><imgsrc="https://img-blog.csdnimg.cn/9a512b2e008947fd8936552a0aafe7dc.png"alt="网抑云热评" /><figcaption aria-hidden="true">网抑云热评</figcaption></figure><p>你可能很难想象患有严重社交障碍的她当年是怎样的风姿绰约：</p><ul><li>安利1：李健的《车站》大家应该都听过，翻唱的水准很高，不过我还是更喜欢<ahref="https://b23.tv/av5270243">《駅》</a>，这是竹内玛莉亚专门为中森明菜创作的歌曲；</li><li>安利2：<ahref="https://b23.tv/av7033508">《难破船》</a>的混剪视频，惊为天人。</li></ul><p>上世纪70年代的日本乐坛是山口百惠的天下，然而在1980年，只有20岁的山口百惠突然宣布退出娱乐圈，随后与三浦友和结婚，如此退隐使得日本乐坛出现了一片巨大的空白。</p><p>中森明菜通过选秀节目出道，甜美的外表、独特的嗓音加上经纪公司的宣传，她迅速蹿红，被誉为继山口百惠之后新的“歌姬”。</p><p>80年代中期，凭借《ミ・アモーレ》和《DESIRE-情热-》，中森明菜连续两年获得日本唱片大赏。热情的舞台形象和不俗的唱功使得她成为了当时日本乐坛无可动摇的霸主，甚至被人称为“昭和时代的LadyGaga”。后来据徐克回忆：《倩女幽魂》的聂小倩本来是邀请中森明菜扮演的，不过被拒绝了。</p><p>与在事业上的蒸蒸日上不同的是，她与近藤真彦的恋情危机开始逐渐爆发。近藤被誉为“日本第一渣男”，与松田圣子、梅艳芳等女星之间有着无数绯闻，媒体的报导更是推波助澜，中森明菜受到了很大的打击。也正是在这时候，她发布了单曲《难破船》，曲风开始变得哀伤深沉。</p><p>爱情的坎坷加上家人的天坑，中森明菜于1989年在近藤的住所割腕自杀，不过在送往医院后得救。在这一年的最后一天，为了挽救不断下滑的人气，近藤哄骗着明菜说会在记者会上宣布两人结婚，并特意在会场挂上了金屏风（婚礼常用装饰）。</p><p>傻傻的明菜出席之后，近藤在记者会上翻脸，把所有错误全部归因于明菜一个人，并且声称明菜的自杀与自己丝毫没有关系，也完全没有和明菜结婚的打算。而深陷爱情之中的明菜一个人承担了所有过错，在发布会上道歉。</p><p>之后近藤迅速与某富家女子成婚，并且利用权势限制明菜的发展。</p><p>回过头来再去听《难破船》，只觉得情到深处无怨尤：</p><blockquote><p>折れた翼広げたまま<br />展开折断的翅膀</p><p>あなたの上に落ちて行きたい<br />好想坠落在你身上</p><p>海の底へ沈んだなら<br />如果能沉入海底</p><p>泣きたいだけ抱いてほしい<br />好想你能拥抱我到尽情哭泣</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏感词过滤</title>
      <link href="/posts/sensitive-word-filtering/"/>
      <url>/posts/sensitive-word-filtering/</url>
      
        <content type="html"><![CDATA[<h2 id="需求">需求</h2><p>在一个非常大的文件中存在着很多敏感词，现在需要将这些敏感词全部替换为*，时间响应要求较高（几百毫秒）。</p><h2 id="思路">思路</h2><p>要做这个事，首先需要知道哪些词是敏感的，因此需要有一个敏感词词库。<br />例如文本是"abcdefghi"，长度为<spanclass="math inline">\(n\)</span>，敏感词库是{"de", "bca","bcf"}，词库长度为<spanclass="math inline">\(l_1\)</span>，每个词的长度为<spanclass="math inline">\(l_2\)</span>。</p><p>比较直接的做法：对每个敏感词，利用暴力匹配或KMP算法查找并作替换，这些单模式串匹配算法的缺点很明显，需要多次扫描文本<spanclass="math inline">\(O(n(l_1+l_2))\)</span>。</p><p>目前主流的做法主要是多模式串匹配算法：<br />1. Trie树：将敏感词库建树，用3个指针去搞，<ahref="https://zhuanlan.zhihu.com/p/65115496">具体在这里</a>，查询复杂度<spanclass="math inline">\(O(nl_2)\)</span>，建树复杂度<spanclass="math inline">\(O(l_1l_2)\)</span>。 2.AC自动机：是Trie树的扩展，增加了一个fail指针，避免指针回溯，<ahref="https://www.cnblogs.com/shengyang17/p/13719653.html">具体在这里</a>，复杂度一般优于Trie树。3. DFA确定有穷自动机：利用状态转移，<ahref="https://blog.csdn.net/weixin_36586120/article/details/113482752">具体在这里</a>，时间复杂度<spanclass="math inline">\(O(n)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Onedrive File Open Problem</title>
      <link href="/posts/onedrive-file-open-problem/"/>
      <url>/posts/onedrive-file-open-problem/</url>
      
        <content type="html"><![CDATA[<p>在用Onenote2016写笔记时，同步到Onedrive后就变成了Internet快捷方式，而且直接打开时会出现提示：<br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108200433406-2018295429.png"alt="image" /></p><h2 id="原因">原因</h2><p>用Onenote客户端在Onedrive上创建的笔记本是一种特殊文件，用Onedrive客户端将文件同步到本地的话，就会变成Internet快捷方式，不能直接打开；<br />但是如果用Onedrive网页版的话，就可以正常使用。</p><h2 id="解决">解决</h2><p>在Onenote客户端，“文件”-&gt;“打开”，找到你的笔记本，打开即可看到内容。</p><h2 id="参考">参考</h2><p><ahref="http://cn.onenotegem.com/24120352653838239064/-onedrive-onenote-internet-url">onedrive-onenote-internet-url</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON Introduction</title>
      <link href="/posts/json-introduction/"/>
      <url>/posts/json-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="理解">理解</h2><p>JSON（JavaScript ObjectNotation），一种轻量级的数据交换格式，基于JS的一个子集，但其数据格式与语言无关。<br />通俗来说，如果你是PHP，要和JS互相发送信息，那么这时候就可以先将PHP发的信息转为JSON，再发给JS。<br />那么有人要问了，为什么自己不能直接学会PHP和JS，直接先将PHP的信息转为JS，不就OK了？<br />没错，但是如果你要发给C++，发给Python，发给其他各种各样的语言呢？难道你要学会所有语言，再去发信息？显然不可能。<br />所以： &gt; You are now able to learn only one programming language, inaddition to the communications language, JSON, in order to communicatewith ANY other programming language.</p><p>但要注意：JSON并不是编程语言，只是一种规定的数据格式，这种格式的数据便于计算机处理。<br />JSON比较规范的定义是： &gt; JSON is the text grammer/format for theinformation that is being sent between programming language.</p><p>除了JSON以外，还有一种用于交流的数据格式，XML（Extensiable MarkupLanguage）。但是JSON更加流行。</p><h2 id="格式">格式</h2><p>JSON有两种结构：<br />1，Object：对象用<code>&#123;</code>开始，用<code>&#125;</code>结束，对象中的一系列非排序的pair中，名称和值之间用<code>:</code>分开；<br />2，Array：数组用<code>[</code>开始，用<code>]</code>结束，数组成员之间用<code>,</code>分开。<br />名称（name）是字符串；<br />值（value）可以是：字符串、数值、对象、布尔值、数组或者<code>null</code>。<br />字符串：用<code>""</code>表示；<br />数值：可以是小数或负数，也可用<code>e</code>、<code>E</code>表示为指数格式；<br />对象：就是上述的Object；<br />布尔值：<code>true</code>或<code>false</code>；<br />数组：就是上述的Array。<br />举个栗子： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object &amp; Array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Andrew&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="string">&quot;36&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;number&quot;</span>:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;12345678&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;fax&quot;</span>: <span class="string">&quot;87654321&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;address&quot;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;Beijing&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;10000&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考">参考</h2><p><ahref="https://www.quora.com/What-is-JSON-2/answers/50464172?share=8534699f&amp;srid=5OZ0m">quora</a><br /><a href="https://zh.wikipedia.org/wiki/JSON">wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System Call</title>
      <link href="/posts/system-call/"/>
      <url>/posts/system-call/</url>
      
        <content type="html"><![CDATA[<h2 id="内容">内容</h2><p>设计系统调用，将系统的相关信息(CPU型号、操作系统的版本号、系统中的进程等类似于Windows的任务管理器的信息)以文本形式列表显示于屏幕，并编写用户程序予以验证。</p><h2 id="思想">思想</h2><ul><li>系统调用是应用程序和操作系统内核之间的功能接口，可以使用户使用操作系统提供的有关设备管理、输入输出系统、文件系统和进程控制、通信以及存储管理等方面的功能，不必了解系统程序的内部结构和有关硬件细节，从而减轻用户负担、保护系统以及提高系统资源利用率的作用。</li><li>模块是在内核空间运行的程序，实际上是一种目标文件，不能单独运行但其代码可在运行时链接到系统中作为内核的一部分运行或卸载。Linux内核模块是一个编译好的、具有特定格式的独立目标文件，用户可以通过系统提供的一组与模块相关的命令将模块加载进内核，当内核模块被加载后，有如下特点：</li><li>与内核一起运行在相同的内核态和内核地址空间；</li><li>运行时与内核具有同样的特权级；</li><li>可方便地访问内核中的各种数据结构。</li><li>内核模块还可以很容易地被移出内核，当用户不再需要某模块功能时，可以从内核卸载以节省系统主存开销。</li><li>用户修改代码后，只需重新编译加载模块，不必重新编译内核和引导系统。</li></ul><h2 id="基础知识">基础知识</h2><ul><li>内核模块编程与用户态编程的区别：</li></ul><ol type="1"><li>内核模块编程不能使用C函数库，内核模块只能使用一些内核函数。比如，输出信息时使用内核函数<code>printk</code>，而不是标准库函数<code>printf</code>。</li><li>内核模块代码运行在核心态，这意味着函数使用的栈是核心栈，这个空间非常有限，一般是4KB或者8KB，所以不能定义占用很大空间的自动变量。</li><li>内核代码为了节省开销，不能使用浮点运算。</li></ol><ul><li>典型内核模块组成：</li></ul><ol type="1"><li>头文件声明。其中<code>module.h</code>和<code>init.h</code>是必不可少的。<code>Module.h</code>包含加载模块时需要的函数和符号定义；<code>init.h</code>包含模块初始化和清理函数的定义。如果在加载时允许用户传递参数，模块中还应包含<code>moduleparam.h</code>头文件。</li><li>模块许可声明。从内核2.4.10版本开始，模块必须通过<code>MODULE_LICENSE</code>宏声明此模块的许可证，否则在加载模块时会显示"kerneltainted(内核被污染)"的警告信息。从<code>linux/module.h</code>文件中可以看到，被内核接受的许可证有GPL、GPLv2、GPL and additional rights、Dual BSD/GPL、Dual MPL/GPL、DualMIT/GPL和Proprietaty。</li><li>初始化和清理函数声明。<br />内核模块必须调用宏<code>module_init</code>和<code>module_exit</code>去注册初始化和清理函数。初始化和清理函数必须在宏<code>module_init</code>和<code>module_exit</code>使用前定义，否则会出现编译错误。这两个函数配对使用，例如当初始化函数申请了一个资源，那么清理函数就应该释放这个资源，使得模块不留下任何副作用。除了模块初始化函数和清理函数，还可以根据需要设计编写其它函数。</li></ol><ul><li>proc文件系统在linux操作系统中，提供了一套在用户态检查内核状态和系统特征的机制，就是进程文件系统(processfile system)。<br />Proc文件系统将进程信息、系统的硬件信息(包括CPU、内存状态及网卡等各种硬件设备)、系统相关机制(中断、I/O)等内容全部映射为虚拟的linux文件。它以一种特殊的文件系统的方式，为访问系统内核数据的操作提供接口。这些文件的内容都不存在于任何存储设备上，而是在读/写的时候才根据系统中的有关信息生成出来，或者映射到系统中的有关变量或者数据结构。<br />系统中当前运行的每一个每一个进程都有一个对应的目录在/proc下，以进程的ID为目录名：<br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108195514838-1179859005.png"alt="image" /></li></ul><p>除了与进程有关的子目录，/proc还有一些内核信息的目录：<br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108195533943-914673534.png"alt="image" /></p><h2 id="fork">fork()</h2><p><code>fork()</code>系统调用用来创建一个子进程, 为了避免多余开销,创建子进程时并不会立即将父进程的内存页面拷贝一份, Linuxkernel将所有内存页面标记为只读并由父子进程共享,只有当需要写入这些页面时才进行拷贝, 即所谓的Copy-on-Write.</p><h2 id="实现">实现</h2><p><ahref="https://github.com/EIMadrigal/system_call">源代码、实现过程及结果</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程软中断通信</title>
      <link href="/posts/process-communication/"/>
      <url>/posts/process-communication/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>使用系统调用fork()创建两个子进程，再用系统调用signal()让父进程捕捉键盘上发出的中断信号（即按ctrl+c键），当父进程接收到这两个软中断的某一个后，父进程用系统调用kill()向两个子进程分别发出整数值为16和17软中断信号，子进程获得对应软中断信号，然后分别输出下列信息后终止：<br />Child process 1 is killed by parent !!<br />Child process 2 is killed by parent !!<br />父进程调用wait()函数等待两个子进程终止后，输入以下信息，结束进程执行：<br />Parent process is killed!!</p><p>流程图：<br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194427772-238897206.png"alt="image" /></p><h2 id="实现">实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> wait_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid1,pid2;</span><br><span class="line"></span><br><span class="line">    signal(<span class="number">2</span>,stop1);   <span class="comment">//signal 3 is ctrl+\,signal 2 is ctrl+c</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pid1 = fork()) == <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(pid1 &gt; <span class="number">0</span>)      <span class="comment">//now is in the parent process</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((pid2 = fork()) == <span class="number">-1</span>);   <span class="comment">//creat child process 2</span></span><br><span class="line">        <span class="keyword">if</span>(pid2 &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">5</span>);       <span class="comment">//sleep函数被信号中断后，就会导致延时失效，直接跳到sleep的下一行</span></span><br><span class="line">            kill(pid1,<span class="number">16</span>);  <span class="comment">//kill process1,send 16</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            kill(pid2,<span class="number">17</span>); <span class="comment">//kill process2, send 17</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nParent process is killed!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            signal(<span class="number">17</span>,stop2);   <span class="comment">//wait for 2 about 17</span></span><br><span class="line">            <span class="keyword">while</span>(wait_flag)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nChild process 2 is killed by parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        signal(<span class="number">16</span>,stop2);</span><br><span class="line">        <span class="keyword">while</span>(wait_flag)</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nChild process 1 is killed by parent!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//execute normally and quit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nParent process catches the interruption signal!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nChild process catches the interruption signal!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果">结果</h2><p>5s内没有按终止键：<br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194549740-1526578900.png"alt="image" /></p><p>5s内按下ctrl+c：<br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194609530-785223659.png"alt="image" /></p><h2 id="附">附</h2><p>系统调用signal(sig,function)：捕捉中断信号sig后执行function规定的操作。<br />参数定义：<code>int sig</code>，<code>void* func()</code><br />sig共有19个值：<br /><imgsrc="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194710456-891175051.png"alt="image" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting Algorithms</title>
      <link href="/posts/sorting-algorithms/"/>
      <url>/posts/sorting-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="bubble-sort">Bubble Sort</h2><p>冒泡排序也许是大部分人CS生涯里学到的第一种排序算法，它的基本思想是：依次比较两个相邻记录的关键字，如果逆序就进行交换，直到没有逆序的记录。</p><p>每一趟排序可以将前<spanclass="math inline">\(i\)</span>个元素的最大值冒泡到最后，因此共需<spanclass="math inline">\(n-1\)</span>趟；每一趟都要比较<spanclass="math inline">\(j\)</span>和<spanclass="math inline">\(j+1\)</span>的值，因此<spanclass="math inline">\(j\)</span>取值为<spanclass="math inline">\([0,i-1]\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[k] &gt; nums[k + <span class="number">1</span>])</span><br><span class="line">            <span class="built_in">swap</span>(nums[k], nums[k + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bubble</span>(nums, l, r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序也是可以稍稍优化的：试想如果序列是<spanclass="math inline">\([2,1,3,4,5]\)</span>，其实我们只需交换前两个元素，即第一趟有交换，走完第二趟发现没有交换时就可以结束了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> has_swap = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; has_swap; --i) &#123;</span><br><span class="line">        has_swap = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">                has_swap = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于最后优化的代码，可以看到：<br />最好的情况就是待排序列已经全部有序，这样要进行<spanclass="math inline">\(n-1\)</span>次比较，时间复杂度O(n)；<br />最坏的情况就是待排序列全部逆序，需要进行n(n-1)/2次比较，并且还有等数量级的交换，时间复杂度<spanclass="math inline">\(O(n^2)\)</span>。稳定。</p><h2 id="selection-sort">Selection Sort</h2><p>所谓选择排序，就是持续选择<spanclass="math inline">\([i+1,n-1]\)</span>中最小的元素并与<spanclass="math inline">\(i\)</span>交换，因此前面的部分必然全局有序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_id = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[min_id]) min_id = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[min_id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序需要N次交换以及<spanclass="math inline">\(\frac{N^2}{2}\)</span>次比较，数据移动次数与数组大小呈线性关系，移动次数是最少的。时间复杂度<span class="math inline">\(O(n^2)\)</span>，不稳定。</p><h2 id="insertion-sort">Insertion Sort</h2><p>插入排序其实就是打牌：每次拿到一张牌<spanclass="math inline">\(i\)</span>，从<spanclass="math inline">\(i-1\)</span>开始向前扫描寻找第一个使得<spanclass="math inline">\(cur&gt;nums[j]\)</span>的位置<spanclass="math inline">\(j\)</span>，找到位置后将<spanclass="math inline">\([j+1,i-1]\)</span>所有元素向后移一位，接着将拿到的牌放到<spanclass="math inline">\(j+1\)</span>。不能保证前面的部分全局有序，因为后面拿到的牌可能是最小的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; cur &lt; nums[j]) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：元素全部有序，<spanclass="math inline">\(N-1\)</span>次比较、<spanclass="math inline">\(0\)</span>次交换；复杂度<spanclass="math inline">\(O(n)\)</span>。<br />最坏情况：元素全部逆序，大约<spanclass="math inline">\(\frac{N^2}{2}\)</span>次比较和<spanclass="math inline">\(\frac{N^2}{2}\)</span>次交换，复杂度<spanclass="math inline">\(O(n^2)\)</span>。<br />平均情况下：大约<spanclass="math inline">\(\frac{N^2}{4}\)</span>次比较和<spanclass="math inline">\(\frac{N^2}{4}\)</span>次交换，复杂度<spanclass="math inline">\(O(n^2)\)</span>。稳定。</p><p>折半插入排序<br />直接插入排序前面的子序列是有序的，所以如果是顺序表，那么可以先折半查找出元素的待插入位置，再统一移动该位置之后的所有元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSortOptimized</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将A[i]插入到合适位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = A[i];</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统一后移元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= low; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A[low] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能：折半插入排序将元素比较次数减少为<spanclass="math inline">\(O(nlogn)\)</span>，但是移动次数依然是<spanclass="math inline">\(O(n^2)\)</span>，故总的时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><h2 id="shell-sort">Shell Sort</h2><p>基本思想：将待排序表分为若干<span class="math inline">\(A[i], A[i+d],A[i+2d]...\)</span>子表，<spanclass="math inline">\(d\)</span>称为增量，对这些子表执行直接插入排序，当整个表中的元素“基本有序”时，对整个表来一次直接插入排序。</p><p>希尔排序(ShellSort)是基于插入排序的一种<strong>不稳定</strong>排序方法。<br />1，将整个序列分为h个子序列；<br />2，第一趟将每个子序列进行插入排序；<br />3，第二趟将增量缩小，重复2；<br />4，直至增量为1，就是简单插入排序。</p><p>eg:<br /><img src="20180707130824188.png" alt="这里写图片描述" /><br /><img src="20180707130836718.png" alt="这里写图片描述" /></p><p>希尔排序最优时间复杂度<spanclass="math inline">\(O(n)\)</span>，最差情况下也突破了平方级别的运行时间。<br />对于最差情况，之前的冒泡、选择要消除逆序，采用交换相邻元素的方法，也就是每次只能消除一个逆序，那么希尔每次交换隔得很远的元素，每次可以消除多个逆序，这样就节省了大量的交换时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = n &gt;&gt; <span class="number">1</span>; d &gt; <span class="number">0</span>; d &gt;&gt;= <span class="number">1</span>) <span class="comment">// 增量选之前的一半</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; n; ++i)  <span class="comment">// 将nums[i]插入有序子表</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - d]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="comment">// 查找插入位置</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; nums[j]; j -= d)</span><br><span class="line">                    nums[j + d] = nums[j];  <span class="comment">// 后移</span></span><br><span class="line">                nums[j + d] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能：时间复杂度依赖于选取的增量序列，大约是<spanclass="math inline">\(O(n^{1.3})\)</span>，最坏是<spanclass="math inline">\(O(n^2)\)</span>。</p><h2 id="merge-sort">Merge Sort</h2><p>归并排序是将若干有序子表归并为一个新的有序表的算法.初始时数组可以看作<span class="math inline">\(n\)</span>个有序子表,一趟2路归并排序可以将其合并为<spanclass="math inline">\(n/2\)</span>个有序子表:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(high - low + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;  <span class="comment">// 左有序和右有序开始位置</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &lt; num[j]) &#123;</span><br><span class="line">            tmp[k++] = num[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = num[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = num[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">        tmp[k++] = num[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        num[low + i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(num, low, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(num, mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="built_in">merge</span>(num, low, mid, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序需要辅助数组, 因此空间复杂度为<spanclass="math inline">\(O(n)\)</span>. 时间复杂度的分析与快排完全类似,也是<span class="math inline">\(O(nlogn)\)</span>,不过归并排序是一种稳定的排序算法.</p><p>归并排序一个比较重要的点在于归并时可以做一些逆序对的统计等,参考如下2题:<br /><ahref="https://www.nowcoder.com/questionTerminal/8397609ba7054da382c4599d42e494f3">数组单调和</a><br /><ahref="https://www.nowcoder.com/questionTerminal/bb06495cc0154e90bbb18911fd581df6">数组中的逆序对</a></p><h2 id="heap-sort">Heap Sort</h2><p>堆是一种将数组看作complete binarytree的数据结构，分为大顶堆（parent&gt;=children）和小顶堆（parent&lt;=children），由于父结点和孩子结点这种奇妙的大小关系，堆也被用来做排序了...对于一颗完全二叉树，结点<spanclass="math inline">\(i\)</span>的父结点为<spanclass="math inline">\((i-1)//2\)</span>，孩子结点为<spanclass="math inline">\(2i+1,2i+2\)</span>。</p><p>排序前先要建堆，有2种主要的建堆方法（以大顶堆为例）：</p><ol type="1"><li>Top-down<br />Top-down的方式主要通过<code>HeapInsert</code>的方法，从空heap开始，每次插入并向上调整<code>sift_up</code>一个元素，复杂度<spanclass="math inline">\(O(nlgn)\)</span>。</li><li>Bottom-up<br />Bottom-up的方式主要依赖于一种叫做<code>heapify</code>的操作，你也可以叫它嬉皮化。对某个结点a进行<code>heapify</code>非常简单：对比a以及a两个孩子<spanclass="math inline">\(c_1,c_2\)</span>的值，如果a是最大的，操作结束；否则将a与<spanclass="math inline">\(max(c_1,c_2)\)</span>交换，递归直到a变为叶子结点或者a是三者中最大值，<code>heapify</code>操作的复杂度为<spanclass="math inline">\(O(lgn)\)</span>。<br />可以发现：一次<code>heapify</code>下沉操作<code>sift_down</code>只能保证从a向下交换的路径上的每一棵局部小子树满足堆的性质（即只对原数组的部分位置进行了调整），并不能保证整棵树都满足堆的性质，甚至无法保证向下交换的整条路径满足根结点最大（如<code>[3 2 4 0 1 6 8]</code>对根操作后变为<code>[4 2 8 0 1 6 3]</code>），所以为了建堆，需要从最后一个非叶子结点<spanclass="math inline">\((n-1-1)//2\)</span>（也即最后一个结点的父结点）开始，对之前的每个结点都进行<code>heapify</code>操作，这样就可以保证整棵树都满足堆的性质。时间复杂度为<spanclass="math inline">\(O(n)\)</span>，<ahref="https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity">Howcan building a heap be O(n) time complexity?</a><br />那么<code>heapify</code>建堆能不能从前向后进行呢？答案是不能，还是上面那个例子。从前往后最大元素调不到堆顶，从后往前则已经保证了父结点是最大的，因此最大元素可以一直向上调。</li></ol><p>建好堆后，堆顶元素即为最大值，此时将堆顶（数组的第一个元素）和最后一个元素交换，则最后一个元素有序（最大值），但破坏了大顶堆性质，对堆顶元素进行<code>heapify</code>下沉操作（只需<code>heapify</code>前n-1个元素），保持大根堆即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inserted num is now at idx and sift up</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_insert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[idx] &gt; nums[(idx - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[idx], nums[(idx - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">        idx = (idx - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在[start, end]范围内对nums[start]向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> maxIdx = start, left = <span class="number">2</span> * start + <span class="number">1</span>, right = <span class="number">2</span> * start + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= end &amp;&amp; nums[left] &gt; nums[maxIdx]) maxIdx = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= end &amp;&amp; nums[right] &gt; nums[maxIdx]) maxIdx = right;</span><br><span class="line">    <span class="keyword">if</span> (maxIdx != start) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[maxIdx]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, maxIdx, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapifyIter</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * start + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = start, left = <span class="number">2</span> * start + <span class="number">1</span>, right = <span class="number">2</span> * start + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= end &amp;&amp; nums[left] &gt; nums[maxIdx]) maxIdx = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= end &amp;&amp; nums[right] &gt; nums[maxIdx]) maxIdx = right;</span><br><span class="line">        <span class="keyword">if</span> (maxIdx == start) &#123;  <span class="comment">// 父亲最大无法继续下沉</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[maxIdx]);</span><br><span class="line">        start = maxIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIdx = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (lastIdx - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums, i, lastIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">buildMaxHeap</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>heapify</code>方式的堆排序时间复杂度<spanclass="math inline">\(O(nlogn)\)</span>。<br />一般求前<spanclass="math inline">\(K\)</span>大元素都采用堆排序，因为只需要调整<spanclass="math inline">\(K\)</span>次，故<spanclass="math inline">\(O(nlogK)\)</span>，而快排要将所有元素排完后才能取出前<spanclass="math inline">\(K\)</span>个。</p><h2 id="quick-sort">Quick Sort</h2><p>快排的核心思想是分治,选一个<code>pivot</code>使得比<code>pivot</code>小的元素都存储在数组的左边,比<code>pivot</code>大的元素存储在数组右边,对左右两个子数组递归调用<code>quickSort</code>.因此如何partition便成为快排的关键, 可以参考<ahref="https://www.bilibili.com/video/BV13g41157hK?p=3">01:40:00开始</a>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * partition nums into two regions: &lt;= &gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * [l, small_idx]: &lt;= pivot</span></span><br><span class="line"><span class="comment"> * [small_idx + 1, i - 1]: &gt; pivot</span></span><br><span class="line"><span class="comment"> * [i, r): unvisited</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">int</span> index = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[index], nums[r]);  <span class="comment">// now the pivot is nums[r]</span></span><br><span class="line">    <span class="keyword">int</span> smallerIndex = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[r]) &#123;  <span class="comment">// nums[i] &lt; nums[r]也可</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[++smallerIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[r], nums[++smallerIndex]);</span><br><span class="line">    <span class="keyword">return</span> smallerIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * partition num into 3 regions: &lt; == &gt; （荷兰国旗问题）</span></span><br><span class="line"><span class="comment"> * @return lowerbound and upperbound of pivot inclusive</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * [l, small_idx]: &lt; pivot</span></span><br><span class="line"><span class="comment"> * [small_idx + 1, i - 1]: == pivot</span></span><br><span class="line"><span class="comment"> * [i, big_idx - 1]: unvisted</span></span><br><span class="line"><span class="comment"> * [big_idx, r): &gt; pivot</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">int</span> index = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[index], nums[r]);  <span class="comment">// now the pivot is nums[r]</span></span><br><span class="line">    <span class="keyword">int</span> smallerIndex = l - <span class="number">1</span>, greaterIndex = r;</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; greaterIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[r]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i++], nums[++smallerIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[r]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[--greaterIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[r], nums[greaterIndex]);</span><br><span class="line">    <span class="keyword">return</span> &#123;++smallerIndex, greaterIndex&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, l, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, pivotIndex + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归，用栈保存要操作的范围的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSortIter</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(low);</span><br><span class="line">    s.<span class="built_in">push</span>(high);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> l = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> pivotPos = <span class="built_in">partition</span>(num, l, r);</span><br><span class="line">        <span class="keyword">if</span> (l &lt; pivotPos - <span class="number">1</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(l);</span><br><span class="line">            s.<span class="built_in">push</span>(pivotPos - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pivotPos + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(pivotPos + <span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">push</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = num[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; num[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        num[low] = num[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; num[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        num[high] = num[low];</span><br><span class="line">    &#125;</span><br><span class="line">    num[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当每次划分的两个子问题规模分别为0和n时, 会触发最坏的时间复杂度<spanclass="math inline">\(O(n^2)\)</span>. 当两个子问题规模相同时,时间复杂度最好为<span class="math inline">\(O(nlgn)\)</span>.假设输入数据的所有排列不是等概率的, 那么为了避免最坏情况的发生,选择pivot可以<strong>随机</strong>进行,这样被pivot分开的两个子问题规模会接近<spanclass="math inline">\(n/2\)</span>. 另外,快排的时间复杂度中常数因子非常小, 所以是实际中使用最广泛的排序算法.</p><p>复杂度的证明既可以用主定理, 也可以自己推导, 在最优情况下: <spanclass="math display">\[T(n)=2T(n/2)+n \\=2(2T(n/4)+n/2)+n=4T(n/4)+2n \\=4(2T(n/8)+n/4)+2n=8T(n/8)+3n \\... \\=nT(1)+nlogn=n+nlogn\]</span></p><h2 id="counting-sort">Counting Sort</h2><p><ahref="https://zhuanlan.zhihu.com/p/270158986">计数排序</a>适用于数据量很大，但是数据类别很少的情况，可以做到线性时间。<br />举例来看：如果有100万个字符串，但只有cat, dog,person三种类型，采用基于比较的排序方式，可以做到<spanclass="math inline">\(NlogN\)</span>，计数排序采用了一种完全不同的思想：</p><ul><li>新建一个<code>counts[3]</code>，记录每种类型数据的出现次数；</li><li>遍历待排序数组，完成<code>count[]</code>的统计，并创建一个结果数组<code>sorted[]</code>：<br /><img src="https://img-blog.csdnimg.cn/20200624082843898.png"alt="在这里插入图片描述" /><br /></li><li>基于<code>count[]</code>，我们完全可以知道第一个cat应该放置在0，第一个dog应该放置在<code>count[0]=4</code>处，第一个person应该放置在<code>count[0]+count[1]=6</code>处，为了更加清晰，创建一个<code>starts[3]</code>表示每类数据中的第一个的起始位置：<br /><img src="https://img-blog.csdnimg.cn/20200624083353219.png"alt="在这里插入图片描述" /><br /></li><li>接着第二次遍历待排序数组，遇到第一个cat，我们知道它应该放在<code>sorted[starts[0]]</code>；第一个dog应该放在<code>sorted[starts[1]]</code>，第二个dog应该放在<code>sorted[starts[1]+1]</code>。或者可以这样做：每当放置完一个dog，就<code>++starts[1]</code>，这样下一次的dog还是会放在<code>sorted[starts[1]]</code>，最终结果：<br /><img src="https://img-blog.csdnimg.cn/20200624084335135.png"alt="在这里插入图片描述" /></li></ul><p>对于字符串排序，我们需要规定<code>counts[]</code>中每个下标对应哪种类型。如果对于非负整数，我们可以用<code>counts[i]</code>表示i的出现次数，接着遍历<code>counts[]</code>，将整数i放置<code>counts[i]</code>次；如果有负数，可以找到最小值min和最大值max，平移到0~max-min即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(upper + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        cnt[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= upper; ++i) &#123;</span><br><span class="line">        cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cnt[i]: number of elements &lt;= i</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="comment">// 从后往前遍历保证排序稳定性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        tmp[cnt[nums[i]] - <span class="number">1</span>] = nums[i];</span><br><span class="line">        cnt[nums[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="built_in">assign</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="radix-sort">Radix Sort</h2><p>计数排序的前提就是需要知道待排序数组的内容/范围，那么如果范围很大，空间上是无法忍受的，由此来看更加general的基数排序：如果给定某种基（二进制2/十进制10/小写字母26）下的待排序数据，基数排序会逐位处理。基数排序有两种方式：</p><ol type="1"><li>MSD(Most Significant Digit)<br />从高位向低位，每一位上可以用计数排序：<br />356, 112, 904, 294, 209, 820, 394, 810；由于对第二位排序不能改变第一位排序的结果，所以要求按位排序算法必须是<strong>稳定</strong>的。</li><li>LSD(Least Significant Digit)<br />从右到左处理，每一位上可以用桶（队列）：<br />[112], [294, 209], [356, 394], [820, 810], [904]；<br />对于每个桶采用类似的方法直到最后一位，以[294,209]为例，接着处理第二位：[209], [294]。<br />最后收集每个桶中的元素即可。</li></ol><p>比如对于<spanclass="math inline">\([13,21,11,52,62]\)</span>，准备0-9的10个桶，从个位数字看起，依次放入相应的桶中：<br />1号桶：[21,11]左侧表示先进桶即队头<br />2号桶：[52,62]<br />3号桶：[13]</p><p>接着收集得到<spanclass="math inline">\([21,11,52,62,13]\)</span>个位已经有序，接着从十位看起：<br />1号桶：[11,13]<br />2号桶：[21]<br />5号桶：[52]<br />6号桶：[62]</p><p>收集得到<spanclass="math inline">\([11,13,21,52,62]\)</span>，这一过程需要注意11和13两个元素，虽然十位相同，但是个位小的11先进桶并且也要先出桶排在13前面。</p><p>具体的实现可以用队列表达桶，但是一般都用<code>cnt[10]</code>和<code>tmp[n]</code>实现：<code>cnt</code>统计个位每个数字的频率，<code>tmp</code>接收每趟收集的结果并存入原数组。<br />cnt: [0,2,2,1,0,0,0,0,0,0] -&gt;[0,2,4,5,5,5,5,5,5,5]表示在原数组中个位&lt;=2的数有4个<br />对原数组<strong>反向遍历</strong>，62个位为2，cnt[2]=4因此62应该放在<code>tmp[3]</code>上，依次类推得到tmp:[21,11,52,62,13]完成第一趟</p><p>cnt: [0,2,1,0,0,1,1,0,0,0] -&gt;[0,2,3,3,3,4,5,5,5,5]重复上述过程，之所以反向遍历，就是为了模拟进出桶时先进先出的性质。对于11和13，如果正向遍历，先看个位小的11，就会在<code>tmp[1]</code>中先放11然后在<code>tmp[0]</code>中放13违背了顺序。计算cnt前缀和数组时13是追加在11之上的，因此往<code>tmp</code>放置时需要先处理后面的13。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> max_digit_cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; max_digit_cnt; ++d) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = num[i] / radix % <span class="number">10</span>;</span><br><span class="line">            ++cnt[digit];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = num[i] / radix % <span class="number">10</span>;</span><br><span class="line">            tmp[--cnt[digit]] = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            num[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bucket-sort">Bucket Sort</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buckets</span>(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        buckets[num * len / upper].<span class="built_in">emplace_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bucket : buckets) &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(bucket.<span class="built_in">begin</span>(), bucket.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : bucket) &#123;</span><br><span class="line">            nums[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png"alt="排序" /><figcaption aria-hidden="true">排序</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Random Number Generator</title>
      <link href="/posts/random-number-generator/"/>
      <url>/posts/random-number-generator/</url>
      
        <content type="html"><![CDATA[<p><code>rand()</code>函数可以产生[0,RAND_MAX]之间的均匀的<strong>伪随机数</strong>，它定义在头文件<code>stdlib.h</code>中，函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>C标准库的实现是： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*rand: return pseudo-number integer on 0...32767*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = next*<span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*srand: set seed for rand()*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果没有初始化“随机数种子”，那么默认初始种子是1，1*1103515245+12345，return得到第一个伪随机数，接着将这个结果作为下次的种子，带入式子得到第二个伪随机数...<br />之所以定义为<code>unsigned int</code>，是防止数值溢出后不会出现负值。<br />直接调用<code>rand()</code>，会导致产生的是同一套随机数，所以我们使用<code>srand()</code>来初始化随机数种子。<br />要注意的是：不同编译器计算随机数的方法不尽相同，所以即使给<code>srand()</code>传递相同的参数，也可能产生不同的随机数序列。<br />举个栗子： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*产生0-9的随机数*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  <span class="comment">//初始化随机数种子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rand()%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用<code>rand()%n</code>产生[0,n)之间的随机数，那么一旦<spanclass="math inline">\(n&gt;RAND\_MAX\)</span>，这种做法就会失效。<br />如果你对精度的要求不高，可以采用如下办法：<br />先用<code>rand()/RAND_MAX</code>，得到[0,1]之间的随机实数，然后扩大n-1倍，四舍五入，就可得到[0,n-1]之间的随机数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*产生10个[0,99999]之间的随机数*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">double</span> random_doub;</span><br><span class="line">    <span class="keyword">int</span> random_num;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        random_doub = (<span class="keyword">double</span>)rand() / RAND_MAX; <span class="comment">//生成[0,1]之间的随机数</span></span><br><span class="line">        random_num = (<span class="keyword">int</span>)((n - <span class="number">1</span>)*random_doub + <span class="number">0.5</span>); <span class="comment">//生成[0,n-1]之间的随机数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,random_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="1260581-20220108194141397-884629663.png"alt="image" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Function-time()</title>
      <link href="/posts/time-function/"/>
      <url>/posts/time-function/</url>
      
        <content type="html"><![CDATA[<p><code>time()</code>函数返回自1970年1月1日0点以来经过的秒数，每秒变化一次?<br /><code>time()</code>函数定义在头文件<code>&lt;time.h&gt;</code>中，原型是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure></p><p>如果<code>arg</code>不是空指针，那么函数返回<code>time_t</code>类型的calendartime，并且把结果保存在<code>arg</code>指向的对象；<br />如果<code>arg == NULL</code>，那么函数只是返回一个值，值不能存储在空指针指向的对象。<br />之前不明白为什么要设计一个参数<code>arg</code>，直接返回一个值就好了啊？<br />有大神说，这是因为：</p><blockquote><p>很久很久以前，据说<code>time_t</code>是个<code>struct</code>，那时候c语言不支持函数返回<code>struct</code>，所以只能用指针传进去。</p></blockquote><p>那么<code>time_t</code>到底是什么类型呢？<br />看看cppreference.com的定义：</p><blockquote><p>The encoding of calendar time in <code>time_t</code> is unspecified,but most systems conform to POSIX specification and return a value ofintegral type holding the number of seconds since theEpoch.Implementations in which <code>time_t</code> is a 32-bit signedinterger(many historical implementations) fail in the year 2038.</p></blockquote><p>就是说：C标准委员会并没有定义<code>time_t</code>的精度，也没有指定标准的Epoch，所以这取决于你的operatingsystem以及你的compiler。<br />如果你的系统支持<strong>POSIX标准</strong>(包括很多类Unix系统、Windows系统)，那么<code>time_t</code>是一个<code>signed int 32</code>，最大表示范围是2147483647秒，标准Epoch是1970年1月1日0点，所以最终时间就是2038年1月19日，这就是著名的<ahref="https://en.wikipedia.org/wiki/Year_2038_problem">2038年问题</a>。</p><p>那么这个函数的实现，GNU C Library是这么写的： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span>                <span class="comment">/* For NULL.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Return the current time as a `time_t&#x27; and also put it in *T if T is</span></span><br><span class="line"><span class="comment">   not NULL.  Time is represented as seconds from Jan 1 00:00:00 1970.  */</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span></span></span><br><span class="line"><span class="function"><span class="title">time</span> <span class="params">(<span class="keyword">time_t</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="keyword">time_t</span> result;</span><br><span class="line">  <span class="keyword">if</span> (__gettimeofday (&amp;tv, (struct timezone *) <span class="literal">NULL</span>))</span><br><span class="line">    result = (<span class="keyword">time_t</span>) <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = (<span class="keyword">time_t</span>) tv.tv_sec;</span><br><span class="line">  <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">    *t = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (time)</span><br></pre></td></tr></table></figure></p><p>如果返回<code>time_t</code>类型的值，说明调用成功；<br />如果返回<code>(time_t)(-1)</code>，说明无法取得现在的时间，调用失败。<br />举个栗子，获得当前时间： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> current = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*把日期和时间转为字符串*/</span></span><br><span class="line">    <span class="built_in">string</span> = ctime(&amp;current);</span><br><span class="line">    <span class="keyword">if</span> (current == (<span class="keyword">time_t</span>)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get the current time!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The current time is %s&quot;</span>, <span class="built_in">string</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d seconds since the Epoch)\n&quot;</span>,current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果： <img src="1260581-20220108191119700-2067131670.png"alt="image" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FTP Protocol</title>
      <link href="/posts/ftp-protocol/"/>
      <url>/posts/ftp-protocol/</url>
      
        <content type="html"><![CDATA[<p>FTP(File Transfer Protocol)是因特网上的一种文件传送协议。</p><h2 id="基本原理">基本原理</h2><p>FTP协议基于客户/服务器模式，属于应用层，使用TCP可靠的运输服务。<br />FTP的服务器进程由<strong>1个主进程</strong>和<strong>若干从进程</strong>组成：主进程负责接受新请求，从进程负责处理单个请求。这样，1个FTP服务器就可以同时为多个客户进程服务。</p><h2 id="工作过程">工作过程</h2><p>FTP工作分为主动模式和被动模式。<br />不论哪种模式，首先，客户从一个随机的端口N(1024-65535)向服务器的命令端口21发起请求，建立起<strong>控制连接</strong>。</p><ul><li><p>主动模式<br />客户随机打开某个端口(1024-65535)，在这个端口等待服务器的数据，所以要通过控制连接告诉服务器自己用哪个端口传送数据，接着服务器收到文件传送命令以及客户端口号，从自己的数据端口20向客户发起数据连接。<br />FTP传送完一个文件，数据连接就会关闭，而控制连接贯穿整个会话。</p></li><li><p>被动模式<br />如果客户被防火墙限制，不能接受到来的TCP连接，这时候就需要被动模式来传输：<br /><img src="1260581-20220108185312740-1401371750.png" alt="image" /><br />首先，客户通过控制连接向服务器发送命令PASV；<br />接着，服务器向客户发送自己的IP地址和自己打算用来传送数据的端口号；<br />最后，客户通过刚才接收的IP地址和服务器端口号，用自己任意一个端口(1024-65535)向服务器开的那个端口建立数据连接。<br />通俗点，就是：<br />主动模式：建立数据通道，服务器主动去连接客户；<br /><img src="1260581-20220108185349044-1665399483.png" alt="image" />被动模式：建立数据通道，服务器被动地被客户连接。<br /><img src="1260581-20220108185409921-1806947979.png"alt="image" /></p></li></ul><p>再通俗点，就是：<br />主动模式：<br />客户：我开了一个端口，你来连我吧；<br />被动模式：<br />客户：mmp，被防火墙搞了，收不到你发来的数据连接了；<br />服务器：哦，没事，我开了个端口，你连我就好了。</p><h2 id="参考">参考</h2><p><ahref="www.serv-u.com/kb/1138/Active-and-Passive-FTP-Transfers-Defined">Activeand Passive FTP Transfers Defined</a><br /><ahref="https://en.wikipedia.org/wiki/File_Transfer_Protocol">wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题小技巧</title>
      <link href="/posts/file-io/"/>
      <url>/posts/file-io/</url>
      
        <content type="html"><![CDATA[<h2 id="文件io">文件IO</h2><p>在刷题测试程序时，为了避免每次都手工输入，我们可以把输入数据保存在文件中；为了避免输出太长，我们将输出也写入文件中，方便与标准答案文件进行比较。<br />文件使用一般有两种方法：输入输出重定向, fopen。</p><ul><li>重定向<br />这种方法比较简单，只要在main()函数的开始加上如下代码,就可以将标准I/O(键盘输入、屏幕输出)转为读写文件: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure></li></ul><p>万一比赛要求标准I/O，而你还想用文件操作来测试代码时，提交时切记删除上述重定向代码。为了避免忘记这茬，可以如下处理：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>,  <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样本机测试时可以使用重定向；如果要求标准I/O，提交时只需删掉<code>#define LOCAL</code>即可。</p><ul><li>fopen</li></ul><p>如果比赛要求使用文件读写，但禁止重定向方式，这时可以使用fopen方式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE *fin, *fout;</span><br><span class="line">    fin = fopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fout = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="comment">// 把scanf改为fscanf, 把printf改为fprintf</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fin, <span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">fprintf</span>(fout, <span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line"></span><br><span class="line">    fclose(fin);</span><br><span class="line">    fclose(fout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候，如果需要标准I/O，只需要： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fin = <span class="built_in">stdin</span>;</span><br><span class="line">fout = <span class="built_in">stdout</span>;</span><br></pre></td></tr></table></figure></p><p>最后，简单说下windows下的<strong>文件比较</strong>. 进入cmd:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fc</span> 1.txt 2.txt  <span class="comment"># 两个文件在同一目录</span></span><br><span class="line"><span class="built_in">fc</span> <span class="string">&quot;c:\1.txt&quot;</span> <span class="string">&quot;d:\2.txt&quot;</span>  <span class="comment"># 两个文件不在同一目录</span></span><br></pre></td></tr></table></figure></p><p>可以使用<code>fc /?</code>查看fc命令的一些参数： <imgsrc="https://img-blog.csdnimg.cn/e4b9baab46cb40bb9bb7f21be154d29c.png"alt="在这里插入图片描述" /></p><h2 id="对拍">对拍</h2><p>对拍是说碰见一道题, 想了个解<code>sol</code>但不知道对不对,但是呢暴力解<code>bf</code>时间复杂度又太高,所以希望用随机数据根据<code>bf</code>的正确解验证<code>sol</code>.</p><p>除了<code>sol</code>和<code>bf</code>,还需要<code>random</code>生成随机数据以及<code>pai</code>来对比结果.</p><p>random <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [0, m - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">rand</span>() * <span class="built_in">rand</span>() % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\data.in&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">random</span>(<span class="number">100</span>) + <span class="number">5</span>;  <span class="comment">// 点的数目</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1000000000</span>;  <span class="comment">// 取值范围</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">random</span>(m);  <span class="comment">// 数字取值范围[0, m - 1]</span></span><br><span class="line">        <span class="comment">// a[i] = random(2 * m + 1) - m;  // [-m, m]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="built_in">random</span>(<span class="number">1000</span>) + <span class="number">1</span>, n2 = <span class="built_in">random</span>(<span class="number">1000</span>) + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">b</span>(n1, vector&lt;<span class="keyword">int</span>&gt;(n2, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, n1, n2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; ++j) &#123;</span><br><span class="line">            b[i][j] = <span class="built_in">random</span>(m);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n2 - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sol <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;D:\\FILE\\mycode\\cpp_bishi\\data.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;D:\\FILE\\mycode\\cpp_bishi\\data.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>bf <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\data.ans&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>pai <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> T = <span class="number">1</span>; T &lt;= <span class="number">100</span>; T++) &#123;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\random.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> st = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\sol.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> ed = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\bf.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">system</span>(<span class="string">&quot;fc D:\\FILE\\mycode\\cpp_bishi\\data.out D:\\FILE\\mycode\\cpp_bishi\\data.ans&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;wrong ans&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;accepted, id #%d, time %.0lfms\n&quot;</span>, T, ed-st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/posts/git/"/>
      <url>/posts/git/</url>
      
        <content type="html"><![CDATA[<p>Git是版本控制系统的一种，用来维护多人协作项目的开发进程。</p><p>首先来看看单人开发的需求，最原始的VCS就在你我身边😂：一系列word文档</p><p>假如在本地保存了多个版本，<code>HEAD</code>总是指向最新的版本： <imgsrc="1260581-20211229110354288-1305060165.png" alt="image" /></p><p>如果Version 3出现了严重的bug，可以回退到Version2继续操作。但是如果Version3包含了很多我们希望保留的change，就需要将其与Version2比对，而后将这些changes拷贝到Version2，一个好的VCS就需要支持<code>diff</code>操作帮程序员们找到两个版本之间的差异。</p><p>除此之外，为了防止本地机器故障，我们希望把本地的所有版本都在云上备份，这样即使你的设备原地爆炸，也不用担心被老板炒鱿鱼。<img src="1260581-20211229111609065-1819873752.png" alt="image" /><br />另外，你可以借助云的中转实现多地工作。当然偶尔也会出现一些小问题：假如现在云上和本地的稳定版本都是Version5，你996下班后还想为公司做贡献，就在家里开始对Version5一顿操作得到了Version 5L却忘了上传，第二天上班在公司又是对Version5一通different的操作得到了Version5D并上传，第二天下班从云上直接拉取Version 5D到本地，价值几个亿的Version5L就再也找不到了...这里就需要<code>merge</code>操作来合并分支。</p><p>更重要的是，程序员们可以随时随地借助云上的备份进行协作，完成超大项目的撕逼工作。<br />为了保证出bug有人背锅，还需要记录who/when/what，VCS里叫做<code>annotate/blame</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">git init  <span class="comment"># 将该目录用Git管理</span></span><br><span class="line"></span><br><span class="line">git add haha.txt kaka.txt  <span class="comment"># workspace to staging area</span></span><br><span class="line">git commit -m <span class="string">&quot;upload&quot;</span>  <span class="comment"># staging area to local repo</span></span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:EIMadrigal/Leetcode.git  <span class="comment"># 将本地仓库与远程仓库关联</span></span><br><span class="line">git push -u origin main  <span class="comment"># 将本地库的内容第一次推送到远程仓库</span></span><br><span class="line">git push origin main  <span class="comment"># local repo to remote repo</span></span><br><span class="line">git push origin local-branch:remote-branch</span><br><span class="line">git push origin local-branch  <span class="comment"># if local-branch&#x27;s name is same with remote-branch</span></span><br><span class="line"></span><br><span class="line">git rm -r --cached haha  <span class="comment"># 删除文件夹haha</span></span><br><span class="line">git status  <span class="comment"># 查看仓库的状态</span></span><br><span class="line">git diff  <span class="comment"># 查看具体修改的内容</span></span><br><span class="line">git <span class="built_in">log</span>  <span class="comment"># 查看提交历史纪录</span></span><br><span class="line">git show  <span class="comment"># 提交详情</span></span><br><span class="line">git checkout -- [file]  <span class="comment"># 回退</span></span><br><span class="line">git reset --hard HEAD^  <span class="comment"># HEAD表示当前版本，HEAD^表示上一个版本</span></span><br><span class="line">git reflog  <span class="comment"># 查看命令的历史纪录</span></span><br><span class="line"></span><br><span class="line">git fetch origin  <span class="comment"># remote repo to local repo</span></span><br><span class="line">git merge  <span class="comment"># local repo to workspace</span></span><br><span class="line">git pull origin master  <span class="comment"># remote repo to workspace</span></span><br><span class="line">git rebase origin/master  <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">git branch  <span class="comment"># show branches</span></span><br><span class="line">git branch my-truck  <span class="comment"># create my-truck branch</span></span><br><span class="line">git checkout my-truck  <span class="comment"># move into my-truck branch</span></span><br></pre></td></tr></table></figure><h2 id="standard-workflow">Standard Workflow</h2><ol type="1"><li>fork remote repo <code>truck</code> to personal remote repo<code>my-truck</code>, enable fork syncing to keep branches and tagsautomatically in sync with <code>truck</code></li><li>clone <code>my-truck</code> to local, aka shadow repo, using<code>git clone https://xxx.git</code></li><li>pull changes from <code>my-truck</code> to sync shadow repo on thebranch you want, <code>git pull</code></li><li>create and checkout a new branch <code>new-branch</code> in shadowrepo</li><li>make your changes on <code>new-branch</code>, test your code isok</li><li>add and commit your changes on <code>new-branch</code> in shadowrepo</li><li>checkout to <code>master</code>, push <code>new-branch</code> to<code>my-truck</code> using <code>git push origin new-branch</code></li><li>submit PR to merge <code>new-branch</code> on <code>my-truck</code>to desired branch on <code>truck</code></li></ol><p>其他的workflow：</p><ol type="1"><li>change name of truck repo from origin to upstream, origin points topersonal remote repo</li><li>switch to branch A, pull remote repo to sync up</li><li>switch to branch B, merge it to branch A</li><li>push it to personal remote repo</li></ol><p><ahref="https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow">Forkingworkflow</a></p><p><ahref="https://ruanyifeng.com/blog/2015/08/git-use-process.html">Git使用规范流程</a></p><p><a href="http://www.bridgeli.cn/archives/200">Git开发最佳实践</a></p><h2 id="use-case">Use Case</h2><ol type="1"><li>在某个分支<code>test</code>上进行了修改，并提交了commit，push到个人的remote分支，提交了PR，但还没有被merge。此时需要再次修改<code>test</code>，但要合并两次commit，并且需要保留前1次/后1次的commit信息。</li></ol><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit  <span class="comment">## second edit and commit</span></span><br><span class="line">git rebase -i HEAD~2  <span class="comment">## pick, squash, then popup and edit the commit msg. if fixup, no popup and the msg will be the pick one</span></span><br><span class="line">git push origin <span class="built_in">test</span> --force</span><br></pre></td></tr></table></figure></p><p><ahref="https://blog.csdn.net/u012586326/article/details/112985496">Git操作：多个commit合并，并修改提交信息</a></p><ol start="2" type="1"><li></li></ol><h2 id="代理配置">代理配置</h2><h3 id="windows">Windows</h3><p>Windows设置git bash走代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:22335</span><br><span class="line">git config --global https.proxy https://127.0.0.1:22335</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p>Windows设置CMD走代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:22335 &amp; <span class="built_in">set</span> https_proxy=http://127.0.0.1:22335</span><br></pre></td></tr></table></figure><p>Windows设置Power Shell走代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Env</span>:http_proxy=<span class="string">&quot;http://127.0.0.1:22335&quot;</span>;<span class="variable">$Env</span>:https_proxy=<span class="string">&quot;http://127.0.0.1:22335&quot;</span></span><br></pre></td></tr></table></figure><h3 id="wsl">WSL</h3><p>WSL2配置（以<code>Clash</code>为例）：</p><ol type="1"><li>打开<code>System Proxy</code>和<code>Allow LAN</code></li><li>在防火墙里允许<code>Clash</code>专用和公用</li><li>写一个脚本<code>proxy.sh</code>，然后通过<code>source ./proxy.sh set</code>，<code>source ./proxy.sh unset</code>，<code>source ./proxy.sh test</code>开启、关闭、查看代理</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">hostip=$(cat /etc/resolv.conf | grep nameserver | awk &#x27;&#123; print $2 &#125;&#x27;)</span><br><span class="line">wslip=$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">port=7890</span><br><span class="line"> </span><br><span class="line">PROXY_HTTP=&quot;http://$&#123;hostip&#125;:$&#123;port&#125;&quot;</span><br><span class="line"> </span><br><span class="line">set_proxy()&#123;</span><br><span class="line">  export http_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">  export HTTP_PROXY=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line"> </span><br><span class="line">  export https_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">  export HTTPS_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line"> </span><br><span class="line">  export ALL_PROXY=&quot;$&#123;PROXY_SOCKS5&#125;&quot;</span><br><span class="line">  export all_proxy=$&#123;PROXY_SOCKS5&#125;</span><br><span class="line"> </span><br><span class="line">  git config --global http.https://github.com.proxy $&#123;PROXY_HTTP&#125;</span><br><span class="line">  git config --global https.https://github.com.proxy $&#123;PROXY_HTTP&#125;</span><br><span class="line"> </span><br><span class="line">  echo &quot;Proxy has been opened.&quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">unset_proxy()&#123;</span><br><span class="line">  unset http_proxy</span><br><span class="line">  unset HTTP_PROXY</span><br><span class="line">  unset https_proxy</span><br><span class="line">  unset HTTPS_PROXY</span><br><span class="line">  unset ALL_PROXY</span><br><span class="line">  unset all_proxy</span><br><span class="line">  git config --global --unset http.https://github.com.proxy</span><br><span class="line">  git config --global --unset https.https://github.com.proxy</span><br><span class="line"> </span><br><span class="line">  echo &quot;Proxy has been closed.&quot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">test_setting()&#123;</span><br><span class="line">  echo &quot;Host IP:&quot; $&#123;hostip&#125;</span><br><span class="line">  echo &quot;WSL IP:&quot; $&#123;wslip&#125;</span><br><span class="line">  echo &quot;Try to connect to Google...&quot;</span><br><span class="line">  resp=$(curl -I -s --connect-timeout 5 -m 5 -w &quot;%&#123;http_code&#125;&quot; -o /dev/null www.google.com)</span><br><span class="line">  if [ $&#123;resp&#125; = 200 ]; then</span><br><span class="line">    echo &quot;Proxy setup succeeded!&quot;</span><br><span class="line">  else</span><br><span class="line">    echo &quot;Proxy setup failed!&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if [ &quot;$1&quot; = &quot;set&quot; ]</span><br><span class="line">then</span><br><span class="line">  set_proxy</span><br><span class="line"> </span><br><span class="line">elif [ &quot;$1&quot; = &quot;unset&quot; ]</span><br><span class="line">then</span><br><span class="line">  unset_proxy</span><br><span class="line"> </span><br><span class="line">elif [ &quot;$1&quot; = &quot;test&quot; ]</span><br><span class="line">then</span><br><span class="line">  test_setting</span><br><span class="line">else</span><br><span class="line">  echo &quot;Unsupported arguments.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="虚拟机配置">虚拟机配置</h3><ol type="1"><li>打开HostClash的<code>System Proxy</code>和<code>Allow LAN</code></li><li><code>ipconfig</code>查看VMWare Network Adapter VMnet1地址为x</li><li>将虚拟机的网络连接设置为NAT模式</li><li>将虚拟机网络中的<code>Network Proxy</code>设为<code>Manual</code>，ip配为x，端口配为<code>Clash</code>的代理端口7890</li><li>重启terminal</li></ol><h2 id="refs">Refs</h2><p><a href="https://missing.csail.mit.edu/2020/version-control/">VersionControl (Git)</a><br /><ahref="https://web.mit.edu/6.031/www/fa21/classes/05-version-control">Reading5: Version Control</a><br /><ahref="https://keqingrong.cn/blog/2021-02-19-proxy-and-pac/">日常开发中用到的一些代理配置方式</a><br /><ahref="https://www.cnblogs.com/tuilk/p/16287472.html">WSL2配置代理</a></p><p><a href="https://www.toptal.com/developers/gitignore">Create useful.gitignore files for your project</a></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Introduction</title>
      <link href="/posts/vim-introduction/"/>
      <url>/posts/vim-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="配置">配置</h2><p>安装原生态的Vim之后，界面非常简略：行号，自动缩进，括号匹配都没有.</p><p>为了我们使用的方便，进行一些基本的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vim/vimrc</span><br></pre></td></tr></table></figure><p>进入配置文件后可以删掉注释或添加新的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> number  <span class="comment"># 左侧显示行号</span></span><br><span class="line"><span class="built_in">set</span> ts=4  <span class="comment"># Tab键长度4个空格</span></span><br><span class="line"><span class="built_in">set</span> expandtab  <span class="comment"># 输入Tab自动转换为空格</span></span><br><span class="line"><span class="built_in">set</span> cursorline  <span class="comment"># 突出显示当前行</span></span><br><span class="line"><span class="built_in">set</span> autoindent  <span class="comment"># 自动缩进</span></span><br><span class="line"><span class="built_in">set</span> showmatch  <span class="comment"># 显示括号匹配</span></span><br><span class="line">syntax on</span><br></pre></td></tr></table></figure><h2 id="使用">使用</h2><p>Vim有三种模式：输入模式、命令模式和末行命令模式。<br />输入模式用来输入文字，命令模式用来下达编排文件的操作指令，末行命令模式用来进行文件存档、离开编辑器等操作:<img src="vimmode.png" alt="image" /></p><h3 id="进入及离开">进入及离开</h3><p>末行模式下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:w  <span class="comment"># 保存当前文件</span></span><br><span class="line">:x  <span class="comment"># 保存文件并退出</span></span><br><span class="line">:q!  <span class="comment"># 放弃此次编辑并强制退出</span></span><br><span class="line">:wq a.txt  <span class="comment"># 保存退出</span></span><br><span class="line">:syntax on  <span class="comment"># 一次性语法高亮</span></span><br><span class="line">:<span class="built_in">set</span> number  <span class="comment"># 一次性显示行号</span></span><br></pre></td></tr></table></figure><h3 id="基本编辑">基本编辑</h3><p>命令模式下按v进入visual模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c  <span class="comment"># 删除选中目标文字段，然后进入insert mode</span></span><br><span class="line">d  <span class="comment"># 上下移动光标选中目标文字段，按d(delete)剪切</span></span><br><span class="line">y  <span class="comment"># 上下移动光标选中目标文字段，按y(yank)复制</span></span><br><span class="line">p  <span class="comment"># 移动光标到目标位置，按p(put)粘贴</span></span><br><span class="line">u  <span class="comment"># 按u取消操作</span></span><br></pre></td></tr></table></figure><p>命令模式下:</p><p>hjkl和方向键类似,w可以按词向后移动,b按词向前移动,ctrl+f/ctrl+b与pageup/down功能一样<br />88gg直接跳到第88行 10j向下跳10行 10k向上跳10行<br />/Node高亮所有Node以后 按n后跳 按shift+n前跳</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cc  <span class="comment"># 删除当前行，然后进入insert mode</span></span><br><span class="line">dd  <span class="comment"># 删除当前行</span></span><br><span class="line">yy  <span class="comment"># 复制当前行</span></span><br><span class="line">p  <span class="comment"># 粘贴</span></span><br><span class="line">u  <span class="comment"># 取消操作</span></span><br><span class="line"></span><br><span class="line">c2c  <span class="comment"># 删掉连续2行</span></span><br></pre></td></tr></table></figure><p>编辑模式:<br />ctrl+n自动补全</p><p>插件:<br />vim plug<br />vim awesome</p><h3 id="批量操作">批量操作</h3><ul><li><p>批量替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:s/foo/bar/g  <span class="comment"># 当前行所有的foo替换为bar</span></span><br><span class="line">:%s/foo/bar/g  <span class="comment"># 全文所有的foo替换为bar</span></span><br><span class="line">:%s/foo/bar/gi  <span class="comment"># case insensitive</span></span><br></pre></td></tr></table></figure></li><li><p>批量删除</p></li></ul><h2 id="中文输入">中文输入</h2><p>确保键盘输入系统选中fcitx，搜狗拼音输入法基于fcitx(Free Chinese InputToy for X)框架，所以要选中fcitx： <img src="fcitx.png"alt="image" /></p><p>下载并安装搜狗输入法<ahref="https://pinyin.sogou.com/linux/?r=pinyin">安装包</a>，切换到安装包所在的目录，改下安装包的名字，不然太长了不方便，我这里改为<code>ha.deb</code>，之后安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i ha.deb</span><br></pre></td></tr></table></figure><p>这里可能会提示依赖关系不满足(没提示的话跳过即可)： <imgsrc="dependency.png" alt="image" /></p><p>这是由于你的电脑可能没有安装有关fictx的内容，修复依赖关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -f</span><br></pre></td></tr></table></figure><p>顺利的话，桌面右上角会出现键盘图标：<br /><img src="success.png" alt="image" /><br />可以看到搜狗输入法已经安装。</p><p>如果看不到搜狗的图标(尤其是第一次安装)，重启系统。右键键盘图标，选择configure(或者搜fcitx configuration)： <imgsrc="configure.png" alt="image" /></p><p>你现在应该没有Sogou Pinyin这一项，点那个+号： <imgsrc="1260581-20211229103646985-2704756.png" alt="image" /></p><p>取消Only Show Current Language前的对号，搜索SogouPinyin，点击OK。<br />现在，输入法应该已经安装好了。可以去桌面那个键盘图标看看了~</p><h2 id="ref">Ref</h2><p><a href="https://www.bilibili.com/video/BV1Yt411X7mu">vim教程</a></p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISA Introduction</title>
      <link href="/posts/isa-introduction/"/>
      <url>/posts/isa-introduction/</url>
      
        <content type="html"><![CDATA[<p>介绍一下X86、MIPS、ARM三种指令集：</p><h2 id="x86指令集">X86指令集</h2><p>X86指令集是典型的CISC(Complex Instruction Set Computer)指令集。<br />X86指令集外部看起来是CISC指令集，事实上，它是采用类RISC内核，将部分复杂指令通过micro-op模式进行翻译成简单指令，再处理。<br />X86指令集的几个特性</p><ul><li>后向兼容<br />Intel每推出一代新处理器，总会兼容以前处理器的feature。这是由于长期积累的用户习惯和生态环境不容更改，否则没法赚钱了~<br />后向兼容导致指令集愈发庞大、愈发复杂，同时功耗也会比较大，不过由于Intel超高的工艺水平，这都不是事。</li><li>变长指令<br />X86指令集采用变长指令(1-15Bytes)，一般每条指令为2-3Bytes。这样可以提高码字的利用率，但也使得译码以及读取指令时比较复杂，因为不知道一条指令应该读多长。</li><li>多种寻址方式<br />X86指令集可以采用多种寻址方式，比如立即寻址、寄存器寻址、寄存器相对寻址......</li><li>通用寄存器个数有限<br />X86-32的系统有8个通用寄存器，之后X86-64系统扩展到了16个。</li><li>指令执行时，最多只能有一个操作数在内存里，另一个操作数必为立即数或者寄存器。</li><li>由于后向兼容以及类RISC内核，导致功耗增加；同时，有很多复杂的指令利用率很低。</li></ul><h2 id="mips指令集">MIPS指令集</h2><p>MIPS指令集是典型的RISC(Reduced Instruction SetComputer)指令集。<br />精简指令集系统的设计思想就是：把复杂指令集中一些不常用的指令踢出指令集，这些复杂指令由日益强大的软件技术(编译)去实现，这样使得每个指令的流水线分段比较均匀，充分利用了处理器的流水线结构，提高了主频。<br />MIPS指令集以32个寄存器为中心，只能通过<strong>Load/Store</strong>指令访问内存，其余涉及计算的指令都从寄存器堆中读取数据，并且将计算结果写入寄存器堆中。<br />另外，MIPS指令的格式比较规整，所有指令长度一致，指令操作码都在固定的位置；寻址方式、对于每条指令的操作都很简单。<br />那么CISC与RISC的区别是什么呢？<br />最大的区别在于：RISC只能通过<strong>Load/Store</strong>指令访问内存，而CISC指令集则没有这个限制。</p><h2 id="arm指令集">ARM指令集</h2><p>ARM指令集属于RISC指令集，每条指令32位。<br />ARM也有16位的压缩指令集，这是为了避免32位出现的码字浪费，提高运行速度推出的。</p><ul><li>ARM指令由于属于RISC指令集，一般完成的操作比较简单。程序员可以通过多条简单的指令组合实现一个复杂的操作。</li><li>同样的，ARM指令集也是只能通过<strong>Load/Store</strong>指令读取内存中的数据到寄存器，其余的指令只能对寄存器的操作数进行处理。</li><li>大多数指令长度相同，字段位置(尤其是操作码的位置)固定，且具有“条件执行”模式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fourier Transform</title>
      <link href="/posts/fourier-transform/"/>
      <url>/posts/fourier-transform/</url>
      
        <content type="html"><![CDATA[<p>为了在统一框架里分析周期信号与非周期信号，可以给周期信号也建立傅里叶变换。<br />有两种方法求周期信号的傅里叶变换：</p><ol type="1"><li><p>利用傅里叶级数进行构造<br />对于周期信号<spanclass="math inline">\(x(t)\)</span>，其傅里叶级数展开式为： <spanclass="math display">\[x(t) = \sum_{k =-\infty}^{+\infty}a_ke^{jkw_0t}\]</span> 系数<spanclass="math inline">\(a_k\)</span>表示为：<br /><imgsrc="https://img-blog.csdnimg.cn/074ecf83ad964d0b869dceb72a65cf43.png"alt="在这里插入图片描述" /><br />由于 <imgsrc="https://img-blog.csdnimg.cn/d580f672cc624a02bafc1cbcb8eaee2e.png"alt="在这里插入图片描述" /><br />说明周期性复指数信号的频谱是一个冲激，那么我们推广这个关系，可得： <imgsrc="https://img-blog.csdnimg.cn/96285b7fb96e48c1891e4745de9e5256.png"alt="在这里插入图片描述" /><br />表明：周期信号的傅里叶变换由一系列等间隔的冲激函数线性组合而成，每个冲激分别位于信号各次谐波的频率处，其强度是傅里叶级数系数的<spanclass="math inline">\(2\pi\)</span>倍。</p></li><li><p>周期延拓<br />这种方法先将<spanclass="math inline">\(x(t)\)</span>在一个周期内截断，得信号<spanclass="math inline">\(x_T(t)\)</span>，求出<spanclass="math inline">\(x_T(t)\)</span>的傅里叶变换<spanclass="math inline">\(X_T(w)\)</span>，再对<spanclass="math inline">\(X_T(w)\)</span>周期延拓得<spanclass="math inline">\(X(w)\)</span>。<br />具体来说：<br />根据<span class="math inline">\(\delta\)</span>函数性质，有： <spanclass="math display">\[x(t) = x_T(t)*\sum_{k =-\infty}^{+\infty}\delta(t - kT)\]</span> 设周期冲激串<spanclass="math inline">\(\sum_{k = -\infty}^{+\infty}\delta(t -kT)\)</span>的傅里叶变换为<spanclass="math inline">\(F(w)\)</span>，<br />由时域卷积定理： <span class="math display">\[X(w) = X_T(w)F(w)\]</span>又时域周期为T的周期冲激串的傅里叶变换在频域是一个周期为<spanclass="math inline">\(\frac{2\pi}{T}\)</span>的周期冲激串，即： <spanclass="math display">\[F(w) = \frac{2\pi}{T}\sum_{k =-\infty}^{+\infty}\delta(w - \frac{2\pi k}{T})\]</span> 故可得： <spanclass="math display">\[X(w) = \frac{2\pi}{T}X_T(w)\sum_{k =-\infty}^{+\infty}\delta(w - \frac{2\pi k}{T})\]</span> 也就是： <spanclass="math display">\[X(w) = w_0\sum_{k =-\infty}^{+\infty}X_T(kw_0)\delta(w - kw_0)\]</span>我们对比两种方法得到的结果，可知：<br />周期信号傅里叶级数的系数<span class="math inline">\(a_k =\frac{1}{T}X_T(kw_0)\)</span></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Information Engineering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Process/Thread Synchronization</title>
      <link href="/posts/process-thread-synchronization/"/>
      <url>/posts/process-thread-synchronization/</url>
      
        <content type="html"><![CDATA[<h2 id="进程间同步">进程间同步</h2><p>进程同步是为了控制多个进程的执行顺序，为了做到进程同步，通常需要进程间通信（IPC），在不同进程之间传递消息，常见的方式有以下几种：</p><ul><li>管道（pipe）：包括匿名管道、流管道和命名管道（FIFO）。速度慢效率低，容量有限，只能用于父子进程</li><li>信号量（semaphores）：不能用来传递复杂消息，只能用于同步</li><li>共享内存（shared memory）：高级方式</li><li>消息队列（messagepassing）：容量有限，消息的复制耗时，不适于信息量大或操作频繁的场景</li><li>信号（signal）：</li><li>套接字（socket）：网络上不同进程通信</li></ul><h3 id="管道">管道</h3><p>对于匿名管道：</p><ol type="1"><li>半双工即数据只能单向流动，有固定的读端和写端</li><li>只能在父子进程或兄弟进程间通信</li><li>可以看作特殊文件并使用read/write读写，只存在于内存中，不属于任何文件系统</li></ol><p>对于命名管道：</p><ol type="1"><li>可以在无关进程间交换数据</li><li>拥有相关联的路径名，以一种特殊设备文件形式存在于文件系统</li></ol><h3 id="消息队列">消息队列</h3><p>消息队列是存放在内核中的消息链表，由队列ID来标识：</p><ol type="1"><li>消息有特定格式和特定优先级</li><li>独立于发送和接收进程，进程终止消息队列仍然存在</li><li>可以根据消息类型有选择地接收信息</li></ol><h3 id="信号量">信号量</h3><p>本质上是一个计数器，用来进程间互斥和同步，而非用于存储进程间通信数据。PV原语操作</p><h3 id="信号">信号</h3><p>异步通信方式</p><h3 id="共享内存">共享内存</h3><p>速度最快，直接对内存存取，需要同步机制，通常与信号量结合使用</p><h3 id="socket">socket</h3><p>不同主机间IPC</p><h2 id="线程间同步通信">线程间同步/通信</h2><p>线程同步机制有以下几种：</p><h3 id="锁机制">锁机制</h3><ul><li>互斥锁（mutex）：排他性访问共享数据，用来保护临界区。某个线程加锁后，其它要加锁的线程将被阻塞，申请失败进入休眠，直到锁被释放。</li><li>读写锁（ReadWriteLock）：用于读者-写者问题，共有三种状态：不加锁、读模式加锁、写模式加锁。每次只有一个线程可以占用写模式的锁，但可以有多个线程占有读模式锁。</li><li>自旋锁（spinlock）：专为多处理器并发引入，不断循环测试锁的状态，申请线程不会休眠，忙等锁。</li><li>条件变量（condition variables）</li></ul><h3 id="全局变量">全局变量</h3><p>在各线程共享的堆上，每个线程私有栈</p><h3 id="事件event">事件event</h3><h3 id="信号量-1">信号量</h3><ul><li>信号量（semaphores）：有更多取值空间，实现更复杂的同步。</li></ul><p>信号量和PV原语的使用可归纳为三种情形：</p><ol type="1"><li>把信号量视为<strong>加锁标志位</strong>，其目的是为了实现对某个<strong>唯一的共享数据</strong>的<strong>互斥访问</strong>，如各个进程间的某共享变量，数据库中的某个记录。<br />共享数据的值与信号量本身的值没有直接关系，信号量的作用仅仅是作为加锁标志位。其特征是<strong>信号量初始值为1</strong>，然后在一个进程内部对它进行配对的PV操作。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P(mutex);  <span class="comment">// mutex的初始值为1</span></span><br><span class="line">访问该共享数据;</span><br><span class="line">V(mutex);</span><br><span class="line">非临界区</span><br></pre></td></tr></table></figure></li><li>把信号量视为某种类型的<strong>共享资源的剩余个数</strong>，目的是实现对这种类型的共享资源的访问，如各种I/O设备。<br />信号量的取值具有实际意义，即为<strong>空闲资源的个数</strong>。多个进程可以同时使用这种类型的资源，直到所有空闲资源均已用完。<br />其特征是信号量的<strong>初始值为<span class="math inline">\(N\geq1\)</span></strong>，然后<strong>在一个进程内部对它进行配对的PV操作</strong>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P(resource);  <span class="comment">// resource的初始值为N</span></span><br><span class="line">使用该资源;</span><br><span class="line">V(resource);</span><br><span class="line">非临界区</span><br></pre></td></tr></table></figure></li><li>把信号量作为<strong>进程间同步</strong>的工具，利用它来设定<strong>两个进程在运行时的先后顺序</strong>。比如，它可以是某个共享资源的当前个数，但是由一个进程负责生成该资源，而另一个进程负责消费该资源，由此引发了两个进程间的先后顺序。<br />其特征是信号量的<strong>初始值为<span class="math inline">\(N\geq0\)</span></strong>，然后<strong>在一个进程里对其使用V原语，增加资源个数，而在另一个进程里对其使用P原语，减少资源个数，</strong>从而实现两个进程之间的同步关系。</li></ol><h2 id="reference">reference</h2><p><ahref="https://www.cnblogs.com/CheeseZH/p/5264465.html">IPC介绍</a><br /><ahref="https://blog.nowcoder.net/n/6fba971da3f34c5c946665cbb189d049">进程间通信</a><br /><ahref="https://blog.csdn.net/AJIEIT/article/details/105368896">信号与信号量</a><br /><ahref="https://www.cnblogs.com/wsw-seu/p/8036218.html">线程间同步</a><br />https://www.cnblogs.com/meng-chao/p/16323985.html<br />https://www.cnblogs.com/limich/p/7477079.html</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Process Synchronization-Example 2</title>
      <link href="/posts/process-synchronization-example-2/"/>
      <url>/posts/process-synchronization-example-2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>理发店有一位理发师，一把理发椅和N把供等候的顾客坐的椅子。<br />如果没有顾客，理发师在理发椅上睡觉；<br />当有一个顾客到来时，他必须先唤醒理发师；<br />如果顾客来时理发师正在理发，如果有空椅子，坐下等待，否则离开。<br />用PV操作解决上述问题中的同步和互斥关系。</p><h2 id="分析">分析</h2><p>将顾客看作N个生产者，理发师是1个消费者。<br />理发师和椅子是临界资源，故顾客间是互斥关系；<br />理发师和顾客是同步关系。</p><p>信号量设置： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore barberReady = <span class="number">0</span>  互斥量，只能取<span class="number">0</span>或<span class="number">1</span>  </span><br><span class="line">Semaphore accessSeat = <span class="number">1</span>  互斥量，如果为<span class="number">1</span>，表明椅子数可以增加或减少，相当于给椅子加锁，避免两个顾客同时坐一把椅子</span><br><span class="line">Semaphore num_wait = <span class="number">0</span>   坐在椅子上等待的顾客数</span><br><span class="line"><span class="keyword">int</span> seat_free    空着的椅子数目</span><br></pre></td></tr></table></figure> <ahref="https://en.wikipedia.org/wiki/Sleeping_barber_problem">参考wiki</a></p><h2 id="解答">解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顾客进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(accessSeat);  <span class="comment">//试图坐下</span></span><br><span class="line">        <span class="keyword">if</span>(seat_free &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            seat_free--;  <span class="comment">//坐下</span></span><br><span class="line">            V(num_wait);  <span class="comment">//试图唤醒理发师，</span></span><br><span class="line">            V(accessSeat);  <span class="comment">//不用再锁着椅子</span></span><br><span class="line">            P(baberReady); <span class="comment">//等待理发师ready</span></span><br><span class="line">            理发;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            V(accessSeat);  <span class="comment">//释放加在椅子上的锁</span></span><br><span class="line">            离开;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*理发师进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(num_wait);   <span class="comment">//尝试获得一位顾客，如果没有，去睡觉</span></span><br><span class="line">        P(accessSeat);   <span class="comment">//尝试获得椅子锁，更改空闲椅子数目</span></span><br><span class="line">        seat_free++;    <span class="comment">//空椅子加1</span></span><br><span class="line">        V(baberReady);    <span class="comment">//理发师准备好了</span></span><br><span class="line">        V(accessSeat);    <span class="comment">//无需继续锁着椅子</span></span><br><span class="line">        理发;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Process Synchronization-Example 1</title>
      <link href="/posts/process-synchronization-example-1/"/>
      <url>/posts/process-synchronization-example-1/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>把学生和监考老师都看作进程，学生有N人，教师1人。考场门口每次只能进出一个人，进考场原则是先来先进。当N个学生都进入考场后，教师才能发卷子。学生交卷后可以离开考场，教师要等收上来全部卷子并封装卷子后才能离开考场。问：</p><ul><li>需要设置几个进程？</li><li>用PV操作解决上述问题的同步互斥关系。</li></ul><h2 id="分析">分析</h2><blockquote><p>考场门口每次只能进出一个人</p></blockquote><p>考场门口是共享资源。</p><blockquote><p>当N个学生都进入考场后，教师才能发卷子<br />教师要等收上来全部卷子并封装卷子后才能离开考场</p></blockquote><p>这是两个同步行为。</p><p>信号量设置： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">door = <span class="number">1</span>    <span class="comment">//能否进出门口</span></span><br><span class="line">mutex1 = <span class="number">1</span></span><br><span class="line">mutex2 = <span class="number">1</span>   <span class="comment">//互斥信号量</span></span><br><span class="line">sr = <span class="number">0</span>   <span class="comment">//学生是否到齐</span></span><br><span class="line">eb = <span class="number">0</span>    <span class="comment">//考试开始</span></span><br><span class="line">eo = <span class="number">0</span>     <span class="comment">//考试结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_stu = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num_paper = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><h2 id="解答">解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*学生进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">student</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(door);</span><br><span class="line">    进门;</span><br><span class="line">    V(door);</span><br><span class="line">    P(mutex1);  <span class="comment">//增加学生人数</span></span><br><span class="line">    num_stu++;</span><br><span class="line">    <span class="keyword">if</span>(num_stu == N)</span><br><span class="line">    V(sr);</span><br><span class="line">    V(mutex1);</span><br><span class="line">    P(eb);  <span class="comment">//等教师宣布开始考试</span></span><br><span class="line">    考试;</span><br><span class="line">    交卷;</span><br><span class="line">    P(mutex2);   <span class="comment">//增加试卷份数</span></span><br><span class="line">    num_paper++;</span><br><span class="line">    <span class="keyword">if</span>(num_paper == N)</span><br><span class="line">    V(eo);</span><br><span class="line">    V(mutex2);</span><br><span class="line">    P(door);</span><br><span class="line">    出门;</span><br><span class="line">    V(door);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*教师进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">teacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(door);</span><br><span class="line">    进门;</span><br><span class="line">    V(door);</span><br><span class="line">    P(sr);  <span class="comment">//最后一个学生唤醒老师</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    发卷子;</span><br><span class="line">    V(eb);     <span class="comment">//开始考试</span></span><br><span class="line">    P(eo);   <span class="comment">//等待考试结束</span></span><br><span class="line">    封装;</span><br><span class="line">    P(door);</span><br><span class="line">    出门;</span><br><span class="line">    V(door);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pattern Matching</title>
      <link href="/posts/pattern-matching/"/>
      <url>/posts/pattern-matching/</url>
      
        <content type="html"><![CDATA[<p>字符串模式匹配，即子串的定位操作。就是判断主串S中是否存在给定的子串，如果存在，那么返回子串在S中的位置，否则返回-1。<br />实现这种操作有两种算法：</p><h2 id="朴素的模式匹配算法">朴素的模式匹配算法</h2><p>设主串S长度为n，子串T长度为m。<br />对于主串的每个字符，做长度为m的循环，判断是否与子串匹配。<br />最好的情况就是一开始就匹配成功，时间复杂度<spanclass="math inline">\(O(1)\)</span>；最坏的情况就是每次匹配失败都是在T的最后一个元素，复杂度<spanclass="math inline">\(O(nm)\)</span>;平均情况复杂度<spanclass="math inline">\(O(n+m)\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; j &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[j] == s[i]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == t.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="kmp算法">KMP算法</h2><p>KMP主要分两步：</p><ol type="1"><li>进行t的自匹配，这一步关键在于得到next数组。next中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度，将Next[0]= -1。<br />举例来说：t=ababaca，前缀为pre，后缀为post。<br />i = 1: 要处理"a", pre = {""}, post = {""}, next[1] = 0;<br />i = 2: 要处理"ab", pre = {a}, post = {b}, Next[2] = 0;<br />i = 3: 要处理"aba", pre = {a, ab}, post = {a, ba}, Next[3] = 1;<br />i = 4: 要处理"abab", pre = {a, ab, aba}, post = {b, ab, bab}, Next[4] =2;<br />i = 5: 要处理"ababa", pre = {a, ab, aba, abab}, post = {a, ba, aba,baba}, Next[5] = 3;<br />i = 6: 要处理"ababac", pre = {a, ab, aba, abab, ababa}, post = {c, ac,bac, abac, babac}, Next[6] = 0;<br />i = 7: 要处理"ababaca", pre = {a, ab, aba, abab, ababa, ababac}, post ={a, ca, aca, baca, abaca, babaca}, Next[7] = 1;<br />Next数组<span class="math inline">\([-1,0,0,1,2,3,0,1]\)</span></li><li>S与T的匹配，这步的匹配和朴素匹配没有太大差异，只是主串S的指针不用回溯，而将子串的指针j回溯到Next[j]位置。</li></ol><p>从T的第一位开始对自身匹配，在某一位置能匹配的最长长度即是当前位置Next值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getNext</span><span class="params">(<span class="keyword">const</span> string&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(t.size())</span></span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>, next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i - <span class="number">1</span>] == t[j]) &#123;</span><br><span class="line">            next[i++] = ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next[i++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">getNext</span>(t);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; j &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[j] == <span class="number">-1</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == t.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进kmp算法">改进KMP算法</h2><p>主要改进了Next数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next_compute</span><span class="params">(<span class="keyword">char</span> T[], <span class="keyword">int</span>* next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == j || T[i] == T[j]) &#123;   <span class="comment">// 自匹配</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i] != T[j])</span><br><span class="line">                next[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[i] = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];  <span class="comment">// 字符不同，j值回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><ahref="https://www.bilibili.com/video/BV13g41157hK?p=13">1:28:00开始</a><br /><a href="https://www.zhihu.com/question/21923021"></a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Data Structures</title>
      <link href="/posts/advanced-data-structures/"/>
      <url>/posts/advanced-data-structures/</url>
      
        <content type="html"><![CDATA[<p>为了避免BST退化为单链表，出现了AVL树，但终究是二叉树，难堪大用。</p><h2 id="b-trees">B-Trees</h2><p>B-Trees可以认为是一种泛化的BST，BST的每个结点只存储单个key，因此最好情况下只能将keyspace划分为两半，查询复杂度<spanclass="math inline">\(O(log_2n)\)</span>，为了进一步提高查询的效率，可以令每个结点存储任意数量的排好序的key，即所谓的多路查找树，每个结点的k个key可以将keyspace划分为k+1段，每个子树负责一段。</p><p>m阶B-Tree有着如下性质：</p><ul><li>每个节点最多有<span class="math inline">\(m\)</span>个孩子, <spanclass="math inline">\(m-1\)</span>个key</li><li>除根节点外, 所有结点最少有<span class="math inline">\(\lceil\frac{m}{2} \rceil\)</span>个孩子</li><li>所有叶子结点都处在同样的深度，即绝对平衡</li></ul><p>4阶B-Tree又叫2-3-4树，因为每个结点可以存储1-3个key，即可以有2-4个分叉，因此得名。</p><p><img src="https://img-blog.csdnimg.cn/18941cde817d4500892631525dfc53b4.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><p>B-Tree的多key存储虽然会减小查询代价，但会导致插入和删除的代价增加，那么人们为啥还要用呢？本质上还是因为磁盘的访问太过耗时，访问磁盘数据的时间由3部分组成：</p><ol type="1"><li>磁头移动到相应的磁道所耗费的时间，大概10ms左右；</li><li>磁头旋转到相应的扇区所耗费的时间，大概4-5ms左右；</li><li>在扇区读写数据所耗费的时间，基本可以忽略。</li></ol><p>因此，任意一块扇区的访问（读或写）大致需要15ms，数据一般被排列为相邻扇区组成的磁盘块，B-Tree可以极大地减少访问次数，尽管使得磁盘块内的读写代价增加，但这些代价相比于磁盘访问耗时可以忽略不计。</p><p>可以通过一个例子感受下B-Tree和BST的差距：假设数据库有<spanclass="math inline">\(n=10^6\)</span>条记录，每条记录包含4B的key（如id等）和50B的信息，扇区大小512B，指针大小4B。</p><ul><li>如果选择BST来存储，每个结点共有62B（key+value+2*pointer），每个扇区可以存储8个记录，由于访问次序是随机的，因此不太可能接连访问同一个扇区内的记录（该情况磁头无需大规模移动，即访问2个记录的时间和访问1个记录相同），故访问每条记录均需要15ms，在<spanclass="math inline">\(n=10^6\)</span>条记录中查找任意一条记录最好情况下需要<spanclass="math inline">\(log_2n=20\)</span>次查询，共耗时0.3s左右。</li><li>如果选择4阶B-Tree来存储，每个结点共有414B（最多7个key+7个数据域+8个孩子指针+1个整数记录当前结点的key数目），在<spanclass="math inline">\(n=10^6\)</span>条记录中查找任意一条记录需要<spanclass="math inline">\(log_4n=10\)</span>次结点查询（0.15s）以及在该结点内部查找对应记录的时间（可忽略），性能大大提升。</li></ul><figure><imgsrc="https://img-blog.csdnimg.cn/c21d39e6148343eb8bae5953f21e713b.png"alt="3阶B树索引" /><figcaption aria-hidden="true">3阶B树索引</figcaption></figure><h2 id="b-trees-1">B+ Trees</h2><p>B+ Tree的非叶结点只存储key，叶子结点存储(key,value)并且将所有叶子链成单链表。</p><p>MySQL数据库支持多种存储引擎，不同的存储引擎可能采用不同的索引结构。InnoDB</p><p>B+树相比B树的优势有两方面：</p><ol type="1"><li>由于内部结点只保存key，因此内部结点可以存储更多指针，降低树的高度，减少磁盘I/O次数；</li><li>叶子结点之间通过指针链接，方便区间查询。</li></ol><p>红黑树等二叉树相比于B+树要高得多，因此磁盘I/O更加频繁，更适合在内存中查找。</p><h2 id="红黑树">红黑树</h2><p>是具有如下性质的BST：</p><ul><li>每个结点要么红要么黑；</li><li>根结点是黑；</li><li>红色结点的孩子必须是黑色；</li><li>所有从根到null的路径均含有相同数目的黑色结点。</li></ul><h2 id="跳表">跳表</h2><p>LC 1206<br />https://oi-wiki.org/ds/skiplist/</p><h2 id="reference">Reference</h2><p><a href="https://www.youtube.com/watch?v=aZjYr87r1b8">B Trees and B+Trees. How they are useful in Databases</a><br /><ahref="https://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/02/Small02.pdf">BalancedTrees</a><br /><ahref="https://www.cs.utexas.edu/users/djimenez/utsa/cs3343/lecture16.html">B-Trees</a><br /><a href="https://web.stanford.edu/class/cs346/2015/notes/Blink.pdf">B+Review</a><br /><ahref="https://zhuanlan.zhihu.com/p/107228878">为什么Mongodb索引用B树，而Mysql用B+树</a><br /><ahref="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a><br /><ahref="https://www.jianshu.com/p/d67c637776d6">Mysql索引BTree、B+Tree详细分解</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记本血泪史</title>
      <link href="/posts/sad-laptop/"/>
      <url>/posts/sad-laptop/</url>
      
        <content type="html"><![CDATA[<h2 id="缘由">缘由</h2><p>我是ACER笔记本，电脑从桌子上重摔，之后几天可以正常使用。可是后来看完视频准备退出的时候，发现所有页面已经卡死了，内存占用已经超过了80%，任务管理器没有反应，不得已按了电源键强制关机。<br />接着就再也启动不了，开机后一直显示No bootable device。<br />进入BIOS发现检测不到硬盘，估计是硬盘损坏了。啊~所有数据全都GG了！！！</p><h2 id="硬盘处理">硬盘处理</h2><p>先是用WinPE启动盘进入DiskGenius查看，没有我的HDD；<br />接着拆机，把硬盘重新插拔一下（也许是连接松了呢~），还是没用；<br />最后用硬盘盒子接到室友电脑，还是无法检测，这下彻底确认硬盘凉了；<br />拿去维修店，专业人员检测后说是磁头坏了，修复数据1T要800RMB，哇穷~<br />换块新的要480，有点坑哦！<br />还是自己买一块希捷的，加上各种优惠，不到300RMB。</p><h2 id="重装系统">重装系统</h2><p>第一次重装系统，折腾了很久，试错的细节记不清了，只说一下大体的步骤：</p><ol type="1"><li>插上新硬盘之后，先用WinPE启动，用DiskGenius将硬盘的MBR格式转为GPT格式，此时不用分区；</li><li>插上U盘启动盘，重启电脑，按F2进入BIOS，切记关掉BootSecurity，否则系统无法安装；</li><li>如果出现安装程序无法创建新的系统分区，也无法定位现有系统分区的提示，建议如下处理：<br /></li></ol><ol type="a"><li>在安装界面按Shift+F10进入命令行；<br /></li><li>输入diskpart启动磁盘程序，接着输入list disk查看电脑的硬盘；<br /></li><li>按提示输入select disk0，选中编号为0的磁盘，输入clean，删除硬盘所有数据；<br /></li><li>输入convert GPT，转换格式，然后list partition，查看分区情况；<br /></li><li>输入<code>create partition efi size*100</code>，创建EFI分区，大小100MB；<br /></li><li>输入<code>create partition msr size*128</code>，创建MSR分区，大小128MB；<br /></li><li>输入<code>create partition primary size*50000</code>，创建主分区，大小50GB。(建议这个系统盘分的大一点，否则以后清理很麻烦)；<br /></li><li>输入list partition，查看分区情况。<br />P.s.遇到这种情况，网上有的说可以重新插拔u盘启动盘，刷新；或者利用Windows自带的引导文件安装，具体的可以自己试试~</li></ol><ol start="4" type="1"><li>下来一路Next，装系统即可。</li></ol><h2 id="再次遭殃">再次遭殃</h2><p>距离上次硬盘事件已经过去了一年半，当我开心地吃着零食追着剧，想把页面切到咪咕下几首歌时，电脑瞬间卡死。<br />后来反思了一下：一是我习惯长期不关电脑，只是进入睡眠状态，可能资源本身已经占用很多了；二是打开的页面太多，而且切换太过频繁。<br />强制关机后就GameOver了~（遇到这种情况，一定不要继续操作，等着吧！等到听不到硬盘的转动声再按电源键！！！）<br />BIOS偶尔还能检测到HDD，经过专业人士检测：硬盘损坏，600RMB修复1T，好像比上次便宜了一些~<br />一般机械硬盘保修期都是2年，所以就免费换了块新的~<br />建议有条件的直接上固态吧，条件差点的可以固态装系统、机械存文件，没条件的就凑合用吧。。。<br />这次数据损失不大，吃了一堑还是有点用的，不过备份频率得改为一周一次了。<br />重装系统可以去老毛桃做个启动盘，把Windows的ISO镜像拷到U盘根目录，开机进入WinPE系统后，里面有个一键装机的软件~<br />不过不知道是不是由于机型的原因，那个软件我的本用不了（垃圾Acer）：<br />所以就利用UltraISO把ISO镜像写入到U盘，插上之后开机，就会进入Windows的安装引导程序，分区也会在其中的一步引导你去做。<br />不同机型可能稍有差异，具体步骤可以参考<ahref="https://blog.csdn.net/weixin_43175701/article/details/84349445">笔记本换硬盘装系统完整教程</a>。</p><p>重装系统一般有2种方法：</p><ol type="1"><li>PE：老毛桃等工具直接把ISO放在u盘就可以一键装机，可能会有捆绑</li><li>msdn+UltraISO：把ISO写入u盘制作启动盘，比较干净，费u盘</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fibonacci Sequence</title>
      <link href="/posts/fibonacci-sequence/"/>
      <url>/posts/fibonacci-sequence/</url>
      
        <content type="html"><![CDATA[<h2 id="递归">递归</h2><p>斐波那契数列定义： <span class="math display">\[F(n)=\left\{\begin{matrix}0, n=0\\1, n=1\\F(n-1)+F(n-2), n&gt;1\end{matrix}\right.\]</span> 递归解法最直观，但是复杂度也最高：<spanclass="math inline">\(O(2^n)\)</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="comment">//细节可以处理非法输入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>为了避免重复计算，可以将每一步计算得到的<spanclass="math inline">\(F(i)\)</span>存起来，这样的话时间复杂度降为<spanclass="math inline">\(O(n)\)</span>，但空间复杂度升为<spanclass="math inline">\(O(n)\)</span>。</p><h2 id="通项">通项</h2><p>求解通项的方法有好几种，下面展示一种用线性代数求解的方法：<br />斐波那契数列的递推公式是二阶差分方程，先用一点小技巧将其化为一阶： <spanclass="math display">\[\begin{cases}F_{k+2}=F_{k+1}+F_{k}\text{}\\F_{k+1}=F_{k+1}\text{}\\\end{cases}\]</span> 我们令<spanclass="math inline">\(u_k=\begin{bmatrix}F_{k+1}\\F_{k}\\\end{bmatrix}\)</span>，那么<spanclass="math inline">\(u_{k+1}=\begin{bmatrix}F_{k+2}\\F_{k+1}\\\end{bmatrix}=\begin{bmatrix}1\1\\1\ 0\\\end{bmatrix}u_k\)</span>。<br />矩阵<span class="math inline">\(A=\begin{bmatrix} 1\ 1\\1\0\\\end{bmatrix}\)</span>，令<span class="math inline">\(det(A-\lambdaI)=\lambda^2-\lambda-1=0\)</span>，求得<spanclass="math inline">\(\lambda=\frac{1\pm\sqrt5}{2}\)</span>，对应于两个特征值的特征向量为<spanclass="math inline">\(x_1=\begin{bmatrix}   \lambda_1\\   1\\  \end{bmatrix},x_2=\begin{bmatrix}   \lambda_2\\   1\\  \end{bmatrix}\)</span>。<br />求得特征值和特征向量后，我们将<spanclass="math inline">\(u_0=\begin{bmatrix}   F_1\\   F_0\\  \end{bmatrix}=\begin{bmatrix}   1\\   0\\  \end{bmatrix}=c_1x_1+c_2x_2\)</span>，解得<spanclass="math inline">\(c_1=-\frac{1}{\sqrt5},c_2=\frac{1}{\sqrt5}\)</span><br />故<span class="math inline">\(u_k=S\Lambda^{k}c=\begin{bmatrix}c_1\lambda_1^{k+1}+c_2\lambda_2^{k+1}\\c_1\lambda_1^{k}+c_2\lambda_2^{k}\\\end{bmatrix}\)</span><br />所以通项公式可以表示为<spanclass="math inline">\(F(n)=C_1\lambda_1^n+C_2\lambda_2^n\)</span>。<br />故斐波那契数列的通项公式为：<spanclass="math inline">\(F(n)=\frac{1}{\sqrt5}[(\frac{1+\sqrt5}{2})^n-(\frac{1-\sqrt5}{2})^n]\)</span><br />用公式求解的复杂度为<spanclass="math inline">\(O(1)\)</span>，但是由于无理数在计算机中的存储不是精确的，所以结果的精度很难保证。</p><h2 id="分治">分治</h2><p>通过矩阵形式的递推： <spanclass="math display">\[\begin{bmatrix}F(n)\\F(n-1)\end{bmatrix}=\begin{bmatrix}1\  1\\1\  0\end{bmatrix}\begin{bmatrix}F(n-1)\\ F(n-2)\end{bmatrix}\]</span>不断向下递推，可以得到： <spanclass="math display">\[\begin{bmatrix}F(n)\\F(n-1)\end{bmatrix}={\begin{bmatrix}1\  1\\1\  0\end{bmatrix}}^{n-1}\begin{bmatrix}F(1)\\F(0)\end{bmatrix}\]</span>接下来就是求解矩阵的高次方，通过快速幂可以在<spanclass="math inline">\(O(logn)\)</span>时间内进行计算：<br />整数的快速幂代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            res *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> half = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> a * half * half;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> half * half;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将传入的参数改为矩阵，乘法改为矩阵乘法，就可以得到矩阵快速幂：<br />以二阶矩阵为例，求解斐波那契数列： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;base,ans;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">multi</span><span class="params">(Matrix a, Matrix b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="comment">//第i行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)  <span class="comment">//第j列</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.a[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                res.a[i][j] += a.a[i][k] * b.a[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base.a[<span class="number">0</span>][<span class="number">0</span>] = base.a[<span class="number">0</span>][<span class="number">1</span>] = base.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    base.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;   <span class="comment">//初始化矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果矩阵初始化为单位阵</span></span><br><span class="line">    ans.a[<span class="number">0</span>][<span class="number">0</span>] = ans.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    ans.a[<span class="number">1</span>][<span class="number">0</span>] = ans.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = multi(ans, base);</span><br><span class="line">        &#125;</span><br><span class="line">        base = multi(base, base);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    QuickPow(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.a[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="动态规划">动态规划</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        ans = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refs">Refs</h2><p><ahref="https://www.zhihu.com/question/28062458/answer/39763094">斐波那契数列</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hardware Introduction</title>
      <link href="/posts/hardware-introduction/"/>
      <url>/posts/hardware-introduction/</url>
      
        <content type="html"><![CDATA[<p>计算机硬件组成可以概括为下图： <img src="1.png" alt="img" /></p><h2 id="cpu">CPU</h2><p>CPU生产商主要是Intel和AMD。<br />Intel的产品主要有四种：</p><ul><li>Celeron(赛扬)：低端处理器</li><li>Pentium(奔腾)：比赛扬强，比酷睿弱</li><li>Xeon(至强)：属于服务器处理器<br />-E3<br />-E5<br />-E7<br /></li><li>Core(酷睿)<br />-i3<br />-i5<br />-i7</li></ul><p>AMD产品主要有三种：</p><ul><li>FX系列：旗舰级多核处理器，AMD FX-8350</li><li>Athlon(速龙)系列：入门级多核处理器，AMD Athlon X4 870K</li><li>A系列(APU)：A4，A6，A8，A10依次增强，集成了核心显卡，A10-7870K</li></ul><p>以Corei7-4770K为例，Core系列i7级别第4代处理器，770代表性能编号，代数相同，编号越大，性能越好；K代表可超频。<br />笔记本CPU可能带有后缀U/Y/M等：</p><ul><li>U：超低功耗笔记本CPU</li><li>Y：极低功耗笔记本CPU，比U更省电</li><li>M：笔记本CPU</li></ul><h2 id="显卡">显卡</h2><p>显卡分为核显和独显，核显集成于CPU内部，独显与CPU独立。<br />独显由GPU(图形处理器)和其他结构(显存，散热模块，PCB板等)组成。<br />目前生产GPU的主流厂商有三家：AMD，NVIDIA，Intel：</p><ul><li>AMD(A卡)<br />-HD系列：AMD HD 7970x2---第7代高端(数字9代表高端，8中端，7低端)双核GPU，第三位7代表性能，3，5，7，9依次增强，x2代表双核心。<br />-R系列：AMD R9M290X---R9：R系列高端；M：笔记本GPU；290X：2代高性能增强型GPU。</li><li>NVIDIA(N卡)<br />NVIDIA GTX 980TI：X表示性能比GT系列更强；980：9代高性能；TI：增强型。</li><li>Intel(I卡)<br />I卡都是核显，有两个系列：<br />-HD系列：HDP4600---P：企业级；4600：代表性能，一般数字越大，性能越好。<br />-Iris(锐炬)系列：Iris Pro5200---Pro：专业版；5200：代表性能，同上。</li></ul><p>显存：SDDR3，DDR3，GDDR3，GDDR5，同容量下性能依次增加。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang FAQ</title>
      <link href="/posts/golang-faq/"/>
      <url>/posts/golang-faq/</url>
      
        <content type="html"><![CDATA[<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build  <span class="comment">// 编译</span></span><br><span class="line"><span class="keyword">go</span> run  <span class="comment">// 编译运行</span></span><br><span class="line"><span class="keyword">go</span> fmt  <span class="comment">// format</span></span><br><span class="line"><span class="keyword">go</span> install</span><br><span class="line"><span class="keyword">go</span> get</span><br><span class="line"><span class="keyword">go</span> test</span><br></pre></td></tr></table></figure><p>types of package 1. 可执行包：只有名称为main才是 2.reusable：其它都是库</p><p>bool string int float64</p><p>Go不是面向对象的语言，因此没有class/instance的概念</p><figure><imgsrc="https://img-blog.csdnimg.cn/54aa480dbe924f0a86bdb02b6af3c73a.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>数组只能固定长度，传入变量只能创建为定义了size的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">length := <span class="number">5</span></span><br><span class="line">array := [length]<span class="keyword">int</span>  <span class="comment">// error: non-constant array bound length</span></span><br><span class="line">array := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Rabbit and Turtle</title>
      <link href="/posts/rabbit-and-turtle/"/>
      <url>/posts/rabbit-and-turtle/</url>
      
        <content type="html"><![CDATA[<p>知乎上有这样一个问题：<ahref="https://www.zhihu.com/question/22364825/answer/27255001">如果兔子都在拼命奔跑，是什么给了作为乌龟的你前进的动力？</a><br />随着视野的不断开阔，我们难免怀疑自身前进的意义，曾经有很长一段时间我也深陷其中，直到看到余亦多先生的回答才有所感悟。</p><blockquote><p>我想每个人成长的经历中，都会或多或少曾被“自卑”的情绪所笼罩。我自己就是一个一直纠缠于“失败者”情结的人。</p><p>小时候因为痴肥，体育课上在同学面前抬不起头；搬到大城市，因为口音以及内向的性格，成为全班男生的出气筒；到了高中，进到全省理科实验班，才知道有些学霸的智商，是自己一辈子都无法企及的；初到美国，被身边同学认为是FOB，来自第三世界国家的乡巴佬；混进所谓的世界名校，看到身边一大波牛人，陷入平庸的沮丧；好不容易挤到纽约华尔街，看到名校中选出的所谓“精华”，才开始面对自己综合能力的缺失。</p><p>再回到香港，身边很多投行同事的业务能力与人际能力都远胜于我，只能在高压力的环境下苟延残喘；从乙方转到甲方开始做PE投资后，当跟索罗斯的儿子同桌斗智斗勇时，才能深刻体会“家学渊源”与“赢在起跑线”对一个人的意义。</p><p>由外资换到国企，开始看到体制内藏龙卧虎的主流玩家真正在玩什么，才意识到以前在边缘化外资环境下膨胀出各种不接地气的泡沫有多么可笑；随后开始接触到保险、银行以及其他金融领域的强人们，才知道在整个金融大版图中，十倍百倍于自己原来折腾的小池塘规模的资金，是在做什么。</p><p>分享了上面一大段，其实我想说的，最重要是如下几点：<br />1、就像talich老师在我去斯坦福念书以前赠我的那句话：<br />到了那儿，不用指望成为牛人，但至少你知道大海有多宽，能看到牛人在做什么，就够了。<br />对乌龟来讲，兔子存在的意义在于，至少让它知道这世界还有“兔子”的存在，以及兔子跑得有多快。盗用一句标语：让你看到更大的世界，这本身就是最大的意义。<br />2、兔子的存在，能够让乌龟直面自己就是一只乌龟这个事实。有勇气面对真实的自己，才能准确的定位自己的位置，也才能冷静的思考最适合自己的人生规划。而这，很多时候恰恰是最知易行难的事。<br />3、其实人越往后走，越会深刻体会到“阶级”的不可逾越性。愤青的时候会咒骂：“这世界为什么这么不公平。”可当你不再被荷尔蒙冲昏头脑时，也许你会开始思考：既然现在是这种情况，那我应该做点什么呢？当你绞尽心机让自己变得更好的同时，也许你也在让这个世界变得更好。</p><p>当樱木花道完成两万球的训练之后，他才知道流川枫有多厉害。<br />因为在一次比赛中，他看到流川枫的一个中投，这个起跳，这个姿势，这个弧线，竟然是他训练中想象的最完美的画面。<br />他很气，紧握这拳头，又不甘心，他问教练：这只狐狸是从什么时候开始打篮球的？<br />安西教练：你应该好好的盯着流川枫的姿势，尽可能的模仿他，然后用3倍于他的训练量训练。这样，你才有可能在高中阶段之内超越他。<br />流川枫是那只兔子，幸运的是，樱木大概也是。</p><p>题主的困惑在于，樱木是个天才，尚且如此，而你，可能只是木暮。<br />李宗盛有一首歌，歌词是这样的：最近比较烦比较烦比较烦，我看那远方怎么也看不到岸，那个后面还有一班天才追赶，写一首皆大欢喜的歌，是越来越难。</p><p>中年危机全都是这样的：<br />前面比你牛逼的人一眼都望不到岸，后面一班天才，比你有精力，比你聪明，比你学历高，比你国际化。而你，小孩成绩你得操心，老婆吃秘书的醋你也得操心，父母身体逐渐糟糕，最可怕的是你头发越来越少，身体越来越胖。</p><p>题主的困惑在于，比你天才的那个人，还比你努力；比题主的困惑更可怕的是，这个比你努力的天才，还比你年轻，比你有精力，这意味着，即使你想努力，你也没有那个精力努力。这就更无力了。</p><p>《蜗居》里面，宋思明想抢郭海藻。他比小贝成熟、稳重、懂得女孩的心思，样貌也不差；他有钱，有人际，能帮海藻解决问题。<br />若是宋思明未婚，小贝拿什么跟人家拼？小贝可能一辈子都达不到宋思明的高度，即使拼尽全力。<br />这才是无力感。<br />所以，我们能做什么。</p><p>如果你是个绝对的蠢蛋，那我只能说，请你尽量少的认识这个世界，最好一辈子不要离开你生活的地方，有时候知道的越多，越痛苦。当你看到那么繁华的城市，那么美丽的女孩，那么高端大气上档次的生活都与你无关的时候，更多的痛苦便会袭来。<br />如果你是个笨蛋，又不肯努力，那也请你知道少一点。<br />如果你不是个绝对的蠢蛋，又愿意努力，请你参考第一段安西老师的话：盯着那只兔子的每一个动作，能学多少学多少，然后以他三倍的训练量训练。</p><p>兔子一定会打盹的，即使牛逼如牛顿，30岁之后也再无建树；也不是每个像科比一样的天才，都知道洛杉矶凌晨四点的样子；你知道洛克李吗？火影里那个相信笨鸟先飞的热血少年，他说，努力的天才也是天才。<br />我曾经在一个答案中说过，勤奋，可能是这个世界上最被高估的美德。但是对于一个毫无天赋的人来讲，可以依仗的就只有勤奋了。</p><p>如此，即便你还是追不上兔子，你可以是乌龟里跑得快的那一个。<br />如此，即便你是木暮，你也能做成一个，每天都比昨天好一点点的木暮。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Predecessor </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

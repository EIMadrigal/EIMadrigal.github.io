<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大厂再无光环</title>
      <link href="/2022/06/15/%E5%A4%A7%E5%8E%82%E5%86%8D%E6%97%A0%E5%85%89%E7%8E%AF/"/>
      <url>/2022/06/15/%E5%A4%A7%E5%8E%82%E5%86%8D%E6%97%A0%E5%85%89%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f0e9536fdf32181656814ed3935dc8d04dac74c97ae1a3211ff4e91699d36b56">c172f4ee74b2b6d246b20cbfdc0b877e9936a258f94e636d7669c7052d37c5803eba0f644717a5abeeafffc9435ef6c3d57a48ce87ef0f6dc85defe7a39dd003ae87b5b8c811b797a48afe3cdfa7cf6a3f4c47017452150570fc89510b8815ba4e96e2fcbf7a2363a9f84e3e38ebc2ee8eef1d7f2b7f628efbbc1c8dbedceea577f271c5b8c053178951b10be99c744189c65a736ff151a7b2d4ad0e7eef3ff65530c89e75177468a1b3a1b2855487bb6de1e425f1699c000f90e899bb65f74ea30989d1bf8bf1acb294589c178c05939de0cbf490aa8be4ceaf2ddd57f73dbff943183596a6693ba6739916d9b2b74e2b5f5562ed4e7e95e95f2dc898f4e523e4e2e0080db84ebcb7ee2cf0a68ea8aca40220abb24af34c128f71c9ccad015fad367439c2b1fc9dcd2b499f71095007e0b8b7edf6718f128992b069667fdc74ba9d05a370b3335102064e9bd7ac0a75f0d620af7bff533fe954f6d55645047334dd7f9f27cecd2a5cc2cf80de561260ca71a935d2108f10426e713d8a015075ce3f78359ec6409d4b3993cb98190fa5435fd6a6563b08e535cf8a5880f48f1af56daf03277e5068ee05735f23ec390abad13052624b7825edb44421e2c2e8a0018931741ddef1332e22186e8aed9052cb303f2865882faa0f04a9f8d7cbd3b3e311ba386d84130278ab34e7c260dbd476f328c710f0c0c327ddfc7de3b1ae190da025cf0ba1b2088d60ac324329c4bd5cad4f89d94fddd0d8e45fe0965f9333ca42f2fa7d2b21a648ad38ec8be3a3d4c767eb7ef86e76188e4cd10890c9c1667d0ad9b34a532223e56908d305bfb26ffe443c581772942edcae6205d2c3357924108dccb8b014ecc1d0995c85e2274bbd7c1f8495488f63ba2bc3eaa155d7df848ff511882805e46f634b1ba5e40fcf362a87863b9b99ab6f4f29615f3f1612684b5a0a08413273e0548ca1c1c9fdfcaa17f510b5fcb4aa7b4c9ea73e10f8fb7877b13320d3c0c3a9873fa00e6b51f021310666c0554d552e92b2e6e17f1b5918eb225b9c158f2bd841988c7031dcfad192ef3a2fbc0c64e681695a75a878c949a916e93da8771a22fa66d5b6b3a598266fcb899652a6dc447f06e0ff0278d1617d61c25f0a19a6aac8f81b22db2172fb6e7a8646364263d6f52b60e4548b23480a3de1b0309cc62811b8fd2ba78721b09e16a81f33ceeee8544d0a9312005eda952efe528dff416b9318fd95de714cd4d824b6800cb6b50f2a36fa794f97f80bfe8bfc78630d8fb604e6fe6ef50ba370e03e90f812e78cd683b42b4394f7a2e80f87bda1957e026353695586714516efaabb7eabc15eb93c244629ac23132573ed8e2b356867a70bc1a36187bda367fece450304b88a7ca67ead333c38a5419fef3ab58c74d882a6aaf658098c5af8dbe5759eec4ddbf5f7ef2f5a686c5cdf4ef4c7690e34ca0643dd3d771aa35e57cd009d2947b54307a8f4d88385e7d2acc0e07c6d997a38319c8a4153e6ff1a8bec1bdcf8437f75adcc4e34a02afcf84542b97c7994bf2345d831dbdde9b04c4a8fe4202492bb4064a45e5b0d7e60413b979e5733025891a26cbd92df4a0d306f7b8ab50aa7ea16c0a6a0c2b66707787c37d67231f2d15bf474c5c0f6aa1f0e7b1a2ed26bdcd032a51c39c965c09ea9bd3d038e33158bd411c1c95a433e14ac6323eddcb83e75fc2f07d8d62e9993317f4d3e3a6979c603876ec04356a3c1f726a1462bb8968c752ebf2af523853a0529516c48e87ac7e7e3e7f6cadd1ca14868af296d44ff3440e7c24b1f7b844cb9eb9847e199151d2d07f9467c63e0df084a990d5eaeeb92e9b8ed19108c6f4d0aaf0bdb901a66a4d50cf5fe962c5a7237027d90d3c6042f3aa0be2813294f0b02ee2312d5211ad203ff942d75d3a356903597644d4d2bf11c3e50a8162832734f9f9c04aeeb8c533d0aaed9220807c1ae407b67bf50e6dc621cde59da7e50eb2e1e151897fda35f59c55629d6f83165b219d55e98b441dea30ab77e5db8e83684eeca9e1a198a471c22194a82ee729132e1db8a33da7db5d18a4792372edab6eb959f9fac1e999a6c36d7fa740f7e9d9fd663e5d60cc95519753d2d1fb882cda3527a3d3a2d7d61ba5282879ec027e65ed71a80f869d1213a63ea7ccbd2d628b87a92e327695648af825e0265d617f7eb9f064187308fb49cc6fec8bfb0349d8441b31ac94b368174c41307c41aba47d5fc8f9fb545ebba414b7fd1c991878922db99fbe46d3efb0c4e381c5ede9b74270cfece2841d1268967ff968bc845c8878d07687bd07169a10c5d37c62f24bcd4bbec9b26ac6e1b42679eb02d3f4bb1c36c9ba23dc372fb2012637c0a0ec09ae06935a77c78ab6d9c6371758282f38cadf31c7174017b1608b52eeca950762efe5e6419fcbbd1022fc3ba89e130e34c3ccab3a3c935108c3b180264495f8c8d9d0d03100edbe821645a65ae8116c31504c633006ef6d504d885f698532a4c5dcc58a54115a62be6b28c2aa02f78c57a0fcbb77c7889f655590530acb4f18e5723d5dcb0f862d5f349468352492c0ed251feb126faad88d4f72a7e53cda158f0f0897aa2eeb2e2ddf000d973842a41fab8415f901af6041b417a864f3a04a0322f70895284aaf70b3052b4597f17b56bd0745607421a1b224e22a014e1ccd6ac03ece2a8cf96d436531fd92e5d71d12bf47042b4dbfff6c6da873ad1fc2841890394488e55976e7f5696fd5198b2ba159a9e7debb3884552d906249492407471ba88be137480e7388025a6912848e7e11709349eff503cb84f8e35c91727d3a0f216f6e91950efb5135181b3f9180365f5b1a724f850b499da60d9cfb4d0540bc04ed09f5ba065b686b54703200d881adee24a3e8b0a59afe6a210f06a4c6c99c4d162e2b6824ca1f7e37c872f320e0afb42fbd63389ae57c413eb96ec48c4fa1fa161a03ea5ef34150a871aba8229c5dd88210b6dc7f1daa64573b77864b6f7c7919440b41a8d4a290e9188d6d9b6df0d11a54fa36d11c5beebfdc16b3e923754843cb0f0e575a92fa4a1124b0d984d55b8f1c4a9209d210741432d0f271bc61af459e27feb7776d9833013488db4277bd643ee9ee6b9260d4ed2ac530ede34c07c7635dfad75d512d7329d3689b9e9aeb4565e4f8f82fb639beec1cf14a2abe4c5d213f14a6adbf9d1dcff3e9b329555b6b338c1cf8dc51f213f5815882df627e0801c1d21d3e312fffd1730615e531e31c104f521103e513a6bc239e6d211d7ffc67b0d04a18a1c864b002e8f2a65aef86e6afe36478eb6cc89f400bffb8df5f6fd7d382658ff9c042393569fe4352fde7d25d7dac5bf109b8867a9a0d7496fd84846d2bf1a45ecaf9e42a9003e69552d43b2c32d21827e4744142c125f4544fa2f4a83b275a41a483d140fd8327abbce05725ec2ddf595552c1ce3cff6fa4e0f51ab69e7baa30ae5fdf00f19cc81c440d3c5152225852f2a066d10b56050b8adf87402fe541aba8d41aef1215a9090830194e7b2bc65ce97dd24f801a784a8e2253dc1098cb1944f75bddc38421b3e28dcf2f1596e342373a943a41153b5ae690d6a1df34fdde18a4caf3299ae5b5b06ef63205f9a6b520548e392d2b28aca58f603672feed3dc8a12a5198fd617ac0480c537817ebff88b7573d4faa18284331eaba3e8793fce3cc10f2cb945fed446b1869db096b0632cc4b04a676becc0feb34e421a082f090ffaf40fbc967dc89b3e68fdcd29b4e957595900628910c224e005652eba6a9543873d18442f65ae569dbbba71774e0bb14df9085f3e3b321d43da747816f9b78f0159b62aa64b055c13ac9f52bad8d3e6945c03cdbf2c8bf1093c32634111d75ca1c50a5e2a90b9ba6a48f15bd244480f859114d379731673ecc5cc4873c0d15ea3369cc38b1b17aa0f1386639da82ed176178f943cc9c06abe972617d0edcf68566f4bfa92596dfc2ac8ad6edf997d4f631414233623410980953178196a081bcdc0615d20374cefbf6c26d46b12733ed7a4aa0160b95d2cf06e70663edfc53b3399a61289be9e78fb7d548a6aa4ee8305ff0c5811fd4267585c6e5e080632bd69c3409f1865ec289d180bf779f1317aafc0c97b0340361f697a011e3ec52cf85b82f03cb0a6a40856846d34af51fce5f83454d9c5fb5ff4d9c4a65e1566a3246d7762c0b77ae02f772fda811cb0c41a3b0a7cba72edb23ea387b9bc1fcaa07d99c342f40652d50d16e00c1fc73e406b7d32ac1422023ffdb1e1a37c0e0f4a7c024c6d5f97b887571b8b9f6cec0c42a81d8e8330a4c8a7b2f6ac8002ffda1f661693835eed25ca23e75bf04e2b1306b9a84a2c06b6de895cda9404f92c14418d821f12346c8e5f22320b4fd1d124e3d812744235285181050711473ceb22c1887695e09823728c61771ab510bf0011f9265c1fbb230caeca86b8cc2d92498d47a5ea731d37f87a5a9f5d87797ef8a97ae576e0ae71c6273b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希</title>
      <link href="/2022/05/25/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
      <url>/2022/05/25/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<p>由于hash算法的均匀性，可以用<code>hash(object) % N</code>得到数据的存储位置，使其平均存储到N个节点上。如果每个数据的访问量比较平均，负载自然也是均衡的。这样的问题在于分布式系统的节点数目通常是在动态变化的, 因此传统的哈希会有大量的数据迁移, 可扩展性很差.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NODE_NUMBER := <span class="number">100</span></span><br><span class="line">    DATA_MAX_NUMBER := <span class="number">10000000</span></span><br><span class="line">    cnts := <span class="built_in">make</span>([]<span class="keyword">int</span>, NODE_NUMBER)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; DATA_MAX_NUMBER; i++ &#123;</span><br><span class="line">        data := md5.Sum([]<span class="keyword">byte</span>(strconv.Itoa(i)))</span><br><span class="line">        dataStr := hex.EncodeToString(data[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">        hash, err := strconv.ParseInt(dataStr, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            id := hash % <span class="keyword">int64</span>(NODE_NUMBER)</span><br><span class="line">            cnts[id]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    desiredLoad := DATA_MAX_NUMBER / NODE_NUMBER</span><br><span class="line">    maxLoad := cnts[<span class="number">0</span>]</span><br><span class="line">    minLoad := cnts[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; NODE_NUMBER; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> cnts[i] &gt; maxLoad &#123;</span><br><span class="line">            maxLoad = cnts[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnts[i] &lt; minLoad &#123;</span><br><span class="line">            minLoad = cnts[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxPercent := <span class="number">100.0</span> * <span class="keyword">float64</span>(maxLoad - desiredLoad) / <span class="keyword">float64</span>(desiredLoad)</span><br><span class="line">    minPercent := <span class="number">100.0</span> * <span class="keyword">float64</span>(minLoad - desiredLoad) / <span class="keyword">float64</span>(desiredLoad)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Desired loading: %d\n&quot;</span>, desiredLoad)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Most loading in one node: %d %+.4f%%\n&quot;</span>, maxLoad, maxPercent)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Least loading in one node: %d %+.4f%%\n&quot;</span>, minLoad, minPercent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Desired loading: 100000</span><br><span class="line">Most loading in one node: 100695 +0.6950%</span><br><span class="line">Least loading in one node: 99073 -0.9270%</span><br></pre></td></tr></table></figure><p>可以看到负载整体上是比较均衡的，此时如果增加一个节点： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NODE_NUMBER := <span class="number">100</span></span><br><span class="line">    NEW_NODE_NUMBER := <span class="number">101</span></span><br><span class="line">    DATA_MAX_NUMBER := <span class="number">10000000</span></span><br><span class="line">    moveCnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; DATA_MAX_NUMBER; i++ &#123;</span><br><span class="line">        data := md5.Sum([]<span class="keyword">byte</span>(strconv.Itoa(i)))</span><br><span class="line">        dataStr := hex.EncodeToString(data[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">        hash, err := strconv.ParseInt(dataStr, <span class="number">16</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            id := hash % <span class="keyword">int64</span>(NODE_NUMBER)</span><br><span class="line">            newid := hash % <span class="keyword">int64</span>(NEW_NODE_NUMBER)</span><br><span class="line">            <span class="keyword">if</span> id != newid &#123;</span><br><span class="line">                moveCnt++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    movePercent := <span class="number">100.0</span> * <span class="keyword">float64</span>(moveCnt) / <span class="keyword">float64</span>(DATA_MAX_NUMBER)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Moved items: %d %+.4f%%\n&quot;</span>, moveCnt, movePercent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Moved items: 9900989 +99.0099%</span><br></pre></td></tr></table></figure><p>可以看到：只增加了一个节点，竟然需要移动99%的数据，这是完全不能接受的！一致性Hash主要用来解决服务器的负载均衡问题. 一致性hash不仅需要计算存储对象的hash值, 还要计算每个节点的hash值<code>hash(name/IP)</code>, 并将其分配到圆环区间<span class="math inline">\([0,2^{32}-1]\)</span>. 对于存储请求, 将<code>hash(obj)</code>利用二分法顺时针分配到第一个节点, 从而提高<strong>单调性</strong>, 即增删节点后, 原有数据的哈希结果不迁移或迁移到新节点, 但不会迁移到旧节点. 在Swift云存储系统中, 负责存储对象与物理位置映射关系的组件叫做Ring, 也许就有环hash的意思.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NODE_NUMBER := <span class="number">100</span></span><br><span class="line">    NEW_NODE_NUMBER := <span class="number">101</span></span><br><span class="line">    DATA_MAX_NUMBER := <span class="number">10000000</span></span><br><span class="line">    moveCnt := <span class="number">0</span></span><br><span class="line">    startDataId := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    newStartDataId := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    remainder := DATA_MAX_NUMBER % NODE_NUMBER</span><br><span class="line">    base := DATA_MAX_NUMBER / NODE_NUMBER</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NODE_NUMBER; i++ &#123;</span><br><span class="line">        startDataId = <span class="built_in">append</span>(startDataId, cnt)</span><br><span class="line">        <span class="keyword">if</span> i &lt; remainder &#123;</span><br><span class="line">            cnt = cnt + base + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt = cnt + base</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remainder = DATA_MAX_NUMBER % NEW_NODE_NUMBER</span><br><span class="line">    base = DATA_MAX_NUMBER / NEW_NODE_NUMBER</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NEW_NODE_NUMBER; i++ &#123;</span><br><span class="line">        newStartDataId = <span class="built_in">append</span>(newStartDataId, cnt)</span><br><span class="line">        <span class="keyword">if</span> i &lt; remainder &#123;</span><br><span class="line">            cnt = cnt + base + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt = cnt + base</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; DATA_MAX_NUMBER; i++ &#123;</span><br><span class="line">        data := md5.Sum([]<span class="keyword">byte</span>(strconv.Itoa(i)))</span><br><span class="line">        dataStr := hex.EncodeToString(data[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">        hash64, err := strconv.ParseInt(dataStr, <span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            hash := <span class="keyword">int</span>(hash64)</span><br><span class="line">            target := hash % DATA_MAX_NUMBER</span><br><span class="line">            id := sort.Search(<span class="built_in">len</span>(startDataId), <span class="function"><span class="keyword">func</span><span class="params">(k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> startDataId[k] &gt;= target &#125;)</span><br><span class="line">            id = id % NODE_NUMBER</span><br><span class="line"></span><br><span class="line">            newid := sort.Search(<span class="built_in">len</span>(newStartDataId), <span class="function"><span class="keyword">func</span><span class="params">(k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> newStartDataId[k] &gt;= target &#125;)</span><br><span class="line">            newid = newid % NEW_NODE_NUMBER</span><br><span class="line">            <span class="keyword">if</span> id != newid &#123;</span><br><span class="line">                moveCnt++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    movePercent := <span class="number">100.0</span> * <span class="keyword">float64</span>(moveCnt) / <span class="keyword">float64</span>(DATA_MAX_NUMBER)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Moved items: %d %+.4f%%\n&quot;</span>, moveCnt, movePercent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Moved items: 4897001 +48.9700%</span><br></pre></td></tr></table></figure><p>一致性hash虽然减少了数据迁移, 但是在node较少时仍然要迁移大量数据, 因此引入虚拟节点Partition. 引入Partition后就形成二级映射: <code>obj-&gt;虚节点-&gt;node</code>. 通过提前设置固定的较大数目的虚节点, 使得obj到虚节点的映射固化, 增删node时只需要维护虚节点和node间的映射即可.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    NODE_NUMBER := <span class="number">100</span></span><br><span class="line">    NEW_NODE_NUMBER := <span class="number">101</span></span><br><span class="line">    VNODE_NUMBER := <span class="number">1000</span></span><br><span class="line">    DATA_MAX_NUMBER := <span class="number">10000000</span></span><br><span class="line">    moveCnt := <span class="number">0</span></span><br><span class="line">    vstartDataId := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    newStartDataId := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    vnode2node := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    remainder := DATA_MAX_NUMBER % VNODE_NUMBER</span><br><span class="line">    base := DATA_MAX_NUMBER / VNODE_NUMBER</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; VNODE_NUMBER; i++ &#123;</span><br><span class="line">        vstartDataId = <span class="built_in">append</span>(vstartDataId, cnt)</span><br><span class="line">        <span class="keyword">if</span> i &lt; remainder &#123;</span><br><span class="line">            cnt = cnt + base + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt = cnt + base</span><br><span class="line">        &#125;</span><br><span class="line">        vnode2node = <span class="built_in">append</span>(vnode2node, i % NODE_NUMBER)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    new_vnode2node := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(vnode2node))</span><br><span class="line">    <span class="built_in">copy</span>(new_vnode2node, vnode2node)</span><br><span class="line"></span><br><span class="line">    remainder = DATA_MAX_NUMBER % NEW_NODE_NUMBER</span><br><span class="line">    base = DATA_MAX_NUMBER / NEW_NODE_NUMBER</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NEW_NODE_NUMBER; i++ &#123;</span><br><span class="line">        newStartDataId = <span class="built_in">append</span>(newStartDataId, cnt)</span><br><span class="line">        <span class="keyword">if</span> i &lt; remainder &#123;</span><br><span class="line">            cnt = cnt + base + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt = cnt + base</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newNodeID := <span class="number">100</span></span><br><span class="line">    reassignNumber := VNODE_NUMBER / NEW_NODE_NUMBER</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reassignNumber; i++ &#123;</span><br><span class="line">        vid := i</span><br><span class="line">        new_vnode2node[vid] = newNodeID</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; DATA_MAX_NUMBER; i++ &#123;</span><br><span class="line">        data := md5.Sum([]<span class="keyword">byte</span>(strconv.Itoa(i)))</span><br><span class="line">        dataStr := hex.EncodeToString(data[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">        hash64, err := strconv.ParseInt(dataStr, <span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            hash := <span class="keyword">int</span>(hash64)</span><br><span class="line">            <span class="comment">// 不用二分，数据项到虚节点映射固定：vid := hash % VNODE_NUMBER</span></span><br><span class="line">            target := hash % DATA_MAX_NUMBER</span><br><span class="line">            vid := sort.Search(<span class="built_in">len</span>(vstartDataId), <span class="function"><span class="keyword">func</span><span class="params">(k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> vstartDataId[k] &gt;= target &#125;)</span><br><span class="line">            vid = vid % VNODE_NUMBER</span><br><span class="line"></span><br><span class="line">            id := vnode2node[vid]</span><br><span class="line"></span><br><span class="line">            newid := new_vnode2node[vid]</span><br><span class="line">            <span class="keyword">if</span> id != newid &#123;</span><br><span class="line">                moveCnt++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    movePercent := <span class="number">100.0</span> * <span class="keyword">float64</span>(moveCnt) / <span class="keyword">float64</span>(DATA_MAX_NUMBER)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Moved items: %d %+.4f%%\n&quot;</span>, moveCnt, movePercent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Moved items: 90423 +0.9042%</span><br></pre></td></tr></table></figure><p>上述方案中需要预设合理的虚节点数目, 如果实际节点多于虚节点数目，会导致有的节点分配不到虚节点，此时如果增加虚节点数，就会导致大量的数据迁移。因此通常需要将虚节点数目预设为系统最大规模的若干倍。</p><p>为了加快速度，还可以通过位操作代替取模操作，即所谓的partition power.</p><h2 id="ref">ref</h2><p><a href="https://www.cnblogs.com/yuxc/archive/2012/06/22/2558312.html">Ring实现原理剖析</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更快乐些吧</title>
      <link href="/2022/05/01/%E6%9B%B4%E5%BF%AB%E4%B9%90%E4%BA%9B%E5%90%A7/"/>
      <url>/2022/05/01/%E6%9B%B4%E5%BF%AB%E4%B9%90%E4%BA%9B%E5%90%A7/</url>
      
        <content type="html"><![CDATA[<p>Positive Psychology是Havard开设的一门心理学课程, 这门2003年的课程解开了我相当多的疑惑, 是我研究生三年中上过的最重要的一门课. 在2021年6月左右就刷过一遍, 时至今日仍然常看常新.</p><h2 id="成长第一问-人生的意义是什么">成长第一问: 人生的意义是什么</h2><p>我想在每个人成长的过程中, 都会或早或晚从某一时刻开始, 不停追问自己: 人生的意义是什么? 我大概从初中开始想象: 既然人终归都要西去, 那么每天努力学习又有什么用呢? 这个问题一直萦绕在我心头, 时而觉得已经靠近答案了, 时而推翻曾经的答案. 犹记得大学室友说: 人生的意义就是没有意义, 人生就是用来追寻意义的. 看起来很有哲学意味, 但切记: 汝之蜜糖, 吾之砒霜.</p><p>随时间流逝, 我也变得忙碌起来, 不过还是会经常思考: 辛勤工作挣大钱有什么用? 勾心斗角追名逐利又有什么用? 到头来不都是一场空? 所以有段时间我变得十分佛系, 并且经常感到生活如同行尸走肉, 只是在为了一个目标机械式地付出时间精力. 就像Thoreau和Floyd所说:</p><blockquote><p>Most men lead lives of quiet desperation.<br />People are comfortably numb.</p></blockquote><p>幸福感这个词虽然偶尔仍然会在耳边闪现:</p><blockquote><p>人生嘛, 最重要的就是开心!</p></blockquote><p>但彼时对于幸福的理解却完全是二元的: 要么幸福, 要么不幸. 从来没有想过幸福感竟然可以是连续的, 是可以有比较级的: happier. 因此人的情感不可能永远维持在高位, 每段时间都会有ups and downs, 但是通过科学的方法可以让自身的幸福感呈现出总体上的上升趋势, 而这则应当是衡量人生意义的唯一标准.</p><p>那么人生幸福感的持续增加是否能够依赖他人呢? 或者说是否能够遇到伯乐呢? 很不幸, 概率极低. 我以前低谷时, 总是幻想会有人来拯救自己, 但往往事与愿违, 直到最后也不会神兵天降. 所以抱怨和幻想都无济于事, 正如Tal所言:</p><blockquote><p>No one is coming. You are responsible for your life, for your self-confidence, for your self-esteem, for your happiness.</p></blockquote><h2 id="认知误区之成功">认知误区之成功</h2><p>如果用实现某些人生节点的目标来作为成功的标准, 正如我们小时候一直被教育的那样: 考上好大学就是成功, 抑或是拿到tenure就算成功. 我相信: 你原本想象成功后就会永远高兴下去, 比如考到所谓的好学校便会一帆风顺. 但事实往往是: 这样快乐的情绪并不会持续太久, 接踵而来的便是新的烦忧, 即幸福感会很快回落到之前的baseline. 同样地, 失败也会是相同的感受: 你以为自己会很长很长时间处于低落情绪中, 但其实没过几天就会走出阴霾.</p><p>因此, 在基本的物质和精神需求得到满足后, 外界因素对于幸福感的影响其实是很小的. 幸福感baseline更多取决于自己的state of mind, 取决于如何看待世界, 看待发生的事情.</p><h2 id="关于理想主义">关于理想主义</h2><p>曾经在很长一段时间里, 我都自诩为理想主义者, 但后来我发现自身的认知有些偏差, 我顶多算个半理想主义者. 理想主义者要有理想, 这只是前提, 是否拥有足够的勇气和智慧去践行理想才是区分理想主义者与否的关键:</p><blockquote><p>To be idealistic is to be realistic.</p></blockquote><p>这个世界最最需要的是有实践精神的理想主义者:</p><blockquote><p>What the world needs more than anything else is practical idealists.</p></blockquote><p>很不幸, 目前看来我并不具备这样的勇气和智慧. 我之前还有一点疑问: 对于那些所谓精致的利己主义者, 或者说只顾自身幸福的人我是持鄙夷态度的, 但很明显这样看起来并不正确:</p><ol type="1"><li>追求自身幸福并不是一种自私的行为, 幸福感是正和博弈, 是具有传染性的: 助人即是助己, 助己也是助人. 因此传播幸福最好的方法就是经营好自己的幸福.</li><li>作为伪理想主义者, 我自然没有资格评判别人的行为.</li><li>目前某些国家的大环境的确没有理想主义者生存的土壤.</li></ol><h2 id="关于完美主义">关于完美主义</h2><p>我从小就有完美主义的毛病, 小到考试要将卷子写满, 大到人生决策全都想要. 我甚至曾经一度认为这是一个好的习惯: 追求完美, 追求绝对纯净. 栽过几次跟头后我隐约觉得这种认知不对, 但是无法科学剖析.</p><p>完美主义者通常更加看重未完成的事, 看重缺点错误, 急于做出改进. 正因为如此, 这类人经常忽略自己的优势和成就, 忽略过程的享受, 更容易成为所谓的rat racer. 另外, 总是会后悔: 如果当初选了那条路, 结果会不会不一样? 这种All or Nothing的思想是病, 是一种对充斥于生活中的失败的一种失能性恐惧, 尤其对于我们所关心的方面. 看得越认真, ta就伤害你越深. 另外, 通常会很急躁地, 仓促地急于完成这些所谓很重要的事, 最后效果也不好.</p><p>是病就得治:</p><ol type="1"><li>Permission to be human. 你是人, 不是神, 给自己一个做凡人的空间. 尽人事知天命, 随ta去吧.</li><li>从A点到B点一定是蜿蜒曲折的, 不存在最短的直线, 否则就违反了天性. 如果你希望journey是直达的, 那么你在白日做梦.</li><li>Go coping, go trying, go hearing.</li><li>Learn to fail or fail to learn. 吸取教训, 下次不要掉进相同的坑里.</li></ol><h2 id="自尊">自尊</h2><p>自尊代表人对自我的评判和感受. 很多时候明明已经不错了, 但还是经常感到痛苦和低自尊? 这个悖论其实取决于你的自尊中三种不同层次所占的比例:</p><ol type="1"><li>Dependent self-esteem. 依赖型自尊是指需要别人赞扬, 将别人的评价作为自尊的体现, 与他人比较来评估自己的能力. 这是part of human nature, 只是或多或少而已. 高依赖型自尊的人很可能有完美主义倾向, 总想在别人心目中留下完美印象.</li><li>Independent self-esteem. 独立型自尊是指根据自己的标准评价自己, 与自己比较来寻求自身进步. 这也是鸡汤文最喜欢说的: 不用和别人比, 和自己比就行了.</li><li>Unconditional self-esteem. 无条件自尊是指足够自信, 不需要依赖他人或自己的评价, 既不和别人比, 也不和从前的自己比, 对自己当下的状态十分满足, calmer. 是一种just to be, just to exist的感觉. 这种超然的享受事务原始美的状态并非漠视他人的情感, 相反会更同情怜悯他人.</li></ol><p>随着年龄增长, 第3种的比例会增加, 但是it takes time.</p><h2 id="reference">Reference</h2><p><a href="https://www.bilibili.com/video/BV1kx411S7ZU">幸福课</a><br />Happier: Finding Pleasure, Meaning and Life's Ultimate Currency. 中文名《幸福的方法》<br />Choose the Life You Want. 中文名《过你想过的生活》</p>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
            <tag> Predecessor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Finite State Machine</title>
      <link href="/2022/04/17/%E8%87%AA%E5%8A%A8%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
      <url>/2022/04/17/%E8%87%AA%E5%8A%A8%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>有限状态机在本科数电实验接触过, 但是最近在做LeetCode第8题时才发现其妙用. FSM通常可以用5元组<span class="math inline">\((Q, \Sigma, T, q_0, F)\)</span>表示: Q表示有限的状态集合, <span class="math inline">\(\Sigma\)</span>表示有限的输入集合, T表示状态转移函数, <span class="math inline">\(q_0\)</span>表示初始状态, F表示结束状态.</p><h2 id="deterministic-finite-automaton">Deterministic Finite Automaton</h2><p>如果不知道DFA, 那么在做诸如LC 8/65等题时, 面对浩如烟海的corner case, 即使写出了代码, 想必也是一团乱麻.</p><p>以LC 65题为例, 给一个包含大小写英文字母/数字/+/-/.的字符串, 判断其是否是一个有效的数字.</p><p>DFA的思路是: 开始是自动机处于初始状态, 之后顺序读取每个字符, 根据当前状态和该字符的转移规则转移到下一个状态, 读完整个字符串后如果自动机处于某个可接受状态, 则合法. 如果读取过程中转移失败或者最终自动机处于非接受状态, 则非法.</p><p>第一步就是要枚举所有的可能状态, 通常对于字符串匹配问题可以考虑用字符串的不同部分作为状态集合. 例如本题中一个合法的字符串应当包含以下部分:</p><ul><li>符号位+/-: 如果存在, 其后必须跟着数字或小数点</li><li>整数部分: 若干0-9组成的串</li><li>小数点: 两侧至少有一侧是数字</li><li>小数部分: 与整数部分相同</li><li>指数部分: e/E, 符号位, 整数部分</li></ul><p>所以状态集合包括:</p><ol start="0" type="1"><li>初始状态<br /></li><li>符号位<br /></li><li>整数部分<br /></li><li>左侧有整数的小数点<br /></li><li>左侧无整数的小数点<br /></li><li>小数部分<br /></li><li>字符e/E<br /></li><li>指数部分符号位<br /></li><li>指数部分的整数部分</li></ol><p>小数点有些特殊, 其两侧至少一侧有数字才合法. 通常来讲小数点可以转移到e或小数部分, 但是对于左侧没有整数的小数点, 其右侧必须有数字, 不能转移到e, 只能转移到小数部分, 否则违背了小数点的规则. 例如<code>.e1</code>就是非法的, <code>3.e1</code>就是合法的. 因此小数点的状态需要分为2类: 左侧有整数以及左侧无整数. 那么为什么不按照小数点右侧有无数字来分类呢? 我认为最大原因在于状态机是不能回退的, 即如果已经访问到了小数点右侧, 那么无法结合其左侧状态进行下一步的转移.</p><p>假设右侧有数字的小数点为a, 右侧没有数字的小数点为b. 例如对于初始状态的输入<code>.</code>, 能否转移到a或b都是<strong>不确定的</strong>, 因为此时无法判断小数点右侧是否有数字. 如果采用左侧的划分方式, 转移则是确定的.</p><p>第二步需要找到初始状态0和可接受状态2/3/5/8.</p><p>最后需要根据合法字符串的格式定义转移规则, 并画出转移图: <img src="https://img-blog.csdnimg.cn/3f282f79feeb47d799fcf0d02a5a4867.png" alt="状态转移图" /></p><p>为了写代码方便, 通常用<code>unordered_map&lt;state, unordered_map&lt;cur, state&gt;&gt;</code>来表示状态转移表, 只要将上述转移图翻译成代码即可.</p><p>除了算法题的应用, FSM与KMP算法和正则表达式都有着密切关联.</p><h2 id="refs">Refs</h2><p><a href="https://patterns.eecs.berkeley.edu/?page_id=470">Finite State Machine</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云</title>
      <link href="/2022/03/11/%E4%BA%91/"/>
      <url>/2022/03/11/%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="cc8d17d65feef18f9aed4fe488b55a093f681cb01323f93d5221cfe88e4924ae">418fac4f173397084caccc18ab9f089e707caf583bd354c6ef7976737c697a3f3b9a8cb267430489472d32a541523ccda228af51cff66f4307241ee65cc0ce480cfc012e360f7934ea080ddfd65126c083ac1847b9e9928e0c5dd43e0e384be72f2ae72b2a910da86d76684e1d84b71fa68d195ac61e5f6ae29b44527e4b5938245f6587802a2aa5ffa8f17afe17523daa16b8b59b728deff6fa93cfe2515974de05230124b2fdc32e9f6b630709578a7a95e77f8332354851ace5e396469da2f61e3255b89648cc32fd98b482a5369b4af47e38eeb94951bcf454a352fb448df6c87bb3e4f4f08ec3dc422f62fd04f322dd323f8219202fd1cc4527fe1c386d8087af5a2de10b6dff8cca8bbd90e8d60b12f77256759e1c7e75548dda1dc1505dc465d572cafd73a468041f07ecac5a80663e5eb51694364c3bdf1386459fc8475bac0101186f3ea28a9f1b7ce63c445fb2ce6d10f03185203e58b8d871377e8c90f6ace33ba6be74d0ec598ce1b58a29dee045c2715b0adb50f549c7b4f1cebb6307f33c3121c44308f2b40c711de17913134ccd8f44d34f2e29ea633eef2a3635314cdb85260d083e9f3fcc29608cd40f70be7d47e338a98e25d7785bc1875e6d4f34cc7a87f8895095a203dfce01ba7459509eb693bd2e34611803c642ead83d0db89cece6670041272a04ae441dee9cf7278b991cd1d5f7623b8f4b33d2ae7c3cc2fcd7dddd0667596d2898ffcd086c8c7726220a040c4f2b8c085cb1e64b567dcb5d16359265de8e4c1c6a8216d5e7f418ef290280bbbd8b2cef36c169b00101609d039cc51648ee26318bbb31b761c9a41cd0a2c3a82ca6c42090d42fe019871a88b1ad844d66bc257f45395759fa6b45b2eab67080010b984a836188adaa2dadd910541a960133a1621bd25634d8a39dd62c9ad512cb4d2dc9d57633ce042fd22c5af7aa4f73b4e88ef8540eabccb67f5facf5605d2deee88fbaa1ff7c49eb3cc5e06ba830670bb852c1c88dd50ad0e771b18ce97cf27364cdf471e8d8bee3400de5009a8115edf1a03a736f2288bda309424f96c031a0d7d0f34950890e4819493bd8ed59c180ec1a49d643c37f382398b6a65acc24de8170d9712b3f1896cdf7a8d977a93539d740607493f178f1f92d2d578706f81e63aca04301cba879d4e0c110bf74ad107094631f5881205d3c01add490eb40abf129a4767dd9caab3fea6a232df9d0fe1fdb4afb4e33e55b85830f24d15da06688b59cf87dcbfaf2a1e2c704ac689455f5032523879f606dbc64fed7903135c115194679d30423b43355f7e08a5e20bb250c96f9bd039f9f96a6ac83a90739228ad977095118d13346a81f22f47fbdfccae662957c1a897af5c75f4aae47ee63888c7ea1f29fdd2ad3359924c660b422d190d7f28cce7e20c285e7c566f2598d246f946a5411c02b8382812aa8716290cd8820bc3b0de98be5db87b9e5c5cb264c536e17e64569636edb42ebd4b19b9c486fbeb96bae00499e7b41cfe71c3f1e15d26934ec1232ef6191b18efbb589ae3897d609c033af6e7a5971b95ec6ee7d63d894108956f894dcee3931e83980607ea0a6d76a6f0d7c2a126f8a5700e72f0e2bd0786cd5d7913c7d221176d985080c915c8eb692f9320f3ecd7b3461c4728bece998bd339dd21d372f85e56bc152043c98bdd28fbd71d4d75dab9bea806856bdd8d7ac941d02350d53bae8ba2015730679b739681e3d1206f82c126ab1930ba7466a1aeca9ee56e0bd28acd14a197e24f4d0725ea960cb4d0ea4ca449a6397997379a8ad9203edd7981416e239071c3f1fcdf25f52339fa0874e8a60143997ac54e2de0bfc5f304e5b81a3ba6b28bda1e0a9be37c5eb6376df03c9b8011ef2991e31d3ff19c3a3c440d8e7e6d533fa7219c5a3ee576f359457ef3c392b905f6a365809844460663248258feadb74e86792eb7fe7dfdfcc8669ecfcfed93c329eebe05c2e768e19a83b41fdda44171280fa8c5e1e0e953f86aa3a1f0d1e0f4dc305e5efaab79cb9a3486d527db172fdd070596c8c1c10ed0dc04fab5a10ca9a49934eb3ff2959fb7c24ab1d0980d8e668862bf1e65dd5eb5ece0cf25e19da8aa816543bc6cd489e41dcd8c9f9e1301b3bf85442585d08fbf8b9a1785812e046101851f98607c3e006d67c7e1c6a617866da3c078ed546117901c7f98acc13511432a36313b472953d68fd45a22204444c5a2c37bb9fa2b47a908808462c91c50d8bef730d362c6ea9da2d86374392bb1ed07efbe6204e9607509bcee9057e79380432aed5f7870a40a4642958f46fe1c11dc0f215b6baae86b4c575dce718cd4396cb013f9543173bf16fce1f1940f5d00254dd71075dd56c321a2fdf2ae430877ae30877f0d7fa5e2dd674c2d9798e2b157a84039c7cfa6772bd8129ba9390fdce0282654196fe31c37e74aef5c7f07a2119211293e9d6b927c662b585b76a204dae7e7f89ab8068c91293d18d59cb3b6238ec3e1004933dca52e3c6751bd99eced44fad5007e81306f1978630c5fb1d875640d288e3bfb4d2acd147c6c4cf36958c60c25bd651eb4ab40816150a35d13866e28a359d1e5964eb9f931af1527227e8416e0481473499c1adb24063afdb7ff5633c4dd40d84bc83b7319cfcfe120b6b486218f96928af091e7248b9f67fa66225b6ebbd296555723f61a61f3deba4053ce768654aa8c95f1e96ec14db11abefbc8ed8d183a572a16b49e15636ad2815660793498b4b428a60390c046e9b6ea8ae1e664fd4cbfa0c503a4b114447bbe44dd6bbace028c9ccf0c28abe77ec38a278f161e708ef0e7e7649501675ba953260cb96985af584bc6708644f53f867c973bce5f14249cd0b8e00715fa280be46088264a1db889973e7e4e476a812f3772572e095c0748aae248c9e3db29b7a2b549b4ceb21a2f90561b49ecc513bde1202be004372677410b715c9600aa699702c3a413770604025dbbac649e5ef3771c10cc2104aaaa88e99c16ca897ac4ca8a93c44192dc09c3fbc7630b7441acb3d5711ddcd55306f1fa91fa3067a08e2c2bb2143b16a5c7e3330fe0ef3ed35f781b2e1d37ffe48de0ce4b92e1ed0ae7357bbd6ec32fd0b668c9707d7d3e529dd8b9a15e3b5194e4770ee27be4e81ccc7a4fbdc2a4ab273acfaf8fe1bdc5e860c148f73bae635da3f0580d9a588e035cdda2219b56527e74b8dbd650f82126a9a79b628b2bf537f5259e9c253534ff0a01b46b2a7eaa8b20546f03104b454922a9ee33ece22a8ee74fb6d1d8933f76c5cd0eecf30156e4866e09967c5c929470350fa3171931684a0971d425e70da28f364979d29a42052d63005b867885fe27f6db9d96fbb94446e5b74f9e0a9f467e6a47431a091120142073123c69e20ddc78c920c1fc511a32a7a4b6aad269ee4b3aafc30891e5daec122217e779fc7ddd296dada13b90eab5e1d7e4adb7eb79676e05d4711674bc0fe119f95424a2195e92db62e4908cfc6c9faa0ed7e80da7ae99d26b1beba4d37d73389cedf2466ee95a77d57613510f3c1b2ddd3082085d7cc676969068ecdd397ef9f93d92d8636af5f5862ed0945ed58270999164655e83eb122dc7ff618ef692ba0b230b059d65b7e8771c29dea8247ef5e6303765b28d51715ebc301cf9b6241d8ce3dc6e268ef0c06873674921673d57fa8f7710c92edbd981893f56f89c0f5f91b4a502b1f703e91462c80b93e1ec521df5259745fcd0670e652661be5bd37556a8c5b93d2a284727e14b81fe3f32155e2310bf9b0f79f6a1a585bfaf61f723772ca3baadcdbea48f3a766263b9c927cf49230d99af11302ff3d8b6673cbaf7ce271f2f0810ef3fcc8a2b8a79eea0f4d92ce1146dcdf534b5a3d0e973cac91246c7d9b6759bb3732fd8b4494caadf34723b913b2619a49f8295fa263b275583888a0c0cff06afe2bc9b89e6894e03ef81bf90f0d2b03726078e71a2030f464c223956b7c0f7c8d948cbac998dca87d7a93ce2a69119a236d50ceea8d4783e281ea2c1fabd7352456b8d9eef1753825b28180d25b36871e0f79739d670f1a1145c574135653de66bc642753c0bccdaf3b8e3abd321ef82163ca7048768429b6e64879405259c6f67df91221c5d1cd6f4f2a2b0972903fa14ddc61e2da26e7a2e4c193ac463e6cc495304d27ee2a67eabaabe052f0c736df93f28f3348e83c47c9501c6ef73b1fc4f362c68a19f6354cfb18ee149369f5d8fe06d00f6cc51d39c045676c75a70b74432440941bfd8243aa2d5cca1c8b3eabcfdb725ee27f95846d995c6275ee94a6430c61397892ca06b2af79c6dbdbb95835bfc5acefd436e9f5f22b69663f6ff4affc2ff95b01072057066a064ca7a8133a5123cca460679d065c03af6f99316de5e6af37742a8661fbdaf1d5ce93007061db7ec503fdcb16899e23336f25497793a20e4f88e16cfab125b7610da976edd5d77c5147764d8540ffd66f5d97ca5ae834403ffaa739c3acb6d509d5f151365c57465103837eb9de89ce9cc68a8ad32586659c9219d794cacf77e4116e41b8ac6d93f7416186b8939575f8d8e2efddd51f5f8bc02229c47d72a57fa1485c43c14ab70f5262fc34636e0373bd6b0fcca0bfd245e2a08ede3c0e2de1980fa9114f15a9e82fe5c3f8b9e0702b2954482aef17cb8e23183aac661c571802b35d7cd7010e37923c9edaf958aa88ad641a3055c5e2653a2ec089239355e2db36451d25e4d5fec909feb7e21a91bf883071111747bae7ec65308c53561678a30fab2b971b2026f8bd535a50e10378c40c4e80dece9a046ece2eceb42c0bb78bd8da6b89c960715e5f344818ab0c2401d129ff1446a23f05055a5d211e6a056fb18a859a46a2df2daaf02012dea4fb2ea504d091021fbd71a03b63669d22425eda70c1b4292b29c726801ecfe2fcf117fdfb87201504d7f944f6ce427f94975a64b8f8bcb94ef8b3eb5fbc717daee1fda5b11b04226d842667521bcfc98d7b85d55ca0ae27e8b73123f712722cc9a66a8cb1e9b1ea5996c168a3fb31d2f3af1c90030f94351c987700d067c920453aea4049033a1ddb83140e1fb5c4f6cb81bf1dcc764134089da2d2f4b0d783f6ba6be9716caf3ff455784d6242a0cabcbcfc3afd5262</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成年人呐</title>
      <link href="/2022/02/10/%E6%88%90%E5%B9%B4%E4%BA%BA%E5%91%90/"/>
      <url>/2022/02/10/%E6%88%90%E5%B9%B4%E4%BA%BA%E5%91%90/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="bd14a9eb8a580050234a590741e3b278b0fc32139556a42926ad46081c8f2d22">c172f4ee74b2b6d246b20cbfdc0b877e3c5bb7f712e97548f8a290a5810ed13ad1a232e9bac13f74c6bbbcacde9ec62adcd72baa74dee248412382d3ff42cac7c780a33e54885d70c7e27579afb0a5111e8bd43aff9a8ecce4c327a4f09d0de0260e31ab1c2ee7b7060e64cfa85a349620e4ae75fb2974383a01bfcabb9955419e6b4517386be7436167ba768b9b67e10ddc9a84db80bc77cf6b97e0ecb6af963037625e6c5bc82b390dcbdf118c0fa48120bc50fb21f87ee02114d8ca2f30abab8819aa86b00da62bb1a7ace710a0d3438b2b5584ab79657102a9d62951a107232160748ffaab30172f819ae99d3de000d572a7d1ccc87730689e777d9d069c4ffc105a2dd41ef989bb76b18b6b804a8585e7757974fa9052d24a6310f8a446520a616d20b448b303c3c3ccbb84a1cab97a2dc5df8837a49c9bc2e5027ca9853baf9b57467878ffb7a5e1a29d65df2e5ee2f42eccef36c9a83eda2d40535fe1cce3c9b992a105696eb32139166409b7804e9b727eac6e2d53b5400a2bc1ea5612313b2e1094ed732398a719e21fd0c5b938a7c06bf79c11be7acc8126b7aa8858060274a332c965bf27181c0901526cb713a9d198a30cbd04977a3b7cce913b3ad402ceddf3a488a370b2413e043174e486fc8f8e64c63ffd4ead34d6f279d98bb05e105e8583e4ab979122c17186e50a1ac0b3c8585128c8f63b68d746d247b1b566e6ee75436f84adf1866cad60d405a8f0a69c55019b7d7b95cfdcbec083b5e0cc87f0f590914ef0901f68f7ce8330f50429b1ec0d5131225596a90e00d26e4b49990c2bad1afa3be9c6491d0fd4a1f0f471ab5a17dd9067191419470e29a932f5f17d15b7887ababfbe70db959e4462c0a7d218b6fae963cc2b53e2e720b77088e33c8033cf933382b4496168dbe919d4294811bd9e2161b164cc88301d215b06ad8999c8411d5ecb00e51f5bb2ff9da1e2f351c9f6ff61de2f0ac30b36982e7203222ba03e0078a3efa317f52e6933f45f111cf60285316b71a8dade292ae56a6dd3fa3db27e80f366f3c4d83d365bbb685bd251644a519bd7646e848d5e12d0cb1c66ff036652401ab234fa39af7510de11b0d8b90b34a3025fb4ca31b19fb90eae568f54d18305464ebba8f48b4116aaf0f4c3b71fc9729e324e3ce533333ab18fecef10fd6da3b92a20348b12c0e61e78090bbe574bf15a89f36cf726211145d67ddf9a506493fa9bdbda3707060708531dab2d4119a24920d0b17d66e10e12c05e544f164c421e4d1c9fe50f63e5477ffde2c7ad0a80f780979b977ccc9674015c1c6ce118b08aedc61ac4a30daf4c4551302f1e39c5661295537fdaf5a2a58ced383636a8fdbd4260b3b166a3c1376e5a0e8c0b2fedffe2ab53d8a8ae38ccccecf735d19d63e2f5ea17627529f286949c73e4b08b028f00d67c14016f53e45512c783e08c27e1f393cc086c4e63ff1492d4bbcc5c0f8b48a034012842d801e7ef4ca02014bbbb68af430351d84b592cecfb87dcf81cd4390c24265fdb6ce7b7478629ba125b039c04d0447a4e79ca33b45f470e47509ec9a1d505b6335349996b69b97563e0733a3e4efeafed9cf9b9478ef4ecbb9259b769ac3338d130d2f8db0b52fc3cf356561c565f2dfaa3956a0754ab74464878771ed7dc175c4da430e85cbe479952ca483ecebfacf39a5ff99b1180ec12a984a41d2f265c2008d13ad0025a9a359e30c58fda4ed7f0bfccfe7970b6234d8f3f3f4c846f8efd8cf3e7c46bead8d15b0c649520013024965cd30feeacf60028b799744370495bef73a46c4de8dedc723da855b98eb808098e38674e3c4398cb4472be3b0fd8707bdb851c70c49c5fb5856f0900292b1e8eb91f760cbdb155c349c1933877eec0d5d786ced9387df059224ae3ab969f3b3e766aa21d0d52bb34e7e17c69662cb3037864533b4c35d4f621ddfd6cf9c218a5d2a171afe462bea81bb028504084871ffc68c7eff5d893f0d835171b0ac5463f791a7b77e82e02972160cfbffeed8c73288a85511c5f8c4ec87cd6e27ea9fb29880a6797ebbe8ba7805eb542f3dde8a7dc2d7cf58684f351aa1771ce68d031767a40507f01b1e7259d0f1c59ff06e84367fa560539cde17cda8a677a3afb90d05d67a8fa96b295232384fd99fa9f6865d63beced6e952a1b309adf8e524b0ec17490b496e84cc4b97bf5149d3ad86bc17b7d4eb9dbe038c4ce4dd6092bc7ba08aade18db490dfbcf1b10c312391d5a2926ffa6e7c771895575d1e8c0a5df5d07e706aa353682aea1599ca4ed49f1104d6f8333497e71df3661c6439403f84c778bc81f7048b6005af8362b6a6502156290749e21dfccf33af6d2cef0cd77c0a46e333c0c13fd13e49431e324f902ca043c63e4d60be631830e550962d13fd9b28a91a7be9bd568dd5a505e6b9d00a8029b7c0bd1d710256904b08ad3a6826731ad03cdc41eebcc680d49d0bd37544511fe3a07fd43847467d7cf7040bd882fab1a6e8a7f9e6494803efb8e61010cfa938f9cfcc0a296f271fadb1c0ca64d917243713307d0d1625ccf4504ce390587d6e8a20ff550a78239c59d933ce24a7d2da328bc9330641f7b2dedd5ae1fa7370d271b21955e83847b0c78c2f4f383d74cb8a2f2ace5281b4565947bb4370aa31719239f96f4ba5937d5ca5a48413656f89b3c61916fef63a29f776f2379de273c2f162ddea0e1c19cfd32323d1e0c62f34fe1f34353fbeee3f1eb8401607519e76e0fd95a2200a8fc5c12e9701ee9ba581a35938246e2434a5ac528dea0ea539541be245b9a5cad662bcbb4fcbe3af16b283e5c9bfa9ff513e3e78cdd0479f892d8dbd97ec66cc9eabf41d9085c86e89b04317251afa014208e805f352485e6d66ea5a0535188c599ba284fc66153959fafbd08a2ae59f60cab7f28704b7feb3d4d429bb4cbf472532ea631a08434c189b80c8bb5b1ba67abc638f772ab69fbafdd82a8efaae7eddb592c4957c49a02fe8ba6b43b1e03f802547eacd7557747c3fef73e72aac0142c06fc1540c4a3a0f74dd01b7ead3f8669f601f5856f9e21f22ac51b680b8366b9bcbc8316c314f1db7d9b281a7a17aeea264c76478dc5f75f97dbed876922ffc8a537a57a0e8f6c069fda270b68e9e9b9f106d0d3e554a9ad1a5ae62590aed8d89f6b9993eb9213dfa3e673a9bf6874dec1b439498740dae64d8323f839f954dbb265e9918624263c2350b79e694c49820e4be70a37645bb1eab69c5822358ac8fa0be4c573d5911d688a68dd802f92213d8b4a77b4be56f8c5ea959b3f033ced685e1cfb98ae8110c1fd1387475210139b018e87aa8e34605cf23d0ef07eb0602f67aed5042b811ce7c93d486ec5c38b3a20680893</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中途岛海战</title>
      <link href="/2022/01/13/%E4%B8%AD%E9%80%94%E5%B2%9B%E6%B5%B7%E6%88%98/"/>
      <url>/2022/01/13/%E4%B8%AD%E9%80%94%E5%B2%9B%E6%B5%B7%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>中途岛海战是第二次世界大战中太平洋战场的决定性战役，其地位堪比苏德战场的斯大林格勒战役以及中国战场的平安格勒战役。从小学至今看了无数的资料却仍然稀里糊涂，但愿这篇blog能解此心结。</p><h2 id="战役背景">战役背景</h2><p>1941年12月7日，日军偷袭位于夏威夷群岛的珍珠港，以极其微小的代价重创美军太平洋舰队。不过这次偷袭并未对美军造成致命打击，尤其是美军航空母舰依然完好无损。为了逼迫美国进行谈判，日本决定彻底摧毁太平洋舰队的航母。为了将航母从珍珠港引诱出来围歼，日军最终决定通过“围点打援”的战术在进攻中途岛的同时伏击并歼灭美军太平洋舰队，即所谓的MI行动。</p><h2 id="战前准备">战前准备</h2><p>日军方面：由于珊瑚海海战中祥凤号沉没，翔鹤号被重创，瑞鹤号也需要休整，因此日方将剩余航母划分为第一航空舰队（一航舰）和第二航空舰队（二航舰）。一航舰由日本海军最强的4艘航母组成：苍龙号（常规情况舰载机52架）、飞龙号（常规情况舰载机54架）、加贺号（常规情况舰载机63架）和赤城号（常规情况舰载机54架），此次进攻4艘航母共搭载248架飞机以及12架侦察机，一航舰包括第一航空战队（一航战）和第二航空战队（二航战），一航战包括加贺号和赤城号（旗舰），指挥官南云忠一中将；二航战包括苍龙号和飞龙号（旗舰），指挥官山口多闻少将。二航舰拥有2艘轻型航母隼鹰号和龙骧号。需要注意的是：此时的日军飞行员毫无疑问都是顶尖选手。</p><p>为了掩盖真实的战略意图，日军制定了极其复杂的攻击计划，并且联合舰队司令长官山本五十六要求路途全程保持无线电静默。一航舰的主要任务是：夺取中途岛，摧毁岛上的飞机和机场跑道等重要设施，为登陆部队扫清障碍；寻找并消灭美军航母。因此南云将一半的舰载机装备对舰武器（鱼雷），防止美军航母出现。二航舰负责占领北边的阿留申群岛作为佯攻，试图声东击西来分散美军注意力，行动代号AL（Aleutian）。</p><figure><img src="https://weaponsandwarfare.files.wordpress.com/2020/06/midwaybattle.png" alt="" /><figcaption>1942: Japanese Options | Weapons and Warfare</figcaption></figure><p>美军方面：1942年5月，美军已经部分破译日军无线电密码（据说破译了80%以上），还通过经典的“AF缺乏淡水”钓鱼行为确认日军的作战意图，因此总司令尼米兹上将决定提前设伏，将美军航母部署到中途岛东北部，在日军攻击中途岛时发起偷袭。珊瑚海海战中列克星敦号航母（CV-2）沉没，约克城号（CV-5）被重创，但是美帝损管仅用了3天时间就将约克城号大致修复。美军3艘航母分为2个特混舰队：第16特混舰队包括企业号航母（CV-6）和大黄蜂号航母（CV-8），由斯普鲁恩斯少将指挥；第17特混舰队包括约克城号航母（旗舰），由弗莱彻少将指挥。5月28日，第16特混舰队率先离开珍珠港，5月30日第17特混舰队紧随其后，6月2日美军航母在东北部设伏完毕。</p><h2 id="战争过程">战争过程</h2><figure><img src="https://upload.wikimedia.org/wikipedia/commons/5/5a/Battle_of_Midway%2C_Movement_of_Fleets_%28ENG%29.svg" alt="" /><figcaption>Battle of Midway, Movement of Fleets</figcaption></figure><p>战斗前夕，中途岛附近出现大量的美军活动迹象，由于前期的潜艇侦察并未发现美军航母驶出珍珠港，因此南云认为美军航母仍然停留在军港内。1942年6月4日凌晨日军所有战斗力量就位，0430战斗正式开始，一航舰出发轰炸中途岛，4艘航母以惊人的效率在10min内放飞了108架飞机，队长友永丈市大尉。同时仅起飞7架侦察机搜索半径300海里的东部180度半圆形区域（能覆盖才见鬼呢），由于气象条件不佳，加上南云认为美军航母在珍珠港没那么快出来，因此日军的侦察形式远大于效果，最终因此付出了巨大代价。但目前来看，7架侦察机中只有从利根号巡洋舰上起飞的那架晚了30min，其余一切正常。</p><p>0532南云意识到自己的一航舰被一架美军PBY飞机发现，意味着中途岛的美军飞机可以提前起飞避免被友永炸毁，事实也的确如此。美军轰炸机提前起飞后直奔一航舰，只留下18架老式水牛+6架野猫战斗机负责岛上的防空。0620，留守的24架美机在距离中途岛基地30海里处拦截日机，被日军的零式战机爆锤，13架水牛+2架野猫被击落，日军轰炸机随即轰炸中途岛。0634日机开始轰炸，美军防空火力击落11架日机，击伤14架，也因此导致日机轰炸效果不佳，飞机跑道只有轻微的损毁，因此友永丈市请示发动第二波空袭，彻底瘫痪中途岛。</p><p>0710，日军发现第一波（中途岛共起飞了4波）美军飞机（6架TBF+4架B-26）来袭，30架零式起飞迎战，美机投掷的鱼雷均未命中，5架TBF+2架B-26被击落，一架受伤的美军飞机试图撞向南云的旗舰，最终差之毫厘，日本仅损失2架零式。此时南云收到友永第二波空袭的请求，南云可以选择让友永返回航母补给后再次发动空袭（大约需要60min，中途岛可能用这段时间重新组织防御）；也可以选择使用航母上的预备队前去空袭（但是山本要求不能出动这些飞机以防随时可能出现的美军航母）。此时7架日军侦察机（按时起飞的6架基本达到航程极限）并未发现美军航母的踪迹（云层帮了大忙，从筑摩号起飞的侦察机没有发现企业号），而且自己的旗舰刚刚差点被中途岛的美机撞到，所以南云认为中途岛才是最大的威胁。</p><p>0715，南云无视山本命令，开始在下层机库中将一航战预备队的对舰武器（鱼雷）换成对地炸弹准备第二波炸岛，俯冲轰炸机则直接在甲板上安装炸弹，这顿操作需要大约90min。0745，从利根号放飞的那架晚点侦察机报告在中途岛以北240海里发现了10艘美国船舶，南云吓傻了，命令停止换弹（此时有64架还未换装炸弹，换装了15架左右）并开始分析研判，有2条路：其一是立即起飞所有飞机（挂炸弹的去炸岛，挂鱼雷的去炸船）；其二是等友永降落后再去空袭船队。</p><p>第一条路不符合日本海军的作战操典，而且也没有多余的战斗机护航。由于无法分辨该船队到底是普通的运输队还是航母编队，并且按计划船队出现的位置并不属于该侦察机的侦察范围，要么侦察机偏航要么报告的船队位置有误。如果报告属实，那么该船队很可能是美军航母编队，因为这样可以从侧翼攻击日军编队，可是如果是航母编队为什么要逆风行驶呢？因此南云觉得大概率是普通船队。除了这些情报外，时间对于南云来说非常紧张，燃油不够的友永编队大概在0815到达并且最晚要在0915降落完毕，整个编队的降落过程需要30min左右，所以最晚0845就要清空甲板让编队开始降落，因此南云需要立即决定到底是选择第一条路还是第二条路。南云从0745获悉美军船队到deadline 0845大约有60min时间，但是排队放飞所有飞机并清空甲板需要45min，所以最晚0800就要决定是否起飞，因此0745-0800中间的15min才是真正供南云决策的时间。</p><p>0753，中途岛的第二波16架无畏式轰炸机接近日舰，日军派出9架零战，美军飞行员战斗经验欠缺，因此无一命中并且8架被击落，日机损失1架零战。在0745-0800的决策时间里，日舰还要走位躲避美机轰炸，虽然也可以起飞但是风险较大，并且此时45min的放飞时间肯定会被拉长至60min甚至更长，意味着即使从0745开始起飞，0845也很可能无法全部放飞并腾出甲板，友永丈市编队大概率就要坠海，显然此时先让友永降落再去组织攻击是风险更小的决策。另外根据侦察机的报告距离来计算，美军船队至少要到1015才能进入攻击日舰的作战范围，因此南云认为有充足的时间回收友永后再去攻击，加上南云本身的性格非常保守，所以选了第二条路。</p><p>0810，中途岛的第三波15架B-17从高空投弹，IJN闪避，双方均无损失，飞龙号差点被命中，下图是其风骚的走位。通常在这种规避转弯下是无法放飞飞机的，只能等待美机攻击结束后再放飞。0820晚点侦察机报告美军船队可能是航母编队，机库里的飞机为了攻击美军航母编队，又将炸弹换回鱼雷，由于匆忙便随意将卸下的炸弹扔在机库中。但此时仍然无法直接放飞去进攻，因为友永编队大半还在天上，因此南云只能等待，别无他路。</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Japanese_aircraft_carrier_Hiryu_maneuvers_to_avoid_bombs_on_4_June_1942_%28USAF-3725%29.jpg/1280px-Japanese_aircraft_carrier_Hiryu_maneuvers_to_avoid_bombs_on_4_June_1942_%28USAF-3725%29.jpg" alt="" /><figcaption>IJN走位</figcaption></figure><p>0827，中途岛的最后一波11架老式俯冲轰炸机来袭，但很有自知之明地选择攻击战列舰榛名号而非航母编队，11架日机迎战，美机无一命中，损失2架。与此同时，一架美军潜艇鹦鹉螺号向日军雾岛号战列舰发射鱼雷后被日舰发现，雾岛号躲过攻击，美军潜艇跑路，日军岚号驱逐舰离开舰队追击美军潜艇，“带路岚”最终返航时带着企业号的美军轰炸机（麦克拉斯基少校）找到了日军航母编队。</p><p>0837美军攻击结束，南云开始回收飞机。0910，友永机队全部降落。不过最迷惑的是这段时间南云的编队竟然朝着美军船队不断行进，而且日机比美机飞得远啊，为什么要主动靠近呢？接着，南云只需要等待45min放飞飞机攻击美军航母即可。0918，美军航母编队15架VT-8鱼雷轰炸机来袭，被零战锤爆，最终全部被击落，30名机组成员只有1人幸存，日舰没有受到任何伤害。0940，航母编队第二波14架VT-6来袭，此时停在甲板上的日机重新补给完毕，满弹满油，事实证明日军侦察机报告的距离有误，美军完全不用等到1015就可以打到日舰。美机9架被击落，日军损失1架零式。这2波攻击虽然没有造成伤害，但却拖延了日军放飞窗口。</p><p>1010，12架VT-3+6架野猫继续来袭，美机采用了著名的萨奇剪战术击落4架零战，仅损失1架野猫。美军的护航战斗机吸引了大部分零式，使得轰炸机可以抵近日军航母，在日军航母上空巡航的零式不断加入舰队东北方与美军VT-3和野猫的低空狗斗，造成日军航母上方防空力量空虚，这一波美机损失10架VT-3，日机损失7架零式。其实这一波又一波的饱和攻击并不是美军安排得当，恰恰相反是由于航母舰载机起飞管理混乱造成的结果，也算是因祸得福。</p><p>1020，50架美军俯冲轰炸机（好巧不巧，分别从企业号和约克城号起飞的2批编队飞了不同路线，并且约克城号的放飞晚了30min，竟然同时到达）几乎没有受到日军防空的零式拦截，这一波南云好运不在，加贺号被命中4发，并且引爆了飞行甲板上的满油满弹日机，苍龙号同样如此，赤城号被仅投的1枚炸弹（贝斯特少校）洞穿机库，引爆机库内未被妥善放置的炸弹，只有友永所在的飞龙幸存。1030，南云将旗舰换为轻巡洋舰长良号，日军此时已经注定失败了。山口多闻意识到自己的飞龙号是唯一的幸存者，开始组织反击。</p><p>1045，飞龙号的6架零式+18架俯冲轰炸机奔袭美军航母。1050，山本获悉战况，召回阿留申群岛的隼鹰号航母和龙骧号航母，以及其它佯攻力量救援南云，可惜远水解不了近渴，此时美军航母舰队向东行驶远离日军。1152，美军雷达侦测到日机编队，战斗机升空迎敌，重创日机编队。1210，日机剩余的轰炸机开始攻击约克城号，4分钟后约克城号瘫痪，日军13架轰炸机+5架零式被击落。山口多闻自信地认为已经干掉了约克城号，接下来就是1v2的局面了。</p><p>1331，日军第二波10架轰炸机+6架零式由友永带队，山口多闻要求再干掉一艘美军航母，这样就可以出现1v1的黄金局面了。1430，友永发现30海里外的一个航母编队，看起来完好无损，他认为是企业号或者大黄蜂号，但是美帝的氪金损管使得这艘还是苦命的约克城号😂，美军6架战斗机迎敌。王牌对王牌，萨奇击落友永，日机损失5架轰炸机+2架零式，美军损失4架战斗机，约克城号再次被重创，1500舰长命令弃船。约克城号很坚强地活到了第三天并差点被救活，可惜最终被日军潜艇I-168击沉，同时参与救援的哈曼号驱逐舰也被不幸击沉。</p><p>1545，剩余日机返回飞龙号，随后山口得知干掉的仍然是约克城号，随即命令飞龙号撤退，准备休息后发动白天的最后一波攻击。又一次迷惑操作，飞龙号一整个下午都在朝着美军编队行驶，可能是已经杀红眼了吧。此前1133由约克城号放飞的美军侦察机在1430返程途中发现飞龙号。1705，企业号+约克城号的24架飞机抵达飞龙号，由于日军没有雷达，13架疲惫不堪的巡逻日机直到美机抵近后才发现，4发入魂，15min后大黄蜂号的机队抵达发现飞龙正在沉没。</p><p>山本最后希望再赌一把，利用其它战舰在夜间和美军航母对决。由于南云被撤职，近藤信竹中将接替指挥，直到2330仍未发现美军航母，不久后全体撤退。6月5日0255，山本宣布取消MI计划。</p><h2 id="战果分析">战果分析</h2><p>日军损失：4艘航母，1艘巡洋舰（三隈号），250架✈</p><p>美军损失：1艘航母，1艘驱逐舰（哈曼号），144架✈</p><p>经此一战，大量的日军优秀飞行员、经验丰富的机械师被消耗殆尽，后期只能神风了，美军完全扭转了力量对比并开始在太平洋易守为攻，采取“跳岛战术”不断迫近日本本土。退一万步讲，即使日军勉强赢了中途岛，也几乎没有可能战胜美利坚，强大的工业制造能力背后蕴藏着巨大的战争潜力，后期战舰下饺子就是铁证，这绝非战争资源匮乏的日本可以匹敌的。</p><h2 id="reference">Reference</h2><p><a href="https://en.wikipedia.org/wiki/Battle_of_Midway">Battle of Midway</a><br /><a href="https://www.youtube.com/watch?v=Bd8_vO5zrjo">The Battle of Midway 1942: Told from the Japanese Perspective (1/3)</a><br /><a href="https://www.youtube.com/watch?v=BXjydKPcX60">The Battle of Midway: Hiryu's Counterstrike (2/3)</a><br /><a href="https://www.youtube.com/watch?v=WHO6xrSF7Sw">The Battle of Midway: The American Perspective and The Strategic Consequences of the Battle (3/3)</a><br /><a href="https://www.bilibili.com/video/BV1Rh411v7de">再来亿局能翻盘？中途岛海空大战</a></p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> History </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷静思考 拒绝盲从</title>
      <link href="/2022/01/08/%E5%86%B7%E9%9D%99%E6%80%9D%E8%80%83%20%E6%8B%92%E7%BB%9D%E7%9B%B2%E4%BB%8E/"/>
      <url>/2022/01/08/%E5%86%B7%E9%9D%99%E6%80%9D%E8%80%83%20%E6%8B%92%E7%BB%9D%E7%9B%B2%E4%BB%8E/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="739c8fec141cfca3e03dfdd9953da73747ebd6989dc0fba5b0cb69bb82178590">418fac4f173397084caccc18ab9f089e4418037cce73db100e9f35c582f9caba008c1027876eb9e3962ecf8ba9f8bf51e9acee9e312b6e0d67e8b2667ebf104101c4cd3e92dc9438b278f7ae71873e741a11123c63daf87a478d076526be1164a1a6190ea06d6bc270fba1e0647cab898a9cae54aad673db6e3b34c64720ad73642f6a7bdedb6b63a30658990e3a514cb7815258a2e94b69fd3ad71b080b7e2bcc3feca63f7c2980fcfe4d4892200bcd75d9574f57d1559601a95801b9637c64d5e070f1015bc6533744b5ed3f5393d954edb3b14dc22a69ed70536a43b4713744242701b201826f9dff0de9dc244757c2e7db3856b281470dace5fbef1d445e7be0b4f46af3dbb9a2ad54583b58575f416ea745c8998d53ee2310c464cd49c8f5bb50018c22f6f93870c56d2aedf5a79ceb14d38fbb11274bc814717dee367de94569daf4f2967fd366ae815980b74d6d56f865c9c9d1b220666e1c5e23f131c096b815166441fe9c254075b3d02345a7c6c0560821f9b0d16af3d7e571d4742795b0763a630b4694b590f9f928e19211215e6eb43e17c011fda76564fdb78769d3c71c837936754b33984ca6c287cf2d7b1f0ff88b15d7cda255050b9fdc88d2f6702ceddcd8fa748d72e6b56ad6bebe01b36c6542f0eeb32fa69408930f55fab6accdf14f5663b2fea0fbe2095a6d2ee8cde50242374d79a749fb914bf4ad2be7ff0a06e7bcfd75ab1f059bb67b38c73e6ed65e9c1a3b37d128bb9eaf9a40d83fd9bd0fb2a88593b1083fdc325c235560ea96ea2e0536d7c6336812d73eb157fc077783187ad00c3d5553ef7582039311fcf8379d1e526f990ec07ac1c29e9edab3de42beb0efdb187b8480f40b5d3bea691467b28b494a8bb9d011313897e538a424f7f5c2335d248f1410878b8b047237300653a80d862c654644e8d17e999f30fd2e034746c2196fee0a7440552800b9e37e7246e42e84e2628722f4d733c44fcbd2124f92488f2b2ffecd4f59480ece83edd4ad7c9d4b434dd731d24d51c1a2628877c81d5347abfaa32a9027226b8305f51b10ddf22392e490fc9fbd0cb7e6a49395a84781e3329abfa04b674974f6149278adbca09871227e8b44280cddb12a0f32cd45c3872bce53d98b03a75ae8c3a014f9f49573fc1fcdd2246db16b17ba67e88a0c08e8270c9d1ba296ecd819e8a503b8c564179b1887403a45f12fbacbc921cb35443cf875bbaa60fe3b89b393b7db75037ebc98fc54ff82adbc7b55db3c87eb3116c7346ffbd66c23df9affadbb76bb8e28c910c06be1989fc3110f435b547294f0058d86e7bceecccc95c1e9b9d2f23d26ce439b60a5b96505a237519621baa45455ef8f428820f82b766fd75a261aafdebb973a448778baac2b3d75ea4ab7d9012451f062b0c98fbcc2e1416806f6cef1f8fc4e9a9f08759dabde96f12c07e236a353eabfc9377dfacc07e62b29e65f5e2d663be74897de04a77648f90e0724e12cbf271295ff896b475f86083e899f07850bd2e089566b2ae24af6f152d905fd67eabe1f7946c50f6d224aac7b1f983a20d833a4474cbdaf29789dde8e7d934b4dd076a1f076d78fb07e1b16f693e8ff1a943a5fe4e124bb1bbce5a0acd18ac63e2c80403c42c7291acdf2ca5e1f0bb5556f5513b092cc4e4cf9cde25034ef41f6e9b64aa977ffda90ef434880d6a0d02e3f6d216c17e919e2ae037daca2cd82e95dbc0b1e0ed2b4a54bb411c5971053f986b4100d7c9f2511c45c5d683c42bf75822797b56b6fddc1f22c3a3066fa8f61e6fed76134da4850e68048af2c5c70b751a8741ae945bfa7a518cd308ceb662602f04c8a778e079ef1fbe12e7fdddd7834d40e059d61ae3419013f6b203c5a7aa7e23c9b3cf5ff6dd4a0058ec09c011502318b7810b4a2943cab19b47c47da644bcee450e9774073a5983ffcd6649ce92a54c48f2f3927305434b6193b85a31845e50eb9295f177833f30f147091ee181fcdabba96c30902e0bc0177d5acedb419ccead26d157e98d2dfd28c9994ac7135b2f80bea9939be27fa3bd3b58fe4938f92b54658b677ebb121a2c51dca5497b944a44572a3ad79fee9972e0905bcf89230f5db1808abcd441178abdfc1bf1d1cf3722fb8f19116c0c45ec7b9057412e3616936797baddec788f40219582e841699043b80554e802c4e1b54a175c75679e1daec6df81cbef2b2be94067c8272a451a1e8113d9cb60d966bf7ef657a993c13ae279c257561eb2a57d863adc681d586636489014aa0090c862a59f9325f16dee9200bca41f1301aa139eab4c1582a7852b278c3ed21cc5b0278eccc5393ce92bf6fef9f836bc437a377ffb17da27aa45f772599bb293d8d5f2e2613418adad1d86562cbcb1107fd1a12c15dd33ff36a2733de95bff9c5ec25b9cf70712aec03dce1772cbc83604e4fe09d801d073609f3d7e0f4348804eb21f2a4a179a4d1f32885312b48b71396c15c7d2463a57df7d670f2eef8cfae417f608a9b533481925b7f7ad81c59987247ec9df42a5738b749bf2a287fe32c2a75edaa666a56094cbd8418c459e4c94ff97b3af5a45495fc3a1754aa0b45a7e552d8aa923cb2dab3a2444effb8c0c374efe40b25328a48af84ae05b86814b7a83c3dbdd160135e7a503d74506b63afd856567e5fab04aa47e25930e6d972ed450b4cbf0b5299bc174449563dc183b318ca3c089ef90690809bb61a46c289b7d17998819ca8aa277322b982c0ea7d08caea386f87bcfd7c55abcd34e40e5613086c1a34028fdce94f5007a21d948be25e8d9bbe4744148449e737b29a68db405edda67a4c6bc0275ba1a12d3fec936ab002cd8d710557e30227f16dad0e3bfeed2ec3be2851a7bc3e5b378c056c38d47b6f7fd171e58ece17d5fd951d08ea6df6ffa97b429a0ce437226d225c69660d88aefc428f682bbe7729aaf16a53879c2bb96a7cf36cee120b3b75d74e20558b03e03afe6dc25239004d135fcacae064e8d57f6d02de05e8a96dd36f306ac8f92aac4cd7d32b0061d6882ef1a35a1ad0c83cc7e027c9fe11e113e7656165f4d5dad2eb0ecec1d7bad8157eed21b2173f991c5876384e618e9b0bd7b138a35c3516154c5024797cb3d0064596c48b184438afdc3a7d5154058a36d28f77959c612a4f97f40a83e4e49173a848a6af0d083cee0d3ddba0be5cf56e45a1a4ee1e54ea06aadebf55a36d9fcd047b74379c7654b680bffa7cb2a23f9d3f3fa7079b243ec59e448ec958fd6937b55a6c8e801cdb593703970153eaa12c9e27ea26546cc8e13cac837660f1931db1c0f2b32d3d79e60b3c9cbff5ede82f672ab2bacc3328f40d10295abccaa2faf73fa8d43d48b0a25674feee582d2f3d7f70ff0533d9a8d72d0db26e56ddd95ff7c002eee44f5877f2c79a6cac5f0e9c82aa434f8ecb29b2687bfaa98265130f0e396a46bb99a643eefd886a3812d9a02d1deaec13c418390bca24f5d0ab4007223c86292c3e8a16b49351399a8d251df98c614a3ee5689b09b18e56ed39ecf521c2312e27fcaa223d99756a2200a754539609d94c23e126c08f5b4e52d2d0f145c7a522e4f49361894b7a745e6e993169ce1225c62c0712ae79063ee7027c69f28f98be5d48af6451c0a3ddb1316362ef665b00243d2083a78a891ef2422f1bfad8c94594867459a86ad66cf2c8bd3b0dd270f38a68ba0a0abd5fa8aa37fb22a886c0a050583ff55e21fcabace57d00120ad6a0de883c35fd051efd6b1f5fb2cc87b073888c85166f60966a6122441179fb62d2ac2e7a595c03b99335b5ed4aae07264c475b6a788bd727ee77ce0841d697ae05a68ca6d38208351d1223c70524b72722f221ef1b9e37699e0ece87b51f8d5df6ed81a5d9d294fdbc7b997abb90287269ac6d374a71a0ef4420bbcc9e40b61671157f91058e83f6e8ff5f87e45bf5fe340ebc66ced3f0165c8d42bd0d23de79937311769c38efb841521ae6ba53973846933e211eb37cd770307ce5ff561864aa28c5c24e40820f361ca535f3963b4f369942eab9d488dfddf81b30ff5d5cdf7f96a8990376edefb5ea9325046820b8c979b97266723fd99e36dea4be9095dbef292076e232c31aee5197d3e21f049da88e928b9ed9ad1bddf6918bf78c8d61733ba2313846d55cefa21a624ee470276be0f7cf141e775adce102efdd9ba155b42d61c8320ee9f4b44c4ad6edd6044f873daddd3e5e0cd79049b791087561542242111960e9ec8a1f4691abc0512c7562ab52d0e0c1ac3f9e330db4a2d5670ad860999b9d43e886de04138f10b29ff9337be562317c24d7d31d8a8203087f179d478abef23abffd81921f1a2b54efb08f8c4d48118bd705d1372adfdaf16885934dc9c42d9334e3e5fba45469f8c842cf0a7b1097ab3ae3344049c91db6b8fe4f160a5280b0c98811b21bca3fc0f820d383b0e529ddd1548cd7ac8f4bdbb26fe098bc65369a48a6a5dac413a2961e8c6f88f28bcf82992dc6e14b8032008180f814867b3c16c99e01257fb68579ae60f4a98448e84a51c6365d0d838ff4a630dc50a926aa4922e975dc73aff1991a334ea97c26929af4955ab25cfe96b95d1eab78702d75facba6d2e858358252440b63cd027d73e18c79561e2841754b4cb8a9b614d6c76d29737e72633d7edd325c68f82dad2a75053f0db1297055eaa5275adf0442dd1816a339f1621296554b19ceb1004682e01ea1443689cd59ff87b99ac6445ce81b8a08009e10330c52b2bb6db5ae29930d2d60fd6b208dbb056eeb996a76e4151c7f56c262b7644bbf73594f109c71600a278519620e02b2e6c7ea014e1c11db744e8cc24c1e1033c8407a20ac1b7d66195faf94c9cfe8184ca837740da5ffb24ba8cb61bdc139221c9add39eed963cd83a746ba9616dfbf89200e0a40ff8b7503096f64d93567dfca99cbbd4d7eb4ae819742321c92ccd12896c091c447f49e953a1f745fe1d32567b503cb87df54cc6aa2df1e8c63ef879af7e32e44e4c7a8c4cf42f0aa61571021a53566130d635573d023523dd87953a3ee95db0c7e246c5af8d51ead7c39c0d753c18750eec8c3a4d8268628ffef3af2a63a5873f44710a5e687826b832a4a1e9f86128a70937dc7a766ef964290844058714605e9e5bf24e48044f1f59c136ed129e675182388d2c1802936f7257219c21abd52d86fe1287e7c311c8f23b31e22190d7108ee1b696e79dbe3af583eb6b63922f77f6f02c2e86b4dc9cdc8893c62bc24bc41d001391bde1604477b4eba7cb02a4fa6bf8fdc82389aed9af92313d64f2da90fbdce3a80bd3ee5ba56f97206d0d5023f32822393956dda07d5a005502f36ad9741c464e65876e98de8bcbe179fe5ebe6ac11932fcc273a5e29cbeb642cf73da413f99fe86380667f84b13e4fca3968dec6e980a687deae500067096bef5913e03021c9700724805fa719679d3737850435936b9967578de6e3aefb66575d7c532dd83a6b151fba387d6cb07b2a6a3216a924413b649ed1f6437180632c0df06c095c72d31b4fa68ff6ebc723cfbf70fdb59e28fb4f44d7cfedc218e6f71614ef62766dc6b9ef23f1df0e9710a0bbcd72d3485e579344b9022c068633b682d2232ca7e2e05a14f0387f7b14c8e19bbcf10057987c1e25c771bdc89aef6fda5ead55df0ec8ed40818be294d3099236e9384b5b6b948a3643b6899e3da5d1ffa696c596d5197e19415e56844674c6af74fecb4962f38bcac7a59d76f7ee13407471ae1d2760fff32606214bc8fe8c694b8ff1d8d86ae4372d9263efc5c48d9a6fc39c62888ffedc2d3ab4d81f0196d743ced9975f196ddb6d922216dc072f14dc58c4caf545e3e0da37558068a37532b2a33abb3d4a11b5e40316a1c1d13cee143da5f028d46502125d6ac448b5d665c6a9d6a72708ef0f3c3c567e77f9c3fe6616556cbf384a9ed1c4162e2739f46b299faa75a3d2760f9e491dfc6904fb70950fb9e65bcb329e6b9c51e997f0262e26bcf38c2e7229eaa60fc60d4eacbda2772084292e5f087411758c078821629374e0382b003c5df6fe10bcadb6b60c23a19a1a23c51c73312c2317b052cb800e96618e613da3c4adceae4c404350e229d62e3786b4324a8caa0c7cb86267ee59558850df7bb49462ae80e290f48fa41a0d8e98350315621017b8e2513b4bca82936419b26618ead36455bbed2568450a9abf349c67d593c50bef3499add7c5207cc69157eb4fc8bd678e0bcbd7b7343b55ad56fbc99181ae92401586255e93c348a441ca7b5b612d1f66318872407fbfa7083a9bcbeeef2aab902666152d515772a20bf1faa98314edacd846a460a366c9e1d4dd3a6fad5fa88e4b5a3da1459be7921712ad96f7f686d0a7f6a150a21da835ce2d56411edf3c96d59ab2c9bfc6845d694d1442baef4354b57ce4106d619c5debfc49586ddbcfa5028002768028a78377d3fd3a94a7b2302b71211f352e553ed79a16e9ed7c5e0bb69c66b51f39a78a96b55b9c89f530cfd7405e58726c7f6ab1baa917e77f87e439ca2c9a84aa7844ba34319ae4a3972b88696559e4023c28ee91be110382cf242d978ff57dfa0da199845c51434e82e4e3592b67e4fa5cc526884d7ac80c00234548cda4556bfa791807588064cadd63785790d0783223fee476b8a127a80841eb54ff8cfcc2ea54a5b850d16595baad265c52ca7689f2b27ab52915542de49f1236e4a139</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2021</title>
      <link href="/2022/01/01/%E6%88%91%E7%9A%842021/"/>
      <url>/2022/01/01/%E6%88%91%E7%9A%842021/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="16198fd9d52f5b076b57ed29e3cecbf4073335f61d27caa7ca4a959fca9111cf">c172f4ee74b2b6d246b20cbfdc0b877e4796208fb8efd1cbae1d198a549ca20b7df7bad19209fbc2fa7b16ffb3c37723442b9b48691d2c71f35e3c27e02aa6dd1992d58e8a79f167d9bdfc05e73c3d7134b029e0148f4e7a03a4075f7f17d0deb002b41cedaebef1d130ca6c11f99137f3bdf285d95682d5c030b9607af063ae66098e15125c88ad64d3ce5220fe79f093c08f3478b7deb94d1d3ca76e4dcc5c12e99ebb177555ae7bd3a61cb80498246e799bb494474fbc88a78b1fbdd3afff00f38e624af7fce460d3ce060b2675191821d79cc7bc9987a8bd02d231ad454346b7cb7effd6b5bbbbbd70c3b31d71da554152e7e77f0b4921c0b2ea44ebb6f2373d12fc101425d696a7937930a0d9061574ca0a68e55db819550d75f11ae7ac1096362707c5916412162cc493b3abdc2352107a10430118f987c19ac321b897dfcb02bf7db45994698339321fc84a08b126464a51c826624aef3657b358d732d712767890be52ed858451ae84ef451c58e84541b1f902217a6bbc447a2fff2b3d57ad614accb0edf49d29e2b2da2be59f5348f484a6e192dd50f5f577036f678a6172630231a399b83f68590b3806f8a1a422c5add2e0364cc00b36258053bd8b1a2416a05e1d62123474f81fd6a67869d248e1d3d72df041867021bfb41a072d00077dc9742ea00375e1da6483dc7ae1581d292d9488ed8ae44816525418588e0d1dd0fdc68fb0fb24774a39765b8817507408c4e0e135532bda8a2e88b7ffaf2b6593a3dc7518a4319ea8080801ce7c94a795556cc064a7d89ddea8c7be29bf24fe56e278b05a0e3874ba4eea71d4737eab9d441a78d0693325b16baa59b18b8b1926314a94584a7653a55a2bd69eb28b67e79aa73a86bb99a552ad2d1ec0132d93bc041671788b81305b3866f7f34f88c7b19c6ae1712b2fe446e4db37f10b9e3deba2f9bc69f4f0f198c578cb3b281c9735bc9ee557717ccdb53ddd1a695b3b914b6edab11dac80d7ae89fd690d855f29a14c53637e21aa54b515b3655760fb46b7e891904cf2f8ac31c46fbbc6633d9d9b00fc412672d93607f84f2210206c439813d1b53fedf884d84ea52fe948d51a750c5d1f3f44912f5dd688731618e4d3d4750237ff088029a2b1edbb11ae679bf3645603b28c6bc6eed46866ea37e975aabe163036538842b35477a4650d62c7abd0bd4ebc7503b4a7849bafd6f99f3a2924979fa13267d72ab7147302fff6204c7e80cc1fdd1df773d03935fa6cfec39f38740be08a504e9b056351565d043ca235d69cce5f2b3a1ea1c6de8c816a692df5a5a1cb7726bda25c5bedbd1233d6dc005e9cc07627c1611379d07d9670c844b7dcd1c3cd964544aa83043fc549500768f9f472c3e5f88573fd0426d1c33d1ff3bf9d34ca5d6dc04c653a6023c121a94a0aae198573a74c3111a320d517de40696cfef5cb3ff3dfd05cc3aad4f63f6c78d6e115ea880bbab170a11ac65a863e892431a6bc05772ee67e20f1d65fee1c780b2b6ae7d0f41348d68fee241f74206c4ce63a6436eb864e0d2758114120963610bfbf546a98eb55ac6fbf8cc36a5ed67b3576f5b16debe743aed00c41c5a596cdfdae233616d5de54506f771ed1d3e76e8037ddfa3716234c5546b72c883076c170ac1c8fb17b689a208d9129bc050c7991ffe1b90c92219995e8b6818cb24d4513a972c54384c2b4901fc4cbcaa93def5e5c2cc9b097deea6152aad8a08cf0bd7dc3962ef282a74bb8b921eb506048c3a781e712a0e39d15ede864b320477c2c7d489852d6fb075354991b2027b72c8f539a1816f5c63392b83e33b7bc63c2156c8bd9684b19f833b3b693ec1b26ce93c1ba31d032cd7c5e86de9c437d27b03ef008d97ebbd0e4a4e4bf0139c856c33315aebde20cca39823de0d21105004caa1e0899f534941f3e08a4f1b92c30c5ed830465439bdf20b8e0845c2157b5ffbe80764307e167f159910a8bec82fc03d8eb76954a93ae47909d968c21feee5c36c494ce9e6223f8eb9683d0b8f59695b88448b9b9a5804ab6e8821fad21208dc876b24dd4c57a7ef34f8e8b00d41ae81776c8c62dc0771f023d619bfb428ce5e96929054b8c9c47c04c95ea83d6b1e2d9c9fd53843624bd3d13a0cc3871f81c1bd71e27647aa8295da6787c1e929a22eb12f082009b1c1fe67240d38d3301eb2e57a2f0f956895f5f2d8cdb2f48dd6fd601856fc0520f48f8fad39ae9bb7e0522fabd43db0db4bab830bc6c04275031967235a55a60c52768d5dc36f3ea3089dd8916e8d90bf34648709ff04f6ea05ea7d0a4e221d18ed213c3a7d167d1ea552e89c6963b9e96ae5ef2d663ef692fa4480fcfec5410e1452282fb323a776dea4150c1d3c07a405d520f7e69b768add2cc76ed87d4f12fb31cd3a16e0599cdf8a70be0034871ab226b9b9cf5d8e675bcac5f5d4baa0b71d36ba2d5c1c0da38ef59ab1ce4413b2eb82e5d98cb41ea08a762ecc4e9398124d3cc1170ad2c6a60fb71930c409d47d2c0620eb277419aa44d4c6c1b8a0de7463b53a2194300988a1d1a64b1b1dc3638d9f4f40a47dbaa8e2f04a006f9e378f1007f1e51dfa2ce6866354533043e63638517871bb1f3343fdd2131896b81c14f1e16a83e01bf0c70df12b509a5fcf982ccd950dc63f55033c2566e603f8092cd510079977105b0cbc6c41b83ebdafeb0ad9a4ba6935b66bae0624773230eb8b98243cab765e4558e0aef350bff99824014dde7c5c649c24c7a91863e65d473731412675276a1a2b8240e28312ed998d019c63101ad3d739ed2955ae90c12c7fd79d482c2e2685f2090aeaeae69ed2c2fcfb0c9ca36855f1c23c55a05858e5fef23a327b7da49c59753cc4a026eb0030e9a66871fceb86df8350b6e6472c564d4aa77df20f9c6cf8eeae6f4725cc0da9ac1f1e953f8e260f925e9afa8588a1cabcb4ced87e628dc997b93795886d161e0f423e66641c2ecc0dce82504e6258769834e7a0391d7a984360b7134a94abcfd7ce6bd5639f99c9420c4b114fe252229831c4499ec0472bf6455757a5b9b050ec0d43f0f2336ec9928b5a241131c3c67b312f253787e04852d0318f38335b2626ef886495bdd0ee2f3709da06b6be5b608adc9b2f4e4065fe8b3f4075ce4d67753c2dbe63853283869036c2efbebbeef8e4699aa7525a98bde048296498894ab8eb4e79645d3a3a5fed3269112532a9a59b088002723f4ce3d7e33dffdb33386b1c626a9266c05feddefe04b15f5811daa649cf0e313489bb587b4e7b9b9103db3cca533c8b84b60c94af764abbd27ecc32e3714981eb40de01328096181e5013b627a82dbad09701834797baf57e79ca628cc148eed2de8edc95887832c0c41b12cb151b7828370eaf4a734ba26a411a75289e76354f28424856991a0adf8779ffbffbc53a2094244bc47c8e3ca090644eea2327cea61a09e8c26d6825fc1f3d6b0484f5b9eebbb11de9a7c8bd9aa63c25b3136b9fe7cb2575d58059eade7cbf15d7d66ac9d9ccd34dc64f70759f963d8d3ccbe1cc1bdb643c9287626941751ea4fbfd4e98571d36ce67231a7b18b17967eeae961256d0e962950f32fed57c469623ab6a03b8a458f0c291da2c3e66caf081293e9f1be3991668a745ecced12f0027711</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Social Connections are Good, Loneliness Kills</title>
      <link href="/2021/12/28/relationship/"/>
      <url>/2021/12/28/relationship/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="cc2996a3fa7b3565bce9da2383d7f767b0b1e2bba27a91335bafe666476130cf">c172f4ee74b2b6d246b20cbfdc0b877e98714098114e5e214ad2e1bc0791ac811da87126e79ec0c1b3dd59428e481fb518de8f57431b8dc5ef3f337ba7413ea8cb5984cba39a5d5b53138ef693dd006d6295c2c47ce012b33eecf9aca8235425aee3800116385c911ed8e7451f8db81e7ce3a9777702e2589137963d039e884d7cad2007187f4c6481a613e04928c60185a5e60d775a74ba7b08606c49c6db0a29342b562ac91365b41a52948e0706f74a2dbdb480021c758419e06e108aa26f90b056de51e9d3988b9a2c6b8e28f2d8d4917f43ddd7279c880839a94eb7f7d73d02927bf3570d1c5f6d7a4428db30eb50b7fa0133fe31ea0a1c2a727a13fbc1732edc22831fb928e18a70c4d5d5890e406f33f9be0add19e66d0ef034d01a643e94984ba023411bfbcefcc08715b2f02accbb27cf6c75c40fd49edf31c48ab3add97a0e27ba9b4df0fcb6c03905f0a696feb49d6a3548de1aec8b8f97fa4769a2dc4a1f7ab5552fedcae100a97832fc090dbdd595ea21c52a5a408f76aa990c9333c2f640f67436c3528295d7e698910faa865a987c015b28c501ad62f4389948bbe8ed5263f071eec55f874ecfc4566c980d7772104e4737d3c2269e000c6da67395ff34b18a1800e9e60f8a63384bb018038427ad6e11b9cd50136b544f028ad8b9c22c7d651dd6e0701fa6aaf05dcf0aceaab71a59dc21931067042c900f8c87a87a039a01580ab9e5e6bc6d793606f311f336a455932289442a5553661eef53fdcd22374f18d0aa650e169240550a5519c320ab96543384a4768f07d705c077daac6f3a7ae4d24aaa23babdb6e14d9fe61ab2d3e4c881c55a11126f37c4b029df713d19ff8d888e3dea08fd01587ca74fd2ea54b705a4b282628fd74b589b833880377e9618296d1ed9e8c152ac0302a36d06b665ec5dcd36f030d0864d10328e0550663c5d1e785b2d96bff13ab9c296f638e10adcf5bddddc277a6fad88f88f0a5cc22344c4f1f5c3389ebc0ec2005961ab903c5a38f677ef69923dde825109ce5204389da7ef3ed1e9d934332179f90068b86aec2ee9cbfe8de2d229895598d5d2aa93d96e3c43813fa7f34dcbe55245f8ce792ed0746e6126e3b59e791c5fca080ca12fd5bf066d6f20ff43b1cdc93de45c95ef48d908a5b1e5b1d2163749eacaf741e2a4dc7ce378bd03032583059ff0a2afb5b3f3761e41091831cc4e9c5ef9afdac4fcb328b8032675229903261157a851421b5f8a5ff17d9038850f1a689871d4798eeb5766d84d962f232800d1e46ec2c9368efc831830c31eaa62ceb238feee513b1dec193d36c2293db1f62616623145d74a704f0868f8675f84f467b32951401811f5588782b3d22fef0427a6562785c8a17e2c00f962b6e671012bbe0c4bfd70ae835110caf50b7cd571e56fb93c598bdc7be6f50f54c82e1226a0d281733993d5c97ed33026887302d9ba4a9fa489d8eac905778e2f19785c1f9efba8200e959d53e988035192b966e4431a9f99d442d5f2a86d2de361672c936707bcbf1e979df923998e593d7c71fbe2f6c8520ab0fa4b111768e8b8086226be3832f8248091e556452dffbe3a7787374ad0f953989f78bea328ca36be4d27495477ed21097a987610a44c75c4daf7e1d92bac40407f9abffed35b0c2ceb0a7c2c43671d20533831dc2f9e12d611289afd9891b152e586f7145a2c50db945779c9f14af054e79c4ea96db4e44d42d31bf4d4f93b6a5f327d8a98c63332a635edc5e58a5db8510cd668744052f485de09d29e2ae0b43d77a45486a35351dc07c6f5108d8221140310348f5ed0f31cf8d36658fb662b409e3afe578c28c13052572757a4de0b4b790faf2fc5274e78cb2686211bdf09b5c2fc03b4b4dc032e4f9375d9771d1e90280631f22fc57264c2377d8ef4139c473dc0e5ee2431f49c1ffcc35e65972cd2bfb5ba03f8335b3d80bc79f408f57e9049a0087bfee0428d6bd46fc726bdcdf1b546817fa75bca97aeba634373a72213bdff529f0ccc4bb211f007704c9f792fe9b1e30478db7b3ad6b8ffd4941ca9933d51c864dc8ede326bb02c4f3616674ff93df57daf396bd3479b7d22d2f6f338c621865f6595a0eb810e2a612ad5a4c0073630d8e2eee45949f783af03b930278db5c447e92689af3bcf58350920269713f988aa0f07d71b7c558c4796f9fc30bb058e0605d0019e301dea45e22d0ba9e18c56ffb5ef17ff2e30bd2091eed91c53459b75b209193bfe065f40829b7e01e645a06df13e19ee68efa527a0a48b420e9ed3bc52ff9548fa88bab13e7ae2693dc167db9bafb0da307f979bf6428165b2746d312efa3309b5cc562e2ab3e77a200b1ceae5a7bf79f68616c27ecc09380670d60ebad7b549d21c7ce47c3067a8e0aba7c94e8f5d637344165e072a4760580ea17a5770fd9c1c0facf8b25e19f3cd023ba45eccfe59916cb4d733bf8841b6e48473fc67fa52bfabc1a7bd5acacabb4366973649d22fea453d887773d31538f0192dc6f8b9165cc7ac3c90412dc05a541186e65e44db189b0a94fef43b6b2252f5976c76ae24f7feb1fad97519b84fda5f1028e91b2b86f5edd8c67bee659e607edca4099341229a1d67df5e3ee57eb299d3d0ddbd137c641d3cc08d72b3b0199f329806cb7f0a74508c9bf013cc34ded0c098618c0ce482d140e9522229227f61c3bfc148630a1a4bfda597fcd77efbed236a67899c12eb49505fbbc7a633c92ebc1e0058ba129207d2c638393dc363a7e951bc77a1104d5f33d0d2413e7b1f8bc911339762bdbd83fb8eca100aeb5fd0f85cf22bb5419fc5c5ee54ceb6e3af06c83ed322e6117bca852e84aac5d3384c7e26fa38c54f72f85fbe1da7e7a71270740944e75b51bc1fb068d98326dde6b8a8202a95e030eadf5e62e06fb28a6e0b74943d30faed3341f6cd42c7ff69e6247b3761b97bf7c9d246aeb405d933828e343a7ce73dde665a8392833b86fc17bc6f66475ddfec82fe106b8921bf9b8a99f7e67dd6fdd5c8714c792f23bfff125da069cfdee0326c3ab5cc6d5e315a412b16eeaa4cf1c46c6ebbdd3b088e789d8e8e9d621e789fe7cc68fd6aca68d9ae8ea3d1a9118ce54aba4a635e7fca7e2190a27463daa19ea2a51f6478f580d0176518b3f8ffd4ad4a85efd1fb0cf0e3ff9a6a4d2cfe0ac71f69d29ba2494b7eb4c9c7593ab605f3d568b6140aaaf2a05b89840aea34358dea1341565fda4803527bbefce020921b02d66c3f5a56b814d809ac37cfcf79a535dce89ec4912e53ef9500d737</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Where to go and What to do</title>
      <link href="/2021/11/23/Where%20to%20go%20and%20What%20to%20do/"/>
      <url>/2021/11/23/Where%20to%20go%20and%20What%20to%20do/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="72e92f742789d154f67a541fd08ebc5443eebb5ad9b65b7c22f4158a3239cf29">c172f4ee74b2b6d246b20cbfdc0b877e8bbcf32b0350f372e58bf556c0a0e018a278f0d8b1957ddfd9765be148897416a00132d101c5251115bde0c1fec649f8ea46100ee8ef47be6dc34b7db67930107ac58c386a26f4bff999cd1800f08bb77ab00ab7275f0087faf7bb9ed6519b42d2eee9864c81b703c11b0cbe9052c1ea7c02189879a9b1af251f06f39b2798df97fac82f336f8c874dc0096a937a7e908babe003639df24b23cbc69f2a0fd9e4a39622e7c63051623ad208c95606516ab2b119a77d3ea2ac8f37a01aaab28a380b8562a42e69557e4ba3dc6b62a81b8fdf35176130c70d66330ebd55e6d731ae90b9d7aa3ebc8ecf5e2c854c2a1843f6278936993164471efcbead5060372611d9f087463634d4f9115aa262a23ade45325b0b9582c30db14d3b6fb18e1b2be4e59ea8d008415d4a5771b79dfc97835f0fa25e9798f1a4fa3932378cfe89d0f873356cf01525ee3029c47eeef884abcce122a3107aea8464094b9987e8fdb7d1cde870b9fcaed331fa00f5781d7ee31d9e5c90ed982855638ae9a6557ed9c29aee544efd9596a51d78d18ec07f9ab37affb55ae64987e92ac122c0e748c478dcf6cc2f1ad8b02abc862d5a2f429893f3d78458e5a06f52d2ca7826e992959869ef76fa1ecc60444ff74f56ff95b09ce8986bd9f355edadf3f07c42d3b920e7baae54b8b9028b0ae6f9f71bd0209b5455535678c5a6077017953d3804a6192aca32ab737b9a01ba3a510ead8ee34b4f045a8aa89b14fa0aca6ef821f58b7efd9ef4515f3513be47acf15893f65a464aaa05230bb73af50b7e19f771de343bcfcc61fa62d0def5f7c973cd91ad00c18b197e486e044e634b538b7908c82649b978c3a38155c39a27afa938d6a5609486dffcc1fd947b0399e334faba092a47050470943f5f3befa3b9569a093584e1034abf2847b2cbc0ff1ad0e5b98b83dcbcd1e0cebc58097d7a87b60d180ae6b45820c734e13911fff86b36934813710a3d13b25480bdeac9f99ea7f627398a407359dda0b10c16d9ba5302fdb1654d42dd3090fb70b4d7bd74ce5a418807b9c881cb941ae674ea3178186e7fe58d8731f88f4506b9e058219a12b24d80b277ff977d3f035abcbe4a527f7842af5965ed499448478ff38290d14d3a5c624e6c76a603bd7ea444325fa11ffb76cedebb806f92715c0b7fccc8b52e011aee5cbac2c7745a37a4b3ca1cc0208de895cad0880c66f4fab8374e57600aa1b3e1e3c18bb1403aea5d0c6f7d3a1f38d33afb5f8b670cae1a847f40748fe95bd1eff571604586026ef86fca091e617c477ea9f5f54490922f7bb42bf50e4289be047995ee1a1dd236564ef4c4dc82e308650d70a2af91ca9e71a820ca21b609be51cf36bb42ff44f77d3611d1f0d35fe0add29f3e00be3ff1db92c9659ab25b93f26f753aec6862725aa087ecd9394869028d6864d96cd28b02b37388b570575085da9cf16832a3c324e80de564c6332c16d46a97b014e64817c9a5548f786562277497efb78acf5144e91bd0bf79681fec77247dbf38b473be862d2104c8cf99c304f0c07928f10e1919146ddba4b293d9f066174d2288d7070c7b6fbd8aafe7ef7abdc8cb9e82d63d2d6061e558fd4cd7ed3966f37bee915e09b42387e5d59dbc0cbdc5ccc7265cc45d128f7847ab2cad1ef56077f87126733b1df1ca372d017cbbad3203dd53b38d716f166d31279ce487a4a1ded16f041c1f9abd57eac6e538656484535b5c935d169e5f4facfce6deb2d3132605bac0da5a78d95572011ce5a208f726167f988bdf6cb43ce1b20279980bdd5c93e5a05f6804c118acb5f8e7d0a0b83f0472aceb8912ec050bc4adac366a313ebcab91fb2419ef74c70caa38faa8abc67d5e8a1eebcd7fc8e50b2584837b70efdf555d7282333afbcf087a115c619bdcbbaa996f375044a3607b1e7ee44b93eb711ef78cf92a929ed10100c13df8b072df8a403007b0c3c84c2a15bb7c6d4940e57a68de3806cd0f89a4132c2c1bdcf62eb16c7dbf0628d1d33731e39f7ed9f5171ac5d3b2ed6a7823d7b53f715eae26e23d1a45403b7b5d569ed9b3f2dbde9c9e2f932b0446c6c24c3e36190925e3cd9df7a005844dc3964c9c3707a5892618ddc29fb22c14dc9a8e62813f6eb21f72d33d2948c3b0f83c306443eeb35a84c846980d7fcd9378bb8a67914f8d068a93299d52173a207edd90f96df14620539b3c932488c4cd92355f777ee69258f27a1cd40aa7d7a8d9043161e403a3b419954737b6f21cd5c48f3c836478f1f03ee8019992811475db2f48986a393d965361a6335048efee4e0db46f8004425fe2da31f181e1485a9fadbfa91dd3f76be65ebb97788d513ce4ca2f8bd5858ae383afc2b703c1b2de504ce5a69a6f1c44f91f6e89aec666feed0d5916d60e292a4af73c3959222e5b86eff81867a22de595dd6f22960c54991fad556f26b225bc2281b271d2b95b806f16e91c8ab30776cbf923d00144b9d0d224831f139c2ffb3a4c1fa4a37971b259fef539d09b5eb154656c8c494c4773fe5f820c4b8fdd53d1cea04de5a22e04e202343bbb0242b8a36ee95c1a84bbcad5384f0daa890bf3054e42f7e80ccf3df556dd7deac90157feb5035e52186b70a27deabf6bdde2eb4f73aad73790e39845b70ad44534b82ed2990bcb5c070263a48ec999aff0b7ef9b831495c7dd4699e80ac0a3aad2c697073e7c1dd8cd8eaec2b0fde303868948e4b5b3f4f693753b32303b3c969eea4c5995fb89d838f78eff0fe0299b4ef7350c101c6faa3d5fa7e21963ce5fa7f4dc71b7033e6404701b7297d7f7098d5e530293a071cf08bda270397f0247824598cee15ab13301ef8a50f7ebed06db1dab52deb2e47e9b5ff8f713b12b0db5dd5d2b5288fda0587cac54edd084c8c99f9290685a3bcfc4d9784ce51359935ee9217962610158004996cf1a40e9fd0a6eb73bbb73e91d78dd0e13f4d09ad49f8d23259407dcc034cfb2cb9e6ed2e31b03743d0c8e99d6a2824b7a7135bf375e210cb36fce233a85dfdf758ee4e82c3746f24e316e9617dbed444e5f491f1302620f6a67146a2104c7ba422876c0dbe2079cd410a7962024c74ea79da1bf6591f6b80dbafea5a8df476388c8fb058353284709c012c23666e8e900472c3924095cc8a7fceaefc34b7a57849ea2037b2f476a4f069251771543049b03b11c84e83f40162284e06d09ae35e67ff5295ae8c60527fb2a6940b09f03003784008bbc50252d5d5c16082bafe293ba41c7a54560d4cfb37a6a9a55c47e872f17ced91d87426c0b77bb0de033cf37f6c85e2109d5e46c6a7f077db9bb94ebb73d15931565a3b149d31333561e2359d34ad4cb95d87f44b97d8bb896ec71cd8eaa830ee30a974ec95568cb7e8bd5296df39b8ed9856112f7e5c0a55ebe25236f24383bf9ba68227f8eb68d330683512830dee19e944937c88ed85989395f8a688bcb85ca96170b2c48a8150b6989906387fa2aa016dd27e0038476f83771db3d28b09a61663f8cdf972a13a23e79a91e5a83cfe8e6994114725d12e200de2264bbababa3a2b7d3e5df70b2ad1e0c540407171d70271cf69da9208e5389ab09ff0871ca15a7de8e5fceede521081ce257a115271cba9aaea4560abf1cbf8a2fc38747871349a2d2d6a85d8427dc2c6deccc50f0298de6ebc4921b5cb2c0e230f3a607b05fc86bbb0052b099068f1321d58a7dc9fd504a87aff4ab10ec1299c9f1d729579781cb4db56b2a8a4c761ced2ad5ab168969925282d5727bfa8a7b840e8330e44baf7fb6cb2cd07694abecdd8963e6af7cb1d03b7681d4906971e0392c75c8aeb0c87c5744f996e0a574bee278ed582454ac03c72083dac4cbb0e7e8e27a85d87b3cf4263117a40881b6bd0de4931b02619cc3bb2e063ba5b6f5f7e156c916cf64976d9afbd82d55252740b3939079f9fa1cabe3cd83c6cd3ad1a4a548b1522025863df9229b2c3b0d28cf641c15d8387eef747d1fa87fc00bfdf2e3684e6a9d8499feaa81894e6339fd8c7586bdc230abc77447ec4fe2cdea8f1772afb9d7cb51fc49b4ce1ec2a2f8bbb06cf041fd358e921b5c848d19d6cf82bcc6e03a173f7a760cd289a8e9be6954706db8fb0616df35b6b53fc3ee9c4d3abf5eb71458fdef606553bf6c7e45125663b58d8e41bd3f2d3e6fcf700c5ced720183395b64b42cda1855fd66e888df98862f983acbecf6defcdfea06704f0daf11e3297c293820cb11bc93ada3d2e9d83a3efb7eed0c50a6b65968da60db01ee672f63caca2573b84bb5edae2358b9f0fbc0204c2362c016e0400c11116f6d1f70c58722d07a2f6edb6ae8102653cf73ccda06261bf8fa11102f0e01dc8a2733a20bc16ddc4e629c7ffff345d42ddff8e412ec2d27159d8d75dafbaeee8b673caa4f0bc67699f49b783a5e7714a3dfa61ba91d002fc5f357e814f7f6b9d60d1b8c9c6b2290f4d1ec8c292fcdeb6018d26cdf9d1784c406348bed22aa3b6190af93775b354e2fb961aed51c9b104a9e8530cb474ae86a5426e67f2cc8bff3e558dc6890f993f2d2c5b37292e37ac49f3e2ea333287a7e381a83bd4687ae3995b080244cc66ef07b6ff827f486c1b3c88e685741c6377ab3f115ef8a1bdfb413eaae33d81d8878da6e2c2ab3560e0c761791dca365c270bd0562f77597079128c07c1da3cc4e9f1e7a191d67c045754ff0f75bf9f66510f1fd67615e0ee38819c9504ef73de293726ba972205a2158878d9cde31ce5f39878d9a37169e931767cf68ec18f7eb45e089bf4ec9a1bf0b2b13be0b804d5ca705a3c65d2b8f7bafe9bbeec5753d40ea462205d0012efbc67a9e6c894d11edc0d45e3f2b6fe2a56c7725bbdf4a3947c49ff0df9b17c7f2126827fc82f50c29b16953eb35ec75d795b0df335590198eece0a9aabd60abcd8146b43d0f966fee57a74a114674b6eab95bc971e8842ed3403d997a460a6db659f87e23ba96c17dfe6cfd387fdc568f454fc47eaffec6ddf475d7853a76ae7f549b83169c036b857b6e98efa395d68ddc0511de531e48849a9880c20e43e3c32fd22dc610b0c20e8102b6b82caab72b9590c213b189c57fa002d49fb49dcfd459cfa37f15bd16121926480a748678402ac4b7d4483023fcf94521da0f64da1bfb49c9b70b807fd381cd9c23e306af5d679bc75908829c134bad41360416b708ff42feb86d0c513db4a5f504f9cc007e35ff020e8be99053a2113bba983eb6e7bbf2cd67d588c30256f2083d0fb149e832c5b7bd17cc652b35b775c6224862227da2203bb3e3dcfe592d7e7cb124d0d2340ef03548e2eaa5cd7929293f06f6725963ad057c4a8ad26e9c47474b55fd351d976583504ee3e1caf0c2d42ff7df7001761bebca7a55adffcd28cf952b958f84d2c2b32884c4b0818d7ea69bdb088162005728a39ad6382a64b96c1ae3f089e6cbc6b3045e6414b98ab07749633962094dc438ef1ae57c1e7c1a5f46dfdf2cd4cac469a89effae1a393f9f908d529eac80d92a1b23b34fa748825947796ddb795ff39d7ecc74525810539ff3d54e1ad36330baf583772ebd605c081eb0a2bbc51aa0a9440e5807b3a173d1bf1f8e94c86c35585ce6a4b37504665baf6b4c5accac5622d94dff077c400fff76d5e1297f950f1bab444d320cbaf6f548cd5faeb91e98a69f15d461042be807175d3da8d9b731a1e606804cffd7e47290a3f5daa47dd8ff09cba94c43903a386612af2f2cfc1fcc2c0b283c82d12e9f74f378d10f2718c3d1ee1ecd5f009479f14987175811d03e4c4098c89fdcdeda307c61b5fa99444a65ee3b3b38c9a832a9cba8356fb17b746f7a7d8e79b25ef2a4af93cebc3c8c63372a09b430756a2e99719e47acd357c57ac881b0bbf146c0cb8841da8eaa261a2fc76d1aadb3ebfe6790933347d5a893c863bc35bcd4c8afd2724ec2d523af5395567695f631d623fdbfef22e18995aff6548923106874c71e215a8edc56fe1ccfca93bd6d7b8a215b2b851fb32f9d55f3b545f5c23f47323f1f1d349a0ea6a2b2f8d6d5bb303b52755cacddcd3643898782657efb111de35011bee0039b74af6b466aad2d163d89d6dfc7ba87d6d9c86b5b33673e6bdf4c2e0ee43126c1ebdf1ae7efdc97b0bc7188ecad036aa9ab446fdec69eda1fc525485210dc4c01744957357764b918612c3e1c847e3577583bc868cf61c686eb4fcbab5f494845bbcd8e354c1bc8a7cf2141b2a4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wilcoxon signed-rank test</title>
      <link href="/2021/11/23/Wilcoxon%20signed-rank%20test/"/>
      <url>/2021/11/23/Wilcoxon%20signed-rank%20test/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>Wilcoxon符号秩检验是一种非参数检验方法（总体没有高斯分布），t检验貌似要数据服从高斯分布。</p><p>具体是这么操作的： 假如有两组数据<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>需要检验对比：<span class="math inline">\((X_i,Y_i)\)</span>首先被转为差值<span class="math inline">\(X_i-Y_i\)</span>，记为<span class="math inline">\(Z_i\)</span>，假设<span class="math inline">\(Z_i\neq 0\)</span>且绝对值均不等： 1. 计算<span class="math inline">\(|Z_i|\)</span> 2. 将<span class="math inline">\(|Z_i|\)</span>排序得排序后的索引<span class="math inline">\(R_i\)</span> 3. 检验统计量<span class="math inline">\(T=\sum sgn(Z_i)R_i\)</span> 4. 通过对比<span class="math inline">\(T\)</span>和原假设下的分布求出p值</p><p>如果存在<span class="math inline">\(Z_i=0\)</span>，有几种处理方法： 1. <code>zero_method="wilcox"</code>：忽略所有等于0的数据 2. <code>zero_method="pratt"</code>：排序时考虑为0的项，排完后扔掉这些0项的秩 3. <code>zero_method="zsplit"</code>：</p><h2 id="refs">Refs</h2><p><a href="https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test">Wilcoxon signed-rank test</a><br /><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wilcoxon.html">scipy.stats.wilcoxon</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS144 Lab</title>
      <link href="/2021/11/12/CS144%20Lab/"/>
      <url>/2021/11/12/CS144%20Lab/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cs144.github.io/">Introduction to Computer Networking</a>是Stanford的网络课，据说lab质量很高，就把它作为转System后的第一个小系统吧！</p><h2 id="准备工作">准备工作</h2><p>Stanford大气！能让我们这些野鸡学校的同学接触到最顶级的教育资源，甚至开放了lab，也希望大伙不要把题解po到github上！</p><p>因此我做的是Fall 2021的版本，所有的starter code都在<a href="https://github.com/CS144/sponge">这里</a>。</p><p>至于如何在自己的github上备份代码，参考<a href="https://stackoverflow.com/questions/10065526/github-how-to-make-a-fork-of-public-repository-private">这里</a>。</p><p>虚拟机平台用的是VirtualBox，144官方提供了基于Ubuntu的系统镜像，CPU和RAM随便设。</p><p>大致按照<a href="https://stanford.edu/class/cs144/vm_howto/">官方文档</a>配置环境，windows环境可以用powershell，无需<a href="https://putty.org/">Putty</a>。<br />开启虚拟机，通过ssh client建立TCP连接到远程主机的某端口：<code>ssh user@remote -p port</code>，<code>user</code>是在远程主机的用户名，<code>remote</code>是远程机器的地址（IP/域名），<code>port</code>是ssh server监听的端口，默认22（即登录请求会送进远程主机的22端口），上面通过-p参数改变了该端口。</p><p>不过遇到了点问题：<br /><img src="lab0-1.png" alt="putty error" /><br />奇怪！远程虚拟机明明安装了ssh服务!</p><p>从主机去ping虚拟机超时，但是虚拟机可以ping通主机，参考<a href="https://www.cnblogs.com/mengjie88/p/11803879.html">这个设置</a>成功ping通，后来发现国内的这些blog都是在胡说八道，真正的原因和解决方案在<a href="https://unix.stackexchange.com/questions/145997/trying-to-ssh-to-local-vm-ubuntu-with-putty">这里</a>，本质上是虚拟机的端口转发没设置好，设置好后VB会把连接localhost:2222的TCP请求转发到虚拟机的22号端口。</p><p>关于IDE，开始用的VIM，后来想用vscode，Host上安装vscode以及remote-ssh插件，关于配置网上一大堆教程，自行学习吧，powershell以后就负责编译运行了。</p><h2 id="lab-0">Lab 0</h2><h3 id="networking-by-hand">Networking by hand</h3><p>这些小游戏都是为了翻译翻译：什么是可靠的双向字节流，网络通过这种抽象完成许多重要的交互，如上网冲浪、发邮件等。</p><p>第一个事是要手动模拟浏览器的请求过程（注意手速，不然还没输完就408 Timeout了）：</p><ol type="1"><li><code>telnet cs144.keithw.org http</code>：<code>telnet</code>作为一种client程序，负责和服务器的某个服务建立连接。用telnet客户端程序在本机和服务器之间开一个可靠的字节流，并请求服务器的http服务（80端口），连接成功证明端口可用</li><li>建立连接后就要通过HTTP协议请求内容：需要告诉服务器所请求URL的path和host：<code>GET /hello HTTP/1.1</code> <code>Host: cs144.keithw.org</code>，不过为啥需要host呢？难道服务器不知道自己的ip吗，好像是因为服务器可以同时运行多个网站/服务</li><li><code>Connection: close</code>：表示希望服务器一旦完成响应，就关闭连接</li><li>输入回车（空行）：表示HTTP请求头结束，接下来是请求数据（当然GET没有，POST有）</li></ol><p>其实这就是一个HTTP请求报文，效果：<br /><img src="lab0-2.png" alt="在这里插入图片描述" /><br />作业就是瞎玩：<br /><img src="lab0-3.png" alt="在这里插入图片描述" /></p><p>第二个事是学着发邮件，请求服务器的SMTP服务（主要用来发邮件），我试试和自己的邮箱互动下：<br /><img src="lab0-4.png" alt="在这里插入图片描述" /><br />这里要注意：首先要开启IMAP/SMTP服务，还需要获取第三方客户端登录的授权码，登录时邮箱名称和授权码都需要Base64格式。</p><p>文档里说From地址是可以伪造的，有点神奇，垃圾邮件可能挺喜欢干这事！但是我实际操作时是伪造不了的：<br /><img src="lab0-5.png" alt="在这里插入图片描述" /><br />因为已经登录了本人账户，所以发件人必须一致，Stanford那个没有登录，也许是商业邮件系统一般都比较完善？</p><p>第三个事是作为服务器去监听，主要使用所谓的瑞士军刀netcat：<br /><code>netcat -v -l -p 9090</code>：-v表示显示执行命令过程，-l表示开启监听，-p表示在指定端口监听<br /><code>telnet localhost 9090</code>：<br />然后服务器（netcat）和客户端（telnet）就可以通信啦！</p><h3 id="network-program-using-an-os-stream-socket">Network program using an OS stream socket</h3><p>这部分让同志们利用操作系统内核提供的stream socket从Internet上抓网页，和上文中手动抓差不多，不过这次是把手动过程写成代码。</p><p>由于Internet只能提供尽最大努力交付的数据报服务，因此这些数据报可能会：丢失、乱序、内容更改、重复，所以通常OS会把Internet的这种抽象转为可靠的双向字节流，以便应用层软件使用。OS一般使用socket来完成这种转变并向程序员提供接口，socket和文件描述符类似，一旦建立连接就能进行可靠的通信。后续会自己实现一个TCP去揣摩这种转变。</p><p>这个简单的web client程序有几个要注意的地方：</p><ol type="1"><li>由于<code>connection: close</code>，因此服务器只会处理一次http请求</li><li>服务器响应后就会关闭从server到client的socket连接，但是client的<code>socket.read()</code>可以持续读：If the connection is broken on a stream socket, but data is available, then the read() function reads the data and gives no error. If the connection is broken on a stream socket, but no data is available, then the read() function returns 0 bytes as EOF.</li><li>EOF一般是一个定义为-1的宏，因此没有对应的ASCII字符，因此也无法显示出来（可以强制转int），C语言将其定义在某个头文件的宏里（可以直接用EOF判断），C++一般使用函数判断。EOF的作用就是client可以判断是否读完了server发来的响应，终端输入windows环境是ctrl+Z，linux是ctrl+D</li><li>为什么一个<code>read()</code>不够呢？因为<code>read()</code>是有limit的，超过上限就得多次读，<code>std:string FileDescriptor::read(const size_t limit=std::numeric_limits&lt;size_t&gt;::max())</code></li><li>及时关掉socket的写功能是一个<a href="https://stackoverflow.com/questions/4160347/close-vs-shutdown-socket">好习惯</a></li></ol><figure><img src="lab0-6.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><h3 id="an-in-memory-reliable-byte-stream">An in-memory reliable byte stream</h3><p>在单机上实现一个可靠的字节流（内存里当然是可靠的），即接收方收到的字节流和发送方发出的字节流是完全一致的，writer可以结束字节流输入，reader读到EOF后就无法继续读。<br />基本可以理解为一个容量为<code>capacity</code>的buffer，<code>capacity</code>用来进行流量控制，文档说了只会进行单线程操作，因此不用担心并发的读/写。<br />需要注意：流本身可以无限长，<code>capacity</code>存储的是已经写入但还未读取的字节，哪怕<code>capacity = 1</code>，只要writer每次写入一个字节，reader读走，这个流就可以无限长。</p><p>开始想用<code>queue</code>，但是<code>queue</code>无法支持<code>peek_output</code>操作，那就用<code>deque</code>了。<br /><code>size_t write(const std::string &amp;data)</code>：如果长度大于<code>capacity</code>该如何处理？这种情况多余的写入只能被丢弃，就和网络上超出线路容量的写入被丢弃一样。<br /><code>size_t bytes_read() const</code>返回的是所有pop的字节数目，包括<code>read(const size_t len)</code>和<code>pop_output(const size_t len)</code>。<br /><code>bool input_ended() const</code>返回流输入是否结束；<code>bool eof() const</code>是reader判断是否读取到了流输出的结束位置，因此必须满足writer已经有过写入且buffer为空。</p><p>记得先<code>make format</code>，再<code>make</code>编译，最后<code>make check_lab0</code>自动化测试。</p><h2 id="lab-1">Lab 1</h2><p>接下来的4个lab要自行实现一个TCP，模块如下：<br /><img src="lab1-1.png" alt="在这里插入图片描述" /><br />由于sender会将发送的字节流分割为若干segments，每段不超过1460B，封装为数据报交给网络传送，但这些segments可能会乱序、丢失、重复、交叉重叠、长度不一，但是不会出现inconsistent的段，因此Lab 1要实现一个流重组器，将收到的字节流中的segments拼接还原为其原本正确的顺序。</p><p><code>StreamReassembler</code>会用一个可靠字节流<code>ByteStream</code>作为输出：as soon as the reassembler knows the next byte of the stream, it will write it into the <code>ByteStream</code>. 接着应用层就可以从<code>ByteStream</code>读取有序的字节流。<code>StreamReassembler</code>和<code>ByteStream</code>的容量大小是一样的，不过<code>ByteStream</code>真正的size（绿色部分）是动态变化的。</p><p><code>push_substring(const string &amp;data, const uint64_t index, const bool eof)</code>一旦超出<code>StreamReassembler</code>的容量，就只能丢弃该碎片（或者丢弃部分）；<br /><img src="lab1-2.png" alt="在这里插入图片描述" /><br />根据上图：可以想象为我们拥有一条index从0开始的无限长的字节流，每个段都有自己在流中的位置，随着应用层读取流中的数据，<code>StreamReassembler</code>就像一个滑动的窗口，落在该窗口内的段都需要被按序组装。</p><p>显然，需要用某种数据结构把不能直接写入<code>ByteStream</code>中的segments存起来：<strong>data+index</strong>即可唯一确定，因此单个segment可以用类、结构体或<code>std::pair</code>存储，为了方便起见，在segment结构体中增加成员变量<code>len</code>来指示其有效长度。<br />由于可能需要根据index快速查找合并位置，因此最好按序存储，并且自动去重，所有不能写入的segments可以用<code>std::set</code>来存，底层基于红黑树实现。</p><p>处理逻辑：</p><ol type="1"><li>新来段是否超出/部分超出了<code>StreamReassembler</code>的窗宽，如超过则进行剪切；</li><li>新来段是否和<code>ByteStream</code>之前（蓝色+绿色部分）有重叠，如有则切除重叠部分；</li><li>合并新段和暂存段：确定新段插入位置，不断将其前后的暂存段往新段上合并，直到找不到可以继续合并的暂存段；</li><li>判断能否写入<code>ByteStream</code>；</li><li><strong>处理后</strong>新段的eof为true：<del>若暂存区为空，结束向<code>ByteStream</code>的写入</del>结束写入的时机可能会导致潜在bug，后面有血泪教训；若暂存区非空，<del>报错</del>，可能是last segment先到达但还不能写入，因此存入暂存区。</li></ol><p>根据上述逻辑准备用3个函数完成：</p><ol type="1"><li><code>void _cut_overlap(segment &amp;seg);</code>完成12</li><li><code>void _merge_segs(segment &amp;seg);</code>完成3</li><li><code>void _write_to_stream();</code>完成4</li><li>直接在<code>push_substring()</code>处理5</li></ol><p>这个实验一般就会开始出bug，我直接跪在了corner case，来了一个eof为<code>true</code>的<code>""</code>，空串是要被忽略的，但是这个空串带了我们需要的eof信息，由于在<code>_cut_overlap</code>直接返回： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (seg.index &gt;= _first_unacceptable || seg.index + seg.len &lt;= _first_unassembled)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure> 所以没有正确设置<code>_eof</code>：<br /><img src="lab1-3.png" alt="在这里插入图片描述" /><br />测试样例<code>t_strm_reassem_single</code>报错，所有的测试源码都在<code>./tests</code>文件夹下，对应的可执行程序在<code>./build/tests</code>。<br /><code>sudo apt-get install gdb</code>安装GDB，找到对应的测试源码文件<code>fsm_stream_reassembler_single.cc</code>打断点开始调试，跳出<code>launch.json</code>稍作修改就可以愉快地debug（面向测试编程😂）了： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;sponge debug&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/tests/$&#123;fileBasenameNoExtension&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: g++-8 build active file&quot;,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后来第7个样例一直过不了，而且Byte Stream实际读取的字节数和真实值差距很大：<br /><img src="lab1-4.png" alt="在这里插入图片描述" /></p><p>怀疑是提前<code>end_input()</code>了，主要是下面这种case：<br />first unassembled=7且first unacceptable很大，先来一个<code>index=9, eof=true</code>的""，再来一个<code>index=7, eof=false</code>的"ab"，如果这样判断： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_eof &amp;&amp; _unassembled_bytes == <span class="number">0</span>) &#123;</span><br><span class="line">    _output.<span class="built_in">end_input</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 很容易在第一个段就<code>end_input()</code>导致提前结束写入。<br />因此核心问题在于什么时候调用<code>end_input()</code>，我用了<code>_eof_index</code>来指示结束的位置而非用布尔变量<code>_eof</code>，一旦<code>_first_unassembled &gt;= _eof_index</code>就结束输入。</p><h2 id="lab-2">Lab 2</h2><p>Lab 2要实现<code>TCPReceiver</code>，将从Internet接收的segments送入<code>StreamReassembler</code>转为可靠的<code>ByteStream</code>，以供应用层从socket读取。<br />除此之外，<code>TCPReceiver</code>还要负责和sender反馈：1. first unassembled字节的index，也叫做确认号<strong>acknowledgment</strong>，这样sender才知道下次该发送啥；2. first unassembled和first unacceptable之间的窗宽window size，用来告诉sender允许发送的字节范围。两者结合形成滑动窗口用来进行<strong>flow control</strong>。</p><p>第一件必须要处理的事就是序列号sequence number的转换：在<code>StreamReassembler</code>中我们用的是64位的stream index，因此不太可能溢出，但是TCP header空间宝贵，所以第一个字节的index采用32位的seqno，这样就带来几个问题： 1. stream index可以近似于无限大，但是seqno只能从<span class="math inline">\(0\sim2^{32}-1\)</span>不断循环； 2. 为了安全起见，seqno并不是从0开始，而是取一个随机数Initial Sequence Number(ISN)来表示stream的开始SYN(beginning of stream)； 3. TCP header中的SYN和FIN(end of stream)标志位都要被分配seqno，但是SYN和FIN并不是真正的数据，只是表示流的开始和结束。</p><figure><img src="lab2-1.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><table><thead><tr class="header"><th>isn</th><th>isn+1</th><th>isn+2</th><th>...</th><th>2^32-2</th><th>2^32-1</th><th>0</th><th>1</th><th>...</th><th>isn-2</th><th>isn-1</th></tr></thead><tbody><tr class="odd"><td>0</td><td>1</td><td>2</td><td>...</td><td></td><td></td><td></td><td></td><td></td><td>2^32-2</td><td>2^32-1</td></tr><tr class="even"><td>2^32</td><td>2^32+1</td><td>2^32+2</td><td>...</td><td></td><td></td><td></td><td></td><td></td><td>2^33-2</td><td>2^33-1</td></tr><tr class="odd"><td>NaN</td><td>0</td><td>1</td><td>...</td><td>first unassemble</td><td>...</td><td></td><td>first unacceptable</td><td></td><td>2^32-3</td><td>2^32-2</td></tr><tr class="even"><td>2^32-1</td><td>2^32</td><td>2^32+1</td><td>...</td><td></td><td></td><td></td><td></td><td></td><td>2^33-3</td><td>2^33-2</td></tr></tbody></table><p>第一行是32位的seqno，可以想象成在圆环上走路（正反走均可），二三行是64位的absolute seqno，四五行是64位的stream index。</p><p>absolute seqno转seqno：<span class="math inline">\(isn+n\%2^{32}\)</span>，<span class="math inline">\(n\)</span>直接强制类型转换即可截取低32位。<br />seqno转absolute seqno：有点麻烦，可能对应多个结果，因此选择距离<code>checkpoint</code>最近的那个结果，<code>checkpoint</code>取前一次所收段的absolute seqno。原因在于两个前后到达的段absolute seqno的差值几乎不可能超过<span class="math inline">\(2^{32}\)</span>。有个corner case是当<code>checkpoint</code>比较小时计算得到的absolute seqno可能小于0，需要加上<span class="math inline">\(2^{32}\)</span>即<a href="https://stackoverflow.com/questions/4201301/warning-left-shift-count-width-of-type"><code>1UL&lt;&lt;32</code></a>。</p><p>做好索引的转换后，因为麻烦的部分已经在Lab 1完成了，剩下的就是根据<code>TCPSegment</code>写一些业务逻辑。<br /><img src="lab2-2.png" alt="在这里插入图片描述" /></p><p>注意下SYN和FIN对ackno的处理就行： <img src="lab2-3.png" alt="在这里插入图片描述" /></p><h2 id="lab-3">Lab 3</h2><p>这次的活是TCP Sender，负责将应用层的ByteStream分割为段发送，根据接收方的反馈情况进行超时重传。</p><p>每次收到接收方的ACK就可以知道其window size, 发送方在每次收到ACK时更新窗宽，并且在下一次收到ACK前，根据发送情况记录窗口的剩余容量，决定是否继续发送。<br />只要<code>_stream</code>还有需要发送的内容并且receiver还有空闲空间，<code>fill_window</code>就要一直组装成段并发送直到填满该窗口，receiver真正的free space应该是其声明的窗宽减去已发送但未被确认的所有段的长度总和，这个free space才是可以不断继续组装新段并发送时可以利用的，在<code>fill_window</code>组装新段之前要check该空间是否大于0。</p><p>另外，发送的第一个段是SYN段，没有数据，只有SYN和initial sequence number，SYN段发完后就返回等待receiver的connection granted，即第一次握手，此时窗宽看作1：</p><blockquote><p>What should my TCPSender assume as the receiver's window size before I've gotten an ACK from the receiver? One byte.</p></blockquote><p>并且在TCP Header中SYN和FIN不能同时为1，否则应该报错RST，FIN段是可以携带数据的。</p><p>如果收到ack表明窗口大小为0，在<code>fill_window</code>当作1处理，但是超时的段不应double RTO，因为这是receiver的原因而非线路流量限制导致的，但是SYN段超时需要double RTO并增加重传counter，以便判断是否终止本次连接请求。</p><p>FIN段的处理需要仔细一些：<br />如果<code>_stream.read</code>以后<code>_stream.eof()</code>意味着ByteStream已经没有需要发送的东西了，这时就要考虑设置FIN的问题了，但是FIN是要占序列号的，也就意味着要在接收方的window里占空间，如果free space为50最后一段的payload size为30，那可以设置FIN；如果free space为50最后一段的payload size为51，那么最后一个字节就需要进行下一次发送，并且在下一次考虑FIN的设置问题；如果free space为50最后一段的payload size也为50，那么这段数据可以发送，但是这次没法设置FIN了，也就只能等到接收方腾出空间后才能继续。因此只有free space严格大于最后一段的payload size才可以设置FIN。</p><p><code>fill_window</code>有一种情况，free space还有但是<code>_stream.buffer_empty()</code>已经空了，但是只是数据发完了，FIN标志还没发，就需要再发一个段，因此这样写是不行的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!_stream.<span class="built_in">buffer_empty</span>() &amp;&amp; _receiver_free_space) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="lab3-1.png" alt="" /><figcaption>image</figcaption></figure><p>可以直接多循环一次然后用segment的<code>length_in_sequence</code>判断流是否真的空了以及是否要继续发送： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (_receiver_free_space) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> payload_size =</span><br><span class="line">        <span class="built_in">min</span>(&#123;_stream.<span class="built_in">buffer_size</span>(), <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(_receiver_free_space),</span><br><span class="line">             TCPConfig::MAX_PAYLOAD_SIZE&#125;);</span><br><span class="line">    TCPSegment seg;</span><br><span class="line">    <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(_receiver_free_space) &gt; payload_size) &#123;</span><br><span class="line">        seg.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">        _fin = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(_stream.<span class="built_in">read</span>(payload_size));</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    _send_segment(seg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 但是这样可能导致一直发送只包含FIN的段，因此要在while循环限定<code>_fin</code>来确保只发一次FIN段。</p><p>关于重传，闲来无事，把重传计时器单独写一个类，因为这个类相对比较简单，所以就和sender放在同一个头文件吧，不过据说有些公司的coding guideline有规定：</p><blockquote><p>Each class shall have it's own header and implementation file.</p></blockquote><p>采用累计确认：如果发送方收到ackno代表之前的所有段都正常接收，因此用<code>std::queue</code>存没有收到ack的段（包括只被ack了一部分的段），超时后从队头开始传。<br /><code>_segments_outstanding</code>发送时在<code>std::queue</code>里是按照seqno有序的，只有每次收到ack才从<code>std::queue</code>里扔掉一些已经被完全确认收到的段，否则认为<code>std::queue</code>里的所有段接收方均未收到。</p><p>收到ack并清理完<code>_segments_outstanding</code>后，如果此时还有未被确认的段，重启计时器并将RTO和重传counter恢复初始值。<br />注意收到的ack可能是非法的，比如ack了一个还没有发送的段或者ack了已经收到的段的序列号<br />还有一个corner case在<code>send_extra.cc</code>的95行，如果收到了与上次相同的ack，计时器是不应该重启的，重传时只有收到的ackno严格大于上一次的ackno才重启。</p><p>计时器的启动可以参考课本： <img src="retransmit.png" alt="计时器" /></p><h2 id="lab-4">Lab 4</h2><p>本次实验要实现<code>TCPConnection</code>负责将同一个主机内的<code>TCPSender</code>和<code>TCPReceiver</code>衔接起来，理论上如果<code>TCPSender</code>和<code>TCPReceiver</code>足够鲁棒，那么<code>TCPConnection</code>写起来很快，然而现实太过冰冷...第一次在项目中体会到测试的重要性，也有点理解TDD的好处了，好的测试不仅能够发现问题，还能根据测试样例debug，再次跪谢Stanford~</p><p><code>TCPConnection</code>既充当接收者，也充当发送者，可以理解为实现以后就可以在你自己的主机上使用，接收别人的消息，发送自己的消息。还有syn的处理需要考虑作为接收方和发送方两种情况分别处理。</p><p>通过<code>segment_received</code>收到TCP段后：</p><ul><li>如果RST为真，sender和receiver都要将其字节流设置为出错状态并立即终止连接；</li><li><code>TCPReceiver</code>获取自己需要的信息：seqno, SYN, payload, FIN。如果ACK为真，需要告诉<code>TCPSender</code>相关信息：ackno, window size。</li><li><strong>只要收到了<code>length_in_sequence&gt;0</code>的段都需要发ACK，如果sender要发数据那可以顺便携带ACK，否则就要发空ACK</strong>，便于peer更新ackno和window size。我遇到的第一个corner case就是空ACK段（比如第3次握手），由于Lab 3的sender只关注ackno和window size，通过要发送的seg的<code>length_in_sequence</code>判断是否继续发送，第二次握手收到一个payload为0的段，以后正常交流是不会这样的，因此第三次握手应该回一个段（可带可不带数据），但是Lab 3的<code>fill_window</code>遇到这种情况会直接返回，不会发送，我们在这里发送一个空ACK段作为第三次握手。</li></ul><figure><img src="lab4-1.png" alt="" /><figcaption>三次握手</figcaption></figure><ul><li>还有收到keep-alive段的处理：peer可能发送了一个非法序列号的空ACK段来判断连接是否正常并获取我方的window size，需要回应空ACK段。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span></span><br><span class="line">      &amp;&amp; seg.<span class="built_in">header</span>().seqno == _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>TCPSender</code>负责生成要发送的段并填充相关信息：seqno, SYN, payload, FIN。并且从<code>TCPReceiver</code>获取ackno和window size进行填充，如果有ackno还要填充ACK。</p><p><code>tick</code>这里如果超过最大重传次数，不仅需要关闭连接，还要给peer发送RST段：如果sender的<code>segments_out()</code>不空，直接将队头的段设为RST，否则调用<code>send_empty_segment()</code>设置RST并发送。</p><p>比较抽象的是TCP的关闭这部分，有2种关闭方式： - unclean shutdown：如果<code>TCPConnection</code>发送或收到RST段，立即将发送和接收字节流设为error，并且<code>active()</code>返回false - clean shutdown：不出错的情况下关闭连接。</p><p>由于<a href="https://en.wikipedia.org/wiki/Two_Generals%27_Problem">Two Generals Problem</a>，背后的道理是在不可靠的通信链路上通信双方理论上不可能达成一致，因为总有最后一条消息是不能被确定收到的。因此只能A确认B是否收到即可，A保证B已经收到，但是B并不知道A知道B收到了。即client并不知道server是否收到了最后一个ACK，因此不可能两边都做到clean shutdown。<br /><img src="lab4-2.png" alt="在这里插入图片描述" /></p><p>四次挥手是这样的： 1. client发完数据后发送FIN通知server自己发完了，但是server不一定收到了，client也不知道server是不是收到了； 2. 因此server发回ACK通知client自己收到了FIN，此时client知道服务器收到了自己的所有数据，但服务器不知道客户端是否收到了ACK； 3. 服务器的数据发完后发送FIN，通知客户端自己发完了； 4. 客户端对FIN做ACK，表示自己收到了所有数据。这个时候客户端知道：服务器收到了自己发的所有数据，自己也收到了服务器的所有数据，客户端没有问题。但是服务器如果没有收到最后一个ACK：它只知道自己接收了客户端的所有数据，但无法确认客户端是否接收了自己的所有数据。因此这个ACK如果没有收到，服务器重发FIN，但如果此时客户端已经关闭连接，最后这个ACK就永远收不到，这也是为什么有time wait。服务器收到ACK后就直接关闭连接。</p><p>从client角度来讲，做到clean shutdown有4个前提： 1. 接收字节流已经被完全组装且该流已经结束（peer不会再有新的输入了），对应<code>ByteStream::input_ended()</code>，即收到Server的FIN，Server确定接收了所有数据。 2. 发送字节流已经被本地应用层终止（即本机不会再发了）且已经完全发送（即字节流为空），对应<code>ByteStream::eof()</code>，即client发送FIN，但是并不代表server收到了FIN 3. 发送字节流已经被peer完全收到，对应client收到的ACK 4. client知道Server收到了ACK，这一点无法保证，因此有time wait。</p><p>总结一下就是：什么时候不需要time wait？如果是第二个发送FIN就不需要，那怎么判断是第二个发的呢，如果已经收到了FIN（对应<code>_receiver.stream_out().input_ended()</code>）并且自己还没发（对应<code>!_sender.stream_in().eof()</code>）就是第二个。什么时候clean shutdown呢？满足前3个前提的前提下，如果不需要time wait或者已经time wait了足够长时间就可以关闭。</p><p>初步写完代码后，就对着测试样例疯狂调bug吧！！有时候打断点会瞎跳，据说是编译优化的问题：<br /><img src="lab4-3.png" alt="image" /><br />默认的Debug模式的编译选项是<code>-Og</code>，会对局部变量等进行优化，因此关掉优化选项，将<code>sponge/etc/cflags.cmake</code>中： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> (CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -ggdb3 -Og&quot;</span>)</span><br></pre></td></tr></table></figure> 改为 <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> (CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -ggdb3 -g&quot;</span>)</span><br></pre></td></tr></table></figure></p><p><code>txrx.sh</code>的测试不好调试，可以用<code>cerr</code>打印一些变量，但不能用<code>cout</code>： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../txrx.sh -isDnd 128K -w 8K -l 0.1</span><br></pre></td></tr></table></figure> 调单个测试用例可以：<code>ctest -R test_name</code></p><p>如果按照状态机来写的话可能好一些，但不一定非要按照状态机写，网上有人说不按照状态机写肯定有问题，官方文档也说了，状态不过是一些模块的公有接口而已，不一定非要materialize these states in your code。 <img src="lab4-4.png" alt="image" /></p><p>神呀！Test #104-#160一直过不了，卡了三天，用Wireshark抓包，发现一直在重传SYN：<br /><img src="lab4-5.png" alt="image" /><br /><img src="lab4-6.png" alt="在这里插入图片描述" /></p><p>实在没辙了，无奈只能通过替换网上的模块找bug。但是Lab 0-Lab 4全部替换后仍然是那个bug，不知道哪里有问题。。。严重怀疑由于服务器在美国的原因，结果不是。和大神讨论了下，据说换成VMware就好了。。。开始搭环境。</p><p>编译时如果提示g++版本太低，那就安装8.0以上版本并且进行<a href="https://blog.csdn.net/kenkao/article/details/89550641?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-4.no_search_link&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7">版本切换</a>，如果还是报错<code>The CXX compiler identification is GNU ...</code>，还要修改<a href="https://www.cnblogs.com/minglee/p/9016306.html">编译选项</a>。</p><p>接着就可以正常make和测试了。换到VMware没有任何改动一次性通过了所有测试： <img src="lab4-7.png" alt="image" /></p><p>有点离谱...第一次遇到系统级别的Bug，至今还不知道咋回事...吞吐量结果： <img src="lab4-8.png" alt="image" /></p><p>虽说是达到了100Mbit/s的最低要求，但肯定还有提升空间。我没做profiling，参考别人的分析基本就是<code>ByteStream</code>的一些操作造成了瓶颈，换成<code>BufferList</code>后有一些提升： <img src="lab4-9.png" alt="在这里插入图片描述" /></p><p>接下来的瓶颈应该在流重组器，等以后有时间再说吧😂</p><h2 id="lab-5">Lab 5</h2><p>实现IP/Ethernet网络接口，也叫网络适配器/网卡，用于IP数据报和以太网帧的转换，可以作为主机的TCP/IP协议栈的一部分，也可以作为路由器的一部分。 <img src="lab5-1.png" alt="image" /></p><p>主机与peer之间TCP段的交互主要有以下几种方式： - TCP-in-UDP-in-IP：进程只需提供TCP段和目的地址，剩下的事情均由Linux的<code>UDPSocket</code>完成。内核负责构造UDP/IP/Ethernet header并发给下一跳，并确保每对socket的组合都是唯一的，保证不同进程间的隔离。 - TCP-in-IP：大部分情况下TCP段都是直接作为IP数据报的payload，需要向Linux的TUN接口提供IP数据报，内核负责构造Ethernet header并通过网卡发送，因此进程需要自行构造IP头。 - TCP-in-IP-in-Ethernet：网络接口<code>eth0/eth1/wlan0</code>负责网络层和链路层的转换，Linux提供了更低级的TAP接口负责交换以太网帧。</p><p>大部分的工作都在ARP协议，有3个函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkInterface::send_datagram</span><span class="params">(<span class="keyword">const</span> InternetDatagram &amp;dgram, <span class="keyword">const</span> Address &amp;next_hop)</span></span>;</span><br><span class="line"><span class="function">std::optional&lt;InternetDatagram&gt; <span class="title">NetworkInterface::recv_frame</span><span class="params">(<span class="keyword">const</span> EthernetFrame &amp;frame)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkInterface::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span></span>;</span><br></pre></td></tr></table></figure> 当<code>TCPConnection</code>或者路由器要发送IP数据报时，需要该函数转为以太网帧并发送。<br />如果下一跳的MAC地址已知，创建一个以太网帧<code>type = EthernetHeader::TYPE_IPv4</code>，将payload设置为序列化后的数据报；<br />如果下一跳的MAC地址未知，广播ARP请求来获取MAC地址，缓存当前IP数据报。为了避免ARP泛洪攻击，如果5s内某个IP地址已经发了ARP请求，不再针对该IP继续发送ARP请求。理论上如果一直收不到ARP响应，网络接口应该向源主机发送ICMP host unreachable报文，并且丢弃相应的IP数据报。<br />只要ARP表没找到，说明需要学习目标MAC地址，因此发送的IP数据报均需要缓存。不论收到ARP请求还是回复，都需要学习ARP表，如果是请求，还要发送ARP响应。ARP表中条目的TTL为30s。</p><p>由于以太网帧只传递一跳，如果收到的帧的目标MAC既不是当前网络接口的MAC也不是广播MAC就忽略。</p><p>完成后，就可以将<code>webget.cc</code>中使用的<code>TCPSocket</code>换成<code>FullStackSocket</code>，这样从传输层到链路层的转换都是自己的组件。</p><p>VMware可以过，VB还是挂： <img src="lab5-2.png" alt="image" /></p><h2 id="lab-6">Lab 6</h2><p>这个实验要基于Lab 5的<code>NetworkInterface</code>实现一个IP路由器，负责将接收到的数据报根据路由表转发：从哪个网络接口转发以及下一跳的IP地址。<br />我们只负责根据生成的路由表转发，至于如何生成路由表（RIP/OSPF/BGP）无需关心。<br /><img src="lab6.png" alt="image" /></p><p>第一个函数<code>void add_route(const uint32_t route_prefix, const uint8_t prefix_length, const optional&lt;Address&gt; next_hop, const size_t interface_num);</code>负责保存每条路由信息以备后续使用。<br /><code>route_prefix</code>和<code>prefix_length</code>共同确定一个网段，比如<code>18.47.0.0/16</code>的<code>route_prefix=18*2^24+47*2^16,prefix_length=16</code>，如果一个数据报的目的IP是<code>18.47.x.y</code>那么该条路由即匹配。</p><p>如果路由器直接目的网段，路由信息的<code>next_hop</code>为空，直接通过<code>NetworkInterface</code>发送到目的IP；如果路由器通过其它路由器连接到目的网段，路由信息的<code>next_hop</code>为下一个路由器的IP。</p><p>第二个函数<code>void route_one_datagram(InternetDatagram &amp;dgram);</code>通过最长前缀匹配找到最佳路由，如果没有匹配的路由则丢弃数据报，如果该数据包的<span class="math inline">\(TTL\leq 1\)</span>也丢弃，理论上丢弃数据报需要向源地址发送ICMP报文，否则通过最佳路由对应的<code>NetworkInterface</code>转发。</p><p>这里的abstraction在于路由器只需要关心IP数据报而无需关心链路层实现细节，只是通过<code>NetworkInterface</code>与链路层交互。</p><p>在通过移位比较两个IP地址前N位是否相同时，需要注意32位整数右移32位在C/C++中是<strong>未定义行为</strong>，因此<code>prefix_length == 0</code>需要特判。</p><h2 id="lab-7">Lab 7</h2><p>到此为止，实现了Internet的传输层TCP协议、网络层和链路层之间的接口转换以及路由转发。<br />这个实验让我们用实现的这些组件和另一个人交互： <img src="partner.png" alt="image" /></p><p>由于学校局域网内的IP都是私网地址（<code>10.0.0.0/8</code>，<code>172.16.0.0/12</code>，<code>192.168.0.0/16</code>），为了交互，需要通过<a href="https://www.zhihu.com/question/31332694">NAT技术</a>映射到公网IP，所以使用了<code>cs144.keithw.org/104.196.238.229</code>作为中继服务器。<br /><img src="nat.png" alt="image" /></p><p>按照文档交互： <img src="jiaohu1.png" alt="image" /> <img src="jiaohu2.png" alt="image" /></p><p>任意一方按<code>ctrl+D</code>单方向关闭连接后，就不能继续发送数据，但仍可以继续接收直到peer也关闭连接。双方都关闭后，任意一方完成了lingering之后连接才真正关闭。</p><p>除了聊天，还可以收发文件。</p><p>通关截图： <img src="jiaohu3.png" alt="image" /></p><h2 id="reference">Reference</h2><p><a href="https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html">【计算机网络】Stanford CS144 Lab Assignments 学习笔记</a><br /><a href="http://yuzijun.life/2021-02/CS144">斯坦福计网实验 / CS144 Lab Assignments</a><br /><a href="https://kiprey.github.io/2021/11/cs144-lab0/">CS144计算机网络</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
            <tag> Projects </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新思考机器学习及职业方向选择</title>
      <link href="/2021/11/01/%E9%87%8D%E6%96%B0%E6%80%9D%E8%80%83%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%8A%E8%81%8C%E4%B8%9A%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/"/>
      <url>/2021/11/01/%E9%87%8D%E6%96%B0%E6%80%9D%E8%80%83%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%8A%E8%81%8C%E4%B8%9A%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p>最近参加了一个<a href="https://datafountain.cn/competitions/537/">AI比赛</a>，引起了我对机器学习以及自己未来职业方向的重新思索，我发现自己现在做决定更加在乎自身的兴趣而非舆论等其他因素，也算是一种进步了吧！</p><p>比赛的过程我很难享受编程带来的乐趣，只有在看到AUC指标提升零点几个百分点时才会有一丝丝成就感，而在数据清洗、特征构建、魔改模型以及无脑调参这种占据算法工程师大量时间的环节感受到的只有繁琐和无聊，这不禁让我反思自己半年前的选择：如果将来步入互联网，到底是选择算法岗还是开发岗呢？</p><p>从世俗的角度来看，算法岗毫无疑问有着更高的薪资甚至更光明的前途，我也坚信机器学习会持续改变人类生活并且在未来应用到方方面面，但是需要多久时间可能谁也说不准。</p><p>从现阶段来看，AI的发展尤其是落地遇到了很多困难，突然想起了《智能计算》韩德强老师上课时指出的数据驱动的方法终究很难解释问题的本质，我当时嗤之以鼻，现在有些许赞同了。</p><p>从自身喜好来讲，对于不确定的东西我向来不太喜欢，然而机器学习领域充斥着大量的不确定性，大多数模型缺乏可解释性，我在操纵灰盒甚至黑盒的过程中祈求获得指标的提升，在出现bug时不好排查。除此之外，现实世界的数据大多数是杂乱繁琐的，需要花费80%以上的时间去清洗数据、构建特征，这也不是我喜欢做的事情。相对而言，我更加欣赏自己能做出来一个确定的、完整的系统呈现在眼前，它可以解决现实生活中的某个问题，并且可以重复使用（可复现），所以我决定学习重心重新回到开发岗位，当然如果时间充裕可以去算法岗实习看看再做最终的决定。</p><p>还有就是胡神的很多思考对我触动很深。</p><p>我想好啦，做system！当然我肯定会把当前分内的事情做好、该学的学懂！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>屠龙少年 遍体鳞伤</title>
      <link href="/2021/10/24/%E5%B1%A0%E9%BE%99%E5%B0%91%E5%B9%B4%20%E9%81%8D%E4%BD%93%E9%B3%9E%E4%BC%A4/"/>
      <url>/2021/10/24/%E5%B1%A0%E9%BE%99%E5%B0%91%E5%B9%B4%20%E9%81%8D%E4%BD%93%E9%B3%9E%E4%BC%A4/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5bd80d0b897b52a1062d3b5bd7145b020b2b9c99b7068b7c373d5e31c5e017da">c172f4ee74b2b6d246b20cbfdc0b877efc42ed51cc9967fea7e00930fce7ffa8d4d197ad92799923025d6ef122972b450ca5a0e8515135641fe6542c23b5848673f9e775a61d5d0821ac039b480ccad26bf3c8463effc083007cad62c4d1ec49ad35c1e55c88a5a860dd03f9b4ce3f61405fdd3c08ee59dedf6ca4a49350c99d4176f36ba7dc4f7fca6d28027267bcfb88b285613210d99a1d2c8ce61cbc97e0226108f471a3c10a96da69a478d5aa00b369b3b0c78239ea97952e7aed206e81ddf47f3598c85515a16655f6e1afe6361d26b6b721a107ffb48e4e8d2f0179660f7183b90ed35f9a7364a218bc8d9da5ad8ec557666acc691dcfa8b8bbc6f9629f9386e431f79275313b232c96a2a4ef0a2fdaeb3a0e283fb6f385fa4dcf03149a24bdb7103eb34d14e339d11a62b57998fa2f63d67b59ee535839470539271a22c9a07357dec425a0e5f3b4ca33703d744d54c22f071c6bb07f9941e62884f1c9172870436bfc4db9695afcb8a0536d88aea82b32c72186e8fd8a6f255eb2bd5898527e7187a3218729debc37d76df8dec08f40735915073934b9ecdd2ef20825ac15cb632b54de7cc50887658721b6a40c025f166f36129bbbeffb399a9b7ee98bcf5a9af3a09ba1696e0bffb5b9b662310c9be655209881ddbb954a3543370c3b2ead55fe40999c8fca947ed207a099034fac6a8b72a476c455acca8b02993bbea9417894a69ee3cfd2f95ed386728d930f74043c59928ff1a3b783ee66b0b2471ad2d66282ea4c226d50b332ddb68c7372d932871fa223de76efc17e13d13458e70bba97b40ba87ae9d1e6fe77e30524c4f9b733d16fb979243d25e52ca07c0d57b1e3cd5de503878c9bc94f4e97eda6d8434bc06cff98aff7ccbf4f40638c607c8fb56c784807af5b33975424708e472507eeac4f0c2b07d95f362fafa985575e4d501c62bfd2d4eaed9b30cd3b7b2821882461085ca264ccd3bd06df253d8a33eaf4b0d9df11b94482acee770910cac6ca27829e50bdbe147b6bec56b03947a1473cc7a52d16570713af04215b2b70cd3c5a54294d04dd4abd0791abbaf5c1e191177ea7c953a3b2ce7278bcf71f4dc8e1ef540f92be1257bfc11979f979dc92cc81fc970ad6e155c572d59f58c6e12d9b6918cadf5b3178cf0be8b7f3d50c1dcb651010ab6e2d45a96a8436e03214cac89a899b5a51166b726bacc9f6a37fac8d50a93d6825989b88528ce2723e639f31683e57796d785ae22f15a129f94ce34d18f2aa1968f766d8bba12dbad9264e590f2347db818411d7501ad1fc826d30ffead5dc63eb1ab9eba0d8c19665d37e61d3fad709f63f322e228c410f86b0f3d09737f66ffbf89cc4a725eeb046ecb63f85065501b994f496c4f029fda77aba57106e08fbe280a3f31249343a787ea7c55bee7457274444e46c9e3832f9134966bb66318a165da1f561639249cb53ad1e7e6df807c6517c419e67890eca7deffb273e79776137ac4f5cb295d83c4f78c5647ad630445a4f85f07a0376ad59cea6ae729173f17425def9d6c7ee3bab7cae76e95e6d99ca7cfe6926ca2a764a4135e74b602be90e184ab1a662f4ff16219a49d0c561531273b8fcc823503571dfbbed9dee87b17af6c40b9a9146f93618b863d99e3ef22cb68c58295d3b5394ccd7e516036a0dbeb699923f5f73492e929a69c2a2802dfa08296c79b0c9dec6c3ec0a4cc6cc322fa494ec7957a6ff16197407f2f09652f84a5d837fd70545981c51b393f2a2c6b34e5c93b7fd030772f05c729acafff29c8deaef3235e2689827ca90334608100d85c22dcfca7491eaac6e7668c8c64074f8d6c6eaa356b7e6f0157c60d9a04d7debc8d1dfb477ba0afb74f7afbfed4a5d380e58a2879b6eb4898317cddf71e799d1a3e39465caa746536d2c77b1782be326c7064dfe627bf20e41abcd02efd0dcd230e761237beb830eae778f59ea35d049293c726c01f6d2904cb7d6d25005161899ca05d8239ec983585d800ab447056af55218cf4e008524f479a5be43a3ba8c32446b924830adb9b51aef92d71b5dbfe96dd34a64e06b0f1fa6568a9e4a5fe14daa7e8966bae822908fda0c0bd44eef93ad2e9b3fbd07310af62fd5ed666ad929b0a898bd7e8d7fb84f5ee242b879960a06610dea0bc7d63f1738b266d746d537f8c50f40c5d869d79f77784b39481c6f7ebb0f836ac8fca2d0c9800eaccdd38b645ea3dd9f3a1a1232bdf19f2f0d5aae7245916d8e3b17cd0105c4378e200e1a5ea715f686d737d506265ef45bba72bbe03fb75f0f886d5466a50834df9dcbd50a9920d4f4f7db7e2d2829a8fe87322759ee625863bdc2cfb169732644aec0d6ab3e99c1724eef2270d48044d6433ed5181a426d6348ff5554c8438d76de354f5a632ba3f980273c35a5bab95a9fdb68a23234faa767cb512f4bf673c525902b1a62933b52d92928e657ae3caa89854cec6c9374939d01f2747dd4a3c6235743b8b04849fd15f1edb201b91045c2f822b49336db90f117bbab4f369062202621e822c63c6a08b02a7bb2f62c2947b5d1e46d6009f5f1ecc383c588a201efab8305a5fdb00d91cdb5a7da60a15bcd7d3c4cab3b5c7bc7ac0036ea77e8ba76793de5ff0d708c2921236b694aadce4d8f2810816893de9373bcd86da2dfe434b842c5e9bc5ef688a6d841855ab61f7f90723cbdb0d4d70f836a8b5a7f1d74fae315d6fb2eeb183b0565e11991f7939e00b4ce39aed39b295e3dce114fd3deefb81675b33b2b83640efc242552fa924298d05f7345173fb7c97f39be7a77afe99ede53334b3c8340fb941743f1254c763ea2cd2a060e1dc541ee4aef174500c258a16995e7abf015945d0da2e3802d29037f92ee6f29a4e211bf99ea42373c629fb68290e766c7a5672b14fcc4ce7916d67be27a1e9c6e67a6460f8d709a5c13d1ec295293797be04f7b2e5b108dacdd729c79fbeaaa5ff73085636d44dce1a1cbdf288d67b663013e894df1d98b1843f6217d3c00b8d430a596df58b63fce165d76b57fe543c93226fb995cabc83fc62e47a762ca9f628aba8a6742da0a6814c23fd00fdbdbbafef5459055b17f91ee87bfd5c5985986ca80a6df700fd28b2fa0674d0f011a252a5ec79d98d739129d8cddb6c02439e2ec7dd019499b723d7ce364edccedb667f15cd4b8ce81fc0fe82ead256695e24493119bfb1f1f0b896769c825876ab20ab3123980daf730f1242c3dab356e5d5d387824489d6ebe1579b01012215c00151874fb1faf50ec561588e1a6156686456fd2a5c03cfd1f2c25c3513e203d1bac31855649825e060e67c5611af4c73942151b22e7255dc32986a3c1002b195624b07a81df31bf8d2b56f1868599ceaa5ddb480e202419bbb6e2a04cd83f5adb0331ab552974b9bf30350b0d28bc51bf70a3d1f5ede6fb9cdbf3827709e496e9928969411c3db4edd4ef27172e2c91d6d2f5fbc54028bc463c9f87f43426228c567acd99825f6a90cd618ad13c4f9621bda9a23689fcb2c09e5999acb16b7393d3c6abf980263cba4574efda1db952dc4a0e6a9c73fc7edbfba48beb55490c2d7ada758a02235b49a0585bc3b129785aac25b8425f058c7669811f588e4dfdd7573b99186d39a23d191dc3398504010f8ffa8d50999dc26ea48aa691d5bee4a21aab47e3d22da32197257dc1ec67863ae1cdabc8e9970d020ea6ad7f2626557ddfd82637c5aea1bc58a497b05926acdb8405616303653398531ab43c6948366503788e8a338f97a5ce74d3c7277d8f0116e9794291a317814783a995be1d400586094b692f215cfb2328df2c602b28f627d7bda36ffe29c6d948acab0603cfdeba29a423cf75addeb24030f7d2e30948bb221ec5d5fd1b75b8f80bee3c601d2176608ce78ec5567d26c759c067987f7c41a59d607c6c32a17693969cb491ea5418a0c250e82bfe2d7063dc14d981bbc26a042fb3757205d1de2ba700394e3d152961dab9cd1d9dbdf3d14ccc908d0f139fd8d163f211978846ba638313db35e756287eccbf300f726fa782969f998885fb3294456cbd155f269f7aee93d28ff0563360fabc4ca43268402a8ae4f2f1fa86edbc4f50f92cb383d94bf394640c379aa7f7328db58990957a58e552bb4d2e80635c289563fdb78c6c93ffbb9c9c8cf0105998770a6fbe58339dc76c52a25ea80af49b8294290287fa574b1e5b66980a36f11848d0d94a17db55cf3778e4fd81b66937390912580c859d66b6c643c1152803e74bb8a16bcfefb348d5727e5c986a52fbffd837c7e7230d1756fb254824a0d886cb2de40594ced992788ebe0ff731efb7a26cec103e22d1e1ffbc80646340419d41d59d608b25a075c89e58782c1caed11f6bc8050635f45ae0d136afebc8b59feac91852106be644e2d82c8f68201d9454a34f25666be62c0c0cf9c369749a271f20702ef8f4e06efdddd7f18a309b3b76b1d04fec634f14987ee119d4090073af8997660871a8488a365f5aa7f11f8227717712ec5437b87bcbbc02c0d9f76347d343825db7daff55edbf941a257bcf36394a5a33b473a0f28fce631d6e271fb9594ed55e76df2833c9567942211edac8004dd1e8e0e85413e18028beccecc1d76bbc97e6b46167139c1f82741556ad11d2d89092acf68ad22c07bb97ae63084e57679f05c31f8a170eeb496958d1cb5ce3c94af80d1153c4f0f2a2adec4487a503a82bc226d4490cd2880f34697468806a4a018948a2a4e46f4cb4fb3bafad0f59c4c4b1d7e4b84890fd26b3d1d680ab8ba3cc03d16e2bd91a5179f2962f8b404fc150f0398d30819fe8efcb8c4d3aa965a780dbfc7aafda4c87e8ccc6255c47bfb12364ad749b7e32dbda3f90a1d6ac469f56120a47cc8fdfc09c4a2279b040ad47564017b5af3d1bfb8c5f27e8bfbaef36cb1e0889d4c7e49c8f26196080c0054c848a00106a9d94ea3deb9176f82d931b7f240a7938153091be6b09be37b6d2298dafa4dce07d2a0657fd3a4cda8b0813508890df0f6c21aca09db4bc224e4666d25ffea15b8e625905f2d0da2b2d72e179a4b4a851305ab1fb495fb0f6beaea9c8a7764c741b377017029b01d5d63e7b675ded2c8d89e1eb2c772668d825b9e59444949141068c183edbab8a61084fc5d0e5c39cb5e3420b08957306a177874c296ae7f0cbd5e59b5a56295f06e31bc5f7a2fd8379f5780b4b25ad1bad269d1fc6d2188841eb8f80cfe42c22c4c855f1a0b0537687bfdef94080432855031581b71304941525fb2e9cfdc0724d0bdf7423f384612621771926d0f15a6f02cb3c53a30da891e8c00aef1f39e93836515152dff29db451526720183dbcc6247c519feb7e0a025db1b3834a48788609eac48bbe856f4eb8e452ada879ab32c6931ae5d6f0d54d4c61d903e22f100e4d13c8fc85beee35edcb13cb3c07afc986af73dc31cb785791eaf348a2970a445271532220047f2d32923ecd64f00c8ee084c3a49d3ceb3155e2c9f121c0b0c306f4c159eee6b4dce6d4af6d964cf67cd2cc1a8bb3d6a1b0e82b9eb80f1dc1f9b477a1903a434e18bad435e8690c37980d218c87f18793a89752a02c77b83b072b1463b75c9ed94735af59a1a0811cdfc87cd6ca9776c5c59a2db87d418ba88e9ec28e0dcee094180ddcc8011bcf755f2e9bdd8898b2363942eae06d20c4543fa21d49040a3c8d20e8a064a0930e3a78683aac51a8641684fb7060309a72357223f52e4c3dfee7de39828e81900b3565c586c780f4d47158929274625132be5c7f8f1bc96a1500508100ca8c4d7ce3d1165ec750370fe966cdabaeab27013f9cfc54e032bc67e21b021354f38eb307ea6670ad20caf5b54075519c91ab36a86dd43a086049b1e986e5162cab4abb8609953c7f13d8f85ac0be8508e32e1b6a5c1ffc5927a41699c93a0406416b2376c1396b7f51ef310e47b106a77780a3964e72f1eb420bfec2ae45960161dcf2d92c3d6c1a4097cc5688ab0a3473ee88625ec36118690e079a5e0ad3bf7169c5582058ed559dc90b779e91c7410f24bb23e69a9df35b9557ca0ca78a4aed4b004398e2509d7bd50fea64746df40dabe14aee166d94a8e09ff9c7a655730b43a948b72b6de894a07fc7cd3e140da62aefb243a507f49325d797e60967eca78afaf009d5ea7ed69b211e7bfc2c9a76027e2c59b369537b4e741a86972b269400fdbd48555a73dac3783c90844b9173a667bc42a5d7dac386fa504b8bf93ac742bc1e4c8168542ff7d02fa10262095db8e7aa5c55babfa52f289e9e2e71a631a7dc6eba4158ea821baa055a940720b35c1c505f2e5e7bc30e5fedd837709daf7cac5483b085de55f5452bb8931652a3a564fd4759bd009f7d3606112477acda29c648b97363e77d8bb8ccd57640297feabc4fd5bcbc2db45ea43e1c826e70d384edc322a96a2a45e3b967ce1c187d6abb9a096178bc15cdbed79f11c2aa9ed3121a7a55a43b6cb70e90bf3b70ef1b8ebc221d41cfacd1d0cfce635d155cd12b4d298332bb342fca58bf9fcbbe7890d463e684b3a8bb43b090e6f21620b548d583b4ed84b7daac386f23cf5e9cb3fa0b8c2b83c4ee69f016ab283dc492ebbf38e75a656a692a0cb22d948dec58d63f0ecce40bf2483a367a57ac36df22c3046fbb27302adbf412896ce3ff43025620acb4c6d02761b4aaacbb77adce87f1eb984328bc0aeda57e5e6277648c9dab671f40ca0600d6f7f37ed57384ad7da1aae8c8c0f536b423ad51e0d7f4dc3e56addbdb49163ca81f5cc9ccdab83fd9d6c3c6dba6e6de9f7204c19babeecc6eaa13c37ed82a1c6bef56da1c6336a1a8518684bf042f6fe833dcedfa5b0c865a10871c0994734a6ce77f02055e0b14c71fd8f9cfbc7fe273c621f2c94c62091d287660b4974e0bd0689ac79816dfc8e2c4b0f384fc5208285f492c611133eec6f63bc4292fc6f3e758b7b980948b2b749c98686aac8013aa0d6d800302c59bdcd39eb1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试注意点</title>
      <link href="/2021/10/16/%E7%AC%94%E8%AF%95%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2021/10/16/%E7%AC%94%E8%AF%95%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="输入输出">输入输出</h2><ol type="1"><li><code>cin</code>的结束符是空格, 制表符和回车, 读完后结束符仍然在缓冲区. <code>getline</code>的结束符是回车, 读完后结束符不在缓冲区. 读取一行有空格字符串需要<code>getline</code>.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cin.<span class="built_in">ignore</span>();  <span class="comment">// 忽略\n</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删掉该行所有的回车</span></span><br><span class="line">string input;</span><br><span class="line"><span class="built_in">getline</span>(cin, input);</span><br><span class="line">input.<span class="built_in">erase</span>(<span class="built_in">remove</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), <span class="string">&#x27;\r&#x27;</span>), input.<span class="built_in">end</span>());</span><br><span class="line">input.<span class="built_in">erase</span>(<span class="built_in">remove</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), <span class="string">&#x27;\t&#x27;</span>), input.<span class="built_in">end</span>());</span><br><span class="line">input.<span class="built_in">erase</span>(<span class="built_in">remove</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), <span class="string">&#x27;\n&#x27;</span>), input.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>将空格分隔的字符串读到<code>vector</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function">istringstream <span class="title">ss</span><span class="params">(input)</span></span>;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; tmp) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="keyword">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; tokens;</span><br><span class="line">    string::size_type start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((end = str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>, start)) != string::npos) &#123;</span><br><span class="line">        tokens.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(start, end - start));</span><br><span class="line">        start = end + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tokens.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(start));</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>知道数组大小后，可以直接读到数组中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>删除首尾空格</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; &quot;</span>) + <span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">0</span>, s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>多个数最大/最小 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">min</span>(&#123;a, b, c, d, e&#125;);</span><br><span class="line">*<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li></ol><h2 id="stl总结">STL总结</h2><ol type="1"><li><code>int stoi(const string&amp; str, size_t* idx=0, int base=10)</code>：<code>idx</code>指向第一个非数字字符</li><li><code>isalpha(int ch)</code>: 头文件<code>cctype</code></li><li>对<code>map</code>或<code>unordered_map</code>按值排序 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="keyword">int</span>&gt; record&#123;&#123;<span class="string">&quot;a&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">vector&lt;pair&lt;string, <span class="keyword">int</span>&gt;&gt; <span class="built_in">vec</span>(record.<span class="built_in">begin</span>(), record.<span class="built_in">end</span>());</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; b) &#123;<span class="keyword">return</span> a.second &lt; b.second;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>unordered_map</code><a href="http://www.hawkers.cc/2016/04/unorderedmap-pair-funtor.html">自定义key</a><br /><code>unordered_map&lt;pair&lt;int, int&gt;, int&gt;</code>会报错，需要提供一个hash函数. 如果key不存在，访问仍然成功，返回value对象默认构造值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PairHash</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> pair&lt;T, U&gt; &amp;x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> h1 = hash&lt;T&gt;()(x.first), h2 = hash&lt;U&gt;()(x.second);</span><br><span class="line">        <span class="keyword">return</span> h1 ^ h2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>, PairHash&gt; m;</span><br></pre></td></tr></table></figure> 但是<code>map</code>就不需要, map的key类型必须支持<code>&lt;</code>运算符</li><li><code>sort(v.begin(), v.end(), [](int a, int b) &#123; return a &gt; b; &#125;)</code>或<code>sort(v.rbegin(), v.rend())</code></li><li>vector追加: <code>dest.insert(dest.end(), src.begin(), src.end())</code>. <code>vector&lt;vector&lt;int&gt;&gt;</code>每一维元素个数可以不同</li><li>C++ 17的structured binding: <code>for (auto [k, v] : unordered_map)</code></li><li><code>std::lower_bound</code>和<code>std::upper_bound</code>对于random-access iterators的时间复杂度是<span class="math inline">\(O(lgn)\)</span>，但对于non-random-access iterators如<code>set::iterator</code>是<span class="math inline">\(O(n)\)</span>的。这种情况下应使用<code>set</code>自带的<code>setObj.upper_bound(target)</code>，复杂度<span class="math inline">\(O(lgn)\)</span></li><li>反向迭代：<code>for (auto it = nums.rbegin(); it != nums.rend(); ++it)</code></li><li><code>sort</code>记录原始索引：可以先过一遍数组，将数字和索引绑定，然后对<code>pair</code>排序。</li></ol><p>常见算法：</p><pre><code>1. 二分答案2. 数组、哈希表、优先队列、栈、双向队列（在头尾都操作的）3. 深搜：建图转化4. 排序5. 贪心: 从大到小/从小到大排序、单位价值排序6. 拓扑排序7. 并查集8. DP：线性、二维、背包9. 双指针：对撞、快慢、滑动窗口10. 模拟11. 数学：猜答案、打表12. 前缀和、差分</code></pre><figure><img src="https://img-blog.csdnimg.cn/7cd3cde9f220426cbef7fcb4d6d5a38c.png" alt="" /><figcaption>知识点</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Interview </tag>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常碎碎念</title>
      <link href="/2021/09/24/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2021/09/24/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e88d1667989a1b8c4a5118ca57c9241970fb27617678f327eb88e42d37119d61">c172f4ee74b2b6d246b20cbfdc0b877e4764b888105c1ce8666fa174a7a9eafc057f93334e610ff42f95dca57b7d3a34cf2111b56c910099f310233427e7d797cd18735fa17f10aa179d0c23d3f2f0e5c08b44a1525a3dc7a698fa190011aaf709b07f50c72add8132f741dcdaa6d3ca4aab7971f982554517535523ec0f88110859dfc5b94e95d5ed2f619a5aeff685a35675c6f6d6169c0e9891ec054f5b2cc1f924c557670241d4d660bb38821d57e0fc550316cb77bed709fb1b58bae4bb5d8e8139a7f3a895d56a386c7d134a05d4eaced0ac669fb8cbf0951c7c76e56743838f91c47910bcd45b6441d60599c2ff674d146d448a94ec5588cd7d531c99e584bc9b014318ad0326778457c130d844ec93d39a41cda7a72a4545debec1d97c0c42ea4dc1303029eaa7ff4911eeb771f64ad68d44eb0719905d087d1371ed0bbebf90a81f072c220bf0ec142b733eb29a743e41b1a75d8d9e9b8ba77a682e2d9cb28c855cf180372d107be6d43e49b582d57015230bdf742fa92efaa09edd62a472481c35e00287bffc117ef0fe339d15fa072ea3a7fcc2251121b56c920b7590d1dab3c94857ddc4f122ecc0bd04c071b13dfbb3aeac621a3542c3d8a023dcb53b16915eed3100609770efbfb514cd0e13e077bbc9ee12a545122098e8c26a162610305555fbba5e008fd1952f85d0f1835cfffbeea473000cf922a6c6b55c029fed1d65d6c5a41f52cd8633e1e4a6b9501930224472d6d060a3434694686a358414f1cdf80ffccb71c321eeb3f32bcab098017b71be10e198a45761f6d42c4a5b5150abb281e0c6dfa666231efd2afaf3d90fa340511a83746abf9f435bfb239592fc6a4f19c622a9b898dd653c3479da59fbf3551546992be9bf4daafdbcb50af9e1bc3fadb9fecf354ae558d2b2d261a19779cf6564b16ad155d50d3286c32d4c14af2bd8460b099ce15afb15c42a7670a3aebe8fceeca1e83d08973f35ca127f51bde05e7984c571a876daecd38f3fef616d918676f357a30157360e0bb3a19988886826b262a71978aaade32b7a58602384e56c5520aa4f08c89195bb119d38feddf39f209e24bd0c26bc379ef053637faaae7fccf680fd9a5190f76d20909641207b520212c443cb8ae269233d7ade00d0380e4568ccff2982e3680904032fb725022dc9e0c3aa60783b1c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是江湖</title>
      <link href="/2021/09/11/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B1%9F%E6%B9%96/"/>
      <url>/2021/09/11/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B1%9F%E6%B9%96/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="93538279bb91b48ec9590a6ee71c2865439c3225be3bf261b895e4bf6caeef71">c172f4ee74b2b6d246b20cbfdc0b877e79904ce4b41922be13efa65d3bd543c45ae5e2998a683b737fda11debe8a3e574a183c3da3e0ae9e4e898cc5bb81e85a300a3765a3bc2e4a076656b805517a1448c4efdce6243b3a9c57b858e2840efadabbb9efc3695216ccbce007af95e921f24e2836d829693dc53168b09c1d2b3b47b125f10f1ea182f22280908cb7bd48d93ae154cc2f0dd72a3136a76ee4b8141deb718f7d82db488b23d2f8419dc1f04955b12de0a562471a150e3f8ed37f351f24002cd637012ce319af952b039d746aacc5f428ec16fd92d182db06ba591d021cca15e1146d8a3df79dba125ff2481ea1d548074ac566661c27bc4f703614ce7ba6cbd82bcba89d9daf5cb01b60c498215dd7becda2f6f6fc94b3ed89e1171aa611d2f52eff9010c12a2eba79124bb869bc4fe13d924357a9a3e3694f20e1be2e45ce6b61c0e2c41750f0a03de597fad2d46acd7026f1720df4734dd8257148dc8fde6d32fc68508f3ede0c6cb0d77d6b1a1a749b3e20175f34c26416e018d52c1e295afd26d3e545828a9c09c319125b3612507337d834809f6dbf75218eaafca7445858e7cbce7b3f5c8b950a1721695907562b19095120e6d8557f15e58926c84400f5269c44196e40763f39a41db530eeb5face416fba19e4bb36099a17307fdc7e1a7210e5a3f1b8cd4473cd6c8ca1dfe03c530103d2429077555f7fe980a71fb4dba4cb2252c49142c66aac29915efcfade1968c6497b985f177d525d611ba69ae498d776cf121ede147e790f65f14a9f31ffd5c866c7620e2e5273f254e18100e8f9dc0ca2faa742ceaa6ed96c42736b612d07b7a47a013e90caab1ae553507aaa032ce464b92121422bfd3d79c4b7936e7ad120228abc8e407b28f342953690095b948e7fc48541500e93764014f33474cdec2cf5a99cbf4850852d3711b9db4d80193c2c2ada338f533bcae0728550dafa1a98ac19a607465a044efe5edd59a9f3fc55c300f62f46ae3a5b79e9deb5f72d619132db2570fe39ea38ce0e06b766f2fc5eba4b7b5f399389c2ce65d961060692ce1046efc6db03cfb0d26ba815519e485b5213af2a414b538b52f7143379ac0890003aa497d5ffb54892adc748f489a9e2243de872cb8b042041708ad38ae21b0d99d06442c47f545b45845425dcb3312d64819fbb1fe46b7ae76dd9b8ea83a5e24debc7b8f469aaf17bf2a3c16981db9b645c569f4475358929d6c25014079c68b747638e24f882f284143c26973b2b04633aaad4609e52dae4d35e92c0c8037094ebc67775b4d4b333d08032ffd7b56543ad3fae672ecaf18d009ce8004d7350e2d48ffa30bf0dd4f853782bde25b396c5ce47943c6d3f6dfe6e7ceaf26e8a50064f5b06f3f9e3df5683cd9b250bd7fb78e315972e686cd739ab631ee1e4c55961b1c4580862c639b33d2f2effe0166958cc171a1155e6cd426c313f1b40f0e33b80c7bc9508084718033214024de4cc2b672ceba1cb0f491c2d87a2757e4db6b47c5d3b284c4125bec712623d648fcd24fb15caddf216e83e28b9717b9d37428bc17759fb5dca26a8eda0307744ca9bfa0d559f95f7cb08de32a35a21babf2fc7ead24b1945c8589f91974db54c82a953161defb2c9f5023c01b941c61fbf036ef51de6bf0dd18df552c0eb6847eaccc4647011c049d1382c3d93aeab6496a21b3d70fd6c616b70f6918583b33e6ff838ed9007ec02aac20a6b2b9cadb743ef9e758fe6d2d33b0da9c9ea690f4a59d4b64575af67ebff04ffbdf4dbbdddd5119abf69fad8ff6efe10ec9c22b8e10d0ac238eba0f884e481f9e1ce217894315600b1b1b77280c50d8b689eb4e6f4d0fff8e1be2258ecaa54e7e7950bc1678a8b141f5a7c6b109ff72d1189b1116242862829daed26e02e06342a7b6a2dc08837731f0561c4b7b2bc409b87d6f39ca18ffdfd91a9d0aa2be12e167e8ae9386ba80506e174cc9ff3207d510039d10b3a3c6760cc3429484c22f73d601b07ac44862e08e1b6eeb6456f83e587eee2e2b8662a3b490cc1e264244b10340106e345b6cb3225dc96f2bdfe06fdf4c038102f1298099678a3b85233d8984e60e34c8006a895b2602b9890329e571044ebb3640c9ca86d91ccc0c7ede4a746490328912ac4baae20a04ddd651e91baf08c35f13c3afbd76c4151be067932a9bf12f291a670bcd5345f1adad06ad2e7e37227adad48f2cc06dd659885f5ba2805e118ac241d5cc4d740e3dfc658e9e29c4989a99177f726895d917e8824f185591603f3a2ac6c7ef37bc280a3a14ae94ccacfe6d8ef8a6485c3549bb0fd069dcfd26323e46e595a41b2499fda571605faa6d22143ede37f120a0b17dfcd45fb6cb36356abc17aa014f24b0f47490a333197d0997636db6b527d549c300bbd18eb7331a694ac2f8ecf1c7db64b31889bfe97a1ccb59382ba7df694615e41374f4ba2f62f38d1f2bee6864d833551c09619591b39f651e5e13202390346464ff43134c11689e0121e4228b0d7dd1637f4e98a6be721629f78b3452997d079ecd207a0bcd5c9faa05a900894cf1d3165f9b3f8bc7cb3d093072a4e564c0eeafeceda2d3b854be1374dc397693d080d2dd9226fc01d569c53f899e271df71211679ab1d6fb86f114924603a57e7b555a2a9a799e9da10a6a1c91b7f259cbabb5e76f2f42b8fb93255f50dbe3f2a913f276b12c8718220031a0a0aaaeab5832e0b4a8bb1b9b0616a539d0486e211bf071d1067d0db7f2ae5c4246be99e45f9c04195f1e5ee7071e2959743fe1ba83a8891ff1f9254563e7e2d4b8964967446c306a5e366df4edb758dc2b52660d2a93a8acbc0bce43e0d3cb1d8315a1ab61be64203bf30f90a33d84e422a21d1e883044a52a2f03021dc2c75a5f173b3143c88628c336d3ed095af9685080a30d6b59a59e511abc4ad3a0b3dd8049dda4f3f507cd2fd1d70bba2e0a0768dbb2fb2cee975692ff8d0340cdb9e94658272780a93158f9d787b669d6f0336be0f0ede6911777c5afcc24b127c4525450be13b48e080d1bdd40315d2f5b91935e9bb546a427627ba7ad989cd7e6bd628fca0e610e2277d5c554ed7b71cee10517ce190fbbc12a09c004d2e390e8d010d2594c5b1597e22920ea02e430e80428dfbe7f7d0f3762f58018afa230de34e6eceadb9afbd17815d5c72371892cc0429a1eb1ecbedcf5b8534ecc566fb10ed2050ff28acfb1f905e635bd86b674c385d0b6e30956d4cf1b4a6051d108f9356374e70c547a2a14591c3ea7f2b472628ef328d99256e19053797cdcee3b9cf71ae121178aba6a1d0418ccc438f57bc885f9f50daeca049ac822b4ebb4ca8b9b4d23d3fcd0dcc2ce6bdfba42fe88b7ef6934682b4aee0cc4fb507af73b7830a4eb6caa835e6fe2cd19ea8f0ba4b2e27299e2d7991019373e9916f26ce1b74a64b290153f80f15845142c6cd612a32c914a12bab9ff4bdd5232cd56be0fc8d12c9559853c69bcf9d3a5fcec5e653d5908571007946e8572944763dc128ea1b7c809b820b4da256f70c70cc85759f80622335c05e23bb003c9371b639ada299a769b3f26dcb532cc74e530050e18934139166c23a384ed934364e6c17aac4a1b432b2fcec417256705360cb2f72972506ef1b7f464e1898c143ebd8ed439760fabaf9748534a34ae0e255d69914218cc16c607fe8e2c91b122aa1149a51aa9394d92e8a34252a42e1f055e878ebb96c639f40d4f197db3d57edb38a24412606897d69acb4264e11040fff6abb529747ce7eb44c350abecad76dddeeaac663a1d9ff1642678efa48bbd438b4f0119830c33993850dfb796baf023729d040f4cbfa313084009f522c00927d0ed83e09c79a5e29016c0d0ee27842693965ac132d5bfaf38a1bec1b41cc0447d3e1be42a9de90628f9c9060e6fdb4f0b8acced28fb474d5a53a65</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Make Plans</title>
      <link href="/2021/08/30/How%20to%20Make%20Plans/"/>
      <url>/2021/08/30/How%20to%20Make%20Plans/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="57ffede0ca0c76eac40aeb4e2accda68f626f897e9a4c7251942e5be7466702a">418fac4f173397084caccc18ab9f089e0dbe5a3f55ea9f5889ce3b2b354a143dbb8fb8de69281e5be84d3d0bd8f2cd11f9a3f2c716010bb4afa88b47b913f73b1783a60b8488c70bb3b5a1d8fe8e84d2087d284b4a31fbfa1719aef35c8658ffb7e6bb004df7d61293d6718784830be32f273ecd4c35cd6729798e06eae79d60c5a153598d66c12c5330fc4a42928929c823fc6729709455414abb677f69acdd85d6a6117711f018ec32fd50ef569f85b0634d78e5495bf4a199a0b958258d312ab277827ce5004747e8d4395ed8923ff49e4b490bb481703f7aae08e321c0536bdf110f5a1ee897fcb53dccb38299ea54ae1315c6a0c42136f30f3561359a05b683de77d28fee7fb1ec07bd1e91ca520c94977f49d8a70898456e867c12b2de7aa9187548d4a980615e134a75b7ec9409872fc60c2f26879b2d7cd46779f6ceafc1aca722a405ad74f908e9932649d5442e86da4be342f699021646047434e1fd10c22a228409a46e54a06f5cc69c0630e57c16dc665aac0100cf21f4c047f6d0088957499f4cba523ba73b4b6f172e733a3030386c2aeb81c7ef648efd9683a504b7340be3d3c8c0beb4bf7fdbe24e39f6db2fcafb43374f6b8cb204eeff0b8cd3719ade68afaf7ab61e59ff1cbbc4a900c352fd84c95a7746ff45160ccf5cde02ee2b09467e7947a3b93d0daf99aadc64ca057c3d7e4359bb06e3a5fe4d228b762239469fa9f74dec43e821b4ead6036f1c2ad0909c5e5d9faa19acd3d53dbc23a704e4000d5bd89d14ff7f159996f0f1f685408790ff1426671d87957d7a7255a4dc7464879f502c22e728e9a09b594c4f57e4a921d3875b872d37122235b4cd4383a7c0d8c774ddf1cea7256ec33021dea9b6450bffaf6fad123a6095be819f25e494e37e83aac8f64a3ff45dfc043f8f5c13cb2386bb75b0fa96390398d4475a234b2b7e7d5e655142af715042f86d5453f5e88938326fe405fe5552d524124af92735abfcd4615bc81e16e3d0e24929cb050077084e12b5615b9940d60e7d33b9c3965e51040cd801bc9e69f42e4d7e38dd77c4ee45f62fd54b52504a02f1c0dd763f17374852aa4f582673f5ff2cee9d799d4086543ff616e97e76858aa508f61b16f2e6cbbefef3323fdda19791d4f051f16059a94b77181034ab564aa876f843e857a14499a78977e48ebf0084b4aaa62669aa191f1c9a327bd712dd0f6a7fc1f02df31730ef8908c29399f090857dcee6818c95fa86452ea52e3c346057353d89a23d247c9362a630793f15610b3e4246010c531e1ca8508583a38450af6be48c5a95cb734ed657d481439c4b6e4b1c20eb64c37f15458862e5db11cb4740734106e2039e8c8dca350b44bce2aa402e994c5802e236fa9eb3920e3fc1d84f29230d62f8c1029fb81778d0cfd027fc15277439b3808233eaf6fa119dfe591d8bd0465acb0b5e25f9a616b3bf172844d85222a07dd721af159b056a460775ecb270d87c8d5d58ed12c809282f96c1f4338dc2bce49551a537ae4aa19bca5da5f512b130b1c1b6b4feb84b03d1ccdde1279113b6e482a2a37b734bb37977c408c338935ecf5dc73226d7bcd57b8b13019d3b7d5fc2570cdb24f7a28951cdbac36e1cc8af36889e86dd34becd14b5b3d10a3982a5a450b2eb2b8332c8b1400987f505c7386f6a2985c37b6da1e2f0500214ea4ab71f36d8c21c7c630c46f0695f33109581f80891972afdb3f0b6ae5c1ca17738f67c865ceae2ab94741bec8ac861e3d75622d292fb556e49c7a13a6f6968779c7263ebe9efe0d0ae97c990e046625ed802e03c41a9a930ae87d4ffc582e31eea9682d0b31227484b30c967817cd5b28a6e72c49452e1ad871725c86b3e9dbb57b26032265cb66e3781eb2c4e6be2cb998f8d365082bee833173c3fd929c7f70071fc509c13a8d3d26266336b3055becca079c28668ce9fcc7454a1665aed80ff2be1d5047521ae482ad087de9cd1d5c8be1c1c39b5bbbad59fa402a5c9d062228c1fc2652799e1e61e67f057fbfc3b5db4fb698ff063f708a7bba1a5b1128e922f382b1e06c78cb80e2876f394f2b0c411f52880a2ac39846afa4c77f6821f95d96757996c73d59b2edbb3638b9e01cc32994f111b626e360c7584619f021127224b7899555bb5ba37fbb3d0196d648397c9d8c77c2d32520bfb225037d408ef919cc4b080ae10f4138623caada233c3a63bce519bc5819616c9764dfc8e368bef3a3a0cab39ae6feb6922d3ec28f5483500aa8acd0894bc2a65c47a6bd6dd663a4ad5bf1754cac1770a5fdd2c81a09bd5ba87d7dcee9b7e82cb2c811411fc5c66997535c13a1ddd40f6fc3b24b071c517d707e177160c0c396e96e949aa82b7e08ea375b44a906ddfe114bf6a5d4761a83a7014842d5ec5eb6e13d6a9fac11cf64da28be7d2bbd4b525fa3079f2b9f100342e85403b49bdcbc154c8e6798dfca7f7f50c1a238d5d4797be822b0254afb433331d938209095e606fd3ecae8ffa2578d9701b99653c9e406e8de585d8333be640b694f4c011b173efecbf4c477ba536145120a620b046bd887d828711b7c7e5a02b40717076baa71f54f839a238b69a8669acf29eea469eda4e2f70e989e3f1f016074d82b8ae2f47b9941287ffff592e7fc82e89559ee8640a39ea860097a148dd7ab94b98298ea8bf9bec62485596debb2a94f49e97f18ae3f1353354a624ec52589b5f6b594169bc5e74dd9e533d4866e75c7a12598636e18bc95f662c36445ade67cb86c14b2c0674234fd03ecc590725406dac5454f3d677414f4514a3fc249f51a59b941a39eb1dbeaf115eba8b5c7d89681dee8ef32f8eca7cf2fe053908efb9afd735845ca482b5666d761858f447fc59c9246f2615c14b01446b4ffe25c22dc9e5d118e095b6dccf62a8911d75b54cc5896e4c149ed9076d37e0e0e905eaa88de7fd2ee880e1797922725ef4c24e1387ef296c254416cc1c1b88743a26e28e044d559709fd223e5d21e09c32ebfb70f859b709c3e75b2b8abc341bcacf5690c115b2532168cc599de2709249d6571892d57f1dd76c3932cb9799ab47a3cb8d98c5f6a1e230e7bb1178b45ebb29899865c7049086894837dae7113b0761b66ec2b2ab8582df2b0ec0a828945cd9feca9c70b8882b06155de832a7c60c37e733b86a1a5a9ef86d95b2f2c04e04226f03d5aba1b6145526bc7269d65ee4d0d47d341a186791dd934bfc8777e2c257082fa6033b85ba5fcb1568f16fee7df9f7e71ecfb8045b708782a4f872a797d0b98dbac5750dc671538363bc3c9e94c0abf9b9c65c805dc205ad161ceddfc0fe8673405a6187cab14949ca4e07cd67784baaf85aa1b2ea66df899e6a037ca335de9be32128c2dbeb431e5efebd712cc254986751dffb2eeace731c081f6bbc054728ed4bfb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inspiring Quotes</title>
      <link href="/2021/07/28/Inspiring%20Quotes/"/>
      <url>/2021/07/28/Inspiring%20Quotes/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3a5803baae0aba4cd48f07a292dbf941cc6e9e68d506c6503d889b14d0eb6d33">418fac4f173397084caccc18ab9f089e07699afa44e088ef428d1995e53e30a59d519c6a4de6bd064bf82735b89d8323405e3bf9657f296d285b30c5beeafa6312f6b99cc1f3788e6cc77b926eaa90fc169efea59b2266efe8dac8dd02c546f198ec6e742389028366a8f642cab94a308953304522e25159bf02570c835324d307c66127ab79deeb6d61551699846084d70a09c60c614f98ce920ab08d4380f91e61688185c0c66a7de7c8039cb3a84023f44e271fc75b80d8ccceffa8fe342c24a358dacf35d0ea9432cf36bee823fa3bd22b0eb7cdea564f2b5901b23391157dcd1765f229fdbf25c81e69fe3a5a24c540330f6bab9bdfb9287e9b99afe7d28416488b522333e75d4044ed83bd5d9b0ccc5786750310ba3cd20a1e2a316963f5679f2f1ce79cd7b33c48f4dc1c01b7ba8f28d650d0833f5e1b7fa4b3a531da3671fa87969346c812c61feac1df603cb40d15dd9f682929672d815ebb83e8effc0e625d7c7a688f67508b33bc91d9953fd937827209e71fc45c909820c67d73b3bca4f147e7f2bd51c25eba58cbaa976240396ce1b522dd315f0471516371da65163e037d2135fd37263fb7f11adfb86376af3969132f64ce2905103142c6bed4de52501756e87f34803da8b75ab357632ab0426fe7f25a88fe146a32c5fff695603c4a04fe059778c36a8e21dcbab46f22ea93974487dddd8b63188d127f11dc344db08a56c251de0d54ea5a5e98427c23d01bc461ae5add5d6d22dc04735c85409cc8ececfd6bdcb1cb739f65fd4da095ba8381007086cb1c7eedac8089ee4b3f3fbbf095e27fa3c44e8549e60b8e8f776be06f8c8c139f77f0cd88cd54c0536379ba7bfedfee163de181d40852a0751060ed2c08ea91e91664fd81ccfcf90269df0638e8eb45de55ffb79ac6a0174ca5a7c55d6ca0cd9595b0f18c1a7d291895a4d74033586ddfa633c808033b2d2bef4f3a7d7a142ca166f157f7783eaa6558a0f30ce17c97781b7bb6ed462ae3c9e41ccd223ba75044d9f49918a221635437a868d5dc3cadf4ada21ea974faba5b078758e491d623c4933ce8c652be81b84e3b7a17ccc951e99ca7b21fe451b6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Predecessor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS231n Assignment</title>
      <link href="/2021/07/21/CS231n%20Assignment/"/>
      <url>/2021/07/21/CS231n%20Assignment/</url>
      
        <content type="html"><![CDATA[<p>先吹一波Google Colab，所有操作都可在云上进行，还能白嫖🐕家的GPU；再吹一下Stanford的骨架代码，真的是干净整洁优美，堪称典范。<br /><a href="https://github.com/EIMadrigal/CS231n">My Code</a></p><h2 id="knn">kNN</h2><p>最幼稚的机器学习算法。</p><ol type="1"><li>计算测试集和训练集的距离<br />训练集<code>X_train</code>的shape为<span class="math inline">\((N, D)\)</span>，<code>y_train</code>的shape为<span class="math inline">\((N,)\)</span>，<code>y[i]</code>取值范围<span class="math inline">\([0,C-1]\)</span><br />测试集<code>X_test</code>的shape为<span class="math inline">\((M, D)\)</span>，最终的distance matrix的shape为<span class="math inline">\((M,N)\)</span><br />声明：不能使用类似于<code>np.linalg.norm()</code>这种东西作弊。<br />首先来看看2重循环：第一重遍历测试集，第二重遍历训练集，当然如果你愿意，还可以用第三重遍历dimension去累加距离；<br />再来看看只遍历测试集的单层循环：对于每个测试样例<code>X[i]</code>，减去<code>X_train</code>，通过广播机制得到一个<span class="math inline">\((N, D)\)</span>的差矩阵，做element-wise的平方，按列相加得到<span class="math inline">\((N,)\)</span>，表示测试样例<code>X[i]</code>与每个训练样例的距离，作为距离矩阵的第<span class="math inline">\(i\)</span>行；<br />最后来看看full-vectorized的版本，数学推导见<a href="https://zhuanlan.zhihu.com/p/146076139">NumPy之计算两个矩阵的成对平方欧氏距离</a>，吃饱没事干的同学可以自己推推，我数学太差就溜了。<br /></li><li>根据距离矩阵预测测试集的标签<br />对于每个测试样例<code>X[i]</code>，选k个距离最小的训练样例，将其label（从<code>y_train</code>获得）存入<code>cloest_y</code>中，投票决定最终的预测标签。<br />先用<code>idx=np.argsort(dists[i])[:k]</code>取出前k个训练样例的index，再用<code>y_train[idx]</code>得到对应的k个label，最后用<code>np.argmax(np.bincount(cloest_y))</code>得到最终的预测label。</li></ol><p>kNN效果当然比较拉垮了，在CIFAR-10的子集上分类正确率大概在27%左右。比较令我震惊的是三个计算距离函数耗费的时间，2重循环57s，单层循环41s，fully-vectorized只有0.57s，竟然<strong>降低了100倍</strong>，写出高效的代码对于程序性能有着至关重要的影响，反思下自己写出的junk code，不由得留下了伤心的泪水...</p><p>最后就是用cross-validation确定超参k的取值，就略过了哈。</p><h2 id="linear-multiclass-svm">Linear Multiclass SVM</h2><p>首先要为多分类SVM写一个损失函数，老规矩还是先写一个naive版本<code>svm_loss_naive(W, X, y, reg)</code>：<br />权重矩阵W：<span class="math inline">\((D, C)\)</span><br />minibatch输入X：<span class="math inline">\((N, D)\)</span><br />标签y：<span class="math inline">\((N,)\)</span>，<code>y[i]=c</code>表示<code>X[i]</code>的标签是c，<span class="math inline">\(0 \leq c&lt;c\)</span><br />返回浮点数<code>loss</code>和解析梯度<code>dw</code><br />Multiclass Support Vector Machine loss是这么定义的：<br /><span class="math display">\[L = \frac{1}{N} \sum_i \sum_{j\neq y_i} \left[ \max(0, f(x_i; W)_j - f(x_i; W)_{y_i} + \Delta) \right] + \lambda \sum_k\sum_l W_{k,l}^2\]</span> 看着有点复杂哦！主要有data loss和正则项两部分，对于第<span class="math inline">\(i\)</span>个训练样本，data loss为：<br /><span class="math display">\[L_i = \sum_{j\neq y_i} \max(0, s_j - s_{y_i} + \Delta),s_j = f(x_i, W)_j\]</span> 什么意思呢？<span class="math inline">\(s\)</span>是第<span class="math inline">\(i\)</span>个训练样本的得分向量<span class="math inline">\((C,)\)</span>，<span class="math inline">\(s_{y_i}\)</span>表示正确标签的得分，<span class="math inline">\(s_j\)</span>表示其他类的得分。不妨看看什么时候损失为0呢？稍作变形即有：当<span class="math inline">\(s_{y_i}-s_j&gt;\Delta\)</span>时，第<span class="math inline">\(j\)</span>类损失为0，说人话就是只有当正确类的得分减去其他类的得分大于某个间隔<span class="math inline">\(\Delta\)</span>时才不会累积损失，否则就累加损失（必然为正数），这就是大名鼎鼎的<strong>Hinge Loss</strong>。</p><p>如果<span class="math inline">\(f\)</span>用的是linear score function，进一步有： <span class="math display">\[L_i = \sum_{j\neq y_i} \max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)\]</span> 其中，<span class="math inline">\(w_j\)</span>表示W的第<span class="math inline">\(j\)</span>列。<br />至此，naive版本的<code>loss</code>实现就不必废话了。接着来求<code>dW</code>，老规矩，还是先研究单个样本。</p><p>如果你的数学还行，下面的梯度推导可以略过： <span class="math display">\[L_i = max(0,w_1^T x_i - w_{y_i}^T x_i + \Delta)+max(0,w_2^T x_i - w_{y_i}^T x_i + \Delta)+...+max(0,w_C^T x_i - w_{y_i}^T x_i + \Delta)\]</span> 共有<span class="math inline">\(C-1\)</span>项，因为<span class="math inline">\(j=y_i\)</span>那项不算。另，只有在<span class="math inline">\(w_j^T x_i - w_{y_i}^T x_i + \Delta&gt;0\)</span>时第<span class="math inline">\(j\)</span>项的梯度不为0。</p><ol type="1"><li>对<span class="math inline">\(w_{y_i}\)</span>的梯度<br />每项都有，并且都是0或<span class="math inline">\(-x_i\)</span>，因此只要看几项大于0，梯度就是几倍的<span class="math inline">\(-x_i\)</span>，正式点就是： <span class="math display">\[\nabla_{w_{y_i}} L_i = - \left( \sum_{j\neq y_i} \mathbb{1}(w_j^Tx_i - w_{y_i}^Tx_i + \Delta &gt; 0) \right) x_i\]</span></li><li>对<span class="math inline">\(w_j\)</span>的梯度<br />只有第<span class="math inline">\(j\)</span>项有，0或<span class="math inline">\(x_i\)</span>，正式点就是： <span class="math display">\[\nabla_{w_j} L_i = \mathbb{1}(w_j^Tx_i - w_{y_i}^Tx_i + \Delta &gt; 0) x_i\]</span></li></ol><p>naive版本的<code>dW[:,j]</code>和<code>dW[:,y[i]]</code>就2重循环按部就班更新即可，别忘了除以<span class="math inline">\(N\)</span>和正则项梯度。</p><p>接着来实现<code>svm_loss_vectorized(W, X, y, reg)</code>：</p><ol type="1"><li>loss<br />首先求得整个训练集的得分矩阵<code>scores</code>，shape为<span class="math inline">\((N,C)\)</span>，每一行表示一个样例的得分。正确类得分向量<code>correct_class_score</code>可用<code>scores[np.arange(num_train), y]</code>得到，shape为<span class="math inline">\((N,)\)</span>，注意这里不能用<code>scores[:, y]</code>，简单试验下：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">y = np.array([<span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(X[np.arange(<span class="number">2</span>), y])  <span class="comment"># [3,4]</span></span><br><span class="line"><span class="built_in">print</span>(X[:, y])  <span class="comment"># [[3,2],[5,4]]</span></span><br></pre></td></tr></table></figure><p>下来到了最关键的<code>margins</code>矩阵，该矩阵和<code>scores</code>矩阵shape相同<span class="math inline">\((N,C)\)</span>，第<span class="math inline">\(i\)</span>行表示第<span class="math inline">\(i\)</span>个训练样本的margin即<span class="math inline">\(max(0,s_j - s_{y_i} + \Delta)\)</span>，在每一行第<span class="math inline">\(y_i\)</span>个位置上应当设置为0，其余位置按照公式即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margins = np.maximum(<span class="number">0</span>, scores - correct_class_score[:, np.newaxis] + <span class="number">1</span>)</span><br><span class="line">margins[np.arange(num_train), y] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>需要注意：<code>correct_class_score</code>是一个<span class="math inline">\((N,)\)</span>的向量，如果直接<code>scores-correct_class_score</code>就会报错，广播机制从最后一个维度开始比对，只有相等或者其中某个为1才行，因此用<code>np.newaxis</code>将<code>correct_class_score</code>的shape变为<span class="math inline">\((N,1)\)</span>；还有就是<code>np.max()</code>和<code>np.maximum()</code>的区别，<code>np.max()</code>和<code>np.amax(a, axis=None, ...)</code>等价，返回数组的最大值，<code>np.maximum(x1, x2, out=None, ...)</code>返回element-wise的较大值。</p><ol start="2" type="1"><li>梯度<br />这里也稍微有点tricky，根据naive版本对梯度的讨论：对<span class="math inline">\(w_j\)</span>的梯度需要知道margin的正负，对<span class="math inline">\(w_{y_i}\)</span>的梯度需要知道<strong>有几项大于0</strong>。怎么借助<code>margins</code>矩阵统计每一行大于0的项数呢？无聊的程序员先将矩阵中大于0的项都设为1，然后按列相加即可：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">margins[margins &gt; <span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">num_to_loss = np.<span class="built_in">sum</span>(margins, axis=<span class="number">1</span>)  <span class="comment"># (N,)</span></span><br><span class="line">margins[np.arange(num_train, y)] = -num_to_loss</span><br></pre></td></tr></table></figure><p>对单个样本<span class="math inline">\(i\)</span>来说，其对<code>dW</code>的贡献要么是在第<span class="math inline">\(j\)</span>列（即第<span class="math inline">\(j\)</span>个类）加上<span class="math inline">\(x_i\)</span>，要么在第<span class="math inline">\(y_i\)</span>列加上<span class="math inline">\(-kx_i\)</span>，<span class="math inline">\(k\)</span>为<code>margins[i]</code>中大于0的元素个数，即<code>num_to_loss[i]</code>，整个训练集对<code>dW</code>的更新即是在累加单个样本对<code>dW</code>每一列（每个类）的影响。对第<span class="math inline">\(j\)</span>列，其更新即为每个训练样本对该类贡献的线性组合，组合系数取决于该样本的标签以及是否满足指示函数，即为<code>margins</code>的第<span class="math inline">\(j\)</span>列，取值范围<span class="math inline">\(\{0,1,-k\}\)</span>，0表示该样本对第<span class="math inline">\(j\)</span>个类的梯度没有贡献（该样本标签不是<span class="math inline">\(j\)</span>且不满足指示函数），1表示贡献了<span class="math inline">\(x_i\)</span>（该样本标签不是<span class="math inline">\(j\)</span>且满足指示函数），<span class="math inline">\(-k\)</span>表示贡献了<span class="math inline">\(-kx_i\)</span>（该样本的标签就是<span class="math inline">\(j\)</span>），因此：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dW = np.dot(X.T, margins) / num_train + <span class="number">2</span> * reg * W</span><br></pre></td></tr></table></figure><p>可以从矩阵维度相容的角度验证。</p><h2 id="softmax">Softmax</h2><p>先用循环实现一个<code>softmax_loss_naive(W, X, y, reg)</code>，输入的shape和SVM相同。<br />softmax分类器不再将<span class="math inline">\(f(x_i;W)\)</span>看做每个类的得分，而是希望输出normalized class probabilities，最终选一个概率最大的类作为预测，<strong>softmax函数</strong>就能将<span class="math inline">\(f(x_i;W)\)</span>映射到<span class="math inline">\([0,1]\)</span>且满足概率的性质： <span class="math display">\[P(y_i \mid x_i; W) = \frac{e^{f_{y_i}}}{\sum_j e^{f_j} }\]</span> 从预测函数可以看到：softmax是把<span class="math inline">\(f(x_i;W)\)</span>看作unnormalized log probabilities，因此对<span class="math inline">\(f(x_i;W)\)</span>先指数再归一化得到每个类的概率。</p><p>再来看softmax的损失函数： <span class="math display">\[L_i = -\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right) \hspace{0.1in} \text{or equivalently} \hspace{0.1in} L_i = -f_{y_i} + \log\sum_j e^{f_j}\]</span> 从直觉上说：属于正确类<span class="math inline">\(y_i\)</span>的概率（括号里的分式）越高，损失应该越小，这就是大名鼎鼎的<strong>cross-entropy loss</strong>，衡量了真实分布<span class="math inline">\(p\)</span>和预测分布<span class="math inline">\(q\)</span>之间的差距： <span class="math display">\[H(p,q) = - \sum_x p(x) \log q(x)= H(p) + D_{KL}(p||q)\]</span> 具体到softmax： <span class="math display">\[q=\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} },p = [0, \ldots 1, \ldots, 0]\]</span> 其中，<span class="math inline">\(p\)</span>在第<span class="math inline">\(y_i\)</span>个位置上为1。<br />由于<span class="math inline">\(H(p)=0\)</span>，因此其实是在最小化<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>的KL散度，即希望预测结果<span class="math inline">\(q\)</span>尽量向<span class="math inline">\(p\)</span>靠近。</p><p>从概率的角度出发看损失函数，我们是在最小化正确类<span class="math inline">\(y_i\)</span>的负对数似然，本质上就是在做一个极大似然估计。</p><p>看完理论，还要考虑一些现实问题。比如数值稳定性，由于指数的原因可能会导致overflow或者underflow，因此做一个简单的等价变换： <span class="math display">\[\frac{e^{f_{y_i}}}{\sum_j e^{f_j}}= \frac{Ce^{f_{y_i}}}{C\sum_j e^{f_j}}= \frac{e^{f_{y_i} + \log C}}{\sum_j e^{f_j + \log C}}\]</span> 一般选<span class="math inline">\(\log C = -\max_j f_j\)</span>，这个变换不会改变预测函数或者损失函数，只是将得分做了平移。</p><p>至此，naive版本的loss就基本有了，接着看看梯度咋求。先稍稍展开康康： <span class="math display">\[L_i=-f_{y_i} + \log\sum_j e^{f_j}=-w_{y_i}^Tx_i+log\sum_je^{w_j^Tx_i}\]</span> 其中，<span class="math inline">\(w_j\)</span>表示W的第<span class="math inline">\(j\)</span>列。<br />然后使用我们的小学数学知识去求偏导： <span class="math display">\[\nabla_{w_{y_i}} L_i =(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j}}-1)x_i \\\nabla_{w_j} L_i = \frac{e^{f_{j}}}{ \sum_j e^{f_j}}x_i\]</span> 记<code>p = np.exp(scores) / np.sum(np.exp(scores))</code>，shape为<span class="math inline">\((C,)\)</span>，表示样本<span class="math inline">\(i\)</span>属于每个类的概率。<br />所以<code>dW</code>的第<code>y[i]</code>列更新即为<code>(p[y[i]] - 1) * X[i]</code>，其他列更新为<code>p[j] * X[i]</code>。</p><p>接着看下vectorized版本，<code>scores</code>的shape变为了<span class="math inline">\((N,C)\)</span>，首先处理数值稳定性问题，每一行都减去该行的最大值（注意<code>keepdim=True</code>）；接着求出概率矩阵<code>p</code>，shape与<code>scores</code>相同，那么loss为：<br /><code>loss = np.sum(-np.log(p[np.arange(X.shape[0]), y])) / X.shape[0]</code><br />与SVM类似，<code>dW</code>的每一列（每个类）是由每个训练样本影响的线性组合决定的，组合系数取决于该训练样例的标签，比如对于<code>dW</code>的第<span class="math inline">\(j\)</span>个类来说，如果某个样例的标签恰好是<span class="math inline">\(j\)</span>，那么其对梯度的贡献就是<code>p[j]-1</code>，否则系数就是<code>p[j]</code>。因此只要将概率矩阵<code>p</code>中所有正确标签的值减1即得到系数矩阵，进而得到<code>dW</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p[np.arange(X.shape[<span class="number">0</span>]), y] = p[np.arange(X.shape[<span class="number">0</span>]), y] - <span class="number">1</span></span><br><span class="line">dW = np.dot(X.T, p)</span><br></pre></td></tr></table></figure><p>同样可以用维度相容去check。</p><h2 id="neural-network">Neural Network</h2><p>这是一个两层的全连接神经网络，架构如下：<br />输入<span class="math inline">\((N,D)\)</span>-&gt;全连接层1-&gt;ReLU-&gt;全连接层2（输出每个类的得分）-&gt;softmax<br />参数们的shape为：<span class="math inline">\(X(N,D),W1(D,H),b1(H,),W2(H,C),b2(C,)\)</span></p><p>第一步Forward Pass，根据输入X和权值W计算<span class="math inline">\(scores(N,C)\)</span>，然后计算softmax loss；<br />第二步Backward Pass，需要计算loss对于参数们的梯度，根据网络结构： <span class="math display">\[h=XW1+b1\\o=ReLU(h)\\s=oW2+b2\\L=\sum_i(-s_{y_i}+log\sum_j e^{s_j})\]</span> 根据链式法则+维度相容： <span class="math display">\[\nabla_{w_2} L =o^T \nabla_{s} L\\\nabla_{b_2} L =(\nabla_{s} L)^T(\nabla_{b_2} s)=(C,N)(N,1)=(C,N)(all\ 1\ col)\\\nabla_{w_1} L =X^T \nabla_{s} L\nabla_{h} s\\\nabla_{b_1} L =\nabla_{h} s (\nabla_{s} L)^T\nabla_{b_1} h=(H,C)(C,N)(N,1)=(H,C)(C,N)(all\ 1\ col)\]</span> 可以看出：关键在于求出<span class="math inline">\(\nabla_{s} L\)</span>，在对softmax的讨论中可知，对于第<span class="math inline">\(y_i\)</span>列导数为<code>p[y[i]]-1</code>，对其他列为<code>p[j]</code>，因此该偏导为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d2 = p</span><br><span class="line">d2[np.arange(X.shape[<span class="number">0</span>]), y] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>另外对于<span class="math inline">\(W_1,b_1\)</span>，还需要<span class="math inline">\(\nabla_{h} s\)</span>：这玩意在<span class="math inline">\(h&gt;0\)</span>就是<span class="math inline">\(W_2^T\)</span>，否则就是0。因此<span class="math inline">\(\nabla_{s} L\nabla_{h} s\)</span>可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1 = d2.dot(W2.T) * (h &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="image-features">Image Features</h2><p>之前的样例都是直接用raw pixel，加上都是线性模型，效果拉跨太正常了。这里用的人工feature包括HOG(Histogram of Oriented Gradients)和color histogram，HOG捕捉texture（纹理变化？）信息，color histogram捕捉颜色信息，两者互相辅助。</p><h2 id="fully-connected-neural-network">Fully-connected Neural Network</h2><p>我好菜啊！！很早就写完代码了，gradient check也过了，但是需要过拟合50张图片的时候一直不太对，调了几下学习率，我看train acc只有0.14左右，loss曲线波动也很大： <img src="https://img2020.cnblogs.com/blog/1260581/202109/1260581-20210912161403754-1113281186.png" alt="image" /> 因为最后要100%的train acc嘛，我看差的挺远的，就开始怀疑是网络哪里写错了，就没管超参数，检查代码检查了好几天tmd，深度学习debug还真是无从下手...后来跑去看了下别人的东西，发现原因竟然是不会调参(T^T)。</p><p>仔细看下，这里还是很明显的，20个epoch训练损失才下降了一点点，说明学习率太小了。 <img src="https://img2020.cnblogs.com/blog/1260581/202109/1260581-20210912162656860-43278840.png" alt="image" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同辈压力</title>
      <link href="/2021/07/17/%E5%90%8C%E8%BE%88%E5%8E%8B%E5%8A%9B/"/>
      <url>/2021/07/17/%E5%90%8C%E8%BE%88%E5%8E%8B%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>见过更广的天空，才能愈发意识到自身的渺小，并保持谦逊的态度。</p><p>中国或者世界上不论做任何事情，牛逼的人都太多太多了，不论是天赋型亦或是刻苦型，因此不可能超过大部分人，只要自己学到新东西，过得幸福充实就可以了，归宿也没必要苛求，尽力够到或者接近自己的天花板也就无憾了！</p><p>很多同龄人的经历会让你惊掉下巴。向更优秀的人学习！</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode解题报告</title>
      <link href="/2021/07/16/LeetCode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
      <url>/2021/07/16/LeetCode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="寻找两个正序数组的中位数">4 寻找两个正序数组的中位数</h2><p>最直观的做法就是合并2个有序数组，根据奇偶返回中位数，时间空间复杂度均为<span class="math inline">\(O(m+n)\)</span>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        sortedArray = [<span class="number">0</span>] * (m + n)</span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">                sortedArray[k] = nums1[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sortedArray[k] = nums2[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m:</span><br><span class="line">            sortedArray[k] = nums1[i]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; n:</span><br><span class="line">            sortedArray[k] = nums2[j]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (m + n) % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> sortedArray[(m + n) // <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (sortedArray[(m + n) // <span class="number">2</span> - <span class="number">1</span>] + sortedArray[(m + n) // <span class="number">2</span>]) / <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>空间的改进可以避免开辟新数组而采用2个指针，时间<span class="math inline">\(O(m+n)\)</span>，空间<span class="math inline">\(O(1)\)</span>： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        i = j = cnt = <span class="number">0</span></span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cnt &lt;= (m + n) // <span class="number">2</span>:</span><br><span class="line">            left = right</span><br><span class="line">            <span class="keyword">if</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">                <span class="keyword">if</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">                    right = nums1[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = nums2[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == m:</span><br><span class="line">                right = nums2[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = nums1[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (m + n) % <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (left + right) / <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>要做到log级别的复杂度，需要使用<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">二分法</a>。</p><h2 id="正则表达式匹配">10 正则表达式匹配</h2><p>判断字符串<code>s</code>是否匹配正则表达式<code>p</code>，<code>p</code>仅包含<code>.</code>和<code>*</code>。<code>.</code>匹配任意单个字符，<code>*</code>匹配0或多个前一个字符。题目保证不会出现连续的<code>*</code>。</p><p>可以发现此题的难点在于<code>*</code>，<code>a*</code>可以表示<code>"", a, aa, aaa</code>，<code>.*</code>可以表示<code>"", ., .., ...</code>。第一次看到这个题不一定能想到DP，甚至暴力做法也不知道从哪入手。我认为核心在于先不要考虑<code>*</code>到底需要匹配几次，而是考虑<code>*</code>到底是否需要匹配，即匹配0次/匹配1次的问题，多次匹配不过是将匹配1次重复而已。</p><p>例如<code>s=aa,p=a*</code>，从匹配0次/匹配1次的角度出发，暴搜的过程可以表示为一棵二叉树，左孩子表示匹配1次，右孩子表示匹配0次，开始时指针位置<code>(0,0)</code>，此时我们发现<code>s[i] == p[j] &amp;&amp; p[j + 1] == *</code>，意味着可以选择匹配0次或1次a：如果0次，意味着放弃目前遇到的这个<code>*</code>，那么只能<code>i不变, j = j + 2</code>，j越界匹配结束返回False；如果1次，意味着<code>s[i]</code>匹配成功，那么可以继续使用目前的这个<code>*</code>匹配<code>s[i + 1], j不变</code>。直到将<code>s</code>的所有字符匹配完毕，时间复杂度<span class="math inline">\(O(2^n)\)</span>。</p><p>另外一个例子<code>s=aab,p=c*a*b</code>，从<code>(i,j)</code>开始，先来看看可能使得匹配成功的情形：</p><ul><li><p><code>p[j + 1] == *</code>：无论当前字符是否匹配都要继续，因为<code>*</code>可以匹配0次，保留了成功的可能。此时可以选择匹配0次/匹配1次，如果选择匹配0次，意味着抛弃目前的<code>*</code>转移到<code>(i,j+2)</code>；如果选择匹配1次，意味着当前字符必须匹配且转移到<code>(i+1,j)</code>。</p></li><li><p>如果<code>p[j + 1] != *</code>，那么当前字符必须匹配即<code>s[i] == p[j] || p[j] == .</code>，否则无法继续进行返回False。如果当前匹配，那么继续判断<code>(i+1,j+1)</code>。</p></li></ul><p>如果上述2种成功的条件均不满足，那么只能返回False。</p><p>终止条件则是：</p><ul><li><code>i &gt;= len(s) &amp;&amp; j &gt;= len(p)</code>意味着字符串的所有字符匹配整个模式，返回True</li><li><code>i is ok &amp;&amp; j &gt;= len(p)</code>意味着<code>s</code>中仍然存在未被匹配的字符但模式已经耗尽，返回False</li><li><code>i &gt;= len(s) &amp;&amp; j is ok</code>意味着<code>s</code>中所有字符均匹配完毕但是模式仍未耗尽，此时不能判断成功与否，需要继续递归。</li></ul><p>即递归函数<code>dfs(i,j)</code>返回<code>s[i:]</code>与<code>p[j:]</code>是否完全匹配，暴力做法存在着很多重复计算，因此用哈希表存储已经求得的结果提高效率。</p><p><a href="https://www.youtube.com/watch?v=HAA8mgxlov8">Top-Down Memoization - Leetcode 10</a>讲得比较透彻。</p><h2 id="同时运行n台电脑的最长时间">2141 同时运行N台电脑的最长时间</h2><p>有n台电脑和一个电池数组<code>batteries</code>，第i个电池可以让一台电脑运行<code>batteries[i]</code>分钟，求n台电脑同时运行多久。</p><p>我第一次看到的时候就想到了优先队列，时间最久即每次选n个最大的电池<code>a=[]</code>，然后可以支撑<code>min(a)</code>分钟，直到<code>batteries</code>中正数个数小于n停止。</p><p>但发现连样例都过不了，比如<code>n=2,batteries=[3,3,3]</code>，第一次选2个最大的支撑3min，<code>batteries=[0,0,3]</code>，无法同时继续，但答案是错的。贪心策略不太对，每次选最大的n个是对的，但是不一定要支撑<code>min(a)</code>分钟。</p><p>最后发现二分答案是反着思考的：虽然求的是最长时间，先假设n台电脑可以同时运行t分钟，一台电池最多能供电t分钟，所有电池的可供电时间总和为S = min(sum(batteries), t*len(batteries))，检查这些时间是否能给n台电脑供电S / t &gt;= n</p><p><a href="https://leetcode-cn.com/problems/maximum-running-time-of-n-computers/solution/er-fen-da-an-de-checkhan-shu-de-si-kao-f-g8no/">这张图很形象</a> 对于当前枚举的时间P，共有k台电脑。需要看电池能否填满该矩阵，同一行不能有相同颜色。</p><p>对于大于等于P的电池，只能利用P，让其一直供应一台电脑即可，即填充一列，剩余电量只能丢弃，因为该电池不能同时供应2台电脑。对于小于P的，让其供应一台电脑直到电量耗尽，注意这些小于P的电池不可能出现同时供应2台电脑的情况，对于小于P的电池，首先拿一个填充一列，当然填不满，接着拿第二个继续填充，如果该列满了就填下一列，以此类推，由于小于P的电池最多填充P - 1行，因此不会出现相同颜色。（最极端的情况就是：某种颜色的电量为1，只能填1行，第二种颜色最多P-1行，因此下一列不会重复，如果第二种颜色可以填P行，那么下一列才会重复）。</p><p>假设共m个电池, 大于等于P的有a个, 小于P的有m-a个. 由于大于等于P的只需要撑a台电脑, 因此问题转变为小于P的m-a个电池能否撑n-a台, 即sum(m-a) &gt;= (n-a) * P. 稍微转化下: sum(m-a) + a * P &gt;= n * P.</p><p>因此判断P是否合法只需要求所有电池里：如果电量大于等于P，sum += P，否则将剩余所有的电量小于P的电量全部加到sum起来，判断sum是否大于等于P * K。</p><p>二分法一般的题目就是求最大的最小或最小的最大，假设要求的是ans，那么从ans=0开始判断是否满足要求，然后判断ans=1,2,...直到上界。例如本题就是求最小里面的最大，比如0,1,2,...都满足要求，需要在其中挑一个最大的。</p><h2 id="section">767</h2><p>给定字符串，重排其中的字符使得任意两个相邻位置的字母不同。 样例：s="aab"，输出"aba" 最开始的想法是贪心+双指针，指针i从前向后遍历，指针j从i+1开始，如果s[i]==s[j]，j不断向后遍历找到第一个与s[i]不同的字母s[k]，将s[k]与s[j]交换。WA在了"baaba"，期待"ababa"，输出""，所以这种贪心策略显然是错的。</p><p>接着就想到需要考虑字符的出现频率，先按频率高低排序再去按照上述贪心，WA在了"aabbcc"，期待"abacbc"，输出""，很显然这种贪心策略本身就是错的。</p><p>接着就想到先安排出现次数最多的，如果当前要安排的与前一个字符相同，就选择出现次数第二多的，这样交替下去，可以写出如下代码： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reorganizeString(self, s: str) -&gt; str:</span><br><span class="line">        if len(s) == 1:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        from collections import Counter</span><br><span class="line">        dic = Counter(s)</span><br><span class="line"></span><br><span class="line">        ans = &quot;&quot;</span><br><span class="line">        prev = &quot;&quot;</span><br><span class="line">        for i in range(0, len(s)):</span><br><span class="line">            cnts = list(dic.items())</span><br><span class="line">            cnts = sorted(cnts, key=lambda x:x[1], reverse=True)</span><br><span class="line">            if prev == cnts[0][0]:</span><br><span class="line">                if len(cnts) &lt;= 1 or cnts[1][1] == 0:</span><br><span class="line">                    return &quot;&quot;</span><br><span class="line">                ans += cnts[1][0]</span><br><span class="line">                dic[cnts[1][0]] -= 1</span><br><span class="line">                prev = cnts[1][0]</span><br><span class="line">            else:</span><br><span class="line">                ans += cnts[0][0]</span><br><span class="line">                dic[cnts[0][0]] -= 1</span><br><span class="line">                prev = cnts[0][0]</span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></table></figure> 时间复杂度<span class="math inline">\(O(n^2lgn)\)</span>，空间<span class="math inline">\(O(n)\)</span>。</p><p>因为涉及到出现次数最多的问题，可以考虑max heap。每次迭代时，从堆里弹出堆顶元素（意味着下次迭代该元素不会考虑）加入res，如果上一次迭代加入res的元素还有剩余，就将其重新加入heap，意味着下次迭代需要考虑该元素。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reorganizeString(self, s: str) -&gt; str:</span><br><span class="line">        ans, cnt = [], Counter(s)  # decent order</span><br><span class="line">        max_heap = [(-value, key) for key, value in cnt.items()]</span><br><span class="line">        heapq.heapify(max_heap)</span><br><span class="line">        prev_ch, prev_cnt = &#x27;&#x27;, 0</span><br><span class="line">        while max_heap:</span><br><span class="line">            cnt, ch = heapq.heappop(max_heap)</span><br><span class="line">            ans.append(ch)</span><br><span class="line">            if prev_cnt &lt; 0:</span><br><span class="line">                heapq.heappush(max_heap, (prev_cnt, prev_ch))</span><br><span class="line">            cnt += 1</span><br><span class="line">            prev_ch, prev_cnt = ch, cnt</span><br><span class="line">        if len(s) != len(ans):</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        return &#x27;&#x27;.join(ans)</span><br></pre></td></tr></table></figure> 时间复杂度<span class="math inline">\(O(n)\)</span>，空间<span class="math inline">\(O(n)\)</span>。</p><p><a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">题目链接</a></p><h2 id="题意">题意</h2><p>给定一个单链表，删除和为0的连续结点序列，直到最终链表中没有和为0的连续结点序列。 样例：head = [1,2,3,-3,-2]，输出[1]</p><h2 id="分析">分析</h2><p>由于链表头结点可能会被删除，因此首先创建dummy结点。一个比较直观的想法就是记录前缀和，依次遍历链表，遇到出现过的前缀和也就意味着出现了和为0的序列，就删除两次相同前缀和中间的序列。因此需要一个hashtable记录前缀和出现的位置，手动走一个简单样例吧： dummy设为<code>(0,head)</code>，hashtable初始包含<code>&#123;0:dummy&#125;</code>，避免[1,-1]这种情况。</p><ol type="1"><li><code>cur=p(1),sum=1,hash=&#123;0:dummy,1:p(1)&#125;</code></li><li><code>cur=p(2),sum=3,hash=&#123;0:dummy,1:p(1),3:p(2)&#125;</code></li><li><code>cur=p(3),sum=6,hash=&#123;0:dummy,1:p(1),3:p(2),6:p(3)&#125;</code></li><li><code>cur=p(-3),sum=3</code>：此时hash返回p(2)，因此就让p(2).next指向cur.next，相当于删除了[3,-3]，<code>hash=&#123;0:dummy,1:p(1),3:p(2),6:p(3)&#125;</code></li><li><code>cur=p(-2),sum=1</code>：此时hash返回p(1)，因此让p(1).next指向cur.next，相当于删除了[2,-2]，<code>hash=&#123;0:dummy,1:p(1),3:p(2),6:p(3)&#125;</code></li></ol><p>大概可以写出这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        cur = head</span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        hashtable = &#123;<span class="number">0</span>:dummy&#125;</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            prefix_sum += cur.val</span><br><span class="line">            p = hashtable.get(prefix_sum)</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                p.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashtable[prefix_sum] = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>交上去WA了，问题出在哪呢？ 走一遍出错的样例：输入[1,3,2,-3,-2,5,5,-5,1]，期待[1,5,1]，输出[1,5,5,-5,1]</p><ol type="1"><li><code>cur=p(1),sum=1,hash=&#123;0:dummy,1:p(1)&#125;</code></li><li><code>cur=p(3),sum=4,hash=&#123;0:dummy,1:p(1),4:p(3)&#125;</code></li><li><code>cur=p(2),sum=6,hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2)&#125;</code></li><li><code>cur=p(-3),sum=3,hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2),3:p(-3)&#125;</code></li><li><code>cur=p(-2),sum=1</code>：此时hash返回p(1)，让p(1).next指向p(-2).next，链表变为了[1,5,5,-5,1]，<code>hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2),3:p(-3)&#125;</code></li><li><code>cur=p(5),sum=6</code>：此时hash返回p(2)，但此时p(2)已经删除，因此让p(2).next指向p(5).next肯定是错的。</li></ol><p>至此应该可以看出问题了：在删除改变链表指针的同时，hashtable并没有做相应的同步删掉对应的元素，所以每当出现重复前缀和时只要删掉hashtable中两次前缀和之间的项即可，可以借助<code>OrderedDict()</code>实现，按照插入顺序即链表顺序有序：</p><ol type="1"><li><code>cur=p(-3),sum=3,hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2),3:p(-3)&#125;</code></li><li><code>cur=p(-2),sum=1</code>：此时hash(1)返回p(1)，删除后为<code>hash=&#123;0:dummy,1:p(1)</code></li><li><code>cur=p(5),sum=6</code>：此时hash返回<code>None</code>，符合预期，继续迭代即可。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        cur = head</span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        hashtable = OrderedDict(&#123;<span class="number">0</span>:dummy&#125;)</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            prefix_sum += cur.val</span><br><span class="line">            prev = hashtable.get(prefix_sum, cur)</span><br><span class="line">            <span class="keyword">while</span> prefix_sum <span class="keyword">in</span> hashtable:</span><br><span class="line">                hashtable.popitem()</span><br><span class="line">            hashtable[prefix_sum] = prev</span><br><span class="line">            prev.<span class="built_in">next</span> = cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>Two-pass： 上述做法的hashtable记录的是第一次出现前缀和的位置。现在换一种思路：首先遍历一次链表，hashtable记录<strong>最后一次</strong>出现前缀和的位置，第二次遍历链表设置相应的指针到最后一次前缀和的位置，这样即使第一次前缀和位置被删除，指针也会相应地跳过：</p><ol type="1"><li>第一次遍历后：<code>hash=&#123;0:dummy,1:p(-2),4:p(3),6:p(-5),3:p(-3),11:p(5),7:p(1)&#125;</code></li><li>第二次遍历：<code>dummy.next=hash[0].next,p(1).next=hash[1].next=p(5),p(5).next=hash[6].next=p(1),p(1).next=hash[7].next=null</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        hashtable = &#123;<span class="number">0</span>:dummy&#125;</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            prefix_sum += head.val</span><br><span class="line">            hashtable[prefix_sum] = head</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        head = dummy</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            prefix_sum += head.val</span><br><span class="line">            head.<span class="built_in">next</span> = hashtable[prefix_sum].<span class="built_in">next</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>时间复杂度<span class="math inline">\(O(n)\)</span>，空间复杂度<span class="math inline">\(O(n)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Research Proposal</title>
      <link href="/2021/07/15/Research%20Proposal/"/>
      <url>/2021/07/15/Research%20Proposal/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="696ed58eae0f2b3548e6c11ea514054278695555b2e0095221b7b3b4478d1ac3">418fac4f173397084caccc18ab9f089e90c7a29408af94da76702e54e165326b535cb6030fef10a1330e7467b6091dc94f629e685a2ef1943734ecccc7f55dd2a44ac6d2e6f417476edabbefaee612452f05abcd8d19bea7c9729ba0c4aa62aa9a27ca9c18dae29b4da89b62a217255c7b476dfc77a9b7c6bf02ecf0ea7da4772e1020d111e8479595f3c3d709e9256f2ce26b8e8a3879ffda9c080562f8ae751c8afbf92c0709004eb31c21db3b7b53c14b7781819ff07d75e0868e96920de25eb80de2740d4b159eb09ba09f993abf2b105bf8dcf03c91a3155ba7fd445c00ed68f1f71a6acc23c5507fffaa2bf56431e5641387ffff5ec365efd202c32b3cd296a801c676c92b3c24a337f301e5f2a48106a347fb58052b021c536a8f9a1dfb4e0f33e3d78912db7e7cf65b1bea2d80c55ded1ea36e2d299b19fbaa32f8d4b658d1ce0b90341bce2d48d40289f173c72d5194e7dbdacfe18c0d7194c6c9029f049cfd7b5a14330306dc915ebf27b2e4a41e799b077fcc262da48977f7c02a70d669c7c774053dabae79f6ea34a206cc15b7f72b9c842e8c6d110df4229d2c07d8f3ba96c278619dc5e747be7f7a959f04d19f4b1aa46fbbcf83f5cc2eb48b07c2a3de383c384e64ea067b82ca177eb7b18386396c44b21768c96018be28b12e5861fcbf62a8b70e35f522cbc8b067d79260bcfb78f2916e9d66f80262a05f8c99717849518483a41bd022798e167929dc8b193fd61912ecaa1a1ec19cd50e226b521eb10d7861e225c711f9bdbc6c4baac3217668ab4058c28142fdbb6f86b647247022b3f005c7496c479ee0f92e3d834edc7bf0ee4fecd8735bd4cc6c9edad70eeb716e1e23ef6a97157bd2d2a7a698bb7a4979f1f371551fc93f7f1b8c3bfab92dea490e66b3ea30a8ccf580af2124091c0a264eef39680bb02eef2a43433214f9ce997b340a56af81eab21696a030baffe343ec42b1fb05b724f40dabe80b21e5b17a35545fb2c09269b129410b456feb4722e83abcbeafb8347273a6fcc894f97a9687b7cb28a5c02e79cfab0532bc93cdac46c69c322b52d3901539f44ee4de4a31a575052542455ac3edbc24103a8c1e1a1815ecfae6873546a4936bb033344d84655f717da415aa14b8bbfd5bca3bea10609e5ba68f916a164b33191088bd15dd9e22ab7cba8220ac597aaba55444c2231bfeec10650fea0fe33f2d1fa8ce63e35cb4779c30188920cca4ffb9d7040773ad58f994ed480ec72404a1f6e1aec47c6b431e7e6cfa73a0c81f376010ed7183e3d1f1fc4c32a7382720c6441ca027f04995c657b88a51a0fe36626afd7e5af2b0e57bbc910b8ea7b0c60ef8d8569caccb707cc744c824325e8a1f3d931dd92e30003d8f12fac3506b81f0ffa35db83687c885e4711a8e4ad536cfd3b16959ba35c36db8baec037f78ce127d48e05d3a989121119fabd923f3be596bded462683c759009bf20bb4bc2d81e975cc38fdbb9f90df5c5fef15a7b61af7637afe643d38a0c799abf98eeac4cb385c7d206aa375bfc8514ab9a4f96763dace41030289f2b9806f167080289cc4c295b642911349260f682f94c61034a39abfc8b550379fc0fb00817828434953da8b4db5a24537dd5e9f10e5d666888457f3116f94c7e75d00e217fcc2993ca0cbef9d05a419b60efda542d3b7e00f0220ff4947532a1a23d99ce0063677d6a790381b0ab94a7c28ca6dc172a377e3df3ff5b9737cea001d1a772bdc5a7ba34ce0d125eef6babc521aaad7cdbff6f3f10efaf8c00afccf1a3609030e31116d0c447f15c6763c1eaf28a5880b0bc3c0f54cf60bc096aaef3fb973068e90c5e6cf138ab45a365495ffdbb675407e6413290cbaa8c2a5a4dc32808e380702d9be152bf6a5d1ab53f718c739f5013e63eabdda8c34f922df1c68c381533b1defc6b7ebd314c2c0eac6cab7fe0d81162d923565869f025142772a9a14eac594823e2618811e84584bed5f1ed64ff6ff0505f41a5ac89d5d6473a3b06d380e64cc619a62eb52533f783f669d43e1668dfa2b13d9acac5299379fa6ea4a290306094de8cc96997e595bf246c6f3687db8988dabbc2d7ea0e8e5f584a94645ecdb87ce1fa6313c64edb8841bacbd5e5935ed20836a4e9f0d7e1c957302464d499c4e7a5606ff4d4d27e2c09a788a411f6b0dba742bd6c68d8555fc6ab7dd31f02b6992c81f1d426a6a8f9916f945c9a70f18096608da4471618d3f5ecdb8a918be573bfd94a50b6c5b96e7f6efa52171e54202f25c1cd7d680792508f7d1f20103ec496d9473e7c90f93c4ad0508acc6559026223cdaca1869af3599582f1333c306460297fbd8428da3b518f205503f21d5bdb9998e4dd9826e4079f4847c3de7a225374a3059a5050cff375f4d655c1e485eadddc11905556a3a39eac995de1294dc55abb00b2db87c629dcf984d7eee9d9ed41b485d828555b21f9a73dcf556caf5249793e00780e4f29372dc197bbdde9be110c241b6af74a9b40ee0966f9bd6b3df249d4d0590a32d75a75003b221c80d1060dd4f5e41f5157e137640872232bcbd19c17d7a8cc6e5b2aa801e78715e423e9834dfb7698491b62cd75a5608a5f4b60677668f5e468e0e2c1ee56676d0788e71246fbb99bafff6c3018b552699101a61281cf6af7b4b2f170f45c4998d8ee6c2a84ac0ea0c06827d93f5654c925d4f86293b63c9f6f4873230c7699d56740d326e178d992298e3b900ea9284b7965139119f1b00cd4381386c1156275e6492a22eb797db92f8c38cf20b7bd93df26c75b53720af744dd2d1d96948758cefbb4af54b8a9a04ac0ea840b30f8e7e26c91d27625fd84ee84698b2ea752193542c461677dcaba3bd83cc034e2ac0b490fd84005956427ccd4eb73483a5cfe204758809230abeedad1694979a0dcebcd03423eeb7312955ab68cc37e34c5b47c40952b9641f3af7ee7495d1abcbc094d7e0025be9f2c16d99477a465b647c83e51c8dac4723a83d1ce41790dc6b783d7d74ea91407f43ce7b5bd5909784a4c832db604081560a0e439f426e85386c692c298e5b28c04a0ead6ded66914d5b61053842e9be21f0708f73275c96dc9d26459ae215597b9c3c152b7184e7e7ed8a34c61cc7c3ec4a2d364984cffbf50028fcb6128c89f01c258aadad9c76b52d1f0ebc340ab92173e4538d3b677fc53551617e25667bb6d80b0896fc43563ac97a8c91c2ede14dcfee06fb055cb25d61ef31d24cc31d0f1dc904697be7dbbeaf93f32cd46b7d37e19fe37c0a662fe814c9b73245763a2cf89e8d64f41b3447d5e33e599491352e0981dbfb59adc7f603c79d1d1694acca0f8b9434951b59f212fd13ade66f983928a519af5f794bc454964ab5348fd2c495827a3ad2fb9bea1df5732fcd277c538a4c022433d1737695c024b4376be5c7a72979f367bead414a97f480418e14943e6fcc09bddbb85b59cc3071f097ed8d7454f7446354d8d53e55efb5cb6ca0016b00e47348ea3bd167fe89eb84c9ad7136bca800d32a76071f4daf05e9a056e8e3dc1c51736f79625a4ca6ba492d07e491e9dbf32a30feffc651f4a210f4081973afcf3e47252f2e145f63ad1f994cfac29d38463b9d632f5a841ec7bfc7defa68c2f8b6ab1282e4793a06fc0c28a1f31087f04addbd8117d56ba788347fcfc77e41930f12c06f5b9fafc491355df662cf2b4644946514a34a0a8fa878ee3c6f41a3b1c20b1d486cec3056d3a2fdc3f1868ee25d131610b120fa305a24d2ef9d8a5276289df8713eb0c14c6b4567a0cbdca6f27850039b72e6b61db3e9a4f02b773926b5c9f40626ad07450395263ebf921f0ef6bbf194b854f96f03ce4cb8137ec3c5291e04d77c7210d9a8d0e53e9db260d73dca3f12aa85083a444a34171c0bc05b72436651874f50cd3fa0c4705c4a25be1d2a8b968f7fd9dab399c016f1e973e9972703acec588a64a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于职业发展的考虑</title>
      <link href="/2021/07/14/%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E7%9A%84%E8%80%83%E8%99%91/"/>
      <url>/2021/07/14/%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E7%9A%84%E8%80%83%E8%99%91/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="add712f1c02ebff3ec7791c4118ca23db3c513cb279c420d8b393d7bd712928b">c172f4ee74b2b6d246b20cbfdc0b877e094fb3226c4a2a6f1e416805108b3eb298ad75b39a83c462261990cc9082fb9f36caad50fd0202ea2dafd3bed104fd727eb7fa912d74497c08cfa76d488c19527f1098f537e8df69a4a9220adf7a84f2d2337b766904ecf5e05b9d6474dbd23a0aa115c5e72fa8efdfd1ba940b5e036dd236b4ee1568d1a436d4a80ba6891957950bc21fe16df209e38b071f6b41152c5e02222563c2bbc7da1a66f2f18f743885b4400d15e13dbe6c9bc343fa96ec874f1bf8aa75f07103983e4eaa915676cf27e85afc2b3d904c3e62be37f992fa4a020a06b71e9fab53a00881ec7ae348acd3d77b538b6dd95693c9a3aeaac8c4541f374a43ea80bf5242bdb86fda7f3073f59d3f922506b6771a60c5a85578d2415cee0d8233de30041f6be120db14bfc63fdadb0de276b49e87b5b463912785e1cac9caee16fb1748c1002ae5944a27b4b2d5d7f70f2c0bdd1aebcc60a2693e811dc64b3f2a9e28f83d194bbd5b688f28d5206edf54d588d24a452f889652c3a72d31190297c399d6780a57c0122922060914dc444d9a3a6ae83406a429eea5c82836c2c982a3c23dead631ead0781d1fb50c962a7608dd47228dfbfb4687ac194aedb497556df7102f370cfa8e55d18de8158205157b429281e7d5326622a9a325182c41caf8170f0b5b7c2100cad168d561fab4ff969ab87ba2014d36ce26e95812f0a272eee3c9941455ba3e21c9741b486f74625ffbf6e2bc368eb6801a53bbdc974ec89f4167382147c2f62b3cd3e8a035b748d88f440e9fb62d370233019fd71b343fcbc70df930591f741417008e8f8ce4e5694a68e903fc6cd40f8444e2ad5de1d612dc60a5c4455569480a690529113e60c81997c9c075d04b6f5ff7154635dd06d82f0ddac480288b9be06061833012d2c0e102d403dd00abc782dbd1b0483f916b6b224c2752fde2ebcdea5615529540b82913c8b8e3a33a6b35e1a180af28589c5f47d77a79d80da161965d06dbcc03c11a515823d8b5196284931ebfb532745107ba347f3101f945e116eb2dfb4a1ede52a4d6205bd1fcf6c9d292bada0f01502b8bc8f326d1083440b0cabcdc6b9f1e93aad30e07d857065226969204a84961be24d9ee31a40a53069dbfe93bad3af046df10dfc73ca49a7bd83941cef15d95cdbac1544ef6dc2c636a275fd75a1846597e1b5d174c4288a5ff89ebf3a5d0ef33f75b9204da8ea5b3fda1b7addb631641a6d6f9d408b337297ae6975a3737ed9751f62b55cc0f2f33691683ea5501a603dc4ce7f9c5424a756a0809c821f652bb68e9a1a146f46ce2320ecde13d5347c1fc01c746c26439a4e1749a5b3f0fb50f91e54cb67650d66f07742937ffdc85227fa1377accf9f157010b1a10a3de79fc2f551869e3a9e6c1fc09fdcb5eca48ae65609f05244c8667361151dbdd0fd7e288e99f7b23521fb2e06ed475b88af576c90db1c88bf56d3c8992077d2942d22a152d3a231397cbbe886dbe66fe4d0ed7f8624807eac90e1eb3caea0370a5a41291629c2dd6de6a8aacd5fb5a49aa808569e82483e7875457d25e9f313630ab461683572dc7ae8ea3c538a254ff42b23466243ef764556774e682f4818943597545de43b305a23f12f25dce53f69b0dee8a74bdbfc8fb51d1f71a3b5c72feea6b1dabb619740d5c7230b127b55f22578bcd30c6f4a9fb9eee5866ebcdd5a7a18ec1412debe769b0876b614417f4b608bdd72e2e07867f3663843e221dc0daa559a75558ba45b62ecb0738e526a589da6ad718a2921f33c68e56b60ac4e5a07afd7e4d10bcd1ed22c85be7611138e60c389f2eb6d46cbf0234a9881aaa68d9b39fa03ccd521f869a9855e0e5561b1e130bd868d492e9bf5b8be1cf42eeb07e6898d87916c46844f3d8ba61aa1486e5053ffea72eed55dc88bd9503b3586688d9602665ee962a38b164317a62f24a747dab330dd82414be323f0952e66db6676489afb0b28a2a9f1d5ee6f4d1e2988ca39df559c54ac3faf84468c75b1f2aafc65d934d1b70d7e323b3685cd8b8888de227e513120a36cda29ac899fd6f1e4d405e590a3f58b957def625e5ed8a32fa18bc3f3a91f26007543eb1091523924afb9a02951f456cbc986f35e880c9ff97cf249eb71d7d809f46106c9243089fa7413007ac3f479efe7de8ad73d44e09d742c96bf41a54cadd1cfa99a66ab86925ab6090da489f1a4260cd1eab7ccee72048512dce23a63d573f4ad46c4cd0315a9412482e978e14f0a44f7fa8b8119736ae17679ac89d087755d27ab3f90495e4ee8f031e9278d977b1abc828baca4ca67738c3267edfda691ea308fc31d4dc775aa585af49ebb6f30d65b6c17cde45fc673776411a7663a0ee755ba3170d6a8fd0f93fc6aa63e2efb7aa387211dd0149bfeca8ea69e5cf22ac47787e49dfc6abc13067dd0e0bd520b956779c65263181f2fa0f68102d5034fe7f1895fb1e8541cd9d907e0fb24487e48daf32cc53189ac2c9d7b150f57410219e4dc5d8def0e187f3ea43a96fd1ab5ca0d4d836bfb8f264c86bd405748af2b05910eec97383430a66847d22bd53027162beeecbddefcb71241673bec5d1ccc622087364756ee7d6f83ecacd210c6a9ad052c9375951e188dc325b615d0933dcda5556b1d692b0a5d3ee3d8f31f4227b3edbaaca4a7b3f1062fd80abec840d77e41ae659be2ae2a3760c87abbe1f26393a15b0a6ebd28d6f0ef2a1789a2567b97d753ee6511d49552b4bfb583acd3a5b4f54f01214a1702607bee774e8f5cb36119e074ae681a79c65dac340d551a179c89dd135b08eb847858bab744884b6ef2bc2083e0e1216aac2a8786f232a3eea2ac31c8b3e1fad8bde7d3a0db1826834003ddf29175a59795217868e1964f423e71f0b841c20d8a5f7b3e5cec34f66e06e778a17c095e6b1eb66caf575fda0eca91864627c41c1a288125c3abecc716caf4362cdd731c4e7551b467a1224cfce39b5de73bb02511aa13ed53aa90a134827e26ed71127aa5484d4e51a66660e035e527ac1d60170f6f18d035fecefc77b2f50eac38b8596ea7ad57dea75895cf70ffd40ce7996ca481d9eb71454ad1eaef7c1b91dd5bf225a9fe444047d47a043781ebb5dfa1413f59b5171482720929f2087801df43fad145500834a5d3751379c0d67c4da2a1aa7ab56456826057a93237ca2ed7af36db7235afd972bc3b843843d26bae13e7e44c29f9f59c8a6ed2349c8f498da93dfd1eb9a231110cb0f2aaf507e1cb4d9a053fb827dfd62c83a4d4736cda734aa46870ee10448875a902b435a7638d81470566a2ddf25cd4bb618e93b3478b2fea0ae51485d1446ea737b54c9d7347f3015b9f99c0126fb7bc51f54fa4d74c361fd4bbbcc27298c20784c62e89487ad509c8281edab59b20253e1976d92f97c36e994d664ee6435a46b10b6da4f52fc6ec2fc9f71cfe9cb0d8db4f31c064a5f58d1023fedb91a55fa0d1055d2d366a444bf5303efd9b661615ef81452d9e3b52eb2e63a3934988c7be882dc285e803477c466a7db71b587a04183ff848077292d2474eeea9e8f9303b5c0e2368c165d5bfdcfa79fb522e65a616cd12eaaef5692b3c85f0eae1eb41200bc4813683fbf19b7a2542f06281de7684e45452061ad40fdd0cc37e15e095b528d72a5bf7a07bf7ea0ad9e754fbdd315a34b5052cd9b1585984bcf57c7a77be5ee75bc08aded39e500ba4fecf065aa9bd5ea628e80a737b6069b9175d73bcb214a5d1887ab7f105909f2cbd2416643a9bfa9991ec69cd1adde8da59064749ecc68c92dbc1b04dc4c859508fc8a1cc1444757e42fc64d515374b39c353efe405c7792f71054c26981febd542cbf11ccceddd7a6fe8403e8ee2d42e47e3eb7d79d53666cdd9255d64893cc6538de157d9da59af5198d5fe103ed30e90e6748611bbc96c092a51e04812ce83bef729dc1d3e7385d9bc9b9ee72ca7c3c1d8043e161bbf3d4bf6589d305ecff5868b6f9db9bda0e8b4d36e9144a353dc1991a95cce571810e98a37fb125eeb6a71a04a315c821c085faab06e167133154362e55c4cc25467a44ae43518e4fe2d36c99112d75b36148b649511b7b9354ec2d3eab8abc5fb55910dbdec47ef38e9fd4bb0552def6354c0df95e284e670779e0a2c6ddf03f326301e56c69b311bd62c7e09add0cf3b1e8836aebb2b42941c772bd4086a19e2a4a32855993932bd60c008d9c7549fc1bad94dac7cc93df13d12f03ffb818f97a594f30ffd6e5f39381f60cd202821b37d530d8e0ab4f537a74a732e8e3c3eafb64503cf4a261defb4153379e383faffcf554e27096ecc1e19d12fa8527e1aeb719295cf17e354b6fb914d8b8870848a22f0cd0e4d4c82259094a2e69275ca1ac2f61989ce9223ed4cd284ac560ed4e6dab7d749705c69f85b37212545fb1b2e362cd8e3891f9bd7c3314aaa25a028ea196c1a67f45783fbbd12f88e9e9e9f50253abda7632bebe23268dd487f1794c91d0af19a3da50f42db1582bb7509af6bedbf884231d716b09154128dffa92d2ec644287eff76eb5073c2f50175d2743bbc9367e975a27baa52198ede32a81ac61f6a8ac0a6e9391a96c41152787c3fa1c8ccbe8155356bbe5be8ca73e7a517f4c0f61764d4c6d4fcf3f924172fbbff3803094f32a5cbf1f0f452c3217a37a1760c6b40ddd3b17a949536906b78bac1385f4502ba419e8136abbc358948eaa3e6912291cadcabe9c322505f88a5c12af3d04d51ebb965625d8e44a2abd8b3d549bd78b5f4a02efcf3aaf4f9f71cb615d4565d0bbe1b1079e727b759e0ebf5cd6632c0f20f4ccd8eadabc7f5bac82978ca015ed92c3d1789190a7fb4eee2fa636116588dbe5f71bfdc7af69f1412a7e7215a5e2c0730852d8fb8885fafef40a12eb6391566f0fe5902746ec74712efd3afe1a4033ead8cccc65ac4ac0111b19501ad29093b7c71581a47d1126abc6af9648d34db9585cc3e170ecf3a931bc94876604b7b64d51554f96c1aab06488b74a3645f874247a0e923f285eb7dbad84ae7825013ab792bd34833dbb039642e08a4263449f98974af548f59d80b5a3fe2b01a48382aa5016488b4793211b43fbb44c4234417eddb75e642f1177f1f4be57e21219b287e3e0c419956133c5f5fc7945f7a1f8cb0d8c0a28cd7cd4500b0e36c1ade9095b1a95af935adbd47a1a2d4a6f66d9b642380e505535ef7283262afa8e7b7de129c06f2ad28280ea1e4733ebfac48ac09aaf4dba35dd20a9ecbe0d5b3d995f9cf4711a29ade3c734678b6109b8e6e3017494d92ef2c347e85f1294bc4898da150f6785cf82a156bb020ea534676e7182467d3962e6d3e8f82128dd48ada44b493766870a2ed08877413a00c8bc2ac7626f57c5996e7e4820873bc1efe25c8e62f154c40b3b8ec376ce75ebe8376e2eba96f5828fb9b26e1f1e764ec866136437b4b48641c99adc9a987851fa29647e8636d61489f47665a279996d1ed6bd308ac9b3a276f534f19349998baa8e606504808c9529c3e957d56ef4a6b5def92f03fb8b882e8390aefb5ca2aebbb6a6aa39f7a9045b0f3ade7e81ef0a5140972e2caa687ed306e3c79c27b257e923afc1833e4612d184a2a0ac165eafaa156efbc01fafe9509fd7f3d16ea72d2f51665cc4852301f641fd99db80f4ae0224850bd62b817ad441b63a8296e7caab7fc594a87fd2d6b1b165e819e3f4e6d5d2566728f5d69df8c55681a53e69f221ffc94bd0f7bc8d38cf7608bd5c4c695013fd12a28111a8ff1fc61ff1876a44328c2ae8cb72a96fe3f862c514837a05bb8de3a4089f6b8a058e15c6d3d019807ef8a7c2620d1d0eaac06cb9d82c5f2110b857f0f44620da4aa7bcae3349c80d9405c27d4d20e5763477165eb727df877b1176dea11528da55320b6e95240ec3b10f08998ab6b60f0a799cac92d19fcb8aa097f84dec6acf36515023ae1735d27a18260a72bb9a60e9cafbfe3f32163423cde669fe0f7e01bb325e25d849648a4f382da4ac597632d5ffd690c9dbe4f6052baed688b93e70a21d296803ede1051c75d384ab90d6592bf0976f2d2367ca7161dbc143095457938592e4dc1f7ffcd834990f17e694c78b84ca6ab46641dfc2793d4c4fc9016f58112e6770b4737d95665ece624ac6d03b680367179d3efa5efc747da55e6e1d0576d7622cf989d9e855f22153f5f214a499cc9f9af1e1e69424806ea888bf598c0c58b63c0b6f852ba831e71e34b981264b7854335e5ba1c3bdb162fb93ef895c36e7e533ac431e22e11557e54a77bb24d874de3b5f32e405cc2ad312c00e8b4abba42d475369464891243c67ebf76b8f84fac62aacb97c1b822db6851e2067c0c41fd78a60e9d88dfcdaf17e6d73d9e124dc7f379d3c4af8d91ea5dc3d5af385cce4b6c286cc3a8b0435a74f6a24f08a99d9557b830b9e0a2ad9fe4771e75a841e21f11c33b1668a74cc06797936d4170b4c177feb0513ca0a2977753e9a07818e59019ce2afdec60fb8a560506da2cfd49f8c51b2bb114bd18330c49a4d0acfe6e60d0aafb6068aa83c01162605d0a79e9c0c760675b786eb539687fca42e5d7913a5782094cded8e418a02e06a182a67c8e0a60b483ae20ea25c1c5126c85f2f090977ad71f7000682145b8c70a109f3f55f84bf85685dda1377c65c8c78aa521385dbf381e488626c2a94b46fe2edde86e394f543ca89b90c6fa57c14702a9c8f336d133db6881bc1b1df47483a8ae7993bcb0c4ce1b137475e1517d24d29cab37f7cef35518cc7a3eb8c79834f3725a98965027027d0a1a0dd4e61159891b32e8992238a2ca39aeea066e0f43699f8cdfeccfd925bad80865b1cd68381c4daa83a180e7f8dd267cf5bf2671bbee5e2c03e1514de00be76c6bda4c10d639b66d4e924b0b7b869a24e22e10d45a58dfd75ef948c83067b35ab156775757207f995557621f1c6d12d1ba90070a2ae68839f7f177a433291bfddc374b71523443bec411167ddd62626c924ad5d04946a77b19b3258b61dcd444aa102ecc046ae9f00e171fcdf81f5e4534171adb24ecbb06cceac14a94e16465b95ee3677f07e843f5c42a6213532c303b5ad82349c5ff3bac3fc5857ff94a3936e7690e45186fe473d1a1d819efb14bf972474d78fd93069b40ddeea8e4bac8cb4077ff820756592a6f17ca9b012e1eec190ea1eb3ce8955e898a103582a4f7fc76831ff64ba6f7492420f95107578a30011c2eb45e9190fa1ff1cad1a50f03451c94d353eb2e00ae793601fef08abee95886019f0231814cd47f35f1d397da4ac892dfc8c70c0cd7b88e5dfa294a12dfc3f5eebf062c3f152269a2afa399a0d40dd44c57205958821e2e5bee8e73a4026598ab22f415bf401f390c5e27fac3f592a9772a93927629694fc9442b968291b3fb735adefec29a47da3637f9b6bafaddbf29d7abf93e6f955b57b77f94ad0412c517bcc87087fcb730602a31b5e472759585bc0a68343eee135b6e957c57c6373038ad7930f47c8bf4dbb85d1c729347093229eae36741f2f0097a3e88239c2a88a061297a7cb3b6d88f9904b8875c83851fa45e0b1a65f58786de3c060bd108609bb1e4f69852ab4c56facc39824f12503e6976b24af2aec2d556f88a64be0487db5b30c25054835f609de6ad7724149d9001ae85e53e5b4665f16d90d4d4554bcad3fd547bab314e05466323c1be0b0cc51a0b818f1d54ca278bfbb0222d5cee5868b95728d506ce3ed655efc4d764097b00ede2411b7d34f1879e85f9e8640ea0f6b78841328c5bb307c24343eefe0112dc16e12ad55ee20e5d057511b66567e65408288ee06c6e5e3917ef910a020d080d4e51422136c9d66d66291f0c3bc0dffd50688674eb2f62d148851044ab41f50b095f7f07b2a30844b3a6518c3ca7df7826f1769cf6f80323f1f073b9197bcffb95ed01885975b23adb13f66130778c1adfbc35baaca3e1521ab9327cc7f1662c96e3cf286785252247fc5cf286a63709170eaa5d8ec09979fb0d7472245068a9411f81fa0006d2b7c465b35df519f56474ab80f0f5e254bfb5f50271a7311f24bef132b574608a0d8114d023551ed7c17170bca935e188b2440e206301063fcbfc4b0b2a0cd9e274d8ffc05194b621589902ba25e54ac7dbe535fa08906131a84fa2c9cca3e03c92d6050ca5621b68c10346b66cb9e109a8e0142266031de7176259d9298236543a907678eb03d85976a0f7c3d7bbbb4db3f6ee3c4ee33a8846e1ac04ae45382a5d27ed04b78b8c802439f7bfbe40ea81ade527731d30a4c8c2f0237f498def6788cb7aba2c60deca44a14cc00e09af2d5e5f68b6e12c4787eb09a91bf493b734b810b456960b705b66647b8f1ceb445c41114601f335c78a68800169cbb4bbaec4fafff17f24dc4c33d4d99313c3041c3c19df850e415829739e11d43852834abca90209af2e605374d46aee238a255a0c8206f8f91bdf1dfd8619c6cd6a21cf163e7e3bb20c0d637092f604b1d3cabb74fb675a98d5c86f934fcec60788e935d357ff4fd32da203032b12be801aa06d136efc57d4198e197b0fc6407f5f71e8ae3163fd93fd32e45e13a083c003efbb57e4c969d7de14ca944800bbb6e4f8157186810751a0502335c77b0345b580c055258ea8d8c29e3f8e287f175a7edec9f1d89907ecefd103e1a8f94ee220a864226edc6b40b093853dcc395a10a3f1873550c64d2ffe4c764d229d7455c6b5925e254bf3fa49eb6885af9daa878c444ab7fb40332005a76da8203770ff89972b1157e62f5112f5b7df120a5a7018d5148e8d463c1b37ab5ca2ddd8d6cfeef5274cfb526b448f603cdbd6fff15a1e2639473f762ded84233fd4072a12ceb9722f95cff4f8165c61ca5a86ef8f9c8f724247db17809c18cf1f094b17e81435bdda23061c2f3aec5a42010704aaa7bcb128cc41731ae6d59d9e8a36e5398df6a69ad692d70015e1b5cc4368ae12293a8bed2dcd9dee9e137f920d07c035235465b102397ef1d9a9bb63caa956447d15fccaa8e9fbf29e4b749a7415dbb8a091da4997b604fbec274cfb43da6b93dd0840c3406ad76bac3af593fdd4aa634d28c1c883a190451bc16f432e9ff3eef9251bd26affb0e8660cf0cdd975645c699b999aa943ece5b75b229f745fb1879f43627f665e80860e767beffeb100903fb13c33a70ee343e1f3b0c8c9b689befb5819fc2de7a942f88ccd7f145048e4632157714b2ccf81cecfa7a4368b256a6d39cc199c3d145535ac1899e0130f16d64022dcb92186a6fca804e57aa3aee380cd7464918d6cd13e4785efb8b091ad58c4879c604187596267e5a1d5cb16888e4e1dacc51739d9efc50964b4819f7e4e0fecdb87b4eb24b63466a01f6aa5cf6f27b539881f4ab21780fad7f904483fb12e53b271827c661d9ba00675dfd8b896fe42734dc1ac55eb9a3905cbdc0e73c4b1b7220b3ca8475f2d4e5ef86e49ba91cb03992b7d1368d468778292eb17a5cfb29396637218f231ff7a94b21f812c639484951bfa55f117e82383f5690b2b5598811adc5b6cc61ba27ac4cbbc71e6bff50cf207920dc8ed2c21ad28f30af5f82b0f706b694ff0a48022984f527432c52a84315c19023a3e211d05291e01f336eb147e33c763808bbe8a0b56b4220e90692962aec1ce457f74117385a2f43156f99c8fdd154891e2421074f0381c51f6bbc323f209e2af9050b65cd8dc3c0d40242a9917b5e5be0a23049ae8b69853ac3b0c59c02ac2bb3fb002cfae7a9edd14c037562380e9866555079154d885da3398b4b11e72f9bb68789f7f53e9d55dfb60e357f3860c68cdcbfec86352d2e288765490c31b5689eccc9aa43cf4dacb10a2ae258e101567f3bac3ef418df31e8625b47af9696dc48b2f7191ce005099ff2ee40567787f60aaa4df1d8078766d4d8d76ae169391b3c05ed25552d9557170b64049704974f17524bded425a892865cbd633b0f0aef4c3dc05f4feb310465cbb445b328912cf10b6b02e44d7b7ffe9e4b99f88a30e1648f19ed23530196dcece4e81acbf145e2c295441a9cb20191c9b0145326725c22c9ee09f9d67589848979df09048c21844766d04e07659cdae52567d83a5d64844b62bc2c686ee5ee34771d80db99321b049a8e2c643de4ec0e56ea3124d77847878a7b26b7efcdeca414629e6d05868015371d2f43bd693e0f3cf0966e350e51f8dfd29f1e97c36f49ada1fd8c35c0ef8227d4d4b68454a7d9385eac7a41c53dad65500896188dfe4b5810eaa1e93b20393ebfb9e512b99c73d3217082ab7aa764142b86af78c288db4e7290ae88c77640ddbda341156268e62e6d8ed3d5d3cd18ed5ff3b25a772d43e77c78092a213f22f29d0eb14f7e60f84e0cbd31501f08ce036598b778f9322630ff87eea44e9c63782f7b9bd324264b329e0f31a8af596fd5bb6c2221715149360341b9277d83d7e32f21335cbbaa98845c3c5b1b0f61bda7d301ec2fe96c89473467836af9f62334b2e43e0d98283001734061df193aed69951099c0de0582741a47c488b152715aca27166e83e8f69aa23a4818eb398f1d808b7c0e600d8e2aaca607f6f6f67082e753f2522e69c13be9623eddb60c78f996ab9c3a26cd1c870d9ddb4b372ad921589fea786b870d4cb5a613aa1e934384aa7e05831182a4f2f14d470cb1e722c19b62bca76de5c247f27cc764db983cdc590a3de7a1010390e6e934159984ab3d4d5ecf5870a99345433517793ed737ac7abbac9cc684767216deaac8f937585654419626e417188154fa0399adaf3d8d65b9b6b1fd6c75c17f1aa973f486303056c49645218d5b1b13c7e7aea71d17450787b1da77eb1923d5ade173d1c0db67ef70b07289f10dbf0506fd4d2391a8215db337c80a7897a33c0bc936a8485bf2b8071cbcafbeaf3adb545fc43fb2e32d5a81c1d15a091cfbc469079610c72afa5cb4f3a72a3fbb379ce075d44f5daa32bcd31c796936463671bd6ba67fd6cb1e232397b6e0e9b357b0184742b82b524d640c2934e467507fc03dbba75b8a88313d0f5091abfd2b71acc84e2bf5bf4625cce7e3a5b8478bc3835eb42f1b774f9fd2b80e2fdee99fb1a8fc11c6856d86fc479175095aa1f194087defde950cf4954b23920f4f0ab59bc5d41d68daa092e5ed725565f47a6ee274326fdbf40cf4181f3e180d6e415d79607f1a9dae36d656bea0f5afd33ba58a67f63b7ef470abf6288fd3be28e9101a212993e7b0c2fac1006f2fa2f60c5f61b300ff6558cea06a98b3b53682dc263c1111c1c475c173b3159fea9bc66e87e83be052fbe098dfbe345d0206d66817e76091b7d3502abaa0c60aa1052ce6f3ff3741c44164562945582b911d23c5636f412ce2ff7f8486e3e6b2868f03507f353d5b7e39f4019ca0df8ca288cb470db301ae3ccfbe91f641daea1db4b771030ad3ea29becbf35c61523259e2dc0bda5bf6d24c155280b4f6810a3c5dad640d0ea1132543fa438eda1449f3b4494a9ff6fc69aea9208772c8047f18270f098961a64bd7737910a86cde34dd9d168ac588097a28774b159e29e8cfa308b044f6a53aa41fcc1e7f22d77dd4be3b6baaedd953bed3e552cec052713998da70ae5f1099eccf9b641122755bcfc3178ccc33101732b48f10ae3e7f927797ec0b55f4ef3c8db6641be6b008d037be87712dc35909f6c09b3af2fe67093d305fd60bc66f69dd1d815afad87cc0b34003945ac2a00cf149e1d3bfee112910287780ffba6fc1f90851681973c9d4dfdef8ddf05ede814fa7f1614ef20bfe09b3815b5cd74a354d57f718b336bccc8b419e50b201121b61ce8f210609e595d1613bb927472d7686a7e5bfda5a59a63795c6d589621f34f223a5380446bd2c5044981b6ff2a68c3126eca366230d2120c4f45db47754644cbe0e18e700c14890de12a1a11e793d2fde53e21ac2ff90fed8256d3ea16a2e7cb9711c3936466c194ae2c8c568d2dbdd4de569dc86ed9afb12d5e2bcfd617b8b906d83e2a0b37c1dab8cd639eaf0ac9a3ceab921158c84526ebcd2057f2267d701c3c2d2deba5b52e7545404ca964f7066fdaaf411368cc2e373cc0506d5ae3ecd3b2fcfae5c037022bccaadac05a2866fa4149fed214cbae8bed2b0724061397199e4fed978a607941612fa56261db88817a809b431897789f6d32f9709036a6bef75bc1a664015e4e4b5fb24e0d1f4c57d51f0ac88f5cd139c6292b61057480a7918c63debb556e465aa2feab9c05997e487e24578b3bdfc39143047b266779f3002a564a89fcb6576e23c6a251da979eb717787bdacd18cf2616ef2a403f20cbf63e61067bda9b0de76f6df988c82bebeb786d60f5ed1a025805c944c77c7acd127e7ac1d53f07486c133392348c8156819260c615fa200031d23bc7eb4f316fb6d391051fc15c4bdca89ece0a70554848001ad3d8995e46a7498d5df75d1585140340a0a1744a3b689ca2c3ea3859c42ecb32bf032d216d43f798845873027fd5c6f35c365e895fe87923f67378930cca5dd5096fe78bee479d31dbbf843c2e601f696de4b831a04fa5c94fc52ff5bc3cbaf67cb70ad42cd5a38d50541ee0d11568f88a26767c4087695d48632a6f9348999231925e986c01eada47de37b4c0633ac4568d4176338944b688210e15e1a3581ca55f832bc855addc4e7d9d9ce59adfb6ce1b6d379687624cac7b21907449b97bb0fdf5394607cea40e24078c7f301ada28bb3af2d04c8204ca1b675baa2bf14fe7babbf097b1f3d0ab627ed17f3325ccee7b58c6179551090d6ed100c11898dcddab399d9fd5e66eefcbcc950f3cc11792b32e20262b2b356bc050ca72071c849cc04e7ea3c1a8b46e7aedee4b075cedd6ef4e23c12623b884f99ebac9958abc15f247edbcfb75c9127424fee9f8be7044665de88449f7765c075b0ce902375cf312ca98348781a4d42557b2992b9e872b774e353b64c2aaff095eef123c727eaf2ebd4173f41077a16b0a87aea0b4e30d792f3cdbfead311e2046fe679ca1d1efcbd53188151cbf7b79ce36dd78108d83a04f0bf79dc4efbf7a769d37b24f7802827e2f2a1e6bb2e03c288a126fa5d5a4ff744d8556837ceef2e8fcaa893b272aaa3247d2dad81f7c6680da9b551e3daee933c6142c16db27f7cd875454a25a0d48dc8e3c1da5ef3bf2e0fc34b73bd34d776f7df1a4155c549dadaeb51cb4cd445590bb74cf812d09388128899a2608b38edcc98a61a55434dff688d2d7a3f5a7ad58ba2e0d0986f1ac7e2687ac5ecad37daf0169ec88f2bfe4abc74693a4fad8c3bf9d9a4b2aa139448794dd82819e640405dd2ca2b2be5ce2095826219054928779f6e2958487e4871f88825ac417ca15813f24421a0e6079922bebb0fba51ccd2fd59e231616eabfae5f94f41b5bdda5508007c9dacbd53e7deafcb2311bb1af5b439c2421f1b7f585f86237045460b046feffe602d3b1226801efac994b418efa7e5572c7e5ecdfc0777fb1a859060faff68ffe1da32f95e1335c0cce99153f35527d0333bf3cccfd922dd612cadc7d00161883165a0179f306214004ec7a2a7334348f19d4cf38039c66e648fecf4bbc65cf412f06b988afae60295a81e576feeeb6178a127a1e10ec9de8c98821273fcf005e2148c464fb26893ab3f1ce071c438f2b0eb547bff43d1e9e8a554443cdb6f4f07bbb7f10c0e676ff92987861ca2d0c631e8f154374333a9f5310fb9614ba02292f3b9dc1a5187c1a2a594b13b56b9c46ea0dfae86e2d6536cce2c43406452df5d32aba6482ce2448b39a5337058961c34c11b773124f8ef5e986fd64cc739304f0cc16cb86868df971b2eaa38f9e2c83852241bab0092813fda27edb43427a9e421f15c04f9b6636759ac9e27886aa3428d3f116b27240abfffc58ed6738e56424958d49368f958ed374a05c82d21888c37613f76008436643f2cd5f8a7bd373efbf4daed26cddeedf6f3fe54148abd8dcb9a1e33aa87ee717c66b8643420d009ee4b77536364f52ec78f854a2059f621886c166b2863b32f821844d5b853347d9a758e4663a8199fc1e7edf94368f69e69e68536b5aca233369f9227bd01004a9b52cdcf551737fe15d6ab3f39347655901d4d2901153293e93b90a9a4e73ec7473be9fd62ec79def3e139a9db9f1c2ce3847db5f3192eee4331e4e37d05600f46815b403d4b1475f685f8ea45d0698807bb4ea60537da6b65057a63965764f2747de09c266f59500ce2d46b34bb245a23ae6e15d9a799f9fd7eaf126c3d8be218909dfed935db0fb0ebeab98bba20260a489ff4e20d86a78b58a515eae12feea2feea25bbe8e9ebbeca6a66139850a1660ff40f416a235b333d7fdd924ebc8eabbbca3324951d445cf98696758c66e616272db1bc7d38bbd12884801ec5fdea28105a17566461c54c175bc85538fd29b421ed3494ccc5d2a5ab20ab60d635d4f9ed952d964edb6199e9ec6a80d234349e1c5cbb0c8fe34060c1cc8e6008c228fdcb0721f3e48cf69983659db000ea7b37a7af4e777bf53cc123867cf9e341481b8df05744f2337369be3bc9747a0a14b0abb518b9cf361f0f027f265fee7c2f3eaee35282b6eac31e766bc97161676c0e9fc3edcc2a18b996c8db4e43da8c3d028f8e8417a84661bd32fd0338342ccf4898c3da7b4cdc4a395cea293e4db7d49bb68288944b6dff2560f89d463fa4f41f64d725548eb51f520e4266971b8fbb559b97eb0c47b6a6962fd9784d193e78bfba1bc16ad71d399673175ecad7ec913b46518c93d6fc68b5115c8c46b515c47098951f4360ba2a44438c69858e6dbf8424fe529c4a82a4af65cdac2eb347b343f05a45f2611b7a3b360acee6d4bce682867f669cddf0ad8b707ab9106ff1881dce83f0f44da293e00bc3b86dff9d84ddfd40ae9ff6ef543077cf888d6b5b72ba9096db6f6f9cd25a00f4d7c8a12cb350c72c2c25ff7a9979bf338b9c64b957534ad5777bce46ae1a1841f835603e04dad13e0c7dec4fdfcb5c1b346787e33f340f77d969ae79ea1ccdad674ea544d01b15ac07d467d2a2f691963a55e4474092de9492a5e532fcdc291744335c3ad4b66808749ec4a1d963e8bce2bda32841b0f2488ddc92180723810877a66c21d45349d0059d0e93410ddccbe83e0a6551efcc704715b0e54a0a90b8f3299a98ac42c731a20a3343ff12110a043e17c3fc10539ee2ca9e127817b804a5b94cb0b4ce0efa76124083f42c13987fd1d7cee22c3af01d6dc4e2d55c2a3eb36ee152581fbc9ddf7c0e50e85cb3ae1f1734e14bcaa8f5e32b7b541abff5b4c33487bfd907f63be228899e1417df1450786d0797f88c61a0675d90293144c6fc06b9cae5d8818f15d9d4d0b1ece113428a2ac3bfb8d6390f3283b18815d808c2dea32f23987290a244101092ffcb5a74eb700d552ac7589916b2e7afc655b769fa1ea766471dea23d7575be706f239d51a63983a417cbaf706732a10c9bac450d3f51009d1503c1e485d72d78276d83eb808382ed7eeead266c68b29990258a6d4270617e4b65eb08b69cec84539691d1e346b107df508d6ed9a5ce0c070ecc80b4ba662085f512bed2159ce24e1a0f35a613946dd2eac3e02ef0f6873b74fc491e7f04dbafee0133ad60ecebd85bde7f4a8f16942fbe136c89917f738cf76fb9eded2413f7145f2a341b2d3bdd5d3996bdaed21d3e681a2a1c8aa9ac9ae7db5391ae8c6785a390020d9272aee637bcdaa1e3a2515df945a629d730187347f62cc76102a230591cc24f8fd74673faa43413d563e7cebdd4266d76009f7bfda693292c710c4652845fb7ad4a8f129a5731f4bf3eed515a22142045635a72d6435036446c454865352dd80f5066f898f5b1cb62ee3e587f96db6a03404ff0f07050a1e77c29c5bfa190cca735c50640f4389c009018a8fa7a0b2ece195683eb388c0e0eebd4d2df07cf7bfc8e297eed38ea808d992af929d3c3e1b53ec0f4f54c4ebc819e2a0ae1b46630ce51716bdf0bbcf8e1b4dbe7ba3b58802499b4f4b552942ff17f15c05104e27573b456fe7a88a959050f4d65f550dcfcaecf40c73984db4e2885e9e27d4f992e0eb721343238a4d5ced25a3a8343c89536cc9cd5d3c605702fa5b42bf59e9644ea9849c4995c6f8630617672ef80e9ac819e27c2b05cc8db17625290c9bf477d9f21e774d15e566a874a377e9b1025b1d2c82e9d32b8cc3fbf95618dbbf5c9720fe872bfd1927ce720d8962cafaad633766c3c828fa86213e6f347cfed5ce9add5ae13db650518bfbc9b7698a5cb65fd5df4ef135898c59326b3bc27e61932506d5fde5130359f66be8f52586ddb3388bba4a0fabb864a4f9a2e9892057976bc425967b60a7eb10844d091d888e8982a02b6c9dc2da3b561bef0e61fde43905472ea0911bff9cc06f809323d66fe012770316ffce4a3a2b944ed619ae79f529ea2762ec10e9293b7a04f58a16a7ba9a219897ab7e762ee20ff2f325cac589cc50c66df2ec4b76bc4f5fc9bb6f8dc91b0be30f6df2fb618c1afa1836fc99f858b0d5d4d293c2ce9e2d6fc4ee093100d32d3b4fa1accce410b91c7bb4874266729761c8dbc981dd6c22cdcff3d03498ad1081f024b509fada6b8f291332862c04787af4141fbeda525cb4ea8e9222a011792f779fc007b3c397fa4be27310aa691d60522837bb4c3de202c4278068a968f7d9c90616ae51ac50fc2aea72a4b53409604479c943cfd137260a91d0e475970b243847a257c162523dbe3798a9c1256acb1f35b8aaddb0a47a6419950de1bd5c187d18db5bc33f8ecb9a1fbf097e96bbcdc598bb8f776800ec8a9ea9988ba07f261eb3f14654520884da84d3fb374df73fb23d0b4f11aeb050b0b73fa1ae318066ef217cf18934609bd06945091a7fce1fe27ad9e384756fd1e1e3c81b35397fa33035b9e357eeccf00c44e8e91a72b21e7900818ec67c5b747fa2b668ddb7619a606fc77bb2c2b106811ab7e6f3d1dc50163cb4448540c831e3e5109612eca59a1e6c28f7212738d262123d4de1c373ebdc4cb56195f7d456c74d5275e8862e537ec0740b4ed67d4d2cac6afab521ebb800f08dd8bdb841ecb66e3bbb103b1a46dfc7768c06b1712d475c4d59d9282bd600c63e1d3bfbc0195fd61d0443c26ca881eb5e2ef9bcd49c2e65057f09ba19623de9ed1c541903d7abcc85767056326ee78bc6f3ae21f86ec545e013d0e386b53c12fc299070ed27682ae9246986a0943b86fa113faa80f5b0c4503477cb3829d0d3d0a5e5f754eaf2ea82a6a473f3ba7d9bb757fd997b08ee515aff65672ba48c85c39fb2810c26d78aabb46b842db05381493afe4e148011660274827b1972f160c45c4be71cd694793309d5f866204141464629064295cec8343710df0376e40b18a6700a3e3accc8391eb85983e3de662e84af968b73d8d0135cab648c2b60b6109c080bda4d10c1cf3aa8e29e552b6fddec6ca7134afd765c3bf2079a694fa7f61671b68462cde2b2878bac26ad46f74928d9fe682a7a69038cf3ed0bd20b5764a50c9d638f61a563ddae05d7a7575f68c28911c1453158b8810e30bc2d09db3f35869215c239ab2303a9f83c4d1af4fb0c84b631b978efdf5f9a346e8805133840df3b06b27195a08b404716b391e9b2bf076bed332bfe876943bd801f85cdda3b3dfe2f8fe2d411536da364bffc35783217eeab269edae7a576b5d20658bc288e412083b63b6160eda708512f23aa9342ddc76e7897f44aaa0e918d2c7c3502e76478aa1bca0a254ba6a8f07e7de74ad127204267bfdfe8d23ee4cbbbdd4d2660c25fcac77eb834a2a2552bf0c554519c455fa4e60962a0d7a78e46c4849dc43c257aca08d81f1fbb488564d679ef536e1973dee8f14ddffd8a190e16e5837bd325ed866c76ec4846dd1dfa27cc3b68ffb811ca7f4f311161198e89255c5c4dcfc5e7f142b35a28c2d478379fe359eaca9cfa385b96c66f664658103dab347fcc061eb1e8838db452c84937e6a9d8f6a9df9977e3d0c476bbbde1b390f21833e73aa2bcf04caaf42448fc464200093b3181423640e345ccfc2ba38a43f4eadd10077f259fea0e5fc2930c91384cbb4faeb6aae52eb916714ba430e994e73d720094f49848674d77c94201f3b3cbec0ff39d4e40bc7d969c7a53de0807a842b4f1ddee9eefc4c5d839b3a5bfcf3f57631f5babcdac80eee650906234df5f0677e584bf76dfc2c79f1ba64cfe41eacd1e16a9c46d2f5833e085b4084b1da13ae4b80a3167cf7061d308200eac3db38da7cf9c2c46672e7bfa20fc9f72ba0d092b343b87cc4cfddf5534dc00a64d3256e8aa2f271d75331bc4d1983a7b6fa91138f4633389d44732f3941e26c3432b5f993eeeed081bc86a01fea06cc52a85eb3cdfeff740354fd9ddfd07e8cc0b14d791bbc6c5efaf205579f52d77bd1fee76d7c077fdff23a9412c146f543ba858a8928295558f84089588746693910eae2dc99c666b9ee54a2c9429eb037d20660bc6b21f43c0e68e6bfd4b62372d9ebfa323a48639435209436f3e7e1fcac20370b24e6bf5e441a3e22a88412efa3922d9b782f9a5e5a3c836dacb8d1c2adf1adf57721b13c2728d67458a6e0fd803bc7f8fbc2bb52b9f535563c3d7b6ff579acb831f41444d8d9249e00500df987d9afd53c65c7ef859c0c3f98110eb92a015baa027b45a3d61d172a3ea84679e13580a7d2ec69b4573b36827594f45d4893e24b4e29df0674fedd2a7b76281ea6b7aa8f48a82105ae922218f4f357af8890f76ee6eb980660dabeda948e26c0e94af6b0ea55c1876cada9f042ee9c16d6a481ebecef21c7ffc4321d8749f6a99d8efdd7b724664eb29539a05e9a21a347c9668dc4cf71673ff95230140bb99d87ec64f4f6b5f27aecd929a02622e90e4eba56103a52170c6ed26d91340fa402d8f9d49934d5221644d2b5499f9efc59533ef0dfd86e9874d2be88ebe722b1fb75b9712a194d02f7656031bc4048f85664bd3a8fa1e4681817a421f82dd7b05365cf2b049b2f0c380f517524bd770cf17c5f29d3ba0bc96cf301af71eada6b7b4102cafbc823d7e484c2db07e9f48753eddd316d3e9afd69eae5b6c54fdee3497d1203f8aee0e62a95496402f5cdd4e56a5c5dc73c64dc96f04574bf147ab51dafab19518649a3022199a5706512a9186f7a508f0299fade819eaf44b6edce3d895e95b86744d8950a1c81f6cafbd0e5fba3fc416de6b46ab2d95217b998ab5146a856f1e15b5498229a520ddcaaa95c10b9d35605b55cb6dcdf5dce0961ebe4039336e9b0111c6e6c08d728e465708f106507145aafacef3f5d85c5c167ea93604b7362603c60281180d994182ba4fff064b27027ae2684f8edfb1621b84e2bb513744a31c71d193724bd60e4a604eaa856c210ea5ee8221593683b9d21f8ed637473c4817452df6635a76bc1e16277444939f9f4e76abf9e796f5fe8772d990cf7952473ac9cacd275d7b7f94787311f54cbba2b8f9aae9c63066635bce60b1a0a85b17d1f83da3919663387208a31aa1232d9b39dda05ccb36ec24a2a36b015732940103b842f88f23ac24b20ff23498c4186100419d338efc456e38a63a3cf037017ba7d7f65cb9a1296b0c3c662036d073229c4378c0e83ac92a071e38aca66137e899566b950f23f717659061851c61fe5cb9f14e76f7ea00d06c4fc07a6c93f084208a4197f4dbec2f01e02d952e62bd725617cf15f0230a3ae56be8cdd4b1ee0ffb41d0b1a59b7408aa924e9d53abdb74f8806b070712af4014dad6a626b950dfba30ef562f1484b9330e2d0b0d915e516dbfa671b1cd8c3779bb38ec27a07561ff027f6569c36a106c9036dc12cf8d2031301f769c140ad186bb6ebc9e65c2832bb88a0323ccc6db4ee207094c2c18cbf44cd7c6f0356267630f39c3a4924d8ac05143ca9499d39d3f3bf994acfd049d6f598355f2c9d2c84a4e318bb2694e263cf1c9ebf1ef53213ff47f6163cc631c04b82b872fc80f70b571363201cf83660ed14f75f31f6c1e0a0ec4b86ae083192523f98816a3f4d4415c1b995695ed995677973c46531a088740e7d2bdc8f26d3e66ebe3bd33fcd9c44270a2e7197b6c4c9b3ba0a6ed5f9d96e8f540495c5c25ee7dcd5d52b31432b43935e75d2a7ac6e272beeb52f6743406013cafa87a41628527f24ffa4717d4fe8f7fec33ad9efe58dc6cf6723b8501f741335a494171e8499bf04bcce3bbcf48b7ea0f9e1dbb0887a1e4bb6cb219074b4f1cbef0fb3fbc9ff24b3faf10a841525bfc203dbed163f25312cc1d6404107fa4479ac1120d34555dfdc07fad4d18da32d8c2962369f7fc7d2bd9c2205430be81a55816d8c04d8b77d37e873ae8b703f1d95e6b2420df0aadfbcb6ee2bbfe7af7f3ebb539d329031448dcc4886ae5c50c7453437aaeb934aca719065e364b2a518ab344827d601e67cd710d45f96e1911d4c2158547826fac1ed0c47003641c6d483707f243cbaa2b9a8a0f256e5fc58aaac97c9b0b78a18010b99471bea5c5179275aa0c57cbd4dcae4b58b1a425b7e98cf742ceda2e7964328e8623bb40188879ef394b96ee691bda966ec118ee8fa8c99ae237fbed4c9079dcbe73c6850eeab6bdea453789342741a2882643edd863177bb99ceefb44fbb0199eb33d97db9aed52a3f3e8c9b33147910fb25de55f73307b6fc42a051f8cfacbf479d58165285831787116af5daad18711e84662d6d3bef6370b3de5fe3413c8f53586e3edec696e71b5cacc83c56519f0a65d8f0e2be1b8cc72b94b1400cef4e314285f17fe45cabfd741f6aa5820d6c65a0888d3c1dce77c97c47720e6b42aea730593f7dca09f4cfcb5e16cb60cf30568d6650bbd6300e50779d43d5a535d26fa9ffef95b08bc089dafc40a09196dec54c11668101b7b305f85c6429b662900758beeb999ad1e865669adba9279a56099bf32842ed26606b620291fd0634b6945d15c0620264d1fa7a4e6b6533c0fc51761273d9b34c766352b0521e00a961c4294ba18ae5175e87ff1a77cfb60a855a795335197e9d6009b3adb71adf1a18fd2c878d569d1845b32a2344ff682211e422dce89ac81ebd72d0371e3e0d6ab18d6066d8087d6bf601cd2a0e568a8506de37d3eeaf0ec19ea80043794d324300e56d0356b2b3a27875b6b3be5661b0046006e86ac426e5de77e42dc84f2639fc1f71f6b529b75ccf4666785a82517b5890f9383fe3a46959575b2182b95e962bd2ade02bda995c191b05184c0a5bbadfc2fbf9d18977b5aee370dfaa483be749a025ed7f1f01656264241c7030a3a5f590e7dd4bf3379d7254426b40e0592c41a494d9fae42757146f140b7cc8b53bd4175c3f3f58cbfa2555f61d425b1ead9ca4d1b0ea247528f7c0461c2330a31fc9be8ceb385c93a46eacc053ffe56e5afb17281f1c2493e8384a56adde0861584ade33eec43773abf6d2c1021123299a7e24260f8b92fb1e44f029acc574934a899219ad0b9dee2f9c791bc674fbf6d20f4a5f4c4317c95f87b05e78c4fb309925005de9d1c7cea21bdb1642ecbd290d98e4556783a0bfdb334c18db39f3967c9b37699df4047ce22471a81dcab686cbaac8afff74e0475f3a81ab6f78dedc3b24ce34a2e84e7c9a71685a140603584e833371c6d20277d4b33d4500a888ef9b2f8137058aedef81ae5339b38e49ebb9112b8b939f655418708661e1c14fa93de42ff7cdd3c421b5299b3a67934013889696c1811c7853eadbe3fdb9f5f7c6100031becabf8670425d37ad71d95c17a4a34ddaa7f33bc9e3cc71e5586be497c850d9c240f4f38cb2f8364b1386f8707a960d922787bbc7027b7acb25606e2be27d33cf90abccbb0de9d2796caa8e43287c759a45d6a6c3107f848770caeda9a192f09ccca96c89f308f09e72e7716a040cd6815b90f80093d9c97b5ae2d39fb518a90249c3f13524a5ef7d8a6c303f9ca67a03291f7e1086be004553fadf8258e41e5fe009998a1d5a87477e47579fbd0d900b0788f8b5d3b6e20864e790c793e563e2c1e0006bf7e20c799f81fa144faab2515a32e3029b84a4445dae0c47af3be5fdef57591d7c8298c4a86eedbe05810e18295a160f3c3ebc15be4212c1f82b871289467391d308caf9c549d6f9913eb337865c666c52a01806091345b2c293d1bfb81cbc3b538f3bae0939ec285f679de7981d7857fb9612c2002ac8a30806346319f4c5a9ae18555ac5b1d8ee3675cac58df02ee65335b938737f7502aa3b1dc71228462422364b373a2ab62bd4fe9115c6e4d5e8e7173168882c5ae6aaf3c0d79613afb15f4b29c5bd87935de07eb6f0732d9acd82def6512e31335323e7f8782e4cdccee1163f73ddbc0ddcdf645cc6d41135767287b5097972a5faa6dc0be6f3d98668d821fb4f1f96be92723b9f374a2821a8db220544c0231dcef489d6c1b4468ef099b28db45588917e6f4a9b6ad62243e90795885f80460ea6bf246552b5467d3ddd47797da2e7548effba791a4a54eb9d72ef3c9bedbc442be7d8c0d79882f6d82bdfbb83e6e1c18507a617e2ed4f684f5c145dc4278d71990d3a12dc43808fed31cf5e9314b55cdff1a61f7079430570da98ac28c870c1622fbffa37a6fd70533d682c527211088c82ff5a108a118064df2eede9608641d690ba0c579fcf74e85cd9c90ace035e1c31e4dec28301f80a41e23751cbefa3ef3edeab55f41c110722d51cdb125b8fa4af34d9178e1db4e703c549774543bcb9ed5cf23bc7d8aef2cc49d7d6792ebe699eac3bdd3baeeacb0669ad9e1491d9895a4e1c8f93be84f2bea7ae3cdced447811d65f1477465bafff2074266c926e6b9bc4b3601f59ad252d2930140d69a6f073bd8e112157d8e6e45b4a35791ae09ca8d4cb0fd45d1943962ab7e6508929c18f4a280972661d976b3c6804d06490e591fbfd360fa612e59f48fe6875acd48d76e9d0c99161efbfec22286d0c9d5f84e56acb52aec53b1ff66f47c6d64973215d8e61eb3707c40c20fd7230985a6585c89e4d9601552b0e6da6f66ba15df842a19b73325f8f74f7a3f1eee53876a89aa011f166fb905f93a94066d62dc7b6259f76c1ac1db2e3e8e9d73f3114137f1ce714900c64c77da6b34b2e91eb427e4a655de14c11c267ac8972b17b469ec4c98b266624bee58486df616f00ee4a55e56fde9e865dddad38e8cabc5e41b3f99b6fe11a3043b131475ba8354befe137f9811eb72a8bdd503bb4a04d98e00404518f5720d314ac095ea07e0c4226cca54b46f7b75b2a63e8a293e969503a708905a5494667f96e656026c1c14dfd1c2b79ba924748804f654f3b8a827fbca849b48a5bfab62cbcba245f1fd913aca9e283e3c61070092b8bf33343bf276457d17638750605f6feb3dcac3d910bd52ccd403e50629d9f278eae82c25f14736a33a057bb71732b84956cadc977dd0607ac1c728ada4631f902efc9bcee5f418e841bc3d3d8a290dc1d20660000f10b8b1985eb1af35986dcf3b7cea468f858ab09f16ba70d10fbe3147f0d80db65896457604eeb1fe11f31ace38b511bb13772789f1f979454b725e4e72d9b5f004687f4e3714ead505b9c900319a8e6ec8e4f9be62da8c54cf65527c6d9f7aa24200f61ea2283cdc0ba7643bc7513db36dc7ed9d0f2de07c4f995c1da37b68344f3f709c6ca1ff3c3a180f23ab43228515e86ecfa4cd65d4ed579ed092885bfd8737a057944ebfa19d0c0ea2d72116c589ee65a77771304e0833c7397c99e66270e3ac116cd1d2606156770fdeebebf8eeb60782de31d031c278b0840359db4c19817906588e9b98d4c60f8de1310289cd61b410ea7a08295eff6c45bb45b4f4f32fe235f0c0e080e3dbb4ed644544315006e25e616ce98dba1dd44fb72088e4bf73f6407e39802ed087fb596f9d53bd35fc8d4abd107407568bb475d1224350a833f32e2855846c439f2867f92b94a018d39a6aaa928f3619048311f9dda40a24705e6a5253c5fe0b9a3481c1b1fbab7934d419a4fff97a1594185c958fa3337395e5fe86c3d6aeebad8e69e58376d3548fec566112f5310bb9b2e660b4c50e0d3c2b0066e0ef3ad5ffe9e54bb021bdbc6e3a3761d05b72280d5415980e1e02d65088011fa6f56dac936142e63dec69b6ba63839c22bb9c2c22bec449499380249a379082c937dfa529671524b7f143258efde29b24328f9302f9792de5061f33912e864a9f0e73da1363ab5b985a0c852060b537aaf308a2b2bd1b2e9b3cc4f2a085d8151d65515c51cc27828b36fe843c16c92fa85510567f3bc0857cb864d17d248d73a830259d9c847d41ebbf17c097e793011df0715a1e4ff1b474c76498dba7b3a61ebcba10ef17f1c27bf05bd77555bec7619770cb233ba21287f75bef11fc34807e1bc24f0f08982d39aa87e2120a5ebe9bdc6d6668383bf60f0200e20ab5513f9038966ef735ae8d2b626ca4e2467f98de3a85a7b574779a9b2cc2233eead2efc44d86d67fcfbf96da543090ba5a921b5aacfb7c666ab18058a718d6369767dfd54aea4a894b7c073fc9e03acd49f7a54c7e505cc49948ac6a912b0e62e1107499f72d511025d9224bdecde113ce4839fba14edc59823d86f0511e49c6f34ce06c9c4e3cb9bfe2432d95d911901cafba8e9f3e15c3e7a567c574ce308d586f824bf75e49b4f959bbc8ee3c8ee320833ffd965a1edd024afa0254da79dea4a85aa4fcdbde256c8d786656b0da75c3fc86627de5156c809514d3141b5c84f28469a91cb41d6ed495ad95d24477c162c65c33639354ff1267b7910bfda174abe30807a75db15b31df28091581d40379ab4c26f1c73909fac7461abdbb6d56de387dcaa854ed45b2d257dbbcefec8b2b58870750d0efe7431249cc22ab7488e71fd62828a6b8a64a791645634b187c5cb7c00d249567f07aad04a7d8b072bc33fce4361878872ed617c518c69631e2425f08862e18bf92ba89c581227d0df8df4fcb5bc121bfbd651fca28a8a2da793928b922a5175d148f954aabe6f8de02c4a1464d5b6a7d51a359e8ba3007523fd7c5dae51b94a590d47c513930de88ba5acaf61d0c61b1ece8773c164004fefc22de29538a11421e8aac0a0db3f6e278d1f51c9368970b6d70375667338cc14908d237010491f04ca32e37358fef9a76ca9bac807f7e15821beae0b8b5d34aa54e95a3baf485bfb557a7878f6e18146ca85ba51264edb85f0ef292b073ad5b4ff5abded464b6545962bdb399a5642e161f936eff92c078d69fa6d9ec0b7ed76f12d1a008bedf8d125317be5af07fd7f4f02b1239c4f86e934b93c86cd816fbe36b3659d6171fcde6a72f3b02672e5cf7d064750e450ea041600468706e98da91f0ab7ef1737e0450364d7a2b612eceeefc0d7c58caf3af1bfb196be94fa2ae4863463d61a3f46a2a0c91b16a972ec7abe8085e0c85dc287be7fba4d6be918dbb1ea71afc51a9c5295af35aa6da18df7fcb9ea1aca97a8371713721bcfdc33a6d1da96007ede5534502395ffd7e8d7759ecea142bb014fa96c67e68a8421eda27563e198b9d077830e98c951caaf8dd0a736ec5c8daee581a0c6bdf7769f0b59cad7ed13ead323804ae8d13962c8061e42edc9fed2093ff8d3d9e5a55193d3cfebb0546dc1802f4890a7cd794ed73637346ec9b41c9bd7d9a35e8433c7bd0ee7f650929da364cb4aa0a3aba2a39b9d9333462452cfe6d883db4544102d5195e1972715568e7c53eb8f0a82ea5de5bc63c8a97a98576a4974c9f2742821e302ab0cdd6784f1dcff34cbe5350b812200bc71807fd1da64429a79f747648167ada2bf6432ffbaea9beee0ae1f069df76aa6a754e1fb0971786738749ff1fe35796870827e368c9f668c78556d62f946652c29c55d17df8f8e54c8dc1f3da41e7290d8a59fc67e883a570ab93919cf6e0526ad23e5c2e0dd1629c1cc71e0356ff0690f49f8925fe496929dcd91ab769650f34b5f192c10c8516409da97f3835c90bf37df674266dc67da270aae32dfe024b30f335074dd889e2201d045d5e625a5eddb41d6a7b0df91a2d97f38be2b64fccf529a699fadaa96cdd3b8d783dc3de154ceb20b44a52db0b106b2c8d4f2486a0343f38ec4568d551853e671bb1c5f35ff847f87161044911e5bf864be5604327a3cf59c7265634b8903d29218d8163e5172547d4b58b4279630ea2ad2c6fc9d2f4b2f3514777c4410d40976518f1de6a64576647a3218654c5f5bce540b6d4797cc9a640e82f0fef47c9bd31ec12cdecbbc85be65a37c82b55d26dd84c3fc0e49c8822427ba9278990f0583dab16a8f6804da3c615e465633a7c043394ac73d67d4d62f11da7492b92d6a5bfae8fae2f7c3ce4cebc1cb11eb047aa1ae72fcb4d309c3e52ec5a255dffdd4bb31e82a681fa2a41c2252ef226ae2aae3535ae1a5017d51798d4c3367e9f3957ae1654f3c3cff66fe21b55e940f7b76c89dcb32098a7b2cf20a825002523a946616a9f52d9fce144b4820b7e6c64224db1f17c09b1175194678203c1b4df3651c4b04257c49757c2b03f9a99b2c6fa007b2a5524c7b469ec7a7d683fa56d85cc15c0e6642f03d94da9a9599ca25d6a75543030ebdde35e6efd33f5a71d902c235cbc526fc313277b0ab26ec94ddd21b990d6cf0929c6ea313757c280e676d88e3da50a85202b85d23f16cef51858a261e3aa80183769b39096cc760331bc655ef2c60efb9ce148f53fa19127c50f14aff7e2f0ef2a5eeb70a9a7f93abbdf011be2e134ba0bb4d3ae1f9164f019ca1b3999c0176c7485828162c441b748a65cba2413a3ad4edbc4572af6ec027ed8106672a8f0ca2e2413b144479545321f90c00eb6e9f2093bdfbacf1c573a0a59a3b52af106bf69d2bf8d60aadc368bb57db115d00d8f5661b18abf83a638ed89d1a57ed067a396827b07c300934733ed1e389b77f3ceff7a552729956c225390008ed3af4b72bee49c9e21cc3567bdc5167cbfc9ac0bf438602e847f8151c60724f246debbdb9bd667e57c6dd65fdd346dca3a37c13e7c1271edaee8ddf3eb48c7029e92a6753310836fa20fd0c3fcf514237a22d28a5cca326a00d0438ef0835f311c9416d3e09ea66bb5c77603cd6475eb0f1bce0464ee168dfedd954c9cc587ebb8a5ef1725b93d08d1638c6dfd2539e5f19ba53ab50a2b3655c38b68c1c9e3845482e69b9f0adef6d1b160352df2d7d913ac5cade19a9cacd1c730579f6f4d7ab875882e27b2efe9ba5012c774995683ed8385238ed4081bdb402306e7a1cc2b4a7728fc2ae675b2d2aec6a288dea151d2b0ec5f7b9e802af611145185ab6ce07a8c93c618105c4c7b50fd6bea658bb2eb07b67906132c79c92873001d4c2a051b0dc0f79612a6dbc5e56056a78158d8b3777aff0cc6873c52cfbd6fbb9d731c77cc650f7d020eb4c721e898d55564db8cf0efc843ef56bd3fbd1d24d4f0b8a5ca43831d3fe938b4ba7ed91579b61fbc302dddbf394bb0c41d7645bb47649228c680086d59e4135d07480e26760bd0e89ed22b6db9bb1e1ecae96d989693b98e981d5a8cde234d20778395bc70ef08d1f3eb01dc4d50f74a4349e4446d5551bd30bf8e6bf3fe31f932e7769b75363d42699305b51462b3091af41bce05559db61ff21403da5f84330d21258377c46c57d284307cf8066c08fe1d025612ff871ee6e570d1a5f5c0dc30c4c07d08b0fcc57efe6d874424bba89c0be2164ba98e56683e46b5f5cc66be8e87e54d3dcfaba0d76efb79d60178d627d5b740be3f790b4d1a2e3fb4407b20a9d02e639258e0c1bab7c2da45a08a79efeb08cdee5e33c70de09c891011200841a5f2820a86f50b4d95a1be1c2400957c06e6ea47ba353ed65e58fcd8fe928c561c3e26d6e63194a8b02865cb062a5e4d8f282fa1193909fd307189f91f1d208cc295b6af5e2ca5c3fb53dbc6b8c9d619cca350eb885b3f82064d27e00b51b85fe403b7f9d27875f44022ccfd8b0f5c6b04d35fa2d3d6a0a36bafe33ab9f2d60890eba0bce5a9bb713bcf747fe745b8eae323b6b556b2c8b7ded54e645be8496c0a321ff94d266201cb0e7926fd959a757512a7acf780d852df8444cb88c07ba5c2f5b42821110036a1acda1912be0cae5fe766667878e102d206009b38af4ef24af0b63e325fed63ce9a1854a867b938bd375e5ac9a556d71ed0cf08c2a32264a034d9c4a3cd648350729b0182dccc9b0f39b53be8b16ff1d6a5cdc82fbe53fcd98cf1e92f2f9f1e4aa60d659e169f057ece69fe6b86d112a31e9e84af15ed2d0c5d843e5195daac4599c981e259081be794ebd19d6f8ceb95a49480ac63f48da0f5ccc392e385cf284d1a2cfe319fea6e57aeaba3185be6151129da2e6f1a1b6357580dfa3d1c673105a0e1ab86f8b2d5140553b10bfd705b9c9a1eb36b281d7a2cfa9c847285ee889c572af2ebcaf53ef4951edaa6b1244fe75d73a70f77177f67a9511bb5693121defd2bf29556e339151459a7a879dd03b655e151396b1827f56086396f4c4dafd954e09d1b9d995c07bced05943ff38bbf53c3e416684f8dd42c1796fbc63a1b91b03eda57b5c6376783b93c6c0cc18c185f24324fcdb7b7d7df54b3b87c08ae1c30fd0a451ed5e99d401695bb8fdf54539b49d7732eef73bedb95fae97ca898850756187d0164ac55e5739d44fe0137b27ac1bdfc6a67ca6d145838766959dfed0cfa7e04affa05e33e91cf5ab6ccf78e45aadfa89c72aa5627bfb7088eb30c30b38cd203a45698b372be3160af422e1bc05eca1f47766cb2c175c7da8c3ccc4f7ec078552ef90e950d451873a521e09d26d5a7baaf6017f3751dc8146f86f7297c132df565c357c26c0be822693cec06b56e90ac4e8494bf37a4a4bf495906e38a33da1fad312df710bdfcf7635def5e9b722ae863241d2f60c6dab8c13166228b0a0604a07bcb769f5bf1495ec1e61559352060c2c79b898d9cd068754262158216ac29b7a91ccd083d24cac7b142dd70b9bdd85a19501b45c70ee50fa09f164180ff1f4b8836b20e7d80bae848ddcc9d472da2f50ef4a61e100d2818ca0d2bb68e0b508e1abe0d5459eea3adc05e0e12da8a0715640a0d983f141b7ecb7ccf38ec82de2bce616c1284e9dbac41a1d8afb6f5d5b2defb1cef9640874a149a195c464627f0ad4934e99d490253b720c4cc9fa8614ba32e3a0d1e384a81783e7ae3973eeae0108c6d66d4108cfead9ff955d2c0640128b2be305d7c15223a18501573fe7fdffa77867a853134e4604cc3c2b725d90b9d59ff9f4d88d7039d83cf5b57ea2af442fcc0aabf8a4fa15351d11fee97a823aa233d014f47a73b453ade01b7737228668ae4ace6bec16625c2c9bd3788326587490761326e6a228b11323724cdae399e2554c702532cc465ac9472157b18dc8137ac49f5a765cbcfb711e2b59aeb2b2339d25cd899ea0bae10eb677f0a119defd82c4afe9b8bd854ae3fdb9ecd2d78fc0904de250c0af6f6192984a32a24023698b822e9f65b22c0a6853907a6438532010f272fe4b1cf92c730938b3e1efa299ea56e8734f13058c108ce99fd11cf9a870b745d632054e9c870454089b601017296aff95dda9971b23f782111de0219180bebdfe452c7c8d5c01e562c5cd6b16f6aa035d34e0b8cf9bc69a4017d5bfd3c8058754544001e5ca6f95de9889cd4a2ab5ca3faa80a4c6e7bf23faf44fc6743f83aada23cdc6555d4aaba13c566dc2a89340932726cd40e33f74360369c157a78de362a6b355172b8f9a92300cdeebcd2befa0ca5aaeef0a0c3efd967cbeeabaf3ba07404bbee3dccbc51a7008df20f3d8786036a5b2fe8dcc1a5a8414c6b5f9607d20c21280d27d39626df78ac90d80ef764a457068f4fc4d49877be0429ee394e8b2cf6fa0896d0c592cb40e46b2fb240d4fbf06ed092700e6e6e48b2754b55ea2d33866ff70cc63e3a618ad6964aa70573840a800abada81625e204c45720d2736018cfae90b2c721e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Optimization Methods in Deep Learning</title>
      <link href="/2021/07/10/Optimization%20Methods%20in%20Deep%20Learning/"/>
      <url>/2021/07/10/Optimization%20Methods%20in%20Deep%20Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="background">Background</h2><p>深度神经网络的训练过程主要通过求解一个特定的优化问题来实现，然而由于该问题是一个复杂的高维非线性优化问题，并且不同的网络结构差异很大，不能将传统的优化方法直接使用。即使数据集和网络结构完全相同，不同的优化算法也可能导致完全不同的收敛效果。实际应用的一些简单方法虽然行之有效，但现有理论无法充分解释其有效性，超参数的不断增加也给优化增加了不少难度。如何确保算法收敛、如何尽快收敛以及能否收敛到全局最优一直是困扰学术界和工业界的问题。如果能够用优化理论去解释神经网络的训练行为，对于深度学习的推广应用将会起到巨大的推动作用。</p><p>对于有监督学习，给定包含n个样本的训练集<span class="math inline">\(\{(\mathbf{x}_1, y_1), \ldots, (\mathbf{x}_n, y_n)\}\)</span>，<span class="math inline">\(\mathbf{x}\)</span>表示样本的特征向量，<span class="math inline">\(y\)</span>表示该样本对应的标签。我们的任务是利用样本信息来预测相应的标签，使预测值尽可能接近真实标签。如果用深度学习来完成这个任务，就需要通过调整神经网络的参数（权重W和偏差b）来近似数据背后的函数映射关系，这个关系往往是高度非线性的，网络越深表达能力也就越强，逼近效果的精度也就更高，因此网络结构很可能是极其复杂的。</p><p>为了衡量预测值和真实值之间的接近程度，通常需要采用某种距离度量方式<span class="math inline">\(l\)</span>，<span class="math inline">\(l\)</span>一般设计为<strong>可微</strong>的，接着用一些优化算法去最小化该目标函数。因此优化问题变为寻找最佳的参数使得<span class="math inline">\(l\)</span>最小，在不考虑正则项的情况下有： <span class="math display">\[\mathop{\mathrm{min}}_f \frac{1}{n} \sum_{i=1}^n l(f(\mathbf{x}_i), y_i)\]</span> <span class="math inline">\(f\)</span>就是我们从输入到输出的映射函数，<span class="math inline">\(l\)</span>通常也叫损失函数，衡量预测值<span class="math inline">\(f(x_i)\)</span>和真实标签<span class="math inline">\(y_i\)</span>的差距，比如回归问题中经常使用的平方损失函数<span class="math inline">\(l=||f(x_i)-y_i||^2\)</span>。</p><p>需要注意的是：深度学习中的优化问题与传统意义上的优化问题有所差别。传统的优化问题需要尽可能找到目标函数的最值，而深度学习的最终目的是为了<strong>预测未知</strong>的数据，而不是将训练数据上的损失降到最低。我们定义的损失函数<span class="math inline">\(J(\Theta)\)</span>衡量的是当前模型参数<span class="math inline">\(\Theta\)</span>在<strong>训练集</strong>上的优劣，然而，最小化训练误差并不意味着模型的泛化误差也会最小，为了降低泛化误差我们还需要关注过拟合问题，因此损失函数往往要加上<strong>正则项</strong>。统计学上称为经验风险最小化，即由于无法获得全部数据，所以只能用经验风险作为实际风险的近似。非常有意思的是：尽管大多数神经网络都是严重过参数化的，但是反而有着比较不错的泛化能力，这与传统的机器学习观点是矛盾的，泛化理论也需要更加深入的研究。</p><p>深度学习中的<span class="math inline">\(f\)</span>通常是多层的复合函数，由于太复杂而无法求出解析解，所以要用数值优化算法去求解。实际中主流的深度学习优化算法都利用梯度下降来求解，梯度下降是深度学习优化算法的基础，尽管目前已经很少直接使用，但它却是其他高级优化算法的基石： 假设网络的参数为<span class="math inline">\(x=(x_1,x_2,...,x_d)^T\)</span>，优化的目标函数为<span class="math inline">\(f\)</span>，那么<span class="math inline">\(f\)</span>的梯度为： <span class="math display">\[\nabla f(\mathbf{x}) = \bigg[\frac{\partial f(\mathbf{x})}{\partial x_1}, \frac{\partial f(\mathbf{x})}{\partial x_2}, \ldots, \frac{\partial f(\mathbf{x})}{\partial x_d}\bigg]^\top\]</span> 每个元素对应着目标函数在该方向上的变化率，因此只要沿着梯度的反方向就可以使目标函数减小得最快：<span class="math inline">\(\mathbf{x} \leftarrow \mathbf{x} - \eta \nabla f(\mathbf{x})\)</span>，<span class="math inline">\(\eta\)</span>是一个被称为学习率的超参数，用来控制每一步的大小。<span class="math inline">\(\eta\)</span>过小，收敛过程极度缓慢；<span class="math inline">\(\eta\)</span>过大，可能造成损失函数在最小点附近波动甚至发散。学习率的调整是神经网络训练过程中一个重要的调整参数，常常使人头痛不已，因此也出现了很多学习率自适应调整的算法，将在下面深入分析这些算法的优劣。</p><p>有了优化模型及最基础的求解方法后，我们需要对其性质和优缺点进行分析，以便于后续的改进。深度学习的优化问题大多是非凸的，因此存在很多挑战：</p><ol type="1"><li>局部最优：对于凸优化问题，局部最优即是全局最优。然而对于非凸问题，当损失函数到达局部最优点时，<span class="math inline">\(J(\Theta)\)</span>的梯度为0，<span class="math inline">\(\Theta\)</span>无法继续更新，损失函数无法继续下降；</li><li>鞍点：该点既不是局部最小也不是全局最小，但是该点的梯度消失，无法继续更新；</li><li>梯度消失/爆炸：由于初始值和激活函数选择不当 (如sigmoid)，当梯度反向回传时，可能在某一层求导后梯度值很小/很大，导致训练速度极其缓慢。因此初始值的选择通常采用很小的随机数，避免收敛到比较差的区域，激活函数通常也会选择ReLU，避免梯度消失问题。</li></ol><p>局部最小和鞍点示意图如下： <img src="https://img-blog.csdnimg.cn/20210710191530881.png" alt="在这里插入图片描述" /> 尤其在高维空间中，鞍点的问题变得更加严重：假设<span class="math inline">\(\Theta\)</span>是一个k维向量，<span class="math inline">\(J(\Theta)\)</span>的海森矩阵就有k个特征值，其梯度为0的点有可能是局部最小（特征值均为正）、局部最大（特征值均为负）或者是鞍点（特征值有正有负）。高维空间中特征值有正有负的概率很大，因此鞍点出现的可能性远大于局部最优点出现的可能性，并且鞍点周围的平坦区域可能很大，需要增加噪声扰动来逃离鞍点。</p><p>由于上述问题的存在，通常很难找到<span class="math inline">\(J(\Theta)\)</span>的全局最优解，但实际上为了减少过拟合的风险我们并不需要训练集上的全局最优，经典的梯度下降就可以带来足够的局部最优。</p><p>分析完优化模型本身的问题，再来看看最基础的GD的问题：目标函数通常是训练集中所有样本的损失的平均值，故目标函数的梯度为： <span class="math display">\[\nabla f(\mathbf{x}) = \frac{1}{n} \sum_{i = 1}^n \nabla f_i(\mathbf{x})\]</span> 如果用Full-batch GD，那么每次迭代每个参数的梯度计算的时间复杂度为<span class="math inline">\(O(n)\)</span>，对于大规模数据，这样的更新速度显然无法令人忍受。</p><p>学习率的选择是一项重要的调参工作，因此学习率的自适应变化就成为了研究热点之一，一些二阶方法应运而生，我们首先来看看牛顿法该如何解决这个问题。</p><p>对于损失函数<span class="math inline">\(f\)</span>，利用泰勒展开式有： <span class="math display">\[f(\mathbf{x} + \boldsymbol{\epsilon}) = f(\mathbf{x}) + \boldsymbol{\epsilon}^\top \nabla f(\mathbf{x}) + \frac{1}{2} \boldsymbol{\epsilon}^\top \nabla^2 f(\mathbf{x}) \boldsymbol{\epsilon} + \mathcal{O}(\|\boldsymbol{\epsilon}\|^3)\]</span> 式中的<span class="math inline">\(\nabla^2 f(\mathbf{x})\)</span>即<span class="math inline">\(d*d\)</span>海森矩阵，存储了函数的二阶偏导数。为了求得<span class="math inline">\(f\)</span>的最小值，令上式对<span class="math inline">\(\epsilon\)</span>求导得0，有：<span class="math inline">\(\boldsymbol{\epsilon}=-\nabla f(\mathbf{x})H^{-1}\)</span>，即每次的参数更新为<span class="math inline">\(\mathbf{x} \leftarrow \mathbf{x} - \nabla f(\mathbf{x})H^{-1}\)</span>。二阶近似利用了损失函数的曲率信息，即如果曲率比较小，那么这步更新就会比较大，反之则更新较小。这里没有了学习率，而是通过“梯度的梯度”自动调整步幅，看起来比一阶的梯度下降要好一些。</p><p>然而深度学习的参数空间往往十分巨大，因此存储和计算海森矩阵的逆是不现实的，这也是牛顿法无法在DNN中使用的重要原因。为了缓解这个问题，学术界提出了一些拟牛顿法如L-BFGS等试图去降低存储消耗，但是计算代价仍然很高。</p><p>从以上的分析可以看到：无论是Full-batch GD还是牛顿法，都存在计算消耗大等问题，不适用于深度学习任务的大规模数据集训练，因此已经很少被直接用在深度学习模型中。为了处理这些问题，学术界提出了很多替代的优化算法，因此接下来我将调研分析当前常用的深度学习优化算法 (SGD/Adam...)的优缺点，并结合实例及前沿研究进行相关讨论。 ## Popular Algorithms 优化算法在神经网络的训练中有着举足轻重的作用，选择合适的优化算法可以使得损失函数收敛地更快，同时收敛到更好的区域。目前比较流行的算法有下面几种： ### 1 SGD 尝试用mini-batch的梯度平均值作为整体梯度的无偏估计，参数的更新非常简单，沿着梯度的反方向即是loss下降最快的方向： <span class="math display">\[x_{t+1}=x_t-\alpha\nabla f(x_t)\]</span> 如果是Batch GD并且学习率足够小时可以保证损失函数单调不增。实际使用时一般会采用学习率递减策略保证模型收敛。</p><p>实现也非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -= lr * grads</span><br></pre></td></tr></table></figure><p>SGD存在几个问题：</p><p>首先，如果loss对于不同参数的敏感程度不同，那么收敛过程会在敏感参数方向上抖动： <img src="https://img-blog.csdnimg.cn/20210710192205509.png" /> 对于非常大的参数空间，可能会收敛到不同的区域。 其次，如果loss函数有局部最优或者鞍点，这些点上梯度为0，无法收敛到全局最优； 最后，如果采用mini-batch，那么计算出的梯度值是有噪声的，意味着收敛过程可能会是非常曲折的，也即需要更多时间。 ### 2 SGD+Momentum 为了解决SGD的问题，有学者提出了带有动量的SGD，其思想也很简单：更新参数时不仅考虑当前的梯度方向，还要考虑历史累积梯度方向，如果两者方向一致，那么这一步更新幅度就会增大；如果不一致，就会减弱沿当前梯度的下降幅度。 <span class="math display">\[v_{t+1}=\rho v_t+\nabla f(x_t) \\x_{t+1}=x_t-\alpha v_{t+1}\]</span> <span class="math inline">\(\rho\)</span>可以看作是对历史梯度的衰减，一般取0.9。</p><p>带有动量的SGD实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = rho * v + grads</span><br><span class="line">x -= lr * v</span><br></pre></td></tr></table></figure> 这样就解决了SGD的三个问题： 首先，由于历史梯度的存在，朝敏感方向步进的数量就会减少，会更加平滑的向最优点前进，减小了震荡，加速收敛； 其次，对于局部最优点，虽然当前梯度为0，但是依靠历史梯度可以越过该点继续下降； 最后，梯度噪声引起的震荡可以通过历史梯度互相抵消。 ### 3 Nesterov Momentum Nesterov Momentum由SGD+Momentum衍生而来，SGD+Momentum是将当前点的梯度和速度结合起来，而Nesterov Momentum则是将当前点的速度和下一个近似点的梯度结合起来，意味着我们不是在当前位置去看未来，而是多看了一步，在稍远一些的下一步看未来，可以提前调整步进大小： <img src="https://img-blog.csdnimg.cn/20210710192712932.png" alt="在这里插入图片描述" /> 所以Nesterov Momentum的更新规则为： <span class="math display">\[v_{t+1}=\rho v_t-\alpha\nabla f(x_t+\rho v_t) \\x_{t+1}=x_t+v_{t+1}\]</span> 通常我们希望针对<span class="math inline">\(x_t\)</span>计算梯度，通过简单的变量替换，得到新的更新规则： <span class="math display">\[v_{t+1}=\rho v_t-\alpha\nabla f(x_t) \\x_{t+1}=x_t+v_{t+1}+\rho(v_{t+1}-v_t)\]</span> Nesterov的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v_prev = v</span><br><span class="line">v = rho * v - lr * grads</span><br><span class="line">x += (1 + rho) * v - rho * v_prev</span><br></pre></td></tr></table></figure> ### 4 AdaGrad 前面的几种方法都是设置了一个全局的学习率，AdaGrad则通过引入二阶动量使得学习率可以针对<strong>每个参数</strong>自适应地取值：对于更新频繁的参数，已经有了很多认知，不希望因为单个样本影响太大，所以学习率可以小一些；对于更新稀疏的参数，希望从偶尔出现的能更新该参数的样本中多获得一些信息，所以学习率可以设置地大一些。为了了解参数更新的频繁程度，引入二阶动量——每个维度上历史梯度值的平方和： <span class="math display">\[grad\_squared +=\nabla^2 f(x_t) \\x_{t+1}=x_t-\cfrac{\alpha\nabla f(x_t)}{\sqrt{grad\_squared+10^{-7}}}\]</span> 此时的学习率实质上是<span class="math inline">\(\cfrac{\alpha}{\sqrt{grad\_squared}}\)</span>，为了避免除0，一般分母加上一个很小的平滑项。如果某个参数更新频繁，那么grad_squared就会增大，学习率也就越小。</p><p>AdaGrad的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grad_sq += grads**2</span><br><span class="line">x -= lr * grads / (numpy.sqrt(grad_sq) + eps)</span><br></pre></td></tr></table></figure> AdaGrad的问题在于随着grad_squared单调递增，学习率最终会单调衰减到0，意味着很可能会提早终止训练过程。 ### 5 RMSProp/AdaDelta 为了缓解AdaGrad的学习率变化过于激进的问题，二阶动量的计算不累积全部的历史梯度，只关注过去某段时间内的梯度变化，用指数移动平均值来表示过去某时间段的二阶动量的均值： <span class="math display">\[grad\_squared=decay\_rate*grad\_squared+(1-decay\_rate)\nabla^2 f(x_t) \\x_{t+1}=x_t-\cfrac{\alpha\nabla f(x_t)}{\sqrt{grad\_squared+10^{-7}}}\]</span> decay_rate是一个超参数，一般取值0.9。</p><p>RMSProp的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grad_sq = decay * grad_sq + (1 - decay) * grads**2</span><br><span class="line">x -= lr * grads / (numpy.sqrt(grad_sq) + eps)</span><br></pre></td></tr></table></figure> 因此，RMSProp仍然是通过梯度的大小来调整每个参数的学习率，不过现在学习率不会单调递减。</p><h3 id="adam">6 Adam</h3><p>Adam的出现是集成了一阶动量思想和AdaGrad等的二阶动量思想，即Adaptive Momentum： <span class="math display">\[m_{t+1}=\beta_1m_t+(1-\beta_1)\nabla f(x_t)\\V_{t+1}=\beta_2V_t+(1-\beta_2)\nabla^2 f(x_t)\\x_{t+1}=x_t-\cfrac{\alpha m_{t+1}}{\sqrt{V_{t+1}+10^{-7}}}\]</span> 由于m和V初始化为0，所以开始的几次迭代会偏向取值0，为了弥补这一缺点，又引入了偏差纠正项，完整的Adam算法如下： <span class="math display">\[m=\beta_1m+(1-\beta_1)\nabla f(x_t)\\m_t=\cfrac{m}{1-\beta_1^t}\\V=\beta_2V+(1-\beta_2)\nabla^2 f(x_t)\\V_t=\cfrac{V}{1-\beta_2^t}\\x_{t}=x_{t-1}-\cfrac{\alpha m_{t}}{\sqrt{V_{t}+10^{-7}}}\]</span> Adam的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = beta_1 * m + (1 - beta_1) * grads</span><br><span class="line">m_t = m / (1 - beta_1**t)</span><br><span class="line">v = beta_2 * v + (1 - beta_2) * grads**2</span><br><span class="line">v_t = v / (1 - beta_2**t)</span><br><span class="line">x -= lr * m_t / (numpy.sqrt(v_t) + eps)</span><br></pre></td></tr></table></figure> 如果Adam再加上Nesterov的向后看一步的思想，就是Nadam算法。 ## Experiment 为了对上述算法有更加直观的认识，同时在部分程度上比较不同算法的性能，构造一维函数<span class="math inline">\(f(x)\)</span>作为损失函数，其表达式如下： <span class="math display">\[f(x)=0.01x^2+sin(x)+\frac{1}{3}cos(3x)+\frac{1}{5}sin(5x)+\frac{1}{7}cos(7x)\]</span> 这个损失函数含有大量的局部最小点以及悬崖，如图所示： <img src="https://img-blog.csdnimg.cn/2021071019313296.png" alt="在这里插入图片描述" /> 为了公平起见，比较时将x的初始值设为-29，每种算法的迭代次数均设置为300次，学习率均设置为0.1，迭代过程如下图所示： <img src="https://img-blog.csdnimg.cn/20210710193206336.png" alt="在这里插入图片描述" /> 最终的收敛结果如下表所示： | 算法 | 最终x | 最终损失 | | -------- | ------ | -------- | | SGD | -27.98 | 7.19 | | Momentum | -24.00 | 6.21 | | Nesterov | -24.00 | 6.21 | | AdaGrad | -27.98 | 7.19 | | RMSProp | -28.95 | 9.10 | | Adam | -26.46 | 5.59 |</p><p>从上图和上表可以看到：Adam算法在前期收敛很快，并且最终效果最好，是综合性能最佳的算法；带动量的SGD能够越过一些局部极小值，在没有精细调参的情况下一度达到了和Adam类似的效果；AdaGrad开始时的梯度很大，但是由于学习率过早地减小，最终效果并不出众；这些结果进一步佐证了之前对各种算法的分析。</p><p>如果将学习率设置为0.01，对比如下： <img src="https://img-blog.csdnimg.cn/20210710193256448.png" alt="在这里插入图片描述" /> 可以看到：精调后的Momentum、Nesterov和Adam的效果几乎不相上下，这只是初步调整了学习率参数，如果通过验证集更加精细地调整超参数的值，那么SGD+Momentum完全可以达到甚至超越Adam的表现，当然这也需要人为付出更多的努力，Adam这个烦恼则小得多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Sun Apr 11 18:31:58 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Jingtao Ren</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = tf.constant(<span class="number">3.0</span>)</span><br><span class="line">b = tf.constant(<span class="number">5.0</span>)</span><br><span class="line">c = tf.constant(<span class="number">7.0</span>)</span><br><span class="line">d = tf.constant(<span class="number">0.1</span>)</span><br><span class="line">x = tf.Variable(initial_value=-<span class="number">29.0</span>, name=<span class="string">&quot;x&quot;</span>, dtype=tf.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_f</span>():</span></span><br><span class="line">    x = np.linspace(-<span class="number">30</span>, <span class="number">30</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># y = -20.0 * np.exp(b * np.abs(x)) - np.exp(np.cos(c * x)) + 20.0 + np.exp(1)</span></span><br><span class="line">    y = (<span class="number">0.1</span> * x) ** <span class="number">2</span> + np.sin(x) + np.cos(a * x) / a + np.sin(b * x) / b + np.cos(c * x) / c</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Loss Function&#x27;</span>)</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_train</span>(<span class="params">y</span>):</span></span><br><span class="line">    x = np.arange(<span class="number">300</span>)</span><br><span class="line">    labels = [<span class="string">&#x27;SGD&#x27;</span>, <span class="string">&#x27;Momentum&#x27;</span>, <span class="string">&#x27;Nesterov&#x27;</span>, <span class="string">&#x27;AdaGrad&#x27;</span>, <span class="string">&#x27;RMSProp&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Iteration&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Algorithm Comparison&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):    </span><br><span class="line">        plt.plot(x, y[i], label=labels[i])</span><br><span class="line">        plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>():</span></span><br><span class="line">    <span class="comment"># y = a * tf.exp(b * tf.abs(x)) - tf.exp(tf.cos(c * x)) - a + tf.exp(tf.constant(1.0))</span></span><br><span class="line">    y = tf.<span class="built_in">pow</span>(d * x, <span class="number">2</span>) + tf.sin(x) + tf.cos(a * x) / a + tf.sin(b * x) / b + tf.cos(c * x) / c</span><br><span class="line">    <span class="keyword">return</span> (y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimize</span>(<span class="params">optimizer, iters = <span class="number">300</span></span>):</span></span><br><span class="line">    y = []</span><br><span class="line">    <span class="comment"># optimizer = tf.keras.optimizers.SGD(learning_rate=0.1)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tf.<span class="built_in">range</span>(iters):</span><br><span class="line">        optimizer.minimize(loss, [x])</span><br><span class="line">        y.append(loss())</span><br><span class="line">    tf.<span class="built_in">print</span>(<span class="string">&quot;Final x = &quot;</span>, x)</span><br><span class="line">    tf.<span class="built_in">print</span>(<span class="string">&quot;Final Loss = &quot;</span>, loss())</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># plot_f()</span></span><br><span class="line">    ops = [tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>), tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>, momentum=<span class="number">0.9</span>),</span><br><span class="line">           tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>, momentum=<span class="number">0.9</span>, nesterov=<span class="literal">True</span>), tf.keras.optimizers.Adagrad(learning_rate=<span class="number">0.1</span>),</span><br><span class="line">           tf.keras.optimizers.Adadelta(learning_rate=<span class="number">0.1</span>, rho=<span class="number">0.9</span>), tf.keras.optimizers.Adam(learning_rate=<span class="number">0.1</span>)]</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        x.assign(-<span class="number">29.0</span>)</span><br><span class="line">        y.append(minimize(ops[i]))</span><br><span class="line">    plot_train(y)</span><br></pre></td></tr></table></figure><p>当然，这个实验非常简单，损失函数形式是一维的，实际中的网络模型参数的数量可能达到百万级别，超高维情况下算法的效率、鲁棒性以及模型最终的泛化能力才是我们真正关心的。</p><p>最后贴2张神图总结下： <img src="https://img-blog.csdnimg.cn/20210306203509952.gif#pic_center" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/2021030620351970.gif#pic_center" alt="在这里插入图片描述" /> ## Research Adam虽然是集大成者，而且也被推荐为起始的默认优化算法，但是一些Paper揭示了Adam的一些问题。 ### 1 过拟合 Berkeley在NIPS 2017的一篇文章指出：如果一个问题有多个全局极优，即使从相同的初始值出发，不同的优化算法也会得到完全不同的结果。文章构造了一个简单的线性可分的二分类问题，证明了SGD在这种情况下测试误差为0，而AdaGrad等自适应方法会把所有的测试样例分为正类，泛化能力极差，也就是根本不能工作。</p><p>随后作者又用VGG+BN+Dropout的网络结构在CIFAR-10数据集上进行了实验： <img src="https://img-blog.csdnimg.cn/20210710193712619.png" alt="在这里插入图片描述" /> 可以看到：前期训练中Adam有优势，但SGD的泛化能力确实比Adam要好。</p><p>最后，为了彻底黑化Adam，文章又用了文本数据集和一些NLP模型做了实验： <img src="https://img-blog.csdnimg.cn/20210710193823396.png" alt="在这里插入图片描述" /> 即便有时候自适应方法的训练loss会更低，但SGD的泛化能力都无一例外地胜过了自适应的方法。自适应方法在训练初期速度很快，但是后期表现平平。</p><p>泛化能力差的原因在于：自适应方法倾向于关注稀疏的特征，因为这些特征对于训练样例的鉴别是很有效的，尤其在训练样例数少而特征较多的数据集中，但是这些特征其实并非关键特征，这样自适应学习率算法出现过拟合的风险就会增大，导致泛化能力不佳，最终的收敛效果不如传统的SGD。 ### 2 二阶动量波动 Google的一篇文章从数学上证明了在某些特定情况下Adam可能不收敛，因为二阶动量取的是某个时间窗口的变化，所以<span class="math inline">\(V_t\)</span>的变化可能会剧烈震荡，尤其在高维情况下，梯度的方差可能随时间波动很大，导致学习率震荡，模型无法收敛。这也是为什么一般<span class="math inline">\(\beta_2\)</span>要取0.999这么大的值，避免二阶动量有太大波动。</p><p>一般认为Adam默认的<span class="math inline">\(\beta_1\)</span>和<span class="math inline">\(\beta_2\)</span>不需要调整，采用默认的0.9和0.999即可。但是这两个超参如果不按这样设置，Adam可能永远不会收敛到最优值。文章从数学上证明了对任意的<span class="math inline">\(\beta_1,\beta_2\in[0,1),\beta_1&lt;\sqrt{\beta_2}\)</span>，都存在一个随机的凸优化问题使得Adam不能收敛到最优解。</p><p>为了避免二阶动量的剧烈震荡，文章对其进行了控制，提出了一个新算法AMSGrad确保模型收敛，<span class="math inline">\(V_t=max(V_{t-1},\beta_2V_{t-1}+(1-\beta_2)\nabla^2 f(x_t))\)</span>。</p><p>作者随后通过人造数据和真实数据进行了实验：</p><p>人造数据上的结果： <img src="https://img-blog.csdnimg.cn/20210710193934596.png" alt="在这里插入图片描述" /> 很显然在Adam没有找到最优解的这些数据上，改进后的算法都表现良好。</p><p>在MNIST上的效果： <img src="https://img-blog.csdnimg.cn/20210710193956571.png" alt="在这里插入图片描述" /> 这篇文章最终获得了2018年ICLR最佳论文，但是引起了很大争议。主要原因在于其构造的令Adam失效的数据在实际情况中出现的概率极低，即使出现也会在数据预处理时被筛掉，因此并没有特别广泛的实际用处。另外，文章过于强调训练集上的损失函数值，甚至有人通过复现表明文章提出的AMSGrad算法在测试数据上表现很差，与原文中的某些结论相互矛盾。 ### 3 学习率下降 arXiv上的一篇文章通过在CIFAR-10上的实验证明Adam在一些情况下虽然速度快，但收敛效果没有SGD好： <img src="https://img-blog.csdnimg.cn/20210710194231292.png" alt="在这里插入图片描述" /> 文章通过实验发现主要原因在于后期Adam的学习率过低，影响了最终效果。文章尝试通过控制学习率下界，提高了最终收敛效果。</p><p>既然Adam后期有问题，那么一个自然的改进就是前期训练使用Adam，用来快速减小loss；后期训练转换为SGD，用稍慢的速度寻找更佳的解甚至是最优解。但是这样也会引入新的问题：在什么时刻切换？切换为SGD后的学习率又该如何设置？</p><p>文章提出了SWATS(Switches from Adam to SGD)策略来解决上面2个问题，在CIFAR-10和CIFAR-100数据集上实验效果看着还不错： <img src="https://img-blog.csdnimg.cn/20210710194309531.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210710194329636.png" alt="在这里插入图片描述" />这些文章都采用了一些比较极端的数据去探索Adam的不适情况，然而实际中遇到这些极端情况的概率并不大，因此Adam并不失为首选尝试。通过上面的讨论可以看到：SGD和Adam各有优劣，精调后的SGD一般最终会收敛到更好的效果；Adam在训练前期收敛速度快，在稀疏数据上表现更好，对超参不敏感，不需要十分精细的调参。</p><p>如果对优化算法不熟悉，可以先尝试SGD+Nesterov Momentum或者Adam；如果对某个优化算法很精通，那么调参就会相对容易些。如果资源足够，也可以尝试L-BFGS等二阶优化方法。另外，选择之前要充分了解数据的性质，对于比较稀疏的数据可以优先尝试学习率自适应调整的算法。</p><h2 id="reference">Reference</h2><p>[1] CS231n: Convolutional Neural Networks for Visual Recognition. lecture 8, Stanford University.<br />[2] The Marginal Value of Adaptive Gradient Methods in Machine Learning. NIPS'17<br />[3] On the Convergence of Adam and Beyond. ICLR'18<br />[4] Improving Generalization Performance by Switching from Adam to SGD. arXiv<br />[5] Optimization methods for large-scale machine learning. SIAM Review, 2018.<br />[6] Optimization for deep learning: theory and algorithms. arXiv, 2019.<br />[7] Understanding Black-box Predictions via Influence Functions. ICML'17.<br />[8] Understanding Deep Learning Requires Rethinking Generalization. ICLR'17.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradient Boosting</title>
      <link href="/2021/06/17/Gradient%20Boosting/"/>
      <url>/2021/06/17/Gradient%20Boosting/</url>
      
        <content type="html"><![CDATA[<h2 id="gradient-boosting-regression">Gradient Boosting Regression</h2><h2 id="gradient-boosting-classification">Gradient Boosting Classification</h2><h2 id="xgboost">XGBoost</h2><h2 id="决策树集成">决策树集成</h2><p>集成学习可以组合多个基学习器，产生更加优异的性能。将决策树（如CART）作为基学习器，结合每个基学习器的预测结果作为最终输出，就像<a href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html">下图</a>这样： <img src="https://img-blog.csdnimg.cn/2021061621501811.png" alt="在这里插入图片描述" /> 正式一些的表示： <span class="math display">\[\hat{y}_i = \sum_{k=1}^K f_k(x_i), f_k \in \mathcal{F}\]</span> 其中，<span class="math inline">\(K\)</span>是决策树个数，<span class="math inline">\(f_k(x_i)\)</span>表示第<span class="math inline">\(k\)</span>个决策树的预测值。</p><p>为了定量描述模型参数与训练数据的匹配程度，我们还要定义待优化的目标函数： <span class="math display">\[\text{obj}(\theta) = \sum_i^n l(y_i, \hat{y}_i) + \sum_{k=1}^K \Omega(f_k)\]</span> ## Boosting Decision Tree 集成多棵树的方式可以是Bagging，也可以是Boosting。Boosting的motivation是用一棵新树不断拟合当前的集成模型与真实值的残差，拟合后将该树也加入模型中，即所谓的Additive Training： <span class="math display">\[\hat{y}_i^{(0)} = 0\\\hat{y}_i^{(1)} = f_1(x_i) = \hat{y}_i^{(0)} + f_1(x_i)\\\hat{y}_i^{(2)} = f_1(x_i) + f_2(x_i)= \hat{y}_i^{(1)} + f_2(x_i)\\\dots\\\hat{y}_i^{(t)} = \sum_{k=1}^t f_k(x_i)= \hat{y}_i^{(t-1)} + f_t(x_i)\]</span> 好了，接下来的问题就是每次迭代时的那棵新树<span class="math inline">\(f_t\)</span>要怎么训练呢？一个直观的想法就是选择那棵令目标函数最小的树： <span class="math display">\[\text{obj}^{(t)} = \sum_{i=1}^n l(y_i, \hat{y}_i^{(t)}) + \sum_{i=1}^t\Omega(f_i) \\          = \sum_{i=1}^n l(y_i, \hat{y}_i^{(t-1)} + f_t(x_i)) + \Omega(f_t) + \mathrm{constant}\]</span> 我们先选择MSE作为损失函数，看看会发生什么： <span class="math display">\[{obj}^{(t)} = \sum_{i=1}^n (y_i - (\hat{y}_i^{(t-1)} + f_t(x_i)))^2 + \sum_{i=1}^t\Omega(f_i) \\          = \sum_{i=1}^n [2(\hat{y}_i^{(t-1)} - y_i)f_t(x_i) + f_t(x_i)^2] + \Omega(f_t) + \mathrm{constant}\]</span> 虽然MSE的形式比较友好，但是如果选择其它损失函数就很难有上式那般人性了，吃得太饱的同学可以试试logistic loss： <span class="math display">\[L(\theta) = \sum_i[ y_i\ln (1+e^{-\hat{y}_i}) + (1-y_i)\ln (1+e^{\hat{y}_i})]\]</span> 为了增强可扩展性、便于计算，一般采用损失函数的二阶泰勒展开去做一个近似： <span class="math display">\[\text{obj}^{(t)} = \sum_{i=1}^n [l(y_i, \hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i)] + \Omega(f_t) + \mathrm{constant}\]</span> 其中，<span class="math inline">\(g_i = \partial_{\hat{y}_i^{(t-1)}} l(y_i, \hat{y}_i^{(t-1)}),h_i = \partial_{\hat{y}_i^{(t-1)}}^2 l(y_i, \hat{y}_i^{(t-1)})\)</span>。 扔掉所有常数项，就得到了第<span class="math inline">\(t\)</span>步的目标函数： <span class="math display">\[\sum_{i=1}^n [g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i)] + \Omega(f_t)\]</span></p><p>弄完了training loss，接着还得研究下正则项<span class="math inline">\(\Omega(f_t)\)</span>，首先得给<span class="math inline">\(f(x)\)</span>来一个正式点的定义： <span class="math display">\[f_t(x) = w_{q(x)}, w \in R^T, q:R^d\rightarrow \{1,2,\cdots,T\} .\]</span> 其中，<span class="math inline">\(w\)</span>是叶子结点的得分向量，<span class="math inline">\(q\)</span>是将样本点映射到对应叶子的函数，<span class="math inline">\(T\)</span>是叶子数目。 如果有点抽象，就看看上图中的左子图吧：<span class="math inline">\(w=[2,-1],f(男孩)=w_{q(男孩)}=w_0=2\)</span>。</p><p>模型复杂度的具体定义随你了，XGBoost是这么定义的： <span class="math display">\[\Omega(f) = \gamma T + \frac{1}{2}\lambda \sum_{j=1}^T w_j^2\]</span> 就用上式重新写出我们第<span class="math inline">\(t\)</span>步的目标函数： <span class="math display">\[\text{obj}^{(t)} \approx \sum_{i=1}^n [g_i w_{q(x_i)} + \frac{1}{2} h_i w_{q(x_i)}^2] + \gamma T + \frac{1}{2}\lambda \sum_{j=1}^T w_j^2\\= \sum^T_{j=1} [(\sum_{i\in I_j} g_i) w_j + \frac{1}{2} (\sum_{i\in I_j} h_i + \lambda) w_j^2 ] + \gamma T\]</span> 其中，<span class="math inline">\(I_j = \{i|q(x_i)=j\}\)</span>表示第<span class="math inline">\(j\)</span>个叶子中样本点的索引集合，由于任意一个叶子中样本点得分相同，因此上式写成了对<span class="math inline">\(T\)</span>个叶子的求和。</p><p>令<span class="math inline">\(G_j = \sum_{i\in I_j} g_i\)</span>及<span class="math inline">\(H_j = \sum_{i\in I_j} h_i\)</span>，就有了一个相对简洁的表示： <span class="math display">\[\text{obj}^{(t)} = \sum^T_{j=1} [G_jw_j + \frac{1}{2} (H_j+\lambda) w_j^2] +\gamma T\]</span> 因为叶子之间相互独立，所以令目标函数最优的得分向量<span class="math inline">\(w\)</span>为： <span class="math display">\[w_j^\ast = -\frac{G_j}{H_j+\lambda}\\\text{obj}^\ast = -\frac{1}{2} \sum_{j=1}^T \frac{G_j^2}{H_j+\lambda} + \gamma T\]</span> 目标函数<span class="math inline">\(obj^*\)</span>的值衡量着本次迭代树结构<span class="math inline">\(q(x)\)</span>对训练数据的拟合程度。</p><p>云里雾里一大堆，我都烦了，来看个例子： <img src="https://img-blog.csdnimg.cn/2021061716123725.png" alt="在这里插入图片描述" /> 假设在第<span class="math inline">\(t\)</span>次迭代选了这么一棵树，按照if-then规则将训练样本分到相应的叶子，将梯度信息相加得到每个叶子对应的<span class="math inline">\(G,H\)</span>，接着用<span class="math inline">\(obj^*\)</span>计算这棵树最小的损失，不行就换一种树结构，以求减小<span class="math inline">\(obj^*\)</span>。</p><p>忙活了大半天，终于知道了怎么度量一棵树的好坏。那么只要枚举所有可能的树结构，选那个令<span class="math inline">\(obj^*\)</span>最小的就好了。傻子都知道这是不行滴，所以只能贪心地一层一层地剥开你的心...哦不对，一层一层地优化：将结点分类为左孩子和右孩子的得分增益为： <span class="math display">\[Gain = \frac{1}{2} \left[\frac{G_L^2}{H_L+\lambda}+\frac{G_R^2}{H_R+\lambda}-\frac{(G_L+G_R)^2}{H_L+H_R+\lambda}\right] - \gamma\]</span> 其中，第一/二项分别表示左/右孩子的分数，第三项表示原始节点的分数，最后一项表示增加叶子的惩罚。可以看到：如果分裂后的得分增益小于<span class="math inline">\(\gamma\)</span>，就不要继续分了，凑合过吧...</p><p>为了在每层获取到最佳的分裂点，通常先将训练数据排个序： <img src="https://img-blog.csdnimg.cn/20210617164041605.png" alt="在这里插入图片描述" /> 暴力枚举一遍分裂点找最优就可以啦！</p><ul><li><span class="math inline">\(f_0(x)=0\)</span></li><li>对于第m棵树的训练：<ul><li>首先计算每条训练数据的残差：<span class="math inline">\(r_{mi}=y_i-f_{m-1}(x_i),i=1,2...,N\)</span></li><li>接着通过拟合上面得到的残差数据，训练出回归树<span class="math inline">\(T_m(x)\)</span></li><li>此时第m棵树的输出即为<span class="math inline">\(f_m(x)=f_{m-1}(x)+T_m(x)\)</span></li></ul></li><li>进行M次训练后得到最终的模型</li></ul><p>可以看到：Boosting Decision Tree每次迭代都将上一轮预测结果的残差作为当前的训练集，对于平方损失容易求得损失函数最小值的点，但是对于稍复杂的损失函数，残差的获得就只能通过负梯度<span class="math inline">\(\frac{\partial L(y_i,f(x_i))}{f(x_i)}\)</span>去逼近，这就是GBDT的核心思想。 GBDT的训练与Boosting Decision Tree很相似：</p><ul><li>初始化弱学习器<span class="math inline">\(f_0(x)=\underset{c}{arg\ min}\sum_{i=1}^{N}L(y_i,c)\)</span>，如果损失函数是MSE，那么<span class="math inline">\(f_0(x)=\frac{1}{N}\sum_{i=1}^{N}y_i\)</span></li><li>对于第m棵树的训练：<ul><li>计算负梯度：<span class="math inline">\(r_{mi}=-\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)},f(x)=f_{m-1}(x)\)</span></li><li>得到新的训练集<span class="math inline">\((x_i,r_{mi})\)</span>，训练产生一棵新的回归树，对应的叶子结点域为<span class="math inline">\(R_{mj},j=1,...,J\)</span>，<span class="math inline">\(J\)</span>为叶子结点个数</li><li>对第j个叶子结点，计算最佳拟合值：<span class="math inline">\(c_{mj}=\underset{c}{arg\ min}\sum_{x_i\in R_{mj}}L(y_i,f_{m-1}(x_i)+c)\)</span></li><li>更新强学习器：<span class="math inline">\(f_m(x)=f_{m-1}(x)+\sum_{i=1}^{J}c_{mj}I(x\in R_{mj})\)</span></li></ul></li><li>最终的学习器为：<span class="math inline">\(\hat f(x)=f_M(x)=f_0(x)+\sum_{m=1}^{M}\sum_{j=1}^{J}c_{mj}I(x\in R_{mj})\)</span></li></ul><h2 id="implementation">Implementation</h2><h2 id="properties">Properties</h2><ol type="1"><li>extrapolate问题<br />众所周知随机森林回归是不具备推理能力的，那么XGBoost可以吗？<br />答案是可以，因为梯度提升模型并不直接根据训练集的结果做预测，而是通过一系列树的加和得到，加和结果取决于每棵树的权重，权重则是由损失函数的一二阶梯度优化得来，并不依赖于训练集的上下限。</li><li>缺失值问题<br />GBDT/GBRT自身不支持缺失值的自动填充，例如使用sklearn中的GradientBoostingRegressor在训练数据包含缺失值时将无法训练，人工填充可能会引入偏差，但是XGBoost却可以自动地处理缺失值（但并不是填充）。<br />根据陈天奇大佬的说法：</li></ol><blockquote><p>Internally, XGBoost will automatically learn what is the best direction to go when a value is missing. Equivalently, this can be viewed as automatically "learn" what is the best imputation value for missing values based on reduction on training loss.</p></blockquote><p>那么究竟是如何自动学习最佳的分裂方向呢？<br />假设在结点A有50条训练样本，并且该结点只有一个可能的分割点：比如只有一个二元特征x，那么分割点就只有该特征取值为0或1，这样训练数据可以被分为3组：</p><ol type="1"><li>x取值为B的20条样例</li><li>x取值为C的20条样例</li><li>x缺失的10条样例，叫做M组</li></ol><p>那么M组的样例会被分别赋到B和C，接着计算<span class="math inline">\(\{(B,M),C\}\)</span>和<span class="math inline">\(\{B,(C,M)\}\)</span>的得分及损失函数衰减，两者中选择损失函数衰减大的。<br />如果使用MSE作为损失函数，并且B的标签均值为5，C的标签均值为10，M的标签均值为0。<br />如果使用<span class="math inline">\(\{(B,M),C\}\)</span>：<span class="math inline">\(\frac{|M|}{|B| + |M|}\text{mean}(M) + \frac{|B|}{|M|+|B|}\text{mean}(B) = \frac{10}{30}0 + \frac{20}{30}5 = 3.\overline{3}\)</span><br />如果使用<span class="math inline">\(\{B,(C,M)\}\)</span>：<span class="math inline">\(\frac{|M|}{|C| + |M|}\text{mean}(M) + \frac{|C|}{|M|+|C|}\text{mean}(C) = \frac{10}{30}0 + \frac{20}{30}10 = 6.\overline{3}\)</span><br />最后计算两者的MSE与划分前MSE的差，选择使得MSE下降更快的作为分裂方向（也就是得分gain更大的方向）。</p><p>在寻找最优特征分裂点（如年龄＜20还是年龄＜30）时，只访问该特征不含缺失值的训练样例，即如果年龄缺失，就不参与20和30的决策，这样计算复杂度也就降低了，尤其是对于稀疏数据。</p><p>预测时的缺失值有２种情况： 1. 训练阶段已经见识过该缺失值了：按照训练时选定的方向往下走就行 2. 训练阶段该特征没有缺失：默认走向右子树。</p><p>Ref里还有一个更加全面的例子，训练集有6个小孩，只有一个特征年龄（其中有2个样例年龄缺失），标签是身高，初始预测值为0.5，接下来每棵树都要拟合残差。</p><table><thead><tr class="header"><th>Age</th><th>Height</th><th>Res</th></tr></thead><tbody><tr class="odd"><td>7</td><td>130</td><td>－129.5</td></tr><tr class="even"><td>9</td><td>148</td><td>－147.5</td></tr><tr class="odd"><td>6</td><td>115</td><td>－114.5</td></tr><tr class="even"><td>15</td><td>164</td><td>－163.5</td></tr><tr class="odd"><td>？</td><td>125</td><td>－124.5</td></tr><tr class="even"><td>？</td><td>140</td><td>－139.5</td></tr></tbody></table><p>接着要根据年龄特征寻找最优的分裂点，将年龄排序并选择中点（<strong>注意：这里就不考虑缺失值样例了</strong>），因此候选分裂点有6.5，8，12，对于每个候选点，分别计算将缺失样例划到左子树和右子树的Quality/Similarity Score：</p><p><span class="math display">\[Quality\ Score=\frac{(\sum residuals)^2}{\#residuals + \lambda}\]</span></p><p>比如，对于分裂点6.5：<br />如果划到左子树： <span class="math display">\[Gain＝划分后的Quality\ Score－划分前的Quality\ Score \\＝\frac{(-114.5-124.5-139.5)^2}{3} + \frac{(-129.5-147.5-163.5)^2}{3} - \frac{(-129.5-147.5-114.5-163.5-124.5-139.5)^2}{6}=640.7\]</span><br />如果划到右子树：<span class="math inline">\(Gain＝划分后的Quality\ Score－划分前的Quality\ Score＝580.8\)</span></p><p>接着对于8：1083；630.8<br />对于12：874.8；216<br />从中选择gain最大的（也就是使得损失函数最小的），分裂点选8，缺失值划到左子树。</p><h2 id="bug">Bug</h2><p><a href="https://www.lycecho.com/archives/2364">PYTHON XGBOOST 报错 KEYERROR: ‘BASE_SCORE’</a></p><h2 id="references">References</h2><p><a href="https://www.youtube.com/watch?v=3CC4N4z3GJc"><strong>Gradient Boost</strong></a><br /><a href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html">Introduction to Boosted Trees</a><br /><a href="https://datascience.stackexchange.com/questions/15305/how-does-xgboost-learn-what-are-the-inputs-for-missing-values">Missing values in XGBoost</a><br /><a href="https://stats.stackexchange.com/questions/304962/is-is-possible-for-a-gradient-boosting-regression-to-predict-values-outside-of-t">Is is possible for a gradient boosting regression to predict values outside of the range seen in its training data?</a><br /><a href="https://datascience.stackexchange.com/questions/77234/can-boosted-trees-predict-below-the-minimum-value-of-the-training-label">Can Boosted Trees predict below the minimum value of the training label?</a><br /><a href="https://github.com/dmlc/xgboost/issues/1581#issuecomment-249853718">Why does XGBoost regression predict completely unseen values?</a><br /><a href="https://medium.com/hypatai/how-xgboost-handles-sparsities-arising-from-of-missing-data-with-an-example-90ce8e4ba9ca">How XGBoost Handles Sparsities Arising From of Missing Data? (With an Example)</a><br /><a href="https://www.youtube.com/watch?v=OtD8wVaFm6E"><strong>XGBoost Regression</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learn to Learn</title>
      <link href="/2021/06/03/Learn%20to%20Learn/"/>
      <url>/2021/06/03/Learn%20to%20Learn/</url>
      
        <content type="html"><![CDATA[<p>上了十几年学，依然不会学习。不知是因为中学一些糟糕习惯的延续，还是当代知识难度的加深，我总是感受到日常学习的辛苦：身体累、脑子累、心也累。</p><p>刻苦的确是一种很好的品质，但这种品质有些时候未免有些夸大其词了。傻傻地机械地重复在中学时代那种应试环境或许可以带来一些成绩的提升，但是显然已经不适应现在的我。我尝试将每天安排得满满当当，恨不得每一分每一秒都在学习，然而效果却并不如人意。</p><p>除了智力等一些先天因素外，我个人觉得有以下几点问题：</p><ol type="1"><li>没有找到合适的学习方法，缺乏深度思考和知识体系。我总是试图单点单点地掌握未知的知识点，试图掌握每一处细节，甚至使用死记硬背的方式处理核心问题。笔记和博客也多是摘抄型，独立理解实现太少。</li><li>效率低下。尽管学习时长可能足够，但是且不说大多时间都在摸鱼，即使纯粹学习时间也经常犯困，无法专注完成手头的某项任务，总是过于频繁地切换，某段时间总想做好多件事。效率*时长=最终效果自然不会很好。</li><li>单打独斗。周围少有一起交流进步的伙伴，遇到问题只能单向地从互联网获取信息，没法通过讨论等形式取得快速进步。</li></ol><p>最近看了Marty Lobdell的一个演讲Study Less, Study Smart(<a href="https://www.youtube.com/watch?v=IlU-zDU6aQ0">YouTube</a>/<a href="https://www.bilibili.com/video/BV1Pz4y1f7oi">B站</a>)，有些启发，但是如何学习这种事是绝没有普适准则的，只能结合自身实际摸索总结。Marty还写了一本同名的书，内容比演讲稍微细化一些。</p><p>Marty认为比较重要的有：</p><ol type="1"><li>番茄工作法。每学习25~30min应该休息5min，可以听一首音乐、出去上个厕所、吃点喝点、回消息等等，这样再次回来后注意力和效率又会回升到一个较高的水平，而非效率指数级下降的持续长时间学习。完成一天的工作后，对自己进行更丰厚一些的奖励，比如看个电影、吃顿大餐等等，以形成正反馈。</li><li>寻找一个专门的学习地点，书桌是用来学习的，床是用来睡觉的。Intend to learn rather than incidental learn.</li><li>费曼学习法。看完材料后，深加工以后尝试用自己的话复述给别人听，能准确复述或者能把别人讲懂才行。</li><li>对于学习材料要SQ4R(Survey, Question, Read, Record, Recite, Review)，要主动理解思考自己的笔记，产生更加深刻的认识，而非机械地摘抄背诵。</li><li>高质量睡眠、高质量运动。</li></ol><p>结合自身缺点和学科特点，我认为可以有以下改进措施：</p><ol type="1"><li>每学习一个新东西，理解算法流程、数学推导、实现细节等确实重要，但更重要的是领会方法的思想动机，掌握优缺点和应用场景，将其纳入知识体系中，也就是所谓的“解决现实问题的能力”。</li><li>合理安排学习计划，劳逸结合。不要安排得过于紧密，也不要过于松散。制定的目标不能模棱两可，要有可评估性，即某段时间里要扎扎实实做完TODO LIST上的某件事。</li><li>组队学习，提出自己的问题，解答别人的问题。</li><li>累了就休息，不要在低效率状态下学习工作。</li><li>科研，自学和生活尽量分离，一段时间只做一件事就不错了，不然会非常拧巴，非常累</li></ol>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生永远艰难</title>
      <link href="/2021/05/23/%E4%BA%BA%E7%94%9F%E6%B0%B8%E8%BF%9C%E8%89%B0%E9%9A%BE/"/>
      <url>/2021/05/23/%E4%BA%BA%E7%94%9F%E6%B0%B8%E8%BF%9C%E8%89%B0%E9%9A%BE/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8892a404ecfaf581173c7c2a774af476a8cdc82c403a9510a7b2cad7e17c16b8">c172f4ee74b2b6d246b20cbfdc0b877e38d8a34e1cf0769d6fb32347a9e58283214dc7e19e6e1b5ac3814e48185c91163e9e02153bdba3445cab5142f6f4ed0ac5a17fa873d23daf631dd0bb2e708a9be0c2b65e291c5d78278ae85e1e871c82e3e279b6c6d0a8d1846a9273b6a5a2ea53b6b3113fecddbbc42a031e35d4aa4c0a534d078e7255e0e73abf79c7cf854ae2a7c1d117d0321a3d33aaf88bb661472b1c4fff419f3c28678469d34fb7fbd51d0cdd73b2942f4e227f6656b3382c65f2eba2284a283897b2feea7661d2a70c8125f2ab8aac987792920862d892605d91c56273c73dc481fe55c29f2942554ae23b1e83f5e1187d4783a643a678af13b969ec0bf66c8ba496ee2bfe069168edb8f773bbfbfcdf0d05089f302ea1c527ecf47d460d50e3d6fd894165c486bd1128c0bbfa219d0997f2c3b81a40b3fd4ba17662f0010aba19fc7fd5c992ded4dc164c18d794e12d73282701068713dbc398cdafc42456e425ee8874b21a38aa07bfb333fed0f25e165372f25d82786a7a1e787aa3a24246471330b39acc78d2ed838f200c9ddbaab2b70f27be576392307707486d9dfc0120c76152918576162802c8b105e32f76046cc774797e21808ee57942a6f85451e6e679b2c8dcd0bf0fb97190e34100ea4db2d7655ea404689f4ffd4ab95b17c165796d524ab10492b5667781e33a1800cc799e598f9f0cca52203cdcf0c0c7a118ce7667d5d9b07805a0943e837f4c6c958c3410e3d1e143dcf865d78869cdeca1032b8b04942ce46bc03c02b2d0dd3263aa1b6c35ff13a87d396d769fd479488d83620264c7bc9172101e9db8a83dee1245f30f2d9658b090c29cf35f9d6c6574b67786ed41192015fb75ca739a780331250d1088f1eabf73c1c2970ffb8162daa21164979a794e34b9c1bb75823fa52332d0c4ee15d60d86fcb9ba96a2ca421d1f1ed52e6e18f7062d79b762785c89d4c3056a1717c70422b13164addc0aef451a22a4ae501fe6e1d0beb8b0cd7b011aa01289e95c29b9eddad7d358d2bf04dc9626fc3d5b42249f3cb6499fc61cad3e02f0abb81c108d7fe499d399c6efc7ba8057d22b82d6f6f76f84d211f8fd5c57763ac372e46b7e3b3547c946bb380dc4c25c27b40744b1d75ba00d6de932ba6fa152a5f17f1bab1339c299e62713da2f0843aef00748e44c90a71b0ceb895e44ae9f0bbe34a5190fc20b1205e6529092a5265af0ac0fa32d6044629ab02115ed69d2918b57b85181cdaf04537d30ce6611c5ff04fdb5841c2b5b9c3260c446d12b9439e481863ed210c608d69325e6f5748c6a41643d25931cbeb4195b62d331563450b1171b31df4f144641513a3fe28538b4d65b0911825ee7f83f1c9680130d4c07e24ab87f2600253bcf88da43ea218fc4b450621f5c917af8215a8cb9432895aa30ff717064e0cd1692c98f743b7fd4d4be84ef4e52811ad97f50c4278f6b9db44c9911437c63b8956ea57eec423af9d38ef224c68b67f4ca25f4dd20b2f65d5b29f0d15688da6356d6510c94a310fcb01e92133475664cef6dba5d8ee8794343b739e8872e7961c355cc1d1bab434e19940183414115e851c97e9cf2b5769a10f0075cac55c29620cfd667faed976b586cf068a36e533e94a5a134b93a752bd1c56c8cd1c99464dc07e8800424aee5a225b6ced354ea589aee1fa83e7dc80dcb39ac549e00a449cade1548afaab165d9b022cc9f3f9b0d55f38a2aa4767687a6888cc18e5284d61837c685745a1ca00fe3d210768b370308ae4ddfdd847963cd54d1be0b50a40b72cb8ba6a00135a5b91e00c3b1c9476eae4bbdd42718734647d495da7b52864aee7b2de642ece420632c87bb14cff4a4aee8ee999fedc9f08756568315eacaf8bd44433d739795f6c45bb9a9465228de244c9b2cdf7f325fa9570737ac413b8f7909248b0c368ff7ec3710020684934704d471b43d5671cf1bbb6c53fa0641c82bb1196de744956748295231260e61b0a5dacd1c35478648007641da5f98f8353246b809427fca86524c548b240d74e602b5357a9cc10c48d7fd65665558377108262d0133570fbc92deea953b201daccef867003a124de70eb7d06831c5d7b24ade51a29afca64423d84ff136a0c83f02fa06cc0bf453065c2a63b02e8bedd5d28106a883ac64347ce9d4a7172d4b5b70302e3ca10c13c977f2ffd6a19efd0ac1c3bb9e20fb07489b828cb5d07185dfa30461aaad1b31bd18b4aaaf2ffaa039c48f3a61ed4b99393bf63a56da216aa8e92ed5830da829c2540645d3b143f71bededb14b4c216917571aa86f97ab42e0bf6790b84ed9fa457b2c281c14249b8d4e622ff16b6f0ca8727831f5d6eaeb062ee9a281442866eb0aebf81aeae144b34007e81f5f57c2ade73697a2c7dc911a294265db8da4189c36aff81817af608b670f7e8b5758aedbd9800ee414ea2975971a0ea2ca3331a96230a5c984917096a18a2294d77368b4d1cc4e8795a03780ca1da0267032cdb7de86a47f55c010f246a5c064d5e29ed3aee0010f48890c8d487c59c4761e6568638c3c61c193166115b3d0da6772246b93dc3120586af8399fe03284f822f9ec12c65a288de7cec6f4302ea8d6a70b898ed20b3606613a3c1ac803882fa315966c46a09d9edb7d2359395c77054dcfa89e86296afe56e70a6c7fa7ad68bbcff6a13f03d109baaea33be9c5d415c0b0088aafcc838e655a224dfb581a8ac531360d84cae8ba2bf0352e8893743987b3599caeff78f33fee6c83ac5be838014332d2cc00abec4a2264b6dc6ef0e25747117b346242454acf3e571a44ec68b2ca0c796db85e00f71d2d652b41477cfc59aa23882dfeace12939e119eca58c0cb0154beb8e82e58eb11a2bea6c4db64f1e79bc6af28022e4e1c9342407e5e421047965b94e4e87042a72cdc611f12e1a7fc9f3e13a0132121b289381682f1b8cf0416c35b250279961dd06b84a6f99d74b8570d4329db850659b35e8d79a0ac2dc7862afae152edfb1b45f2476093e3887a648599a0d43c407fcd65dbbeb9119b15b5a3ba4930490d902ae9566c818ada90e36bef86bbb98f551e07513d20d863d12d649cb8a958bdf9563eb86d849071b1ddc501311e5d6f3666a23611e946a0ec174dea01492bd8764d1af1963a72700de7edb66ff2c7d798559d78ac9bf82ce85874b36c6093056f4cc30d9e292fa3e352de7eed2de173e4130e6a6f3b329079e2f609d305289d7f64dcb6c04d42c0905298d5781af66278ab63d9bb4cdfdccea9c67ca769f111d0ba1a240700b750de3ce5c74f1cd572beabaad8d8ad5791a824b3ff0c8dec7a9b43a964047a90b30a736d22695ad540d8cb8f15a1fabab6b5eb5a23f7f3956c9d5ae36cdfdabb154319b70ce1137dfb0b8e7dbeeba0fcfbfb4c387221280537d4a78a9d3994b69a7f04124ae8c95aee32b6752a9e9b833e38444c07bcfc791f85d179ce4a79ef718a38aa46dcdb1154aecd8d4529512b448f70c20a19f205d37d80577329c1094aafdc3438b9061afd99b1fbf58450bd0a7431e7b4bdc7ea86fd6bdf3f5d6fdf2cfc0b8aa23c2c15a11b43c052d72ab65d5b4b7ffed2817906106698ee1382d8fce68a27bbe7393b663ea7488584e3129a62dfb45fd7d98addb2f3e9cd8457a585c07e1cda6a8cc438bba44a2acd255c8a1aee2a39ffa9ead1e40ffae8c28f38ea34c70d0e23a8ad6882efa273f0af678d9ab48718f83bb8d0fc8f07e62134f6cbd0f27c24146c4331bfa7d18f7b64db262fcca34503258fa403c1a6b323c0fdb88a40b50447b5210954df7af76f04750a19409e84cdef94bda150559fd4f90f0358246d5b2c44ff48bc3e182ddca3f97a47cdac77c3b4ad076aaf5ab4a31563ef099e31ab84d0dd982047ad068734e5de9fd13738a4261961cdeb06d5ecfb010edacef932d1b87fcd2e636abe78550cf24da80b3de1be751ee3850c8b6f2c79cf74a75762ccf9aeeffab037d0bb76e78b6cb972e9ea37ecb1b10465745049de5515d4ccd124aa29752a7f63368966e411fa81ed7f7cc762ef24fa351a91983bf45e4a50d38f9050b675b5b280356f10447105a1e6723739e71bb0ed50a7f14d2b72dda25a1b6b5e4f3bdf685d69d249f6801af9ebc54322e2e83fcf962b486d2e824ad942cfc449c1830c6a02b5a46e53eb3c2de8aa20ed574f18dd0aad7b01f3cda802f23f5c195c4910ceb2077cc1cc26aa321273ae4d34c96868f7054fed8cffe16b5419da9450896459bc0ea96dc5cd4466121afcd99b0ff087d222b6109f2df36b26ca0bfaa2201575cc436fb9699bfdb1ec09d045ebec8267b51ba504e4fbd5c69d7174c9c427e9edb0fa9713c5874e8e94bdc76e2ae774d0875f5cb11bf2d8ab4e4e1dd1bc29229a7af4b32d47b03db940c41d6d0ff76680ae0a331a1ce9498dd91c920045936a18ca3aa2464ba6658020156dad3c7630e8c9b1a9f223d9689aeb23ad0a96735b080721dc281c720a89717657016e973d925e2a1255c695ecae57b806596ceeac43ae558922959924396d3692739707b8136f07d5c7c98221c68b7e93cf2bd6ddbaff9db5328c3a4bfacaa753ab8f866ed4969c3d346b95cca85b24f4333394ff264695f457f90053ad6b89aec259a061494df3793a34a537ec589e64e12d11b19cf31d02dd5abe650863263df9a8d90df10612af41095180ecf7447e2a01e788c2816d08c7959c68f0a6208626cb5c0a155a280f3a6863caa40f020cfb101d1478c7d3a48178f2ed16b60ca5ef0b958f9ab3708a7a6674b80fab4b5935d6e33beb7b51ace8a1d5e5e555e97ec33b675a45a3e628e9091b4bad1809c7670dd240b6587daf0d4efaa93a13c9357ce87389cea02699c52e461a13dfa4d000269a26ecdf117e84b9c5258eabe37e1e2049b02221bc7f344afdf5b03db0db183604e27bb75606fccdd58f86cdfeb6106b3f720920ce670347317280d140a201ba421e11dd3a1cae412e338f71d7c9f8c2cb099dc5b85c7c9b31f8d51b051e9a27d56cae153d6f0095829752e448abac1eee7e0b032746cf4c1c097885f9180e5564d85ae74fc8cce2d269cd5d8820ad051b4fda6c49ff570b2fc79bb132858a180209bc0f9a0f9927f0bfaffb553ea9b90bdb636be43de256b27bcb56e7aa139aaccfe80a8514c2b58701129a9827a4b05f84edb6af1c94be9c82e67b4cb8b864400a4f3c2606b6f6a31211d085d52024d8b01dc45207bcdf1d8aff17716ad0c8169cd50d9cb5f8b607d72245daead2275b2f4182fdf480b21d02e5abe8a0fc072c9e33b6ada8e1e9539dc402cf15ea317abdfd7d84d55c75a644edc4dcc02a03ec8cfc2b44f4aac0e24065f0f941b223cfab578d9518a39151b3d60f4d90360d33363f8c454ef8f8e00bf9250a0853ae806e13bb361aa9dac0a31a0faf8bb85d7c3322a44c12016fc5013762b5436e75671a29408c9295e8a0c0dbdb751f9c8579cf02ee0a794694db8e16a73b63e6bc04cd8b37c9c76db1243ae654486db8c0ef9d299757c2e9bc732ce26e8a05f285498763c97751a11eb2fafdfa72be43a0cc649637fa99a4724cddabf8ffdeb4c601459cb746e258e08bebf60555d0a4609c0393d73fe17d7ccd3ca5184f6f60f9b1a627ff77d980c6b60e9e991c9ac0335fb5e984681cc1cfce275efe685d52196f490fd9ca4479dd1939dec70f4ac2e4d48c21ee0467fc2b2a71ff58c65e85bf49fc39abba6b34d9616a6904b5d09b135ef9ec3236b361e0cc9215f1a8536097fd2a918189d37e3f10d76caf23a520a94af84c1eaa830444c0ff63b32a3a20c5c02e5fa245a38ee7ee1421205804ce4efabdc428865fc9ce67ed3bd82ff6621c8ddced035d620e3d56800e1ba093a14e3cc648a85522389a5a6a51a99e32cd76eeb92e3c36566157a739623d25554f854a94decb08c83f87c300a5d1b9e58d3f9c9ed327e8334ed68157be331b74fb9cb205940ef8ac02827c079e13fe14142bc787504a1959ea305ee25498b0494d9f01abab4850506dccc5a77f1bf9dfc5771d7f1d4a11dd51185e323572b9ab9fcd05586372c6f2b8375a1b808fb44ff36b1297cbb08b7060e15c90ab31ff41946c5d6d7e064889e32e3053ccc606b31ab58eb9c395c7bf40a3bd59c919ca9a948c854733d37381aad12531a4918afe74fd6a7bc20114b02b17f36b96e2b281ef33497bcbd494f55ea5cbd1a5cdc769ccf346c0ca47790e8e66dc8840f882e5300b4c98ed97aaa4779168abb5abb5fcedeb99f9de34a015111955ef84147b83de785c7673d2fe0e841d399b5a7b4c3460e466d5d86008b2888d376f7c6281b6505ead51397465854793490aaa5f5751dda6a106f442955a5082a04aec9784b04bbd3a3fc787394bf5d8e59d1992e468b4ccf1b56bd549a7e37bd37f79b26e0573e775c677b472f224caab02f5a91f12ec968abeae724f7773de57359b404640df7972842f55c1edc8e9e0128e073b2dd09e5b07c6472e443d7ab6f3a5a7818f89059adcf2ee4bbffda8aae45e47992146d99b5eab64fd8aaf9cf3887e564efe5057ad904079340497259316118ab8d79091fbe59c78a959d20a199d0774ed74a4c3e2bbcbf65ae2c87fcb7128e84b611d16b53bf9c4e101d0d975f165e604a0a44c584e126bde17b3a40bd6a14f950d14916795ee67daeb8dc3fc643e176b3200b56929e9f1c153d0374b56847852910cf5a6e7d0e92af714ca08239e9a05962495769ee924f53c3a66b06269152098ae3d632b2615f2a2971be1cf70faf6422f9a7d467e0478062bba1a53de6abc97beeb79aee5985b687878e1cbd674189d8bd128b8da154483575faa3a08bab86ff274ca28bfbb768d20c41ce64bbe4ee8bf2c1f9973fc9ac8f3300d1091686af5411f2747e1d9595fe9f31284032d8c33ff1b8d607f54a40c262f7eb18209a335d7a4aab86e164907e7d1290eeaed7f465e0a69503df4e5788c5159d2a0c7675c7b31e33922fb152177234c1966378c978652d2deb9584cc100fb7da40545190db411fda78d46709b968680c06b3cd59c38a7bb5b1ce84f5216aed5cd726866ab59ac1b9439937b62068a879f715732f484025a836ad377a04f91a35f0295aac556439db26bfb2694082f020ce5b9b21f53b3b21ea721d7c1bbf9a6c44c8a2f0b688bb748a517e122d269c2a4b52543dc570d9c0efbad411917a9e0055df1a29fcb2002dec2bb1bba4bd8efce7f54d9175437d2a70e76ca72ab5a7d4b73b9915f67a0707859420fd610050f609b79a710a3a435f496409695f3bef9380e33af3f488d31d5893f98194a6cb05d57529f73603b900df8cd3c660db553ad7e889a774d884278f81b93806555f30ba8b31e89efbb5141b0c81df1b177fcbea2faad719f465edb737f7d6015adf0cfc05d94690626e792f7b0a8b35cd1b3dc0442fa079ff995c8d76ab60cfffc7cbe667796309360705a2aa5a7ed6aea38f4b34f9cc415b075621ad4aa31952db42a8b829119f0423731ec568a3c3c4c6c6265342acd20f39fa40f57a5fa4034c2c06450545b08175f546cbc2849c6504b51fc5133694d4df205d38eef2edfc576a73536e9b384e3f76d8ebde7ce51f4bc8be28fa2a3176bb1b0ed2f2b9e3921b7e709191b4fc838708b76473e632df9b4a41259d0338429eb7a676c442c1d80ac379f68b4eab94a36d1ccf159a2e1e30dfbd1ac3ca034aa3865da2e77e1db5bff7e2ffcd3aaaa23fb2483c4575c6715e3cde3f1e85638b0f417ebc57b552757114eb2c8e9b99affb2be5986987e44d30893e5442ed9a4e4cbe53e5c950082f8e4d8fc0f15889cb67244a9508e8767bba12b435f09fcf707aaf527d1d101019ac0a0c320084032217553c4e350e41fbc7c3f41b19648a296c23f239306e269a160c097965ab64b19ef15dbfc4c1e0dd3f0d24c579922b150cc1e378ddf4ec896823f41e408ba43a51fd2c1466d81a2db14eb7136ad9d570e540d508fc43510add63035248fef3ded5e96b0c4a5cabd8fbbfbfb2051db4770d33f27f34f47c378fe1968244b81a893ad38b4d62f323100d937ff2c097b992478f96783d2d816d43f9c51d0ed550faab51bb3ea72e4ab9b8e107bced313ac25b94c36a0504515376ecc3ca19366f10f51419cf096663fa5aaf8aa38f23c316a6816a520068bfeace0052489ba7ed033b41d9e1e06465b1be5fa4db36dcbbdcd9e869eee31e030ab96217f7424aabe9574340f70ef4acacd125a52e4859a469c2eff3fda4e4766ddc45d38cd3700ce236c8c6a45ba3fe10e381f5e21212a06040531b81515e8b205e23ae140263a3208616372a82d2f5b58586a33a88d907ce515ee2e2d3430a8ed4bd27f69d8a44ea72cbaed110534b350f52f8100ca1abc82c13d59137615a747991f71603aeb86419eacb75dfca98f97f37c46535b92b09bf43533cd1701d83f32170038a1af8de97d8906a7f6d75e79b6c0acee3073591c40cb28bd803cfc97ce66fd4b52ddc64812507f01d8c31bcc2fc2e1bc03a8f30f5b046b62752c275aeb0617c2048a04660a0c3d18b24f2cdb63d20294851d3f9ad392b67883328ab8382823ce62b5e1598972c51443cb5c6bc2ddf36b71dbf0c2e63471ee445c624ddab5fdc62806d840aa1fc5ed797c2afcae37eef3fb134307a76d2ca217d0692537a49b46ca78ebffd2605012dba9d81b22469eb43df2cb145aa64f537c084b83a5bce663fbadd9cfe2d864045b4404f1a5e2fbc9e95196e09380dac0dc0ab2ce3d755d4f031a3857e943c90bf115e4b99d9ca963a1bcf87209d2309d42336b7c73d1aab2727e07a726c2cf40be835eb3cf3eca259c0eecf31e4996e53a6656431b8f7f31fbb142c52f425e79482084b5f212581ff3df4329da2cea59691fd84e5d46ba897f759dd57dea9c89ac7f4d2a4329c688dc094acb6e3227812036a4e59e4bed7f53fabf21fbc2af240bfbee5bf8171df828cde34da08275d5eba804d8c2bc6c574f61beb4f9c751cf8094a4f145857716dd1ae9504489b6804b25e5cbfdcb64e71aed02bed601f0216c1e8203207aa71366cf884d68005db23d59d947bc324e3c6c7d38cc410e722f09ee9de79af8c9b32f9253386c98d2bf3942d5ff50b2bb124a5f283ad563e7ab9ebb9a0b282ab70cc527a1a5ef20f1a76dbf641efbff3de8ea285400cc9c88eb6a7ae1563b2d00c7669e5836fa329ae5b1a6aa125d10e4c54a22c5767ed57f1e58ddf5e4fc7692454bc290bd1c8a8309bf24432795085d48be84180930e8ab305fc7d97a0a46e0780533deaf1b3bb6dd86efcb00bcbc1443dbb509b4ad229b0882fc524f0e020036b025a93ddba4c94698265853f90795188834793bbdb252b3e0c0df7eeb8dde3eacb40f1c9f2aff7b825c2885fb406864b0ee16e064953834adbbb046ecc6a2ebdf002043ef3e17222f0d6d0c4dce1633264b4971a90de3af0e4320c1c48e4ce85c1844995abcb6f0f00adcbfc7a3d72e71983c4573db655c71ce1c3f89cec6351da8ba3b931bf0e0a10953451771feae87237d4439bdbdedb1d586d8a1fae03053ed0e880a3a98ad2cf20f37993e7c788bcf9d2fa7f0c5a392fdd0c98820c19098573ee1e582592e6f29d5bda3f2d6a28ec5018fec99efaef371aeef75f6583d87faff0d201e6270df578779675a16e000c9bccd816ca0d71514ccac1906e79ab2d57c8e48f51a98d0a9afaa620fd4f59ff694e84c43a8dab6329d473884e5a54abb354ab912598e40c104fe88b89aedbd7881d2f5140e1b395c2c5ab8802aeb49621a4c4436d6d7b1038f89c7e21100697480cbc7a2e4c8111ad3b73820a553f9b642e171b0ffb4e5e69993cccd0c5dc8e4c8348b29835cb32bb035c9844aa3a544ad16f6405ec9c46bdcb1e7fa3fbd2816a1af4d82691fe4a8d803cefd935ed4944cc143c4f9b172e96d6e94f59d31ed83d52f60975f72d881124aa04e8882aaea94a5dd1ed07cd7ef330098ab5bfbd7b3ae19bac7f5c77a371cbff499f4d1cecccc533229e6d8a2f6f01b032973cae485148cca908cacab2692ea3db7d3349289da12001f98e35d43fe7027a4f982954c758928218a84bcd1f5438bfac35cf3db4a04056f7e512d6e6bec7b36d80268f52b4a63e3bf8abcb8303623d3dc2b81a19fa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dealing with Imbalanced Datasets</title>
      <link href="/2021/05/07/Dealing%20with%20Imbalanced%20Datasets/"/>
      <url>/2021/05/07/Dealing%20with%20Imbalanced%20Datasets/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>The Imbalanced Datasets are very common in our life such as illegal users or illness check. The machine learning model always performs bad on these datasets if there are no specific dealings, especially the prediction accuracy of minority class. For example, if the data is highly imbalanced such as 9995(negative):5(positive), then if your model just let every instance to be negative and you can get an acc of 99.95% but the result is meaningless. Another example is that misclassifying the minority is very severe. Assume that you misclassify the patient as normal. Oh my god!</p><p>So researchers proposed two kinds of methods for this problem:</p><ul><li>Cost Sensitive Learning<br />When <strong>training</strong> your model, it will give different classes different weights in the <strong>loss function</strong> thus let the model focus more on the minority class. In sklearn, there are <code>class_weight</code> and <code>sample_weight</code> for you. For <code>class_weight</code>, you can specify the weights for different classes such as <code>&#123;0:0.1,1:0.9&#125;</code> or you can set it to <code>balanced</code> then weights will be computed by <span class="math inline">\(\frac{\#samples}{\#classes\ *\ np.bincount(y)}\)</span>. For <code>fit(sample_weight=)</code>, you give <strong>every instance</strong> different weights. When computing the loss for the instance, it will be <code>class_weight</code> * <code>sample_weight</code> * <code>loss</code>.</li><li>Sampling<br />Sampling means that we will change the original dataset rather than giving them different weights.</li></ul><h2 id="sampling-methods">Sampling Methods</h2><p>Over-sampling means to increment the minority class.</p><ul><li>Random Over Sampling<br />To sample from minority class with replacement to let the number of each class is 1:1. Overfitting on minority class.</li><li>Synthetic Minority Oversampling Technique (SMOTE)<br /><span class="math display">\[x_{new}=x_i+\lambda(x_{zi}-x_i)\]</span> First you find the <code>k_neighbors</code> of <span class="math inline">\(x_i\)</span> in the minority class, then just select one <span class="math inline">\(x_{zi}\)</span> randomly and produce the new one. There are some variants such as borderline SMOTE, SVM SMOTE and KMeans SMOTE.</li><li>Adaptive Synthetic (ADASYN)<br />The difference between SMOTE and ADASYN is that SMOTE will generate new samples for random minority data until 1:1. But ADASYN will automatically decide the number of new points generated for each <span class="math inline">\(x_i\)</span>. There will be more points generated if there are more majority data around <span class="math inline">\(x_i\)</span>.</li></ul><p>Under-sampling means to decrease the majority class.</p><ul><li>RUS<br />Data waste.</li><li></li></ul><h2 id="example">Example</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底作别</title>
      <link href="/2021/05/02/%E5%BD%BB%E5%BA%95%E4%BD%9C%E5%88%AB/"/>
      <url>/2021/05/02/%E5%BD%BB%E5%BA%95%E4%BD%9C%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9f9edcb236e597a052917c5e9bb75f45c6c88c8c5f494b02b2f0f1679a768f52">c172f4ee74b2b6d246b20cbfdc0b877e4bd57af87b207617392664b5e29f88e312d6e561f347b9926910d25e5102863696041f11fe8fe0606e5ed4a5d40239deb870b179549b9372cfe386f7fc1b3200db7532a26b0ce138046d8b8de3b1f12d508d011f45898d7fc309775a8f949cf7a2a5264f0855498b8e0d96327b4107020c299c532d4a8abc6800deb6ef633494936fecf940e17d3585e9cdd3e716e919fd6c62998ec1960c67bebfbaece529d9f49b81aa86875d0b7bac31428638bcde151f1b30c388195985f63e899547687ad8b919dcc90d6737c25d4c6ce8e365c06923ecb74ba1a65ab80c5d44baf76fae349d6227983b774b244fcd688110d822f15caf0c70626b654a0ace727d8133a04ebcc472de291730d3a7de78a2f145aec5e82da318d4062423d61de5bbbb6d9da142a1249df5084c3d030d476c9084e95ee780b768f9a2bc5207f6c977c530bc9cd9132d4b6efd456b0c42cd1d6524499562a091d508739e3471765b22021e832d83f1bcde3171afde82c039031d00306578cb9d66709ef804a336c02301bf89f995c32032050b215ffeff295c21c90dbb39ae9141a6082a38db499fb1e758c31a8570fbeb6a8e2e761cd402b3582749e977398dc0d9dbda1e9f1b83cf468042daf8dfb6d616be96ea29312d24dab3e1fccc462cdad851fef60fc3152f1f61349d85c10163bb5e25469b9e59ce54b3dcdc69505ae0ab0d569608745718d1b5362d332251419c2cb9a3f3f61065c07925a368f37a9a0190fce92fa50e0f8973d3db5c1dca04f513488c3a385d3f4f6d0f3e1ef47d485c82b8dbe73087166b3b16c34066e67d152f44233f2cdfa3ca96df3b66ea25f65082ee4257547446a8aba99a2249a205b214ea35f02cd24b904996f5e90368e97ca2359fd8c2101c8a8b3a5471f666d62351b3bf9b987eda692b22d543f29f425de622ef11b410cc19358a7eb20498d8bc62b1925fb015f845e9f148829a194e562d1564cbf8a97f9e6421c60683cf2e2205a78c3d88d593d69d6a307db2628600bc590960faa5d67961e0a02365cb685222012c5a103bfb6f71e5cfa967ee077a85313bdb7a335ed2affb347d7f3ba61d9ee783f9a86b4cabdd16992b61e28402c8b313c83e6b80f6a0d35cac517ca030cf6b79e42c1ddc951ee361f248f45c2738aab62f5dc38cf1aae0e9b0e3cf1ddee971ff035790079b84d339fa6c70fd46838426927324294d639975aa9d3214af589ea180ad9e03f82b58fde4fffe7cde435d1acde3b8a04c435d1daa7c2a5f81d1b369753772c547cb9de8da43ed957b9982f1cd9f9f547393855bc05e8394c32dad63b5e9e88a024a9152c157819e894155d34fb37286c236909e05909e8e6191b3f91e619aa275f3b367bdfd947d49c65e549351acc905cf4bcf566cf96ca8fefafa32eff41904773e219e59eaa036801f1ef3a6b51a128eb6e55db706d483a5ab9ce43f6ba01579f3328a3e3f95d7d21e2b0f737c8c9bd35b0bc1178325f445dd2038e90994259e5c9d07a670f580a62b861dced8e9febbc318982d024c026da42dbb427c504280bd10b741a5373642f4dbc2a56219bb22202df507a8f2d9135ab278495a3def51375e47fc9580582a700872edd247af6acea47c2d5dba081f793b868e85f6e8d9036e6264f9859ae64ed663d1bf9ac23a77c2b66dc91603d6582b98f111e57cd6dccbf4b42b4426f41aa27d301c30e82c82ec14866d4e4b776066f30ba8de7a47be477268d21158d56922f0ebac76f4fa1a27107e358ec1ea633ccd24204f807db7fc1f13009d982ea8c0fb4053651410da985f500803fa4f0327a70a0db9d63a589cbe3e16e3b8165fbb2416f97bb6ad68f06c358e03525d587be32d87a3c13cdf8498d033ff767474bdcd7949eaaafb2a833e6d5006acbde07e1d5bfacab81f269456aab742888925720be7f6dd3fd5d65360841bd6fe70ee04489c9c7c45d8180d2c9af40691987145fb43b4a6d43ebbb8c2fb0af4346757f6cb2acfaccc6571c3c538390e681677f5564406afd13bc25212735e329e1304e4a90a8b00abece219d955a649ef6537483930269151aa0be52eae7448a977e93c746aef450c82d9e9ccf004ddffad7a0d4495a308e142d11e745634afb44944f0d93e1b11f84db5347255465a96b4a2ce58816e96c5854df4d77685922b5b9a6640f57822d6d29951d4c02d769a6b84323ed953da42dc4893a0a78694bb98bce235060bd4c1de6ea3fcac59ae9e4cc50a31b3c8222961c9320e2b6c03d670f64d844973d8d803497a52a3a56287008d786eca1ed384a7d93264dac5e70ec3a4294b974fdce0d1983b98de7a8f8af6e4d15929986b64477116684307e64cf12eaf381e5518047d17f3809b72538d75d78145b835fc69ee43521207713afd6ab41e37b1bbe613aa47092d41f8cd38881bf1f2eb937761a47a161cd935f3cc548d0a5fad1114b9451ea380e026c19d6ee47a73b1ab7ac9ab35d57ac6448ba533a200e771b66866242b823f92009a8bf693b88b37f6c39a45d424bd837bce72edf70dad40db6714e409e5c903d9373795616ffe37096b3c3b4212fc3cfbafa04015da8df4360a3044c571af14e59fd7f896961a873084c5a271eed09698e84c5973a5db0fc847c7449ea3bc5a0af384e8f9058789620589c37a109f50a0164f2ad4670e9c3c7fb21313d3ce0d8b6d84d1547ef965ac86fb165117e549ad0bd212ad300b934d127e5acc0329f6e9f767a9f986b16ef0c30c99bebbc5f7c3d1594cafe844941ab110ae7fd225e5ae7a9e0612210e20389cc27cf018e9555de6831f658ef427f4982afc841beef9ae98376e70a4a66d8fb74e00dea62dcd39c627d4d67f8824372171a27f3ba039801dfff17900edac214245f7667978404e4dfe5b5dffdb42fa2419d7d569bb5ae29cb23cb20978f220676804bfd98487903e232e37227f5cb1165f2b0b2e59b55804f9fa51f5e1cd2935f49d311afcd23deb83aab49d4dd2f0dfe23e3402f9c0636d5bb7e5e4f28383eb39f9a59a6b3da359c29f09dbe14007b3e72bf545a595aa420c0b02d086a1bac805d35b63e86cec777229330e45d49fe62f97fcb977dafb4350426a0a226002dff967df49b3e1b83e13f29b8d5daec9b08ec3ec7e186518198df5ea0b35cbb4f4d15087dba09916a7d547e04275b2dd7e9b7add3aa19a22dd17f2bbf650645ad95beefd9def0a1808790f8e11718a97202885d8dc46d747698ecc4c56b785425ae9e518780f4ab8d58f51cb05499821350b75d4869577dabe0c2c27b01f710397a7f7c3e5f8f899ad7ed35219228b22456686c30a938accc83f06b25a8d01e699db3fd8662e117a6c3bfe72b6f01d5ffa06da73cc5fff3f606284dc8c75b0ef3aabb4ebf36a35fa9adc275b8fe9d3e1cb87d62ec0ee70ddd03d275128ad6bb5c80d8c47407f758d833fca84aac6ed55e087d714f66d70a8bda5460ddca9cf86ccf4f8c46d177e9a83c1f684327a4205b912b15c4418c930d213ddf4f4f1b943c9e72cedb82dac97cfd0705f4dc5970eaa5cf4f19c62ba97ae3d81e991840e02461c12141f3fdcdd5e6bf265fca63a6d38bca800884f9d01b65a0e9c59ae06dbbb7e767bd36b887caf4f0988a78fb65771463527a320d140317a5bb404dacf83fa7feef0cb11bc84f10566b2d903fdeb1c15300c59d10a13af1d52cec644c0220a10a6112983aab5d612eaa4b1a1f239188cc1b8cbc1212b2e0775fb7ecd8dc3f95ea18fa3c1d10ae0aa1da06a21346337144d94cc9d7540ba1c7c73559f5b59f238c6b639b65b14c3269f478e220b98859dbc1cf2c27f3b4653b934d31854d72c6cdf5fb4f0253430f341084b87f53d36aea76ea877e867829b747eb5ad3fcf9a417860286ff350305d48e55baec1beb6cbeff335c386dabee6932ae575bd7c3a7687932539936c84abae9b1bbb43777e4933e0d61459d7cce34973867d58759584a41b33a81dce94dff236025b27259844a249adef87bc14e8e618bab30fa592c6e738331beadbabaf0af86feba1253b2dfbfe2fcd911143c2e83ff95c47b52f02355426529b8d25c7e26ffbac8673bf4c2a1c349d848f6cbe3afcae62eecad22664d6034bd07a20331b2c37cf9b20159194562928c0f2fe041f9cf638f4119d91a97b32b9bdfef70b907242d0f839ffce9bbc875d00dd5e66d250548aa30a9a928a34a44762b733caec9d7e712b41411b5e6ad323ce3ceae522fa431c861ef7e2d8955567cf4c55b6a36a63db5e051236214cecfa85a3113a8c323d8b5d250b1121735cc01e0c079ce591f3f7200ff94d980ae8c2f4cc173440525a696b33610dc3c1d3cbf2ca68a60e8476ee9b3bec8d7345d05849879b3eecb55ccf510517ffb1aa3650fd6a4e44b459dac11b2f9fc93df43b36dc92351cce931113920a9a16d86f80b1705e9af521bf5780418a651442fa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kick Start 2013</title>
      <link href="/2021/04/22/Kick%20Start%202013/"/>
      <url>/2021/04/22/Kick%20Start%202013/</url>
      
        <content type="html"><![CDATA[<h2 id="practice-round">Practice Round</h2><ol type="1"><li>题目大意：给定一堆人名，从上向下扫描，一旦当前值比前一个的字典序小，就将当前值移动到正确的位置，不论移动多远，代价都是1，求代价总和。</li></ol><p>和插入排序类似，如果当前值<span class="math inline">\(j\)</span>比<span class="math inline">\(j-1\)</span>小，将<span class="math inline">\(j\)</span>移到前面合适的位置，此时前<span class="math inline">\(j\)</span>个数是局部有序的。这道题只要求出代价和即可，不需要输出排序后的结果，不需要真正去移动，只要记录前<span class="math inline">\(j\)</span>个的最大值，如果<span class="math inline">\(j+1\)</span>比最大值小，那么必然触发一次移动。举例：<br />2 1 5 3 0 j=1, max=2, cost++<br />1 2 5 3 0 j=3, max=5, cost++<br />1 2 3 5 0 j=0, max=5, cost++<br />0 1 2 3 5<br />有2个地方要注意：<code>cin</code>读入<code>string</code>时，会把空格/回车作为分隔符，遇到即停止，所以要用<code>getline()</code>，默认以回车结束；<code>cin</code>读完<code>int</code>后，换行符<code>\n</code>仍然在输入流里，所以下一次的<code>getline</code>会先读<code>\n</code>，故用<code>cin.get()</code>先取走<code>\n</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, N;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        cin.<span class="built_in">get</span>();</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">names</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin, names[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string curMax;</span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                curMax = names[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (names[j].<span class="built_in">compare</span>(curMax) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ++money;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                curMax = names[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; money &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>题目大意：</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Monte-Carlo Tree Search</title>
      <link href="/2021/04/13/Monte-Carlo%20Tree%20Search/"/>
      <url>/2021/04/13/Monte-Carlo%20Tree%20Search/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>We all know that Monte Carlo Simulation is used to estimate some unknown variables through random simulation. It is because that the process is too complicated so we cannot know the true rule behind it. Only god knows. But thankful to the randomness we can do lots of experiments to approach the truth.</p><p>MCTS has the same idea but it is based on a tree. Every path from root to leaf forms a solution and the whole tree defines the search space. It is a heuristic search strategy based on some loss functions. But it will follow not only the loss but also try to explore the unvisited nodes. So it's also trying to make a balance between exploration &amp; exploitation.</p><p>One iteration has 4 processes: Selection, Expansion, Simulation and Backpropagation. Let's start to build the tree. Initially the tree only has a root node. Every node holds 3 info: action list for the next decision; visit times to measure the exploration; quality values to measure the exploitation.</p><ol type="1"><li>Selection<br />Using some criterion to select a child node which is eager to expand. There are 3 possibilities for the current state: If all the actions have been expanded thus the node has finished a complete search, then we will find a child with max UCB value and go down the tree recursively; Else if there are still some actions which have not been expanded (e.g. the node has 20 possible actions but there are 19 child node in the tree), then it will select one action randomly from the unexpanded actions and do Step 2 Expansion; Else game over and do Step 4 Backpropagation.</li><li>Expansion<br />We have found the most eager node N to expand and the action A after Selection. So we need to add a new node S to the tree as N's child node by doing A.</li><li>Simulation/Playout<br />Start from S to let the game run randomly until game over. Then we get a performance to be S's initial quality value.</li><li>Backpropagation<br />The nodes along the path from root to N will update their quality values after S's simulation.</li></ol><p>After some fixed number of iterations or time limit, we will get a large tree and select the best leaf node as the result. Below is a figure: <img src="https://img-blog.csdnimg.cn/20210404201349819.png" alt="在这里插入图片描述" /></p><h2 id="upper-confidence-bound-ucb">Upper Confidence Bound (UCB)</h2><p>When we need to select a child node to go down the tree, we usually use UCB criterion: <span class="math display">\[\underset{child}{\operatorname{arg\ max}}(\hat\mu_{child}+C\sqrt\frac{log\ n(s)}{n(child)})\]</span> <span class="math inline">\(\hat\mu_{child}\)</span> is the average reward gathered over all tree-walks with prefix child, <span class="math inline">\(n(s)\)</span> the number of the parent's visits and <span class="math inline">\(C\)</span> is constant controlling exploration &amp; exploitation. UCB tends to select a node with high quality value (for exploitation) and relatively low visit times (for exploration).</p><h2 id="an-example">An example</h2><ol type="1"><li>Initial tree<br />Actually we only have root node <span class="math inline">\(S_0\)</span>. Assume there are only two actions <span class="math inline">\(A_1\)</span> and <span class="math inline">\(A_2\)</span>. <span class="math inline">\((Q,N)\)</span> means the quality value and #visits of this node.<br /><img src="https://img-blog.csdnimg.cn/20210519201721793.png" alt="在这里插入图片描述" /></li><li>First Iteration<br />Since <span class="math inline">\(S_0\)</span> is a leaf node now, we should expand. Since the 2 actions are both unexpanded so we randomly select one (assume we select <span class="math inline">\(A_1\)</span>). Then we add <span class="math inline">\(S_1\)</span> to the tree and playout from <span class="math inline">\(S_1\)</span>.<br /><img src="https://img-blog.csdnimg.cn/20210519202838706.png" alt="在这里插入图片描述" /><br />Assume we got a performance of 20. Next we need to backpropagate the value to <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_0\)</span> and update Q and #visits.<br /><img src="https://img-blog.csdnimg.cn/20210519203559429.png" alt="在这里插入图片描述" /><br />We finished the first iteration.</li><li>Second iteration<br />Start from <span class="math inline">\(S_0\)</span>, since <span class="math inline">\(A_2\)</span> has not been expanded so we have to choose it. Then add <span class="math inline">\(S_2\)</span> to the tree and playout from here.<br /><img src="https://img-blog.csdnimg.cn/2021051921175522.png" alt="在这里插入图片描述" /><br />Then backpropagate to <span class="math inline">\(S_2\)</span> and <span class="math inline">\(S_0\)</span>:<br /><img src="https://img-blog.csdnimg.cn/20210519212028325.png" alt="在这里插入图片描述" /></li><li>Third iteration<br />From <span class="math inline">\(S_0\)</span> there are no unexpanded actions so we need to select one child using UCB (assume C=2). <span class="math inline">\(UCB(S_1)=21.67,UCB(S_2)=11.67\)</span>. Thus we select the leaf node <span class="math inline">\(S_1\)</span>. Assume <span class="math inline">\(S_1\)</span> has 2 unexpanded actions.<br />Choose one randomly (assume <span class="math inline">\(S_3\)</span>) and playout from here and backpropagate, assume we get performance of 0:<br /><img src="https://img-blog.csdnimg.cn/20210519212745377.png" alt="在这里插入图片描述" /></li><li>Fourth iteration<br />From root we should decide which one to select. Again using UCB: <span class="math inline">\(UCB(S_1)=11.48,UCB(S_2)=12.10\)</span>. So we choose <span class="math inline">\(S_2\)</span>. Assume there are two unexpanded actions so we randomly choose <span class="math inline">\(S_5\)</span> and playout and get a performance of 14. After backpropagate:<br /><img src="https://img-blog.csdnimg.cn/20210519213431456.png" alt="在这里插入图片描述" /></li></ol><p>Assume the max iteration number is 4 so we get the final tree above. Finally we can select the best solution from <span class="math inline">\(S_0\)</span> to leaf node according to UCB value.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> AutoML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bayesian Optimization</title>
      <link href="/2021/04/06/Bayesian%20Optimization/"/>
      <url>/2021/04/06/Bayesian%20Optimization/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>Hyper-parameters tuning has become an important work during training neural networks. As the number of Hyper-parameter is becoming larger, researchers proposed Grid Search &amp; Random Search to wish to get better combinations of Hyper-parameters. However, Grid Search has a high time cost. Although some experiments showed that Random Search got a better result than Grid Search but the result is still not fulfilling.</p><p>Besides, there are some gradient-based methods to solve the problem. But the objective function is usually not differentiable or even not continuous. Thus these methods have a very finite usage.</p><p>BO is a gradient-free optimization method to get global solutions of a black-box function. The function usually has a high cost to compute such as training a deep neural network after tuning the Hyper-parameters. For this reason, we usually find a <strong>surrogate</strong> function to approximate the original function <span class="math inline">\(f\)</span>. In the field of AutoML, we often use Gaussian Process, Random Forest or deep network as the surrogate model. The simplest form of BO is as follows: <img src="https://img-blog.csdnimg.cn/20210401193953429.png" alt="在这里插入图片描述" /> <span class="math inline">\(f\)</span> represents the black-box function that we want to optimize (black-box means that the function transforms a configuration <span class="math inline">\(x\)</span> to an output but we don't know the exact function relationship). <span class="math inline">\(\chi\)</span> represents the search space of the combination of hyper-parameters. <span class="math inline">\(S\)</span> represents <strong>Acquisition Function</strong> which is used to select the promising <span class="math inline">\(x\)</span>. <span class="math inline">\(M\)</span> represents the surrogate model which takes a configuration <span class="math inline">\(x\)</span> and outputs the performance (much like <span class="math inline">\(f\)</span> does).</p><p>First we need to get some samples from <span class="math inline">\((f,\chi)\)</span>, thus we get <span class="math inline">\(D=(x_i,f(x_i)), i=1...n\)</span>.</p><p>Next we iterate <span class="math inline">\(T\)</span> times (often fixed) to select configuration <span class="math inline">\(x\)</span>. Use the dataset <span class="math inline">\(D\)</span> to train the surrogate model <span class="math inline">\(M\)</span> (much easier than train <span class="math inline">\(f\)</span>). <span class="math inline">\(M\)</span> has several choices such as Random Forest, Tree Parzen Estimators. Here we use GP so we get the probabilistic model <span class="math inline">\(p(y|x,D)\)</span>.</p><p>Then we need to find the most promising configuration <span class="math inline">\(x\)</span>. The most important thing for Acquisition Function is to make a balance between <strong>exploration &amp; exploitation</strong>. It means that when selecting the next <span class="math inline">\(x\)</span> we not only want to select those untried points (exploration) but also want to select those tried points which has a great <span class="math inline">\(f(x)\)</span> (exploitation).</p><p>Finally use the promising <span class="math inline">\(x_i\)</span> to get corresponding performance <span class="math inline">\(y_i\)</span> and join the pair into <span class="math inline">\(D\)</span>. ## Gaussian Process If we assume <span class="math inline">\(x_i\)</span> is independent with each other, the Multivariant Gaussian Distribution's probability density is as follows: <span class="math display">\[p(x_1,...,x_n)=\frac{1}{(2\pi)^{\frac{n}{2}}\sigma_1...\sigma_n}exp(-\frac{1}{2}[\frac{(x_1-\mu_1)^2}{\sigma_1^2}+...+\frac{(x_n-\mu_n)^2}{\sigma_n^2}])\]</span> We can rewrite the formula to the vectorized version: <span class="math display">\[p(x)=(2\pi)^{-\frac{n}{2}}|K|^{-\frac{1}{2}}exp[-\frac{1}{2}(x-\mu)^TK^{-1}(x-\mu)]\]</span> in which <span class="math display">\[K=\left[\begin{matrix}  \sigma_1^2     &amp; 0      &amp; \cdots &amp; 0      \\ 0      &amp; \sigma_2^2      &amp; \cdots &amp; 0      \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0     &amp; 0      &amp; \cdots &amp; \sigma_n^2     \\\end{matrix}\right], x-\mu=[x_1-\mu_1,...,x_n-\mu_n]^T\]</span> Thus <span class="math inline">\(x\sim N(\mu,K)\)</span>, <span class="math inline">\(\mu\)</span> is the mean vector and <span class="math inline">\(K\)</span> is the covariance matrix (a diagonal matrix since the independence).</p><p>But what should we do when <span class="math inline">\(x\)</span> has infinite dimensions? Such as in a continuous temporal T or spatial S. Actually GP means Gaussian Distribution and Stochastic Process (about time T). GP is defined by an infinite number of Random Variables on a continuous domain. In other words, it is an infinite dimension Gaussian Distribution. Formally, let's sample n moments from T: <span class="math inline">\(t_1,...,t_n\in T\)</span>, thus we get a n-dimensional vector <span class="math inline">\((\xi_1,...,\xi_n)\)</span>, if this vector is a n-dimensional Gaussian Distribution then <span class="math inline">\({\xi_t}\)</span> is a GP.</p><p>Let's take an easy example to illustrate: suppose during peoples' life time, at every moment <span class="math inline">\(t\)</span> the energy of the population forms a Gaussian Distribution but different moments have different <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span>: <img src="https://img-blog.csdnimg.cn/20210404141525979.png" alt="在这里插入图片描述" /> If we take 5 moments during a population's life time, then <span class="math inline">\(\xi_1-\xi_5\)</span> all forms Gaussian Distribution but they have different <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span>. If we sample an arbitrary moment <span class="math inline">\(t\)</span> then <span class="math inline">\(\xi(t)\sim N(\mu_t,\sigma_t^2)\)</span>. If we sample at some points and connect them together we get two samples of the GP, as the figure shows.</p><p>Now that we know what happens at <span class="math inline">\(t\)</span>, let's consider the whole <span class="math inline">\(T\)</span>. We know that for a finite Gaussian Distribution, it can be determined by a n-dimensional vector <span class="math inline">\(\mu_n\)</span> (reflects every Random Variable's expectation) and a <span class="math inline">\(n\times n\)</span> matrix <span class="math inline">\(\Sigma\)</span> (reflects every RV's variances and covariance between different dimensions). It is almost the same for GP except that we cannot use a vector to describe every <span class="math inline">\(t\)</span>'s mean since it is infinite. So we need a function <span class="math inline">\(m(t)\)</span> to describe the continuous <span class="math inline">\(T\)</span>. For <span class="math inline">\(\Sigma\)</span> we should use a kernel function <span class="math inline">\(k(s,t)\)</span> to describe the covariance between time <span class="math inline">\(t\)</span> and <span class="math inline">\(s\)</span>. Once <span class="math inline">\(m(t)\)</span> and <span class="math inline">\(k(s,t)\)</span> is defined the GP is determined <span class="math inline">\(\xi_t\sim GP(m(t),k(s,t))\)</span>.</p><p>The most popular kernel function is RBF which is defined as follows: <span class="math display">\[k(s,t)=\sigma^2exp(-\frac{||s-t||^2}{2l^2})\]</span> <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(l\)</span> are two hyper-parameters. If <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> are close in <span class="math inline">\(T\)</span> then the output covariance will be larger and it means the correlation between the two points is bigger.</p><p>Once we have some knowledge about GP we can start to know Gaussian Process Regression, which is a kind of Probabilistic Model. It means that we can use Prior and Observations to calculate Posterior. First we define a GP by <span class="math inline">\(m(t)\)</span> and <span class="math inline">\(k(s,t)\)</span>, which is a Prior. Then we observe some data to revise the GP's <span class="math inline">\(m(t)\)</span> and <span class="math inline">\(k(s,t)\)</span> to get Posterior. But how?</p><p>Here we need to use some Gaussian Distribution's nice properties: Once Gaussian always Gaussian. It means that marginal distribution, summation and conditional distribution of a GD are still GD. Assume a n-dimensional RV <span class="math inline">\(x\sim N(\mu,\Sigma)\)</span> and we divide it into two parts <span class="math inline">\(x_A\)</span> and <span class="math inline">\(x_B\)</span> then we get: <span class="math display">\[x=\begin{bmatrix} x_A\\ x_B \end{bmatrix},\mu=\begin{bmatrix} \mu_A\\ \mu_B \end{bmatrix},\Sigma=\begin{bmatrix} \Sigma_{AA}, \Sigma_{AB} \\ \Sigma_{BA}, \Sigma_{BB} \end{bmatrix}\]</span> Then we can get: <span class="math display">\[x_A|x_B\sim \mathcal{N}(\mu_A+\Sigma_{AB}\Sigma_{BB}^{-1}(x_B-\mu_B),\Sigma_{AA}-\Sigma_{AB}\Sigma_{BB}^{-1}\Sigma_{BA})\]</span> Thus we could update the GD's Posterior parameters. It is much the same in GP. If we get some samples <span class="math inline">\((X,Y)\)</span> then the rest is <span class="math inline">\((X^*,f(X^*))\)</span>. The joint distribution forms an infinite GD: <span class="math display">\[\begin{bmatrix} Y\\ f(X^*) \end{bmatrix}\sim N(\begin{bmatrix} \mu(X)\\ \mu(X^*) \end{bmatrix},\begin{bmatrix} k(X,X), k(X,X^*) \\ k(X^*,X), k(X^*,X^*) \end{bmatrix})\]</span> So we want to know the rest of the points based on the observed points: <span class="math inline">\(f(X^*)|Y\sim N(\mu^*,k^*)\)</span>. <span class="math display">\[\mu^*=\mu(X^*)+k(X^*,X)k(X,X)^{-1}(Y-\mu(X))\\k^*=k(X^*,X^*)-k(X^*,X)k(X,X)^{-1}k(X,X^*)\]</span> Here is an example: <img src="https://img-blog.csdnimg.cn/20210404155244142.png" alt="在这里插入图片描述" /> Finally let's return back to our BO's <span class="math inline">\(M\)</span>. We first assume our prior: <span class="math inline">\(\mu(X)=0,k(X,X^*)=RBF\)</span>. Plus the observed and evaluated <span class="math inline">\(D=\{x_i,y_i\}\)</span> we can get <span class="math inline">\(\hat \mu\)</span> and <span class="math inline">\(\hat{\sigma}^{2}\)</span>, then the posterior prediction is <span class="math inline">\(p(y|x,D)\)</span>, which is still a Gaussian Distribution. The calculation process is as follows: <span class="math display">\[y=(y_1,...,y_i)^T \\\hat \mu=k^T(x)(k+\sigma_{n}^{2}I)^{-1}y \\\hat{\sigma}^{2}=k(x^*x)-k(x)^T(k+\sigma_{n}^{2}I)^{-1}k(x)\]</span> Once we get the posterior prediction <span class="math inline">\(p(y|x,D)\)</span>, we can feed them to the Acquisition Function to get next <span class="math inline">\(x_t\)</span>. ## Acquisition Function There are some popular Acquisition Functions:</p><ol type="1"><li>Upper Confidence Bound (UCB) <span class="math inline">\(x_{t+1}=\underset{x\in X}{\operatorname{arg\ max}}[\mu_{t}(x)+\beta_t^{1/2}\sigma_t(x)]\)</span> The weighted sum of posterior mean and posterior standard deviation. The two items correspond exploitation and exploration, respectively.</li><li>Expected Improvement (EI) <span class="math inline">\(x_{t+1}=\underset{x\in X}{\operatorname{arg\ max}}\ E_{f(x)\sim N(\mu_{t}(x),\sigma_t^2(x))}[max(0,f(x)-f_t^+)]\)</span>, <span class="math inline">\(f_t^+\)</span> is the max observation value during the first <span class="math inline">\(t\)</span> iterations.</li></ol><p>Except the above functions, there are Probability of Improvement, Entropy Search and so on.</p><h2 id="reference">Reference</h2><p><a href="https://jgoertler.com/visual-exploration-gaussian-processes/">A Visual Exploration of Gaussian Processes</a><br /><a href="https://www.zhihu.com/question/46631426">如何通俗易懂地介绍Gaussian Process</a><br /><a href="https://zhuanlan.zhihu.com/p/76269142">贝叶斯优化/Bayesian Optimization</a><br /><a href="https://github.com/fmfn/BayesianOptimization/blob/master/examples/exploitation_vs_exploration.ipynb">Exploitation vs Exploration</a><br /><a href="https://github.com/fmfn/BayesianOptimization">BayesianOptimization</a><br /><a href="https://www.cs.cornell.edu/courses/cs4780/2018fa/lectures/lecturenote15.html">Lecture 15: Gaussian Processes</a><br /><a href="https://distill.pub/2020/bayesian-optimization/">Exploring Bayesian Optimization</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inductive Representation Learning on Large Graphs</title>
      <link href="/2021/03/29/Inductive%20Representation%20Learning%20on%20Large%20Graphs/"/>
      <url>/2021/03/29/Inductive%20Representation%20Learning%20on%20Large%20Graphs/</url>
      
        <content type="html"><![CDATA[<p>Stanford的帅哥Jure发在NIPS 2017的一篇文章。</p><p>GCN是Transductive Learning，训练时的图要包含所有结点，是固定的，不能快速泛化到未知结点（图），本文提出了一种Inductive Learning的GraphSAGE。</p><p>GCN学习的是每个单独节点的低维embedding，由于输入的图是固定的，所以可以很好捕获全局信息。但如果要获得新节点的embedding，加入图以后需要调整其它结点，至少也是局部重新训练，计算开销太大，应用受限。</p><p>GraphSAGE学习的不是每个结点的固定的表示，因为图结构不断变化，所以学习一种节点表示的函数，这样就可以快速得到未知结点的表示。</p><p>简单来说：学习每个结点的特征如何由邻居的特征聚合而来，学到聚合函数后，只要已知新节点的特征和邻边关系，就能得到表示，并且这个表示会由于图结构的变化而变化，是动态的。</p><p>前向传播是为了生成结点的向量表示，<br /><img src="https://img-blog.csdnimg.cn/20210207163418476.png" alt="在这里插入图片描述" /><br />如果聚合K次，就需要K个聚合函数，初始时每个结点的表示是原本的特征向量，对第k层，对结点v，先得到v的第k层结点的聚合表示，加上v在上一层的特征，最后得到v的最终表示。</p><p>以作者的图为例，<br /><img src="https://img-blog.csdnimg.cn/20210220111424640.png" alt="在这里插入图片描述" /><br />我觉得知乎上这张更清楚： <img src="https://img-blog.csdnimg.cn/20210220111932548.png" alt="在这里插入图片描述" /><br />每一层的表示都是由上一层生成，与当前层其他节点无关。</p><p>由于需要学习参数，所以要设计损失函数。无监督学习的损失函数应该是让临近节点有相似的表示，有监督学习用cross-entropy即可。</p><p>聚合函数作者给了3种选择：</p><ol type="1"><li>Mean<br />取邻居的平均值</li><li>LSTM</li><li>Pooling</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Loss Function</title>
      <link href="/2021/03/13/Loss%20Function/"/>
      <url>/2021/03/13/Loss%20Function/</url>
      
        <content type="html"><![CDATA[<p>For binary classification (+1, -1), if we classify correctly then <span class="math inline">\(y\cdot f = y\cdot \theta^Tx\gt0\)</span>; otherwise <span class="math inline">\(y\cdot f = y\cdot\theta^Tx\lt0\)</span>. Thus we have following loss functions:</p><ul><li>0/1 loss<br /><span class="math inline">\(\min_\theta\sum_i L_{0/1}(\theta^Tx)\)</span>. We define <span class="math inline">\(L_{0/1}(\theta^Tx) =1\)</span> if <span class="math inline">\(y\cdot f \lt 0\)</span>, and <span class="math inline">\(=0\)</span> o.w. Non convex and very hard to optimize.</li><li>Hinge loss<br />Upper Bound of 0/1 loss. Approximate 0/1 loss by <span class="math inline">\(\min_\theta\sum_i H(\theta^Tx)\)</span>. We define <span class="math inline">\(H(\theta^Tx) = max(0, 1 - y\cdot f)\)</span>. Apparently <span class="math inline">\(H\)</span> is small if we classify correctly.</li><li>Logistic loss<br /><span class="math inline">\(\min_\theta \sum_i log(1+\exp(-y\cdot \theta^Tx))\)</span>.</li></ul><p>Fortunately, hinge loss, logistic loss and square loss are all convex functions. Convexity ensures global minimum and it's computationally appealing. <img src="https://img-blog.csdnimg.cn/20210226181824674.png" alt="在这里插入图片描述" /> Figure 7.5 from Chris Bishop's PRML book. The Hinge Loss E(z) = max(0,1-z) is plotted in blue, the Log Loss in red, the Square Loss in green and the 0/1 error in black.</p><p>From the figure we can observe that the hard instance (near the boundary) will influence the loss function a lot so we need to make the model robust and can deal with the hard ones.</p><p>For binary classification we can unify the two cases (classify correctly or not) by <span class="math inline">\(y\cdot f\)</span>, but for multi-class classification (0, 1, 2, ..., k) we cannot unify all the cases. So we use cross-entropy as the loss.</p><p>There exists a vivid example for transform the target function: If a noisy picture is given, and want to output the clean one. Here the clean one is hard to control so we can let the noise be the target function and wo should minimize the amplitude of the noise. Thus the problem becomes controllable.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BusTub</title>
      <link href="/2021/03/05/BusTub/"/>
      <url>/2021/03/05/BusTub/</url>
      
        <content type="html"><![CDATA[<h2 id="project-0---c-primer"><a href="https://15445.courses.cs.cmu.edu/fall2020/project0/">PROJECT #0 - C++ PRIMER</a></h2><p>这个Warm-Up主要是要熟悉C++ 17的一些Features，只需要实现<code>p0_starter.h</code>即可；<br />提交gradescope，要上传zip文件，但是路径总是不对，文档里也说得不明不白，一定要加上路径名：<code>zip solution.zip src/include/primer/p0_starter.h</code>；<br /><code>unique_ptr</code>拥有对象的独占权，可以用<code>move</code>将对象的所有权转移到另一个<code>unique_ptr</code>。</p><p>第一次提交时有内存安全隐患： <img src="https://img-blog.csdnimg.cn/20201227221401866.png" alt="在这里插入图片描述" /> 网上说可能是valgrind版本过低，用高版本测试后发现没问题： <img src="https://img-blog.csdnimg.cn/20201227221456847.png" alt="在这里插入图片描述" /> 其实代码是有bug的，经过测试，发现问题在于实现矩阵乘法时定义了临时变量<code>double tmp = 0.0</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> tmp = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mat1-&gt;<span class="built_in">GetColumns</span>(); ++k) &#123;</span><br><span class="line">  tmp += mat1-&gt;<span class="built_in">GetElem</span>(i, k) * mat2-&gt;<span class="built_in">GetElem</span>(k, j);</span><br><span class="line">&#125;</span><br><span class="line">ans-&gt;<span class="built_in">SetElem</span>(i, j, tmp);</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mat1-&gt;<span class="built_in">GetColumns</span>(); ++k) &#123;</span><br><span class="line">  ans-&gt;<span class="built_in">SetElem</span>(i, j, ans-&gt;<span class="built_in">GetElem</span>(i, j) + mat1-&gt;<span class="built_in">GetElem</span>(i, k) * mat2-&gt;<span class="built_in">GetElem</span>(k, j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人理解是这样：因为原本代码中是模板参数<code>T</code>，如果定义<code>double</code>作为临时变量，测试时用<code>int</code>测试，最终<code>SetElem</code>时要存入<code>double</code>，但是预先分配的内存只有<code>int</code>大小，所以内存溢出报错。<br /><img src="https://img-blog.csdnimg.cn/20210127214548109.png" alt="在这里插入图片描述" /></p><h2 id="project-1---buffer-pool-manager"><a href="https://15445.courses.cs.cmu.edu/fall2020/project1/">PROJECT #1 - BUFFER POOL MANAGER</a></h2><p>整体要为<a href="https://github.com/cmu-db/bustub">Bustub</a>做一个面向磁盘的存储管理系统： <img src="https://img-blog.csdnimg.cn/20210225225705723.png" alt="在这里插入图片描述" /></p><p>第一次作业是要实现一个内存缓冲池：负责将物理页面在磁盘和主存之间移动，这样DBMS就可以支持比内存更大的数据库。缓冲池的操作对其它系统部件是透明的，比如系统通过唯一的页面标识符<code>page_id_t</code>向缓冲池要求访问页面，而不管页面是在内存中还是在磁盘上。</p><p>缓冲池的实现必须是线程安全的，多个线程同时访问时需要用latches保护（OS中叫locks）。<br />关于DBMS中的🔒：</p><ul><li>locks：高层次的逻辑原语，在事务的整个执行过程中保护数据库的内容（元组/表/数据库），可以rollback</li><li>latches：低层次的保护原语，DBMS用来保护内部数据结构的安全访问（hash table, regions of memory），只在某个具体操作时使用，不可以rollback</li></ul><p>具体来说：有2部分：LRU替换策略+缓冲池管理</p><ul><li>LRU<br />LRU的实现有多种方式：<br />1、数组+时间戳：每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。<br />2、双向链表：每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。<br />上面两种复杂度均是O(n)<br />3、双向链表+Hash Map：当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。本质上是list看作时间戳，hash table记录元素值到链表位置的映射关系，get和put均是O(1)。</li><li>缓冲池管理<br />缓冲池的组织形式是frame数目固定的数组，访问时将page从磁盘拷贝到frame。<br />与OS内存管理相似，也需要有page table记录哪些page在buffer pool中，page id -&gt; frame id；page directory记录了磁盘上的位置，page id -&gt; page locations in disk。<br />还需要有dirty位以及pin/ref counter记录当前正在访问的线程数目，只有flush或者置换脏页时才写回磁盘。 <img src="https://img-blog.csdnimg.cn/2021022523062865.png" alt="在这里插入图片描述" /> 缓冲池和<code>Replacer</code>的大小是相同的，如果page的ref counter变为0时就可以加入到<code>Replacer</code>中作为替补牺牲页面。</li></ul><p>从缓冲池中根据ID fetch的时候有3种情况：</p><ol type="1"><li>如果page在缓冲池，直接返回；</li><li>如果不在，但缓冲池有空闲frame，从磁盘读取page放入该frame；</li><li>如果不在且缓冲池没有空闲frame，从buffer中牺牲一页，从磁盘读取page放入对应的frame。</li></ol><p>第一次提交忘了处理并发问题，只得了65分： <img src="https://img-blog.csdnimg.cn/20210209211524362.png" alt="在这里插入图片描述" /><br />加了一些🔒后，还有2个test挂了：<br /><img src="https://img-blog.csdnimg.cn/20210209215248107.png" alt="在这里插入图片描述" /></p><p><code>isdirty</code>一直过不去，后来在群里看到：只有page当前的脏位是false且传入<code>is_dirty==true</code>时才需要修改当前的脏位。这里我是这么理解的：如果页面应该标记为dirty那么传入的参数就是true：</p><ul><li>当前为true &amp;&amp; <code>is_dirty==true</code>：页面修改过，也做了正确标记，不用管；</li><li>当前为false &amp;&amp; <code>is_dirty==true</code>：页面其实修改过，但没有标记，改正；</li><li>当前为false &amp;&amp; <code>is_dirty==false</code>：页面没修改，标记正确，不用管；</li><li>当前为true &amp;&amp; <code>is_dirty==false</code>：页面没修改，标记为修改过，这种也不用管，大不了置换时写回磁盘耗费些时间。 <img src="https://img-blog.csdnimg.cn/20210210204925713.png" alt="在这里插入图片描述" /><br />数据库真的太难了，尤其是涉及到并发控制的部分，我真的没有足够时间去debug这些，以后有空再继续做吧。。</li></ul><h2 id="project-2---b-tree"><a href="https://15445.courses.cs.cmu.edu/fall2020/project2/">PROJECT #2 - B+ TREE</a></h2><h2 id="project-3---query-execution"><a href="https://15445.courses.cs.cmu.edu/fall2020/project3/">PROJECT #3 - QUERY EXECUTION</a></h2><h2 id="project-4---concurrency-control"><a href="https://15445.courses.cs.cmu.edu/fall2020/project4/">PROJECT #4 - CONCURRENCY CONTROL</a></h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flow Control &amp; Congestion Control</title>
      <link href="/2021/02/25/Flow%20Control%20&amp;%20Congestion%20Control/"/>
      <url>/2021/02/25/Flow%20Control%20&amp;%20Congestion%20Control/</url>
      
        <content type="html"><![CDATA[<p>In order to make sure that every packet reaches its destination, we use Retransmit. There are 3 approaches: Stop-and-Wait, Go Back N and Selective Repeat.</p><ul><li>Stop-and-Wait<br />Sender transmits packet one by one, label each with a sequence number and sets timer after transmitting. If receive ACK, send next. If timer goes off, resend the previous packet.<br />When receive packet, send ACK. If packet is corrupted, ignore it and sender will resend.</li><li>SR<br />Send packets from the window and set timeout for each packet. On receiving ACK for left side of the window, slide forward and send packets that have now entered the window. On timeout, resend only the timed out packet.<br />Receiver keeps a buffer of size of the window. On receiving packets, send ACK. If packet comes in out of order, just store it in the buffer and send ACK anyway.</li></ul><h2 id="how-big-should-we-size-the-senders-window">How big should we size the sender's window</h2><p>Don't overload the receiver. Sender cannot send as fast as possible since it will overflow the receiver's buffer.<br /><img src="https://img-blog.csdnimg.cn/20200417151819468.png" alt="在这里插入图片描述" /><br />The solution is Advertised Window (W): tell the sender how much space the receiver's buffer has through ACK. So the window size of the sender: the size &lt;= W. Thus we won't overload the receiver. This is Flow Control.</p><p>But if we set the size to W, we cannot solve the problem thoroughly:<br /><img src="https://img-blog.csdnimg.cn/2021022516554078.png" alt="在这里插入图片描述" /><br />Sender's window contains a set of packets that have been transmitted but not yet acked. But some packets will get dropped at router and sender will never receive ACKs for these packets. The result is these packets will remain buffered in the window. It means that we cannot set the size to W, we only want to send at 50Mbps. It will take a RTT(200ms) to receive an ACK back for the first packet. We will send 50*200=1.25MB data and that's exactly the definition of the sender's window.</p><p>The window size of the sender should &lt;= bandwidth-delay product (BDP). Thus we won't overload the network. This is Congestion Control. BDP is the "volume" of the link, the amount of data that can be "in flight" at any time.</p><h2 id="how-should-we-determine-the-bdp">How should we determine the BDP</h2><p>Things are much harder to calculate the BDP:</p><ul><li>We don't know the bandwidth or RTT</li><li>My share of bandwidth is dependent on the other user on the network, so the window size will change as other users start or stop sending</li><li>The router will stall the excess packets in the bottleneck queue instead of dropping, so you can overshoot the size a little bit</li></ul><p>There are many algorithms to solve the problem given the prior constraints. The old one is Reno, although no one uses it anymore, sigh!!</p><p>Use Multiplicative Increase at startup to find the right sending rate quickly, this process is called "slow start";<br />Then uses Additive Increase/Multiplicative Decrease (AIMD) to adjust the sending rate over time.<br /><img src="https://img-blog.csdnimg.cn/20210225174103869.png" alt="在这里插入图片描述" /></p><h2 id="reference">Reference</h2><p><a href="https://computer-networks.github.io/sp19/lectures.html">CMU 15-441 TCP Part 2</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Entropy Model</title>
      <link href="/2021/02/07/Maximum%20Entropy%20Model/"/>
      <url>/2021/02/07/Maximum%20Entropy%20Model/</url>
      
        <content type="html"><![CDATA[<p>熵是对随机变量<strong>不确定性</strong>的度量，是对所有可能发生的事件产生的信息量的期望，没有外部能量输入的情况下，封闭系统趋向熵增。</p><p>信息熵指离散随机事件的出现概率：<span class="math inline">\(X={x_1,x_2,...,x_n}\)</span>，<span class="math inline">\(P(X=x_i)=p_i\)</span> <span class="math display">\[H(X)=-\sum_{i=1}^{n}p(x_i)log\ p(x_i)\]</span></p><p>Joint Entropy <span class="math display">\[H(X,Y)=-\sum_{i=1}^{n}\sum_{j=1}^{m}p(i,j)log\ p(i,j)\]</span></p><p><span class="math display">\[H(X|y_j)=-\sum_{i=1}^{n}p(x_i|y_j)log\ p(x_i|y_j)\]</span></p><p>按照<span class="math inline">\(Y\)</span>的各种情况进行加权平均，得条件熵<span class="math inline">\(H(X|Y)\)</span> <span class="math display">\[H(X|Y)=-\sum_{i=1}^{n}\sum_{j=1}^{m}p(y_j)p(x_i|y_j)log\ p(x_i|y_j)=-\sum_{i=1}^{n}\sum_{j=1}^{m}p(x_i,y_j)log\ p(x_i|y_j)\]</span> 易证<span class="math inline">\(H(X|Y)=H(X,Y)-H(Y)\)</span></p><p>交叉熵，<span class="math inline">\(P(X)\)</span>和<span class="math inline">\(Q(X)\)</span>是<span class="math inline">\(X\)</span>的两个概率分布 <span class="math display">\[D_{KL}(P\ ||\ Q)=\sum_xP(x)log\frac{P(x)}{Q(x)}\]</span></p><p>互信息 <span class="math display">\[I(X,Y)=\sum_x\sum_yp(x,y)log\frac{p(x,y)}{p(x)p(y)}\]</span> 互信息就是联合分布<span class="math inline">\(P(X,Y)\)</span>和独立分布乘积<span class="math inline">\(P(X)P(Y)\)</span>的交叉熵。<br />易证<span class="math inline">\(I(X,Y)=H(X)+H(Y)-H(X,Y)\)</span></p><p>直观上看：在已知部分知识的前提下，对于未知分布最合理的推断就是符合已知且最不确定的推断，整个系统趋向于无序，熵最大。<br />在一定<strong>约束条件</strong>下，使得<span class="math inline">\(H(X|Y)\)</span>最大。 <span class="math display">\[p^*={\underset {p\in P}{\operatorname {arg\,max} }}\,-\sum_{i=1}^{n}\sum_{j=1}^{m}\bar p(y_j)p(x_i|y_j)log\ p(x_i|y_j)\]</span> 约束条件： <span class="math display">\[\sum_xp(x|y)=1 \\...\]</span> 又可以通过拉格朗日乘数法变为对偶问题求解。</p><p>由于无法求得解析解，只能用迭代法求数值解： <span class="math display">\[p^*(x|y)=\cfrac{1}{Z_\lambda(y)}e^{\sum_i\lambda_if_i(x,y)} \\Z_\lambda(y)=\sum_xe^{\sum_i\lambda_if_i(x,y)}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python FAQ</title>
      <link href="/2021/01/30/Python%20FAQ/"/>
      <url>/2021/01/30/Python%20FAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="lambda表达式">lambda表达式</h2><p>对于一句话的函数，均可以用lambda表达式，一种语法糖。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x: x ** <span class="number">2</span></span><br><span class="line">g = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadratic</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: a*x*x + b*x + c</span><br><span class="line"></span><br><span class="line">f = quadratic(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">quadratic(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>)(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><h2 id="decorator">decorator</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># messy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    c = a + b</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(t2 - t1)</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><p>如果使用装饰器： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_time</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args</span>):</span></span><br><span class="line">        t1 = time.time()</span><br><span class="line">        res = func(*args)  <span class="comment"># do something</span></span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(t2 - t1)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@display_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">ans = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure></p><h2 id="gil">GIL</h2><p>是一个防止多线程并发执行的mutex，不是python的特性而是其解释器CPython引入的，使得在任何时刻仅有一个线程在执行，保证线程安全，但是影响多线程执行效能，无法利用多个CPU核心的优势。</p><h2 id="易错">易错</h2><p><a href="https://stackoverflow.com/questions/51950193/python-a-b-b-a-implementation-how-is-it-different-from-c-swap-function"><code>a, b = b, a</code>赋值问题</a><br /><code>print(1 != 0 != 1)</code>输出<code>True</code>，因此不能用来判断3个数是否不等。</p><h2 id="basics">Basics</h2><ol type="1"><li>两个列表转字典：<code>dict(zip(list1, list2))</code></li><li><a href="https://blog.csdn.net/weixin_37579123/article/details/89515577">Python中__new__()和__init__()的区别</a>：Python中的constructor是<code>__new__</code>，initializer是<code>__init__</code>。<code>__new__</code>首先被调用创建新实例并返回该实例，始终作为类的静态方法，类级别方法，默认调用父类的<code>__new__</code>构造该类的实例，也可以重写<code>__new__</code>，构造出来的对象取决于<code>__new__</code>，<code>__new__</code>返回什么就是什么；<code>__init__</code>没有返回值负责初始化创建的实例，实例级别方法，其<code>self</code>参数就是<code>__new__</code>返回的实例。</li><li><a href="https://hj24.life/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E6%B5%85%E6%9E%90/">Python中的进程/线程/协程</a>： 协程是比线程更小的执行单元，也叫微线程，用户态，在单线程上执行多个任务，一个任务等待时执行另一个任务，使用的内存动态变化，切换调度由用户控制，避免线程的系统级别切换的开销，内存利用率更高。 Python的协程是1：N</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: cat&quot;, &quot;#2: dog&quot;, &quot;#3: monkey&quot;, each on its own line</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;person&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;cat&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spider&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal, legs <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A %s has %d legs&#x27;</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = &#123;<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: fish&quot;, &quot;#2: dog&quot;, &quot;#3: cat&quot;</span></span><br></pre></td></tr></table></figure><p>one of the most important differences is that tuples can be used as keys in dictionaries and as elements of sets, while lists cannot.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name  <span class="comment"># Create an instance variable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instance method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">self, loud=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> loud:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;HELLO, %s!&#x27;</span> % self.name.upper())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">g = Greeter(<span class="string">&#x27;Fred&#x27;</span>)  <span class="comment"># Construct an instance of the Greeter class</span></span><br><span class="line">g.greet()            <span class="comment"># Call an instance method; prints &quot;Hello, Fred&quot;</span></span><br><span class="line">g.greet(loud=<span class="literal">True</span>)   <span class="comment"># Call an instance method; prints &quot;HELLO, FRED!&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])   <span class="comment"># Create a rank 1 array</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))            <span class="comment"># Prints &quot;&lt;class &#x27;numpy.ndarray&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)            <span class="comment"># Prints &quot;(3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])   <span class="comment"># Prints &quot;1 2 3&quot;</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                  <span class="comment"># Change an element of the array</span></span><br><span class="line"><span class="built_in">print</span>(a)                  <span class="comment"># Prints &quot;[5, 2, 3]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])    <span class="comment"># Create a rank 2 array</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)                     <span class="comment"># Prints &quot;(2, 3)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])   <span class="comment"># Prints &quot;1 2 4&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>))   <span class="comment"># Create an array of all zeros</span></span><br><span class="line"><span class="built_in">print</span>(a)              <span class="comment"># Prints &quot;[[ 0.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  0.]]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))    <span class="comment"># Create an array of all ones</span></span><br><span class="line"><span class="built_in">print</span>(b)              <span class="comment"># Prints &quot;[[ 1.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">7</span>)  <span class="comment"># Create a constant array</span></span><br><span class="line"><span class="built_in">print</span>(c)               <span class="comment"># Prints &quot;[[ 7.  7.]</span></span><br><span class="line">                       <span class="comment">#          [ 7.  7.]]&quot;</span></span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)         <span class="comment"># Create a 2x2 identity matrix</span></span><br><span class="line"><span class="built_in">print</span>(d)              <span class="comment"># Prints &quot;[[ 1.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>))  <span class="comment"># Create an array filled with random values</span></span><br><span class="line"><span class="built_in">print</span>(e)                     <span class="comment"># Might print &quot;[[ 0.91940167  0.08143941]</span></span><br><span class="line">                             <span class="comment">#               [ 0.68744134  0.87236687]]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use slicing to pull out the subarray consisting of the first 2 rows</span></span><br><span class="line"><span class="comment"># and columns 1 and 2; b is the following array of shape (2, 2):</span></span><br><span class="line"><span class="comment"># [[2 3]</span></span><br><span class="line"><span class="comment">#  [6 7]]</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># A slice of an array is a view into the same data, so modifying it</span></span><br><span class="line"><span class="comment"># will modify the original array.</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;2&quot;</span></span><br><span class="line">b[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">77</span>     <span class="comment"># b[0, 0] is the same piece of data as a[0, 1]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;77&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two ways of accessing the data in the middle row of the array.</span></span><br><span class="line"><span class="comment"># Mixing integer indexing with slices yields an array of lower rank,</span></span><br><span class="line"><span class="comment"># while using only slices yields an array of the same rank as the</span></span><br><span class="line"><span class="comment"># original array:</span></span><br><span class="line">row_r1 = a[<span class="number">1</span>, :]    <span class="comment"># Rank 1 view of the second row of a</span></span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>, :]  <span class="comment"># Rank 2 view of the second row of a</span></span><br><span class="line"><span class="built_in">print</span>(row_r1, row_r1.shape)  <span class="comment"># Prints &quot;[5 6 7 8] (4,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(row_r2, row_r2.shape)  <span class="comment"># Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can make the same distinction when accessing columns of an array:</span></span><br><span class="line">col_r1 = a[:, <span class="number">1</span>]</span><br><span class="line">col_r2 = a[:, <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(col_r1, col_r1.shape)  <span class="comment"># Prints &quot;[ 2  6 10] (3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(col_r2, col_r2.shape)  <span class="comment"># Prints &quot;[[ 2]</span></span><br><span class="line">                             <span class="comment">#          [ 6]</span></span><br><span class="line">                             <span class="comment">#          [10]] (3, 1)&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># An example of integer array indexing.</span></span><br><span class="line"><span class="comment"># The returned array will have shape (3,) and</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The above example of integer array indexing is equivalent to this:</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When using integer array indexing, you can reuse the same</span></span><br><span class="line"><span class="comment"># element from the source array:</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Equivalent to the previous integer array indexing example</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">1</span>], a[<span class="number">0</span>, <span class="number">1</span>]]))  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new array from which we will select elements</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[ 1,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5,  6],</span></span><br><span class="line">          <span class="comment">#                [ 7,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 11, 12]])&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array of indices</span></span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select one element from each row of a using the indices in b</span></span><br><span class="line"><span class="built_in">print</span>(a[np.arange(<span class="number">4</span>), b])  <span class="comment"># Prints &quot;[ 1  6  7 11]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mutate one element from each row of a using the indices in b</span></span><br><span class="line">a[np.arange(<span class="number">4</span>), b] += <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[11,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5, 16],</span></span><br><span class="line">          <span class="comment">#                [17,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 21, 12]])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>)   <span class="comment"># Find the elements of a that are bigger than 2;</span></span><br><span class="line">                     <span class="comment"># this returns a numpy array of Booleans of the same</span></span><br><span class="line">                     <span class="comment"># shape as a, where each slot of bool_idx tells</span></span><br><span class="line">                     <span class="comment"># whether that element of a is &gt; 2.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bool_idx)      <span class="comment"># Prints &quot;[[False False]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We use boolean array indexing to construct a rank 1 array</span></span><br><span class="line"><span class="comment"># consisting of the elements of a corresponding to the True values</span></span><br><span class="line"><span class="comment"># of bool_idx</span></span><br><span class="line"><span class="built_in">print</span>(a[bool_idx])  <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can do all of the above in a single concise statement:</span></span><br><span class="line"><span class="built_in">print</span>(a[a &gt; <span class="number">2</span>])     <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)         <span class="comment"># Prints &quot;int64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)             <span class="comment"># Prints &quot;float64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)   <span class="comment"># Force a particular datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)                         <span class="comment"># Prints &quot;int64&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise sum; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 6.0  8.0]</span></span><br><span class="line"><span class="comment">#  [10.0 12.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise difference; both produce the array</span></span><br><span class="line"><span class="comment"># [[-4.0 -4.0]</span></span><br><span class="line"><span class="comment">#  [-4.0 -4.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x - y)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise product; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 5.0 12.0]</span></span><br><span class="line"><span class="comment">#  [21.0 32.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x * y)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise division; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 0.2         0.33333333]</span></span><br><span class="line"><span class="comment">#  [ 0.42857143  0.5       ]]</span></span><br><span class="line"><span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="built_in">print</span>(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise square root; produces the array</span></span><br><span class="line"><span class="comment"># [[ 1.          1.41421356]</span></span><br><span class="line"><span class="comment">#  [ 1.73205081  2.        ]]</span></span><br><span class="line"><span class="built_in">print</span>(np.sqrt(x))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inner product of vectors; both produce 219</span></span><br><span class="line"><span class="built_in">print</span>(v.dot(w))</span><br><span class="line"><span class="built_in">print</span>(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / vector product; both produce the rank 1 array [29 67]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(v))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / matrix product; both produce the rank 2 array</span></span><br><span class="line"><span class="comment"># [[19 22]</span></span><br><span class="line"><span class="comment">#  [43 50]]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(y))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, y))</span><br></pre></td></tr></table></figure><h2 id="问题">问题</h2><p>遇到一个问题： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            nums.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        </span><br><span class="line">        inorder(proot)</span><br></pre></td></tr></table></figure> 这段代码不会报错，但是如果： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cnt, ans = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == k:</span><br><span class="line">                ans = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.right)</span><br></pre></td></tr></table></figure> 就会报错<code>UnboundLocalError: local variable 'cnt' referenced before assignment</code> 不太理解为啥list没事，后来<a href="https://stackoverflow.com/questions/2609518/unboundlocalerror-with-nested-function-scopes">SO</a>上的回答我大概明白了： python通过赋值操作来判断是否是局部变量，但是nums的append不是赋值，因此只要不在嵌套函数里赋值都不会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">dict</span>()</span><br><span class="line">b = &#123;&#125;</span><br><span class="line">c = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A new classification algorithm recommendation method based on link prediction</title>
      <link href="/2021/01/28/A%20new%20classification%20algorithm%20recommendation%20method%20based%20on%20link%20prediction/"/>
      <url>/2021/01/28/A%20new%20classification%20algorithm%20recommendation%20method%20based%20on%20link%20prediction/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要还是在元模型上创新，采用基于链接预测的方式为新数据集推荐分类算法。基本框架如下：<br /><img src="https://img-blog.csdnimg.cn/20210127113628615.png" alt="在这里插入图片描述" /><br />用元学习做AutoML主要关注：元特征、元目标的表现形式、元模型。 ## 元特征 第一步包括提特征和识别可用算法。<br />目前流行的元特征有5种：</p><ul><li>statistical and information-theory based</li><li>model structure based</li><li>landmarking</li><li>problem-complexity</li><li>structural information</li></ul><p>由于每个数据集可能有不定数目的可用算法，文章采用了multiple comparison procedure：如果我们用acc作为衡量标准（除此以外本文还用了ARR作为标准，将时间因素也考虑进去），这个程序能用统计检验的方法发现一系列与最佳算法相差不显著的候选算法。文中具体使用的统计检验方法是Friedman Test+Holm procedure test，即如果Friedman Test认为所有算法性能相差不显著，那么所有的算法都是meta target；否则以表现最佳的算法为参考，用Holm procedure test去识别和最佳算法没有显著差异的算法们作为meta target。<br />这样就得到了元数据<span class="math inline">\(M=\{m_1,...,m_n\},m_i=&lt;x_i,y_i&gt;\)</span>，其中<span class="math inline">\(x_i=(f_{i1},...,f_{ip})\)</span>是该数据集的p个元特征，<span class="math inline">\(y_i=(a_1,...,a_q)\)</span>是q个合适的算法。</p><h2 id="元目标形式">元目标形式</h2><p>有4种：</p><ul><li>单标签</li><li>多标签</li><li>连续值：预测算法的表现，回归问题</li><li>排序：预测算法之间的相对顺序</li></ul><h2 id="元模型">元模型</h2><ul><li>分类</li><li>回归</li><li>ranking</li></ul><p>本文将问题看作多标签分类，并采用DAR图+链接预测作为分类模型。<br />建的是一个异构图，有数据集（元特征作为结点属性）和算法（算法名作为属性）两种结点，有d-d和d-a两种无向边，d-d边的构建通过数据集间的相似性（<strong>欧氏距离</strong>最近的k个邻居，需要将元特征标准化min-max scaling），d-a边就用每个数据集的候选算法构建。<br />建图的伪代码：<br /><img src="https://img-blog.csdnimg.cn/2021012815482635.png" alt="在这里插入图片描述" /><br />建好图后就可以推荐了，伪代码如下：<br /><img src="https://img-blog.csdnimg.cn/20210128161524948.png" alt="在这里插入图片描述" /><br />文章里LPMethod有3种：Katz,LRW,SRW。<br />综上，预测时需要的参数有：训练集<span class="math inline">\(D=\{d_1,...,d_n\}\)</span>，候选算法集<span class="math inline">\(A=\{a_1,..,a_m\}\)</span>，推荐的算法数目，每个数据集结点的邻边数目<span class="math inline">\(k\)</span>。</p><h2 id="评估">评估</h2><p>评估指标包括5个：Hamming损失、F值、acc、HitRatio、RA（推荐准确率）。<br />考虑DAR图的边的权重，类似概率图模型</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoML </tag>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Climbing Summary</title>
      <link href="/2021/01/22/Climbing%20Summary/"/>
      <url>/2021/01/22/Climbing%20Summary/</url>
      
        <content type="html"><![CDATA[<p>看完<em>Everest</em>之后，我也做着有朝一日登顶珠峰的白日梦。懒癌晚期也没爬过几座山，希望有机会挑战下雪山（嘿！又一个雄心勃勃的flag）。</p><ul><li>骊山<br />没什么好说的，海拔1300+，高中翻个墙就是山路，基本没有难度。</li><li>太白山<br />很冷，海拔3700+，6月上到峰顶还是很冷，只有下面是旅游开发区，上面一大部分路段都没有开发，只是用石头简单铺了，手机没有信号，基本没有歇脚的地，风吹得你怀疑人生。</li><li>华山<br />海拔2100+，夏天上去完全不用外套，注意防晒，爬起来也没啥难度，基本开发地都不错，只是很多地方非常险峻，比如鹞子翻身、大索道，听说还有完全透明的那种。<br /><img src="https://img-blog.csdnimg.cn/20200829222658646.png" alt="在这里插入图片描述" /><br />路线很多，随你怎么走了。<br />我们是前一天晚上到华山北站，休息一晚，然后游客中心-&gt;北峰索道-&gt;北峰-&gt;中峰-&gt;东峰-&gt;南峰-&gt;西峰-&gt;西峰索道-&gt;游客中心，本来想走玉泉院徒步上去，但是人家关闭了，而且一天时间也不够，晚上在华山北休息了一晚，第三天早上回西安。<br />我觉得最刺激的有几处：<br />很多地方都有那种近乎于垂直的台阶，甚至有超过90度的，反正我上到一半就撤了。。<br />鹞子翻身：没敢玩<br />长空栈道：没敢去<br />西峰索道：下行20min，真刺激，山谷间吹个小风，索道就左右飘~</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MLE &amp; MAP</title>
      <link href="/2021/01/16/MLE%20&amp;%20MAP/"/>
      <url>/2021/01/16/MLE%20&amp;%20MAP/</url>
      
        <content type="html"><![CDATA[<p>自从贝叶斯理论诞生以后，频率学派和贝叶斯学派的争论一直没有停歇，平时的学习太注重公式计算，故在此谈谈自己对贝叶斯理论的一些认识。</p><p>频率学派认为概率是基于大量实验所得的定值（大数定理），比如抛掷一枚材质均匀的硬币10000次，出现正面的次数有4995次，反面的次数有5005次，大致认为出现正反面的概率都是50%。然而现实生活中很多事情是无法做大量实验的，比如某人得心脏病的概率是5%，显然我们无法通过多次实验来计算出这个概率值。回到硬币的例子，如果只允许你抛5次，5次的结果都是正面，那么出现正面的概率是100%了吗？显然这是存在弊端的。</p><p>再来看一个非常经典的医学上的例子：有一种很稀有的病，得病的人检测结果呈阳性的概率是0.9，没得病的人检测结果呈阴性的概率也是0.9，人们患这种病的概率是0.01。如果某人的检测结果呈阳性，那么他患这种病的概率是多少？</p><p>直观上看：患病的人检测呈阳性的概率是0.9，这个人被检测为阳性，那么有很大概率这个人是患病的。不妨试着算算：</p><p>假设用A表示检测结果为阳性，B表示患病，那么可以很轻松的计算出： <span class="math display">\[P(B|A)=\frac{P(A|B)P(B)}{P(A)}=\frac{P(A|B)P(B)}{P(A|B)P(B)+P(A|\bar B)P(\bar B)}=\frac{0.9*0.01}{0.9*0.01+0.1*0.99}=0.083 \\P(\bar B|A)=1-P(B|A)=0.917\]</span> 可以看到：即使检测结果呈阳性，患病的概率仍然只有8.3%，和我们的直观认识并不相同。</p><p>上面的计算其实就用了贝叶斯公式：后验概率<span class="math inline">\(P(B|A)\)</span>等于条件概率<span class="math inline">\(P(A|B)\)</span>（似然函数）乘以先验概率<span class="math inline">\(P(B)\)</span>，再除以一个常数因子。我们在已知先验概率的前提下，通过新的观测值<span class="math inline">\(P(A|B)\)</span>（检测结果是否阳性）来预测患病的概率。</p><p>关于常数因子<span class="math inline">\(P(A)\)</span>可以这样理解：分子<span class="math inline">\(P(A,B)\)</span>表示检测结果呈阳性并且患病的概率，那么还有一部分人<span class="math inline">\(P(A,\bar B)\)</span>检测结果呈阳性但是没有患病，<span class="math inline">\(P(A,B)+P(A,\bar B)=P(A)\)</span>，我们要求的<span class="math inline">\(P(B|A)\)</span>即检测呈阳性的人中患病的人所占的比例<span class="math inline">\(\frac{P(A,B)}{P(A)}\)</span>。</p><p>更加一般的贝叶斯公式：</p><p>如果参数<span class="math inline">\(\theta\)</span>的分布是离散的： <span class="math display">\[\pi(\theta_i|x)=\cfrac{\pi(\theta_i)f(x|\theta_i)}{\sum_{i}\pi(\theta_i)f(x|\theta_i)}\]</span> 如果参数<span class="math inline">\(\theta\)</span>的分布是连续的： <span class="math display">\[\pi(\theta|x)=\cfrac{\pi(\theta)f(x|\theta)}{\int_{\Theta}\pi(\theta)f(x|\theta)d\theta}\]</span> 后验概率密度表示在已知x的前提下关于参数<span class="math inline">\(\theta\)</span>的一个概率密度函数，即<span class="math inline">\(\theta\)</span>是一个分布，而不是一个固定的值，这是贝叶斯学派与传统学派最大的不同。</p><p>似然函数<span class="math inline">\(f(x|\theta)\)</span>可以这么理解：每个事件的背后都有一个分布，这个分布里是含有参数的，并且传统学派认为这个参数<span class="math inline">\(\theta\)</span>是固定的，我们做了大量的实验，用很多样本x就是为了求出这个参数的值，观测到的样本x是以参数<span class="math inline">\(\theta\)</span>为前提的一个分布。为了估计<span class="math inline">\(\theta\)</span>，我们用到了<strong>矩估计</strong>和<strong>极大似然估计</strong>，本质上都是一样的，我们在参数<span class="math inline">\(\theta\)</span>的前提下，从总体X中采样n个样本，用样本的性质来大致替代总体的参数<span class="math inline">\(\theta\)</span>。具体到极大似然：通过找到使似然函数<span class="math inline">\(\prod_{i=1}^{n}f(x_i|\theta)\)</span>最大的参数当作<span class="math inline">\(\theta\)</span>，其实就是选择一个<span class="math inline">\(\theta\)</span>使得样本出现的概率最大，本质上仍然是在拟合样本数据。</p><p>从上面的分析可以看出：我们的未知参数<span class="math inline">\(\theta\)</span>是从样本中计算得到的，必然和总体中原本的参数值存在误差，并且只能求得一个固定的参数值。贝叶斯理论认为：参数<span class="math inline">\(\theta\)</span>不应该是一个单独的值，更加合理的解释应该是参数<span class="math inline">\(\theta\)</span>有很多取值，并且每个取值都有相应的概率，即参数是服从某种分布的。概率最大的那个参数值即<strong>最大后验估计</strong>，参数取值的中位数即<strong>后验中位数估计</strong>，参数取值的均值即<strong>后验期望估计</strong>。为什么仍然叫估计呢？因为我们的后验分布是从似然计算得到的，我们无法采样所有的总体中的样本，所以也就无法计算出参数<span class="math inline">\(\theta\)</span>的精确分布。</p><p>最后来看看先验分布<span class="math inline">\(\pi(\theta)\)</span>，即在获得实验观测值之前对未知参数分布的一个主观认识，这也是贝叶斯学派一直被攻击的一点，客观的统计学中竟然引入了主观的因素！比如对于材质均匀的硬币，在抛掷之前，我们脑海中就会认为出现正反面的概率各是0.5。</p><p>但是很多时候先验分布是很难获得的，如果硬币材质不均匀，我们的先验又应当是什么分布呢？此时就引入了课程上讲的<strong>无信息先验</strong>，当我们对事件没有了解的时候，认为参数所有取值的概率都是相等的，在硬币实验中，我们认为<span class="math inline">\(\theta\)</span>是服从(0,1)的均匀分布。接着我们来做实验，看看后验分布会怎么变化（图源：Cameron Davidson-Pilon, Probabilistic Programming and Bayesian Methods for Hackers, 2016）：</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/11e883581dd48f9c8442b8273371766d.png" alt="" /><figcaption>img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/3110af9ecffd601bb7acd89d86ad9784.png" alt="" /><figcaption>img</figcaption></figure><p>从图中可以看出：起初是均匀分布，连续抛掷了2次正面，此时认为该硬币正面向上的概率为1的可能性是最大的，但注意：正面向上的概率取0.6,0.4的可能也不是没有，不过这种可能性更小罢了。如果我们用极大似然去估计，就会得到该硬币正面向上的概率是1，正面向上的概率取0.6,0.4的可能为0，这显然与现实不符！接着抛了一次反面，正面向上的概率分布又进行了修正，不断通过观测值修正我们的后验，最终得到一个稳定的后验分布。</p><p>均匀分布<span class="math inline">\(U(a,b)\)</span>作为先验看起来很好用，但是他本质上还是有倾向性的，即认为在区间(a,b)内是有取值的，在区间外是没有取值的可能的，更加合理的无信息先验可以选取一个大方差的高斯分布。</p><p>选择高斯分布作为先验带来的一个问题是计算上的复杂性骤然提高，所以引入了<strong>共轭先验分布</strong>：即后验分布<span class="math inline">\(\pi(\theta|x)\)</span>与先验分布<span class="math inline">\(\pi(\theta)\)</span>是同一种类型的分布，就称先验分布<span class="math inline">\(\pi(\theta)\)</span>是<span class="math inline">\(f(x|\theta)\)</span>的共轭先验分布。这样我们在计算后验分布时，就无需计算复杂的积分，只要调整先验分布的参数即可确定后验分布。可以证明：<span class="math inline">\(\beta\)</span>分布是二项分布<span class="math inline">\(B(n,p)\)</span>中参数<span class="math inline">\(p\)</span>的共轭先验分布。即如果总体<span class="math inline">\(X|\theta\sim B(N,\theta)\)</span>，从中采样n个样本，样本分布即似然函数<span class="math inline">\(f(x|\theta)\)</span>服从<span class="math inline">\(\beta\)</span>分布，假设先验<span class="math inline">\(\theta\sim\beta(a,b)\)</span>，那么后验分布<span class="math inline">\(\theta|x\sim\beta(a+\sum x_i,b+nN-\sum x_i)\)</span>。</p><p>证明： 总体<span class="math inline">\(X|\theta\sim B(N,\theta)\)</span>，先验<span class="math inline">\(\theta\sim\beta(a,b)\)</span>，<span class="math inline">\(X=(X_1,...,X_n)^T\)</span>是来自总体的n个样本，则样本分布为： <span class="math display">\[p(x|\theta)=L(\theta)=\prod_{i=1}^{n}\tbinom{N}{x_i}\theta^{x_i}(1-\theta)^{N-x_i}\propto\theta^{\sum_{i=1}^{n}x_i}(1-\theta)^{nN-\sum_{i=1}^{n}x_i}\]</span> 可以看到：似然函数<span class="math inline">\(L(\theta)\)</span>具有<span class="math inline">\(\beta\)</span>分布的核，先验的核为<span class="math inline">\(\theta^{a-1}(1-\theta)^{b-1}\)</span>，所以后验为： <span class="math display">\[\pi(\theta|x)\propto\theta^{a-1+\sum_{i=1}^{n}x_i}(1-\theta)^{b-1+nN-\sum_{i=1}^{n}x_i},0&lt;\theta&lt;1\]</span> 显然后验分布的核与<span class="math inline">\(\beta\)</span>分布的核是同种类型，即<span class="math inline">\(\theta|x\sim\beta(a+\sum x_i,b+nN-\sum x_i)\)</span>，所以<span class="math inline">\(\beta\)</span>分布是二项分布<span class="math inline">\(B(n,p)\)</span>中参数<span class="math inline">\(p\)</span>的共轭先验分布。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率统计基础</title>
      <link href="/2021/01/11/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/01/11/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>联合概率<span class="math inline">\(P(A,B)\)</span>即两个事件同时发生的概率 条件概率（后验概率）<span class="math inline">\(P(A|B)P(B)=P(B|A)P(A)\)</span> 全概率公式 <span class="math display">\[P(A)=\sum_nP(A,B_n)=\sum_nP(A|B_n)P(B_n)\]</span> 贝叶斯定理： <span class="math display">\[P(A|B)=\frac{P(B|A)P(A)}{P(B)}\]</span> <span class="math inline">\(A\)</span>的后验概率等于标准相似度乘以先验概率</p><p>离散型随机变量概率分布（分布律）： |<span class="math inline">\(X\)</span>| <span class="math inline">\(x_1\)</span>|...|<span class="math inline">\(x_i\)</span>|... |--|--|--|--|--| | <span class="math inline">\(P\)</span>| <span class="math inline">\(p_1\)</span>|...|<span class="math inline">\(p_i\)</span>|... 满足<span class="math inline">\(p_i\geq0, \sum_{i=1}^{\infty}p_i=1\)</span></p><p>0-1分布：<span class="math inline">\(X\sim B(1,p)\)</span> |<span class="math inline">\(X\)</span>| 0|1| |--|--|-- |<span class="math inline">\(P\)</span>|<span class="math inline">\(1-p\)</span>|<span class="math inline">\(p\)</span>| <span class="math display">\[P(X=k)=p^k(1-p)^{1-k},k=0,1\]</span></p><p>二项分布：<span class="math inline">\(X\sim B(n,p)\)</span> <span class="math inline">\(n\)</span>重伯努利试验 <span class="math display">\[P(X=k)=C_n^kp^k(1-p)^{n-k},k=0,1,...,n\]</span></p><p>Poisson分布：<span class="math inline">\(X\sim P(\lambda)\)</span> <span class="math display">\[P(X=k)=\frac{\lambda^ke^{-\lambda}}{k!},k=0,1,...,n,\lambda&gt;0\]</span> <span class="math inline">\(E(X)=\lambda,D(X)=\lambda\)</span> 可以证明：Poisson分布是二项分布在<span class="math inline">\(\lambda=np,n\to\infty\)</span>的极限分布。</p><p>连续型随机变量概率分布函数：<span class="math inline">\(F(x)=\int_{-\infty}^{x}f(t)dt\)</span>，<span class="math inline">\(f(x)\)</span>称为概率密度函数。 均匀分布：<span class="math inline">\(X\sim U(a,b)\)</span> <span class="math display">\[f(x)=\begin{cases}\cfrac{1}{b-a}, &amp;x\in(a,b)\\0, &amp;其它\end{cases}\]</span> 指数分布：<span class="math inline">\(X\sim E(\lambda)\)</span> <span class="math display">\[f(x)=\begin{cases}\lambda e^{-\lambda x}, &amp;x&gt;0\\0, &amp;x\leq0\end{cases}\]</span> 正态分布（高斯分布）：<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span> <span class="math display">\[f(x)=\cfrac{1}{\sigma \sqrt{2\pi}}e^{-\cfrac{(x-\mu)^2}{2\sigma^2}}\]</span> <span class="math inline">\(\mu\)</span>是位置参数，决定对称轴位置；<span class="math inline">\(\sigma\)</span>是尺度参数，决定分布的幅度。 标准正态分布<span class="math inline">\(X\sim N(0,1)\)</span></p><p>数学期望： 离散型：<span class="math inline">\(E(X)=\sum_ip_ix_i\)</span> 连续型：<span class="math inline">\(E(X)=\int_{-\infty}^{+\infty}xf(x)dx\)</span></p><p>方差：随机变量的离散程度，距离期望的距离 <span class="math inline">\(D(X)=E[(X-E(X))^2]=E(X^2)-E(X)^2\)</span> <span class="math display">\[D(X)=\cfrac{1}{N}\sum_{i=1}^{N}(x_i-\mu)^2=\cfrac{1}{N}(\sum_{i=1}^{N}x_i^2-N\mu^2)\]</span> 离散型：<span class="math display">\[D(X)=\sum_{i=1}^{\infty}[x_i-E(X)]^2p_i\]</span> 连续型：<span class="math display">\[D(X)=\int_{-\infty}^{+\infty}[x-E(X)]^2f(x)dx\]</span></p><p>标准差（均方差）是方差的算术平方根</p><p>样本标准差： <span class="math display">\[s=\sqrt{\cfrac{1}{n-1}\sum_{i=1}^{n}(x_i-\bar x)^2}\]</span> 对于二维随机变量，协方差用来描述<span class="math inline">\(X\)</span>与<span class="math inline">\(Y\)</span>之间的相互关系： <span class="math display">\[Cov(X,Y)=E\{[X-E(x)][Y-E(Y)]\}\]</span></p><p>相关系数： <span class="math display">\[\rho_{XY}=\cfrac{Cov(X,Y)}{\sqrt{D(X)D(Y)}}\]</span></p><p>de Movire-Laplace中心极限定理： <span class="math inline">\(n_A\)</span>为<span class="math inline">\(n\)</span>重伯努利试验中<span class="math inline">\(A\)</span>发生的次数，<span class="math inline">\(P(A)=p\)</span>，对任意实数<span class="math inline">\(x\)</span>，有： <span class="math display">\[\lim\limits_{n\to+\infty}P(\cfrac{n_A-np}{\sqrt{np(1-p)}}\leq x)=\int_{-\infty}^{x}\cfrac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}dt=\Phi(x)\]</span> <span class="math inline">\(n\)</span>充分大时，<span class="math inline">\(n_A\sim N(np,np(1-p))\)</span>，故： <span class="math display">\[P(a&lt;n_a\leq \]</span>="" <span class="math inline">\(n\)</span>充分大时，<span class="math inline">\(\sum_{i=&quot;1}^{n}X_i\sim&quot; \cfrac{\sqrt{n}(\bar=&quot;&quot; \lim\limits_{n\to+\infty}p(|\cfrac{n_x}{n}-p|&lt;\epsilon)=&quot;1&quot; b)\approx\phi(\cfrac{b-n\mu}{\sqrt{n}\sigma})-\phi(\cfrac{a-n\mu}{\sqrt{n}\sigma})=&quot;&quot; b)\approx\phi(\cfrac{b-np}{\sqrt{np(1-p)}})-\phi(\cfrac{a-np}{\sqrt{np(1-p)}})=&quot;&quot; n(0,1)=&quot;&quot; n(0,1)\)</span>，即：="" n(0,1)<span class="math inline">\(，故：=&quot;&quot; n(n\mu,n\sigma^2)\)</span>，<span class="math inline">\(y_n\sim=&quot;&quot; p(a&lt;\sum_{i=&quot;1}^{n}X_i\leq&quot; x-\mu)}{\sigma}\sim=&quot;&quot; y_n=&quot;\cfrac{\sum_{i=1}^{n}X_i-n\mu}{\sqrt{n}\sigma}&quot; 中心极限定理表明：任意的一个概率分布中生成的随机变量，其序列和统一地归约到正态分布：\)</span>y_n="" 伯努利大数定律：事件<span class="math inline">\(x\)</span>在每次试验中发生概率是<span class="math inline">\(p\)</span>，<span class="math inline">\(n\)</span>次独立重复试验中，<span class="math inline">\(x\)</span>发生的次数为<span class="math inline">\(n_x\)</span>，则：="" 即事件的发生频率依概率收敛于事件的概率。="" 独立同分布中心极限定理：="" 辛钦大数定律：<span class="math inline">\(x_i\)</span>为独立同分布的随机变量序列，且期望<span class="math inline">\(\mu\)</span>存在，则对<span class="math inline">\(\forall\epsilon=&quot;&quot; 随机变量\)</span>x_1,x_2,...,x_n,...<span class="math inline">\(独立同分布，\)</span>e(x_i)=",D(X_i)=^2<span class="math inline">\(，前\)</span>n<span class="math inline">\(个变量和的标准化变量为：&quot;&gt;0\)</span>，有： <span class="math display">\[\lim\limits_{n\to+\infty}P(|\cfrac{1}{n}\sum_{i=1}^{n}X_i-\mu|\geq\epsilon)=0\]</span></p><p>正太分布熵的大小，取决于方差的大小。&lt;/n_a&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逼乎摘选</title>
      <link href="/2020/12/31/%E9%80%BC%E4%B9%8E%E6%91%98%E9%80%89/"/>
      <url>/2020/12/31/%E9%80%BC%E4%B9%8E%E6%91%98%E9%80%89/</url>
      
        <content type="html"><![CDATA[<p><font size="2"><em>早已决定退乎，将一些曾经的收藏稍加整理摘录于此，均已注明出处，侵删</em></font></p><h2 id="多任务下如何保持高效率"><a href="https://www.zhihu.com/question/374401049/answer/1055275763">多任务下如何保持高效率</a></h2><p>第一件事情，是想一想什么事情是自己应该做的，什么是要推给别人的，什么是要找人讨论再做，什么需要等一阵子的。这个是战略问题，比任何战术上的技巧都管用。多任务完成得再快，做自己不应该做或者不需要做的事情，只会累死累活还没什么用。</p><p>随时想着如果不玩这局棋了，把棋盘掀翻重来会是什么结果？也许会有更好的解法。</p><p>在这之后，再讨论战术。以下是一些应付多任务的具体方案：</p><ol type="1"><li>每做一个任务要百分百集中（比如说现在在写这个答案的时候，就不要写一半刷手机了）。</li><li>每个任务最好持续一段时间（我的经验是最少15分钟），切去一个需要一定脑力的任务，做5分钟再切回来基本上没有成功的例子。10分钟的任务除非在做之前有非常清楚的规划，不然要不什么事都没做成（比如说还在手忙地找浏览器里的相关标签页），要不因为专注而超时。</li><li>每个任务有非常明确的完成指标。比如说某个任务是代码能跑起来，文章的introduction看完，或是审完一篇论文并且写出评审建议。不完成不要停手。如果实在得要暂停（比如说得去开会），记得把完成指标再分得更细一些。</li><li>难的和简单的任务可以错开做。做完难的需要休息可以做些简单但不得不做的，做完简单的可以再切回难的（这样有挑战性）。如果发现自己并不需要休息就迫不及待地去做下一个任务了，说明任务安排得好。</li><li>不要安排得太满，不要要求每天都一定要全部完成。总会有完不成的事项。我觉得我每天订的TODO list总有一两个没完成，然后就会发现，有些其实并不重要，有些其实挺重要但下意识逃避了，下次就要把它们拿出来第一个做完。</li><li>经常锻炼，充足睡眠，合理膳食，才能保持充沛精力。偶尔熬夜也许确实活多，但天天熬夜，就说明战略上有大问题了，身体不是这么玩的。</li></ol><h2 id="应届生是选择一个公司还是选择一个行业"><a href="https://www.zhihu.com/question/27032313/answer/315544084">应届生是选择一个公司，还是选择一个行业</a></h2><p>人生的幸福，我的感觉来自自律，独立思考能力，控制住自己的欲望，保持对新事物的敏感度和参与度。</p><p>比选择行业更重要的是一个人独立思考能力，自己纠错，自己拯救自己的能力。</p><p>我混到今天一直在自己做决策，从大学填写志愿，到跳槽，找工作，做生意，都从来不问别人，都是自己研究琢磨。我也有问人的时候，但是我从来不问人生该怎么选择，我只问具体的技术性问题。</p><p>保持对物欲的控制，管理好自己，培养良好的习惯，我们可以摆脱很多不必要的麻烦。</p><h2 id="你生命中最艰难痛苦的一段时间是如何度过的"><a href="https://www.zhihu.com/question/24917544/answer/154775610">你生命中最艰难、痛苦的一段时间是如何度过的</a></h2><p>对于我来说，从来没有觉得有什么最艰难和痛苦的日子。人生本来就是一场旅行，能够和爱的人在一起度过，又何必在意旅途的风景是什么风格。也许，这场旅途对于我来说，只是可能比父母和孩子早下车几站而已。</p><p>当你用心拼尽全力过好每一天，会发现早死晚死都是一种平淡无奇的结果，艰难困苦只是自己给自己懦弱和懒惰的开脱词。祝尚有余生的各位安好。</p><h2 id="活着不开心怎么办"><a href="https://www.zhihu.com/question/29956916/answer/311913864">活着不开心怎么办</a></h2><p>如何减少不开心？一是别瞎去比较，人确实都有损失厌恶，但你如果不主动去做一些无谓的比较，就能让自己舒服很多；另一个是别瞎揣摩别人，别因为不理解别人，而给自己制造不必要的不快。</p><p>说完这两点还没完，因为它俩都属于“别做什么”，还要再聊一点“要做什么”。</p><p>要自在如风，要在不违反法律、不伤风败俗的前提下去尽情享受生活，享受自由。</p><p>我以前觉得那些走在马路上唱着歌还唱得不好听的人特别蠢，可是人家一点都不蠢，他唱歌的样子就能证明他很快乐。</p><p>那些跳广场舞的大妈，人家是真的开心，在跳舞的过程中，她们是心情愉悦的，不然谁会每天都准点跑去跳啊。</p><p>咱们也得好好对待自己，别老那么在意别人的目光，人家路人其实压根就不在意你。</p><h2 id="如何看待论调所谓稳定不过是在浪费生命"><a href="https://www.zhihu.com/question/278108330/answer/400776080">如何看待论调「所谓稳定不过是在浪费生命」</a></h2><p>纸醉金迷可能会有一时之爽，但午夜梦回，浮现在眼前的是孩提时代的无忧无虑，还是高档场所的推杯换盏，真不一定。</p><p>内心的平安才是真正的平安。</p><p>人活着，要常常问自己，到底想要什么。不要总跟别人比较，不要过于苛求自己。和自己相识，和自己和解。</p><p>盗用头文字D的一句台词，这世界上只有一种成功，就是能够用自己喜欢的方式度过一生，这才是成功最返璞归真的定义。</p><h2 id="我们是怎样一步步地走向平庸的"><a href="https://www.zhihu.com/question/33220674/answer/58248246">我们是怎样一步步地走向平庸的</a></h2><p>认为我这么一个大好人才，却被投闲置散，落至今时今日这样的田地。</p><p>也试过自怨自艾，认为自己不知不觉间变成了一个废人。</p><p>直到这个时候，我才知道，我之所以觉得亲朋好友们的夸赞大惊小怪，其实是因为在我心底，我一直以为自己本来就应该是个天之骄子。</p><p>一路以来走得太过顺畅，我以为自己并不高傲自大，其实这种高傲自大已经深入骨髓，我根本没有机会察觉。</p><p>及至看到周围那些，曾经和我一个水平，甚至不如我的人，踏踏实实地走每一步，一步一步地抛离我，我才慢慢意识到，我并不是什么天之骄子，我只是一个平平凡凡的人。</p><p>接受自己是一个庸人这个过程非常痛苦。我每天都在剧烈的内心煎熬中。</p><p>一时劝说自己，生来便是庸人，坦然接受便是。一时又斗志激昂，只要努力，我便能回到原来天之骄子的位置上。</p><p>食不能安，夜不能寐。精神的压力直接导致身体的衰弱，一度卧病在床。</p><p>每个人都理所当然地演绎着自己的每一日。</p><p>相比之下，我国内的朋友，最近一个个结婚生子，安居乐业。我的妹妹，看起来学历能力一切不如我，却兢兢业业安安稳稳地工作着，闲时与朋友吃吃烧烤喝喝啤酒，上瑜伽班，学画画，日子过得不亦乐乎。</p><p>你说这样是平庸吗？然而她却觉得幸福无比。我拿着两个名校的学位又一次进入了名企，努力了那么久，曾经我以为我也算一直在进步，最后也不过是朝九晚五地工作。</p><p>而此时此刻，我只想回到家人的身边，过那带着油烟味的乏味无奇的日子。</p><p>我想，大千世界，谁人不平庸谁人平庸，一切不过是心魔。努力上进也好，安稳度日也好，若是不幸福不快乐，又有何用。</p><h2 id="大学毕业之后同学之间慢慢拉开了差距还有必要参加老同学聚会吗"><a href="https://www.zhihu.com/question/20004337/answer/18961389">大学毕业之后，同学之间慢慢拉开了差距，还有必要参加老同学聚会吗</a></h2><p>唯有真正的好朋友，你过得好，他们反倒会问候你，这样累不累，不累就好；你过得不好，他们也会真心体贴你：「没关系，加油，做你自己想做的事，兄弟帮不到你，但你不开心的时候，可以找兄弟出来喝喝酒、吃吃饭、唱唱歌，哥儿几个陪你。」</p><p>当朋友之间不用显示优越感时，就能好好聊天了。</p><h2 id="如何让自己变得开心起来"><a href="https://www.zhihu.com/question/20657503/answer/28028792">如何让自己变得开心起来</a></h2><p>不要和他人比较。我在精神病院工作，我可以直截了当的告诉你：太多看上去成功和开心的人被自己内心的骚动活活折磨疯了。所以，只要专注自己就好。</p><p>参与社交。即使你是一个内向的人，也要强迫自己去进入社交环节，这会给你和人结识、建立联系的机会。这些联系会使你和你的人性连接在一起。</p><p>做有关健康的决策。运动和好的饮食会改变你的世界观，这是很神奇的。你脑中看起来很真实很迫切的消极想法会消失的。</p><p>做不一样的事情。不要再浪费时间试图找到“完美的爱好”了。学习一点新的，无论是纤维艺术还是品尝咖啡。找到一件你可以投入精力的东西，自己能够胜任，然后等待结果。</p><p>和转折点保持联系。当我们长大的时候我们就慢慢失去了那些转折点。试着在任何一个你觉得亲切的群体里更好的安置自己，无论那个群体是你的家庭，你的邻居，你的文明，或是你的种族。</p><p>少往前看，少往后看。试着更多关注现在的自己。开始建立回忆而不是活在回忆里。开始创造你的未来而不是期待更好的未来。如果你不这样做，你的生活就会成为一片雾，横跨你的整个人生。（在某个阶段做事时候，不要总想着下一阶段，专注于现在。）</p><p>创造。在旅行中书写，或者画点什么。写一首歌，即使你从未演奏它。当你走的时候，开始改变你遗留下来的纪念品。</p><p>放手。原谅那些伤害你的人。我很遗憾你受到了伤害。但是如果你不将那些伤痛留在过去，它就会像狼一样跟着你——当你做任何事情的时候，它永远扮演着一个危险的影子。</p><p>更多的为他人担心。很多时候是我们的自恋毁了我们。这听上去很反直觉，但是每天花些时间想想你生活中人们的需求。帮助他们实现一些需求会使你更加开心，这个你现在可能不会理解。</p><p>停止奔跑。其实没有一个地方是“在远处”的。你想旅行多远就多远，但是当你到达那里的时候，你将始终发现你在等待着自己。拔出你的剑。是时候回头和你心中的巨龙搏斗了。</p><h2 id="关于高考你印象最深的是什么"><a href="https://www.zhihu.com/question/24047876/answer/37943380">关于高考，你印象最深的是什么</a></h2><p>高考前的人生轻薄如纸，越往后走，生活才越显出复杂与沉重的本来面目。</p><p>我希望各位能在高考中取得好成绩，但我更希望，当你们背负着越来越沉重的人生往前走时，依然不会失去感受幸福的能力。</p><p>从知道得病至今我一直坦然和平静，我总是想，人不能只允许自己遇到好事，不允许自己遇到坏事。当不顺或困境找到我时，我会反问自己：为什么不可以是我？于是就能平静地去面对。</p><h2 id="这样的努力真的有意义吗"><a href="https://www.zhihu.com/question/23606484/answer/25156325">这样的努力真的有意义吗</a></h2><p>强者懂得，不管喜欢与否，现有的事情要做得漂亮。才有资格在人生方向确定时，发现自己已经有充分的积累，实现他们的梦想。</p><p>不管你是什么level的，永远有无数的人跟你同一个level，而你只要不断努力，就能超过这些本来跟你同level的人。</p><h2 id="你是如何变得不浮躁的"><a href="https://www.zhihu.com/question/19627497/answer/15875565">你是如何变得不浮躁的</a></h2><p>浮躁是因为急于求成而产生的一种不安的心理。心中总是想着做更多的事情，更快的获得成功，更快的抵达自己的目标，使我们忘记了，我们是为什么去做一件事情。</p><p>做一件事的最重要的是求的心灵的安宁。当我们充满激情的想做完成一件作品时，我们的心不是安宁的。一直到作品呈现出，它应该有的形式，我们心灵才获得了安宁，才获得了喜悦。</p><p>然而当你想着赶快做完一件事的时候，就说明你不再关心此事，而是想着下一件事，你匆匆忙忙的应付了眼前的事，然后又赶紧开始下一件事，你的心没有得到过安宁。前面事情又做的不够好，你会更不安，更浮躁。戒浮躁就要做好当下的事，投入你的热忱，直到做好它，那时你的心才得到安宁。</p><p>高僧把扫地也当成他生活的一部分，他沉浸于扫地这个过程，直到把地扫干净，他获得了心灵的安宁，这种安宁对他来说比任何东西都重要。他过得是一种沉浸式的生活。而心浮气躁的人总是过着肤浅的生活。</p><p>放慢自己做事情的速度，投入自己的热忱。不要着急地去做一件事情，先端正自己的态度，寻找做此事的热忱。</p><p>冥想，静坐，都是不错的训练方法。</p><h2 id="能否用一百字写清楚你最想要的生活"><a href="https://www.zhihu.com/question/34970791/answer/63071829">能否用一百字写清楚你最想要的生活</a></h2><p>冬。 大雪。 小火炉。 热巧克力。 温暖的沙发。 脚边打滚的猫。 阳台上赏雪的狗。 笼子里好动的仓鼠。 靠在我肩上瞌睡的你。 水瓶里开得正盛的鲜花。 爸妈刚打来一个电话。 你们有空回来喝茶。 我给你盖上被子。 没想吵醒你啦。 你揉了揉眼。 一起睡吧。 那好吧。 讨厌！ 哈。</p><h2 id="如何做一个让人眼前一亮的presentation"><a href="https://www.zhihu.com/question/28639137/answer/374782107">如何做一个让人眼前一亮的presentation</a></h2><p>当然，不同场合需要不同的风格，但是整体流程一定要像讲故事一样，大致有3步：</p><ol type="1"><li>一个看似平静的现状<br />不超过10%时间，用一个小故事开场引出问题，接着要改造，团队应运而生，我是xx团队的xxx，团队致力于xxx，最主要的feature是xxx</li><li>遇到困难，甚至已经不行了<br />对比，幽默、数据展示、逻辑说明（乔布斯）<br />经典采访音频、震撼的图片<br />大图片+小文字<br />大数字+小文字<br /></li><li>凭借聪明才智翻转，最终战胜困难<br />勾画出一个美好的愿景</li></ol><p>下来就是看一些经典的发布会，加强练习。</p>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Predecessor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Performance Measurement</title>
      <link href="/2020/12/20/Performance%20Measurement/"/>
      <url>/2020/12/20/Performance%20Measurement/</url>
      
        <content type="html"><![CDATA[<p>程序性能的衡量一般有2种方式：Benchmarking和Profiling。 ## Benchmarking Benchmarking通过绝对运行时间来比较程序的整体性能，例如给定一组同样的输入，比较不同版本的程序在同样硬件环境下的运行时间，或者比较相同版本程序在不同硬件环境下的运行时间。</p><h2 id="profiling">Profiling</h2><p>Profiling通常用来识别程序的耗时瓶颈（通常是一些函数），优化这些瓶颈后再去做Benchmarking评估整体性能。<br />Unix系统提供了GPROF工具，CSAPP上有一个示例：</p><ul><li>编译：<code>gcc -Og -pg prog.c -o prog</code><br /><code>-Og</code>表示关闭了很多编译器的优化开关，并且优化了调试信息；<code>-pg</code>表示产生供GPROF剖析用的可执行文件。</li><li>执行：<code>./prog file.txt</code><br />会比正常执行要慢一些（慢一倍左右），生成待分析的文件<code>gmon.out</code>。</li><li>分析：<code>gprof prog</code></li></ul><p>结果通常有2部分。<br />第一部分是不同函数的耗时情况：<br /><img src="https://img-blog.csdnimg.cn/20201012215440170.png#pic_center" alt="在这里插入图片描述" /><br />第4列显示了该函数被调用了多少次（不含递归调用），库函数一般不显示在列表中，但是可以通过wrapper function去显示它的执行情况。<br />第二部分是函数的调用情况，以递归函数<code>find_ele_rec</code>为例：<br /><img src="https://img-blog.csdnimg.cn/20201012220111993.png" alt="在这里插入图片描述" /><br />前2行显示了调用该函数的情况：自己递归调用了158555725次，被<code>insert_string</code>调用了965027次，<code>insert_string</code>自己递归调用了965027次；后几行显示了<code>find_ele_rec</code>调用其他函数的情况。</p><p>由于GPROF采用的是interval counting，所以计时可能不太精确，尤其对于运行时间小于1s的程序误差更大。<br />如何使用Profiling去优化程序，CSAPP上给了一个非常精彩的例子，这里不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quarterly Review</title>
      <link href="/2020/12/10/Quarterly%20Review/"/>
      <url>/2020/12/10/Quarterly%20Review/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fd76465805cca9bca2fa8fac963fc3e855277383269a210871d160485338d6b0">418fac4f173397084caccc18ab9f089e90c7a29408af94da76702e54e165326b954ea2bf755f452b7d2c4562fe83eff1cc4056c74e87eced62e495c741852087427dc6c1dc58289e108c9e4f4ec798691329c09be7314debd9fddddc3c2e5ce032c473361f450473c0ee1a9942f3fce4743e35a7e66aa14d300540c5ff28947e4254c3bdc506688c76286e90c21e012dc91f70c292f227896868ebe49975c08132368360fe6afb64ca716ea9da458f40ae4e55f51998586ffab217e84fa80804600030ec0cde3f53bc09632827560c044ce3b30668093cbfd64aa282777dcf5f1737172746725ff30423818a6b1e06a60c9207588b6955d180c068c6f9561f5cc1426ed783564d0daeaa2c7a1a6fc45f3b0fd7045f7ff5dfcd3bbf209438bd261ec76d08fb7d666ffa74d060014e033cd39f7944ba618fe1b1c7f40b14b09f6205d0ceeb59438a02dcb1253e3d126a1ab5ebff5cf2a2c5b8cdb9ec9f3eb658ef6f89d32918f79f75df941db6c0f3a28c8d3198ca42918ba8e2449d7b1cb21feb52bc68378f0fc54bc20009af6a23f5b05d4e53ddab3d76a90ce015b2759144d13c3867378de3c42e54061882a40413d7918a3c3f5c1a7e17d9446707439eb0253662592a93c6b88360db0c208e63ee245d0360a86bf90f8a583c753e17c4ef3fdd42b53d744c3419493e2ccee66905dc2b7f0804b0f8fab81be406c2f17241b4207690a24df34f028df8fc8e04d4b4aa40a59eb901a375f7a96cec376ca05a3a2f753813733fb74bf2ea5ea6054662660d630f8e6bf7e03bc96f6ce769abe76b43d62e20c47dd36c91d19038561a22d903a3163a1a8a24c030a282ec99129a7d43847de525613873368ef801d005ca561c4cf5fe425eb4fe847c69993860b04d9d34cd821386b94fefbf829bb809b11a592397696d7ed3e06d73b903e06cbfaf00dececa3e80b3f5b33e13bde150edbdfb74ab4e233ad9c0c690b9e13d1663c0bfede55d66e2a4e0b1c4d02cde669f84f83253221390cadf34654f3999b82423700bef51c51937552eb7edd0decd00010ef549860dc7a7314c7e5ec2f0161723794d42795827d1a1f3e4f2692e385692dbc19a760bae58476d9a2054341af24cb37ef454e3262ad3b6afe88f81e46acd79acd01173fc29c30f94182a59eb2474894edf9e625d87be648ff3403ac6c800b4e65a40ef3fe168549c33cc685566992fe11a39a506f7804c3e2df1dab1909fea4455d60c7960f62e8a8c135408303767f79562518911025dab9f8bfc5f889589b775a483e6202a07fedb0a2f600292808e496958d781543a528f43581a2d40403b1893d250cc375bef86d473970f504debb737d3ec6f5a534a73414057592f57720e4888c0994d3f00b9229cf3633bf41c44c3c301ce55691b7cc821a5ed19d1b7be5e206d821f1d50a6f83f6fb866731ecf6ecee0fb34aa315bad061a04de57f4d57b510cd2876056fc6407e94d85fbf0cb878c2ce019e4c9f34afafd0afdb481fd9019227bf8b35a3a51d37fd29a0aaa62033d157018377dd7c7edbc259ea852181bfb3bb67361f6ee36aaf8dcd8ea32a1c6d34683d1c6dc64fd5a4726a5b2b9f0745a7b3e7be4670c96e3b68466c41db48e10237dfdd4d5ff9f485ce34769596d7a7cf3c9c42e3f2b146ed92524b28b45148ad2c45554b11a8672a3a67b456da249430970622ab9f7706497319b29a075248fbef7420304b08cc63af86746ad9c1231284dc42ad15813ade759d217c77f37b752acaf1e6bd760be7b45fb3d90d3b944e913172442fd605040aa66c2e4c10f8b81ddfeea801c48e126f010bed6959e36e5573bc81445ade4cbd0ffbf0879b38601c41c2a546abe9e66ecaf7f1da819424922bc85c0247ff0a2dab996b7443ac07a376c8a90c49c48c8ac1e5fc9e23ebcc66d4e289b5d6ce1db6d84668297e04776226b1d3cdad20c96b2f646ad6f1f8232daf87f1011fe54f1aba615025c6368c096f908cd334ca614b2169563a59a44384cf38973e31cea8cb0cf9bb65b0652be45cd41314928586da7d952043017b14916a4720c41c76dfc1e93ff36cdeef085a2f21aeda4657c3444a18ffe0368b8d783d4272b477f723662ece660a4b0c6fee91fa549b08d1ddfd4b3e321ee397fc73bfb55426ec46b14b837322bfc94bf5b26062d065b457c0af077c510dc2e2b52659b4e358a8845cf03b52d910abc13e6af1604d463992e76cc58edf56bbcaf263b5725a79124ce2316bb902585d0bfde5c88e8135b57bfd82cf6f11897b34eb91e4ce4055f83b557a0c04def2b5d12d08c851fdfa0d03b0e4f51fa0efa548443ab20dc01fa9737adef6fd338d9e19b36c4da01d07f5ebad52288fc4e0478bd087338572031d1efd5c0b70e420cd3ef30a8f81ec91eafab7a4f05c561e9a5bc599cacb4c4d1fba67ca01ae4aca98f397403b107db785c4bf8f67464738eb62362993b590c1ac1885276feeb3619c009c3d2aa46bb012189951a8eb6aa3e078d14844b9670ccb7ec8ab9dde15eb140d339631ba146e699388a1063ce8c20e00ec39888adf976647f9518b1a4939cad939cc12e64848bafda2996655d619e2bf54d615857e9b41412ca8e17d740d3b1dd50eca17075dd2da62a7177dc9d11ade532deaeb660d6f2bec1be7bf699d9ae0632f4768f238216e8bcf3544407fabe6a1046468d4a4a4c3ec2985474833fb7bf5769b85393908657614e0e50a6e244eea34fe35b5b5c39d23cdd95558eb7f9248997d336d0893958610b7f1c52d481e6cd37983048d3105deafa18f5c0c4c6c6ade3c1cbc5cb74541ab5cebe5b855bec96dadf0513f78cd2efc695df1e69bb6adb03a47613affa0cc696ea7279a258632f27e05de20ada2d2b0e623094371f8fab9dcd0d26be80c954b7544f6b18bd16fa3fcd4dbe2bdfea9e3a76ab86714b0f3a32c30f83427d62aee95ae7db610b81858251acc1d93b29b318121d02eb2eae7905dbad6b68aecd7122a8ba551a6c4b687d23542622ba65bd5e7ab3678c0d7c5c60a5e9177aee9b3532f713b99945e77f8564f97afb3b87aa38e66ced9dfe2dd0eb8c4d9bbd4b6c592366b900d41d40d0ec4fbff82a63bc4d3871df22463998569f90cd56dec896ce8d6a4758001d3a993af74783252e11e17c00bf07dcf0782532a52e5217823cfab1022ab1dfa9bf2ccde7e3237d46d57ffcbd159ca2c32a3f5a6d45d644af1529a5d982d14a397356a9737440d2db5bc6614020cded2633b0a13482474bb071e25ab5d9acee2c044f9d1178ee390b9de41a024076744700de5708a6f84dc07a94397827382cca81ea0aa4a36ea3fefea852d51e70b21e79d70c558331a6182ed8898395eaeed0634548e9246cff2ac618a784f9f76cbd83d2946e2868e3cfe980de3e6269bfec2a428aa4a2a23d81277bc8dd535cc5e31326200d7477c4de6da5ed89c0f554763607f3bb847b0a9305d1e222534dce3f6f8c64943e2a9c242746950257ebe731936697bb7a7a2d6bb268c4ffe795b11e83d1755cec526a40b8dbbf358bf245852c025b7ddb454f396a5573351f261dd212cea4ddf4f31180ad2d5d4718a571b4a6732ddef1036ba7d483140441b25dc2deea4e7aedcf6c683ac204d9cb4637be6c5dca45095b04dd68cb1c2c5bcf9c61be672e2276a5c90312b0e568fd78b9c18fb3d66ce2a2012c1a0d6d89074c72245ef7bbce217d650a915618ca761335dd0c657cca548eb3290e57cf81878e971fee50a3ec95b64b562c31c01d0b155973677a66faff127c8bfe33ae3efc70b4dc9606d0b8569d6421d41af88046514cbb2ce76cf7b33bbdf283d911db18eecddb034530baf5103f9c2f21783a2f3e4fe05f2ca39b8283d69452e2046f12c3be129b60673f082f6803a3325e2320138b2f7dc34e1a1f358b734b98eec5599c04641a35341b94f3b9faf4a9c42eb56dce2b2a405ee54d1d62874f3d325d566d0fbcc312bc5ce9b297ea1bea9f32f652e19f4c802482f85f51b8ad57c4c2464e1c81c72839fac2068d9015a89def7746f1fdf2e806a50f8c3447e72202d28e4ab41e579c82c69f6f1e1830ac0efe9c0569b0bc25798b7daa6cc72e519e2a55d6a67a258ae2b0a69e16f68c959a8bb31f3788dd4539df8b2204a7c023b66b66213dd8cfc7b3b161a96b94b7383e8ae9a1d8b3c80cea99ed5a6d6c246b1327d1a5d5805dea66098855d9dcd3a858de2f24af42ccee4541ce0b151701ab01789c3a7e152fa8f3dc0b8d82377f7d11ca156db8797f957747853545d0f03f994c92b449eda080d1c19c763dc49bafedd439bc75db8e34d3e5aa6af605a105434a6a68b9191740ed8cf02bdfd9f16a7628168dd61ed729cfbb429fc98b79b7b885fd19b58f2a2557fa1b753877fec3bd06480fda9b39c78707e6e6897685ec658ce8801821853882607b044cf4ed4e4524960024d30125629910df554174cbde5855e2ae3d927c669bdd15a9e27d22b1adc02b4ba6b8dca8c750373b728b5a4c18099d1b1040edc6f251dceab73f41abf278c9813ef6298e97e41dd0dbbae640ec520af2b57a9451f7aa39461bd495bbfe15166d88b65c6637fbaca6197635bdfa1832720f2461ffbb4aec4cfd032313450a5981bc65a1df6cb44d6776517a028e41556dc68d4b08508f28c14517fd46b5353a5f7741b4d3654cef0214761f6ca4c4ab5e932041aaa1ddf781f52edf913bf55cdb9fae58c340feb3b6a61d4bb3235e42d17364fd5665b60266532a04427a96579781ae6c00942adb36f4256689422678cdf55ed25d688070dcf81af21b7c68bcbc906848a14783645100eaba2e31b46a41300204e39c12fc5006ca916d181512df358627901955cc1f0da20b9a309167e3adf6f933b59efa63b8e9b54cc8ed1851140a4e3f6b8d55b23b9b463449ebfb1eee70db5b230c15b0cf04926cd64ca043cbfe37628ca93371882c3bc26ef5a4c952314f6c44fe55486a896edaf7a58814809f8bb2cb732f7a3435c9ea877dc9d30816f708491b2a216e4e693163740786055957ddc7aaf3f6a6068d62193f2235943cbc51182b748f198d73e4540b67d9e2a2492bcfd0cf9e280bc389904a8c415f61e4fe3b559ede7e665565094d59ceabe1474f396c72dffb3a18565ff2ca29abb387b69c6eed8cd77cf30b3c83a0a8d82d1057b0551e2eb14ce17d1ac10837ce87b52bab8f34e3926b79186b952c473690e2da19b207ee0aa7a425785fe5b995974b3cf9b242edd04bfb301034e31c4d4252a30f28c0efbe63ecb13228036a74993c81ae91c58d480889306e4b9cc4c72409ca41b00e948bd8c7920395eb2192cc6f4a37c49a5feba945dc8c9c92edae7fd44014a565faa6f49ca5fe25644899cb5421c3b322282db531786e06d90efb52588188d077fc36f88a8173fea2daa9f1c48b90db30ef476790b912dc4391e952d76a3a1d459526a1b443cf4084eb5943ecc81d3fc9bb0595f248f99912015d84c9640127eaa11e135211fb0df9ecb38c9e1070f3d526039f6660d6d094f640c76138332bf2787093829c741a7b537d18b474f72aaa6dbfc6915fbe3542cb22b8c00849c805008422bff8a5ee9eb07287f669dd1e4a423aa6bedd59d64075b64414d58c144ed80ed5b684de3068672e74140f4c24e82a2d1f0b53d0a01723a3bf7a92b8dee2fedbefd90d685608846863897a13e9876b25533cfd684e4b76952eba1626871c5d49e126bb35d9b41f99d8c941167626d626acb9db4a4de9c11bca9503ad806cb2fb780d689c797a8d35ea08b5b71fa4c9a7c1022fb530388acee456e5f90bf4ccbfc23d6caa9a12c72bd14d0313f9f789a5493d78cbfbfb42d7c32007da4c6da4e1ac9e4efa8b6c95029089408a56b351737b79e6baed0efd6806a3b1dd6265e42fbddb5b3a71928ee697a108cc34620b18c65d13229cb501c8d1624bb5b95ddaee5a609649f621f88c8ae4ccc3828a1e2626a29bc8110cb8c17d9d1cfe250d9c7d5dde67be9cd5a0a8479038c1cf7a3c8f13953d5602b7c2f0903a24167d91f900a003d144ee2ec5ee2dcfbd3acde89cfde8346b524187ae063c9eebd5bf39ff2c8d70cd96e522a190cfdad7f476152abce7d0d7e0648e924a77ab1e6d47d95ae90723e54c34b96e7d9ddcce5ebc9b97fbd7dd4bdc6f457accfa5ef3bbe943b2ad383dd2e6428b045f42fb153d3eb60bc59fc560b7dada76dec061a6d733a8964f5e1b16b42aac8a42016f10b154f8f2afb3550e1c737b6d4a0703f8580348f1a0c1c2f3776133f61a8552959668eb4d4ae3056499430dd29bd756ac77fa1040a4be402b1e6f15fc477191d3b1e86e0df4a5807307318c899d606691ace9f62af9708cf9aa57bcc00962e4261b10d6d8e479fce9c32e3220e52108b5b201cdb4591abd0688b34aff36d38e0fccf3eda9acd57cc2ebaa8f249fede28c4bd46f61beb44a533a427809541ebdbb42f9c254315e90ac055af001736171543f4083616a502f26af3336160fb3e9fa478b7bba74127176ab95dc21d36aca1ef827e5724aac00c605f2319df7e1b9de6bc9d75111254f50aec9b975743d733893d0035c9c82d17080d395ee2181b8ded396e31cbaba67a6f31bf0cef31234d4966a9a3ee2659e83c16fd5516d1f19a607cdf98e896b795aa32e1858fa510e17c0e7b10cd2f3a3218c661958823f17e0950119d616efa39be36fcb8a60437d56dba7aabf3fb52663c670fc60d894b2311f536fb7cdff5a8b69d498278f6907e9773739c25fdd4dcaab22e189252cdf0fe70ce2d70d27bad5c26bcc7544a566a08de8ee2115c870543a06394906f8a7015d0885413f1907b30ad50a490083d24ab2ae06307fc55aea759bd0a9679f13bfc9346952cd304be22834b509c3bda24de708e389e825c50e3afbfc414634027537c666643f1335f27dca0374d15ab91c96dc0f85b232bed1a90be790990614645385570c8c4045f2c0538b57ca97612b0c243b268649a2dcebd747500e37bf0f867886a29e74bcfea4d7b497a25ed52e05e4cc22f5333e926cac99664b96ba609ae2b0417cb32b5679113400840e83a8c4857c28f776b5b7036ac0cf563fffb7afbcfd9969b4897171a9a7ae3c1121f05bb5cd04edf59c00409642251b5210833b956a42c714273a7ecb4ea828d8b08b59e572ed58a36f09953c88782b2d8dd44bfa43ae88c5a0986fade7eac00f2b7c9434fe5eae955d167f00f5ef695b76efe7fa3f159f2006a995047720ed2432c6a073dcf23a13e97f35b0b3a1b9ca35abae4955b91ded1974977cba56fb3f0519b866717235d86eb9901125e29f024d81ed7501aa2365ac2668ce8e54078d77ac878683107d1c94734adab460de536971f0eac63844e1330fe85774984cacf7eeb565090b72913d057268f3ac62a51f9c0ff406ebd2405df2ab590ac73e828248661a14edeee584c3518dd79df79fd74bdbe9ce8c6bbfa59f79de67667d48a05be04d93acd621e2f6340dbf283c97dd16ac2a036bc871925f71952e96461bce5e8f29822d54a061cd7bfe2d7995d4b1895d9ad6aaaa1ec955e295073e780ac22ba02e931ff8dd8c634f413c0489545150954054e922da33f2b8850c6a0420981a577f3eaaa4d79277620bdd2f2cf48b218765ecafb28223cc0e5d0c62d76991f0caac83cb43e5ec548c7c941108d9bb5c0a1a426b49c51ee8f8155dd2669482ec183424727cd71ae7e1edc29542a88a7e00b00a8723c64a0854d3fde976251bffb421642340e675add3f75d0f6dcb794f57b866020ebc440918706b5079faab4c59cfc0c703dc4a8ecae28716496a3e3d060ec5fc8d0ab94e85f828093b7eddd995e203a1e63b6cf532a8106e57893bfd9cc5f024dfcea3efe52a68203398c83b5e34f72e7c983b14dfb28b604d16e899ae443970465c1e4e4363068768a3734ad17516a2e9a8cf83feb9d96016d280f5883bc54afd6056e9ff752fa33afc0e46df84f7ebb2e1461d66c95b69318fdf3656d10db56f2668fe663dfc9244350bb8fcd3d7bea423f5f2cb81d0f89b896c0d628b3b0aae978fa8f810714d388a65f23fe4d5ddd494e8515720fbdea74fe33ed61a578bff462d9134347d7b8630e53c63a45b664a9d9d75365ac89d94aa54bb945cbe334f762dd44337729d6dcd34b72af83f2a840d869d9d698773bce1e0c7e2fd58dae88866601788f55f5ff8570d4540ae763609189868962de02d0f80c657736a32f88a80877cebc6e8481247dae5483b1a46d093963125d7583ea9a86b79b26b2ecede8c070ccc3ec425072d64a1c8ed1b29ab860af1a0aa44bf48be5241492a7168e71c9930f8adaf5ad4fb744b092e8285b47397918c8d859f23d57c1e3cd4025d2a71c5fa7aaeba4bcea05d074546f380a9977094032c63b9d1c220cdf5f8e97ddfc4ca7b5af91c0eeef30368e43dc50ee8191e5d0a9584ad70899cb12ee73d8f3bba02d881f0a9cf794627540ec0113494fe8cb2e32cccb1769877a3bce1bbc5ae33aa5bd130719afd8be8ad58cf1b6f276465944e7b4bde60f0ff66b7113d499ce87ff477fed408ef18070d1fa0daaa3505947a0adc64616f58ecc61b763d06137a1b51f94fd90a7685662878307c34af7a2e1f7a32b03a62bd230c502903c7de68e24ba8082b1661db94b2e06501673db98e3f31320929bd1d57855ce2d26ce41b3578bc26ee88bbbbbbb4b2d0f4478198a2f93d74a4a9ef14adebb35e1c110b925cf9fe00aab334109ef82cbc8c8bbf698f1dff436cb5d7d540294a7cf981cc76f63d26685a8d817fa02219ac4cfba5b600157d9137972ccc11f4f4ee2cc77b60f4d8d1817218147e48f7abeb58fc89a2afdbad569ffa7e236071edfebb7dec03b91e0c1171cf4753ec2fa134bebb972dd867bfd86402f633fd1d07fc5169302fc22584c15e342e2c78537d0169d0771f9b8b770f683c27df2ac166048563bee771033163ffefd64411758b1f892dc157be08aba001c60e4aab92c0b09bb1ef08dbcb8b27d183c229764698f5a06e0467ee3a799adfe9ecd6d23c90bf42e1177bbbc927bd4d371a187ad7301edbbc2f57ea27d0f70be6804600c0c260a9befc3acb3f4ded6ec22da1661222301b7221fe3a034249e74c078a4249ec7fcab1a43373eb9e8ccb87d79401e494a4fe53657224f90b23e0861a7d8198cc12b3efd782b2b2285b783bfe41313ece813d28b7afa5460a2b11540d68e562a06977304c6db59c6fdd3b5a2bc931434dbc3a699dbd56f6d121284a320c8c67999d6f37912ab8dbeffbad2bf6b84c267f065d7a0a5882dd6adbd03fde3bcd7ffafc3a62fd975118c4e57cb0c8a727bd8cb07141ffec1db6410a8211e2f38ddc06d4655c79e9fe4a34276cd501645631f29b3d1c330e7f7c0bb6dd21b9ffc28ad8a986aa84feb4a7b4dc8e324d5f6132bc129e4fc2b8166e0d3f5ac0587eef03d41d23c931228768210d49bb1aa78e8a0e3b2a028b8cfad532037c6afd36a02a4eddbdf08abda7a58585a5fbb18638b66e2b1383ae6248e1f09a1f4cdf0bca5511025d8e7b741e3b2529b025c6f130aa62a7a4834ce49e056c95e51dd070a00697e9150f134cf67cf5af4b58e607f98a58aa2821b011da226be4305de520a48bf759bb6c9e5f79b07985e97418adacb189d0b0ebaf48c795d7901d7ea400033751818e9641c8310fcaf406523f7365bf718680c1eb71cc4e08a8395bafd576dda69a025c4b06d97c859f527be6904c7df1c5b925cf4947fb4dab0516899f01b770b04d8307e6e31f9ea5ee7513822447c01f353b22f683a75d6fa8e642cfc8d9bb318ff526aca018f2868b6a0b882f67316e699ca78f911ba957a9bde12b78f14032e57300dc947cbb4d957e2415dd6629ed324cb42844a6365ad206cee585e014830542ac61557e15259dbba8ce7e8ab6f03015c77ad1b96bd2fc23feea5b17899fd77a5a5cc5362dc04d129201b0926933ab9b8a11dcae7af301ebf4880c2bf0ca028259eec856fadf6946cb348500dbb0b4b364f14ed3013d3fe485ca01698120b7bb730d5a20423685ec48e12ba1f32b8e654659eb76b9eab9a7b80078344c840d49d621a54470aa8cf5bb47c59c8ebc3be8dbd607f1300b239bd3e0c2b5c294d5f3b4ae78f8503cc6c92545e316fc367494829e97f3e543b2e6497f514ee0a0519cda81ff757fd5ef8b7d6387dc544f3066250617ab1b038cfa4e85c8db97c6a10fc15ad1c6f212e22d58dc8251ac65678f062a50c018e7e9195ecabc316315f37a97f22674aaf962882316628d7be02fa36e3d41dc9ef673a10e93919375beafbe22d786a67acb99f55c61782f06859e45deb4501ab594d818e954e957ef554c34da691def1c3fb5efcc243f39ce0797be85d524aca99ed808444dc304d914381bbd0fc477b2cc6b6512de72849972e61a8516a406dd4a34632742588d5ab41e121a0ac7815fe35077558ffd830acdb449d7d8d398c4e7f74b9839927f31d64e0f48150b6f3462f70bb524a2b863e1bae7c171f7b2b5b455696e8be1578973212d7f3058d9ed12e5cdefd3b0127fbabeab4e5744362782504e8e56905642ca404c087f7f7eb30ecdd8243217cd0b725ffb0d5144f34b5f8f2c8fa9da4ee8417790ea871cb4778a7ab77a72f1fcb86fff0b255382dfb82fc7cc63ac9b57e1c90491a5d2d2295423e038b5703cce1d3d7afb0dbc027f332505d23bbe76fc6a1fddb65d599c56de856eea9302619686eba0ca4892a8a97813106632ddc6ccd37a2b9ce2e5ee0149e8b8293d8b048ea0d2a291c4e1f19eb793e4e601447177411a6af95486642cf9781ffb2ea4455d666b83155d991983fcd4007e8624480eab88271eba7df2999f29396872b8ac6163bd8079927aebe1a82318357bc74b98b1f8b60b1a0440fb688dc631a304ca4fb374bb895d5fe0c0d48e2ad88ef8c4ce02d539d0915cb24bf8ed91529c8e16ec009ebe7ae9465777f9c060f25e2e6edcca44dcab5f633b2923cde49cd53c3fdfcbbb1f4bd82e9d111d2395f4e02d8bcbb8b92c32ba06cf81bd9eb1c826824f1d0ab0bb7b4197e0eed6f3b872e5ef2d91f5cb7bf6c799d08acb0736025e24a0d02be82457f46f0a44f408756b53e526b021ea1b35c52921b99bb043c07e7b3c36547897366a6a3728a72c1e85f47fa88bc477a3f11d271a6c6eae84bb72f0ad488d79c8839129ff85fcb1d14739fa26cfc40cb7f096b0a49e9f49e1a9ddf73da7cf824a88c528a4521ca3289088a6c2cfd1939970534b322a41dc8b5482f549d775b760f33d91499bca6d36869981d14c5c093958e56c7ff4a2919bdd399d06cd0c0dd1ddeec257b9293592dbdc869ad025cf8081fcefad92470beedf53f7d2bdebf2efb430d81e0f8d214e772e00e1e77b1ad87b60a110acd11ee564ac5f0efb378b08c23a4b11bf9c1c7318eb3aacb7621b155a101667f3413b9746c07e0755d8ea1850ff65e0d361969ec52c0deccfa3db1d3221bb2760b3a19dc76e29a4714d18d8aae1e842749511f6937da291c0eab1671ba86e7a1c96d60b896136d8dcc3b056363e3d266e86080e6719700d3e57c18fb4b3f0d209ab4dad043c58a7a32848002271c2ccae2772af8634e3f6d1f2006a0c8857448046ebbe2501ac08feb4912787f2e33df6a4f40832df2a28f69657c80643f8dd1ad1d7170d5cb03cd8773668cb13a9e9f20d8d03b5fb993e826ce859a2229fcdb96defb710fbb6b9da9aaa09a120a886364062d108ad96471bbcca30a16a466cf57dffea763922e0f764278a3bc32c8677f054ab7e5577d6a0a8adac4b18880fbb90aab2592b0638d306d6f3ac1deb292a9a175d424c0091022e0c19ceb6eabc1da59c1e6ad9e0acf62c5defbf34938518ff6c4cf927e0b602a15f52f50deee68fe609ea19bbbab599b51c1709b65f9161255b6e1d7be50170af408b2112a9a5d5b0542131b660885e3aaba15da0bdad3622aeb8da70c4498dedee3ae836a8267c58396f8d7ac5644920ffed363fb46cf638fccde1b11041deea70519b7cbe71a5ada0f9856104bbaaa6210a8244b0f1484081609a3d96354c0cec7844ef68de2c0ca174b752b7eeb611eabd98e22f0517d1c94382f4884fa3717199eba048d57f0155d6b5d27deb37be672eef07cce60bc0fca65a9622680612a0de8d5fb3d1b20d2a6ef87c42772d3a64338afedcff1c0e025c6b7dd4f4cfd17f6aeeedca3c25f0c5633d34712682484551276c7a013216494a55313015a44657eaf64267b506e3ba536cf2bc23da2b575d92291161604eb80885ea2cb5151ce77be4e9716e8bc944a0fa5caf90bc881b68befd62ce984d6d41d24019c4b3e7789d8f0409a5d1c10b5d330de23acf6620211b774dcfb95a205081890dd417abfad2e58de9fa8d2857976e7cdb2d806021075d05335b7b9e54a244b7a988d61ad12d3feb451c0b5ad433fee63773291f079fd29f223a1430fa56280464f75bce1d6ee6c2b3127994373459abc9d71d818189df1423f8bd5e0ab187b10ca5f9e76b96b6a4e1ca6dd35f61cd17d125dca10634e77b5a4d9a1483a3112221a2e57d6979a872bd93e3c6475595a63a773271242fd0d9f02a562145c2ba509642996959b207165f9a803dafe0c7eb598b9a12d5adc6257af38047726b4dd54121321d073865cebd26d0bfa050d54c30f2ac71a6764f0bbc09d55f2b78f1bc1d753b51d7f8811aa2b7436a1781b8ea7f84f6f57d277c26a58ad3f55221e4baecaa81361d6c7f08f41323f5485dd7d878b7d2d56051ff0f8e41c8f44dcb4deac99253e593211cdb2c4488ed1613294d9186206d7ebd469ad83aa3c77a04763cab5b235307b588d3f0293719f956f30fa1d8922dc443302e9614b7073d3fccc41c2e9b3c439abf975ee5a5d18babc8b1fa81ae5cdb391047b63b361adc294395ec392337ae8edc7c9626f8e9d583493ff502f2f766671bc08e68f7fdf86662e737c4c54601873d6b7788189c473f6b25032a714bca4adc2ba2fcff86ebce16e22baf6221132d04994977b72827674e391ba68c64fdcc654417f75e854da9b8b5a0f26c37208b6fd9ac2a65ebc461a8556bb017fad4168a292a1b294795b68b0d6ed8f10f9be1629ee8da7f57105dd854944fdbff2d452e032a8aa7ecf6e59a93ffc7bf0754727dcbf1ca8eb137b6f127cbd2616421fefdd27b065cbd2fa6d664a2f2f24e8ee90d95feab1bc1b60d9fb2075c3b16f5ddf063fc227b9d34e26fe7924edcd5dbe484393ccb929586003ea3e607896653cef0d811911f2a9acb33e7b5bc7de272d6ac1517306785b4eab211dc8fd909d9afe61cd08e61a94804d86c25192e61a53790b45aaf97872af1db473bcbd4418746030efa9637a4c0c7836e55ae620aac6c5dae80df309bb97e0678624a719beaa4bdef8d8e17c6da345a55a927223aab5da81ff39ed394bcf0adc02a9eed2bdd1e8714010b0baed4ccc70a39a908c26d35ba675fa636c4ddd41e6df4214cb6e62007863aefbead9f8ddd7934c7d0f6a29a3fd9641251d35d804b5d9776527deb661ccda4eaaaac3a6c56434b0c7453f765d107d6afa0a5cd279bb44b78105969dc5b23f94a01ce3de71dab26ef892dc5863f19c518c93919d956b26be24a00bc4e728bc191c644093a2fd0f752717221cf530a15606d4fde71fb8a3926a11d626773b6f5e506eb23962775578da595f8d4b65895ca391699a98bbac981d97edbfd154505c2c0942a5b2409e92201b62e2d5d1ddcbd473fa388661c7f038200a31cb997399ac352ed2e6159ac91a9660bce91f5601b8ec7d6800b8776d1d314af3bbbf1cfca661c7271832db971fee05b42acb968e2bb80f3589ec2a9a1553355c888b21005cffcea9b0dd1caec8073cdb86a4167da3c02b943a9a91308aaf50042c2230c1c33d4b7bb1dce0c419d0ad79b3a770a28dfbd962a4ccc77f0bba643512d2ec957283915bf74008a58790b5b0156f4974392570794991c60abee0c7cc68ff9c84b156c3443b0cf2b2ac5899bbe38214c8cf1793f649100eab6128520d468e5128ab00e6fa6bbbdf4924093b32505097f50d55fecd00dd49ea3f90cdfb5bc8c0ca2b490b260ae1c0afd87042707b7e8abc21f3196a5173e5240cd8f3cc43c13f12350f95aecb637ad8659603435433f77a41658e32105d4c5393f265f04edfb93f3617adc2c6a427b420d59091b5ab715a334ea95d149e78978541e6a3f818c59839905a0b8f9551d490f1b1df780ffbc83efda69c456e38779129c7f06d6a5b2c8246df5f4e741280bf19dd11f39e4ee5cbbbba05ed49a996366f9bd2fd06356d18eb24c3832de75170a80b4cc943374898c548f6e65da806ae4ad8b3f90579aa762f1499f247f37257fc9b58dec6b32f528e8077fec9397ad1a3c32ba162f1e0eef182c24419dfc5873487077499b12d3ec5b91c8e011d0687b2f5ab065c919fcabc2fcb645252e711ef6b1115f3db3ec6cbccae3d97fcf085cc217ab1929c1361c55f3a56344f9251e42bc6567ec0adafb8d9747ebecba89f586e76659811828e140e33942d287b74aecd759c6718a04a6cd9454032d4179c48c671131c8295eeabbeec4b42c2bdf8af277b0e6f8532409cd33978ab0314ac75f867afb5187f822eedcf55549417f0880bc5791fed3b72dbb4ba1c3b7a74b5d14c9a2e88ba783ac0edbe82ebafda3a7135430260538ee0ebef1bd94f0c07cbc272d523071e74a1658f3bb2996e544e040b0a7d255d68b4c8c35479a58db3f34c7c4e373cfd25ab2bd0daeb3c8df8654567cbf030f7053482f6d88e2a0e60058ff062e8b0cb5ce316d39fdb8b1f189ccd44a787139918a2091cbce0f20509f6ec61f5ee985878c70a86af153d608adc63860fbfd7d99e2121bc7326eb3ddc6094553ab6ce3fe8ef6276eacc86aa3cdb2910dac7068f2191ac64315b200074e83b4b344ea8242f28a623f0e852c71456a606024a385b9530984987727c8247dd7f44f8e8c9b61c408bc158c4cca140a51b0f7c576939f7fdbd1f9066953f9b54686b6e8354f6ca10776ba37971f31fc93fa240c8583c06df6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Malloc Lab</title>
      <link href="/2020/11/28/Malloc%20Lab/"/>
      <url>/2020/11/28/Malloc%20Lab/</url>
      
        <content type="html"><![CDATA[<h2 id="basic-info">Basic Info</h2><p>这是CMU 15-213的Malloc Lab，本来没打算做，被同学安利了一波~<br />需要用C语言实现一个动态内存分配器(Dynamic Storage Allocator)，类似于<code>Glibc</code>中的<code>malloc/free/realloc</code>, 由于涉及到很多未知类型的指针操作, 整体来看难度较大.</p><p>开始没什么思路，看了下CSAPP动态内存分配那一节，内存的划分是这样子的： <img src="https://img-blog.csdnimg.cn/2020101116464245.png" alt="在这里插入图片描述" style="zoom:80%;" /> 程序动态申请的内存主要是Heap段，Allocator将堆视作不同size的块，Allocator有2种：</p><ul><li>Explicit Allocators：需要应用程序手动释放申请的内存块，<code>malloc/free</code></li><li>Implicit Allocators：就是garbage collectors</li></ul><p><code>malloc</code>返回的对齐地址取决于编译环境，32位是8的倍数，64位是16的倍数；<code>malloc</code>不会初始化申请的内存，<code>calloc</code>会初始化内存为0。 堆的增长是通过增加内核的<code>brk</code>指针来增加/减小堆： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span>;  <span class="comment">// success: old brk pointer; error: -1</span></span><br></pre></td></tr></table></figure> 如果<code>free</code>的是一个非法指针，那么结果未定义。</p><p>主要实现在<code>mm.c</code>中，有4个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>mm_init</code>负责初始化, 比如分配初始的堆空间, 初始化自定义的数据结构. 成功返回0，失败返回-1;</li><li><code>mm_malloc</code>负责分配指定payload大小的块，但是这个分配的块必须在已经<code>extend</code>的堆里, 且不能与其他已分配的块重叠; 返回指向该块payload的指针, 按照8B对齐, 与<code>libc</code>中实现的<code>malloc</code>类似, 最后会有一个PK；<br /></li><li><code>mm_realloc</code>负责：</li><li><code>ptr==NULL</code>等价于<code>void *mm_malloc(size)</code></li><li><code>size==0</code>等价于<code>mm_free(ptr)</code></li><li>如果<code>ptr</code>不为<code>NULL</code>，把<code>ptr</code>所指的内存块增加/减小到<code>size</code>个字节，返回新地址（可能与原来的块相同，也可能不同，取决于实现方式、原块里内碎片的数量以及请求<code>size</code>的大小），保持原块的内容不变（如果申请变大，剩下的空间是未初始化的；如果申请变小，那么只保留<code>size</code>大小的原块内容）</li></ul><p><code>memlib.c</code>为我们的分配器模拟了内存系统，可以调用里面的一些函数：<br /><code>void *mem_sbrk(int incr)</code>: 将堆扩展<code>incr</code>字节，参数是正整数，返回新扩展的内存起始地址；<br /><code>void *mem_heap_lo()</code>: 返回堆的首地址；<br /><code>void *mem_heap_hi()</code>: 返回堆的最后一个字节的地址；<br /><code>size_t mem_heapsize()</code>: 返回当前堆的大小；<br /><code>size_t mem_pagesize()</code>: 返回系统页面大小。</p><h2 id="implementation">Implementation</h2><p>首先明确设计约束条件：</p><ul><li>可以处理任意的请求释放序列</li><li>请求需要被立即响应</li><li>内存对齐要求</li><li>不能修改已经分配的内存块</li></ul><p>再明确设计目标：</p><ul><li>最大化吞吐量：平均每秒能够完成的操作次数</li><li>最大化内存利用率：<code>mm_alloc</code>或<code>mm_realloc</code>申请但还未被释放的内存空间与堆大小的比值</li></ul><p>内存利用率最大化：用peak utilization衡量，假设有<span class="math inline">\(n\)</span>个请求：<span class="math inline">\(R_0, R_1, ... R_k, ..., R_{n-1}\)</span>，在<span class="math inline">\(R_k\)</span>完成后，将aggregate payload(申请的字节总数)记作<span class="math inline">\(P_k\)</span>，当前的堆的大小记作<span class="math inline">\(H_k\)</span>(单调不减)，单调不减的条件可以通过使<span class="math inline">\(H_k\)</span>为high-water mark来松弛，这样堆就可以上下都增长。那么peak utilization为： <span class="math display">\[U_k=\frac{max_{i\leq k}P_i}{H_k}\]</span> 我们的目标是最大化<span class="math inline">\(U_{n-1}\)</span>。</p><p>这两目标是需要trade-off的，吞吐量越大，意味着需要提高速度，减小操作的时间，往往就不能花费时间去处理碎片，利用率下降；<br />内存利用率越大，意味着要精心处理分配和回收的块，自然需要更多的时间，吞吐量下降。</p><p>具体来说，有以下几点： <img src="https://img-blog.csdnimg.cn/20201023215211206.png" alt="在这里插入图片描述" /> 这些关键细节的设计非常重要，再BB一次：程序架构、数据结构和接口设计是一门艺术！</p><ul><li><code>free</code>只给一个指针，怎么知道要释放多少空间：记录每一块的大小；</li><li><strong>空闲块的组织管理</strong>：隐式链表、显式（双向）空闲链表（存储指针域开销太大）、Segregated Free Lists</li><li><strong>Placement Policy</strong>: 有多个满足要求的空闲块，如何选择以放置新的申请：First Fit, Next Fit, Best Fit</li><li>Splitting: 在一个空闲块放置申请后如何处理剩余的空闲空间。可以直接将整个空闲块分配出去，也可以将剩余的空闲空间重新利用；</li><li>无法找到合适的满足请求的块：做空闲块合并后再次检查是否可以满足；用<code>sbrk</code>向内核申请更多的内存，插入空闲链表；</li><li><strong>空闲块合并</strong>：需要考虑何时合并：立即合并（可能引发抖动）、延迟合并（申请失败时合并整个堆里所有的空闲块）；合并后面的块很容易，但是要高效合并前面的空闲块，需要用双向的Boundary Tag(可以优化以减少空间开销)；</li></ul><p>不仅需要记录每块的大小，还需要区分已分配块和空闲块，所以block的格式可以设计如下： <img src="https://img-blog.csdnimg.cn/20201011195117307.png" alt="在这里插入图片描述" /> 如果要求double-word(8B)对齐，那么Block size总是8的倍数，所以低3位都是0，可以利用其存储分配状态。</p><p>这样整个堆就可以组织为连续的分配和空闲块，由于已经存储了每块的大小，所以隐式空闲链表就应运而生： <img src="https://img-blog.csdnimg.cn/20201014165121101.png" alt="在这里插入图片描述" /></p><p>隐式空闲链表的优点就是实现简单，缺点就是当需要在所有的空闲块中查找时（如placement），需要扫描整个堆（包括已经分配的块）。显式链表的分配时间复杂度是<span class="math inline">\(O(free)\)</span>，速度较慢但是如果采取best fit，内存利用率会比segregated free lists好一些。</p><p>为了降低隐式空闲链表合并的复杂度，Knuth大佬提出了boundary tags，这样实际上相当于隐式双向链表： <img src="https://img-blog.csdnimg.cn/20201011214226551.png" alt="在这里插入图片描述" /></p><p>这样就可以通过Footer在<span class="math inline">\(O(1)\)</span>检查之前的块的状态及其开始位置，缺点在于如果小的内存块比较多的话，内存浪费太大。<br />双向tag带来的内存开销可以优化：只有前面的块是空闲，才需要它footer里的大小，所以可以在每个块用后3位里的某一位来存储前面块的状态，那么已分配块就不需要footer了，可以把footer的空间用来当作payload，但是空闲块仍然需要2个tag。</p><p>那么现在整个堆变成了这样： <img src="https://img-blog.csdnimg.cn/20201016204303577.png" alt="在这里插入图片描述" /> 这里的<code>heap_listp</code>指向Prologue block的中间是做了一些小优化，方便直接定位到下一块的数据位置。</p><p>这里的实现非常tricky和subtle，一开始只申请了4words共16B(unused(1)+Prologue(2)+Epilogue(1))，后续的<code>extend_heap</code>申请一个空闲块后，将原来的Epilogue作为空闲块的header，空闲块的最后一个word变为新的Epilogue。</p><p>由于对齐要求（Headers在非对齐位置，Payloads对齐），分配器应该有一个minimum block size，即使只请求了1B，也要分配minimum block size，这里是16B。</p><p>写代码时先实现并测试<code>malloc</code>和<code>free</code>，如果能正确并且高效执行，再去实现<code>realloc</code>。</p><h2 id="evaluation">Evaluation</h2><p>性能主要考虑2方面因素：</p><ul><li>空间利用率<span class="math inline">\(U\)</span>：peak ratio即评测程序申请的总内存（<code>mm_malloc/mm_realloc</code>但是还没有<code>mm_free</code>）与分配器使用的堆容量的比值，需要用好的策略减小碎片，使得该值接近1；</li><li>吞吐量<span class="math inline">\(T\)</span>：每秒完成的操作数量</li></ul><p>评测程序会综合考虑2个方面，计算一个performance index <span class="math display">\[P=wU+(1-w)min(1,\frac{T}{T_{libc}})\]</span> <span class="math inline">\(T_{libc}\)</span>是<code>libc</code>中的<code>malloc</code>的吞吐量，大概在600Kops/s左右，<span class="math inline">\(w=0.6\)</span>。 这个<span class="math inline">\(P\)</span>既考虑了内存资源，又考虑了CPU资源，两个矛盾的指标需要适当权衡。</p><p>第一个版本<code>mm1.c</code>基本就是抄书，Implicit Free Lists+First Fit+Bi Boundary Tag，抄书也就将将及格。。 <img src="https://img-blog.csdnimg.cn/20201115143013580.png" alt="在这里插入图片描述" /> 将First-Fit改成Next-Fit，还不错： <img src="https://img-blog.csdnimg.cn/20201115202312126.png" alt="在这里插入图片描述" /> 可以看到：Next-Fit在速度上有很大提升，主要是因为它是从上次终止的块开始搜索，避免了前面很多块的无效搜索。</p><p>最后对于Implicit Lists的性能做个总结：<br />分配：<span class="math inline">\(O(n)\)</span><br />释放：<span class="math inline">\(O(1)\)</span><br />Memory Overhead：取决于First Fit等策略</p><p>感觉这个性能已经不错了，但是一些无聊的计算机科学家还是不满意分配时的效率。接着我们看下更加🐂🍺的方法Segregated Free Lists： <img src="https://img-blog.csdnimg.cn/20201024204031234.png" alt="在这里插入图片描述" /> 每个size级别的块都有自己的free list，分配大小为n的块时：</p><ul><li>搜索合适的free list使得size&gt;n</li><li>找到：split并将remainder放入应该去的list</li><li>未找到：向操作系统申请更大的内存，分出去n，将剩下的放入相应的list</li></ul><p>释放时合并空闲块并且放入相应的free list即可。</p><p>这实际上近似模拟了Best Fit，而且不用搜索整个free list，Best Fit一般有着最优的内存利用率，但是运行时间<span class="math inline">\(O(n)\)</span>，又是吞吐量和内存利用率的trade-off，终于明白了为什么官方的<code>malloc</code>要用这个方式了：吞吐量更大<span class="math inline">\(O(lgn)\)</span>、更优的内存利用率Best Fit。</p><p>Segregated Free Lists中的空闲块包含Header+prev+next+padding+Footer，已分配块没有前后指针。 写代码要注意：整个堆中的块位置是不变的，只是状态（分配、释放）在改变，整个堆中的空闲块是用seg list的方式串起来的。</p><p>Debug可以自己写一下<code>mm_check</code>，还是很有用的。 <code>realloc</code>快de疯了，整整一个晚上。。。其实就4种情况：</p><ol type="1"><li>如果当前已分配块后面是结尾块，直接申请新的堆空间，与原块组合返回；</li><li>如果当前已分配块后面是一个空闲块，且两者之和&gt;=size，组合返回；</li><li>如果当前已分配块后是一个空闲块，但两者之和&lt;size，但是空闲块后是结束块，申请新的堆空间，三者组合返回；</li><li>malloc新块，将原块复制，释放原块。</li></ol><p>第一次写完，只有85，内存利用率太差了： <img src="https://img-blog.csdnimg.cn/20201117220719669.png" alt="在这里插入图片描述" /> <code>place</code>的时候，如果申请块比较大，我们将其分配到后半部分，将前半部分切割为空闲： <img src="https://img-blog.csdnimg.cn/2020111909030584.png" alt="在这里插入图片描述" /> 之前class的划分是1，2-3，4-7，8-15... 但是最小块是16B，所以16B以下的用不到，所以改为16-31，32-63，64-127，128-255...</p><p>这样优化后直接96： <img src="https://img-blog.csdnimg.cn/20201119092357832.png" alt="在这里插入图片描述" /> 后面还可以继续优化榨干性能，比如去掉已分配块的Footer，<code>realloc</code>组合块以后对remainder进行split...<br />以后有时间再说......</p><h2 id="思考">思考</h2><p>显然上述实现只是toy example, 工业界涌现了很多优秀的内存分配器, 如glibc自带的ptmalloc, Google的tcmalloc, Facebook的jemalloc.</p><h2 id="reference">Reference</h2><p><a href="https://stackoverflow.com/questions/9866145">tcmalloc/jemalloc</a><br /><a href="https://www.cyningsun.com/07-07-2018/memory-allocator-contrasts.html">对比分析</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stacking</title>
      <link href="/2020/11/17/Stacking/"/>
      <url>/2020/11/17/Stacking/</url>
      
        <content type="html"><![CDATA[<p>Ensemble Learning的基本思想就是将多个基学习器组合在一起，产生泛化能力更强的模型。<br />组合策略有许多种，包括Voting、平均法和Stacking等，Stacking就是选择某种学习器作为组合基学习器的方式。<br /><img src="https://img-blog.csdnimg.cn/20200926193430376.png" alt="在这里插入图片描述" /><br />既然要结合多个基学习器的优点，那么基学习器的选择最好是“准而不同”，元学习器一般选择比较简单的模型（如逻辑回归），防止过拟合。<br />比较简单的想法就是将全部训练集用于训练基学习器，将基学习器的预测结果作为元学习器的训练集，从而得到整个模型。<br />这样做的问题在于：基学习器最终在训练集上的表现非常好，再用基学习器在该训练集上的预测结果作为次级训练集，同样元学习器在该训练集上表现也会非常好，但是模型的泛化能力不一定很好，有过拟合的风险。<br />因此，采用K折交叉验证的方式，用训练基学习器未使用的样本来产生次级训练集。<br /><img src="https://img-blog.csdnimg.cn/20201109191045436.jpg" alt="在这里插入图片描述" /><br />具体来讲：<br />在训练阶段（假设训练集<span class="math inline">\(400*10\)</span>），对于每个基学习器（假设有3个基学习器），进行5次训练与验证，得到<span class="math inline">\(400*1\)</span>的验证结果，那么最终次级训练集是<span class="math inline">\(400*3\)</span>（类标签还是原始类标签），用这些数据训练次级学习器，完成后再用全部的训练集训练所有的基学习器（可选，提高基学习器性能）；<br />在测试阶段，如果训练阶段选了最后一步，那么每个基学习器直接得到一个结果，就会得到3个测试结果，送入次级学习器，得到最终的预测结果；如果训练时没有选最后一步，那么每个基学习器都有5个小模型，将测试样本用5个小模型分别测试，将5个结果平均得到某个基学习器的预测结果，也会得到3个测试结果。<br /><img src="https://img-blog.csdnimg.cn/20201109192340496.png" alt="在这里插入图片描述" /><br />Weka里的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Buildclassifier selects a classifier from the set of classifiers</span></span><br><span class="line"><span class="comment">   * by minimising error on the training data.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> data the training data to be used for generating the</span></span><br><span class="line"><span class="comment">   * boosted classifier.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the classifier could not be built successfully</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 建立整个模型</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildClassifier</span><span class="params">(Instances data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_MetaClassifier == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No meta classifier has been set&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断分类器是否有能力处理该数据集</span></span><br><span class="line">    getCapabilities().testWithFail(data);</span><br><span class="line">    <span class="comment">// 删除类标签缺失数据</span></span><br><span class="line">    Instances newData = <span class="keyword">new</span> Instances(data);</span><br><span class="line">    m_BaseFormat = <span class="keyword">new</span> Instances(data, <span class="number">0</span>);</span><br><span class="line">    newData.deleteWithMissingClass();</span><br><span class="line">    </span><br><span class="line">    Random random = <span class="keyword">new</span> Random(m_Seed);</span><br><span class="line">    newData.randomize(random); <span class="comment">// 打乱整个数据集</span></span><br><span class="line">    <span class="comment">// 如果是分类问题，分层抽样</span></span><br><span class="line">    <span class="comment">// 原始数据按照类标签集中在一起，按m_NumFolds为步长重新抽取数据，保持训练集/验证集数据分布一致性, 避免因数据划分引入额外的偏差</span></span><br><span class="line">    <span class="keyword">if</span> (newData.classAttribute().isNominal()) &#123;</span><br><span class="line">      newData.stratify(m_NumFolds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理原始数据得到新的数据，建立meta classifier</span></span><br><span class="line">    generateMetaLevel(newData, random);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// restart the executor pool because at the end of processing</span></span><br><span class="line">    <span class="comment">// a set of classifiers it gets shutdown to prevent the program</span></span><br><span class="line">    <span class="comment">// executing as a server</span></span><br><span class="line">    <span class="comment">// 创建线程池，为下面的基学习器训练做准备</span></span><br><span class="line">    <span class="keyword">super</span>.buildClassifier(newData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提高基础模型的准确度，使其在测试数据表现更好，用所有的训练集进行基学习器的训练</span></span><br><span class="line">    <span class="comment">// 这里为了节省时间，测试时，可以直接在多个基学习器预测后取平均</span></span><br><span class="line">    <span class="comment">// Rebuild all the base classifiers on the full training data</span></span><br><span class="line">    buildClassifiers(newData);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Generates the meta data</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newData the data to work on</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> random the random number generator to use for cross-validation</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">generateMetaLevel</span><span class="params">(Instances newData, Random random)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 先用newData得到metaData的格式m_MetaFormat</span></span><br><span class="line">    <span class="comment">// 确定元分类器需要的属性</span></span><br><span class="line">    Instances metaData = metaFormat(newData);</span><br><span class="line">    m_MetaFormat = <span class="keyword">new</span> Instances(metaData, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_NumFolds; j++) &#123;</span><br><span class="line">      <span class="comment">// 得到训练集</span></span><br><span class="line">      Instances train = newData.trainCV(m_NumFolds, j, random);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// start the executor pool (if necessary)</span></span><br><span class="line">      <span class="comment">// has to be done after each set of classifiers as the</span></span><br><span class="line">      <span class="comment">// executor pool gets shut down in order to prevent the</span></span><br><span class="line">      <span class="comment">// program executing as a server (and not returning to</span></span><br><span class="line">      <span class="comment">// the command prompt when run from the command line</span></span><br><span class="line">      <span class="comment">// 线程池，多线程并行构建基学习器</span></span><br><span class="line">      <span class="keyword">super</span>.buildClassifier(train);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建基学习器</span></span><br><span class="line">      buildClassifiers(train);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Classify test instances and add to meta data</span></span><br><span class="line">      <span class="comment">// 将未使用过的原始训练数据通过基学习器预测后加入metadata作为新的训练集</span></span><br><span class="line">      Instances test = newData.testCV(m_NumFolds, j);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.numInstances(); i++) &#123;</span><br><span class="line">        metaData.add(metaInstance(test.instance(i)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用元数据建立元分类器</span></span><br><span class="line">    m_MetaClassifier.buildClassifier(metaData);    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>因为基学习器之间的训练是独立的，所以每次交叉验证划分好数据后，都是利用线程池并行训练。<br />如果是在分层抽样的基础上划分训练集和验证集，<code>trainCV()</code>抽取数据后，需要将新的训练集Shuffle，保证独立同分布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes the format for the level-1 data.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> instances the level-0 format</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the format for the meta data</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the format generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 生成元数据格式</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Instances <span class="title">metaFormat</span><span class="params">(Instances instances)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果m_BaseFormat属性连续，就加入m_Classifiers.length个属性</span></span><br><span class="line">    <span class="comment">// 如果是离散的，每次要加入level 0类别属性取值个数个属性</span></span><br><span class="line">    ArrayList&lt;attribute&gt; attributes = <span class="keyword">new</span> ArrayList&lt;attribute&gt;();</span><br><span class="line">    Instances metaFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历基学习器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m_Classifiers.length; k++) &#123;</span><br><span class="line">      Classifier classifier = (Classifier) getClassifier(k);</span><br><span class="line">      String name = classifier.getClass().getName() + <span class="string">&quot;-&quot;</span> + (k+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (m_BaseFormat.classAttribute().isNumeric()) &#123;</span><br><span class="line">        attributes.add(<span class="keyword">new</span> Attribute(name));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果离散，后续会通过每个取值的概率来判断，比如杂色、圆花，这2种特性不能用一个属性表示，所以每个取值都要独立成单独的属性</span></span><br><span class="line">          <span class="comment">// 来保存概率值</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_BaseFormat.classAttribute().numValues(); j++) &#123;</span><br><span class="line">            attributes.add(</span><br><span class="line">              <span class="keyword">new</span> Attribute(</span><br><span class="line">              name + <span class="string">&quot;:&quot;</span> + m_BaseFormat.classAttribute().value(j)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加上原始类标签</span></span><br><span class="line">    attributes.add((Attribute) m_BaseFormat.classAttribute().copy());</span><br><span class="line">    <span class="comment">// 形成元数据格式</span></span><br><span class="line">    metaFormat = <span class="keyword">new</span> Instances(<span class="string">&quot;Meta format&quot;</span>, attributes, <span class="number">0</span>);</span><br><span class="line">    metaFormat.setClassIndex(metaFormat.numAttributes() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> metaFormat;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>生成元数据格式时，如果是分类问题，类标签的每个属性都被作为一个新的属性：<br /><img src="https://img-blog.csdnimg.cn/20201109195503863.png" alt="在这里插入图片描述" /><br />这里我个人这样理解：有的基分类器可以输出属于某个类的概率（如逻辑回归），将概率作为元属性而不是直接将基学习器的分类结果作为元属性，这样做能够减小基学习器的分类误差带给元学习器的影响，模型整体更加精确：<br /><img src="https://img-blog.csdnimg.cn/20201109195918632.png#pic_center" alt="在这里插入图片描述" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes a level-1 instance from the given instance.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> instance the instance to be transformed</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the level-1 instance</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the instance generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 产生元数据</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Instance <span class="title">metaInstance</span><span class="params">(Instance instance)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// values保存分类结果，连续属性直接保存，离散属性则先求得分布，将每种取值的分布加入values，设置为m_MetaFormat格式返回</span></span><br><span class="line">    <span class="keyword">double</span>[] values = <span class="keyword">new</span> <span class="keyword">double</span>[m_MetaFormat.numAttributes()];</span><br><span class="line">    Instance metaInstance;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m_Classifiers.length; k++) &#123;</span><br><span class="line">      Classifier classifier = getClassifier(k);</span><br><span class="line">      <span class="keyword">if</span> (m_BaseFormat.classAttribute().isNumeric()) &#123;</span><br><span class="line">        values[i++] = classifier.classifyInstance(instance);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 基学习器对该实例的分类的概率分布, sum(dist)=1</span></span><br><span class="line">        <span class="keyword">double</span>[] dist = classifier.distributionForInstance(instance);</span><br><span class="line">        <span class="comment">// 将该基学习器对该实例的预测概率输出到对应的元属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dist.length; j++) &#123;</span><br><span class="line">          values[i++] = dist[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标签值对应最后一个元属性</span></span><br><span class="line">    values[i] = instance.classValue();</span><br><span class="line">    metaInstance = <span class="keyword">new</span> DenseInstance(<span class="number">1</span>, values);</span><br><span class="line">    metaInstance.setDataset(m_MetaFormat);</span><br><span class="line">    <span class="keyword">return</span> metaInstance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在实际数据集上的结果其实不一定比其他模型效果好，可能是我参数调的不好吧（雾）~</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bear Maps</title>
      <link href="/2020/11/07/Bear%20Maps/"/>
      <url>/2020/11/07/Bear%20Maps/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>这是CS 61B的Project 3，也是最后一个Proj。刚好上完这门课出去旅个游，放松下心情开始15213。<br />完成基本的要求花了5天时间，当然现在的版本还十分简陋，这个工程我是想做得比较大，后面还得抽时间消化理解、完善优化。</p><p>SP18用了<a href="https://maven.apache.org/">Apache Maven</a>做项目建构工具，<a href="https://blog.csdn.net/qq_41431457/article/details/102999439">折腾</a>了一天也没有配好，<del>不知道这么垃圾的工具有啥用</del> ，最后实在没辙就把该项目所有需要的jar包导进来，后来发现SP19就抛弃了maven。<br /><img src="1.png" alt="在这里插入图片描述" /><br />项目需要的地图集以及地图上的点/路信息都是Google采集好的，可在<a href="https://github.com/Berkeley-CS61B">这里</a>下载，当然这个地图只是一小部分，后面想要扩展可以去下载需要的<a href="https://www.openstreetmap.org/">数据集</a>，包括tile images和map feature data。</p><p>整体需求是实现一个网页端地图，用户通过浏览器输入URL，Java程序接收，然后生成相应的地图结果并返回，在浏览器中显示。服务器框架用的是<a href="http://sparkjava.com/documentation.html#getting-started">Spark</a>，前端以及前后端交互的部分已经写好了（TA真的太强了），其实我有时候觉得这些dirty的工作比较考验码力，这些代码写得漂亮说明System的能力是挺强的。</p><p>后端至少需要实现3个类：</p><ul><li><code>Rasterer</code><br />输入upper left latitude and longitude, lower right latitude and longitude, a window width, and a window height.<br />输出2D array of filenames corresponding to the files to be rendered.</li><li><code>GraphDB</code><br />输入Open Street Map数据集，将其转为图存储起来：每个结点是a single intersection，每条边是一条路。</li><li><code>Router</code><br />输入GraphDB, a starting latitude and longitude, and a destination latitude and longitude.<br />输出从起点到终点的一系列结点，以及路径导航信息。</li></ul><h2 id="map-rastering">Map Rastering</h2><p>首先要将用户查询的真实世界的经纬度信息转为实际地图，<code>Rasterer.java</code>会接收用户请求的矩形参数<code>Map&lt;String, Double&gt; params</code>，生成对应的图像名称<code>String[][]</code>：<br />主要工作在<code>getMapRaster()</code>方法中完成，用户输入的查询请求共有6个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;lrlon=-<span class="number">122.2104604264636</span>, ullon=-<span class="number">122.30410170759153</span>, w=<span class="number">1085.0</span>, h=<span class="number">566.0</span>, ullat=<span class="number">37.870213571328854</span>, lrlat=<span class="number">37.8318576119893</span>&#125;</span><br></pre></td></tr></table></figure><p>表示用户希望显示经度范围<code>lrlon</code>~<code>ullon</code>，纬度范围<code>ullat</code>~<code>lrlat</code>的区域，并且分辨率大概是<code>w*h</code>。</p><p>街景图采用<strong>冗余存储</strong>，所有图片都是<code>256*256</code>：<code>d0_x0_y0.png</code>是整个区域的街景，但是分辨率最低，<code>d1_x0_y0.png/d1_x0_y1.png/d1_x1_y0.png/d1_x1_y1.png</code>分别代表西北/东北/西南/东南四个角的街景，但是分辨率加倍。</p><p>更加规范的说：在第D个缩放级别，共有<span class="math inline">\(4^D\)</span>张图片，<code>dD_x0_y0.png</code>到<code>dD_xk_yk.png</code>，<span class="math inline">\(k=2^D-1\)</span>，随<code>x</code>增大向东移动，随<code>y</code>增大向南移动，我们需要返回<code>String[][]</code>代表用户请求区域的图片文件名矩阵，当然还有一些其他参数（查询是否成功等）：由于Java只能返回一个值，所以结果组装成<code>Map&lt;String, Object&gt;</code>返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[d2_x0_y1.png, d2_x1_y1.png, d2_x2_y1.png, d2_x3_y1.png],</span><br><span class="line">[d2_x0_y2.png, d2_x1_y2.png, d2_x2_y2.png, d2_x3_y2.png],</span><br><span class="line">[d2_x0_y3.png, d2_x1_y3.png, d2_x2_y3.png, d2_x3_y3.png]]</span><br></pre></td></tr></table></figure><p>上述返回结果的分辨率为<code>1024*768</code>，几乎满足用户分辨率要求<code>1085*556</code>。</p><p>这样对于同一个区域，可以有很多选择：可以用更多张高分辨率图片的组合，也可以用较少几张低分辨率的图片组合，只要满足用户要求，比如对于上述例子，<code>d2_x0_y1.png</code>可以采用<code>d3_x0_y2.png/d3_x1_y2.png/d3_x0_y3.png/d3_x1_y3.png</code>代替，这样返回的图片是<code>6*8</code>共48张，分辨率可达<code>2048*1536</code>。</p><p>但这样做很可能overflow，远远超过用户要求，浪费时间和资源，因为分辨率高就意味着展示的空间小，并且前端是不会做缩放的，如果用很多高分辨率图片，浏览器会有太多太多照片加载显示，因为大家都是<code>256*256</code>的。</p><p>所以定义单位像素的经度距离：<span class="math inline">\(\text{LonDPP} = \frac{\text{lower right longitude} - \text{upper left longitude}}{\text{width of the image (or box) in pixels}}\)</span>，我们要展示的是小于用户要求的LonDPP的最大值，比方说用户要求每个像素2度，如果我们大于2，那么分辨率低到不能满足要求，只有小于2才能满足要求。又不能太小，分辨率太高展示范围变小。当然如果用户要求的LonDPP很低，只能用现有的最低的LonDPP图片，即<code>d7</code>系列。<br />可以将LonDPP理解为模糊程度，LonDPP越大，显示的图片越模糊，比如<code>d0</code>系列就有最大的LonDPP。<br />纬度也要做类似处理。</p><p>举例来看：<code>d2</code>系列共有16张图片，用户请求Query Box应该返回9张图片：<br /><img src="2.png" alt="在这里插入图片描述" /><br />具体实现只有1个方法<code>public Map&lt;String, Object&gt; getMapRaster(Map&lt;String, Double&gt; params)</code>，分2步：</p><ul><li>需要的图片的<code>depth</code><br />全图即<code>d0</code>的经纬度范围是：<code>-122.29980, 37.89220/-122.21191, 37.82280</code><br />因为地球不是规则的，但是在确定Depth时，经度方向的LonDPP满足要求即可，不需考虑纬度方向的影响。</li><li>确定四个角的下标</li><li>corner case<br />判断输入是否合法时，边界判断一定要加EPS，不然一点小误差会崩掉程序。<br />输入不合法（用户拖动至全图外等），将<code>query_success</code>置为<code>false</code>返回即可。</li></ul><p>Bug：读取图片文件时，总是<code>javax.imageio.IOException: Can't read input file!</code>。一般都是路径问题。</p><h2 id="routing-location-data">Routing &amp; Location Data</h2><p>明确了前端需要显示哪些图片后，接下来就是要建一个图，因为最后要路径规划嘛。<br />路由和位置数据是通过<code>berkeley-2018.osm.xml</code>文件给的，是整个<a href="https://download.bbbike.org/osm/">地球数据</a>的一部分，文件格式是<a href="https://wiki.openstreetmap.org/wiki/OSM_XML">OSM XML</a>。</p><p>解析XML数据用的是SAX Parser，遍历每个element，在每个元素的开始和结束位置，调用<code>startElement</code>和<code>endElement</code>回调函数。</p><p>先来熟悉下OSM XML文档：<br /><img src="3.png" alt="在这里插入图片描述" /><br /><code>node</code>元素是组成地图的主干，有id/lat/lon等属性。如果结点是一个位置，那么<code>tag</code>标签就会有<code>name</code>，如果是其他的，比如路上的一个点，那么就没有<code>tag</code>。<br /><img src="4.png" alt="在这里插入图片描述" /><br /><code>way</code>元素表示一条路，路上可能有很多<code>node</code>，用<code>id</code>表示。<code>tag</code>会包含额外信息，如果<code>name</code>是highway，那么<code>v</code>就是道路类型。假设所有道路都是双向的。</p><p>在类<code>GraphDB</code>中存储图，要求允许插入和删除结点，最后要用<code>clean()</code>清理掉没有连接的结点。<br /><code>GraphBuildingHandler</code>会解析XML文件并调用<code>GraphDB</code>的一些接口函数构建整个图。</p><p>如果选择邻接矩阵存储，由于这是一个动态的图，可能要增加或者删除结点，所以一开始顶点个数是不确定的，也就不能用<code>int[][]</code>表示。所以选择邻接表，因为有<code>clean()</code>操作，需要判断结点是否与其他结点相邻，邻接表速度更快。</p><p><code>GraphBuildingHandler</code>每次只处理XML的一行，也就是一个标签，<code>GraphBuildingHandler</code>这个类可以被其它方法多次调用去处理完所有的XML，我发现这种拆分很有用，系统会变得简单，只需要考虑当前状态就很好写。清楚需求后，需要设计类的接口，数据结构和算法，这才是最难的部分。</p><p>由于parser的解析是从上到下的，所以处理<code>way</code>时最好不要直接把边和边上的结点直接加进图里，因为后面的<code>highway</code>的值可能不在合法范围内，这种边是不算的。所以在碰到边上的点，先存到一个数组里，最后<code>endElement()</code>时候如果路合法，再加进图里。处理<code>node</code>也同理，在<code>endElement()</code>时加入图。记得每次做完一个<code>node</code>或<code>way</code>要<code>clear()</code>上一个的状态信息。</p><p>每个<code>node</code>有一些属性（id/lat/lon），每条边也有一些属性（fromID/toID/name），所以首先要有<code>Node</code>类和<code>Edge</code>类。<br />邻接表的顶点表<code>Map&lt;Long, Node&gt; vertex</code>，边表<code>Map&lt;Long, Set&lt;Edge&gt;&gt; adj</code>。</p><p>Bug：对<code>ArrayList</code>等在迭代时同时进行修改就会引发异常<code>ConcurrentModificationException</code>。</p><p><code>long closest(double lon, double lat)</code>方法会被用来找最短路，需要返回最近的<strong>有邻居</strong>的<code>node</code>，一个点可能没有邻居，因为他是饭店啥的，不能用来找最短路。另外，这个方法复杂度要求<span class="math inline">\(O(lgn)\)</span>，先实现一个<span class="math inline">\(O(n)\)</span>的做法，后续有时间再去优化吧。</p><h2 id="route-search">Route Search</h2><p>建好地图后，就要做路由工作：给定起点和终点的经纬度，选一条距离最短的路径，需要在类<code>Router</code>中实现<code>shortestPath</code>方法。<br />应该从距起点最近的<code>node</code>开始导航到距终点最近的<code>node</code>结束，当然这些<code>node</code>必须是connected的。</p><p>两个<code>node</code>间的距离采用<a href="https://en.wikipedia.org/wiki/Great-circle_distance">great-circle distance</a>，即当作球模型来计算弧长距离。整体距离就是计算1/2之间、2/3之间...的距离之和，还要考虑经度和纬度有不同的尺度，并且随着纬度变化，每度代表的实际距离也是不同的，还好计算距离的函数已经由🐂🍺的TA写好了。</p><p>最好用A*而不是Dijkstra，启发函数h(n)用结点n到终点的great-circle distance就行，要注意目标不可达的情况。</p><p>开始只能在<code>berkeley-2018-small-osm.xml</code>上跑起来，我以为是笔记本配置太烂，跑大的数据集跑不动，只能用小的来测试，后来发现<code>GraphDB</code>里一行写错了。。。debug真痛苦啊！！</p><p>找到最优路线后，这里有一个optional feature，就是显示方向导航信息Turn-by-turn Navigation，需要在类<code>Router</code>中实现<code>routeDirections</code>方法。导航方向的表示是在<code>Router</code>类中写了一个新类<code>NavigationDirection</code>，具体的导航信息格式如下：<br />DIRECTION on WAY for DISTANCE miles<br />其中，DIRECTION有8种选择：</p><ul><li>“Start”</li><li>“Continue straight”</li><li>“Slight left/right”</li><li>“Turn left/right”</li><li>“Sharp left/right”</li></ul><p>所以我们需要确定正确的DIRECTION/WAY/DISTANCE，方向取决于当前结点和上一个节点间的<a href="https://en.wikipedia.org/wiki/Bearing_(navigation)">relative bearing</a>：</p><ul><li>Between -15 and 15 degrees the direction should be “Continue straight”.</li><li>Beyond -15 and 15 degrees but between -30 and 30 degrees the direction should be “Slight left/right”.</li><li>Beyond -30 and 30 degrees but between -100 and 100 degrees the direction should be “Turn left/right”.</li><li>Beyond -100 and 100 degrees the direction should be “Sharp left/right”.</li></ul><p>难点在于：一条<code>way</code>上可能包含了若干<code>node</code>，如何在遍历<code>node</code>的过程中判断<code>way</code>是否发生了改变，只有<code>way</code>变化后才能产生一条新的导航信息。如果恰好来到了一条没有<code>name</code>的路，就将WAY设为“unknown road”。</p><p>举例来说：<br />假设出发的<code>node</code>在“Shattuck Avenue”这条路上，那么DIRECTION应该设为“Start”，遍历接下来的<code>node</code>时，需要累加在这条路上走过的距离，最终到达一个不在“Shattuck Avenue”的<code>node</code>时，设置WAY为“Shattuck Avenue”，DISTANCE为之前的累加值。接着，下一条导航信息的DIRECTION应该根据相对方位计算，WAY是当前<code>node</code>所在的路，DISTANCE重新累加。</p><p>最终的效果：蓝色线表示最优路线：<br /><img src="5.png" alt="在这里插入图片描述" /><br />单元测试还是非常重要的，只有确保每一个函数都是正确的，最终组合的功能才可能正确。</p><h2 id="autocomplete-and-search">Autocomplete and Search</h2><p>作为一个很有用的Feature，自动补全还是很酷的：搜索地名时只输入一部分，就返回以它开头的所有地名。需要在<code>MapServer</code>类中实现<code>List&lt;String&gt; getLocationsByPrefix(String prefix)</code>方法。</p><p>输入的参数<code>prefix</code>是clean后的字符串：除了大小写字母以及空格外，其它字符全部被移除，全部由小写字母组成。 需要返回所有locations（有<code>name</code>的<code>node</code>）的全名，前提是clean后的全名与<code>prefix</code>匹配。<br />复杂度要求<span class="math inline">\(O(k)\)</span>，k是共享同一前缀的所有地名。</p><p>比如这样：<br /><img src="6.png" alt="在这里插入图片描述" /><br />除了自动补全，还需要完成Search功能：clean后的用户输入与clean后的<code>locationName</code>完全匹配，同名的<code>location</code>都需要加入<code>List</code>。<br />复杂度要求<span class="math inline">\(O(k)\)</span>，k是匹配的地名个数。<br />需要在<code>MapServer</code>类中实现<code>List&lt;Map&lt;String, Object&gt;&gt; getLocations(String locationName)</code>方法，返回同名的所有地方的信息，如果正确实现，那么就会有一个mark标记在那个地方：<br /><img src="7.png" alt="在这里插入图片描述" /><br />具体实现一般用Trie，这里的难点在于输入是clean后的字符串，需要输出clean前的全名，所以我们的Trie结点除了有<code>children</code>和<code>isWord</code>外，还需要保存一些额外的信息（clean前的<code>name</code>/<code>id</code>/<code>lat</code>/<code>lon</code>），当然这些信息只有叶子结点才需要保存，用<code>List&lt;Map&lt;String, Object&gt;&gt; extraInfo</code>来存储。这样重名的地点虽然占用了相同的叶子，但是所有地点的信息都存在了该叶子的<code>extraInfo</code>当中，可以直接展示出来。</p><p>Debug好痛苦啊！！有一次怎么样在浏览器都渲染不出来，折腾了一天，最后发现是因为html文件里一个js文件要FQ才可以访问，醉了。</p><h2 id="extensions">Extensions</h2><ul><li>Front-end Integration<br />现在是每调用一次，就在后台raster the entire image，然后传到前端显示。实际中前端可以缓存用过的tiles以及路线，下次调用无需后台计算。</li><li>Vectored Tiles<br />现在的数据是一张张图片，实际上这些图片是可以从roads, lines, filled areas, buildings等基础矢量几何图形提取，可以用OpenGL/WebGL将其全部绘制为三角形，这样非常同一的工作就可以用GPU去做，速度比CPU要快很多，这些矢量图形可以在<a href="https://wiki.openstreetmap.org/wiki/Vector_tiles">这里</a>下载。</li><li><a href="https://sp19.datastructur.es/materials/proj/proj2c/heroku">Deploy on Heroku</a><br />目前为止，我们的地图还只能在本地运行，下来就将它部署到服务器~<br />具体的部署过程可以参考上述链接，完成后APP就会部署到<a href="http://bearmaps-fun.herokuapp.com/map.html">这里</a>。<br />后续的代码更改需要rebuild jar包，然后redeploy。</li></ul><h2 id="todo">TODO</h2><p>做工程真是长期的活，遇到bug每天能写50行就不错了。</p><p>所有<a href="https://github.com/EIMadrigal/CS61B/tree/master/proj3">代码</a>均已通过AG的测试：<br />Part I：<br /><img src="8.png" alt="在这里插入图片描述" /><br />PART II &amp; III：<br /><img src="9.png" alt="在这里插入图片描述" /><br />附加Feature：<br /><img src="10.png" alt="在这里插入图片描述" /><br />单元测试除了<code>TestDirections</code>外全部通过。<br /><img src="11.png" alt="在这里插入图片描述" /><br />这个Bug真的有些诡异，不过：<br /><img src="12.png" alt="在这里插入图片描述" /><br />尽量少用<code>protected</code>修饰成员变量，写一个函数接口去访问。</p><h2 id="reference">Reference</h2><p><a href="https://sp18.datastructur.es/materials/proj/proj3/proj3">Project 3: Bear Maps, version 3.0</a><br /><a href="https://sp19.datastructur.es/materials/proj/proj2c/proj2c">Project 2C: Bear Maps, version 4.0</a><br /><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">a-star</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Support Vector Machine</title>
      <link href="/2020/11/02/Support%20Vector%20Machine/"/>
      <url>/2020/11/02/Support%20Vector%20Machine/</url>
      
        <content type="html"><![CDATA[<p>SVM是入门机器学习绕不开的一个话题，但愿这篇文章我能把它讲清楚。</p><h2 id="线性可分">线性可分</h2><p>SVM的核心思想是：对于<span class="math inline">\(p\)</span>维输入数据集，找一个有着maximum margin的<span class="math inline">\(p-1\)</span>维的超平面去做decision boundary，这与直觉是相符的：<br /><img src="https://img-blog.csdnimg.cn/20200903193214259.png" alt="在这里插入图片描述" /><br />回忆下小学数学讲过的几何知识：空间中一个超平面由法向量<span class="math inline">\(\vec w\)</span>和截距<span class="math inline">\(b\)</span>唯一确定： <span class="math display">\[a(x-x_1)+b(y-y_1)+c(z-z_1)+...=0, \\w^Tx+b=0\]</span> 那么如何求解最优超平面的<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>呢？</p><p>假设<span class="math inline">\(\vec w\)</span>指向的一侧为正类（设为负类也没关系，后面会统一表示的），还<strong>假设</strong>在正类的支持向量上有<span class="math inline">\(w^Tx+b=1\)</span>，在负类的支持向量上有<span class="math inline">\(w^Tx+b=-1\)</span>，这里之所以将间隔假设为1主要是为了方便表示和求解，并不影响最终求得的最优超平面和决策函数，证明如下：</p><p>假设正类支持向量距最优超平面距离为<span class="math inline">\(c(c&gt;0)\)</span>，即<span class="math inline">\(w^Tx+b=c\)</span>，此时对应的最优超平面为<span class="math inline">\(w^Tx+b=0\)</span>；又<span class="math inline">\(\frac{w^T}{c}x+\frac{b}{c}=1\)</span>，即<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>同时缩小<span class="math inline">\(c\)</span>倍，那么这时超平面方程同除以<span class="math inline">\(c\)</span>并不改变其形式。</p><p>因此对于正负样本有： <span class="math display">\[w\cdot x_++b\geq 1 \\w\cdot x_-+b\leq -1\]</span> 为了统一表示上面2种情况，引入<span class="math inline">\(y_i=\begin{cases} 1,&amp;\text{+sample}\\ -1,&amp;\text{-sample} \end{cases}\)</span>，所有样本统一表示为： <span class="math display">\[y_i(w\cdot x_i+b)-1\geq 0\]</span> 如果能确定<span class="math inline">\(b\)</span>和<span class="math inline">\(w\)</span>，那么分类超平面和决策函数也就随即确定。</p><p>根据小学数学，间隔即为2个平行超平面的距离： <span class="math display">\[width=\frac{(b+1)-(b-1)}{||w||}=\frac{2}{||w||}\tag{1}\]</span></p><p>综上，<strong>原优化问题</strong>为： <span class="math display">\[\begin{array}{ll}\min _{w, b} &amp; \frac{1}{2}\|w\|^{2} \\\text { s.t. } &amp; y_{i}\left(w \cdot x_{i}+b\right)-1 \geqslant 0, \quad i=1,2, \cdots, N\end{array}\tag{2}\]</span> 这里之所以构造为<span class="math inline">\(\frac{1}{2}\|w\|^{2}\)</span>而不是<span class="math inline">\(||w||\)</span>是为了后面构造的Lagrangian求导的便利。</p><p>明眼人都看得出来：优化目标是一个Convex Quadratic Optimization Problem，并且只有线性约束条件，意味着不会卡在局部极大，一定可以找到全局最优解。此时上述问题已经完全可以用一些QP软件求解了。之所以还要继续讨论下去得到其对偶形式，一是为了在高维空间应用kernel，二是对偶形式的求解有着更加高效的算法。</p><p>回忆下学过的高等数学：有约束优化问题可以通过拉格朗日乘子法求解。首先构造Lagrangian： <span class="math display">\[L(w,b,\alpha)=\frac{||w||^2}{2}-\sum_{i=1}^{N}\alpha_i[y_i(w\cdot x_i+b)-1],\alpha_i\geq0\tag{3}\]</span> 如果<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>满足<span class="math inline">\((2)\)</span>中的约束，那么<span class="math inline">\(\max_{\alpha}L(w,b,\alpha)=\frac{||w||^2}{2}\)</span>；<br />如果<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>不满足<span class="math inline">\((2)\)</span>中的约束，那么<span class="math inline">\(\max_{\alpha}L(w,b,\alpha)=+\infin\)</span>。<br />因此下式的优化问题与<span class="math inline">\((2)\)</span>完全等价： <span class="math display">\[\min_{w, b}\max_{\alpha} L(w, b, \alpha)\tag{4}\]</span> 根据拉格朗日对偶性（不懂就暂时当作成立吧嘻嘻），<span class="math inline">\((4)\)</span>的对偶问题为： <span class="math display">\[\max_{\alpha} \min_{w, b} L(w, b, \alpha)\tag{5}\]</span> 为了求解对偶问题<span class="math inline">\((4)\)</span>，先求<span class="math inline">\(L\)</span>对<span class="math inline">\(w,b\)</span>的极小，再求对<span class="math inline">\(\alpha\)</span>的极大：</p><ol type="1"><li>固定<span class="math inline">\(\alpha\)</span>，求<span class="math inline">\(\min_{w, b} L(w, b, \alpha)\)</span> 分别求<span class="math inline">\(L\)</span>对<span class="math inline">\(\vec{w}\)</span>和<span class="math inline">\(b\)</span>的偏导并令其为0： <span class="math display">\[\frac{\partial L}{\partial\vec{w}}=\vec{w}-\Sigma\alpha_iy_ix_i=0, \vec{w}=\Sigma\alpha_iy_ix_i \\\frac{\partial L}{\partial b}=\Sigma\alpha_iy_i=0, \Sigma\alpha_iy_i=0\tag{6}\]</span> 决策向量<span class="math inline">\(\vec{w}\)</span>是样本的线性和，将<span class="math inline">\(\vec{w}\)</span>代入<span class="math inline">\((3)\)</span>： <span class="math display">\[\min_{w, b}L=\Sigma\alpha_i-\frac{1}{2}\Sigma_i\Sigma_j\alpha_i\alpha_jy_iy_jx_i\cdot x_j\tag{7}\]</span></li><li>求<span class="math inline">\(\min_{w, b} L(w, b, \alpha)\)</span>对<span class="math inline">\(\alpha\)</span>的极大 即求<span class="math inline">\((7)\)</span>对<span class="math inline">\(\alpha\)</span>的极大，等价于取负号求对<span class="math inline">\(\alpha\)</span>的极小，于是终于得到了<strong>原优化问题</strong><span class="math inline">\((2)\)</span>的<strong>对偶优化问题</strong>： <span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; \alpha_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\tag{8}\]</span></li></ol><p>利用SMO等算法可以比普通的二次规划算法更高效求得最优的<span class="math inline">\(\alpha^*\)</span>，进而根据<span class="math inline">\((6)\)</span>求得： <span class="math display">\[w^{*}=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i}\tag{9}\]</span> 再利用KKT条件（不懂就装懂吧嘻嘻）求得： <span class="math display">\[b^{*}=y_{j}-(w^*)^Tx_j=y_{j}-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}\left(x_{i} \cdot x_{j}\right)\tag{10}\]</span> 其中，<span class="math inline">\(y_{j}\)</span>为任意一个支持向量。</p><p>最终的分类超平面为： <span class="math display">\[w^{*}\cdot x+b^{*}=0,\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}(x_{i}\cdot x)+b^{*}=0\tag{11}\]</span> 分类决策函数为： <span class="math display">\[f(x)=sign(w^{*}\cdot x+b^{*})=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}(x_{i}\cdot x)+b^{*}\tag{12}\]</span> 最后要bb的是关于支持向量，根据KKT条件里的互补条件<span class="math inline">\(\alpha_{i}^{*}[y_{i}(x_{i}\cdot w^*+b^{*})-1]=0\)</span>：非支持向量必然有<span class="math inline">\(\alpha_{i}^{*}=0\)</span>，只有支持向量才可能出现<span class="math inline">\(\alpha_{i}^{*}&gt;0\)</span>。</p><p>如果回头看<span class="math inline">\((9)(10)(11)(12)\)</span>，所有的非支持向量对SVM没有任何影响，最优超平面以及决策函数都只由少量的支持向量决定，这大概就是支持向量机名称的由来吧~</p><h2 id="近似线性可分">近似线性可分</h2><p>上面讨论了完全线性可分的情况，然而在现实情况中，训练数据会有一些outliers，除去这些点后数据是线性可分的。为了处理这种情况，允许SVM分错一些样本。对每个样本点引入松弛因子<span class="math inline">\(\xi_{i} \geqslant 0\)</span>，即样本点的函数间隔只需要大于<span class="math inline">\(1-\xi_{i}\)</span>，放松了限制条件，<strong>原优化问题</strong>变为： <span class="math display">\[\begin{array}{ll}\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i} \\\text { s.t. } &amp; y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1-\xi_{i}, \quad i=1,2, \cdots, N \\&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\tag{13}\]</span> 如果样本点严格满足约束，对于损失函数没有贡献；如果不严格满足即<span class="math inline">\(\xi_{i}&gt;0\)</span>，损失函数就会有相应的惩罚。惩罚参数<span class="math inline">\(C\)</span>控制了一种权衡：既要间隔最大（即<span class="math inline">\(min\ ||w||\)</span>），又要分对尽可能多的样本点。</p><p>类似地，<span class="math inline">\((13)\)</span>可以通过拉格朗日乘子法转换为对偶问题后再去求解，建议吃饱的同学自己尝试一下。<span class="math inline">\((13)\)</span>的<strong>对偶优化问题</strong>是： <span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; 0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N\end{array}\tag{14}\]</span> 此时此刻恰如彼时彼刻，使用普通的二次规划算法或者更高效的SMO求解<span class="math inline">\((14)\)</span>得到最优的<span class="math inline">\(\alpha_{i}^{*}\)</span>，进而得到软间隔SVM的解： <span class="math display">\[w^{*}=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i} \\b^{*}=y_{j}-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}\left(x_{i} \cdot x_{j}\right)\tag{15}\]</span> 其中，<span class="math inline">\(y_{j}\)</span>要满足<span class="math inline">\(0&lt;\alpha_j&lt;C\)</span>。</p><h2 id="非线性可分">非线性可分</h2><p>上面讨论了线性分类问题，对于非线性可分问题，SVM的思想是做一个变换<span class="math inline">\(\phi(\vec{x})\)</span>，将样本映射到另外一个空间，也许就线性可分了。<br />由于目标函数和决策函数<strong>只依赖于样本对之间的点积</strong>，所以无需显式定义变换<span class="math inline">\(\phi(\vec{x})\)</span>，只要定义一个函数<span class="math inline">\(K(\vec{x_i},\vec{x_j})=\phi(\vec{x_i})\cdot\phi(\vec{x_j})\)</span>提供新空间的样本点的点积即可，<span class="math inline">\(K\)</span>叫做<strong>Kernel Function</strong>。<br />此时原优化问题为： <span class="math display">\[\begin{array}{ll}\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i} \\\text { s.t. } &amp; y_{i}\left(w^T \phi(x_{i})+b\right) \geqslant 1-\xi_{i}, \quad i=1,2, \cdots, N \\&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\]</span> 对偶问题为： <span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(K(x_{i},x_{j})\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; 0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N\end{array}\]</span> 一种常用的kernel是线性的：<span class="math inline">\((\vec{u}\cdot\vec{v}+1)^n\)</span>，当前空间的<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>通过简单的点积映射到了另一个空间；<br />另一种kernel是高斯核：<span class="math inline">\(e^{-\frac{||x_i-x_j||^2}{\sigma}}=e^{-\gamma{||x_i-x_j||}^2}\)</span>。<br />高斯核对应高斯径向基函数分类器，这里有2个参数<span class="math inline">\(C\)</span>和<span class="math inline">\(\gamma\)</span>需要调节：惩罚系数<span class="math inline">\(C\)</span>表示分类器对于误差的宽容度，<span class="math inline">\(C\)</span>越大表示越不能容忍误差，容易过拟合，按照经验可以在<span class="math inline">\([10^{-4},10^4]\)</span>间调节；<span class="math inline">\(\gamma\)</span>控制径向作用范围，<span class="math inline">\(\gamma\)</span>越大，径向作用范围越小，有可能将每个样本点单独形成一个分类，容易过拟合，<span class="math inline">\(\gamma\)</span>过小，径向范围过大，容易将2个样本映射为同一个点，无法区分，一般<span class="math inline">\(\gamma=\frac{1}{样本特征数}\)</span>。另外，这2个参数可以通过交叉验证和grid-search来调整。</p><h2 id="扩展">扩展</h2><p>SVM处理多分类问题的方式主要有2种：</p><ul><li>one-against-one<br />在每2个类之间都构造一个binary SVM，共有<span class="math inline">\(C_m^2\)</span>个SVM，对新数据采用Voting的方式进行分类。</li><li>one-against-the-rest<br />对每个类，将其作为正类，其余<span class="math inline">\(m-1\)</span>个类作为负类，共<span class="math inline">\(m\)</span>个SVM，对新数据采用winner-takes-all策略。</li></ul><p>如果样本不均衡，目标函数中的惩罚项主要由多数类构成，超平面偏向少数类，甚至将所有样本都分在同一侧。<br />此时目标变为了在不严重损失多数类精度的情况下，在少数类上获得尽可能高的分类正确率。一般来讲有2种做法：</p><ul><li>数据合成<br />对少数类样本进行分析并根据其特点人工插值合成新样本添加到数据集中，构成均衡数据集。比较常用的方法是SMOTE(Synthetic Minority Oversampling Technique)。</li><li>加权SVM<br />将少数类分错的代价很大，所以在惩罚项中对两个类设置不同的惩罚系数，少数类的系数设置更大，甚至可以对每个样本都设置不同的惩罚系数，此时原优化问题变为： <span class="math display">\[\begin{array}{ll}\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C^+ \sum_{y_i=1} \xi_{i}+C^-\sum_{y_i=-1} \xi_{i} \\\text { s.t. } &amp; y_{i}\left(w^T \phi(x_{i})+b\right) \geqslant 1-\xi_{i}, \quad i=1,2, \cdots, N \\&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\]</span> 对偶问题： <span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(K(x_{i},x_{j})\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; 0 \leqslant \alpha_{i} \leqslant C^+, y_i=+1 \\&amp; 0 \leqslant \alpha_{i} \leqslant C^-, y_i=-1\end{array}\]</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO Multiplexing</title>
      <link href="/2020/10/23/IO%20Multiplexing/"/>
      <url>/2020/10/23/IO%20Multiplexing/</url>
      
        <content type="html"><![CDATA[<p>当多个独立的I/O事件同时发生时，I/O多路复用是一种解决方式。<br />为了提高服务器的吞吐量，<strong>单个线程</strong>通过记录跟踪每个I/O流的状态同时管理多个I/O流，非常类似时分复用技术。<br /><img src="https://img-blog.csdnimg.cn/20200825092905568.gif#pic_center" alt="在这里插入图片描述" /><br />I/O多路复用的具体实现方式有3种：<code>select()</code>、<code>poll()</code>和<code>epoll()</code>。</p><h2 id="select">select</h2><p><code>select()</code>系统调用：<code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code><br /><code>select()</code>会一直阻塞直到至少一个文件描述符就绪，可以读写，或者出现异常。<br />中间3个参数会被修改，表示哪个FD准备好了，最后一个表示等待时间，NULL表示无限等待。<br />返回就绪的FD数目，有错-1。只知道有就绪，不知道哪个FD就绪了。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd[];  <span class="comment">// 需要监听的socket集合</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = select();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fd.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET()) &#123;  <span class="comment">// 判断哪个socket接收到数据</span></span><br><span class="line">            <span class="comment">// 处理数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>select()</code>是阻塞方法，只有某个socket接收到数据才会继续执行，唤醒进程。<br />直接的方式缺点就比较多：</p><ul><li>时间开销大，所以规定最多监听1024个socket；</li><li>每次调用都要把fd集合从用户态拷贝到内核态。</li><li>线程不安全：</li></ul><blockquote><p>If a file descriptor being monitored by select() is closed in another thread, the result is unspecified.</p></blockquote><h2 id="poll">poll</h2><p>去掉了1024的限制，线程不安全。</p><h2 id="epoll">epoll</h2><p>线程安全，知道哪个FD就绪，只有Linux支持。<br />相比于<code>select()</code>，<code>epoll()</code>不会无差别轮询，只处理接收到数据的socket，这样复杂度就降低为<span class="math inline">\(O(k)\)</span>。</p><p>水平触发： 边缘触发：读只要状态变化就会通知，写只要从满到非满就通知</p><h2 id="reference">Reference</h2><p><a href="https://www.zhihu.com/question/32163005/answer/55772739">I/O多路复用是什么意思</a><br />https://zhuanlan.zhihu.com/p/358208161<br />https://www.zhihu.com/question/59975081/answer/1932776593</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魏晋风度浅探</title>
      <link href="/2020/10/18/%E9%AD%8F%E6%99%8B%E9%A3%8E%E5%BA%A6%E6%B5%85%E6%8E%A2/"/>
      <url>/2020/10/18/%E9%AD%8F%E6%99%8B%E9%A3%8E%E5%BA%A6%E6%B5%85%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>从小学作文开始，就喜欢写一些辞藻华丽的诗歌文章。<br />竹林七贤我当时只听说过山涛、阮籍和嵇康，引用之意是觉这几位遗世独立、傲然风骨，没有世俗羁绊，整日琴棋书画、饮酒作乐、不问世事，潇洒写意的生活，正是吾向往之。《广陵散》和《与山巨源绝交书》更是勾起了我对于嵇康无限的崇拜。<br />我极喜欢嵇康和纳兰性德，即使一些毫无关联的题目，也要用他们的事例强行去阐述论点。但由于只喜欢钻研近现代的战争史（可以原谅，男孩一般都喜欢枪支、火炮等近现代武器），一直对古代史不感兴趣，觉得几千年前的文化故事不过是落后、腐朽的代名词而已，所以其实对一些人物只是略知一二，最近花了些时间重新捋了一下魏晋那段历史，故分享于此。</p><h2 id="历史背景">历史背景</h2><p>我一直觉得想要真正了解一段文化、一个人物，就首先要了解他们所处的历史时代。<br />曹操在东汉末年的群雄逐鹿中“挟天子以令诸侯”，在三国末期势力最强。曹操去世后，其子曹丕于公元220年建立曹魏政权。公元265年，司马炎建立西晋，史称晋武帝。竹林七贤就是生活在这样一段历史时期：<br />山涛：205~283<br />阮籍：210~263<br />嵇康：224~263<br />刘伶：221~300<br />向秀：227~272<br />阮咸：不详<br />王戎：234~305<br />曹丕去世后，曹叡即位，公元239年隆冬时节，曹叡驾崩之际，将皇位传给仅仅8岁的曹芳，并将其同时托孤给司马懿和曹爽，于是在接下来漫长的几十年中，曹氏集团和司马氏集团开始了你死我活的政治斗争，史称“曹马之争”。</p><h2 id="竹林七贤">竹林七贤</h2><p>在那个极其黑暗动荡的乱世之中，文学和艺术却得到了出乎意料的大发展，人们对自由解放的追求达到了极致，鲁迅先生称之为魏晋风度。当时盛行清谈和隐逸，古人的心灵更加丰富和缠绵，规则的约束压抑了个性与自我，却在频频交流中迎来了文化的繁荣。不要用成王败寇的观点去评价历史人物，参差百态，实乃幸福本源。</p><p>而对魏晋风度影响最大的自然就是竹林七贤，虽然百年之后后人将其称之为七贤，但这个文人沙龙的规模其实大于7人，之所以定为七贤，据刘强老师的说法是为了攀附《论语》：</p><blockquote><p>贤者辟世，其次辟地，其次辟色，其次辟言。作者七人矣。</p></blockquote><p>另外，关于竹林七贤是否因为经常在竹林活动而得名也存疑。陈寅恪先生认为有可能是借佛经之中的“竹林精舍”的故事来表达出世的理想。据考证，他们的活动地点在都城洛阳以及山阳（今云台山）附近，后来当地可能为了借竹林七贤的名声促进旅游业的发展，所以人工栽种了一些竹林。</p><p>当时流行修身齐家治国平天下，但是这些才华横溢的文人开始却不愿做官，这是为什么呢？</p><p>“曹马之争”愈演愈烈，再加上这些名士的名气和影响力，他们被逼站队才能得以生存。那么问题来了，是站在司马家族一边，还是支持曹氏集团呢？曹爽此时被封为大将军，司马懿则是太尉，选择稍有不慎，很可能会被秋后算账。</p><p>作为老大哥，山涛最先受到“曹马之争”的冲击。</p><p>山涛早年丧父，出身庶族，隐居不仕，刘老师说可能是因为时机不成熟，2个政治集团的形势不明朗。山涛本人是有政治抱负的，但为了自保只能暂时推脱出仕邀请。</p><p>公元244年，他觉得形势明朗，自己的机会来了，终于在40岁时开始了官宦生涯，并且选择站到曹爽队伍里。</p><p>为了彻底击败曹氏集团，司马懿称病不朝，以退为进。极富政治头脑的山涛嗅出了不同的味道，突然醒悟，夜半弃官。</p><p>山涛弃官以后，司马懿在称病迷惑曹爽的同时，积累军事力量、联络曹魏老臣取得道义支持、散播舆论蛊惑人心，家族势力日渐强大。而就在此时，山涛结交了阮籍、嵇康等名士，整日醉饮玩乐。</p><p>公元249年，司马懿发动政变，一举粉碎了政敌曹爽集团，史称“高平陵之变”，以谋反罪处死了曹氏整个家族，数千人惨死，竹林七贤也受到了惊吓。接着为了缓解白色恐怖的气氛，司马家族开始招贤纳士、笼络人心，竹林七贤自然也在招贤之列：</p><p>山涛由于和司马氏的姻亲关系，第二次做官便凭借亲戚的身份主动投靠司马师，从此以后官运亨通，步入了仕途的快车道。</p><p>相比之下，在音乐、诗赋方面才华横溢的阮籍就显得异常凄惨。</p><p>阮籍的背景十分复杂，他的父亲阮瑀是建安七子之一，和曹魏关系密切；同时他又是司马氏的亲戚。<br />被招纳时，由于害怕司马懿的屠刀，于是阮籍答应为官，做了一个闲职。但他尸位素餐，整日划水摸鱼，几乎没有作为。并且他和司马氏倡导的封建礼教格格不入（司马氏当时号召“以孝治天下”，公元258年左右，阮籍丧母，他公然违背礼法，在葬礼期间喝酒吃肉），生活得极其痛苦但又不想过早结束生命，所以只能寄托于司马懿的死亡。</p><p>司马懿死后，其子司马师又把阮籍召去做官。司马昭上台后，为了拉拢阮籍，想要将阮籍的女儿嫁给司马昭的儿子司马炎，阮籍只能用烂醉如泥来应付。天天这样也不是办法，他就主动求官，调往外地，金蝉脱壳之计，但很不幸，十天后又被司马昭看穿并召回幕府。从此慎言慎行、明哲保身、郁郁寡欢。</p><p>嵇康死后，阮籍抑郁而终，晚年被迫为司马昭写了一篇歌功颂德的《劝进文》，成为了人生的污点。</p><p>向秀跟嵇康关系最好，嵇康的死给他带去了巨大的阴影，后来为了自保也踏上了仕途。</p><p>王戎后来做了大官，却变得非常吝啬，跟年轻时候判若两人，但是他依然很重情谊。<br />阮咸后来被山涛举荐，但没有被任用。</p><p>刘伶据说是7人里最丑的，但是他的精神自我十分强大，整日烂醉如泥，在酒中放飞自我，晚景凄凉。代表作《酒德颂》，刘强老师说他是真正的行为艺术家hh。</p><h2 id="嵇康">嵇康</h2><p>嵇康出身普通，自幼颠沛流离。和曹操同乡，其妻子是曹操的曾孙女长乐亭主，嵇康最后被司马昭所杀可能与这个因素也有关系。诗歌、文章、书法、乐理造诣很高，据传还是个大帅哥，史书记载：</p><blockquote><p>嵇康为人，肃肃如松下风，酒醉时倾倒，若玉山之将崩。</p></blockquote><p>他提出越名教任自然，反对礼教，追求自然和本我，厌恶政治斗争，据传嵇康在打铁时，司马氏的走狗钟会前来探访，所谓道不同不相与谋，故意把钟会晾在一边不说，走前还冷嘲热讽了一通。</p><p>当时司马师废掉了曹芳，引起淮南兵变，嵇康也想起兵响应，被山涛劝阻。</p><p>公元255年，司马师在平定叛乱时，由于得病死掉了。随后司马昭上台，希望招纳嵇康，嵇康借口避地河东。</p><p>嵇康以宽厚待人，虽然他的哥哥嵇喜还有几个朋友做了司马氏的官，但仍然没有影响他们的友谊。对待朋友友好，但是对待敌人却像严冬一样冷峻无情，也导致了后来悲剧的发生。</p><p>后来他又多次拒绝司马昭的邀请，但很不幸，嵇康最终还是卷进了政治斗争：<br />皇帝曹髦一直被司马昭操控，被迫封其为相国，眼看分分钟就要被取代的节奏。后来也由此诞生一个成语：司马昭之心——路人皆知。公元260年，曹髦很快就被司马昭干掉了，又找了一个傀儡。</p><p>公元261年，山涛升迁，找到嵇康希望他代替自己之前的官职。两人虽然“契若金兰”，但嵇康依然愤怒地写下《与山巨源绝交书》，极尽讽刺羞辱山涛，他觉得山涛拉拢他是为了缓解自己的尴尬，一起下水就不觉得那么罪过了。嵇康在书里自明心志：自己生性疏懒，阐述了自己做官的七不堪、二不可：<br />没法睡懒觉；喜欢休闲弹琴，出去玩不自由；需要正襟危坐；不喜欢写公务信；不喜欢吊丧；不喜欢和俗人共事；性情不耐烦，不喜欢做繁琐的事情。<br />菲薄古代的圣贤，被发现就挂了；性格刚烈、嫉恶如仇，沉不住气，不适合做官。</p><p>历史上关于两人是否真的绝交有争论：尤其是后来还发生了托孤事件。</p><p>屋漏偏逢连夜雨，接下来又发生了吕安事件，直接将嵇康送入了火坑之中：</p><p>吕巽是吕安的哥哥，对吕安的妻子有非分之想并且给他带了绿帽子，吕安告诉了嵇康，嵇康严词谴责了吕巽，但为了声誉，劝吕安隐忍不发，事情就这样被捂了下来。</p><p>吕巽和钟会关系很好，为了报复吕安，他向钟会进献谗言，钟会很可能为了牵出嵇康，以报一箭之仇，不久后就抓了吕安。嵇康听到消息后十分愤怒，写了一封《与吕长悌绝交书》，之后只身前往洛阳，去为吕安辩护。</p><p>吕安在流放途中，给嵇康写了一封言辞激烈的信。大意是说天下大乱，自己承受冤屈，他要改天换地。这封信很快落到了钟会手上，钟会终于等到了机会。</p><p>吕安事件由此升级为谋反罪，嵇康被当作同犯抓了。司马昭本来就忌惮嵇康，对他的不合作态度怀恨在心，但对于是否要杀嵇康也犹豫不决，此时钟会又站了出来上纲上线，说嵇康上不臣天子，下不事王侯，私下又罗织了几个理由：他说嵇康是人中龙凤，并且当年有起兵谋反之意。</p><p>欲加之罪，何患无辞？于是吕安和嵇康被关入死囚牢房，等待秋后问斩。</p><p>命犯小人，嵇康入狱后，有几千太学生为他抱打不平。他也在狱中反思自己，写下了《幽愤诗》，觉得自己虽然心地善良，但却没有识别坏人的能力。</p><p>临死前将其儿子嵇绍托付给山涛，有人说这是为了缓解山涛的愧疚之意，山涛接受了嵇康的托孤，把嵇绍培养的很好：</p><blockquote><p>巨源在，汝不孤矣！</p></blockquote><p>就在行刑前，太学生又请愿释放嵇康当太学老师。司马昭看到嵇康如此的影响力，杀心更重：<br />公元263年，嵇康与吕安一起在都城洛阳被处死。</p><p>据记载，行刑那天人山人海，嵇康顾看日影、神色坦然。</p><p>嵇康找哥哥嵇喜要了一把琴，嵇喜果然随身携带，而且嵇康的弹奏要求竟然被同意：<br />在刑场上，他平静呼吸，调整琴弦，弹完了最后的哀歌《广陵散》后说到：当年有一个朋友袁孝尼求学此散，自己由于吝惜，没有教给他：</p><blockquote><p>广陵散于今绝矣！</p></blockquote><h2 id="reference">Reference</h2><p>同济大学的刘强老师是魏晋史的专家，百家讲坛和上海图书馆系列讲座中都收录了他的精彩分享：<br /><a href="http://tv.cctv.com/lm/bjjt/index.shtml#&amp;Type=0&amp;Y=2010&amp;M=10">百家讲坛之竹林七贤</a><br /><a href="https://www.bilibili.com/video/BV1Zt411d7Fr">竹林七贤与魏晋风度</a></p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> History </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bomb Lab</title>
      <link href="/2020/10/04/Bomb%20Lab/"/>
      <url>/2020/10/04/Bomb%20Lab/</url>
      
        <content type="html"><![CDATA[<p>给了<code>bomb.c</code>和<code>bomb</code>二进制可执行目标程序，<code>bomb.c</code>不能直接编译和运行，只是有一些提示，但是程序大致结构是：有6个关卡，每个都需要输入（stdin/文件）一个字符串，运行后判断是否输入了正确的字符串。我们需要反汇编<code>bomb</code>，找到这6个正确的字符串。<br />我是在Amazon的云服务器上完成的，64位Red Hat。</p><p>第一步把汇编代码扔到一个文件中，方便调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.asm</span><br></pre></td></tr></table></figure><h2 id="phase-1">phase 1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  400ee4:be 00 24 40 00       mov    $0x402400,%esi</span><br><span class="line">  400ee9:e8 4a 04 00 00       callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:85 c0                test   %eax,%eax</span><br><span class="line">  400ef0:74 05                je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:e8 43 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  400efb:c3                   retq</span><br></pre></td></tr></table></figure><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br />我们的input作为第一个参数存入rdi，第二个参数0x402400存入rsi，传入函数处理，<br />调用了<code>401338</code>处的函数<code>strings_not_equal</code>：</p><p>在400ee4设个断点，看看402400里是啥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb</span><br><span class="line">file bomb</span><br><span class="line">b *0x400ee4</span><br><span class="line">run</span><br><span class="line">x/s Addr// 显示内存值为字符串</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200703101513705.png" alt="在这里插入图片描述" /><br />为了确认这就是我们要的答案，再去看看调用的函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0000000000401338 &lt;strings_not_equal&gt;:</span><br><span class="line">  401338:41 54                push   %r12</span><br><span class="line">  40133a:55                   push   %rbp</span><br><span class="line">  40133b:53                   push   %rbx</span><br><span class="line">  40133c:48 89 fb             mov    %rdi,%rbx # 第一个参数(地址)存入rbx</span><br><span class="line">  40133f:48 89 f5             mov    %rsi,%rbp # 第二个参数(地址)存入rbp</span><br><span class="line">  401342:e8 d4 ff ff ff       callq  40131b &lt;string_length&gt; # 用rdi的值调用string_length</span><br><span class="line">  401347:41 89 c4             mov    %eax,%r12d # 返回值存入r12d</span><br><span class="line">  40134a:48 89 ef             mov    %rbp,%rdi # 第二个参数作为入参调用string_length</span><br><span class="line">  40134d:e8 c9 ff ff ff       callq  40131b &lt;string_length&gt;</span><br><span class="line">  401352:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line">  401357:41 39 c4             cmp    %eax,%r12d # 比较两个字符串的长度</span><br><span class="line">  40135a:75 3f                jne    40139b &lt;strings_not_equal+0x63&gt; # 不相等跳转</span><br><span class="line">  40135c:0f b6 03             movzbl (%rbx),%eax # 将rbx地址中的值(input的第一个字母)存入eax</span><br><span class="line">  40135f:84 c0                test   %al,%al</span><br><span class="line">  401361:74 25                je     401388 &lt;strings_not_equal+0x50&gt;</span><br><span class="line">  401363:3a 45 00             cmp    0x0(%rbp),%al # 比较rbp地址中的值(待比较的第一个字母)</span><br><span class="line">  401366:74 0a                je     401372 &lt;strings_not_equal+0x3a&gt; # 相等跳转</span><br><span class="line">  401368:eb 25                jmp    40138f &lt;strings_not_equal+0x57&gt; # 不相等跳转</span><br><span class="line">  40136a:3a 45 00             cmp    0x0(%rbp),%al</span><br><span class="line">  40136d:0f 1f 00             nopl   (%rax)</span><br><span class="line">  401370:75 24                jne    401396 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line">  401372:48 83 c3 01          add    $0x1,%rbx # 指针+1</span><br><span class="line">  401376:48 83 c5 01          add    $0x1,%rbp # 指针+1</span><br><span class="line">  40137a:0f b6 03             movzbl (%rbx),%eax</span><br><span class="line">  40137d:84 c0                test   %al,%al</span><br><span class="line">  40137f:75 e9                jne    40136a &lt;strings_not_equal+0x32&gt; # 跳回循环</span><br><span class="line">  401381:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line">  401386:eb 13                jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401388:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line">  40138d:eb 0c                jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40138f:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line">  401394:eb 05                jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401396:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line">  40139b:89 d0                mov    %edx,%eax</span><br><span class="line">  40139d:5b                   pop    %rbx</span><br><span class="line">  40139e:5d                   pop    %rbp</span><br><span class="line">  40139f:41 5c                pop    %r12</span><br><span class="line">  4013a1:c3                   retq</span><br></pre></td></tr></table></figure> 所以这个函数就是比较两个字符串是否相同，先比较长度，再比较每个字符。故我们的第一个key就是Border relations with Canada have never been better.</p><h2 id="phase-2">phase 2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:55                   push   %rbp</span><br><span class="line">  400efd:53                   push   %rbx</span><br><span class="line">  400efe:48 83 ec 28          sub    $0x28,%rsp # 栈指针-40</span><br><span class="line">  400f02:48 89 e6             mov    %rsp,%rsi # 栈指针作为第二个参数</span><br><span class="line">  400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:83 3c 24 01          cmpl   $0x1,(%rsp) # 检查是否相等</span><br><span class="line">  400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt; # 相等跳转</span><br><span class="line">  400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:eb 19                jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:8b 43 fc             mov    -0x4(%rbx),%eax # (rbx-4)赋给eax</span><br><span class="line">  400f1a:01 c0                add    %eax,%eax</span><br><span class="line">  400f1c:39 03                cmp    %eax,(%rbx) # 比较当前数与下一个数</span><br><span class="line">  400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt; # 相等跳转</span><br><span class="line">  400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:48 83 c3 04          add    $0x4,%rbx</span><br><span class="line">  400f29:48 39 eb             cmp    %rbp,%rbx # 是否比完了6个数</span><br><span class="line">  400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:48 8d 5c 24 04       lea    0x4(%rsp),%rbx # 栈指针+4赋给rbx</span><br><span class="line">  400f35:48 8d 6c 24 18       lea    0x18(%rsp),%rbp # 栈指针+24赋给rbp</span><br><span class="line">  400f3a:eb db                jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  400f40:5b                   pop    %rbx</span><br><span class="line">  400f41:5d                   pop    %rbp</span><br><span class="line">  400f42:c3                   retq</span><br></pre></td></tr></table></figure><p>第一次是1，第二次是2，4，8，16，32</p><h2 id="phase-3">phase 3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:48 83 ec 18          sub    $0x18,%rsp # 栈指针-24</span><br><span class="line">  400f47:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx # 栈指针+12赋给rcx</span><br><span class="line">  400f4c:48 8d 54 24 08       lea    0x8(%rsp),%rdx # 栈指针+8赋给rdx</span><br><span class="line">  400f51:be cf 25 40 00       mov    $0x4025cf,%esi</span><br><span class="line">  400f56:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400f5b:e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt; # 返回值存入eax</span><br><span class="line">  400f60:83 f8 01             cmp    $0x1,%eax</span><br><span class="line">  400f63:7f 05                jg     400f6a &lt;phase_3+0x27&gt; # 大于跳转</span><br><span class="line">  400f65:e8 d0 04 00 00       callq  40143a &lt;explode_bomb&gt; # 否则爆炸</span><br><span class="line">  400f6a:83 7c 24 08 07       cmpl   $0x7,0x8(%rsp) #(rsp+8)即输入的第一个整数与7比较</span><br><span class="line">  400f6f:77 3c                ja     400fad &lt;phase_3+0x6a&gt; # 大于爆炸</span><br><span class="line">  400f71:8b 44 24 08          mov    0x8(%rsp),%eax # 输入的第一个整数赋给eax</span><br><span class="line">  400f75:ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8) # 跳转8*rax+0x402470</span><br><span class="line">  400f7c:b8 cf 00 00 00       mov    $0xcf,%eax</span><br><span class="line">  400f81:eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:b8 c3 02 00 00       mov    $0x2c3,%eax</span><br><span class="line">  400f88:eb 34                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:b8 00 01 00 00       mov    $0x100,%eax</span><br><span class="line">  400f8f:eb 2d                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:b8 85 01 00 00       mov    $0x185,%eax</span><br><span class="line">  400f96:eb 26                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:b8 ce 00 00 00       mov    $0xce,%eax</span><br><span class="line">  400f9d:eb 1f                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:b8 aa 02 00 00       mov    $0x2aa,%eax</span><br><span class="line">  400fa4:eb 18                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:b8 47 01 00 00       mov    $0x147,%eax</span><br><span class="line">  400fab:eb 11                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:e8 88 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400fb7:eb 05                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:b8 37 01 00 00       mov    $0x137,%eax</span><br><span class="line">  400fbe:3b 44 24 0c          cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:74 05                je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:e8 71 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  400fcd:c3                   retq</span><br></pre></td></tr></table></figure><p>400f51将地址0x4025cf赋给esi，作为第二个参数，看下这个地址有啥：为了方便，我们把前面问题的答案仍在一个文件ans.txt中，<br /><img src="https://img-blog.csdnimg.cn/20200703164446264.png" alt="在这里插入图片描述" /><br />输入是2个整数，第一个不能大于7，基于第一个整数（0-7）跳转......</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈我的理想</title>
      <link href="/2020/09/26/%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%90%86%E6%83%B3/"/>
      <url>/2020/09/26/%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%90%86%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1dbf4ebdec66af821fb9de08d6a93d605776b33e39b7e9da59fd60c000aa5108">c172f4ee74b2b6d246b20cbfdc0b877ea29f3f69224a35aa384277b5b4b094121c176dcf6723e0e2bffac0b86f04ba6313d1d5425b08e889b5464fdf6edc014eeed8d599d14a5cbc488603a649279abc916b631dbd8940fe96ddbc4d103d26ffe261bab7c81321b4ef21a3f6aa75626ced8241325b4366aa3de5e8a9ba7b742058d4ad6746b578ac3fd90c56aa4ce3e33a704cfc235f2863b6bd60f3a1e774a6a6026905c46404b6df1d917e22efd3bc9aff7682dfdac4a319ecf696218dee6c2696e531c1b6124ff53a1ca1eebbc1b142f4de2286261e149bdf72fc346fe5c67fdf7b0ac914dbf912f531fefc9fe224350a54e3dae04960e771622691b0eea4519c12e75a7c5ddcfebce0ae292548e484947780424257c30a631ae83d176688d7a1d43d7a8ae59382ca91ccfcb755e377bd9ee92125ee166043d924191e90f1de213ed08a3089a7af5214cc83f980435cb72e2d5e173373be25db54216855c8547619e3db9f13fae09b345c3c29d775b05b6c72f75fdde9e3b9ae3fa7c99f7fb76dcfcc78dfecb0005fa53b460ddd11dc7dd4ffb137c4cac8bed3964782f2ea3f141f6b1c9455420bae2beb28886be347b41e63ae21f57e4efdf0dbaeff9b89381684602a353bd24b376021ae4fe0ee0940f0bc3b5e17b7105292b971a2d0f4a56ba03a02989dbf2c3ae8f0ed8b54d0db63d9dcedc854927c5ef7db9ef6f6a3e66f7e27d3ed38bf087b308249274a85aeaaedb03bf928463786e93c8ba1210ff05dec1d3930d053d0e3d49f67b147288b5727cea05f08d4120a7692a2b83ee000f14d0f0f81b182e4b1557495103f038c58ac6dcf83e91a98a8a75c448727dfd1831e637a1cf07cbad4c26add4d6511867defbb3b53158da36b1ddb302b8cd5b48446ee63b372de81d9b7b442cb023e09c09517b518fe25bddacef171d599c05e7135be56aa67177a8b0b72f0b1028693c544e74c7afd7231d185e5be1a30dbee0887afc34ae8d869a7856a4fbbf70ebfdb9bc0aa9a3fc493ac649134693ba39ecd71a80c7c63f0051570e406478fed168391d6ece24d6a2e6bb007cea59232313464ab72b0cad86b7b4f8349195c8774df177845620e05b72a182c8702235c66be78e904391e9ffe6c6c4c28089837f36290fd06c1825d92e47106691db45dc73a1261cf89b80ebd61283196203e2c24658ef1aa658877ac286e2221aa2b7c32c41d1ca562dbc96b027cc61226f34fb0a5d883485a1eed46a566a1bd545d9af2db0dcdde63caa6f050a8938d38b4ebc557995aa03ab4f79b03d823b5eb7dcc1d15f6cf1421e0368e16c7f3289fe0571b98cd750d1fb911792573ef0ebbb5340682d9835a4ba211f3040ba336605b6d3af9496afdeda8718809be3ea752f13a0e5e4c568855070e1034e2307c5d3da08c7f4e7ed085fea1b00ca5c08ec99ca4301499a1c53665832188612995b9f9a604c8acb7af78f7d0d88ce6de931271dd364ff892ba6fe6f43b0073c58797982ab7bfb8ffdf141250c6857e44bfe7f91d5c4473d2453c7141f1db0e1403b836b13cf5b3d035c642f3274c78ab17620ecb4d898a43b9064b8836dd67721f64f951307dd1c1b8ce2ba73e919951a1382f9a8ee307eb0a184a5d9b94ea8504e038b7d48ae0b527026edc129725d97bc92e25bd8438250ade74d101ca9b16f23766b78d5873031e1fd7b46ad9651626c815d8805983e9a70184ad1dc9dd5d09eb80a957fbd22bc2640705593ce4f11cbd10d32bb67aa7f38c2929b507e3891a9afdee69439e1c0b34f572dfa85740dade2e25d0aa88768231ac1a923bc961f130f91a184c0a291d86be051bd8767387354ac4eb1c9de2d1fab97566f874ed046597a78cd79b4d3eee9a573d81b1ed792bc934a41696aeb83bf319d7e5b778e2cb18cf52845cd4a9abaf5741ccb1fc720f7a8ff03faaf5f508198f242a93ed662097bfaa000f677b1356b44e52400dbe8877265eb12e992c765fdbf7c390b7b7e7a262c785ebac8af2855e769119aa8c36156b713439a86fd6d216d3d5b51d5dd1d8dcf1617573d80a491a650763e83f62cf21997c2e92cb4ddc9bded9a5e748167853011b1a0403bf5c00d447bcd76f088a275637aa01c389674fcaf193d2708d039129d5a8eebc7ebe5fcda9ee3606e2fffa9e4e866fdbcd4a04f387c3db8a923d0dcefca79aba2f2b47ceb8b5c640e9837908fab5d9acefa4809478d990803370b5cf770b156119f3b88e315612a7253fa11d833f311bcd3bcf408150f94b29674aaafba9bf80fd892d613cd7e0c63cbbd8631d8baa1743c69b485347644bdaca7dd9e1db6cfb4d9c7c387f589efcf68d9dfa509eae4ecbad08efb70d5a138c68ad154ca5dbcc658cbb363652634964090a76099496ddc9ef8ff97eece1c6e5f7e3bf8654d4dfff26473f76beac4a703f5da332cd38b5494d0f4955edde0b9aac848c94f2ccc6ca17bbeb69fedc5014031fbdfa9da0fc19082b3ce1b78d719197c378d2a253c1db63622cd3a56e8a49f264787c547add32d1d8124ce0842c077b57abed209b9683d7060a777b35a4c285664a41b8c54bb1c1fc4c4c1c03a01996855baf5bc3f8fed7c9b8ed90ebdc1a324252dbbace238bd12675166ae383f4f397747f69291525e938c8a2c301351d072c03ba47c6c063abb77391c77847e9c86d766a335ec76dcb91f55efabccdc679674b81919c1bd19b58a93a56cdc0b26af0fb534711f42c829ff7f810ca3352869b69a7a319b8ef57ad6cf626a85195cded09af361cc610d319e397ed5032d7af4a5fafd86b9ed98327dc6dd6d745d73757af5ec9da7950592058189109d9496d620b3162910d6335cb779b9cf25ced804280c15485564cf524f9b0e6fd19067093203da1806f9c6f626f294f083e5713ac3b621e0c9ce39fba1bb1619faf45168dade966d46e380ea0b813a45d5fe117f2e43d748b4f8e07029228004f14249f9bb2460ecfa1a4cd26caab4c68b2d6ff258e6fbab3561fdd53541266478f1fc7290175f57fd4df0ddae6e068adf9f198f2705f59ead280422ba928a66ec399c1904ae0030a4d2097f4b0a71ddbb4118fc4ec365728d3a1f08b4d53c43ff2515b19a463f75fb6f140743f0fdb17be1a5a7534a22cd4728b36606983ea1b583d7681752b5918bab596b96542c42f724614a71efe8e634e67ac6f98adcaa9230fb305befbf86297c9919c3ace18d8dc52104e574b40576224fdb8522b632327e19dc2885ab3100af2f5d1265b53ac053be8d1380a8fa1e1c9587f59e6cdf54e725d10d4082f7474f48f809756ea96b4b28e9ba2fe717f72731812d2bce43e41c6cf675290713c5eb4cde96c54b1d40ca988ecff82a524130df707b10db224bfd795639d06db8b5572ee001327f7da709d39b86141f02f5a2845c7fbd530262668feb227cdabb91bbeb13e38c1f6bb4415b379808348767bed0d647012cbb6f965d4964e554c43e4867fde6708a63621d147916a47cbc5b0b3ee5ac1b0bffbc2d22e5ac2553f2c9fc46776d714f52a82dc2ebeb4b9c38b09e27e6c1ddbc318ae593a065b9fadd9a91d12a177fadb02da8b7727407d93ca8222906f276974823d630d69a5a712e684e4bb4986a187c666da4fbb2fee9f77bbff598683acfdd079c371b17abff99b12689ae773829f41ed546a12f0527d7259212475c707b85417fbec47a0eea9f65784d019cff943b52b9374609a4bf8b48c67028c515b210cbb9c73aaf656baa8c37da46e772d18578d6cc293b5636b061d5155dd3b143b551856c5bb074ef1ca079b8061097d89b622b9274fcbf1e9aa75386a6e948df5af02afa8fcf78331e9eab7b79f886405b33c5adffc3e71b68625dcf139df3c187c21f76d783678724312a721abf0a6b208b19b51ea386375d9e0ac7857b686095a1a0bb133c8737712722372cc53e53a7d21fa7f2183630aedf1c097d5b18c325c2a9925ef635099fa0b6077c609fb2302d8f553ee6f3701754d765dba8b4ed85d9a7f59bd8aef9c9ee5b7f993a36e2e6d228744b136f0242fc453fba7b944a1ae37a1e04fe4470dc03610820cc44740f79b0e68207653889f93559195f19b11c87b1ece5b84e690e4cc639025f19712716d194af48552aa9d1ac283f2e6c5b66b22ecc0b7612ab6c2aead4fcfa380254ea08bc41e8ae7730f4c71316e22d8fa6ea45d4132667062ef9ee3851a25fdf5211c4e8d642989ec5045fd2d3083fd6ae5200030470876ec65b0e139ab9c847e441a09f36443465195d1b8b9adc1b01a7e5d905223f872eee6877d1c6176657730d053dd8cca63def83472488fddfd9fabcdb4301e0fb0d1d7f2c2ed55f6e21de3cf49c19d67a0a98962da3f589e30cedaeed691bda420ab34f981a8bcbdc984e1c7a621c5ff09ea2c3893259b0113918c6ecdb31a4556ab30d8d2fb2d8b2f11044cc849d0778b8f55153218361271a5ad1f46498f403b6879631564e32d072898c29ad57f874bb2e341d456a643a430ebc21b9f1f843a48ebc98394884ed28ff2abb13c8bd47a497d39c5ddbfcd711546c35ad1329d888b24fa5f17b04a8645172e6657dd62ec7dcdfd46a483630826f91f9a68fd267072ab5870548610e8ff073e6a1c60a9f6aa1a2e136b500884ac7a7b8932245cf6f6c86f2e4d85ce6fc00a595759ec1047777f0fff0555fab40b0aa587483a052aee073c8fb4d907b8b48b0e165c9514d710631a368169180c47584a3318eedc8be0604e2d9fa230b8a91ec2824b4e57985abfa5566bc77825cec6176fea29aeefe005a624a4ce5501186ddfb89b9e1a6d0fa58e93c221c89675bc5fbd69a043601f0b4e8b09a4719e10ca6147e61dd09dcc65f8bee239fc2970a4cdfb11de35be4e186520de842a7acf608cd649f05928b3b6ef5a0837b08cb5e6a5f5ed192f2aff915e807ba1438d58f5ec27b2de3f710db27148cdcc42ceda9bf43a0e899a58c02e8b9ac39349c2694c5880c2359ce6cba04d3dac7d8aca83b3ae3545892aac9b96b6dba66c4b2c9e59105e5ca68179235ff457e488415aedc88af823ab996eff7ba732191cccdaab071824980e4bbc0af2998dadeff9d9f53ebd78423bdf01355ab757005cfc793ef3727ea17415f9aba9d8ff1a90ec93056709faa6e5a2140c3e677d69534bb7ea6147859b4fe177f8a75cce84ab42fa2a81104a2e303dcf316aca1c7976d122d0cbd4f571335ed792efc6e189262e3567be1f267ca5711156051e06c42ac520dcb3b9d063b7af8bc13b97ebf32f35d0e444b6cbc76ce322fe88045ba862477620925edadda6731dd9218c26111406496b487a4f410d1f8bcfa84e56c23aba2e38db102f12377def93be34277ea1fdff22f53c7f0fa9007040b439bdafd130801bb8eaddb739444bfdca636681897af309854a428430b9dd3a82049660c9151f6de8bad6938b90ea1bc7e8f12e2033473fbf018a9be5482c6cd33fbac27ac0edb01c95a5a579ad258077e94bf59e4d74b02089d86115b1a89a2320c6fc159062884cc0008db02551331ce28abdf5893f046cbc912545bc41b5acf06286680ce50cfe47579e5bd199077ff856e800658e58d901f51a26ae1b241612d64ec59f214108800a1c56d4a69cb3c7c0448a5c25180d87ddaf645cada4d1a5d60bcca3f0ae1c8b3e226a5cf71a2be16b34f253e6a9acad43abb0fd158fb2792a3afdbab5430d6e9fe1b9a4c9cdaa1b9a709aed79f17bb77316f41ebaeb4218e7db20c2fc0eeb0eda6397cb41e9a6181434328fef2de58b5ba699a61aba73ff956d070883ba4d89f9d51e9708458961293029985698bc26ab4e5a2d848ff69f3f0c526bda6bc5352c3d53852c5f70fddcbe8ff24cd1233d41dd7d9a760153a3d381f401f75301823a4acba2b4a72ea05acbacda0d19b003c959e88362d2aa97a938f166c0bd5961bdd98edf5d3349dad54f1744564f6f02315a6df5c12436a535ef1548d58d95ff76c2d036a345d3174b3cb1a3a336ba4f1a50c45c15064e8a701f2eb0f7fdc1c6d931e84fd9e0256024c688dd68ac935211c066e39ac3cddd2d6b7ce7f8cf180867462761cd2960abf7c2b46a017dfdcb07d9d229613082556e1effd1715d4bd8fb660016da45480984aa2b3712926a6f97d438bf3f6e82f2cab09e09c5073509dcd43f7cb8f1fc9447a848536e6a43aa3e70e4c73fe2ccbdb4ec629c25327f123c914be7bbfe0a5a93e335d3bd97c5f72b43550ae93f71a58d156dba4aab3ce168e62295ba2d4388377e045a1728c621c946ed6ce2fc3c799a47274f3fccb68c333a04ee7a5c69e34db0c9767e75f74fe869d5950a3a89f57c23130ea4fab792b2284654720dcb577f6d551b7204e8c128a78606559855ff251c6fb0fb993247b792b46d289581014817cc1d09cef5f573fcfbd7958d39e800815b79fbd7420e65e888ab0a83564f540049c61f69d41135a415bb1f3e0fdb380b7c4c0e392c1f11dee9fba62daf05d3b8cad65cd293601385bbc0540797df349cd3258c07b4e06a86fa3472f60a92e26e0c33745ed39cecd11cea7ed4d3b37069803c8e4efeec6cab437ac714a00576da0b17ff06e691833baee6fb69e664bd6ed9b77a45ad612314b50a9167941a9de133ea0ddc1e16c482441a79ba00c3b201c123a1d4f23b22c9e971f24118b20c0b530ee169e0909360687173ac5386a07b8bcdafcb859ec35a3c8f6c9ea98a55adef27e84afecf0b494e0cf7336568a2a5dc1515c0f09e0c69b0c1f594049949a12f166c4b1fb885655b0d3bfdae21bd73e1627eb019caa83013ccb38911b83ba7e2c1f68c0b3583f58834f845bfac08bf0699ad4ec3d2f099da3057d5bbee4a24fabbde9ec92ff32d005083f69f07bfae04fb7ebdc5a490f22983b10cc46b588eac2c94c167a9aa5b699fc405e3d6d3aef08cdd55529b89f35e1c758463423792af1735640cc4bbd9b7acb53c4a414e2968e8b8e07539bf7b7cac58311078ae3789ae522cbbf00bb0d20a83d77f3e74c8a476e4f2b0a3b00110512b47879b17363ee10e1b6cd87edc08d5fadde52370a7b9c102a7604e32527af7460ae0fbbd71b9792f036ab65a282f8cd18f152e55e743512a81dbb8555c40b19e921203b9c8387c31ad28fb13bd24b15f321f58914b8afbc5eccc2389edf3c45cd22e37e86dfd4db54138596547b557bd0579868ceda15308140b0648d2bfcca013d5e4bc6560b78f9820d41597d9a20fe30cd41c0817ec5df9e78ce41ce14fc5c14ab9ffa4d74e5c04a55c7b25e115fa80905030985a3d77f6c681bbf2495fe359faec0e40d12d3d119a9a572b9c7444b569f1a9f1aa598b932f2bbf0b23b1f0c9d2a4d5807d0f248a198160226e821a47f16f3281f94f594ffe02e9c9c09e427a2de485a10db1221be211045b8644b378d0ec55e1d6bc9366def971fbae9d70305feafb16e6ce11ed1d34a605f546c1642c90ae12c2dad2605b58aee3ef197f298586e74657688f3a45fb2f3eb679833067c831a4ba4da8e2476074752a9ac073dc6f95f0df1ac675676877259015240bdde171bdac4d8487efa3bba7b107212643f02b110c971c3b178a13b16743f9219b1ad2d66a220c24c2e4529376bc20715a9ef935154b60d07e733286b0fe83dc79229954e566e639b97320cb5e4db9c07197cdb36e5740d01e4fcf657d08c3a663454a100b58cbd7571e1b17042dd3b8d46f718f61b69f2d4b41f805aec3fbe6582f9d91ea866ad7a2f73b96dbb18558d6bdc56de2f7ce7bee602fc12bb2aa788e4ba421653dd5384f5276eda3adc69f4a6d14b5fea416ccc161f4dc3b11cbfc399dd7063f714dc9811f7ed12f3370b166d69a69fd375674f4932151c2880a6592c1bb75734f393a86bc7fcdf3bab6da536bece744b38c73a70f4105f60d343d116a6c9a0083c7d838890583262f965ad901129012acf0735bf041802f8070e147bedeb151b80faca47fed86c9562a5f01f75262b52b8d9f61a53ca7a7f155926c610402664e7b24a24abe306a71ead8ce71dfb0ad3e12a55794156e4e08fda4d16edde03197dfa1e6736b0febead114fbfbafc83668352323c837b19ac19553a11de4dfffed26a90a747bab87dbefbd628daa7fd40650d36c95afdb8b13e866e565783aba01d13427b4df9b25811020c34e2ee9ac4188828e72e25d46d065659fd207fa448391aa5d157a85336c482ebb9f3e94a0885c7230c28b0b6fac24a52c3639daadc1fd1e95f605cd901efc5e16b7d2156c43347ccff7fb878b39c87f5a15dee25efb7b1aa52fd5f0c3a8d04bbe6f97a4018aff35fbba83dc1d529b7960718b7ddbf91213154cfaafad87c0e31ebb42df7e68a0613501ac54095fc2dc91edc09c04529f902486c890494a2ddbf7fcc7aa52235532cb7d3ca592f3be415ea94d8515a10b7cd42fa7fba6efdcfe9512defeb3bf24bf1cc7f2d140c4e9b28408c0cd31938528c4527185612d186f08231b3a1d2b14584f8fffe9be2741acd138d49b1239bcfb1a7724df9ad38855f68b5c73c54bfab7362a297da16f7b24583efeeb61a5ddff8e5064483e77fcb71bb0d12d0688aab9cb28089567a4066f595f3e8f0d027d5f271bdbb8cfe9c0c5747e2da8ce8099c968cbaa32df057b7dd643a5a68739530cfe60bca7ee40e7a609be5bdcd0c0c1bbd80417a03f4330be992fe24fb53bd06afd554b9b4659a36f675b30adf81d2b2d74919b2b8c4ef3315fca885558b78175049032edea1d1c132573d14713983e39235885c8a80ccd1c7b9ae86011cc619f632c5bc5738e0118f80ada3353b983f153bed3bf8a6bd53996db692d602b7f5428d47233ab11eb46e69e5fe097eee12e9dcefb23a3e9b68afb29da2fd532844a4872d41f2cada42d3681a494f36e8bb630d8b8f64fbd713652321dd1cda6ef7edadf201f7fc746cbf73899cf6d232720441185822ba50711a1e13a30d423a19bb76aa74479ce1d4fa03f03683766680ffa6ac89bfe5e936dc92d5aef16ad229fa5c64a0a1d0c8541c82661608e4ccc84269003142bb874bca95949b94ae13ae081b0e539f9b73ef2330a21f4fcaf40459c8931e23622ee1a7a47f661c13b1d7bc215137eb0344c51978522546a31010719270d40d5f28868840377993d239d0bddabf7e0d8a5d3b26d9a68ddc19bb28f07771da1ad97e55d7fa2887366f3daa84837a207359925d081f08a6851a72ad5265af3ac44b2dc0c3bcf171acd592bef863cc05639f7d806a8612f61084c8207c00d674ff61990d869d555e2183708f417ac0138992e885841dc21bd94408ed3251f6fd1c1f7ba7d09f4b17e900c94c46d1aedf5dd82ff7f60c01ed713c45b77453eb28415</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Operating System Engineering#0 Booting a PC</title>
      <link href="/2020/09/16/MIT%20Operating%20System%20Engineering#0%20Booting%20a%20PC/"/>
      <url>/2020/09/16/MIT%20Operating%20System%20Engineering#0%20Booting%20a%20PC/</url>
      
        <content type="html"><![CDATA[<p><em>最近在学MIT的OS课程，lab绝对业界良心。<br />XJTU的操作系统课就是写一个系统调用，改下进程软中断通信的代码，代码量不足500。。。<br />MIT上课用xv6来教学，lab是做一个完整的小型操作系统JOS。</em></p><hr /><h2 id="配置环境">配置环境</h2><p>虽然没什么技术含量，但是这真的是令人头疼的事。附：<a href="https://blog.csdn.net/eye_water/article/details/80638463">图文教程</a><br />需要一台x86机器，一般的Linux发行版应该都可以，可以使用<code>unabenlme -a</code>查看，如果显示<code>xxx GNU/Linux</code>就行，MIT的学生可以使用配置好的远程Server。<br />本来打算白嫖下Harvard的服务器，但是没有<code>root</code>权限，只能可怜巴巴地在Win环境用虚拟机。<br />平台：Vmware Player15，<a href="http://old-releases.ubuntu.com/releases/14.04.5/">Ubuntu-14.04.5-desktop-i386.iso</a></p><ul><li>检验编译链<br /><code>objdump -i</code>：第二行显示elf32-i386；<br /><code>gcc -m32 -print-libgcc-file-name</code>：打印出/usr/lib/gcc/i686-linux-gnu/4.8/libgcc.a</li><li>安装git：<code>sudo apt-get install git</code></li><li>下载qemu<br />建议不要作死，安装MIT Patch过的版本：<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code></li><li>安装依赖库<br />官方说要装5个库，但其实libtool-bin好像找不到，不过不影响后续： <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install libsdl1.<span class="number">2</span><span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libglib2.<span class="number">0</span><span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libz<span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libpixman<span class="literal">-1</span><span class="literal">-dev</span></span><br></pre></td></tr></table></figure></li><li>配置qemu<br />切到qemu目录，<code>./configure --disable-kvm --disable-werror --target-list="i386-softmmu x86_64-softmmu"</code><br /><code>[--prefix=PFX]</code>可选参数是选择安装路径，这里就默认在<code>/usr/local</code></li><li>安装qemu：<code>sudo make &amp;&amp; sudo make install</code></li><li>下载实验代码<br />根目录下新建6.828目录，切到该目录，<code>git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</code>，切到<code>lab</code>目录，<code>make</code>就可以了。</li></ul><h2 id="pc-bootstrap">PC Bootstrap</h2><p>物理地址空间：<br /><img src="https://img-blog.csdnimg.cn/20200523082913317.png" alt="在这里插入图片描述" /><br />以前的PC内存只有1MB，Low Memory是PC唯一能用的RAM。VGA Display是VGA缓冲区和固件，BIOS以前都在ROM中，不过现今都在闪存中，做完系统初始化（PCI总线等重要设备），寻找bootable设备(硬盘)，读取boot loader加载OS，将控制权转OS。后来内存远远超过1MB，可用的也就有Extended Memory，不过为了后向兼容，还是保留了Low Memory，这样可用的RAM就被分为了两部分。如果64位系统，那么内存更大，这样为了兼容，32-bit memory mapped devices还是要保留，就又被割裂了。</p><h2 id="the-boot-loader">The Boot Loader</h2><p>硬盘的第一个分区存放启动程序，包括一个汇编文件<code>boot/boot.S</code>和一个C文件<code>boot/main.c</code>，启动程序将CPU从实模式转为32位保护模式，通过特殊的I/O指令读取内核。</p><h2 id="the-kernel">The Kernel</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Proxy</title>
      <link href="/2020/09/04/Web%20Proxy/"/>
      <url>/2020/09/04/Web%20Proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>Web Proxy是浏览器和服务器的中间人：浏览器访问网页时，将请求发给代理，由代理将该请求发给服务器；服务器返回结果时，先发送给代理，由代理发给浏览器。之所以这么做，是因为可以在Proxy这做一些事情：</p><ul><li>防火墙: 比如伟大的GFW, 访问国外服务器必须先被GFW的代理审查一波</li><li>匿名器：代理可以隐藏浏览器的信息，使其对服务器匿名；</li><li>缓存：暂存服务器返回结果，加快访问速度。</li></ul><p>本项目要实现一个简单的Web Proxy，支持以下Features：</p><ul><li>中间人功能</li><li>并发</li><li>缓存</li></ul><h2 id="background-knowledge">Background Knowledge</h2><ul><li>HTTP/1.0 GET<br />当用户在浏览器输入URL<code>http://www.cnblogs.com/EIMadrigal</code>并按下回车后，浏览器会向代理发送HTTP请求，请求行可能如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.cnblogs.com:8080/EIMadrigal HTTP/1.1</span><br></pre></td></tr></table></figure> 代理要将这个请求解析为主机名<code>www.cnblogs.com</code>、端口<code>8080</code>和路径<code>/EIMadrigal</code>，之后代理可以尝试连接<code>www.cnblogs.com</code>并且向服务器发送新的HTTP请求，请求行如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /EIMadrigal HTTP/1.0</span><br></pre></td></tr></table></figure></li><li>Request Header <img src="https://img-blog.csdnimg.cn/20200726153711559.png" alt="在这里插入图片描述" /><br />请求头可能有多行，每行的基本组成就是头部字段名和值，需要注意的是：HTTP请求的每一行都以<code>\r\n</code>结束，并且整个请求是以空行<code>\r\n</code>结束。<br />项目要求：<strong>对于浏览器自带的request header，代理应该原封不动地转发</strong>。但必须将以下4项补齐，即如果自带的请求头包含以下4项之一，就按照自带请求头转发；否则按照下面的默认值转发。对于自带的其它请求头，直接转发即可：</li></ul><p>Host：服务器主机名，如果浏览器自带，直接转发；否则使用请求行里解析出的hostname。<br />User-Agent：用户的操作系统/浏览器等信息。<br />Connection：第一次请求/响应完成后，当前连接是否keep alive。<br />Proxy-Connection：同上。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host: www.cnblogs.com</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (X11; Linux x86_64; rv:<span class="number">10.0</span><span class="number">.3</span>) Gecko/<span class="number">20120305</span> Firefox/<span class="number">10.0</span><span class="number">.3</span></span><br><span class="line">Connection: close</span><br><span class="line">Proxy-Connection: close</span><br></pre></td></tr></table></figure></p><ul><li>端口<br />请求端口：URL中的可选字段，如果用户输入时指定，代理应该连接指定端口，否则使用默认端口80。<br />监听端口：代理应该在该端口监听用户的连接请求，由命令行参数给出。可以是1024~65536之间的未被其他进程占用的任意值。</li></ul><h2 id="sequential-web-proxy">Sequential Web Proxy</h2><p>代理首先要接收浏览器HTTP请求，将浏览器的标准请求解析，转换为自己的请求发送。<br />这里的实现不难，只要模仿Tiny Server在一个死循环中监听来自浏览器的请求，接收之后在<code>void doit(int fd)</code>里完成解析请求行、请求头、将处理后的请求发送给server、接收server的响应并写回浏览器。<br />一些比较方便的函数：<br /><code>int accept(int listenfd, struct sockaddr *addr, int *addrlen)</code>：在<code>listenfd</code>等待连接请求，将client的socket信息和长度存入<code>addr</code>和<code>addrlen</code>；<br /><code>int Open_clientfd(char *hostname, char *port)</code>：Open connection to server at &lt;hostname, port&gt;, return a socket descriptor ready for reading and writing.<br />读写时可以使用提供的RIO包。</p><p>这里需要注意的是请求的解析：思路是在proxy这里整合所有的请求行和请求头信息，对于所有浏览器发来的请求头的内容，原封不动保存到<code>reqHeader</code>里；对于默认的4个请求头，缺少几个，就按照规定内容增加进去。<br />还要注意：因为规定<code>Connection</code>和<code>Proxy-Connection</code>都有Connection这个单词，所以用<code>strstr</code>查找的时候：如果浏览器自带的请求头没有<code>Connection</code>但是有<code>Proxy-Connection</code>，这时程序就可能误判为有<code>Connection</code>，所以最好用函数<code>strncmp</code>或者<code>memcmp</code>。</p><p>要写一个非常robust的URI解析器还是挺繁琐的，由于C没有正则表达式（也许可以用其他语言写好编译成库，然后C程序调用？），需要考虑的情况很多。<br />首先明确URI的格式：一般由4部分组成：protocol://hostname:[port]/path/[parameters][?query][#fragment]<br />协议目前只支持HTTP和HTTPS，其它一律不合法。<br />因为一旦和服务器建立连接后，protocol和hostname就没用了，只需要path以及后面的query和fragment，为了方便起见，将/也放入path字段，因为其表示根目录，但是对于query和fragment，没有放?和#，因为找到请求内容的位置后，一些具体的搜索/片段直接用关键字即可，与?和#没关系，只有/特殊一些。</p><h2 id="multiple-concurrent-requests">Multiple Concurrent Requests</h2><p>对于Iterative Server，同时只能处理一个连接请求：<img src="https://img-blog.csdnimg.cn/20200821122702755.png" alt="在这里插入图片描述" /><br />当第二个客户试图去连接：调用<code>connect</code>会正常返回，但Server不会<code>Accept</code>该请求，会用TCP Listen Backlog技术将该请求入队；调用<code>rio_writen</code>也会正常返回，Server会把写入的数据存入缓存；调用<code>rio_readlineb</code>会阻塞，因为Server没有发送任何的response。</p><p>解决方法就是并发处理，我们的代理要能同时处理多个请求，具体的方法很多：多进程、I/O多路复用、预线程化（类似生产者-消费者问题，先创建n个线程，相当于n个缓冲区），最直接的方式就是专门有一个线程负责监听，每收到一个连接请求，就开一个新线程去进行读写。这里要采用<strong>可分离</strong>的线程模型：当其终止时，内存资源会被系统自动回收。</p><p>这部分本来很简单，但是写完后测试发现挂了： <img src="https://img-blog.csdnimg.cn/20200811181713826.png" alt="在这里插入图片描述" /><br />这很可能是NOP Server出了问题，这个Server是用Python写的，我去启动了一下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nop-server.py <span class="number">15000</span></span><br></pre></td></tr></table></figure> 发现： <img src="https://img-blog.csdnimg.cn/20200811182155577.png" alt="在这里插入图片描述" /><br />这个问题是Python的版本不匹配，把<code>nop-server.py</code>第一行的<code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python3</code>即可，指定用python3的解释器执行脚本。</p><p>并发这块也妥了： <img src="https://img-blog.csdnimg.cn/20200811182851976.png" alt="在这里插入图片描述" /><br />这里的测试逻辑是这样的：Client1通过proxy连接到nop-server，这个服务器永远不会发送response，也就是这条连接一直保持；Client2通过proxy连接到Tiny，看看能不能从Tiny取个文件回来，如果能，说明并发是ok的，如果不能，说明不支持并发。之所以要用nop-server，是因为这东西可以一直连接，比较方便。如果Client1也是通过proxy连Tiny，那么可能很快就执行完了，这时Client2再去连接，很可能就不是并发的访问了，失去了测试的意义。</p><p>做第三部分之前，先实际测试下proxy的健壮性。用FireFox浏览器试试，先升级到最新版本，然后设置浏览器的代理方式： <img src="https://img-blog.csdnimg.cn/20200811194820393.png" alt="在这里插入图片描述" /><br />在8080端口运行proxy，然后找个HTTP网站<code>http://csrankings.org/</code>试一下，现在网站基本都是HTTPS，看来后续的Features要支持HTTPS了（先挖个坑）。</p><p>运行proxy之前，画风是这样的： <img src="https://img-blog.csdnimg.cn/20200811200533477.png" alt="在这里插入图片描述" /> 运行proxy之后： <img src="https://img-blog.csdnimg.cn/20200821133459152.png" alt="在这里插入图片描述" /><br />通过代理访问该网页时，页面只能加载一部分，收到59420B数据后，会<code>segmentation fault</code> ，最后发现 主要原因是<code>init_cache()</code>时空间分配写错了，但是修改后又出现了如下错误： <img src="https://img-blog.csdnimg.cn/20200824160910224.png" alt="在这里插入图片描述" /><br />是<code>memcpy</code>时候数组越界，处理buffer时候要千万小心。</p><p>这里要改下<code>csapp.c</code>中的错误处理，里面都是直接<code>exit(0)</code>，但是作为一个服务器，不能随便终止，所以我们注释掉所有Error-handling functions里的<code>exit()</code>，如果在读数据或者什么时候遇到错误，<code>return</code>即可：<code>exit()</code>是系统调用级别的，结束整个进程；<code>return</code>是函数级别的，返回给调用者，当然在<code>main()</code>里<code>return</code>也就是<code>exit(0)</code>。</p><h2 id="caching-web-objects">Caching Web Objects</h2><p>HTTP协议本身就实现了缓存机制, 目的是为了减小网络传输的开销, 只需要通过URI和请求端口就可以判断是否请求的同一对象. 缓存可以说是整个项目的难点, 需要考虑的问题比较多. 为了模块化，将这一部分单独写作<code>cache.c/cache.h</code>, 并修改<code>Makefile</code>.</p><p>首先, 由于内存有限, 因此代理的缓存大小<code>MAX_CACHE_SIZE</code>也是有限的. 另外, 为了避免太大的web对象占据太多缓存空间, 减小其他对象的被缓存几率, 对web对象的大小<code>MAX_OBJECT_SIZE</code>也是有要求的.</p><p>难点有2个：</p><ol type="1"><li>多线程同步：对于cache的访问应当是线程安全的，多个线程可以同时读，但只有一个线程可以写，这就是典型的读者-写者问题;<br /></li><li>替换策略：cache块的数量是有限的，没有空间时就需要换出换入。一般来讲都是采用LRU方式，一个单线程的严格的LRU Cache可以参考<a href="https://leetcode.com/problems/lru-cache/">leetcode146题</a>。</li></ol><p>我们首先来解决问题一: 保证线程安全最简单的方法就是给<strong>整个cache</strong>加一个大大的排他锁(exclusive lock), 效率当然会低到无法接受. 一个直观的改进就是将cache分区, 细化锁的粒度, 用读写锁进行保护.<br />读者写者问题可以有读优先和写优先2种方案: 读优先指来了一个读进程, 除非有一个写进程正在访问, 否则读者直接去读, 可能导致写进程饥饿. 写优先指有进程读时, 如果来了写进程, 那么禁止后续读进程请求, 现有进程读完后, 写进程立即去写, 可能导致读进程饥饿.<br />写优先实现起来稍微麻烦一些, 并且一般读操作频率高于写操作, 所以这里采用读优先. 这里就不自己实现读者写者了, 使用读写锁<code>pthread_rwlock_t</code>, 确保不会死锁.</p><p>接着来解决问题二: 要实现多线程并发LRU Cache，由于C实现双向链表和Hashtable有点繁琐，所以项目要求<strong>近似LRU</strong>即可：我们可以为每一个cache块附加一个时间戳，每当该块被访问时，就更新时间戳。需要替换时，换出时间戳最小的块即可。这样带来的问题就是：读的时候也需要更新时间戳，但更新时间需要加写锁，如果其他线程占用写锁，那么读进程就无法更新时间戳，也就不是严格的LRU了。</p><p>Cache的实现既可以像malloc lab一样采用分级的思想，也可以直接均分所有空间，整体流程如下：</p><ul><li>初始化</li><li>查Cache</li><li>如果miss，寻找可用位置</li><li>找到可用块，缓存满足大小条件的Object</li><li>更新时间戳</li></ul><p>最大的缓存对象是100KB，一共的空间1MB，平均可以缓存10个Object，这样会浪费24KB空间。所以采用分级的方法：<br />100KB * 5块 = 500KB<br />50KB * 6块 = 300KB<br />20KB * 5块 = 100KB<br />10KB * 10块 = 100KB<br />1KB * 24块 = 24KB<br />接着来构思下存储结构，<strong>设计数据结构</strong>和<strong>类（函数）接口</strong>是我认为做一个工程最难的部分，当然还有最后的效率优化问题：<br />一个cache line最基本的构成需要存储URI和OBJ，因为下次用户请求时代理需要知道请求的是哪个网站的什么内容（通过URI确定），进而如果查找到，将内容OBJ直接返回给用户。同时还需要一个时间戳以及用于同步的读写锁： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *uri;</span><br><span class="line">    <span class="keyword">char</span> *obj;</span><br><span class="line">    <span class="keyword">int</span> objSize;</span><br><span class="line">    <span class="keyword">int64_t</span> time;</span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> rwlock; </span><br><span class="line">&#125; cache_line;</span><br></pre></td></tr></table></figure> 一共有5种类型的cache，每种类型有一个number，还有一个指向该种cache第一块的指针p，p指向该种的第一小块，p+1指向该种的第二小块，以此类推： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> numOfLine;</span><br><span class="line">    cache_line *cachep;</span><br><span class="line">&#125; cache_type;</span><br></pre></td></tr></table></figure> 数据结构设计完后，需要设计函数接口，cache的操作有初始化、查找、写入（替换）和释放：<br />初始化需要为cache block分配空间，将每一块的时间戳置0，表示该块没有存储内容；<br />查找时需要遍历所有的type，再在该type中遍历所有的block，如果时间戳不为0，比对浏览器需要访问的URI与当前块的URI是否相等，相等则表示cache hit，直接写回给相应的fd；更新时间戳时，粒度越细越好，这里用<code>gettimeofday</code>精确到微秒级别；读取时如果能申请到写锁，就更新时间，否则就不更新；<br />写入时需要先计算object大小，寻找空闲的cache block，没有需要替换，满足要求后存入cache，并且将结果返给浏览器。这里要注意寻找空闲块时要<strong>从小往大</strong>，否则很可能一个很小的object占用了一块很大的block，造成严重浪费，类似于操作系统内存管理动态分配中的最佳适应算法。<br />那么这种分级的方式的缺点是：每种类型的cache块<strong>大小固定</strong>，很可能50KB的块只存了10KB内容，造成浪费，类似于固定分区分配。<br />关于替换，我们采取<strong>局部置换</strong>策略：即需要换入的object大小如果是30KB，我们只用50KB这种类型去存储，如果50KB的块用完了，就需要换出一块50KB，即使此时100KB的块有空闲，也仍然完成置换过程。</p><p>写完cache后，需要修改<code>Makefile</code>，在<code>proxy.c</code>中增加cache的部分。运行完以后，可以用<code>make clean</code>清除目录下多余的垃圾文件，比如<code>.o</code>文件等。</p><h2 id="test">Test</h2><p>测试的方式一共有3种：</p><ul><li>自动化测试 利用课程提供的脚本<code>driver.sh</code>自动进行，执行之前，需要安装一些工具： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure> 做完所有内容后，先用<code>driver.sh</code>进行测试，发现cache部分没分。。。得，开始debug吧！我觉得GDB好难用啊，所以都是通过<code>printf</code>de的。</li></ul><p>用curl先通过proxy发个请求，然后看看proxy有没有缓存服务器返回的内容。<br />最后发现在<code>write_cache</code>时需要用到URI，但是之前解析时候把URI改了，一定注意URI最好不要改，设置为<code>const</code>比较保险。</p><p>完了以后，cache满分了，basic又错了一个，fetch可执行对象文件tiny时： <img src="https://img-blog.csdnimg.cn/20200819212506210.png" alt="在这里插入图片描述" /><br />一开始怀疑是tiny太大了，某个数组爆掉了。看了下tiny有36000+B，缓存空间足够，但是可能写入时候有些bug。tiny是二进制文件，可能比较特殊？很奇怪的是：明明<code>objSize</code>是36000+，但是<code>strlen(obj)</code>只有100，怀疑文件中可能有<code>\0</code>，提前终止了<code>strlen</code>的计数。</p><p>解决方案是<code>write_cache</code>参数不仅要有<code>uri</code>和<code>obj</code>，还要有<code>obj</code>的长度<code>len</code>，否则直接用<code>strlen</code>获取长度可能就挂了。后来修改以后就满分了，一定要注意，如果用<code>char*</code>传参，一定要附带参数<code>len</code>，因为不一定读取的是字符串，还有可能是二进制文件，<code>\0</code>也就是<code>0</code>很容易出现，用<code>strlen</code>大概率会爆掉。</p><p>最终测试结果如下： <img src="https://img-blog.csdnimg.cn/20200819221810760.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20200819221846500.png" alt="在这里插入图片描述" /> - 利用<code>curl</code>工具<br /><code>curl</code>可以用来生成HTTP请求：假设Sever在端口15213监听，代理在端口15214监听，那么可以通过下面命令经由代理发送请求： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --proxy http:<span class="comment">//localhost:15214 http://localhost:15213/home.html</span></span><br></pre></td></tr></table></figure> 我们用该工具测试下Sequential Web Proxy：<br />首先启动Tiny Web Server和Proxy： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./tiny 15213</span><br><span class="line">./proxy 15214</span><br></pre></td></tr></table></figure> 然后执行<code>curl</code>命令： <img src="https://img-blog.csdnimg.cn/20200730162654329.png" alt="在这里插入图片描述" /><br />说明基本功能是OK的！！ - 实际浏览器测试<br />满分之后，万里长征走了一半吧，因为要在实际浏览器测试，不断增强程序的<strong>鲁棒性</strong>。 测试之前，先禁用浏览器自带的cache，清空之前的缓存。 测下内存泄漏：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --leak-check=full --show-leak-kinds=all ./proxy 8080</span><br></pre></td></tr></table></figure><h2 id="code-reference">Code &amp; Reference</h2><p><a href="https://github.com/EIMadrigal/15-213/tree/master/Web%20Proxy">code here</a><br /><a href="http://csapp.cs.cmu.edu/3e/labs.html">reference here</a></p><h2 id="todo">TODO</h2><p>接下来的工作可拓展的还有很多，包括但不限于：</p><ul><li>增加对HTTPS的支持（看起来并不简单）</li><li>Cache这里还有很多可优化的地方（分配策略、置换策略...）</li><li>目前只支持GET方式，还可以拓展到POST方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给我未来的孩子</title>
      <link href="/2020/08/31/%E7%BB%99%E6%88%91%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%AD%A9%E5%AD%90/"/>
      <url>/2020/08/31/%E7%BB%99%E6%88%91%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%AD%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>读诗之前，先澄清一点：这首诗原作者是作家张梅女士，收录于20世纪90年代出版的个人散文集《木屐声声》。至于流传甚广的余光中先生的《写给未来的你》，完全是某些出版物杜撰的，17年余先生去世时，大家读着这篇别人的文章以为纪念，不知道算不算一种悲哀。</p><p>如果读过余光中的作品，他的文风绝对不会像这首诗这么直白，当然也不会如此鸡汤。</p><p>说回这首诗，有一次搜索「理想主义者」时偶然读到，虽然有些道理比较宏大，但是整体来看都是作者阅历的总结，如果结合自身经验去读相信一定收获颇丰，当然作为育儿经也是不错的~</p><hr /><p>孩子，我希望你自始至终都是一个理想主义者。</p><p>你可以是农民，可以是工程师，可以是演员，可以是流浪汉，但你必须是个理想主义者。</p><p>童年，我们讲英雄故事给你听，并不是一定要你成为英雄，而是希望你具有纯正的品格。</p><p>少年，我们让你接触诗歌、绘画、音乐，是为了让你的心灵填满高尚的情趣。 这些高尚的情趣会支撑你的一生，使你在最严酷的冬天也不会忘记玫瑰的芳香。</p><p>理想会使人出众。</p><p>孩子，不要为自己的外形担忧。</p><p>理想纯洁你的气质，而最美貌的女人也会因为庸俗而令人生厌。</p><p>通向理想的途径往往不尽如人意，而你亦会为此受尽磨难。</p><p>但是，孩子，你尽管去争取，理想主义者的结局悲壮而绝不可怜。</p><p>在貌似坎坷的人生里，你会结识许多智者和君子，你会见到许多旁人无法遇到的风景和奇迹。</p><p>选择平庸虽然稳妥，但绝无色彩。</p><p>不要为蝇头小利放弃自己的理想，不要为某种潮流而改换自己的信念。</p><p>物质世界的外表太过复杂，你要懂得如何去拒绝虚荣的诱惑。</p><p>理想不是实惠的东西，它往往不能带给你尘世的享受。</p><p>因此你必须习惯无人欣赏，学会精神享受，学会与他人不同。</p><p>其次，孩子，我希望你是个踏实的人。</p><p>人生太过短促，而虚的东西又太多，你很容易眼花缭乱，最终一事无成。</p><p>如果你是个美貌的女孩，年轻的时候会有许多男性宠你，你得到的东西太过容易，这会使你流于浅薄和虚浮；如果你是个极聪明的男孩，又会以为自己能够成就许多大事而流于轻佻。</p><p>记住，每个人的能力有限，我们活在世上能做好一件事足矣。</p><p>写好一本书，做好一个主妇。</p><p>不要轻视平凡的人，不要投机取巧，不要攻击自己做不到的事。</p><p>你长大后会知道，做好一件事太难，但绝不要放弃。</p><p>你要懂得和珍惜感情。</p><p>不管男人女人，不管墙内墙外，相交一场实在不易。</p><p>交友的过程会有误会和摩擦，但想一想，诺大世界，有缘结伴而行的能有几人？</p><p>你要明白朋友终会离去，生活中能有人伴在身边，听你倾谈，倾谈给你听，就应该感激。</p><p>要爱自己和爱他人，要懂自己和懂他人。</p><p>你的心要如溪水般柔软，你的眼波要像春天般明媚。</p><p>你要会流泪，会孤身一人坐在黑暗中听伤感的音乐。</p><p>你要懂得欣赏悲剧，悲剧能丰富你的心灵。</p><p>希望你不要媚俗。</p><p>你是个独立的人，无人能抹杀你的独立性，除非你向世俗妥协。</p><p>要学会欣赏真，要在重重面具下看到真。</p><p>世上圆滑标准的人很多，但出类拔萃的人极少。而往往出类拔萃又隐藏在卑琐狂荡之下。</p><p>在形式上我们无法与既定的世俗争斗，而在内心我们都是自己的国王。</p><p>如果你的脸上出现谄媚的笑容，我将会羞愧地掩面而去。</p><p>世俗的许多东西虽耀眼却无价值，不要把自己置于大众的天平上，不然你会因此无所适从，人云亦云。</p><p>在具体的做人上，我希望你不要打断别人的谈话，不要娇气十足。</p><p>你每天至少要拿出两小时来读书，要回信写信给你的朋友。</p><p>不要老是想着别人应该为你做些什么，而要想着怎么去帮助他人。</p><p>借他人的东西要还，不要随便接受别人的恩惠。</p><p>要记住，别人的东西，再好也是别人的；自己的东西，再差也是自己的。</p><p>孩子，还有一件事，虽然做起来很难，但相当重要，这就是要有勇气正视自己的缺点。</p><p>你会一年年地长大，会渐渐遇到比你强、比你优秀的人，会发现自己身上有许多你所厌恶的缺点。 这会使你沮丧和自卑。</p><p>但你一定要正视它，不要躲避，要一点点地加以改正。</p><p>战胜自己比征服他人还要艰巨和有意义。</p><p>不管世界潮流如何变化，但人的优秀品质却是永恒的：正直、勇敢、独立。</p><p>我希望你是一个优秀的人。</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bit Manipulation</title>
      <link href="/2020/08/26/Bit%20Manipulation/"/>
      <url>/2020/08/26/Bit%20Manipulation/</url>
      
        <content type="html"><![CDATA[<p>位操作可以使得我们细粒度地控制数据，但是很多技巧显得非常tricky，需要做一些总结。</p><h2 id="basics">Basics</h2><p>常见的操作有：与、或、非、异或和移位。</p><ul><li><code>n &amp; (n - 1)</code>：将n的二进制表示中最低位的<code>1</code>改为<code>0</code></li><li><code>a ^ b = b ^ a</code>，<code>(a ^ b) ^ c = a ^ (b ^ c)</code>，<code>a ^ 0 = a</code>，<code>a ^ a = 0</code></li><li><code>n &amp; (-n)</code>或<code>n &amp; (~n + 1)</code>：lowbit操作，将最低位的1及后面的0代表的数字转为十进制</li><li><code>&amp;</code>只会递减/不变</li><li><code>a = a | (1 &lt;&lt; i)</code> 将a的第i位设为1</li></ul><h2 id="examples">Examples</h2><ol type="1"><li>计算二进制中<code>1</code>的个数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>判断整数是否为2的幂</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v; <span class="comment">// we want to see if v is a power of 2</span></span><br><span class="line"><span class="keyword">bool</span> f;         <span class="comment">// the result goes here </span></span><br><span class="line"></span><br><span class="line">f = (v &amp; (v - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">f = v &amp;&amp; !(v &amp; (v - <span class="number">1</span>));  <span class="comment">// v=0特判</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>整数相加</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// a^b: a+b without carry</span></span><br><span class="line">        <span class="comment">// a&amp;b: the carry</span></span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum(a ^ b, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>将n中第i~j位置0</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">    mask |= (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br><span class="line">mask = ~mask;</span><br><span class="line">n = n &amp; mask;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><a href="https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary:-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently">A summary: how to use bit manipulation to solve problems easily and efficiently</a><br /><a href="http://graphics.stanford.edu/~seander/bithacks.html">Bit Twiddling Hacks</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Library Functions Implementation</title>
      <link href="/2020/08/16/Library%20Functions%20Implementation/"/>
      <url>/2020/08/16/Library%20Functions%20Implementation/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">void</span>* des, <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!src || !des)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (des &gt; src &amp;&amp; (<span class="keyword">const</span> <span class="keyword">char</span>*)src + cnt &lt; (<span class="keyword">char</span>*)des) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* srcB = (<span class="keyword">const</span> <span class="keyword">char</span>*)src + cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* desB = (<span class="keyword">char</span>*)des + cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">            *desB = *srcB;</span><br><span class="line">            --desB;</span><br><span class="line">            --srcB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* srcF = (<span class="keyword">const</span> <span class="keyword">char</span>*)src + cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* desF = (<span class="keyword">char</span>*)des + cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">            *desF = *srcF;</span><br><span class="line">            ++desF;</span><br><span class="line">            ++srcF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将original中的子串substr替换为replace</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strReplace</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* original, <span class="keyword">const</span> <span class="keyword">char</span>* substr, <span class="keyword">const</span> <span class="keyword">char</span>* replace)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!original || !substr || !replace) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(original);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* newStr = <span class="built_in">malloc</span>((len + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(newStr, original, (len + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* p = <span class="built_in">strstr</span>(newStr, substr);</span><br><span class="line">    <span class="built_in">memcpy</span>(p, replace, <span class="built_in">strlen</span>(replace));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector">vector</h2><p>比较高频的问题：为什么<code>push_back()</code>的平均时间复杂度是<span class="math inline">\(O(1)\)</span>？<br />假设倍增因子是<span class="math inline">\(m\)</span>，vector当前有<span class="math inline">\(n\)</span>个元素，那么扩容过程大致为：<span class="math inline">\(0,1,m,m^2,...,m^{log_mn}\)</span>，每次扩容的复杂度等于当时的元素个数，无需扩容时插入的时间复杂度为<span class="math inline">\(O(1)\)</span>，所以总的复杂度为： <span class="math display">\[1+m+m^2+...+m^{log_mn}=\frac{mn-1}{m-1}\]</span> 如果<span class="math inline">\(m=2\)</span>，那么均摊到<span class="math inline">\(n\)</span>个元素，插入每个元素的操作复杂度就是<span class="math inline">\(O(1)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">class myvector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">push_back</span>(T&amp; x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="built_in">broad</span>(<span class="number">2</span> * capacity + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        obj[size++] = x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">broad</span><span class="params">(<span class="keyword">int</span> newCap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newCap &lt; size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        T* tmp = obj;</span><br><span class="line">        obj = <span class="keyword">new</span> T[newCap];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            obj[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    T* obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Invalid input!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*str == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;+&#x27;</span> || *str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*str &lt; <span class="string">&#x27;0&#x27;</span> || *str &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;Invalid input!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        value = value * <span class="number">10</span> + *str - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign * value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(mn)，可以用KMP优化为O(m+n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; haystack.<span class="built_in">size</span>() &amp;&amp; j &lt; needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - j + <span class="number">1</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - needle.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tiny Shell</title>
      <link href="/2020/08/02/Tiny%20Shell/"/>
      <url>/2020/08/02/Tiny%20Shell/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>本项目要实现一个简易版Shell，支持以下Features： - 命令提示符<code>tsh&gt;</code> - 若用户输入的命令第一个单词是内置命令，在当前进程tsh(Tiny Shell)执行命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span>   列出运行/挂起的后台job</span><br><span class="line"><span class="built_in">bg</span> &lt;job&gt;   通过发送SIGCONT信号重启进程，将后台挂起的job设为在后台运行，&lt;job&gt;可以是PID或%JID</span><br><span class="line"><span class="built_in">fg</span> &lt;job&gt;   通过发送SIGCONT信号重启进程，将后台运行/挂起的job设为在前台运行，&lt;job&gt;可以是PID或%JID</span><br><span class="line"><span class="built_in">kill</span> &lt;job&gt;   结束&lt;job&gt;</span><br><span class="line">quit   退出tsh</span><br></pre></td></tr></table></figure> - 若用户输入的命令第一个单词是可执行文件路径，后续单词是命令行参数，tsh会fork一个子进程，在子进程运行 - 支持job control（前后台切换），改变进程状态（running/stopped/terminated） - 支持管道<code>|</code>和I/O重定向<code>&lt;</code> <code>&gt;</code>(TODO)</p><h2 id="background-knowledge">Background Knowledge</h2><ul><li>Shell<br />shell是一个交互式的命令行解释器，可以执行用户输入的指令，显示计算结果。<br />用户输入既可以是内置命令，也可以是可执行文件路径。<br />用户既可以在前台运行，也可以在后台运行。后台job可以在命令最后加一个<code>&amp;</code>，否则视为前台。比如<code>/bin/ls -l -d &amp;</code>表示在后台执行<code>ls</code>程序。前台job只能有1个，后台job则可以有多个。</li><li>Signals<br />信号机制的作用就是允许进程/内核打断其他进程运行，是进行进程间通信的一种方式。<br />Linux的常用信号有： <img src="https://img-blog.csdnimg.cn/20200719145450179.png" alt="在这里插入图片描述" /></li></ul><h2 id="implementation">Implementation</h2><p>整体的思路是：父进程读取命令行输入，通过系统调用<code>fork()</code>创建子进程执行这些输入。对于前台命令，父进程必须等待子进程完成才能继续读取下一条命令；对于后台命令，父进程和子进程则是并发执行。</p><ul><li>useful functions<br /><code>int fork(void)</code>：父进程创建一个子进程，在子进程中返回0，父进程中返回子进程的PID。<br /><code>int kill(pid_t pid, int sig)</code>：进程向其它进程（包括自己）发送信号，成功返回0，错误返回-1。可以通过改变参数<code>pid</code>调整发送目标：<code>pid&gt;0</code>，给该进程发信号；<code>pid==0</code>，给包括自己在内的当前进程组发信号；<code>pid&lt;0</code>，给pgid=|pid|的进程组的每个进程发信号。<br /><code>int execve(char *filename, char *argv[], char *envp[])</code>：在当前进程的上下文环境中装载并运行新的程序，成功不返回，失败返回-1。<code>filename</code>可以是可执行目标文件或脚本文件，会覆盖原进程的data/code/stack，会保留原进程的PID/open files/signal context。<br /><code>pid_t waitpid(pid_t pid, int *status, int options)</code>：指定进程终止父进程会进行回收，否则等待。内核会将子进程的退出状态传给父进程，之后清除子进程。<code>options=WNOHANG | WUNTRACED</code>时，如果wait set中没有终止/暂停的子进程，立即返回0；否则返回任意一个子进程的PID。<br /><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)</code>：<code>how=SIG_BLOCK</code>将<code>set</code>中的信号加入阻塞向量；<code>how=SIG_UNBLOCK</code>将<code>set</code>中的信号从阻塞向量中移除；<code>how=SIG_SETMASK</code>将阻塞向量设置为<code>set</code>。如果<code>oldset!=NULL</code>之前的阻塞向量就存储在<code>oldset</code>中。<br /><code>handler_t *signal(int signum, handler_t *handler)</code>：改变信号的默认行为。</li><li>step by step<br />-- 整体结构：除了测试文件和Makefile外，全部实现都在<code>tsh.c</code>中，<code>main</code>函数有一个死循环，不停调用<code>eval()</code>实现命令的解析、执行。<br />-- <code>eval(char* cmdline)</code><br />接收到用户输入后，第一件事就是解析。解析是通过<code>int parseline(const char* cmdline, char** argv)</code>完成，将<code>cmdline</code>解析到<code>argv</code>中，如果用户要求后台运行就返回1，否则返回0。<br />解析后，我们需要通过<code>int builtin_cmd(char** argv)</code>判断是否为内置命令。如果是内置命令，就在<code>builtin_cmd</code>里立刻执行；否则需要创建子进程执行，这里需要区分前后台进程：如果是前台，需要等待terminate才能返回并接受新的输入；如果是后台，则可以立即接收新输入。</li><li>key point 1<br />父进程在<code>fork</code>子进程之前，要用<code>sigprocmask</code>阻塞<code>SIGCHLD</code>信号。否则由于父子进程执行顺序不确定，可能导致：<br />子进程首先执行完毕，内核向父进程发送<code>SIGCHLD</code>信号；<br />从内核态切换到用户态时，检测到<code>SIGCHLD</code>信号并且执行<code>sigchld_handler</code>，删除该job；<br />父进程执行<code>addjob</code>操作，显然删除和添加顺序反了。<br />如果我们正确阻塞了<code>SIGCHLD</code>信号，还是按照上面的顺序：<br />子进程首先执行完毕，内核向父进程发送<code>SIGCHLD</code>信号；<br />从内核态切换到用户态时，由于父进程阻塞了<code>SIGCHLD</code>信号，所以不会执行<code>sigchld_handler</code>；<br />父进程添加该job，解除<code>SIGCHLD</code>信号的阻塞，下一次context switch时删除job。</li><li>key point 2<br />用户从键盘输入ctrl-c时，内核给shell进程发<code>SIGINT</code>信号（默认的signal handler是终止shell进程），一般有以下几种方式处理：</li></ul><ol type="1"><li>忽略该信号</li><li>使用默认的signal handler</li><li>实现一个单独的signal-handling函数</li></ol><p>在<code>main</code>里面安装handler，在<code>sigint_handler</code>中处理：终止所有的前台进程及其子进程；<br />用户从键盘输入ctrl-z时，内核给shell发<code>SIGTSTP</code>信号（默认暂停当前进程直到收到<code>SIGCONT</code>），在<code>main</code>里面安装handler，在<code>sigtstp_handler</code>中处理：暂停所有的前台进程及其子进程。 - key point 3<br />默认情况下，<code>fork</code>出来的子进程和他爹属于同一个进程组。当我们在机器上运行Tiny Shell时，程序运行在前台进程组中，这时如果Tiny Shell创建一些子进程，这些子进程也会同属于这个前台进程组，用户输入ctrl-c会终止所有前台进程，包括Tiny Shell，这显然不是我们想要的。<br />解决方案是：<code>fork</code>之后，子进程调用<code>setpgid(0,0)</code>将其放到一个新的进程组里，这个组的group id和PID相同。这样就可以确保前台进程组里只有Tiny Shell一个进程，用户输入ctrl-c时，就可以在<code>sigint_handler</code>中调用<code>kill()</code>终止特定的前台job。 - key point 4<br />当子进程终止或者暂停，内核会给父进程发送<code>SIGCHLD</code>信号，我们在<code>sigchld_handler</code>中根据子进程的状态做相应的处理：<br /><code>WIFEXITED(status)</code>：子进程通过<code>exit</code>或<code>return</code>正常终止；<br /><code>WIFSIGNALED(status)</code>：子进程通过信号终止；<br /><code>WIFSTOPPED(status)</code>：子进程暂停；<br /><code>WTERMSIG(status)</code>：当<code>WIFSIGNALED()</code>为真，返回造成子进程终止的信号ID；<br /><code>WSTOPSIG(status)</code>：当<code>WIFSTOPPED()</code>为真，返回造成子进程暂停的信号ID。 - key point 5<br />对于前台进程，需要一直等待其执行完毕，然后回收，可以在<code>waitfg()</code>中调用<code>sigsuspend</code>完成；但对于后台进程，由于不用等待其完成，所以为了避免其成为zombie，需要在其执行完毕或者暂停时通知父进程，这个机制就是signal，具体的就是我们的<code>sigchld_handler</code>做的事情。</p><p>如果子进程因为收到了未能捕获的信号(如SIGKILL)而终止，父进程尚未回收，子进程残留资源(PCB)存放于内核中，那么该子进程就成为僵尸进程。</p><p>处理僵尸进程有2种方法： - 杀死其父进程，子进程变为孤儿进程，进而被系统回收 - <code>wait</code>函数</p><h2 id="test">Test</h2><p>一方面通过提供的脚本测试，共有16个脚本测试文件，测试通过<code>make test01</code>~<code>make test16</code>进行；<br />另一方面通过实际执行去测试各项功能。</p><h2 id="code-reference">Code &amp; Reference</h2><p><a href="https://github.com/EIMadrigal/15-213/tree/master/Tiny%20Shell">code here</a><br /><a href="http://csapp.cs.cmu.edu/3e/labs.html">reference here</a></p><h2 id="todo">TODO</h2><ul><li>IO重定向<br />https://www.cnblogs.com/weidagang2046/p/io-redirection.html</li><li>管道<br />https://panqiincs.me/2017/04/19/write-a-shell-redirect-and-pipeline/</li><li><a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L1">xv6-riscv/sh.c</a></li><li>history：支持快速访问最近的若干条命令</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seam Carving</title>
      <link href="/2020/07/24/Seam%20Carving/"/>
      <url>/2020/07/24/Seam%20Carving/</url>
      
        <content type="html"><![CDATA[<p>这是CS 61B的HW5，具体实现<a href="https://github.com/EIMadrigal/CS61B/tree/master/hw5">在这里</a>。 ## Intro 这个项目是要实现一种基于内容的图像缩放算法Seam Carving。Seam分为垂直（自上而下每行取一个像素点）和水平（自左向右每列取一个像素点）。<br />下图是一张505*287的图像：<br /><img src="https://img-blog.csdnimg.cn/20200707090755919.png" alt="在这里插入图片描述" /><br />移除150条垂直seam，得到一张比原图窄30%的新图：<br /><img src="https://img-blog.csdnimg.cn/2020070709085251.png" alt="在这里插入图片描述" /><br />与传统的内容不可知的方法（裁剪、缩放）相比，seam curving可以保留原图的大多数重要特征。<br />图像处理中的坐标表示与常见的笛卡尔坐标系不同：<br /><img src="https://img-blog.csdnimg.cn/20200707094310172.png" alt="在这里插入图片描述" /><br />每个像素的颜色采用RGB空间，与<code>java.awt.Color</code>一致。算法的过程分为3步：</p><ul><li>Energy calculation<br />因为是内容感知算法，所以需要一个指标衡量每个像素的<strong>重要程度</strong>，这个指标我们叫做该像素点的能量：能量越高越重要，就不太会被当做seam的一部分剔除。<br />我们选择双梯度能量函数来计算能量。对于上面的冲浪图，计算后的灰度图如下：<br /><img src="https://img-blog.csdnimg.cn/20200707095021383.png" alt="在这里插入图片描述" /><br />可以看到：高能量像素对应颜色发生巨变的地方，比如冲浪者和大海的边界、天际线等，并且颜色更白。处理过程中就是要避免移除这些关键信息。</li><li>Seam identification<br />计算出每个像素点的能量值后，就要找出一条能量值总和最小的seam，垂直seam从顶行的某像素点开始到最后一行某点结束。但是如果(x,y)位于seam，下一行只能选(x-1,y+1), (x,y+1), (x+1,y+1)之一，可能是为了保证图像的连贯。</li><li>Seam Removal<br />移除找到的seam。</li></ul><h2 id="implement">Implement</h2><p>三个步骤的实现都在<code>SeamCarver</code>中，我们逐个来看： - 单像素能量计算<br />采用对偶梯度能量函数<span class="math inline">\(\Delta_x^2(x, y) + \Delta_y^2(x, y)\)</span>，x梯度的平方<span class="math inline">\(\Delta_x^2(x, y) = R_x(x, y)^2 + G_x(x, y)^2 + B_x(x, y)^2\)</span>，<span class="math inline">\(R_x(x, y), G_x(x, y), B_x(x, y)\)</span>是左右两个像素点(x+1, y)和(x-1, y)的红、绿、蓝之差的绝对值；类似地，对于y的梯度，就是要求上下两个像素点的差。对于边界的处理，采取循环方式，即如果某侧不存在，就取反方向的点。<br />举例来看： <img src="https://img-blog.csdnimg.cn/20200707155708977.png" alt="在这里插入图片描述" /><br />要计算(1, 0)位置即(255, 101, 153)的能量：<br /><span class="math display">\[R_x(1, 0) = 255 − 255 = 0, G_x(1, 0) = 101 − 101 = 0, B_x(1, 0) = 255 − 51 = 204\]</span><br />故<span class="math inline">\(\Delta_x^2(1, 0) = 204^2 = 41616\)</span>；对于y方向，由于没有(x, y-1)，就用(x, height-1)代替：<br /><span class="math display">\[R_y(1, 0) = 255 − 255 = 0, G_y(1, 0) = 255 − 153 = 102, B_y(1, 0) = 153 − 153 = 0\]</span><br />故<span class="math inline">\(\Delta_y^2(1, 0) = 102^2 = 10404\)</span>，所以(1, 0)位置的能量就是<span class="math inline">\(41616 + 10404 = 52020\)</span>。<br />接口也很简单<code>public  double energy(int x, int y)</code>。 - Find Vertical Seam<br />这个接口设计为<code>public int[] findVerticalSeam()</code>，返回的数组有H个值，第i个值对应要移除的第i行的列号。<br />要找这样一条最短路径，我们考虑用动态规划求解：<br />首先定义子问题<span class="math inline">\(M(i,j)\)</span>表示以<span class="math inline">\((i,j)\)</span>结尾的最短路径的成本，用<span class="math inline">\(e(i,j)\)</span>表示位置<span class="math inline">\((i,j)\)</span>的能量；<br />接着寻找状态转移方程：由于路径的左右位置绝对值不大于1，所以<span class="math inline">\(M(i,j)=e(i,j)+min\{M(i-1,j-1),M(i,j-1),M(i+1,j-1)\}\)</span>；<br />最后确定base case：每行的值都由上一行确定，所以base case就是<span class="math inline">\(M(i,0)=e(i,0)\)</span>。<br />最终结果就是在最后一行找到<span class="math inline">\(M\)</span>最小的像素点，逐行向上寻找三个相邻格子中<span class="math inline">\(M\)</span>较小的那个。 - Find Horizontal Seam<br />对于水平方向的seam，当然也可以用动态规划求解。但是为了避免代码冗余，我们考虑利用<code>findVerticalSeam()</code>：先将图像转置，然后调用<code>findVerticalSeam()</code>，最后再将其转置即可。<br />具体的：考虑如下3*2图像：<br /><img src="https://img-blog.csdnimg.cn/20200708090038977.png" alt="在这里插入图片描述" /><br />将其转置：<br /><img src="https://img-blog.csdnimg.cn/2020070809031641.png" alt="在这里插入图片描述" /><br />利用<code>findVerticalSeam()</code>得到(0,1,0)即为水平的seam，最后将图像再次转置即可。</p><h2 id="待改进">待改进</h2><ul><li>能量计算<br />每次移除一条seam，都要调用<code>findVerticalSeam()</code>，<code>findVerticalSeam()</code>中会计算所有格子的能量，这样如果我们移除20条seam，就要计算20次所有格子的能量，显然这是可以避免的。<br />最直观的方法就是空间换时间，创建能量矩阵<code>double[][]</code>存储每个格子的能量。</li><li>水平seam<br />转置矩阵耗时<span class="math inline">\(O(WH)\)</span>，更快一些的做法是利用一个flag记录当前是在寻找垂直还是水平seam，在计算能量时判断分类。</li></ul><h2 id="reference">Reference</h2><p><a href="https://sp18.datastructur.es/materials/hw/hw5/hw5">HW 5: Seam Carving</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫谈三毛</title>
      <link href="/2020/07/17/%E6%BC%AB%E8%B0%88%E4%B8%89%E6%AF%9B/"/>
      <url>/2020/07/17/%E6%BC%AB%E8%B0%88%E4%B8%89%E6%AF%9B/</url>
      
        <content type="html"><![CDATA[<p>三毛的书我读的不多，大概只有《撒哈拉的故事》、《梦里花落知多少》和《谈心》。<br />初识三毛，是在《谈心》中她给一个读者的回信：</p><blockquote><p>三毛女士：<br />我今年廿九岁，未婚，是一家报关行最低层的办事员，常常在我下班以后，回到租来的斗室里，面对物质和精神都相当贫乏的人生，觉得活着的价值，十分...对不起，我黯淡的心情，无法用文字来表达。我很自卑，请你告诉我，生命最终的目的何在？<br />以我如此卑微的人（我的容貌太平凡了），工作能力也有限，说不出有什么特别的兴趣，也从来没有异性对我感兴趣。<br />我真羡慕你，恨不得能够活得像你，可惜我不能，请你多写书给我看，丰富我的生命，不然，真不知活着还有什么快乐？<br />敬祝<br />春安！<br />一个不快乐的女孩上</p></blockquote><p>谈及生命的意义，这或许是大多数人都会思考的问题，然而它却不像数学题那样有什么所谓的标准答案，这是一道拥有无数种解法的题目。丝毫不需要掩饰，直至今日我仍然没有完全明晰。<br />是的，人终有一死，一切都会湮灭。生活中的很多事情从人生这一宏观角度来看根本不值一提，广而泛之，其实所有的事情都不值一提。那么生命的意义到底在哪里？不妨先了解下三毛的想法：</p><blockquote><p>不快乐的女孩：<br />从你短短的自我介绍中，看来十分惊心，二十九岁正当年轻，居然一连串的用了——最低层、贫乏、黯淡、自卑、平凡、卑微、能力有限这许多不正确的定义来形容自己。<br />以我个人的经验来说，我也反复思索过许多次，生命的意义和最终目的到底是什么，目前我的答案却只有一个，很简单的一个，那便是“<strong>寻求真正的自由</strong>”，然后<strong>享受生命</strong>。<br />不快乐的女孩，你的心灵并不自由，对不对？当然，我也没有做到绝对的超越，可是如你信中所写的那些字句，我已不再用在自己身上了，虽然我们比较起来是差不多的。<br />如果我是你，第一步要做的事是加重对自我的期许与看重，将信中那一串又一串自卑的字句从生命中一把扫除，再也不轻看自己。<br />你有一个正当的职业，租得起一间房间，容貌不差，懂得在上下班之余更进一步探索生命的意义，这都是很优美的事情，为何觉得自己卑微呢？你觉得卑微是因为没有用自己的主观眼光观看自己，而用了社会一般的功利主义的眼光，这是十分遗憾的。<br />一个不欣赏自己的人，是难以快乐的。<br />当然，由你的来信中，很容易想见你部分的心情，你表达的能力并不弱，由你的文字中，明明白白可以看见一个都市单身女子对于生命的无可奈何与悲哀，这种无可奈何，并不浮浅，是值得看重的。<br />很实际的来说，不谈空幻的方法，如果我住在你所谓的“斗室”里，如果是我，第一件会做的事情，就是布置我的房间。我会将房间粉刷成明朗的白色，给自己在窗上做上一幅美丽的窗帘，我在床头放一个普通的小收音机，在墙角做一个书架，给灯泡换一个温暖而温馨的灯罩，然后，我要去花市，仔细的挑几盆看了悦目的盆景，放在我的窗口。如果仍有余钱，我会去买几张名画的复制品——海报似的那种，将它挂在墙上……这么弄一下，以我的估价，是不会超过四千台币的，当然除了那架收音机之外，一切自己动手做，就省去了工匠费用，而且生活会有趣得多。<br />房间布置得美丽，是享受生命改变心情的第一步，在我来说，它不再是斗室了。然后，当我发薪水的时候——如果我是你，我要给自己用极少的钱，去买一件美丽又实用的衣服。如果我觉得心情不够开朗，我很可能去一家美发店，花一百台币修剪一下终年不变的发型，换一个样子，给自己耳目一新的快乐。我会在又发薪水的下一个月，为自己挑几样淡色的化妆品，或者再买一双新鞋。当然，薪水仍然是每个月会领的，下班后也有四五小时的空闲，那时候，我可能去青年会报名学学语文、插花或者其他感兴趣的课程，不要有压力的每周夜间上两次课，是改换环境又充实自己的另一个方式。<br />你看，如果我是你，我慢慢的在变了。<br />我去上上课，也许可能交到一些朋友，我的小房间既然那么美丽，那么也许偶尔可以请朋友来坐坐，谈谈各自的生活和梦想。<br />慢慢的，我不再那么自卑了，我勇于接触善良而有品德的人群（这种人在社会上仍有许多许多），我会发觉，原来大家都很平凡——可是优美，正如自己一样。我更会发觉，原来一个美丽的生活，并不需要太多的金钱便可以达到。我也不再计较异性对我感不感兴趣，因为我自己的生活一点一点的丰富起来，自得其乐都来不及，还想那么多吗？<br />如果我是你，我会不再等三毛出新书，我自己写札记，写给自己欣赏，我慢慢的会发觉，我自己写的东西也有风格和趣味，我真是一个可爱的女人。<br />不快乐的女孩子，请你要行动呀！不要依赖他人给你快乐。你先去将房间布置起来，勉强自己去做，会发觉事情没有你想象的那么难，而且，兴趣是可以寻求的，东试试西试试，只要心中认定喜欢的，便去培养它，成为下班之后的消遣。<br />可是，我仍觉得，<strong>在这个世界上，最深的快乐，是帮助他人，而不只是在自我的世界里享受</strong>——当然，享受自我的生命也是很重要的。你先将自己假想为他人，帮助自己建立起信心，下决心改变一下目前的生活方式，把自己弄得活泼起来，不要任凭生命再做赔本的流逝和伤感，起码你得试一下，尽力的去试一下，好不好？<br />享受生命的方法很多很多，问题是你一定要有行动，空想是不行的。下次给我写信的时候，署名快乐的女孩，将那个“不”字删掉了好吗？<br />你的朋友三毛上</p></blockquote><p>这篇回信给我最深印象的，就是<strong>在这个世界上，最深的快乐，是帮助他人，而不只是在自我的世界里享受</strong>。实话实说，我并没有那么高尚的境界，甚至以前很少想到这一层。不过非常幸运的是：关于寻求自由与享受生命，我与三毛达成了一致。有了思想的指导，方法自然不会成为障碍，信中提到的做法会带来改变。<br />好久前看过李健的一个访谈，他说在任何时代，自我价值的实现都是很重要的，过好自己的生活，成为生活的艺术家是最难的事情，但他一直在尝试。经常性地关注村上等人的生活状态，极度追求个人自由与价值的实现，但是忽视了the big picture。当然村上自从《地下》以后，改变了很多。<br />这些对我个人价值观的塑造都有很大的影响（大概就是读书的好处吧），所以我一度认为生命没有意义，你做的一切，或者说人类做的一切，都没有意义。那么为什么还要去做事呢？是因为总得有事情去填充我们的时间。做好当下的事或者虚度时光，结果是迥然不同的，将来回忆起来很多事没有体验，岂不肠子都悔青了？<br />真理总是很早就学过，却很晚才明白：</p><blockquote><p>人最宝贵的是生命，生命对于每个人只有一次，这仅有的一次应当怎样度过？<br />每当回忆往事的时候，不因虚度年华而悔恨，不因碌碌无为而羞耻。</p></blockquote><p>前面说过，这是一道有着无数种解法的题目。每个个体想做的事很多，不过共同之处在于：do it，千万不要因为畏惧而放弃、拖延，当下只有一次，永不会再来。在认真体验、洒脱生活、享受酸甜苦辣的同时，记得帮助别人。<br />戏剧之处在于：如果读者只看过《撒哈拉的故事》，没人会接受三毛最终的选择。物质生活那样贫瘠的非洲，再加上常年患病的身体，都没有击垮她。相反，她将平凡的日子过得如诗一般，幸福早已溢出了文字，哪怕结婚用香菜代替鲜花她也津津乐道。就是这样一个善良自由、追求自我实现的人，荷西的死却成为她生命中无可挽回的拐点，也许浪漫的人很难有好的生活。再去看《梦里花落知多少》，你可能无法相信这出自同一个作家之手。<br />痛失挚爱，无异于晴天霹雳，但我想大多数人都会渐渐走出这份悲伤，只是时间长短不同罢了。感性的人很难自拔，会沉醉过去，也会幻想梦境：</p><blockquote><p>记得当时年纪小<br />你爱谈天<br />我爱笑<br />有一回并肩坐在桃树下<br />风在林梢鸟儿在叫<br />我们不知怎样睡着了<br />梦里花落知多少</p></blockquote><p>那种语调，并不是刻意地悲痛，好似一切都变淡了，当然也包括生死，三毛不断提醒自己要有责任心，还要照顾父母，如此目的很难维持得下去。<br />我们慨叹命运弄人，每一丝幸福，都可能是若干年后的一场悲剧，因为开始就会有结束。而且快乐往往是短暂的，就像它的字面意思一样，平淡和普通才是人生的主旋律。</p><hr /><ul class="task-list"><li><input type="checkbox" disabled="" />不知怎么搞的，可能读书越来越少、手机越玩越多的缘故，也可能书单过于单一，总是看些小说滥竽充数，写一些人文类blog总是力不从心：不论是行文思路，还是写作手法，直到最后的自我表达都十分混乱，而且遣词造句多有贫瘠累赘之感，甚至还不如小时候来得自然和丰富。别无他法，只有大量阅读思考才可能改观，希望每天都能静下来读会书吧，先看看中国现代文学@-@</li></ul>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Garbage Collection</title>
      <link href="/2020/07/10/Garbage%20Collection/"/>
      <url>/2020/07/10/Garbage%20Collection/</url>
      
        <content type="html"><![CDATA[<p>垃圾回收：为了防止内存泄漏，对<strong>堆</strong>中死亡的对象进行清除，并回收相应空间的机制。<br />某些有GC机制的语言(Java, Python...)，平时不会特别在意内存的分配和释放。但是对于C/C++等语言来说，稍有不慎就会造成Memory Leak/Double Frees/Use-after-frees等问题。</p><h2 id="garbage">Garbage</h2><p>垃圾顾名思义就是以后不再使用的对象。但是要确定一个对象是垃圾通常很难，所以我们认为不可达（没有被引用）对象就是垃圾，但是需要明确的是：许多可达对象也不再会使用，也是垃圾，但是这种垃圾我们无法回收，所以即使拥有GC机制的语言也很容易造成内存泄漏。</p><h2 id="reference-counting">Reference Counting</h2><p>C++的<code>shared_ptr</code>主要采用引用计数法，实现简单：<br />每个对象都与一个引用计数器<code>cnt</code>相关联，每当有一个引用指向该对象，<code>++cnt</code>；一个引用失效时，<code>--cnt</code>。当<code>cnt==0</code>时：Remove all outgoing references from that object，并且清理该对象。</p><p>由于每个<code>cnt</code>记录的是引用数，而不是可达的引用数，只关注自己的对象而没有全局的信息，<strong>循环引用</strong>的情况就无法被回收：<br /><img src="https://img-blog.csdnimg.cn/20200705104719124.png" alt="在这里插入图片描述" /></p><h2 id="mark-sweep">Mark-Sweep</h2><p>Lua/Ruby等主要采用Mark-Sweep算法：<br />有一些位置是明确知道可达的：全局变量、栈中的变量以及寄存器中的变量等，这些区域作为root set，从root set出发可达的对象视为存活对象，不可达对象视为待回收对象。</p><ul><li>mark阶段目标是找到可达对象。<br />-- 将root set中的对象放入worklist；<br />-- 当worklist不空：<br />从worklist中移除一个对象；<br />如果该对象没有标记，标记它并且把从它出发的所有可达对象加入worklist。</li><li>sweep阶段目标是回收死亡对象。<br />-- 对于<strong>所有已经分配的对象</strong>：<br />如果未标记，释放；<br />如果已经标记，为了下一次的GC，unmark。</li></ul><p>有时候确实很难想象如此简洁的设计竟然是Lua 5.0之前采用的机制，不过工程上一条重要的原则就是：<strong>先完成、再完善</strong>。这个比较简单的GC实现过程可以参考<a href="http://it.deepinmind.com/gc/2014/03/26/babys-first-garbage-collector.html">自己动手写GC</a>。<br />这种Naive的方式虽然简洁，但是却有很大的缺点：即mark和sweep阶段必须一口气执行完毕，不能分步骤进行，结果就是在进行GC时其他线程都必须挂起，也就是通常说的Stop The World。<br />原因在于：假如在mark完成后，新创建了若干对象，这些对象显然没有被标记，在本次的sweep阶段就会被清除，造成无法挽回的后果。</p><p>为了改进上述算法的时间和空间性能，Baker's algorithm应运而生：<br />每个分配的内存块只能属于四种状态之一：Marked(可达)/Enqueued(in the worklist)/Unknown(未处理)/Deallocated(已释放)，维护4个双向链表保存4个状态的对象。</p><ul><li>将root set中的所有对象移入enqueued链表；</li><li>当enqueued链表不空：<br />-- 将enqueued链表的对象移入marked链表；<br />-- 对于unknown链表中的被引用对象，移入enqueued链表。</li><li>合并unknown链表和Deallocated链表并释放，耗时<span class="math inline">\(O(1)\)</span>；</li><li>将marked链表中的所有对象移入unknown链表，耗时<span class="math inline">\(O(1)\)</span>。</li></ul><p>这样时间复杂度优化为runs in time proportional to the number of reachable objects.</p><h2 id="generational-gc">Generational GC</h2><p>分代收集的核心思想是将内存划分为若干代，每次新的对象总是被分在新生代，新生代没有空间时，做一次迅速的GC，之后将新生代中剩余的对象移入next generation，实在没有空间可用时，对整个内存进行一次GC。<br />Java的GC就是基于这种算法，新生代分为Eden和Survivor：<br /><img src="https://img-blog.csdnimg.cn/20200705145530733.png" alt="在这里插入图片描述" /><br />开始的分配都在eden中，满了之后做一次GC，将留下的对象移入survivor浅色区，具体过程可以参考文献中的200页。</p><h2 id="具体应用">具体应用</h2><ol type="1"><li>Python的GC主要结合了引用计数和分代回收2种策略，当对象的引用计数为0时立即回收该对象，如果出现循环引用，则等待分代回收算法清理该对象。</li></ol><h2 id="reference">Reference</h2><p><a href="http://web.stanford.edu/class/archive/cs/cs143/cs143.1128/lectures/18/Slides18.pdf">Garbage Collection</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Annotated STL Sources</title>
      <link href="/2020/07/03/The%20Annotated%20STL%20Sources/"/>
      <url>/2020/07/03/The%20Annotated%20STL%20Sources/</url>
      
        <content type="html"><![CDATA[<h2 id="intro">Intro</h2><p>《STL源码剖析》用来了解原理性的设计没什么问题，但是这本书实在太老，所有源码基于GNU2.9；现在语言的发展飞快，而且很多地方都是考虑兼容性等因素，设计非常复杂，也并不高效，我没有时间去搞明白所有实现，更没有时间实现标准库，所以只学了一小半就停了。</p><h2 id="六大组件">六大组件</h2><p>容器、算法、分配器、迭代器、适配器、仿函数。<br /><img src="https://img-blog.csdnimg.cn/20200423140448163.png" alt="在这里插入图片描述" /></p><h2 id="allocator">Allocator</h2><p>分配器用来为容器分配内存，分配器是class，有成员函数<code>allocate</code> <code>deallocate</code>，调用<code>operator new()</code>会调用<code>malloc</code>，<code>operator delete()</code>调用<code>free</code>。<br />不同编译器的分配器实现稍有区别，不建议直接使用allocators，<code>int* p = allocator&lt;int&gt;().allocate(512)</code> 会创建临时对象，归还还要指定大小：<code>allocator&lt;int&gt;().deallocate(p, 512)</code>。<br />但<code>malloc</code>归还时不需要指定大小，因为<code>malloc</code>时候会有<strong>cookie</strong>保存分配的内存块大小，如果每次申请内存都包含cookie的话，开销太大，并且频繁申请内存十分耗时。<br />GNU2.9觉得allocators太傻逼，自己用的是alloc的分配器，有16个单链表，每个链表负责某个特定大小的内存块分配，比如8B（该链表串了很多8B的小内存块），16B，...，容器需要内存会被调整到8的倍数，去相应的链表找，如果链表没有小块内存，就会调用<code>malloc</code>向OS申请一块大的，切成很多小的，串起来去分配，这样<code>malloc</code>次数会变小很多，而且cookie会少很多，时间和空间开销都会变小，碎片也少了。<br />GNU4.9没有使用alloc，使用<code>std::allocator</code>，allocator继承了new_allocator，有成员函数<code>allocate</code> <code>deallocate</code>，调用<code>operator new()</code>会调用<code>malloc</code>，<code>operator delete()</code>调用<code>free</code>，一夜回到解放前。。。<br />4.9有很多扩展的分配器，2.9里的alloc变为了_pool_alloc，要改变默认的分配器，可以写<code>vector&lt;string, __gnu_cxx::_pool_alloc&lt;string&gt;&gt; vec</code>。</p><h2 id="list">list</h2><p>双向环状链表，end指向一个dummy node。<br />因为非连续，所以<code>++iterator</code>要重新设计，使得指向下一个元素，而不是错误的地址。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev; <span class="comment">// 4.9 struct __list_node* prev</span></span><br><span class="line">    void_pointer next; <span class="comment">// 4.9 struct __list_node* next</span></span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="comment">// 5种associated types</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer; <span class="comment">// 4.9 typedef T* pointer</span></span><br><span class="line">    <span class="keyword">typedef</span> Ref reference; <span class="comment">// 4.9 typedef T&amp; reference</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    link_type node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 操作符重载 */</span></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    <span class="comment">// 前置++</span></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        node = (link_type)((*node).next); <span class="comment">// 指向下一个结点</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置++</span></span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>; <span class="comment">// 记录原值，拷贝构造</span></span><br><span class="line">        ++* <span class="keyword">this</span>; <span class="comment">// 操作</span></span><br><span class="line">        <span class="keyword">return</span> tmp; <span class="comment">// 返回原值</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line">    <span class="comment">// typedef __List_iterator&lt;_Tp&gt; iterator; 4.9模板参数只有一个</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="vector">vector</h2><p>1.5/2倍增长。<br />迭代器只是一个指针，而不是class iterator，通过萃取机（Iterator Traits）中对类型的偏特化处理，可以回答算法提出的问题（iterator_category,value_type,difference_type,pointer,reference） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>)); <span class="comment">// 建立一个元素，并以最后一个元素作为初值</span></span><br><span class="line">        ++finish;</span><br><span class="line">        T x_copy = x;</span><br><span class="line">        <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">        *position = x_copy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        iterator new_start = data_alloctor::<span class="built_in">allocate</span>(len);</span><br><span class="line">        iterator new_finish = new_start;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将原vector内容拷贝到新vector</span></span><br><span class="line">            new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">            <span class="built_in">construct</span>(new_finish, x); <span class="comment">// 新元素设为x</span></span><br><span class="line">            ++new_finish;</span><br><span class="line">            <span class="comment">// 拷贝插入点后的元素，可能被insert调用</span></span><br><span class="line">            new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">            <span class="comment">// commit or rollback</span></span><br><span class="line">            <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); <span class="comment">// 析构释放原vector</span></span><br><span class="line">        <span class="built_in">deallocate</span>();</span><br><span class="line">        <span class="comment">// 调整迭代器指向新的vector</span></span><br><span class="line">        start = new_start;</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator; <span class="comment">// T*, just a pointer, not a class iterator</span></span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    iterator end_of_storage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">            <span class="built_in">construct</span>(finish, x);</span><br><span class="line">            ++finish;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="deque">deque</h2><p><img src="https://img-blog.csdnimg.cn/20200424213635414.png" alt="在这里插入图片描述" /><br />The data is stored by chunks of fixed size vector, which are pointered by a <code>map</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">    T* cur;</span><br><span class="line">    T* first;</span><br><span class="line">    T* last;</span><br><span class="line">    map_pointer node;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="comment">// BufSiz == 0表示使用默认值</span></span><br><span class="line">    <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line">class deque &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="comment">// BufSiz指每个buffer大小</span></span><br><span class="line">    <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> pointer* map_pointer; <span class="comment">// T**</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    map_pointer map;</span><br><span class="line">    size_type map_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">        <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> *tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">            <span class="built_in">push_front</span>(x);</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;</span><br><span class="line">            <span class="built_in">push_back</span>(x);</span><br><span class="line">            iterator tmp = finish;</span><br><span class="line">            --tmp;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cycling Summary</title>
      <link href="/2020/07/01/Cycling%20Summary/"/>
      <url>/2020/07/01/Cycling%20Summary/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9717ce7262c2b315264dfde5a42ece4db151d99f43a364258ad4cc48a9cbdfd8">418fac4f173397084caccc18ab9f089ed4cc3b41a07fb777d9ddd6d7c594ab8006d22591efcd33984d37648dc6a70cbb9b06b6688388bee76945558f8e9bedb0fccc07b7f7589d74e3762391f559e58d77280f7235d29c87910ac416b8eeb4dbbf37b5223c812bff46aa60a7fcde7ea843a689d48e0d1ab9f7c05534beab1c7ba7cbacc6f5e30230ad2bf71e0dbec4926ddbe109e84ff2c0f7a874949231671afc4597fd549081fbfde54481babc0660342e297cef0f40dd5a38ead508c52a5671c87a44a4b88656e5ec82e6dea19700041465aefd40accdf24e831a630181fd33046b8c7adccbf97ffa5d061c402ce7c24f574c3eaca8d1bcb5371905d3fe0f54512963348d6a0d9bb8e93a0cce5c3a88a6000e1cafdde71bb37bd78e538c625f57e8634e8008eaca3d1fdfdcf3422d68c908bd193207ef554448b5cb1daca5e1683916330d60ae61d17bffcb1ec00db1884b17b617f22f2aa76f15dfeccdcdc17e353e6040135445c3a4aed801f5805414e92abcdb8843af22698a26a5bd964e55997df1382701874b2f0cb8a7b616cdbe96b51f6326c69c3a8cf2e728fc64a0ee2b9c1cf2f1638af480a413e3a2a48368cada92e71f79e33b33a889b993541df18d4023dbbd6c3480f6a5ec20a045159e3a3de52f7d90a70400841a93354fd64e08d0b0d816c810882509f20133c29676acc1a6a88335c4b6a229d1d700cc6b6a9e3046937ed1c6c107c829b9b048e9122f2bb9e65f1f324dcd2f94afcd1e494d879d805cc5ebc35d65195786810fe2c2ffbaef45a61cd37dd16d26a6eac0b4b298168c1f197b1d0efb5d80343f05aca01b26c2e81bb7c167f97bd02053c76e82f1e5e2ef49045abb845ee9280efb87423f653b6f35c75dc27cbc750dc2c0989e14a466122619e4df41998885f15dde740c918b659784a2c526ac9fa8d986266c92fc097b98c0fd2e3d7ed93583f57c1e57b60ba8fe49e0bf30cc077c23d180a82b03b3bf864d6c069be3389345dd105329829f5968f1ea22ea68c2845de09127405a3b6ab57254469c0629f4190d12f1561dbf95c24c93596b7f8be0bdccd84bf6a5cff1f5e54da23c7904e097a486dd0ae235444abeb36f00bd5c3c21a344fa7f8aedff188dd9b009115b3db44e4e2beeaa4e401a4ec461acd8ab0c1310c596c80933b0116d32b6ca49e2c97ca6ce0b9d459ef2a884d2dd00da736f468c433ce905eb15622dc4fa9f8c7ff9d0222006a6ec837c17b2817d94812a13771a5496481a4060e70158c11c0321db2cb1d8e06fb3ab945eae4ff1f145ef13a9bfcf2464a4549cde91f904230c823fcaecb9b6706aa9adf011ac163d4c767e92d0a40196db9e6674fbf2dbb1e4170e2bb3ab3664250e733be33aa09f1b2071e868301699e3e88e0d5aa1912b2f36b6c92989f005bace5c423174940847cd33aa7082278f24732f8983c8e56777c97c61ac099b07469aebb862799f876e2d90c96efe40fae43ba6edfc679360f63cdcea9e0aac91315cc7a9bf5e97d313f189c6e984479ebb7b78430a16640c8c0116dcb47a20b3bfd7a3971e84ac0479b2dcd79d18c8b7a238e08445d4eadffdb027bd02a696b46a73e4b6e64deae10f1542ba865b4e34d42111ce0d4bc8e13e85e6af4963452938123af5d97a51e21c720fd0daf83d3cee6f0d0b5f7968d6f1dcc6c931ffd5e056c85fa8a8213345fff386cf0a07beaa2444c514559f2a3fbd22be1db5925a15e2d54d1d3b1569be1b12c5307f079fd89288c33bc9f93bc18c5e713ef12ca968d9b815868e82c95cab646a9b788069e337efe2ee7186db8554e1e1213bbe60bd60146ca30d63e70676968d3ed0028878a60bda2056625ea2e3787e65f1a9366c4297e39818304347fdd74e9537d64dcf33a62a455f2ba9a991f401b019585888e242d34877a16bee3d31535a2d43145bcfa8d4d60b517d4a8e7d06ae14a6d9d849a9fcd18d3e1888a6a86ed123fb473328961d37fc2ffff7be2aeb09c80adc05a5ab12d2f28be6c5453b0508048838e86d81eb116ab8bd956d48593a89a36339793991bd200b728254159938174678f726de0cca3f1c500c9ce13e1ae6fb66db507d3384d27c033bdc857ceb1426d8b1e08e74e99cd6475352b0b0b41b6e81bec6dde2061a60835550534d6fba2384dc172e10148e7f1a9f26ba6326709e84c753949bdb62c988b69f9af0f7b841ce37562eb64ec861699a43db447749706b910ecf75095210bcaa10ee91eed12a47a1f75348e47048af08314442e842a0aa25653765b4511cd0631002deaf10d91141328677b3015a06ad84a3b1c6b94eb8f9219edc87fde8de66a41ae5b20ed9b25b7d5c4c8af2035937264e0204ce54e0baf7607962f33dfee152df80fc9049e233488654ba37bceee33e42dd273fa13ea9f5dec863232fa545b105e3f054c5ef188db163c833cfc8317b65d064144510ce64a1c576522e09797348909fa9f431fd5adb4e7352ce9df44505df7127e66565bdb6b53370186beb4e4596656b6e141c72c51d125ead9f4ec12eb26c4212298458d1f334f1fa47330c8c750152897291fd95ad7927581d53928b1f182e0457be1ea21fb12efc7d7d5133a71ddbba39d6f8f79be8df33e72dc63017466d437382034c72c83a9405eac41a1050d421f9e002ce4c7b9c8d93b248e03b295ed1e7df0d5877dbe086ec012e3c8d397a07ac1488836668744a8c162055b934f43bbf9c5bfcb43ae77e6c5f1f464509bec477efd30c7cf72970b9cfe3397c26439786fe7e481b4945ad210bd7cdf8c4117cc9976ad29f26db63910cd414caa2765a8beeb588b78ef0b1b505ee7e10ea88d545993663f5b0d7445cf69e6f6e2410d1927b365f23864698c28d17e7960284bdf127df7146144eac214cf86f0a5df0b28569afc3b9dd49447409ee9de7f233983ccd09403df3514d05ea410be887d4ed79cf18afbe829ddbbaf5c7874063e47006fecc45ad2cac9135409183937c1ea290bfc14abcdc2095921693f57212deee76327e58e2c42bb0f3b00dd48dc61e7cfc893efad3dfa222a17e5dd09ac404d80fed09f734ed05459d2e63e959b35c815e4df9ee42973cb338c2b55543d8cd429711726fa9e0dff17fdff1449adee9b2a0f477c65925f6965196a00dbd6cf13724068dd7d561fc737a39edd954eedb7552805d1ef903b0113a10d35e8f0d9f087fff26ea8b18c602b62ed098e1d235a7756dea0d93a88a47cb41afc86bb8381b0c637c0d6fd7f08946a36286cfcae28ba39a1231c33e8d0630bc775efe6b70bc9e24a05770d11b7d8393ab413e3b7ffd950711ea42cf43b028882ef6273ab8ca9aa0701df83b4af1eb6c95da268afe583fdae7f9a68cbd1db0bf8fe8f2abdeb89f72bff6ede80190237ee50abc313e58a468113037f0babc122ec43d0f380d3fa5a8574d6b67c9e10920d8c87fd71e49b8e904800c3a71eea62602dfc43f57eab6ffd94e8242d4b80d200097a74aa2948de4e4a0be1e8704e114b8bf374446e7960e8c96559a821e850be42dc91b587fcd7d3c9e5cdee14da4e3855f912a7455abef90dfdd7164a5e5b39c124cda9350c1988848a9ef8b789bc1ace943cb573bf0b880f8682208b4713b6460732b791f9a4ece29f9238bd4ed120cf3503bdb419bc40d504a57a7a218fa0e82a5d4bfbc57ea1bb1d42d9903a8345c50fc8de951916b021b275362c587525698a7150bedc041de860c26806cd8555cb7f78d7ac2ea66a81954a2a8fef31ab628cb76df28b297b8332c53a1acc164f70045b23455310faa65cfa3bac5498121cb9c727159fb18d2a49a22e5fdb7f7f1e45a114c7386b16b51a6a94989f4a7c624432dd49da6a535f77287e24402c558534e4c315f328c9a400d061eb29d356967ca9acf61d50d98764d232da9afdd44e840c3c788a92c4a420e0e7713bae57d21a6a2e2e69c233a3162678aada00dc4d8299bd5ba774c97347119c12a8c7596232b9441f84138ce317ef525653046a2ff81356a60762bc5909ced189cfd6949e344e41ed6b8f3f1998d2b731c1b2bb999bf618b92c97bb4faae25a6bc5cd21de47ca87dc9f9fdedda7f94d4f84ee01e1de894e571590c851c5e02f37c95ee7cfda9ea7dc9d4162d2dcb3846a826b5861dd09983a72bbc2cb92ce9680a7feaebc5ac8f1072eb04321ad9eb183f667b0718efab8f3d8e4999bbf533fc43dc0b9737140a5ded0ded39a1046837e4746b135c7992885fab73f4c1350f91ed6a866bb902ad4dcd8ebbad46309934bdabf2c740ade42efdddbd23465af972d6da94028b62359d58e9402413174f94280003e587284ed4096dacc3fe2ac91192156e9e771c17d8b4b73ec9b284318ea70b76539a4e5b5777e703e7ac48de939bdacbe52e51c3c29278b9994f903f47faeb0acb30f823d31461d4c15564ef189dd4a5bfdce00f636804c0fca6bda192d3be43326987124bf5fe199e50957c8634cb2c9d5a802f2f7b8506de3ba361cb0675fb2942a0672c7060e3c8f4d5506c0d79886e6cf38a7197f61efa85e29fbb53ad15ad304831ca0928f98ac425f8e4f0efa9c4ccbff3c45243f9c2dad306bba0f5e0bfee47d7f323da2f6a66c0add92b5842a7e6385ccddb2184ef1e4a642240518b6cb330153c970b8929cb30de907a5460dd5d1e9b7208287bda753d1c7943968ec61d42074c1f07c48bc0d39d74050ee9f1b83323ccc4450d173411e5b4fb79abb953db24a089520537a1016393b3769eb40443f15b7bf3af774ac2ee26a8ba145daec1ffdd837ad1a0b2e0c04110c2e153d9c2bbdb03f7600258f3c1f50a96c8e1b514774d477711308517fd0d86d16ea84c91fa44d85b35df9d24b766bcad5df1c96f822101b6f02610246fa016ee8818f1676e62280744ae7dfea39e012178a4519c2b0cb6621d89d7bfc906f05cf9319fdeff7f85c96734a281a79ac440769d1a005bf3e96e5c2b90f5da134ffa6503451697259d76c60e832943e1171e7b0c41aaa6cc9aebba642d1467c6608f7111809f7571fea83dbf2de2e0098e8069110f115547a1ee6e6fe78f432c8ff10366203168ba72ece8658d18eefa95f20ba7d8866586bf1fd976cbbd0d7b614b61d116b16b137e44cafaf5900a1a30fbe190abf2a1c8e871a3148c435ffc56ff729dbb648057f1d90dfb80dcff2dc810534c822f8c98346f88e3e27b33645f60be86a2613e1cd6fb37407945b080c2befa45e110c8397471fcd6c4f144db3eb444363f303441c8967ea7a9bb38a08906070912608d364b8f117658191ec636ae24c325872bfe5f77d666fe83013613673c69bfb9670e7581699466ecc3b991cb946cbffab0fd48eca31b4dc23966dddbcfe11c8b4d38f2bb90f79e160de11b4e936dbdc95725bf3ddb0b6b7a62b60426cc09a936673bb8b9cc4d0930ba6f26dc668e3b116629c343025e7ddc6e754f00dbaffb55d82259f7f90b7a302a94b6a2fd70bf210fc1dc79a045cab06a87ea0017a312def05f97c08ef6e48aa132160912cae7fc2c9dbd6e5bca431f0051d04bf5bad35ca49df178f5c7bb9bb3ae4b85ef78269e429761971ff0ef4637a3281685053ceebafb763c38735f8c7aae2502dd6062aae17af64b818187b37997e1ae87869f54318714cf59c922829220aaff96a1ae76eed4a3895360ee88eb60fff5ac7c27c08e1d93deb294abc09bb3c165a9597798195dc1007c4ca16d709124bad97fae3799302a0e19c065a160901a9699e9ef45395b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Percolation</title>
      <link href="/2020/06/15/Percolation/"/>
      <url>/2020/06/15/Percolation/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>这是CS 61B的HW2，具体实现<a href="https://github.com/EIMadrigal/CS61B/tree/master/hw2">在这里</a>。这个项目是要模拟一个渗滤系统，最终目标是要通过蒙特卡洛方法计算出渗滤系统的阈值，主要会考察对并查集的使用而非实现。<br />渗滤有很多应用，比较重要的就是复合导电材料：刚开始是绝缘体，将金属作为导电材料逐渐掺入，填充到某临界值后，金属会形成一条导电网格组成的路径，完成从绝缘体到半导体、导体的转变，该临界值就是所谓的<strong>渗滤阈值</strong>。<br />模型是一个<span class="math inline">\(N*N\)</span>的网格图，每个格子有打开和关闭两种状态。如果一个格子是打开的，并且可以通过相邻的某些打开的格子连接到第一行的打开格子，那么该格子的状态就是full。如果最后一行有格子是full，那么系统就会发生渗滤。对于前面的例子，如果金属材料能形成一条从上到下的导电路径，那么就发生渗滤：<br /><img src="https://img-blog.csdnimg.cn/2020061309400433.png" /><br />我们感兴趣的是：如果<span class="math inline">\(N\)</span>足够大，每个格子独立，并且打开的概率是<span class="math inline">\(p\)</span>，那么会存在一个阈值<span class="math inline">\(p^*\)</span>，当<span class="math inline">\(p&lt;p^*\)</span>时，系统几乎不可能发生渗滤；当<span class="math inline">\(p&gt;p^*\)</span>时，系统几乎一定发生渗滤：<br /><img src="https://img-blog.csdnimg.cn/20200613094728545.png" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/20200613094740884.png" alt="在这里插入图片描述" /><br />我们的任务就是估算这个<span class="math inline">\(p^*\)</span>。</p><h2 id="渗滤系统建模">渗滤系统建模</h2><p>模型并不复杂，写一个类<code>Percolation.java</code>专门模拟该系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percolation</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Percolation</span><span class="params">(<span class="keyword">int</span> N)</span>  <span class="comment">// create N-by-N grid, with all sites initially blocked</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span>  <span class="comment">// open the site (row, col) if it is not open already</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span>  <span class="comment">// is the site (row, col) open?</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span>  <span class="comment">// is the site (row, col) full?</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfOpenSites</span><span class="params">()</span>  <span class="comment">// number of open sites</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">percolates</span><span class="params">()</span>  <span class="comment">// does the system percolate?</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>难点在于要满足规定的时间复杂度：除了构造函数是<span class="math inline">\(O(N^2)\)</span>，其余方法都必须是<span class="math inline">\(O(1)\)</span>。<br />如果采用常规方法判断是否渗滤，那么至少也要遍历最后一行看看有没有full的格子，这样时间<span class="math inline">\(O(N)\)</span>无法满足要求。<br />问题就在于第一行和最后一行的格子数太多，减慢了我们的判断效率。那么如果我们在最上面和最下面设置两个虚拟节点，事情就会变得OK：<br /><img src="https://img-blog.csdnimg.cn/20200613110636913.png" alt="在这里插入图片描述" /><br />virtualTop负责连接第一行所有打开的结点，virtualBottom负责连接最后一行所有打开的结点，这样我们就把<span class="math inline">\(N\)</span>个点浓缩成了一个点：</p><ul><li>判断某点是否full时，只需要判断该点是否和virtualTop连接；</li><li>判断是否渗滤时，只要判断virtualTop和virtualBottom是否连接。</li></ul><p>这种解决方案看似很完美，但是有一个问题Backwash：<br /><img src="https://img-blog.csdnimg.cn/20200613111558820.png" alt="在这里插入图片描述" /><br />如果已经有一条从上到下的路，那么水流可以通过virtualBottom回流到最后一行已经打开的格子，而这些格子本不应该full。<br />这个问题的解决有点tricky，开始我是想通过周围格子的状态来判断是否full，即只有周围四个格子之一是full，当前格子才是full。但是如果要在<code>isFull()</code>里递归调用去判断周围格子，那么一定会爆栈；所以要判断周围格子只能通过是否和virtualTop连接，但是只要这个打开的格子在最后一行，就一定要和virtualBottom连接，如此一来只要有其他通路，那么该格子必然还是backwash，进而就会导致其它和该格子相连的也backwash。<br />举例来说：假如右边3个蓝色格子从上至下编号123，先打开3号，3号周围四个格子都没有和virtualTop连接，因此我们认为3号没有full，这没问题；但是接着打开2号，2号下面的格子（3号在最后一行且打开，必然和virtualBottom连接，即也和virtualTop连接）是和virtualTop连接的，因此我们判断2号是full，这显然错误。</p><p>没法用逻辑优化的时候，就应该转向用空间去优化。我们可以在开一个并查集，这个集合最多只包含virtualTop和地图中的所有格子，而将virtualBottom排除在外。判断full时，只要当前格子在新并查集中与virtualTop连接，那么必然full。</p><h2 id="monte-carlo-simulation">Monte Carlo Simulation</h2><p>为了估算阈值，需要做<span class="math inline">\(T\)</span>次独立重复实验：</p><ul><li>所有格子都设置为关闭；</li><li>随机选取一个关闭的格子，打开它，重复直至系统渗滤。</li></ul><p>那么这次试验的<span class="math inline">\(p^*\)</span>就是打开格子数/总数。</p><p>取<span class="math inline">\(T\)</span>次实验的平均值，可以得到更加精确的阈值；标准差<span class="math inline">\(\sigma\)</span>展示了结果的波动程度： <span class="math display">\[\mu = \frac{x_1 + x_2 + … + x_T}{T},\sigma^2 = \frac{(x_1 - \mu)^2 + (x_2 - \mu)^2 + … + (x_T - \mu)^2}{T-1}\]</span> 当<span class="math inline">\(T\)</span>足够大，<span class="math inline">\([\mu - \frac{1.96\sigma}{\sqrt{T}}, \mu + \frac{1.96\sigma}{\sqrt{T}}]\)</span>提供了95%的置信度。</p><p>这部分的实现很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercolationStats</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PercolationStats</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> T, PercolationFactory pf)</span>  <span class="comment">// perform T independent experiments on an N-by-N grid</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mean</span><span class="params">()</span>  <span class="comment">// sample mean of percolation threshold</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">stddev</span><span class="params">()</span>  <span class="comment">// sample standard deviation of percolation threshold</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceLow</span><span class="params">()</span>  <span class="comment">// low endpoint of 95% confidence interval</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceHigh</span><span class="params">()</span>  <span class="comment">// high endpoint of 95% confidence interval</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>痛撞南墙才回头---高考五年记</title>
      <link href="/2020/06/08/%E7%97%9B%E6%92%9E%E5%8D%97%E5%A2%99%E6%89%8D%E5%9B%9E%E5%A4%B4---%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E8%AE%B0/"/>
      <url>/2020/06/08/%E7%97%9B%E6%92%9E%E5%8D%97%E5%A2%99%E6%89%8D%E5%9B%9E%E5%A4%B4---%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c298cfe6e2d238ccb3604b8c2042f67d5992e3e039a34381d4d4b3afe28e9368">418fac4f173397084caccc18ab9f089e90c7a29408af94da76702e54e165326bb43445556805a27c488f08cf79be199e14c309af2502a15845831e2a580c02a7d8b2cc490775ec50214754add554f5c2b4b2b21ac9e3435885c63c81f9cef4de973dc4887f3caf6407e9568b59790b0b444a379c4cfcadc3e1c2240322b0b163cc8a1e7f4a98093fc5930f4457af162a0a57efebe0679e68fb31f8baa6a5ccd258936db25fa15fa25b9561000871fe4d0f889e8d03bac66b8444056eb65648579a122bb606631b786fd5df36d13a84ddfdfd3899a608c09092f5fc4b3e599274c58fbe1e0cfeb8a523b2a027a685675ee68466563a0a9df8ee9ae8eb4721e25e05f2ace47fb3943c9bd498e9e6af095ae998125cfb999b82ec06807e5052f8186c4fd9cd0580e38cb1bf3bc6a525e4993af8f5b68292ee42b7c92ac58a8f8724e47fb3a055c87b597b001ab2b25d65183a0f0d9e6b709f6d6128240255077a52f6fbd347b28eb12b4239fa64b3fa0db2aa96c68b065e7b02e54bbd715c445966485ebab893732144707bac46dc36fc93ac20ee8cbc07a20fa34094d08d1736da72a0cc8505e9dfddf7a0232aa79d8d9cee6a19f14bc62e903faec731cdc7ff6ce436de0a42f9ff1abd9974e178af8fa840a712fff2aeffe9efb0aa00d62dbbfc89a8df8878eaa48c56b39b416324311fa5f8918b7d892fbeaf338e741c36b8613481e574848a0b029d2d30d7f10ac5e2ff8c3ac66813d5764d3b86340cc934c1d56a2f8904e51bb99fdc8417139a7556997de3e3b90c58f59697f0af24189126b032bb77c49560bb45126639696da49a78a7bb5a78bbdadeb3b1049416236298773496eb77714a4358dfd2ec68f73db538fc49a8f43634bff5cd271333763bbe72b86a1db72bdef4ad9b6595fa8c86be3a9d89247c30d69bc4e5e1e43b5abc62a9fb0370a8fd8fbcf64dde4c563ffe178874eb094438a62dc661e8b7a290186f68f13611d62c288158b8dbf569e09be2e9e71df1d6f14871a18d3591e49d6361ffe1a48395727e11025a8520cac2eae5a89b1a083bea177379e8b7b745e57ae80dd17006d241148139a4db7a60f3cd6a46ebbb60b09eefa5ff6faa1894bdc9a9cdc0389d6febe1ff76d0e92cb98668e95d6651308e35a782cf1905188f20b16d6f85dfabbce96e21e1178b3f6b040cf60e4f71f82db1c2f3b53372cd068eb9ebecf1062f4017434e6832bf263b94c8ade47760439866f4518580f3db911818af4dc46c5ca06abb9ee6e3118a7a6c8b9ec31ac85cd504b06f76b318e4d8f1dc9051bd05b07d00c26232a31c16a0db9e2a57b49046fae35cc497e2951f49aa4955d5598c31168e0df269cc7eb6fb837c0caa3a1b5c718cc83c0447212e1886361c00d95e732bf0b4481bf057980595b9668184a11751c9adf5eb0494b4f569d3638d06a47f432fc74022f732b9bbd8b8ded2e74b14ba77ee068bef443baed9e5884246ea26e4d250038a93f31a80b4279b3f2f5d6968a4a43e84db38c2a866a92642ebad1be56ab1070b24f945a51fb9aa91eff5ffec5b5a1460a2253ffe6da4a94dfa4e70431edb1e92a8135824afc4260ba5f18a3c559f5d036a52f7e13a1240187ad2f378ba02436ed3be367db3c84ef649b4eaeea59e25323c60f4cddbf228f98885837380fb0ddce517d30bc931db3e231620c56bcc729ddc71a8ec2af75df9f244cb78c35d0e1355aba6325efb7c2b7c087f1836892685bdd44f2fdc3ffd114522edaa7130dd4721e38c028c205a6bfe605daa5a73e21cc6e0759e210eaeb39c2f327949d8fd79acdec347e4605734a385514fbfad19ec3eaa8162fbba599b1a0c1d599a6528e2c4a804d6cf8ecbeaaf81522560693d427cacdc7e88cfdf1f7faffe2e362bbc5c8366713d11a3c3a968974bcba054c1a2816e8b1088138d972b0807deb5e08ae828e692ce81daff004d0eca05d24bb332fea3e33c665d888cf195189e048c8df4eaf33f31029279d119353be118c36d1c879ebce4c48d1d6c646577b2b2b196485d5bdd05c23ae4f431d6b5d5836207f1926d7305f9af39b0f0834c13d2f8162934789bbcb617664f0dc888b82d866a3232b8d9fd0295aa24b2a6dbe45e3f1df8125e04d9e4eeb18f41a3b0d77ad7561e128c59bc62796f35d62eeb27d7c8e25fc6b642dd517376d76380e66d7c7d01fd3b45a0630141b30c8af570047b52f7365216f2e974c45a4d44a06dc4c80d608b721399ddb82156847ddc3a1f59c7c3336b53120da2cadd18a4740e955366505243a7a2ce0dd083fc82f2b56c12db33d8b7eff821ace8552495f41b3a28216ebaeb28db40b3551af3676c7cbad7c328bfaf077ff36efecad15bf73eca1adbfd7604dae8ed84dcb626d09ae66cc8fbc9d7e3b9ebd69cc039abae3c29e10a1ab3a5852dc74ec6cbe37dddb57d80e318f8980c4fc06daf893101dc0c4f4aa3cfad642552b2d8533429ff32e7d7239fa1f77151442f844948944e6f179e7d461f41d0f9d8b6b4d6f7ced169af374e59bf3bf4b1c804c681d6768a832fc977c94173e7d4cc2035f2d54a90129b843bc114f9b75487d6557e142e3618559ee614a60b9e32bfb202a7fdbf67c935aacb4324a81cb76436e9294c406aa331c1e1c07bb490a97316ec22a45a75e6bb109653128036298402b04e14e0074891155c235bb4e2b5ab54a560e999a9a657bbacd3c4f57b4cc1e4517a559a7dd97bb9c9108dc318336f8f20dccdb9296e83b20ef7d27391f7f19a1ca473e72c2959914eed1dad25b5230f9bb1bced9221e91c7b39edf5a547ef0ccbd45ca13568b0c275f3ffcf82cefd3bf86c3af142dbb095dbaaa4e2467ffbff5f5b81f7a88a385c208232ce9fc7b0ef48161bc22e16ddf58ec42029d584df6ba58109717daf3f2d2c0a8c385c660b8d68f9f4dbced6e7317d24740a0917c46f6bec7e3f2af4f9f9a5874c3c3b3b6009ad6b269b08996dc6918eed96c0e4f2dd0674097eb97e409d4517742828289c347ffa8e39572e54186384bd3b4d5cda7d024f484cf52df76dee64c7a9dc15b665b0069233a92b0fb6cb4e3b6c02258046f09c04513e15db20b6a14b82ed120eb3c62eea093821bbbc29805670d6638be4bc7a556f6a05de4db514b4c2f78ea1ff689634a75cd16c0dd827795997b5c879cc5d3be46412574b66a6855a14623440f6156918cbd3e23dd799d27b94f3a1d7eba4575f2aba78eb2d652d076664ef0523fab19e75b5429611927c6ccdba1c3e061ae57a139340b7b6d0ec16cc82088e09473da5046c85461d2132ab6bd8998886a0c2836e0023f0827dd3080b8444dc5d0c857225545e19c9534a4c5b7f3bd7dff01d6c1689d8c4fb672e74ebaac9667b0a6a27fcb8d072759a0815fd2d5e9e5f2990688e7f0174044c525714f93466ef3fbd86c66a68fb3d27d791df0004c24bd4f6383f693d109bf27ddacfc67488bc80774ba60d3da888b288709238f1b0207d14ffe40b9caf13505392a0f128ce781ef1e639e860d052da31ef09850cdb4bbf35f9cbee82039512b495af3aceb4e5aaaf1db1da4ad2918b4cd2e950b3f9f45fd8a0a1bb3de4e5fa6b282f88bfccc1432e730c02cb19f7b714c431a1035b58c85b0dfaef2437b42508071fbf723c4f167054949b4727e697c52e6da6a3c37ffc699eaa6937bfb4a03a6199ddfdeb98bc2cf435130fe82839686e97ea7beed6f052e4daa3a7250f9cd7422dda18828cb11dd11f33c8948f32da773a9335696a6fcdf0e354053f1059665bab58a65544bdcf2aaa657889223134c8b1b9983141ba7f267fe6bf905a4d31ed824c78951128d6f63e705e1bdd3292baf9c88b51042caf7550999d57f3e46f80b815e70cf5a98cd14897bdce75d0c1fe9762ad09f5664aca6227db09dcae624cdcb49be1529c713390c0a61d137e188bae41ec228e2f911c768f7016927aabbdfc209399c2c765dca1fb1606a632dfbd45baf0d5aafa814a73d6a1f2126eb61986c08a3dfa06a43e13c526656147b46c89661083ca36621100a563566c12ba2c6fc0082bcb398e13990cf0fbf419f651391fc9198b119dd9624d54c662190097b7ca2a5c2230e11e66c439ab590156aaf245c9fda36e10428d23f6c0b8e9e597e90992f57c6790bcbd1ef76be1eaed3f41f87cec2ef32360877076f2ce6623ad233f0809a4851ebe398c6c87a6b5362ab366ee4c06877570b8ec0276aad27aa4ea0978adac7c0dcecb0bbb436620f38cb89cfa5408e509e3598b99e43352c056faa7275a336e8fbcb71befb02ab016004c41755408827c8846db663fe54f0d1f406bc474d97c7ba80212b9237035d9eae6038b342c7697011343c10d153867e898a851b2494acb4f371e67af22e0ba62340106de7d0316ef845545cb6a5ef80c49d957c4258753288105bd6fe08ac38189b40818c03ccef38109bd928530c91e97462d921fe6cfc6f79d1a4fb2155c192fa93b5e43961fdb7ecb06aabf30aad91532f49ba6968e3e135a23439a045df03040fa969c0fe5cb2df627f969db4a099a274568703e025d0e85746fc0c837ed8616b86535bd5e6ec2325b3819c32b5938f85d40b172e7762b8c6cc9bcdd73e8e79090d671df05d927a7cc3c113bd889ed5ed4328bff8b55caa7a38a5c2e458a2f31dad6b0dad92ba6744da7d61d1c4f7e9a0b2fc84da4b30afe37156207a42971961b6902a7591cb846be7882fae8ac0c536b4ad55f090dd42069ea689e5278d39ee99429e7117f57672e68a3ba3b0cb17928a4684c416358bf0c0839fba4f4f4a871188eb174a54bd0cd3a83c834569d6374bb6eea68188aa262880b7530397614ed8a14935f665bdff24a6f308ce984463ef602993f962e5ba9ce13bc3e696f382c383a4e9c888de62a1257139c55bbd45f4ab5516e20292a8f52e11848fb6becc8f5a9cb7d8ad062115337f84b3b90fcfc372de10a7316d4a55c4115d2c47bba33b3d00fd69f25014d6eb2de63e7c2b75abc06e6d3e1c540b4df553fa31b562aa0eea2ea85285d313c4e162ec5af1e36a4082c51aac3383e7402cb4a79d1e9aed155b7ea0b0a18612f7e3b2cfa98bd2ec20779878a7818736b4f0895c759052c345255e34e24d7c1c88e492919588fe3af1dab0e92e74755959138add7de6c172e86b0ec4aa8ce50efa8cc45cdf147ed42de5505bc22f8921ee3ff9328f5e4ed921debdf593f0905c57d65a38283734867632192dbf9c9dcb065fc5ee9f0cf16e71ffaf339c68f31d09935d5dac8ecdebfa01df5968f64ab5ac9a099be410dc1605f45391786fc40c93605903c6ab4d50d8ce8ed4836c09b0f6578fdeac8d14b88f8662c2fb9c94a68ad0e065a3be8bb05084a1919a89a3b3cfcec0a5f759c5f3cbc7df940de9231e940a3960df4c413f19fd1434ddf388664477f2af8da105a52d1bca3fccaa17408a35127adfb9888ca120706f345172e0744477967e3c911370fc73264985c6f5a3f75310ec9728850f4d9e0bd22302fec544697bd9a9239daace2ad6982dea4f7f646567a327a0ba9c16de4bfd6be9e90ebe297a2c89b46e7d7b10d3664431d706a3f71d7a60c9b71b927ff57e9c32ddc90cb34e1f6fc8e2a170a9ca049b52e7a96fbc220bade69c48a4182522317cbeb3712762a2f9a3fab5f77943a0569990b0a79773a2e001bd9c0b3dac65578b9c5dda2e02c9397c50d06547171da8e9d241dab378b7bcba3b8713de72a1e98519c11c0424b9b7982fec120494d2289ccef9e4c638c9efa55335acb572fdfa39259173577a2eed22d494aabf833f4ca971dd8d83e265b4b97bf57c132d215958350a028d9bd748aa169c1bfc49cb9eec9b847ab53565a26fa863c0a8b0c8a49ba319f09e29a57b07df7fe2b96022b2c2da7a536fdafea68c3a16137f2c266e0e67f191f35a3ef4ffd0a91476e7363779856466bf38d392467494f7c79243d4908e5bae0ed8ca64cb6ae6250fe79fd3ef17ede84b61d736a6941389ecf8c3aa9a75135d5ed9b8014bfe64cbcef0883c65699f4c9ada1a60651f4266020764345207c4b7bafb4d788544ce75f4b003c7f19c6fd06edf91d4f8a23698c3ee5f3f751fc6427c76b70134f72cf240f24fd1dcda55a3ea060265d76f5449ca076446e7c1df67a4cdabd3722873ad9be959d1befdda08c09c18de44bc3a6ea85daf664883575d733e10c2c1d4d5ca8e1a2e3065d8f3d69752f350a7b0347cf4389a59b7a77f838772a26094b59ac990aa26da4b8528ec88b68d441fa0c25b885b030b01baf78e9dbe4afcc11fb159936a03297963275d1291acb528291c44c99a7adaf88eae0bf9d3b295e01df1482ac7059c9592d859b71fa3dd41c1d9a16a654cd3429551143f8738e5b72ea0584535bf6c7a7f2755f56c031e51c969466bd1a43ecede42c298d2a64a5cda620103085cef00264dd60546d0b85c42b689d68b85606cb743197dc0d745cc0ca14ce6d03dec2152a5e0ae72dc0280900fbd75815a2bc3bbc248e9accddf27710b7f062c5a11c8dc67b13276f230b3bdf769011f96ba0a18825973cd9018f241a87240ad895e1844a1d9aa410a493469b0e1d6cd52da64dbfb139178b5e05a7c65dc83dcc012b49f8dafa405d2655bdd69d266d70e09b7ba30fa11c3da710420d9ad21e79a615ee6e01f86e3b6afdc52da6887d0ca261f5d73407574ce802d48c789540fe0d883303839796320425e99293ebef8adcab6ae64258e39e71eea79a6cae5997b1539b01d187cd931ec02d5dcaa1dde1d3249b36f93256a987bad0e9fb830b7a35bfda3bd38ca6ff6b9d77ea9903d76d983987b9ecbe3a2cc832e01eab0e89da0dba03389fc2a08d4b8ab07febca2075e5eb7aedad9bb6fa192d1df76aa07742758ca19f26d27d4ac66b9a421333f911e22ef2ebee520838979d96e76960d2a18d494c296d65ecb1ba5d056e4243e8f66669d811b3ea155a5aba425b1d496c2947d8609f72719439a2ae2be598318d56ba821e5045b1dbcc124e2b5cc13a075da71d2fcf044d42bc1a72da4960a4726204dccdf9f2ba4614722da9bc8c9582e99633d45cd329da060bd7fd9dd420a088c9a17cdb7fb4695ae11c75839e97d315794b55f58c10afa04926c59f21b39c319a49a31564f3e6f865238ab5480d25a53fe61e8d3c33ffe7b0e7fd985e88b5628419170a9fb7ac9e648a2a9c094c376bf92f0eeb289261433e86fac62f18e14704918d0575854d5fe079d85ae1401ca27bd37eac3f5cab0d977a93a707f761e861ae6f54b0c5f883b4aadcf30f3ff9e618f5ffd93ca761a56d96952b8eb29f7363a3297ce50888940d3ae4ac6cbf340d05fda070ffc09460d363bb75bd9d5074577548aa2db3274ae32d49a7c9936518d663500ac3e3550f912f2f6b78042ff485663c761a61c1369733f0be2d96399645264330541313d71162d9d7404950aa8b00b6c895e1798a4f4f702a2c657dbcc382c383cea7bbfff8b89297b592891b9266c556da53e24f613f6ca98ce406d1c122d1bc2adb22cebd0e60ffa870de9f699987ac50d63716c7ee646f0578e0e24b5deefd985ba1bf072dbad657811de378a7ade3e9f0dd9c9c4dfe24e5630a5e46d32bf366b961d10798a51c5bb1d6997aa009f1f6d58bb877d9b5a381a380b77b59f54d046bb0e3a8c57345643635af0e131090720fd29727f3550e5724b2957b642edadc19a41b04bb562e5a7c9ea0c6c2a9fb25546db22ad289d69f7d0de29b1d3e49e597d6c63c9b8aa77344fcddb41bd68ead53a63f419e8eee4736810fa15e611e7beacbaf37cd1605689969413fbb234429e3ce97c8098a4f266fcf0e1e9f7b7e8da3688bffebf31fce7539028d91d7d1491808f98906cb413311a33a7be710106e6aecf02e16de433b7b8218a968b901c0c1af986adce03ddf4430a222d82d400b50f03d6e822d6e0ce1f322e79dea5f1e7d35de55a6e5e7d8868933d0c858d771a9792d25568494c6281ccfd05ac40abbfeaad80403db387a592dd735426478fa2e2dcd56177a2f306d13f25a9c92c82a3d2eac3f5ae145f1d0a8ff34405b6a77341e3e7d79eb81799fdaf1c59d3f5e8db0b6343e15743b03e83f4498a640d18004ca56e17ec44e069204b8549752cc26177783d4b99e3d935b1fce51b96a68aea1f63c378f845ed9ea7d49deb9fb5e62859d755d6d844660e987abf4645f85de5f69dec07105f8477d4631f9e72cc657d7c43d6400feb59be1027590e3dfbbc8483598b7ee787224fb266cd402ff0cd2fbbcecbac294f049e6a072ec21a04d1eb9d600ecd46184628dbb7b5d061a6fde10cac30bdc337988e904a04599bccdbe64420422e27f31f33b12efbee507f751578e2df9ed2d01b6476c48fc0d60b6853abdb01cebd212e7a81837258b8d2bded98fc964acc182030e2c659cc01ae5bee65ba70eaf06c1919412c51bf83d54b6afe24f9e9601d8fa39f159bfeb2305db1ffdc7eee559448c23f45dec241189bc6200dceb6a03fb71014c525bb0cf5a54a257a4cc14b79f7867d94694a6efeb7cb647dbd780945758face9b9eb179ab529d381951225c6c3225cfc4b6b60f846a1fe3223ed13125dff2741e717e25a8ce6774becfba20bbe0dba43a828ba2affda24db3375b3dd966e3cf96e9c8eb18ec98ed2ccdf74ed74412c2de5b7ce6bd65250fa9cc57e01261d4f8f524fa119b93d3314135b217a95d9e48a8f2d35a202595bbca3e53a233aec69df21122af6045a3cead0158d1f2f777f299ee5fe7a4644627d46b01a1c8e3e7c8b47dc0dab0f83b74b9734ee2539304b72444990a7d4bb94ba498218656b553a7be67a0904d5a719eac0901849d1373f462f417bf99c3606be81c485814732e1545a8fb80406f45acd3c1af6286c749516a8c390a9687ea21e76e368b49e6bade054a7ce0386fe0ed9484047f8b3e22ed35624239e5652f3100a616679997273557507f2e6071b2deb4f9a3f21d50eb809d687afff824fa7bffd488ac0999d70ac42cabb04ade9f206f938d68f7060f6053ac9f918727dd46b4383d68ee113e878340122b56770f9840522c1853c007408c437ecab838d41d887410ece012dac60ccb57091cadf4e498dea8d0c376e7167706622d9053e4d4216f131c59e7b3a5a719f113673b794b80e36826fb0a41a26e0d222a00dce5a8c684b249a5e0d4ea889a2f1e8f84fef315a81f9fbd44f0462f2876944cd85fd1eb8676524c74b8edd655e92a1da79897cdf8ec8486dde601bd4aeca039b9bd01e08132605e26630e124287e00c806abfd6fa7b37a7985629f37fb1bee91bfcb9fa41b9b14321f2a5a365853f36799073149d4554d943a272d16eef125418e4a11488282a17f7cbd67bb7a194b582ed115ec7734880fde6e7a5d849666f14dc070dfe37c48c42d7dccb96d5cb88ae222438cc280046a44fb5a40ef99ca0396cf7e1307c27e10df5c5cb3c98bed3a47425a1ffd1bf2598020b62426d8d9f15c50be78c06001a579d842f83cbd24bfec42d374d3c97605f0c650ef06cfa2104ca6dfbf611c9fa44a724d526cdf80d349517379a458a7895ce1c70a8fe91ca3bdeeff132003379ef8555546f5fb6fe9d980a320cb851f371129bbf88b7f4f24935c9996b865caeaa77e763f741e5f915e36a272df325fbd04075e744154f85589b0e75a74834727a3300da27a551ac253a2cbb0003356f39662a4da5955736e7afeebb4645905488881c841bbf9d6ac413d9cbede273710716ab87dcaed520daeed23f2b584fc6c8d84ae9236723b3502546a26954be590f2a90bf4bc78374c78f174318a6a5a6017630f3565d6990df71f7413875e29fc26da1fc663600523a108d98428e4253b1615422bd151e6ccbb9dd8aae5d3f736876866052e86c7b42386e2b0208b43abe644601fda494a4de7d7779ad0e83d92e70655b492075dfd9f986543dc8987707328a8f81c0a010205db3517416780ce452982c870e7961f72dc64aa8011b323fa06aeefcba35e91a7f13a82919dd8790b16ac0340600d32fdef18f7ea268b353caba85cc5e950f2d0be579c43d33668b4150d77cbf9a1c18b9508641011519f6b3da1d3a26fb260b1f081eda4e485e7119f764c45de529e341e98f3a70005e5d6c886229ae28e1ba88f5387b3f38adec4608ce08b35a140cf404af6d006e605f185edcb5a97bd0ded33555b37a41b69ac8ab33af56456ed977d0626fd46d1f1629c7d81933f005fafd5702eef5a130ae731145e4ec65273d7e062ae18fd3227a82c3417e2374b8e17b83df1260309922cc61bbef7dd7532629016b5e4eec841ddde7e2027d894a544e5e0a6db0989eb552c77201247019c6e99dcc5309f27e1b147e3140880f244e69e32e35a30bd259a2aca4052602da29288289e8584226a3a186137a78460bfa68aefca2cda045c9adc4a3685a56ba5951fa0e00a40c72c256de5ac268f5140096f9c8d0eab5ce818425a2f2e48cdbf7b0c106e4c50ccc74005fd7a2b4a82aecb955770191a4cfad84813f764f406e28dfa04fc50b70245e5f844830029bb3939761a7dd7ad3aafe5b9845461b053e786a933b5dd215c01857941c4bf4f83fa66b62b761dadd98108e5f08992d33aae2cfd22c4c1fe84901a7d3704ce5649643e24306ea7d28e3f61e937401d1d7891cfef5a2a4ed100b2b0f5053b8958bf76cbf99f5a61ff74e7ef5fa190a3a0f78f3f128eeb17107cc0a266ce43616c5c55cb61dc06cef030636b04667a596b32674edf0342c713c0cf0e4180baa0953af2429ea9f0998289d134eca5b0eb124e68fae4f6ba6e164cbefc3d9417f1d681f4f9c19e25647e86b63138f3f713530f09de8dde88ba64eff08945d7e15870117941b9045ac30cc1f0b81a75f2d78d47abc4697bde34476bdd5058db0e824ca9de73d9c1d615560054f1560e90034cd550976ae6ec30b11fc58ffe55586e25861d71e122e9eaf184f3ea8a1cd10ad3bae4d9f1ba281adbd31dfc3cab9e02ef9f62448657dd2a7e974b1a2d1ac72393585946fe777965ff9bd80b952fb58981431bcda8dac676578e09c45f4746d57f811722702753e20c9aadbf70f2b49ca3306696622419cac180da4cec4610606c282a4be7fdc4965f414198b28430255474992e7bc6e918d1619dcdc2859a7ca89b13bb97da4fb5120239e6f5c4784517b27b9297bd6d7fecedcf523d2b87edcd97dc51a8a73caa4f7f1fcb96eeed273bb0583b6b645440ae538def215eabb3be69521c64fb97e0c573037d755bfacb19ce6a817bf89d3fb957ca5b39bf27d80ed5fcf35b7551f99ba0425a9c35b6e9fdcc9a5479935cd8112ce5a5627de32158abacf2f0b187d62f5925653a7b866376f9d7135e203d2287161ded34216fee6d556649dfb622573dd5288c36ae46686f398e2fba74835ee09ea0cddabb1ef86b93f09ecc9ea460bb5e0a77f95c94675f982b79872093945e4366bf629d091556d87cd87c6572a7c6ee519712340ff776a41978dbd742e80ee449d506d268fbcfc6f2656f47a82c91af42018f70e60780a336bf178119f09761bc6a052f72550974c251a7c6084f7ca7a912beb11adb00a1082b5a880f74d7921e459a908986bac726b96cb9f4511f20777dc675e9ddd6f5b6b44c4f64122388cbc3051b75162733bb759fa286e6e387a1752db36da9969c04681fd3c085b780b4ac443c5f4112f90a4f6e04e99b0ca2af002f3bb206325570b8e34a247b5aed46cdae016843cfea2e74794951f1401f2e4c17be3d5223fee21cc35e55af8ab914befc79fbd4113494098ae4558e72a0601b075e72261b82377d5ac1094adb5d4bdfef4a43219e1df2afe3fb01ab2a9041b3c8df57d2a1be9602bf006e6611cf5767b5699281816faafcb782040a5d58175182c63dd07f4ed33eb4ff34dd54e0b10a2295e0e440c3bf6887e66ba1ffaee0f3135e9a046a9a4f91aa59281a0ee8b666750781b281f25ccaaa235718110d1a0de84d8c738884d1d709fc6d4f8aee0aa592c8d5027811aefb5c777d534a94587fddcf7d6a06cee5332c28a14ea0b07a001ecef42986412829f492204e9a165e2a95f234345fd0e201d3eb7a9610f27588d841d1d3e1b08db9b2b58973741feb3af0fec075a8f70d69c17afd3fae2809bba38e1e4ea95cc2f970809da31d5461462412d49d0364a9a41ea91a23c9ff93b422141cda574b919007345e24754caa323982b910527e95b1cf31dedab31dfe7bb4084162b0e0748dd9e9f76d18dd421a0744a87edcd735b57cbb17bd2c53f35c76c03d44a9778217280d7f42817ba578770de748d2c7a408e5d94208b82a6261011bca2baf61bd564f38b8cc74b7bb39ee28d443ae341656251de8bf5cbd3dc924d3d2e8993c0b23c8492a2a958f5945e20f66338e8404c09441e3f2f358972ac7d9abf8840bd9e9de83cf0af69e916aa622e0dea809e480abc1728bc69ef2e84f0e8fa16a18948bfbee7b18288c3ea32ac9727d0755e458a325fe9d6a783484a1032c7f139381df5b91c39f626de80128845527c330877771380fe455a16a023509a1f375df68e016f7488d73ef070cc7c3f2cf45ee3450ac678fb8a402bb2fa719baf61369d2bfaecfd8d26980c8bd37daba693800a65988d860ad4cd6a52faacf756af98db57b5cc57fa422953ba38d4df8ea4a87f4188d94868cad716b7e215b4d967945af2fd7438c486fe3e1353eda330ac4628e4b8a5ecf784308dd9da4413245b2c378834c2fb25366d5554d798d64ad95b96b86fe6627f66a6add8754fd693db9571bd2fb05a256b726f9ba819275d2055b6a6ee0d842fb4f328fcd6e2375a5c6bf0b7c434d2473a52cb4a737d2828a7f32560f5141164c2d54e362ca933d969c8bf6e16ceff85d4241441de5897962c295c03c3d6d332a17a526f9aae04ab8156631e45aea1512bfabbbec0f25adccc37da88695ffbe3530b51aef889a01ce54cdf0294c179d3cd19ddbd2a79d039a40f6aed3875dc7ec5394c920fdf1725a879c9db34d61cde7f757fda2bf0bbb3773ecfa97ffa675ce8cc96702d9b935360dd40c6d15a429e044f3fdccb3d730a1b77f9b8369ce3a549a7333ca728369eee0d361af2c43feff32cbf6ec6fdfb33defd7506afeec0dc08988f30c4c2b2b61f8793eae99424797b2c7714f72a10cd4ff6dd6cc2d338c445fb6d013db13f9dbe23781f572f17829425f0146fc3330cb5f1a313b0cce5f665783c078258a62945756b91eeb365ac7c7312767f7f3fc60a76fa339604916be53d91ccaaec41520c0cf6f9df92cd10021a7b7a830e25102512c38857ddeccc6fa30ffbd0b1ad3496da83fd88c4b0a1a453e95ab76e675c2bcb12122279cceac8e5755066f8e8a473762d7445379e15b1323b8b8df56cfd4cd730d3f5429d0eda3d2510e9fc94adad5c2f3844a7fdb7abf29f355bb8477ec3951c7d952088f6d9e3ea391a47f1f6800547b4fb49ea1c32a7a7d182fc6fa498b9d98ba3bcb3c1cc98d0a903dc636e27fc757d3d94cf42a34abf6b2b3b5130525369ea250367524d79485ec1d98d8e88f8ba99d6e7512a8b080f4c3d661c7455adba7124d8b1da4fc73c27078239e89e192b002d7cf3825b28f9c3f9e45d78c7c6aa161c1d2f4a50b1c2f27a1a7e7cffb963ea5d09d4049c94a5026635dfee6f8bffd36af86808bd2521de25d8f4ed4f1e39f9ff96a478ac9f83138944b359dc7b34f339d6b43087630028c1ae6f2bb90a9fb934ae73876f2b045fa1e5f155f633b26b9170ddb95d0fca03f6957434cfcdfbaabb2c6b80314b34fd5d2d448c578cefb697c8ad5a96a98756b0397d26cbcc6003b8f2d29e8c49c36854119cf998ad8513566b503a686192d488874ee277e4e3f4a6ddbc66e587d5c026226c441c784329964f694310e065b95873da01160ba7bfd206cc194d6341fe3e5b4981fe8896bcf5f3d28c468c68296cf464417d0e1987b9cceec44cbf5cf49717a36ff61aa718f19d944ba15fe9e4f84892ef2ab7ddbf10c1233b85a13766804b6ad7b4715ba8854f20b33b9fbbb2a05d7fbb5e3f1cc39b964481ae179c50747761bf232a712504d357656f6bc4a0075abf0fd7dc13bffc875018888ac2290d8f1585e050938004ad9da26672177e700106c802d922d3c93d0c4af2c631fe6391d7c587a0bac345d9b7020447d4ade08b8c47a4fd39e7bd5ca64c712b4a7eea22273ab7a8ecda084869b56a740db2ec5ef35cc864036bade18968a2a88e54733853c1d0914da665ff014115c4bf89af88ad9dfa346e805b009cc9e6cb0963a133a880ba7c9b651f7a2274b8609104a664cac43060f90f870a1c48c172a41a41ce6c99e25a274351f953bd88c9edb542761edeb7849b937d9898c754f7bd9305934ce1215d814c788e178154b643cf5e72ee35a9613bde3dcb6a124162588bd17735a866c39158e64675b10d961fe67011202268c89bb779a8741aff95f6c1a369c9f741e21298e5871f6aea2e4b8d654e924276db5e96cc29f2e7730a121daa17623a4495abed096fc0d02a78551e927bbd1ededef02a8e7dbcb3995e0dde2c27fcd4325d8d1cd53fd28122236efb4d7a023199cae0f93a390562ec4f39a4e6d91b3c462a1ea67215da63833dbe6991509dcc5cf0cd12fd00dca48b325d6016d6625209d04029c12aec62e94fd416abee02d7fdb679f00312e3f31c881088260840da6eaaf612fccf6405ac02cbd1f6284c7520f7e642cea5e78220f66a36cbd2b2821f43c1991c6314a4753eccbca8da41c6de39e66d4bf5e667618f8de3c0a21b23e228ac8fbcf8f7099fa69099ce9a810ac18f08630a6507bd2ddfc08eca427169bb65439559ac21c82b59a1deb0a9832e4c09723b85eb65503662cb52b3d4e8ebc4e0bcf89a011be4f4c951d4ddff226161d9682d2afe0f77c09c0f48d5c06c23ffb51e058cdad7d472baabeb12fd33dd762aceac7d8a6df31b15e7e6b3be4ff4d3f7b01fb5779c3bf3f17202dde6d59ca3b6b6391a021e578559d879f108290d0c62a87dbfbaed8236435ba05d2d205a45f23d38212fd1ba86097bdb260d3ebca16988dddad11ab956a354c5faa471679fce3e46210ebce35f8c27c893ef325450627011e638f6851339bb7b767c23dfdbbdcbaa84e57c3efbe74448c15d153e726d57e8cd3339a63deec316b6b41541af1992188c34ace2299eaff194ba744bcbefd92be3a6445f63611c0a8d3c26a50eaf24c87994b6040d3e219626f2801428252d9329055a600400f5f13433476d838e646c104caccf0172b6fc5524122b0d601ae4cb1f40e0fc333851690d8e13910b5e2e09eee258bc1bedbc181c88f04888c99f5b6469fac91d7982888685fd8b91254750f1ef40848af3cdcb15723d32b4271e76ea8f42b43caa9dfed8acced0a0b33fe60dd6db3daf2b27655fb24a5adfeb156c672853436b8cbff68b2e3eb044d6fad3617ba64f8cd3a8b7635736d765e408a2af75549894b8fb232f4c7eb1e259998bb629a7b38a57afde2703ddd01324fa3b10d45afb6acc9b5a9307296f1731fcdd929b5b10c72be8858696485d2b312d95d7cc32ea6cf8e76a5891789aa2c3e9b4523152629eb34f55d42eb594594d6d69bb536d62ee9edc3e9a0f6045e02b4d5066c830e5a22b9140bcb19a9254eedf78f993b596727a976710f8427c44a4d2eb1f04ab5580ed3b13e5c9ee7248eb276bb0feeb9373a42788c828913d8c5ce51c8ef6a6cd7c7f77a0c5537a6e26d0386812dd36e29f6a4bea079028e1e80dddeef2c6c349c0bf27ca2a6f172720e389338e75e848ba7a5954e1ba83b7784f19c1f7e768fa99c6fd0c8e0a8d93676662e3243e92e7891d08bd3c57eb1f234691eebd76b41804b0c9dcd533950a0ff7c7fecfa6630f517c26ad29639f8504da7834b044db43374f736001fc1c14cfb1d428f1374831b58cc367f4a9fced0cfeb1c2babe95f48ec09322c59206821464344d28ab98cef59b6f1cd9e0e42d4fcab6225581a1d695329594cffdac624fdd5e065f48b9ac84dfe9e568c42dbdfc62f1b5f916a59149d6d0ef7921fbd6fc443e1cda6802793d227b6a02e900a4662a487233b70a2bd096230b243e910f0f0ee6a61032f6e9327ed6687b0c08883a01adab604e548782a94a60e52104919da050935636b9c2c52abc065f0601aa2d2eaac3f54da10a1dcd47e36fcd3a4e747e21dc5a547168d6e6e38511174c9300b1b44806a166804371d6af1b420eee25cb14318ade81799273c5f40d826375e4d7fc4705a598e52f5f79ecdc644cb878995d04523432f7988ff770f228c1ec9396ae453b9e29affbdb219052c3ed29fcd93f79c697bd4d963a967de5d55ba1a5ad2f9150d33944c142335e1d60783dc2656df1d319dc1540e325f39e95c1dbedd887c7ba895dcdf3ac85fc04864fcf894c4888e64785434321dadfcb09c3f9715fb35f4e84ba284c9ead95cb476b7f320f6133db7eb9716d0b6ed7388681ff8dfdd848d4b18e0ce648495e178966db526cdf58ff1fac96358876f5becd62af4bf0af95d867370506649344f31eec2464083038a110e4dc1290729f01ceedd021673e17d09b3b0313882ba892c4938749b765548c0ba5cdde1f4bb4398459139c15ebcffe21e54c0d308c844f991872ac30d3fbfd70457f52032ac6ad8670f2930295244e3d657ec77ca4ec37316434a29f11f8c6ac412f5c4fb55fb7f4977646eb0ca832223692cd8ced89e3ba05e08aa6b155c5b3c2402cb467ed6812dbce059dba5af1792a85793a8cc94e32f75823c3e7f18dc1aab3a2439e0671cb007251248e1081de3e1751d28fe8f227edb87f5e622a0a28234c65de2deb482c4b9c8ee5119b24d67fb55317bcbed2d583e7faaf1939b73469030cc92e245e7a464d6b99e1c15edf5319b10eb9ab6d9cd210df0e028f851f81e58a2c61a613ed7800176269d9bf27f85c5f0c6821b0e68aa610a6b7920405cd9b44404f7d3d80ed26fec1216e97da490711305274172544fdae90a15536a3b863d0e169dd570a28a1517c231fd6337e446c5fa2ee3cb4e0c62e49aeee47d97d1e24e2cc51c239e50f071ccc2fd0ae6f2b1e0a1682943f5e0aa034fe0c4a8863be80ad1491d814bc0358decf66aea9081d8ca5944d16f886c804a1975b1df8a3686a5a18151183f4a7ea03f4333d41a611d94c61fb8e792008a6de5c3474bc248d765d2f2f762953d522fe098eb25fb9900585fccab77fad0e422e3f62ccd1923b0539746c946e34d187405310bc622ff8014736dbd60724b42fc83d4b6b0150df3d9da2f607459803532e89e342a50a234edb0fd1e894ab8362b1a460c37aa1ef741038014b4ab3afd87a1b9672550fe7a6c072039234ff0043d4882906aca2427ac67df8e276d042a1d8fb433899695fd27d409c12faf1323a91e63d3893be9369e84fe1d55874857d68a7f650d4b329c4c0122d37529f7284c1e2f0868f9981a5850cb6eb46d0273c29cc4a96ee7e73779a7c7a927d7425bd4a4dc676e6cd132741a5f4176d579dae505e0081c0acbf8e25c5fefd8de873eefb23a75da96355d64c54e0dcc7a24dee15ecf96a7c65bc161e0a192c2370a176ab6e05a51997153d81ca16852039cedbfe10187c2f9b28abb52eaa7914feff5268228781e7bfc5b49d03e76051dd9aa417a3473a161dae982002ba99d143cc7e7975bcde7e61206f7b7e5b723925677c5b355a03ca421088a5666e1ec6733733cc803ef6e4bbc6c60c26a0abf9d542ee552e7a714ea4c09e85f957fdf73aabd7afce864015382566685f26e173c9df5b556b439553af30fca095472b77d4cda867cf30bc6a048bed7145082c64ba8f5c74853ad1b2f397e1b257563289c85f7366a430236fd155f5eccb90006b056c1ae75013f4896b3f6d1eabe50c34a2b5be04b6f403b26231aa6db122d8d22bc6fd6bcb6c730312f53f424338bcf71a2e450f5289d669a60ed994606730f73bfe9a4c72582e0da0f65e5e9de353167f4e48764f8adee167164a1e5340fecf2f49a8736f54ba8bed5a7f4a6f58215a2bff2096caecb1cc1d621c55799532ad18c0586ee72f7d192236a532721e5cd24f28479faca60d864b5bd256612db175264bf88583d1c680e4380aa8f6ccf07acee4d6dfe8863e263da0e0b617d83f53a9d456877d0d9090b2c8098c15a2b4fc5230e7e63c5d9cffc477d752807780b32e8941060315dbbbe811f31684293fbfb4af66ff8614a553cca995dc109e25c58e661af600b23bbfcfef10559220425df4c21e390aa89657dd8459e71ec411515a5f481ab78ee3d4aa326d8be43b0847121faebc48e2e3637c9433405466af105e05dace77454ed7a885170035aeb6c7b5d6dc4374d8bbf8ee2c7f1a218c229a0b15f8ee3cb40f836cb50ad5bdd7ad179483fe26081ec9a497ac617c7c87a2f3a96a8d1e9d05d62774200f26cce402b1fa60cb6bc83b1554f452aa0a7a354ccf605938517304bbfbfa02bb1375d341ba0b16bdcec8b8c572107d0df55f0c40099dd573d8f9aa9f856a8ee3888e33fa3a937b6b6aac512b6d8b64d4678b1a5d0ee8af9673a9bf8fd7b7eccad11d070eba68a2d1648107b9e83ee2f2daab919d138550fa232ea7b5cb0c33b329585487dbca341af4be461f058e90e632acd5856b6ece9e3405934774fbd4d6816aafb4ee2371715acf06120b2c1fd66f8c34c8af23bdb2194542b9d72e69aea942d761ab06c391aea7bfd561fe7591e1b0acfb83ecedf6220388e133bb1700fe6fca922f1cd393550e673edc07dfbb80be67ac940be1f624892d9912be20e652368ed6e1e104b78b1f82fe30669ac6e53fd7d5bcdd6a68bb614b523797bdba753151a4e351b8a39c224113320770c9ee998ccb71aef4b1b14198ddbfaf6b7e3dd7c8025f61ae471b14b56e34d662ad2951dad6122f7546c9d4c7ed486f6a0d33a85fc4b9d6de32adf65f26898359f730b9f27c0cb0131899d5a85a44fbae9898c0f330652f3f66a108df2a8d60af7bdc982304d2ca8f8158a101bbd60bfa6f1ae6a326dc5037876cc15ffe9e4f439f03500ccea7eed581a932ba574f302e0a063a6d101b09e081b4203f3c18fedeeb628b619e043ec4d7cc913cf1395b6ee12f661f2de83906805bacc19a664e651127ae333d7b9f7952dbf784fa4ab17ac6d1ba117a4eb96a2abd3627cc0f7ed6267c26a0c4d439f98593d95a3768e09e4c55e4d6f74f2b2b552bbb8935c5d10de1dd88ccc455c99ea53d898ebedd516aac51fb65e48ce1b4aca0283643170bc551f4d230540e684b3ff7fdc0c190f8bad5529a80037da632df142ad9cec4c62a4c69de31dae1b30753e177379bc81ca35b5744e810043a8a1b98b9d1d3ea7c64b3792292b85f26117b8b618e58b779761d7e13d2f050d679f0f4f5d98797735edada0f77e4c8ccb9850964b33d6cf88532f692ebc21b4a712f85d180a9571525d25a63b67022b290a5b41b384ac26a09d8aa72de7ec9e4913b2997eb54ed5c214ac5b2596ce7cd81d84958d3c0dd23bca7f95c42e779dfee1a7a9dd9285e7c4b097e1f7a220bf57c789e8cc9c1dba939f1d7b8582b44cb818593336cbdffd8b6995a8b8a3fbaf6a415e3ccfbb1f52f14ab5926a1b944079d68065554a19cafa2366821be516552f43f5c5d2e247d390892163f78fce5b6ad33578730d333a78af6e8eda03f31cff69beb7324ff152f5afed807fc748adb094ebc23ebca5f498ac6798e055688cb80dc1439c6e58f84a77f65c967fe6fa371d29e9fa51b27bcceb286aaecb46897f41f58115739599121cfc6e70bdf022ce20753570dc733f8cab5bd8f5c209958b4443ea128fc6bb72aa066c088738a4854fed2f49cb9cb3a58859c076a360f0b016128d2009d6dc71f9999111b6afb2383620c46751c8e9bc983c3220ce46d9b82893956990b31a56c99904a066a345c23a96ec1fe25d7eea93f2f2f6eb5255b7856cd8e87193bde71656b12a628c5ff6c968b2e351b2daf022289e17d01f1f8c0445a0377f18b1f8b13e9ced3873ac9d9d7c0160ed6e556e05bfe673a0d05d37cee7c2782420d8fdbaf8f6afe158c7f69600081d93a57ff194bcee6f1d9a76b8173180ff16665c570246eab16b56f4586084502d12f05128d24eae874820409c534f494c4fe1aebcadf4f11e15eeef33d3a27f9cf65ece0a962ec3f1ec45d1eabd8886f904b19cca0a757f826b9839cb5bb521939586c80b77b0982feb49c33b78f024b5b68849b538f5aaf74f38c85e0e02900007f582278e2f89aad6e1a7039d1abf86b85ec91a01c0c7402b3ae2d2813f4f844e4662654911f26271acb1f11d77a98a983e30e0fc834041f0fd7f4a3b4836483a446471ecc0e01e22fc47ec2538d2553a8ff70835d1add020a229a1a6b4e209fd11a6c7cb413db8fe4b7981edba0e43a2df4f097bf414b427741d5255cb97ba36b84d462fff38b36f93e6461c7119e4dbb05bff47367ce56becc80c4cf6c3bd2a567ab32c6cefa13940eb6517e42ee148e887451cd9b8fa96a9900ebd04796127ac071a0b02c9838fc3312db38b8f34204d8c0451da6c4348272f295e4d09af87800fe7d538dc48fdf0bcdb4043ae3c05a500b2082888f819d421a1769c02a27195714faef17e086ba4f4777ad828aa99c5c9e0641a28a7e37eecdc0c564019a6cb93062f5309b06e57a5db034caf32bcf9a654b3f47e2aede12fade027c84b057a00259a5edada3bcaa733eee285f8cd6004d4c8ef7fca88dc38e3489b782fa14ef0d43011ecb0c10be53fae7e75117c1eafc2a073f987d11f882637be37befc1ce179d7d13ea7f753ef553f49a9e2c67b3b959d228f01de5ec16c3fa2e385a8f0b85aebab3234738685dad572bf99f91bcd386b9770a78b94e9b41bcf2b503abf5f0b32b546e9a1f32ffc3ed62f2ade4bc1a1914a7067c8e8247b8463f2bb35138478fefa8ec75661db5cd0775a37f7ec78197d0a3ed010dc893c991dae9a45625342105c35e98e927cbc2d80e588c18ddf2bd4f61ef03f1ebdc4faa3d1f5351717619e08b2b6f53eca59a3521e2ff49af760f555d8c022b4d99b267ff4263a8062b5488d32998c103b922267a26410837a91b6cb815eebd15c72c1364d29a3d449ff12b3b58b54fa390f4afab31de2008f267f6e0386a6b89ce57f087aba7ffd5b5d55872878f84165f613c642eee7d2b99a14f4afcbb28b76c09b59b3358ae29a931854a305bee551dca13c634520dfb40f0fe92fcf0f36e9464ac6b3d506c291509d3ee41cfc724a49e17ef58897929e555be5a84d3d7e49aaaf9971bdcd52e3bdaa7f62a4cce37beaa593fea890d35e4cb9d6e4f7e952e6d3b4c3e6e7e8349599911070def68b10517eedabe2980bd453ec715cb152a785bfb2457d2969717797f1ffe48183ecb50cabca83a4e5bd80974e0b67f0c9796cbcb4da2e627e72565f64ffcc388341549105e4e28ef6584fc4070ebaf164a7a81ff87e74d775092f258de23fd14b8b7ccd87912755c309af783f24187b04c515804f60544a0b6a0e5e6eac22be1fdc941c399d1a7f2a40151b1687325c37e9d14422cf28303169e606c09b5519571c036762e7f4aca9154dd76538b419ae9142edf50e0bcee1c6d255ffaf68c0ebff8cc1a37d7a20a372ccd790516eb3d7c794075da58c6d7895d0e719e2d05c3fe3d181e03e5a16bef765367a1926fbfb6bb894eb85c033c12e848be10c30bd954bb7d0295efc64d37243892d0f834e69845630446445cb11eb10ca34a9ff9a053806e307981146513f5889aff24d4281989e5e7fe61d2ad725293044d18ae1ac2f6c48a9d4758504e65cec6408c6b7acd9c89fb178c55494cf7caa40e80ab669355e55c3b86179a2c497829f7dbfdb84ec0133b102a692f11f2093664b1afaf74c45e1564a8feb8abe91c62552555578c6d28fa6730b85b57f490f5c30467ab186062463d806f2cc37bed3580878efae5d1b0dec7df86d4a2a1745c538d200469b69dc56bbb07926bbe38a2231088e7c590485d3c9aa76cc97cf134cf7e32081bcbaa9a7cab7df01667539cea9becf5f15d132ffaef769034776120d89bb278a0ee778bf2aaa2cff839603118667793dea7128de42e82df0e7ee0561362a9f2cf3c62342eda58cc0db757741bb60fd8dc38cc2d8def65f996ff6ea1cef1a68d0400cd409674d097cd71f2fdc8c31987916833814474319ee213853a1f23d8e04ce75cc15c5e21b59d66b08c1b9d47353369f2140fbb574b94764cb9b2cefedd0f0c4c237913ae11d330370d7a4ce62c217e27559f1dce207791568fbe8b7b5483018fa198fd28b9b0a572605763cd9be9ebd43c31f0bbc10c0038dbaf03c73c3433711ae12dd4baefcc0fe401a6f62773263c40b5ab21d1432f6188768d0533520f1889dfbe401244cd653ee36a45eec4da2c74d6267fb55ba8de81fa02358e8dd9e5dd873babe5bbe6543416711f39bb574afd6b06f235dd59af06b9c0a14c770da85209c44106661bb7263ad50d15a7a0f6b7cc23c73baa18733a9166a0832d627915d8955cae702a7d5b161674f2adfe1c93d1db356ba2ed79efa3c3c835828223389c1b77ab53dcad1347b7601115c058f400823157f4f049bc26f605e470186e183167d7eef7371be4485ef403c2728ea5b5be7c0139760128e062a3d33407cc7675dd76611ebc85eb61b84599ba77ee1eabb28e3baec97971b1ad7ac203613ae5c2b628fb48a43d5e80a5f5abac458420645b95c9df4084d1b478694ecded22fb8590e757f2dd7ff6df0b5104abda2068204a03f616e6dff16b72c9a0a9a48d9b3f76656fceacb5c4b650cdebf2bf5f4e24eee1a35a5d7d7803a22013282d5caec74bc936a910d50ed2352c796ae57d86c5d457a6710a0d172105578756d1a5bfd7e379c3eb1b9aa49c4b9c688dffd2fe3fcd07c306d645290f76e1c6ed8245a3eca9e2aa45510ae3febb77b6175d3dfd092d1e74770ac086a3439d92d6ede21fdaee4b0c2f7605166e390a01955680a1dbd38feeb9b0a8e8a375ee8b5a4ffd1148be0b480963b5ec989ee62015dbff562075dd81354ee4d51c65514d8fff493ee0b669c66962e164f13054f406ec6c9ea64b37c56cb65974f4c4d7a2712e736f2035f18f89a356cbe3e8ea110f29128013c21d3fa9bcbabafb23fbd40e9d3632e4ee73b235adab8f8ef27a4f483f79eb6fa6e6947cf017e284266357701d7bb0b3a7140861c384017d5386f27b83493b0fe1d9c491f35cd16e6ad98e49513f0d026e70b14432e5596c1b4b5d5a1cf353a6a9a437f64b09e2cda97f85896fb801498cbca6069cbd916d24607b9c1aea0ce144bc248295a3c866d105b477a379d68db87d860eed90fc51619d26903ba579fbba0e81ffa3937d666b77820fee20428e3199fefea22a6c07987b867e6fc9f834183a45e950de04b48f1da5430ccc749d2ddcc70ab0bf6e2ed9f458d9291017b4f6024637b74695d96b559780d676db223e5ad92ff109b4d882cb2120e4db5412e6599f2e32d798403448bad178c85563bec1ff6c1a2ff14c56cdf597eae971d9dcd2ed7b34aab94fbf7a4c4bd241e244103c6c22842e55d98d65e2c6a16e7e6c35248eac979fbe98fe5979720cde481d677b3964614fe8128923cd361db1c86deb207c75c99dea614340a472fc24c5fbafc5b2dbcb370e502e672e7910c89f332a61aa419dc8123a684af3d4b6c3aea913c02a07697a335b82731853e09f8d4a9fe4abb96f30d1cf6fb8ffcd2c7671202908c2df735eda12fbf80b7a904c1d455dde8235b6e1dc2e803cbd1688deee4028e6aff5b51d7ca85e9fe8933bea670ba805a2b6f01972765f27e9943d45589ed376a08192e8195153157bd352065023264ff59613793555ea059e2f1f0d88cfe0351ab8fd0a38e28b7d1ac864ee296486f4cc9a2909a093392169eced8f93dcc7007be2c11f3d9c8bc6272c730edcc2bc204556684eb095cd4a617eb8d9c7902e37040227506d121f0052dc55a1147bece42f30b67b27b4c19bf20e0e79810704e4398494016545ca629a146be04b9a5a50f27f2965155531aa4a298c286762d43dc174f2eeb77d218ce1d72aa09a2d3d58afc00e656c296bf683fb933102205c0cf976f13a619141745e2811f459791531bda554ea709046d24c64d1db0347c6b5401b696fe5b9b5c04cc42ad1f1e20af47b60a37b9014647364a05d6af3a5890fb6b5fd83f76d9cd20cb48cd6ee517d14f0b8beef833b38b58ec7d572b4115bea42a05873c3b52e9974f77aefba337ed7f190c3a436222d6d93381d9d4babeefd05fd64ffda8d1557248c8dba2822c3eea8acb42e203c54ee5cf4b3f94f5e115aa553d3d3526de2c3c470f9e025dffe902c51001e0084428371126a3bf948595bccd6a5d78b8520be21428643a549174feecbfca075ad78167a4696a56854b8c53f4fc360a9c7a93c6561842b09647984d85c3e3b74136dcdf40e9772ddb9b2464b27aa778dede98bb18704145f6f4a09fcc509a1801329d173254d4e8dfa9345bbbebd1b6c320ee69cedcb45cada8acc45ad81afbb711c545a2602ddf4f4dfa9d2ee3fffd148c45d697c4ceedc51f0b1d99ecaf16ccc50df181f43bbbcc07e5f466283e1d08a290b91a011c59b2b607a2c7bf75eaeb31039a084e9f3ece8c2e9ebfe7f6f5b17cf7a6c2924705beced52c85b019a2c307dd996c1d8de87d427b3056e4e7b38fb80b96b1ae0d7024a731c0aa0f3ab52acc33a00a438136cba6458d148637d4c7fb32a1efd0e9b7b30dc4cbcbd0a3d1e8960cd614d22a8e0c0341985d04bfdfe2933748b8029ddbb11e375332a7d4b59018c5d986ba8c5fe28cab8d889a9edda9f4113aa5f0423243f25c51c7a4c8ddeb370b2a188072ae8f984b5833ca8127876bf7320f30061e15751e8e81c682061c5ce5476a60a5ce2491e7c5fd4c4e40ce83723afc6f54f2e577795e3368a94c760349574844cf7fb42ff91ae7c17229a0e24ed61e4c5fa3b11d911753e6e6a191803a3d5987d543bb9c7a30d46f47f08383765605aefb4db5b11a5ed0a0bf6b34a0152c7c201c4ff324549d23e6a71f4cc365749c64fea9cdb43ff964be5a3b101077cb6113bc71c570dc80d3a65a6161d4c721f6ad677fad7d2180ce9583a83ef4134216beaee4514697c0cefa03139fc1af4cbcb0403d190ffbde26e871e8251788891b0cb970f9cfdf974e210c38ede5cda3b3f405a8baa4c7a7f37dcdb11a96f7b816fc9de64eba36e650883983cc597478a55d363f7ad39a1b2a5a218d7fb19dc0e84b61715ea4693b527c4643a6a6cef3aa946f49921c8a05096c6f19c5509829e2f8b612cb00c7f1c4961637d0583200657ed4a10e866d9390d67ff08fd6267d26718829e4e31a4ca94616e162676d9eb3e0f4003c641c6a3518848898a923d7503767814f4dfcb9eebdc3153f212a0212ddb544ba27889e6a54ba78392d21d96c4467107cb6cc21d3c9c5844a2e4a17f228781bc9b37179b1cc5f9ece895138f014e12609def12b405375853fc3e09912f1ae2f21625298c868beca1f3975fd6ddcad084d1e79bda5fb135d954c7ba8477d4413b776633d2f5c2f1a61fbf6bacacfde5fdee3fe66127dc06ab55233de95950820e02f39095e29715dce795380e1629d19e8e4297e1200a453b02c3eaef6ff026b133c9efd43fd0bcd3e8be142464a66241ac4ffe387bc77e71027950ec298b3a9b7c1353f6324d8da277e5aef66c286b93661eaefa0a7a7e5b48752ba354a966f3a6b069245145ceb8f78f237829b05ea64aceda6eed525380800c1c33eb2ea44bd8c2fb20143a229dbc6343a355f72519dfbd3f5f4f1e6d400be5fc0a49b7a622a5e729c1e608e27373726d6be492317e4f0e4ef65b0e03797fbd9516ff6fec03ed6139533540ba644c1019ad75104e7f5ced923e40c68ac3d13054729f43d31b6eb43fdf2cdca807b33b812ef4d077935403b9638c0e8d6564495099aa8d7c7576f4a57909abb2d56694d02dcb74da99799c8082ba60e97a8f8f81e4dcb2b853f7ce6b19fc62519c523cb18da1eb2e8691fe335bd0e71c7435cc444749ef1e275c42cd582a5b7b7c3ea7def0d0341472873eed7d16cb2b9173f984d322faaea6957d0a5deb053f0e8330f8f0eca4c50219a8c02558a0a692bf36e947403b2cf76b39d7b4affd9dc64a4e89829a7392157a3cf0684b11d4f17d78ad7a52d80fecf8654718135daee0e21e3dfd88bde00ea8f547fc7874efeb3395d7110ac48477b6f585ada0112df750e224348276fa1cf28d71fa9506b746c6741aa7c93a841522dcde7cefd51cb88a43c123800f51394bf6eec2607a9f556058edf71955a00047621e2ae37793f241cb5ffa6c719d391a7a7a64db3bf088f7be9f778169d9d196aa102d912c85c6e0cd5ace0fb20a2d005e8ff1cea6dddca69fe166e96fc79309f093cf0835f181cbf1fb5f72cd5a9dbd06e9f468bcb85aca80374f3af90dc90827945adfe724293130e876af031fa2d6d2f4beea1b063f9a42b9c73805860bc9a059fae03b95f1a9f08a9b0f04136bd836fb13ea4d68adcdbbc27e533707c041deac09676feb084e09f815a6c4cb49a2a258d9b14887f3e2d7cf6b9f089233bd90b70e173363089dbdad1f26e1fb47ca9f4cfed3d74d8f59f3920b5e6b502bdf94bff2b7762dc34ff9e278beae808fd6de73d446338b6b919df11e067ad990cfb6f24bf66b40541d8da1d667500bee81f4a1986962c113f897a73e1e8322dfc60d2056cd892d0ed09b6a01b1d79552ecf1ec140a47e06fa5365d06f13bdb1a520c527b20c8a7807e1ac1e0763bf40d9a032224366aabe1afe2065b9d4794cd8fa44984a85c911360a5150f864854ed536e70bab62716e1a9e3b8c031ca771ff3970efe712c556c780852e79e59e8b6ebde4aa5c63c602417908c95b94a0c4efdd127ffe766fdb1922e918172198bebe2448546e4413fb76dfa9136ce1c36f45b2f4582d7f94c510237f9afd9071b85fe4a36ee8b279e26b55c8a45373a28072626dce8d7862d3e4cb8ff25290b9e274de98f4c8d975b563c823b6120c6067b722a4fce0088b33cf512b248df0d9a158bf8443571333963b7598a6f3b5dcfd9d8fc3fd4dd98e3122db109a063a26f785dcb09ac2b256347787d1737eb4bd7538a320a24d79df4e41cbc5ae1adf9c2ce4f28a74dcad483b4069f9147d5847a40571716294f51166fe8ab3578d5d5fb74867b0c6d2b24565a0a0cf36c0cd4bbf7c192778ef58ea5d37ac389c5cda2009eb22fb5cef72b7208540111cf6a32dea5dfbed5ede6879c80dde2dde11a96b5a2854d548e005de2a9027326c2685f87cf653478327b54af7f85e285e036f2822ba4699072223f82edc9a621cced9f6b6ce3bd2500d76ecfdd1645bb75be6d050f22b7617628cc1b0f90dde0dc9a87933b725658032cdba9ecbf35b745a8ae385eb2e686d7c7c4eadfd5d13c1b281652d1701d310738eb64e1bd06a062dc1afbba396b572df1de81d41809dd19a7502255de35de52eaf2fedc3fd41e00dc8646be7d3e859a26011582fae1815f3be3ea6e82f8b6c092214cfbf958572899cd6cca978c99dbb446cd071719f1661e5093ce6320419a7a1e48c73a0232bc6ec1f33c10f2eecdf6cb9d87bc99e3d29fe1326ceb6cba950bfdf623a0469a420d70e75da46997d89fa2eeee8b8b7eeca0cb7ad8f17eb84de12b0d7e8b999cb37801417d962c790b3fd2d8639750dc5333d33abcd715fe7d8da581baa6482669162f41bc6cfbec985fdf911fe09d799507ee620cd4800e19bb25e2905317f89648491eddfc340b7142e979e1b031347db4982ff0a338e9052d00b2ae85060d0fe7dd2498a115ea25b05c9244f1fa83d208547e90493e083228c1eaab512c868556b68960c4f08bbfe191255bbf58cf7005b2b8f4d00539f8de7cfc2b1a78c3e1f9d342ce82a63c3b1288b9bd6712e51b0cabce31828537e4bff69346a53624b0b50b9bb05004ce6b8c1dc2cc7b17989b24881a6e5e2952e341b8932da20f268b826a24755517f406952c67c42e4e01533592bb682fee090d86389a2e52440cc0099ec5c1de32a62b026eec8e6754028a860dcffd453bc50bdb297bceb648e935a064000ac3f818fd6c11a5724ed42433e70a41adff390ee5c0c02b73f3ee72d65bf5946d21f0d41dd21ded5a837663f3623339e1fac5bba6439f5c28fc4cfa220b79b6bdc5efccdf42c6c0d21043f50ef8015e6fd68a6b0e07fe556870a91e7d2d20db5698001c357c4b7aa2c9d3a3a8622207205908293d88fbe06f8d052a5883deb1be5a6d0b22b1d53218cbecd625acb26d4e2e8cd0d8b8dd704d809e51224fba2945fe742201a0cb6ef149591daa4424f8ba12d1de3b6c2e2fa821c49202d47b67d2ef4a71bd5b6915f483944baecc8e45bdcd0959ac7d64daf421c34dfc2e6b5631ddf4a30601d106d351283544711e1092732e38df749a509490e3cd9e7156f536110ebda62f76fe8e3d1ae9b9a9c6d1f379303ce30c00de80c1bcea3f623d5b6557b0294b1dddb81e01f4695b0fca8c0852dddc4ce50377a4787d1af8b51919376e39e0fa759cc7e04b02d7ffa41c5d33565e5dc9fda46d73980ce541cc5d3ed9c5d2a13f76dd978d5f3d1cddaca76012d5fc127112ef2cbb3ae2d9a707a6fd2cacdfc484230d7d617311cac260e9029bbfa0fd0e3e19e8416dcdfd9cf9d27d1581b6355e4dbfeded10453e8229621ee23e86208270c8f4a76172ed3e93e301abd5cd78114ccaede454efd47e27149b27c0d161c77af77dd48ed292bc5259bf83e51b88aafd73c4ee68963e3bf635793dd9115b42806db86085fa7d9a4e3eee6405d52a60db09f688b8a7ccf4041e1359a9ec579766af08e3bc5e49852faf491490da6f7f9aa0a237610e4f16b91acfcfdfd9dc3a0efd5a3fbccbcce9c65dc48f99b0e55faed270aeeb706902659290f0d7791d745d24c44e60b787ca8ca1acbdb95fca34ba8eca3596ec9c7f502d3b169360f71e2b821a6175f0fddcfc9fa1194bd4068fcb738450abe81bb104cd56be3dd9416f04a183e9f884dc641fb3c9940893277af49ce765b5553f17462c036d6e06761b6228800701be482da37ce7633106eb6604791777480259544149a1624f862200308cda5042e8bf092eef86711a50f03a1317e928ba8727af5dfc794e8c32bd01df99fca291c18ce262e4bc2ecd833934724ea6a9900536c2863d9f5f03e5412f64faaea13b8ee5cb8aa56f50017d9d076254afd0d8525d289191f5e9cf3e08e2164714a672729b320316a3408a17522d74a88551e7bf0a6eb8d9e3579aa7ae1649c0b49f868da077f7473fa5753bae339ec681d02a7f9d0ea6a1db56e4d6b0e5f95b74c0a2a804b4a36e9ba5be192bae66c35b577211d33675c729630aeb9ac6be583f285e6ea7a78ebba69e1e199ebf4cc982d4aea572c3f856c9f59eb77c8570c0523bb1bb30e8df08ec09a4e85753f56f6ef464c79641ac580da227d2658975df056602c5940051a7f9b493f2c9c14c48bbbdc746015c46ab237820b54d041a2d23ee2801ef08eda240ae8c261f7711f3fcfb12e37694a99d6e5e84c7548d3673f5d06fdda4b92997f7add607704601660dbed7c95446bf5442a68f870fd4b07041b3b24ec23605ab2533759c8141179d8e5167dac9a5422efbf549cffda52f06d637152fac6c7dfb105b02d6a624dc8439b9f4d87c7becb5d905b1b756eeddbab106fdda64f0d125df4000e9925c28dd0d5662998e3f59e3243cae9132107e3839a68e0625e8d32cd11e3a860a9529c4133a3317e14ed2465d2cff2500785e5da1d7ae32834c5ae03587ef5926f9e27dca82c3daa9f060f2b842f8ecbefdf4bdefc0aa51370303ee5d92da8c485068004f0fe555ab064cdacfe3a97a947579f674cd2f95e585b0359e2de563d70562a9d66f3e94aac5cd58bda05445768b338c082bc8518550c5f9c8b3c0f75234e68b0472f4b84d3c71fb1c9edb9d24935034c77bbfa15821fb662639185b4492567ef9cd885c7b7f13e28183fd9e4818076ddf2ffe105c5ad1ec0986cc95767d100bf617ed0f8a3fdd8c9e83d050e990db06d94bfc4327fbadd8004f0ab190a01d9ba99f039b5ea36a9769ade9b5903a8aa09ad7358d19df63c068c9bc67560f0b77dc03b89740cb76b5ace4359e8768b5b89b4d804aa60b9fde4f98c485388fddf6fa7ca800eb3eca5f97209a11f895ac23b8e25f1328df0565ae5b1cc9c1afd6d5822a204d521f106e1a4be56849cff5844e1874656ad47ad9de6f3fe6be90d7358126720f1e88aad7c7125ffcee097353d6fb3eaba1baf6490d322e2d5bd267962e63c5d26a78f20ca3e08e3c15ada432fcec998ccea95922fdeba1c769a5cdb74b7cf06f2da49a3cd30693a1c96a0443a8344af3863335ca6dfa263496ab22777103b2d03fdfd182b07c88ffe0e097ca578ad6accf5171b70a7de0f7528013b193b7a81375b53423dc881417ec161a39062b57675f6e9c86f8f5b051d39acb21c506700e9e8eb0ba6b26cff5dbcdee7995b05fe4b1b404b7ab56623defed8c8fefa96ae08ac2bb8f9a0ed136aa840b481bd13b1ec2c27d66b61a799e1114d978863f5eff0fc78305d6533241df2c76aa029c60bf0a4159272540d8e5952aea67b4eb7616539261482ce4f11de4caa1650cc45ad805e19a3f894e81f3f99f901b743521374bf03e083569629a29cf8d1bf3278385e9110bbadf6e94137c3cf3e5acaa5241d9d1ccc0bd4c2b20c9070b3779072567392ecba94b2c4d022e5a50988a4f669b8b660eb545bcf49894251002018a0089868bd856c599c1bd7c18649b82cb9f83f97b85736d2c88ce633e97a37a5d6ccdea58b113bc6f251ba759b3d4b7c3bf70d83adc4a679073ce40ef9d0e0b792a312119d0eedd95a6b72763af6a8d10c17abcfb828ee095f6eca708055e236f28963b27557401828e0870673b74d2673a090503a8426ee7619c0e4a34fa2198d38c05d99220ff103461a4022aebbaa2392e7423590d40abe7e364ff58a5aeb6bad2368f7890091a65ddfa4dc922984d216f5e73316c813662280f1209307f54c29f71e11c782c7abd52ff3371829f7dd8d4012f07a4f20e3c7794119fc3e3a1ca626ec69e47b293d0535dc5b322ef22003a3bdb57013fabfeb5d6e17236a4095cb50818a5e1a29fe98d2df066687a21ad36ffeb0c7d49c4f1212fe0caf569265d0b3898d0a17627dbef89dbc07bf43e1fc9d6cc675679c5c105f9c750ff0a2e0c6b9cca45e08be7b80bfa6604f241f6daadec05c5cb8f034559d296ed03fa9a2766149208553b28ba11a26575c4fddac54f93c30cba43a6874a314f390f19c64ee7549953e24d89287896ee1543c9e88f4f189e3334bbe0294219ebce764fe50a2e98138c13d535946fb93e60f7f328fea296c815656f707c11562da482a57c5de7054efa26cc636dd9149e6d43d0322be6f956b9565ac1529f35b5cd80526fec6bf9c25e3f1f6b5ca555087df97d3fbec59986f3bacc9271dedee2e5e3decd0560c7df007b71fae03bcb18cfd22bd4bdb80a5acd5ba360e30a559192e63932e6feb1577d229cf1afc57f8bddd24c161e6521f022031d8ee354677caadaeb9704b888fd57b26a447162225809d624d8baab2cab11244e160aa2b3c272d44af461d94805ab73baf8285edd9167418aafd771fe6a821b1792c2dbe19ff9a41a0efcd077a4f02dddffcb5e7c388a3d256ca0d32f54237776e52749550a71400ffff98fa1a7bcf4b2ea9b894a0835fe50bcc075fba074d9de3b26f182ba3c549fc4deac74c920823ccb1e2028bf5445c4d8fbbfd8360f3e20b18f431a6f2502726b6d80236d81f19ebd43240898077b9779b740cd601d3b51654802f702aeeb0d9764cd4c9e348a93aeab38d0c1c3f3230eb5756ed5e94f60e211d82d3e74fab58f79c933fcd82e21511bec5979678f7c06bc7546ef657ced348b4ebdb7d54a6c9241866122a08cb93b167b414905481ee5033190b89ae8e199a70991d71e3c5215411c85ee39c392aa1ac72f984787121963d5e85405cf19a6c0c52ed88305668a5fc70ffee2d60499f35c849cf25d61e3c7e2c50a3ea70d2b86a17d9b741bedda942d9a167375213f32c1c64d6ee39bda5f68618f581215c16620ec611e631c40de9aea87f8e5ca1ad5ebc325ea73249042185f2209b993b74491fa651cd47b2bc3441a849acaf603191592063b69451e659f9848cfe86164fe2a15302f06150d63230be324cfc53c0314b09bc3ca315eb31c34c82e9b564b2528de8d92163d4dd3b183c30c91d4af0cb605df618163ef484aae9e4244118059bcbf382a15d3343956428f2c51bbe7fef0805a843f5e0bfcbc8b2f81d55cdd0519a48c3405480d32f7407e40e75955dfe58403268ab67f1172a180a1e5f4ac7d0b85de09d9f99d9a6d2cb08897aa061d4f38831d82bf3715afd490d0b51370378def140130bb62e1831e81b631e2b83ba24e3369e724cf8ebe2c93d780cd7c8a721269d611c3d4e08d82c4fdcbaf003ebd9497ef5489e4919f81a92b486b72b6355c392b2b1d58d42b20b7388549027907bd2529a94ca340bd2d03ef7ace4f092deb9f8b6f1aee5c3eb5dca3d8f0a31c68ba06949ddf1b0fd5523f8c3ea57b9926eef03621179a72f9c5c97b2f45541600b23cf1fb91a58ed0ae057cc48f278eccc16d7dfefc6b79bf2ff798e1c76b89385c743861eba83c4a0c8391bc7793718d90c708f18a13c5c6482b0d712d19b964bef28687b88766a4068c878a521443a441804d4b4c1611ea45e0d1a2daa5efa94f2928ef4bce62d77f6bfe24a4264ea67284725f96bbc2fe87a02dc5c576abc152c4629c215a056fd69578d6d4a3a54891be7ce8d31506b2fe3562d8a09ab886cef45eb75efe21e43a19ebe18e8c48986a4ef3220c235131f217a5f2e4f1e72ab199e8521ebfd7acd7b5f9d8ce7a98824d09d79401f3cdf309e7bc8e7a4d1e1e1d0eaccfdfcc2b67099f078ba61dbb0edda801d4c8869268ef79730a669acaff112cf65bde77ef81a781b999797f3ff200cd95d0a88468bf3f7ff5d218e7b502484d35465616d4fd3693492973c368d4a30c9d85cd7fc5d251df9535ef968a5c3fef8e46a258da005b72c0ef66e57dba12fc189ad5f7bc0939472750416f7d44c28d0301ee430a10e46a94214099e87c1ad6efc5b981d90bc74e36fbeb6d2d91e650da629f9c11e1e3cc1c96dd315ab62555d802bb3871e9e0ddcfa8bf0fa8bc75cbbab25f9c092216a5854cc60d4836bb683541e5a364d3483289fb0f3356bd22438d5f0810bf3841fcad2679065d89fc53aea3cfa3f870756838b2248948a0d1256f5519529e9076b7462efc8028db283265aa95a19b917a13a0ccd9f65b66fb126b12269e6134473e6f2b1eddd22ff93a5326cd28cbbcfb8d1650dbcbf9e8a4c9ea864861d516723fb422513062c0148cf33c20aaf1c2685b28e4e2473d5ffdc85d2c342ac4029dc746dd8dca03818463da4e0e5606539876c9cf7481dc393b3052aaeb46ec79856dfab69994a3c1d1034e205304f85e560c560b2afaac066bb45347c144c00e77d308347ee9d728ca2357c3900f6942d86e6b30e3951636a2260352a1a0553830f3bdfa16348311d3f2ddacfe02954defa978727172cdbf6224ff16108a55a83eec8ad5037c519513e64baf873c3b82657c6b9dab21fee7063382b2fbac6101097fc60a46858d32235fcb69d6ee6771900ce1d0cc68117a1e805f50d9ab0ea9acf56ea0ef126e61c295da57cf021d54d1faaa091ccc6c021ead91429a0abbf2ba84db4ae53eecf6e17206ad6293c2b013bf484c1e7c8415695c9aa170177bd673660b6098d3098f4bf253995936b52943e35c76bbec5a75fa35587ccebeb01cfc5f4921b803bd27a80a28cbe59994bd9d9dd1e050fe7c5906f100bb4d3290369391f50173057579174099d03bc340717c0ad87fa38c935222e4ed0b660ea414a6cdb0317c091739426ff5384a7f143af004fcc51ca1c4ae068445dfa8a12a6e3c5564a665cef3ee2f3c7034112734ae6fbc34cc393580ac5bd132f76904b132fc1b57b22c72c02f0f0b0ec3750376a89539bf99b592b172dea47f73ff5a05f0c9a984ec092de62feac5eadef4d5d0422b16ab5ab48c5b14d5f1fa14ba1b2e1b0c1dea651eb3e45cc2624cab93d9c9741db023d2674c92f3ef4eb94826a06beaf0334f4d1aa4100cfd3ea1b514a57ec261a5289241abb65cb98b64e4895ee340254ba92d69e0892367184368582f73ede819fc99fef774a226bbd0ef765ddbcbcfca0ea5e0f5a3bee5efcac7002eebc21e4b01a039f471d3fe1d934b7650596e6419a10e64ac8926435ffd5d1f8b8644f1eb62417c09bac8be964cb445f4d2b4d072a21efb1781182c93fd1e214334a41537ce28c0f5212eb28ab6b8c4a97929563513be195cf98f2132e640c170eb2287d5c5e353a0001fb43bfe205e742e3c2635e989ac1f3d53e394ffd15484d7b35716ca37bc4141e29d4e06d951f5538030a6bb7619bf7639fc91bed5ec8ed3a3c3273bb5cbc1283bcdfa15d12f451ab2fa80658148340ae318cd64892a0472360da729a334167894266174eb6ac8dc66b771df41308a0f2d4ae8181d8f199be91eefc1b39385afa50741019e1116f70332b7e690a1351ba204a227235248145720f2729f397668750c3a7425d392b0c3cd5036f5a9ee0f8e9c466b52641a078d725636c2cdc9fda8aa8efa682fdff1744025e81f02056b0826af44404e17a89b4f5d1a05f52032919816956c0f7a072284f0fea124e49f736a64dc7243b34009320ff013c46945fa293df0a17d76776cbfb8052fb3ba60e2202d6ac450eee1924b839c86d5bad934dfb9f177713b4cc05d387b8bdfb01478dc984761f89d5a2b0bd95d503a02e9dcd53843aebf31a7d391935b7915f991f7cd7c68937e548a9297836eda963716920c694a0ecfebedd27c183ecdfc9a5868abd4390b03e5a08765f1f14b42e3ab8b6aa5bd0ab85acef921ba6e019bd153f6ef56575f2a44d3ef6c275c0cc6a0addb5d7b92e530e33939764a3240e14382ac40521be4ee8614c22381d853d5b385b93982a2a80883449d0c5d0987ff2c6cba548032cad9bc8e69dbe4bc61bcc30f74dc35a80a9aa6040f559c3cceabb4f564b5f6b1f3751456fb0750c02a1c9e79fdb6bdecaa9c1a54a38364630a7902f10dd6d2c4cc1c068e7e0fe1bf81d1992fff25430e99ad878ca44cf133377ff19e01147c400c1afcf3006428b0c4e45093b3631bbeb5dfa3412c18601ccac7fdae9e80ad1b585d6e5c71d57213d51df4552c36744c0880401e1baff8182962d5cbc1cfb74292714f00cda295ae4df8d5294d96ed3532b6334b00f8810f5216ca36dc16ceed8b6cc52ed7affbd69fa84cdd3d5f7da6779fe696dfced029fde9217b8b44e8e686375cf8ae0f8b54c18b860e4aedeb9b1a4cb129a5b50919edf4995e99f23c9c932e62fcd9dc94d87ec8e79ddcaad3c3a83495b4987b5e1d0dc7f64f495db24832e276bcc7d11dfefee5528fe9c2cd13e3b0f08e753ecb629fede2fbc814b2a66ccd7e41ace0429454f5ddd5a401ef56555b5ddabff5dc8e4bf458c0bdce4488ab73183c84b373a0e4eceba1e3ea787184a94f3f6ce855ba46d21b6678c115248d9a6010c11dbd280f4ae5041e0d61a0e62a4f74d8272366124fecfdb8d5ea5771bda0d2267501cd742b26df543811798073adc410c0d028f661768b664e8cda933dd646e7e093842f6f9d43a770c6fe4878eb4c0aca1b04464cd9272ff59bbfe69d07c29d8e6d11b6c162eda24159bf55bdf2e30b150f70cb0301302c3a8b55e8baf7660755899cf7aa8ba1b6c17f054d617036adfe6974177fc10c57d12f4ff3d33111a9d8b42ae2396a9d7547c442595f2197e8255d210a8cf86d1868296df474ccb8af0eb80fb1a0c829d8173165bc2ae031901e80068d3532fe2b8e88bbfbbe6e39a1fa9e1c185581a3e62c280febee5a0d7b4f48a1b1e851d631a443a609749b8ac373cfb2e6ecd8c95815ba39050cfe20fec6fe3abfa3ba19d16ec2903d5b94b6a6300d102c1090881fbf14d2df3a00df6fea01c90354645e72b99bd64bf00f8c045c4b754d6e5d25fb80c2243f0628e9ed5bf40d8c3d78a7494bfd5bbf459b7c73ffa1f3f062531a7cd6696868b23d8277160341e3bcfd3f2a6893decdc683fbcca988c50decbf0ce8195382b62d97fccb9af6d6d2d68995227d33f27d4987ed84ade43cc9e75d93f536fd1eb85621e4ae727749b6b0ed1f78567af06c08e1d877b3654c0fc3b5dfef3ca96914e488f01f70693bade249ba77926c6cca550b11086f962168dc3070ffec63f9ecc34b57e12036cc94201fde24e1a1f790049c594954adc8825942da05c7bdefba7659151a5937dd1ea56f88ff508237a2bdd71a4b4c758cab28587f9e7ccb18bf8855b1c049d2ccd173231b4aab6d296e2dd636c963f64d228c94aa294b3caf03e56b5ce103d2a02d28ad60727bfb7bd54648f7b2b31428b10e83b672b5bd31648d277c063f0348003afefc167d76bd01776f282c04a4db87a38019f1455239ef9594608117b9c96ca0859b0e959e11d549df8217eeafa129a7d3d2d2b5639898d0251685292e261c2db68ee497246fc789cda4e96c2cf126fc81f9fd97e7fe62cb027b613aeba99b1803712d49f60eb3a99669c6d19b2133e29eb7bcd8ddf1184809fe8df0b0dcbfda584365852ff8b0cbbb611939cc3ee183b514a532a951ee4530b5b2e3a92fb414ab06aeebb1b599b5254bd1035269fccb9a218856c54297470bd5e54fdabb1184412168f44d65b3d5c76e931cbe956f063e4f91c4fa99e0adf9ed9aa3a59e9e36ec8cdff8997e42fb2259f8bfcca67f6f90e4d7b195c78ef4394a940f28a18d61e1811ae5a074565aa517b7560d8293071a6bfdb15ba971442a30d7a2cb3722eec1cda01299c05cace4906a3946b89c2009023c45d1b2cdebf28a8721a58d10ca9c9cc50e30c5d985312d0c570f9fb754942d6d2e397c127249ebf9453aa83badd0cd1b4bc309eb10a4caa38b8651d89c4b06c83b0bc6b87254e7a32c0803e8eb60a5db8e2d53971e7f7359d6567610a5141cbf534b57d8564d3c29f5b83a1336cf812dd24405b99659abea703a12e408b390e7bab635c03be6616a3cac6deadf35dd658d6447d16726ce3725918dd6f69f0f261b8ea8c4ac6bedca2f3746100202ce5347faa3df0612bb1c5e7c74f4ddac377fecc7592437aa0776d151439b2395e9f3409bdeed3ba30559e711957ad15b7d86eea0995fc927d0205d252a2cdd9399df693b28b9c58d595fb4b5a5350495dbd6d23cfd85295817d586cb4cbcc981e9fb954df9642fbd9b10070fe8385ac8413f97a05a504ba9a28e883fa1a73f5cc0e5e62a6d29f7afa76159db4f7ed348055808a2311030ebe831e96d1a176121e06e302a26617b36936d281964ef29d14aac88569fe419b7dc87c495ee4ef156fc41af2fefa7ac8cc39b6142f75eca7b2fd1467a10f707180d5dd67341459aaf18f478ab8e62a86d3fda49ce57f6a4d67f263f7d9f21e059f366ec8ba169c0afac42e373a63c3e4712e87dd05985ddb159070164a240cb55fd0c71c481b2755f75f00eba172d206ea9134cb818f13f5480bb431e2675b0f508a65fd9129e786e28faa2dfb44d475d784afce4fa0120b1ed032bb96dd1faee64244749be3ec6ba38cd3d5d948e0345a62374d56edd698fc6e963dee0a8040fa4878ef2a8bace9b512a357ad5f4a3475d50554a8213c8c9a36c431aaa47833bedf253c5eb4a38dfa03eaa18bdb727382b4ea679c93eca6b5d5e1f4e54041eadca271f2d6bb6d72f00a58a35480c3daaebee943dbae49eba66f9f4fe3056fc7f62e9de6c8b0a3adba230da8f56fe843538a080d8f0c1cb16be7203f26a6dbb7a0c5ba7d5c7076e8fdcc86c2c8609914a3e99c23d78de20b2e3724406625fbaae9d736c89ac45a94442fd50b65f4eb33ef552319cdb6f2e2258691b6f14a60b084cf80599505dcc362e7c4b0ea66af968f0f3024d82fc55ac9086f8e6ecf675944cdb96c9afa1b7825970397b95ef75b691a07f1d8f80ff1ea331ad251d661181fae6c6f4f82e15feff026772cacaa13d88d60b9fad6e5dacb9dfdb9e243b0aa01c4afa275dc656ed7e9b470288cca67543616224d8efe7d7e5d1491ce0a821b8839627f02544a4c9bb7a42984ec645d756740040a15b27f8c11c0d3e2a3de1ac7ec121931794b41d838561acd91be82ac0b6d814769b363e7a8fc7a4d40b7b89bdc9b42d1654bea59d637e17c141825167925a6df93b1fbd9dcf776c9cf4dba854ffe33938e53bd15ef25f4abf9191b08934fde6604c900c5372a8ac22bcf882de08cf5effb1bd9db040ead6ee5ebc70caf9a7184261da9642364d2ba2b5110fc85251de30d0e456009a15c017db3b502b475193a8d761ae08377d7441cca9bc129a986eb4dcb52c1d494fab531bd59543047df8cf0be61e4acd29aa961ded245278ed9358380af90f663432fb28c45d3da73be7beb1cc0bd041644566b3f767ff80a462c41315667ee1d3d463e66582eee8e094aa3cadda03797924c18479dd26db6ca7187eb0dddc3b79190dd4e41f20b6d55d7ae6085d198e4acfdafe2b6c74352eccb73e016589f6d1c2bf580a0de1927eb88fec028b5ca8fb1aed6cff508cb33a5b679fbcd927cf5ace67298e83b1a319024a2d2faee8bfa932d86556ae46174ed984740c339b1deeec9ef13dacef9971e2a78a697b12700680ae69773ac663a2f55ac5ba54f07b69fe529d212990dae91f601f358a38d9a3d741d452f84dad9b7575940f26e8f0898a3884852972827291d02c214221f19454df3c4c1bd48ce4c12cc7250e7a95bfc4aa0ff0e4c770cfcc178e8a35c14b041b5cda0d862a8a4375b4bbb807def75eebcf00ba501db9f21132f35f721d5e1ad7de49a352e33d6fa736f45f10272b0cfd16d6e7486210e43d9624ba5b199ed223ecf821f05009321360cafd0e59e8181d2fac17f2f3d812d182385e602eaf89304caaa175f5e35d92d25eefa4b264f26a00b8ec8d1ec7348678675a9d0e7fb8e91f5200ca14388dd495621c0b04b96246a5549469d85ba2f60a0f063a6b282c07f339ebb526c1c060c485be1cf4449aace48bde7fe6710c855d175e21ad625fa4ffe17a24cb229bfa02b1f2f8dab63ed9d4e95846394ee8bd86b010a85fca8ae89614cd810153dcafe456f0ff020987b9915ed5959ef4c5a81bfc0258939a1be074d19955419e66ce449ab70cf1a0ab92575ed9f34ca86bf3caec100095faa3e487c00285bf8ecca95f005312b03d3ff8fcb1d8a418ac4f38e1a515d015c48ac6201d241d91092a73cad852f45540db71f21c25de012669116fdd6801d6080aa76601152836242760813020b5a590206e2e1d060e2a57680846148a58ff71263bda4583a5cdd3d5836714a71f7bd4e324f9d6e1ceb8e1f137faa97231a98e120017a8c8d03e2c42bf46c4e398b9cdfd7101687103eea044c4e8456421ae8014ab8296ad1c004df4525fac581a46fe30f54e995d7f00772108f6f168a88a3f7b476177991bcd6073515d30d3345bcdc0ab3ad33c6219ef4d9a4d4fa077f42a533c4ec1ac3defeb7a98ac86fc57f90ffd0d14b92c2ab31979ad7a1aeb5ea65a59ebdcc0327cc384e54713e5cf881913368c80e4c5e9c3afaba5187a0698bb60bbef0f55b6a6c56911aa39364138221d3fe1ddcf031d78c58c6e2987c162e6c906331ed0f7dcb96e68a2f88529bf2017861fccd892278621289ae12423033a2f661b03736351242f21419ea0cd1d8261aff945fb54a4ad7b2a054fbd2ccdd7ea897d23af73db8429c2e37afb8b7187aa0ffd49e9bdef4cb600423520e30489dd71fe9d6031a75d7adae642db0e4e357f81a8365021e4348072b16e1dc7efce84295ee2e5a77077cc031f8adfc7ec88c7dd978ff4835348ca457471077d4f225e5a34773b12e26283477d93418b72ee6cf3191edbb1f954bed3ad007c8e8742d223cf3a97039260e33893a9d913cb2164774f577db0a412d670cdae7211b06fb83247d14aaa7675b9cb748a5b008b2f4fe944a1b5229c37f8ac912f1a785bffe12e98243eb2cd3a2809d62289ee4ef38ba7ddc0dceb9593ac673ca86af22916700f3ef1b3bad52fa314c3bf532ba144133bc96627ccea2d10571af5b2cc6d2dd147f9c5acf29a0ebff779a85768a057e8bc23fbbc24e1df170c6aeb7701190362c52018ceca1af9ac556dc5dd686800363bd12c87b02686ecdcadbbc53d8c19cf842a961d4b1c0732278db494b743f6b1296e2de37efeeb44a1f90836cdc0451b7d24ba65b2016fbdd5172b80809815df78a990c84e146e8ee8a7ed31217ac2adc8d8f23f23c0543a92dcfd2a8af1710139ac8b0c704ac759ea07b909ff2d4a0c35607cac7dad097f1e3de140ba2f0af621c68d7318c45828066fad70d2700f3ce84374897faa34daf559d357b6b38910bb1a0c766e2148cf13c0388db0494f9ac2f8e149fb7ea06ebcf33dbfe6cf7385cf20b3b8314c18977d59088f17f4fc175a9fcb87f4fadfddb4f54229f05376bbb7fcefbd8f8bad2955d749a1c21e4457273c3a056d60970ff9726c77e063c490e8813b4cd22484aadd4414da1e0835ddfde7cc3ecc2acd7f8c0ab735fae92f74ed4b88ce377d18ce13f85de6b4b06c06ecc76f15f3f38b7e3778731e309a1dcfebdd585242de71b4f0a1b9c1140fe43a57e5e60df7139e8eebdbc0e9fdf34085b090780e783cdbb78fc47446c74baa2688fa2bc274a8e1117128a66b99f134ed0c90d253ad1c53c4e5293fe330a551ed23035b4c22d7b74bb133402e57605a52e9247a9856ede4b557102a61ff32de3763a18cb3d7c31121fe78f3c1852269b01f1623b2e1b9f8a1076c7b570c6382ee348f470b2154024f07d20da80b08f7f45c4a47fe409813224af03dd186eddcca3c998291e7878518d22c8fbdc18d7d4005678489d29b99dc34061fb6adbf85b5e499b8a977f5e3b3043d64068b27e81ce6acc9d7837aa71edac209120bb234ce7428e230c7a92c7daf3b88a58a6e1fbab821545ede3d2c44c1ed8869369bb41fe7ae6cfa20a1c3e55346dfb741209cee3d24e8c459a6459e5da3d57af49fb6e917a64a11b11d2205c0918bc95b611b6b13fb6f737189a00aee4f3bad8ffab5dfed4345e5c65913b304bb932f2adab083e5684529faf536e6fb78e6759fa3d5716eb9bde830d9b1f42a87cbc859462b85751de6d2a445b392226ca149d16797fd52b0078b145fe003f27ec392cd051bdbfbd57dd549f68cc923c3edd5fdbee841d3daaaff6f0ea115cba0879eb5d4c9d27107d63d3eabbf0d461f9a3a5707efc20f14df9eed9c7210d7f144df8884f57ed1c7f5613d4f6992ca1ab023da72ae1152cd45b99ba1eb3201e2e2ab9ff52615abdcd448e7345516197328ea4ed7c019ffa2ada024076d71f39dc210a7b451401af24fc73e711f4b13cc73d4a6e1281c83be52ee4e60a370d4d5eef1246f68187ef1de9a174373242b747c71677db7187030cdccc49fab7b90f707da3af2d780c41d14c0d9384cfa7f337fdfcf4010f0d66ad8fcc6ad914b109b3f9efd7903efeb2cfeaf2a542bd48f49f53f303653bb56b1e6d402c433f7ba383c78d30e6ea92e48f28786588886d60f56a094b93e744c7e0cfa05f2a794e7687f16d554de183525d4550a06f21ec32401880c23981c4f39fa19b9ef71a6f4f9d4931dfd10611b1ec9a2f53c22650f136a485f7a9b7723432d9821ad983ff9fe32e4735658a29944e09a2618a061e42249ee9aa2c4ba4df92ddba89f7a0960706dd033e71ce7c7b6bd3c178ce4a3691bf256a0d7f944fb0b67226e2002bd2911ac85c95c6e62f536f26d5b951813dbae4435e379094c66689893865fe3f59c3018dee7e45e4b4ac733df3c8775cefe3b35c05fc607ff4b8bd4c42fb0e5b0c1e8d992c0e51777f8bb875f4e070dd111b6e215f04cf89b92670d0c4a87afe820e8b4b1f0ba6362b9bc1a1f27db4d8996b5049cad6ee36714d868faa1f1b25a2360968eba9050aa15aa7ad24e5f7039b171a3c128229a8e828b5eddeb09e287265c91f1c2e1b0fa00f7cafe87d4eddb6b8b22b307c928cf60a85092c8925c42ff3906b67ca0d6cc808718a3998e3f5b22a710079976b07bf1235969f685587a28fe267b6c453a7a255eeed33451386895ba4935fe5ae413147862c6982699ab55ffc57a227abe74fd8771feea8319d1a069375c4965b19677e9db4bab63541981dca05e4bdc3b4a39415960c1d4c4e34ccdea5c3aa04a9adb7bc782fc84322bbe881bd7095d23305c6a405811990ff992d6d9e7c92cbe2e2c241ef0aca537431981e957a10d455c70330e35919507919a4d66cb55b984bca348f7e1b4a760ec181e632f9a93a48705effc583d4dc78711d3f9b01ed9100d859baa58b754818a066e0b496b57985e4d5c44b468a82f472e2a545636721c1488d7d3fdb06fd9a9aa267ea8a9b30a885cc48a6e42d1b1f319d1156e1dd71aed54408634eddcb76e9c4b793b276d386897d809af3912655b36fb4f4fc79b01726666350273de79bc9f5a23141d865137d8e5448b340fb42f94c4b8c8cbd0503e735c7e7d46befb50f51a176d33baed261c2038a4faa82d82575123b329cffcc0156fdad9bb105d08d3f9c9789a67846cb4df1f764912498c9c26f9715e5657763fae4ce69fcac49afe74b4ea2ceef61d7e60b49f079d982ba6c36e05d1b7ec2c541297b6b8c0ce68aedaed6ad9b7c5e4b2ac8236420d23f6735c5ae77eb727b07243bacff2c1fe31227cd356558ba5b9f1b2347fc58d992624dfdef1c9ee59b5c9c217cfd11132d45208c4ecf8b997197789c884322fad4107925151e2ef978601bc86df7126a06c04a6336ea11d9bb5473c5885bc1f4f4e4ca865913bc031b5d967c57b1b553f1c0828ad189de6126b3ea7024b990b0c1ca631f2ecdaad7c2fc0635fe031f47a2347b191e70d2201def03712d09d9e6254c167fa8a73f0bb87f8f0af1a4708b3def0f806ac476858ae6241b6ef92b7e83cc1c02def883360901e65ef6c8dded4b8f3b15184f5f0e696211318e73ffd6a651bd57a2b81554e6d4f3c642b9169af584e24578fb7685fd6e370cc0674625ddc46882d04832d87c2ccf5df041da81ce4e1d35b11d1b0055f0bbbfd9214f5216b239fc63767ffe46cf7f0a570d5f40a8bf0e95cbc8ad1fc481487812200db8a029174f3b7d12f31c268a6dddcc43bfe0ef7326b3799b1415d8511e77a34d0fd9f673c168cfab9c712d460248cd63dc572823ac9db1a267d2ec28776bc9e72a46f4ed5d8b7d981a57c3b042c7d96c2f26381245d17a5eb02f59491146a5b616b6ac651ae46ac71d2dde056e805becafba0dbe357995cb646fa2c08d50b3a025ab7a2a4f9b9c4b158aff8e04b6f54d3a576b57a55c14dd767aa308ecb30ae4fd4d8a21a5f251080cf4cf71c291ff5a915487d629bd905598e9e96df57fc14b6d5a93bbf9498f2ed5e39f01daf390c98893cc85a5b6e51b9d67c85ed6f68c76355f965e57172b39b391003502dedaf66a42c1161aa1bab87aae1397ec532224e4b07ca916067b06cb7e453c9fcae910ed0d6f101d46b3d56e055864c5d46a5af7723992aaecdee70ea673f5940f2ef4bd698b2e9ff991364a3c1c13516ba1d1228a43c953a3a68d180a8ea7b567c20820cffcb1a4050934f0e92b3dfe399e1b085bf42dc9030b3a072a52ce77e27c811ffad3626e77dc0fd47c675635d6a64b3e66c94b89c8eb6fcbcd67dae8ec7d932fcbb68a1163540cb44292df2f1687e06facba88b8d44c110816ad031b1f202e201e589db477030b7a9c06872941ea63965c9750abf7e4a30fa716ea2ffe54188061f443fdf2e5e0cd8a629440ebfbd7e9ed232cea70c95f7100cc98fc33861ac66e7762c57edb0891d280496607b10760c4259305cd348ac9ffb35950f4bf3c43bf75a81499ec6097599c2aa302d7a8ca208b22c20f0d1abd690c41cb297e7d190195522a4fb1d009097fb170568d726d481ee750103b8a1dc35b1274362bfee5cc73723b200034816f80e8afae2d52cdd9073c6fe959dd5982bab4c8f74d16673fde0850cdad233d14c9dc46c3a8eb83307df06cfe507da8942aa07e0bb07024abb818875fbec4516c8317d255db931fff6354a10844cf078e379c704e898e4f19bd117841b96ce4b2e34e2ad35a7215ecfe7337d314a7ebdf66762305b1d0faafafaca2ec0564298ef486ff5fe281a63d0cd7e4f08964e15c6a9ed7f1f5a210190f02150722e8e8c63373a4621187aef5e90c8ba883687dba0afa3ac9d3cae821d561ccc106cbc17a916ffa748fbbe34586bded2e30ee30aaeaca6cba69b519b6600d3c614efbbc92e8ea16177e46710e35804d61df799ed903bd00a4cac9e91a143776bc8edfbc677d60e81b29020ec3f8b9f3654b8fb6b530151ee96f76ec66cc977f8a50d09071b7f13ff7fa656a129cca6ad11ff7c37971f84db0ac2c0ba55d69f3cce367000cd960a738b18e1106017f8922cc66ac06455d23b026669822eb0f63a645340a62c7ef2dcd2d9fe69a8444b394142f184aceb430d98c43cc73431354a6ee4529e32a38a8485471825950d031110b9f3e8993c1eb992f348c643f3138ff69b8af0f635d305143b59b0b04b9c6d4b4c05f1113bce4a096532549d97b86275b79001f424314e92e83d7b58beb1a5d973028bf0a94932d79e2e84854346f9254ae057ff7b100aef439ea091c17cf66dad1ce77f9202fbb66c22be6bc7d69c2aa9ddb1545265f67889e375c970147c894a51598fd34f91ab840e1ffd75ddc05c2205834834f03c30fa8ab9216153bff041194c2df0c0219addf40bd3b25284dbec9670e67bd1ac3276cef912ad78091a05d1ff33780a9668128efb4d05009ed0345c0b777e5964e67a35fe26ef119ca7b1a62ca22bdffe820ef2badf6c52c6c8f0b09a128eaba21f78b51998865cb65036fec1fa67df8a312bed6e5b97bb1ace365a2d4cfb94c2c4c4f5f66ca4b36163b4c4addb8f03ca469d1c4195cd6e17919a8d862bf56463f38adf6bd69ead2ec8f643b1fc1a8e4e9e413f0333b6a9f946795d026267753b9d0aff5b72723fb18dc4eedbbb13358516c5e239080d445468704c88bd1a410e1d083402746f300b58e849d9ea52b561e55dd3bc83ad287dd402218fe0e3bde8173f6ebfed99b7e5941b8c902343d21395658c3eede56af29de2edcbe9761b67d0008451c8fd20a575a9bc4c9ce8201eefe78a344e7183859b206054507d459558dbe563e5aae9b45fc06a6d2b9c716bc9b285f1e1ef9ed125816cf21516d6f611af7f74b2f97638b139af7ea41687612492b488efb0a26485008aeaf8b347cb643d7b91201d8dbea3eeb955eb32434f444a5cd680f36e9150a8dabe7002f5ae7341e152e747ba9776b0df6ff8111ac730c0714846afffdd7b50a7a6cb2af4a388c8dddf50a4666a1b448c98587d35aa7388d8993bce508ba6b98d7e6ee26dbf7f052bb063ada4a6386c06df55054ac78a8541ffe2b88e36b0033238956e9516ec145aa53f5f8218d979bf36aae0f3ef97e81414dc1a0f590ce1cababe57f60db9182b5b5194fbb13b3f4727d641d62bbe36cc7804023f5f9d9900c5792c148f5413ccbdc50d35b4fb18c0ec4c86cc35ca38546f235256d2a997e7bdfe2d4da8b1c20ab2066ebc1bbdb16a54682d7c379350b41007a3440a212ad7aa350e84e9d0baf9683de1f451a449b75cac4958812e2b9c71d690ca627ce16af40b568c0541edb7d0039a0105056c8c8b8080adb106a421019a5e26dc369abd0594903b0046dfcc4843fc10469d3235cf5329f6c37b7a1420c3937947ae7fe469744d2c82dc828397c3829363e19a6dd4b8f51082c45ebc9c01ed04d227e8ad78fb8d6f5138eb4de38d66a44c0bc4b8333e254d9f2be231b6278cb264b17b96455aa7fc605125c059473a2e794285f4961d3b349aa0bd5e311a0caae40684731673aa22b67836cf47262e4b7a51b6aba48147a92f1f81ad6a475ecf6fd9860dbc4c70e247faa16a45cf1a132601ebebc25223080ce8a0319275551641803af3776ca497644ec241063b2494b3fd30a3e76c2c32d50600727cc65fc28c5cb08211b581cc4d7844b896d936e66e376f9f3a36fdddf2b4991819b015708c6c715940d31baf8a9c6fa79e95a2ebc3559cd3ee16a1e3393b8b5e4442ead450e101837265a01a1bffb0851e155718a35411576ab211c79d9ae990d342f9ef270be7f49f2250f5238bf3a6fe64dad85bc225d07a8c480f2ab73cae768e7bfb6350b3ec85c56e0eea31ec4b4c270f24aa957d4f60ba5e76ca8819f387b42289456f732bbd8b25ae9adae530cdd2f79704e8282b63a55ee3f0855ffd9e2a94272b33a08b5268e0d7a03bb1139dc1a13d014ca0f290bb1c1dd3a9461395ad6626567db7734f29741a016a5b9d31f414bb13933fa7b579cc3044f75017b8793b0bc4df4fd56d84ee203e62356a7bbf61a328149e364c9f55b8d9c26fc9ac33b8df20bc623ea7fc81e6b79232fff824719dd34ab9a6df107f6dc1144ad331cb68f3747c889f254f9f55fcdc3dd355cd8c177d55181f46c4eb4f6fe283c7737d6545bbd4e093f687cb97aaa2def7eecfc21cf1ddb831dbe6feb84abc5009ae363604231083b859ececa7be8473270d7e01240aa27ef1f9b058e917889b0b6910cf502bcf99f1d5a556d8af779742493bcc5ca4f5bde96586a52335c28ad1dd75a99851c489ba3e41658d1734552ccc132ee9ad64cfdd778041c22dffef364b47a9527602083d1d14630525340a969edf4354c1ab5b8a261b99b2125685b7bf8d6278927492cf83ea9c2d42dd3f249b81760a3a59560dbd6abe4d404076007fb3555b7252f8ff52d8704341366f5d96045fd27ef17e5c6a3bb4781f11fbc4764b5980c6b9d7fbd3bb3d5294a450438be83aed1637719e6d9751dd917519a8d4bcc5838e2289c0b92db10bc1bc11c7fd1fa491953892643800526ffa25a94af0c5a5681803a733310afda99b8cb4ca3ac6d9586e8852fa974ed347c1ba979400cb285a635fb580a8c73bcb123a35dc827c21292350075d9932d53e625b523443e893d5bd21aaae2aadcf405bef61bb45670593648322399f25c4cd01dfb8e549db999930703a4d290db4931f394c8869de736ab1cabd9c79d76370bd8021bfb7589928d15c56ecda8d3849ece3c441affebdd809735a4751ac9d55f85cdbac02b0be5e802ff82f0e56194df1e2d477543beb3956db70073cda47dd3b9824ca4da74f8059453fe4c13001f0b9359a593dcf81622cb18ef419edede6160ab365416bd1487d080c2eeba5d833332fec449ae0f500f6a7c39467feca03d6911cbe0954506cddcead7a10e7ad22efad55a3cfa2e6c139f839cf20f68735d63d31c7442fc8570c038f1259ab3b9293cf72d6a2173b839917f5af0e75b5f210c958960c40755ccd5ccc3efa83de30064a800b93b4831705805587f7a3a0299a90d368e4e7ac96b17bfdc28bb46019ffde2050a19fa17d08e800b12ea3ad78392c0e60a0f32ae4fe4960aa38c6428ab8b6c899edd250ace7748fd755c766de7630798092bed86383513be33f76e73a02fa3431fdc2fe3d925dd0de62357a2b13d6619ee6069ab3b4e6ca9e3fe61a6ee94b64eb982dd346a24885f3f9670b14e679c1bfb6c6ba22e5ef36315f2a0ff2f455f851c2c1efc06391ca24243ed19f32e998243c432652a529ed9c706c2d96e5f3534e645d344b6e9384d95afc3f41e0a060341ec1456bcf1d5e46b5bca93466661dad5db202818aa47312b6d2f5560b394b6830c61d6c983d1df64825ac085392003d03a610f493d15c4c421678a59e74d586306da959742655a0f80515cf19ca5908094e1e0baaca4341b1404b0c11c4bcb9789d9eb085ab9eb77ab8d55cfbbcfbfb4f34b92de47728510673f508972a906259dc7bb6ac79d1863e22fbf311c40875a5a1caeb00883ffc1737c99c23ea33500ccc04aa2071cc23a990048ea2a633025ee45e5df4ec8166ecd92cd096b928a1fd6a3abaaef0fb01c6b987e48283bdfd56334f124945cebae732033e62b63181e1aad235eb1d83dba41b3d3d938e42bf179b201db3505f567b8feef0f539ca2615fe9f7dc2989ce2fa98277f2c08ea15018563f1f9bfa25170acf8c54a2d630889df3ea48fab919337bb404f0f2426d284f08337ea9bf60388163b5578a60ebd7206836970c8ad1052788715ea15e31c1cf3a18f484adbc3dae96aa9fa2f067d4acc091c02c3bef38bcacfbd4a82cbe66d2a7caa07de10d35350a32de6165d5ad24a1232abd35b18b75d00d1eaf7d9d904dce15455aad71957872b2f77cb6c174540e57b8c6d28134096b1537434794727f3b5c686fad411b5261682513e80aa8f8cefe0dedb89e001ea04b96fe679fd4662f53a53a1c2af5bef51ca9f14132887cd79e47431b01bed2fffa10af0407038c6179a5f3114cfcc7601b0fffbbe70503fe13bc489d3bf7a292a5c7963c4a598e237a2d18a34f1a3f885c9db994c093b073f6d2f51e154b7b07dfdbcd0bfca8fccd4dd04d28cd14142daac48b71cfc2d1723705f2bef6117b7cef96ac977bfba06f401b5f760085fe8aed3b05a7ad1c569e55e0288903d6fc555ae2913c34c268e8897b8142b021fa62ee0fcbf3159bf66050917661b1a31c7f30a487f5151e4c1f14cf60882e3bc464011a56684993d0ec608d8eb1f027cc3e6e6fe442de37066d13617de8c90780569e0d80db000beaeb227c4ca8e25e30cf36474bbc2570ceacdd0fe4aea0908d8556eefcbadaa497b976b3f17053479dcc6a59089aaa530e7cb776e7fa7252c52a979c1d235c2d726483a4173459894e5c18f32056f7b361860ba86ff928d3d257018f05b830d02db7a7b28e4fc2a5d7d264f00d427043baa35aefb2d3e4e6d8b0665ba78866bac28eaea94dedc50969b0544e057d889208880d09c806c06a4048510378fc7489e8f4708b4fddaade43e651bb440a079c39c85c85dad87aae1c926557546b5a3675de2b0227c235c2dec81602bb75eced1d9459cca83729c5a81921c9b5f86bc7aea0073e4f03c79673fb1628f46947627259f4eb52caefea4a15149cb512fbece311764aef1a65d388b79860487a8ea37cbb5c39ef669a69ec3988562b310b82d0713d00d1680a9bd49cd7e26466f528c27758be6e7bf9742b3e2cb6273ce006bd5622caba6b8ca74e38ae7ba1bd7d5a376cb347eaffcec6cc324971cb2fe95ad2ab75f84e99c3b518ac1e50f7178c5e13ba1406f14932a77e2fbbbb728c13c5fab3e563cc41ee84451eb5ea58916a13a56d2e5f968269dbab053bc0adfecebc0c0206bb27d562fadf144f24fa5b7702c4a576c9ea89dd43da3977262046743bb2090f417447bc3a7a2c8cf8ff1f9f805e021615a1bd8687f2c2f858a538ec411de89c2ce96ea01f9756dea0da769bd5c72d8393965a81f16633df99cba5e5ca631942168685383dcaeabc4d73e5cce1423cf9876fee00c43307dae2f511655e7fc48427a81884b4961cc21a6f71900fd09126c5478c08cb92ebe6b7868e61b7cf2d1605c73addb6908e8b669e6a3e46abc44e52a7bfb6aa444a4f3b0da70766d88203fdf18a24b6a4109a69aff70d2c00ab9f062c3dc79d1c643c571f31b2c7945f9004e9a4162fe08bf798a768861ad9a743b881e3422ba3682a37a9d68a885ccfc3981a1d9d53352d211c124d438caf44ac7f26aa213e7dbc653b572d0fac72d8983ae71cfd8aa0983eb6c4c1c82cbaa7d785ff7657a719a6bbad4c48bb9a6c8a92ebb7c8bf89f1c39153df9873332eb5c822e26839d815fa34805d170c55fe3bd053dd1e22d7df1419301e8e9783b49ece1c555fd7cf1522376d3ab18a33cf3fbf289cc052037f178b4a2a9437521a540c433477f538270239220dbf67dc4f3032b03b3fd121dd50682cc2a099bcb931f4838bb00818dd42e2b1ad3779d2e4e2e5a62fa1fa4dd7c9749376cde70166e4890269cc91a023716bfe36180817ec477af58dd502b5a3b517190998562af2c5216479c8c54a0b0e0f410c681c2ddc03052d501bef57010b46cd043cdda34ce698c27a5f93533d3f83c739a6c544dca61c60c47eaa805aef2806946c29fd83f37eb1f3d330029ba78aa9ba8a3b4e9fdd6c7f9ed72349a694fe1531a119dd85e364f06319978dab2c9a7ffb102f7f8098612d6041b6e9c19468171c2cb6350dc6f62d9268afd6811de28d9c282b5d293787ccd5ccb693173a50d44c1b4cbe9ae03a95649d376d1be6a5654eec8a2eee6c2b0237c025f766c59fafe426aefaa9ff8ee092466d6059e2ff68226ccb0e5e6a37ff410c3e23dd1dc95d2caafb7e2d1285b383a15655ee8d58eeb5cf5f784062df4d14d118a6c0ff0f8961395b12ab225cc440c178b78eb3e7175bb582fc82d16b32c14bf1821f19a09aceb6e45fcc8a2f65ccd2ef0a364d16dca7fb0f41b0537f7f094b32bedad544b3bc3defdb3a7df99ae16d207dbee895c2fb8238a5ff52338583d6045a00418c2e5b6832aa393d99eae1d546f229a09379b2feb902830fe52120db21573865888cba76933c4ab069ca584056465d9eb72d00b675f4e7a2ff1a040d1c733b2409447cdcff0ba973fc66b36b88b4b8189d7beda3c2bfd9c2dcacf2728a44d561976546841d2c3332078b57334700ee3015bd96b61da6093d752303a4ef39e044aeb5fe4eb541e43fbbce5bd46a4121d37152dab550ac237312c5445e3a7520b79470b583f923e76140ef0a5e82c41c178fd403d557baaa71f258c86dfef8c78196495868de080ac971cd070b1922f908805ee667dcaea8932e2eba8186dc80c3ab3f88d86641a4697fc1dbcf459bb17c9435f215e4c007abe1ede5dede91bd95cbd7887aa5a35b17fce621c1e2514fbdb1c72385d86f827a44d32f81dc74b0dda8f2104439d48c0075a448789f6765b437aae9f32636a51e283198092d17021a43e19604b7c1bf6ac1aa2eca479896d904b28c96fe9d6819eec3589db02ccb003e705f9d67a19fe1b628e35e8470d5b57339d09e3ad8abf07128035ed55497b6b2945fc13504d0b3c440fa9db4b599bf61c33e643e6125640cce2c634b3e06986628a3762fdd94fab8ea8970d5a3bb2ce3b1b7c5d236ab446c0d5bc64240beb602769adf7d2d3d384b30614d1d27282da2baebc9b943fc50ded4484b979d3b186a5d2233c00bd840e9e7c79479e96af7daeb6eb699f476b3603d97fdc9763baa10c392464605e046fbc3dd51c5a09413c38ae08daa1d0ff89a94f8638860372e71e6030aae55e70494dcfe2e3c85f92ae8ddd3fed2b2688d4f1ec976219f2cad48c8afb851535db0fc68141750d5271f1bdea4826a1d079b40c5c5dae8212032801db0d2851ef083e024a91c3469ea10d60e125fa132f482553b27a2648d433b0502d3c518ff4078677ffaa5922262948309d2f1be1f68b92022994dc54d543f0d9f0096a212a741a996c0fa18c12ac4f9d74bc092ca0c35f74d7c123652e914ed3e76e41248f421b43b4a8b4b290bb7504f99c43293539f284d0f824f1f0e49cb3f62ecad2698366f92abeeadfb82cb31bf20f22c5ba792e9ba0c92b16790534b8f3792ea25dd5dbe7c60a692d5a87dc5c9f48c6ee10d4f2474baee5419805b8a8f447426bb51f71fae4011066edc292ac6793f76b317d099d98921544f11f926e60c5b9a28b94bb01369d00d443107722f4e57a79f52107097e5c0f7a8f00f46320a898c12b6e06ef203e1b84bdc144f41cb1a6463cb8631239e8d09db8b950e7e9b7a9526f3da176f1e0a722f78afc27437b3f1c736b2e744168ee786315367e133a34a0e643112fbfb37c13476473b72068b79812e7427c07de729b4c4d732942ef97746a5b4520d1b2e80db33cb736015ac7139c81bb63792602ce4b805d42df44d9f85cb1fc28bed8da93d11d61224c68bf0a31e04475934e96c11b1e7e987f796b12acac2f873187335af07bc07bbd0e7a695f4d6bf45b00b6875f0a140059db9a4df10d20b19de4d4c0bf67ce256b05aebb348ba45ac0187276e661d27e19db192e0a8159deebd480dee2d6da84502066a1966007a87f112687689012c91edc81516d4fb1a844ecae7311112fac667034882909cf5f03efa6425486cfee869ce0f63cdd9564f2f1ca192573b47b03094c7b1a7e265ae990274d21d4f8107e62b46c6490ece7e4d94c0d32175c964aef6b69d3c14a781e00fa0173d154f1d8577fc3dc9f336e20215e6734f1098daff9283744f554b445fa4b7d0c12926413acabc667bb26ab3a3a61263dbf1a59c7c3e1f10fcf3f6a498506aa417d202ab7fbb9df47eae15e90251fa22a33bfe68bfaa9a4835e2b7c007b37c4cf1243a8dda3a4e9faa1bd1cadfdf61d2052783f725ef7c9d9a14146b1cffac2b378b17dac94311d520d7e6f3dc1a8d7b718abeb0395b310899ca21a230ab9ab7820d2c0bfe0875d41285808f769c45d7787a09eefb99b4ed46d7100d929f6f2dba4334591bdf50fb7155d2e205987fdc1902073215911f5c9d75ad87df137504fbc2e71a5af163f85d4ccbb6cb354928fb770ec939d1c1b1b31ffc23762ded8ff785583dfc2ec9f5aa7adf95b7ba9e7e31dea54c4dea452c6eb67709bf457421516e2a2420b9ef3bf1c95405eeab2285ddef99e5f085b44dbc634f4ec69b66a37ecc33078f1da0cf277489fa0ee274b6aac40dd8b4ee28d2f9c613d0610d933178e383ce01329a065273a3920232f7dfb893632c522736f7560ee867a3fc35802f8fce4b2c85d9b656e1ca2ac642e3dea15a4a70e0cfc31a2d0beba329427e6db9b822b79a4e60bd2afd6f9c6958eb4377cc49c263b2216bddf498354e0c22a5c199a454bdb83f8655bad2aab0d402c0c1d05208879b4d2a08946b79768b97a2176df587475999e5b1fb3da45b145633598fff612c9ddf15224a51e32d1aef26d2dcca0aea6f00c936787239b956b4b69eaeb05e2828ad0d9c4d07144b5c0bb5697c37d923ac4873ab27b846b3dec46b79c567bbc9be18c9f77cb4f0d8ce1e9286f0e4a4be66d474be40b626dd44b997ac4dcd0447838e8590872b754910e77c56d12e050e3d14cbee38eafc751163a60fa3b4a5e03b93a8722244abfe6ff02869e5d92fffbc920c313fb7ca765e71412a4f26ebf1bc8ad32d3dad1231257e8e9f78c1a136d76fb32cdb217b5f862eca8bdddd8c854bed9f34ccd8cffde5df18d1ba80c44123bae624d7ecd187d9dd14a427a89b812add2ec6ee527c2d62c5c648cf2e5691a648bf49bfb32766576491e144592a356f3221cc749d520b86acda1624d2cfcb30450b2f9d68ea55ce92f894be15999a3e7b1676845ec38613741e3f7e2146095fb0c864dbffa6c715851e9d74b11f1e8373f969858a62fcd61c808309c9ccbb655eba6de3901c1ecdcb3979a597342c659b46325b8d850825326aa7430d2c443a0a965756ed017428cfc853b206e5988297c196fd1cf744e121249fc8ed1d66fc8f97f595bf91c87bda7ffbda08f03b33cee106d8c0db1c5b81d9b13592689bbcb4437cb458c2062f54436c68d6ccdf281b0b61832877a46dc8fa69402d5dc05534e552b47516bae83e9336386258f6cc7156847882754df13f663037cdfa2978550090fd11d4a6f0e5d95e2cc3515b92867357eef785a08e4b10ed44f9dfe6013a201fb1717e1394daedb09533204f7b51a457f74f6b5a972cd0bb80fbe7dbba794e30313a23eabc27b0e114cf0b03877dece1d3e67ee03ac14d880f5dba68344da17edfb8321f96cc32b56124ff54a0b9d1d52129f348c4941089050423cd8328424ca34fe7a796ca77bde63b32a74d597cd11252e5b24c3c389b50e01afb8e1401011c5280a3538f89c95b7152592f1872a8fe7751cd913cc44967212f5b306f4cae4e75f19c39fa988fb8d5563eb565a73e32f5c21f4297cda564b1f97dd05c1cf6c8367c5609ac20a26c8611f2ca7c9082433afb0848273f375eb279bb69add6708ba8279b648199d6dea80a2baf5a579de64d91c0f7cd123e0d91cdc41944eb0d4fa63d831fece0f849f6c9d5390ec19ada6fb0385288805912c8b15a830ec6972b7fbfa8c63f171ab5aa2e1963f6a29f0c19ab85c74a708c170eb453e20edef407c4d0af05f00b04a4a18f3178ccb5840527685b0abfca46fc12501d7cd284b91c96222ffe4769db6a2cbf1171bd1edb57f481f7fd93dc085cf892404d34d94920029fbe3f6a2281659ca968fe831159ad6692c02a71e182cbef5e8cbd65648ad72f65ce842bf8dbacea812a235fd38596a124d559d46a81a3fe5f0aba378e221576d83bc442d6002106d2e68c311174c316a3ed3b523ee41b2dd83f0df1e8c8576024e7ed0dcd8c12bcfb38d884ea951eb241fe8148e50c539b862cf37fb0e69c60593419e23065f2c6bb91337a7fd2d2d40c3c89f12e6529c438e9ac934e5808a04b9677cfb0a058a6d0ba75dd525c7e272ca4f397c60eaae3831b0f5513e7d156519b7e3781041a8c4ef4d78c7650f0be3b8e026a67ee32a0d925c644fd46b2810689a1ff69a6598b3dec69463ed20b86100bc91bdf160981aa6cb4b54f086f96f22ade7da35419e995163abdf5deeb885cb7e6a57c10a032cb82cf013da00042ac9931ac82965a167d1002b686181ed0c213c49ed4c10029235199f08cb450c9f6c4b03de83e2d54805eaaafd248b6610bfe430430d9c3e00d5328d6b41a556b31695d227d1d59554691737b98077b937264690a90e86295787f70bd33cb76e3a432b9fd13407142f02853511cac12cc52ff704e69a5ad7f216b2145f66e2fc0218f3cad8a13308c4ed5dff51c9856affdd30b275a6f621097d82696c3d468a0977b86b68796db5576b65efbf1483233f3feb50b591ea74605bf77aae42f431ee217aaf0ed0acab0e0a816bb36ed8827270c2b11385eda8de9cbee2c237044dac70a1e1c2349a8b70e5a996e161a6f4b59c00bea795fc118d264b894e256b869a46272e2bdcfa563a7b0265658d599c9fb7de8b488db64712763ba76b29b8281447cc3e5c2fdea3e68516d7fb76d508b2e614fbbee5db18b4aef1f7bbcdf7c7451717718671165c891eae4f561470b659ac83f1abb9154ef050e3ec63edf08723cd509d6cad4379146dbb98a2ab33065687124e085b516917c73eb2c6b94a9c6d2f4df5a3a7c5a475ccf0006f56a2d0e750ae054f47669326838d6384d5473ea4e5e1068dfe939c14d52787ab6b5b1b635504ce91bcd0bb09d29966b40f7bf16265edc6d322d21154d4775144a3a0929daf7e44a2e3d52fdc6919256f23bb371180898e5f3f7a5ad49cf28a355fd81f2a8954d539ff6d3ae522b3a42e54bbec486d2dad99c24a40d6348e448cddeb14aebf5407e6f7d82cc0b3cac309e36bc695ffc6a0b93086e49af5e7cb6cd20109429e64a1fa5eb300a9407fc79ee55797cf8d8cf207a9f27c34827292da1aaa916c3b786f065290dcbb8fa294770a0eff196e0a8dd949b14d57c5e66db6c0e9fe0a981a33c2399a345d7aeb1bce8bdedf2b58cba227a4e01f8702aebfef8a96d2ab39dfc95aa4e284d20e4f07b686f53d99971a01e5fceafc37230e05d228b57c10fb10b468d00633a0f345a4089c1a592ead10c9dbc45755ce3cf96b5326cc2d7ba5e9bc5d968f31276218181fb1f2e23efc82810428b5017957365410ebff3572f016a2cc400b62690296d38b0f840111bbf1286d7a828b9a7336d3a249058e53c729aa9b75a9bae7ae387a5a39ec73a635a2800bcc8f94a9a4cda09359f327b3cbe144c24a7ac38df4f4f1d824a4df9cf7e85da47985ed9b8270c12e512ed1b565153b6734bc07952342c526a0a1002b908f58f61c6cfb3a36b961d5f1431dc0d3b70ee3b7b6720bedb033ba9ac46a71e3cbfb6dd161ac9555743d86a19a7db0a0b9915b9769572c723a80a076f302c25f47a139db71607f3153fc027b94d367a7372905ed212604c6ab02e872096dd292dc8732b4aa4d6a26be328394a4a78dbe5271ed157d99fa97922365fedc9301bcf843516e3e40255e685b3ea6718063379062cbaba3f156e3792514814c93171b4beaa5929c62d73bf0f9eb3d370e3e087bc419496b13aeac7baf0106519ab0c9a7b48efa5c6bbf0e70495839dc4b47df4e32c11131300e6530194d3a447d1efe537ad02f01305139287f0af60c881fb7a6677652cebbcd727c13b65e30e718216cc532597a521510c981d0d4b0f44d225dd51e47acd699224f46a94d480b9176ae9fe450d97df6a440e909bfef81a45e228d577ac5d30d7a43afd180f4c16865a5cb0a8034cc0027c32003ef2b93a95a560ba92db4bda6058aa8f7579d42bedab84b60903c82bcac601475c0a5eb41fff4736485054fb2656eb8072479f74626429d8bcb5892066520c34125c4f7918df2529074b2a212e8ce63279951e41f7570a1fa288e16422058e622c599f678da8c7934aa1ed493e6ffef3f122136010ddedd136fd1147cdaa9487fa6ebdfe42062f57fa030e6fb839b290e97b04a11fc4c22bab94ea38917cb40dd4ec5b2a88cf17f296338be116f937c18ed2d1383cab110a9682f9688a1217b90e4214139171443ae3986c34b67c49e6f04b85cba12699a862006bbe2065e9263a4c0d7bc401d47be5b18ec0876b67a2c97a0ca31dbdbf3405ed74718dc46d2885b4fcb175a4220c43b598bb7ffe705c2890ac43293f1e08502bcbddd8106c9dc8957dd90d23d090d9e16a82adc17552adf17889a6aa5a8c51a1832b962e998f53dbfbd36584004244c0854ef4d1f5dd957cdc35873a57eb3bc561102eee337a09a5750300ddd0a2e5099a26e78240e3a1223e0da81cc326b90d0103f5561e198c9fcaf7ffef32168f46faf6950e25a71c6588a60fe4f8ff603e53122535ec4e3ef42205cd49b529f29b4b477d551204dff6a4220d84d1f010fdd8a34dfbb3fffb05457281ad323e8be3eda672262938f865c6eca73881ed1342543158dbdb36d73099fd1ef962f760958404d2cd3898d3a0a2a02d17700812b768de4427e88776050f3dfeba77b7ad134c8a4204f7107290592168f2dce475cceae1e781b2cef00985995fc66595a6e737da06182f9216414ec184e9858dafa517d5b2898fab8281083cc3d59dd5c01b93865a805ffc5ce264b15ba1994c3cb2a2868aa56e5773ad2904d485b30905961b6bea9720bc7a0c30b6e5b657ad9d3636181d69a57f3556c7aed5c82466e3c83072b4bcee1de21b0894c4a5d51d3a652db1107ef9fcbbf2d54fdd9a06a1d3a6accb62e460ebac2eb4ea294634828b965789319ee9538296f283d6150a2920eac7ba0dc2985970f56ff2c8de8e7aa2b21497bb1e04a937a18e62e5e5124f9bdb393ae3cbd1ba5d77d0cb59c3dd2ea757c6ebad8d836f817396d50d6c30913da3ae16ab4fe0ae810b0aeb9e732aa91da25ac5c4ede18d5a249164bedf590b8f2a8f21117045ca8c7da709bf83abf09cf09d218c287f6fdf34ac09239223ba6200ea3677766232bbae71b328caeb3fa8e7cd34ffe28aac3d1cf98b43f1bbc981423163cde82b41683717b6b765c829cbd1e91147a722b6153060f5a83a2023729211db2c5800793f7c8d034524b13d70a89f4c539af92003bb2ef1cecb13170b41d82a1a7f4676dd4650efe1c28ad8e91136e28f00c881d8a1ab650f00e2b0a630b8e619b10c549cfc45f879c37a8f0ac28384475ac1b3e5eb5b0fbe236d7f9713c0df5cd5dd5e7e9ed4aa54951cab4de98a07b6dfe892baec7985a2f93f22d83ff2300b148508a32f34a3f324f65219ad4278c1999b989adeeec2e8f0ec9184cc3dd4b9de3b7d61533a65ec86a133b88aaadf2e9e72b3327827a3aa930f183ccbc795d479bfbf4031eb8ee486dd013dd63e2b142dd04f6f5a9c438fff853ed2a3146eadb7f67396edb7c915a9bc40433d188a57ea08c97cc09185cc0f7ff77612c555474cdb70059e0663df851f5d981b5e98f355fd9fc0d5cfebf0fe448bb0c7287026c6762e4e448d52dcece62027bdbe3b26db9b9482c9da4caf3dad0f561334d93d4b21b3ddeb6e6efda65e66f47594cc9cef081ad1cb07cc167d04829ba845a4e7a97bd62a06cc70cbab57bbe4c33ae85f2c4a20f7c31e70c63e25c1ba07caf6199895fed4b67b70ef348fc87500b8586297023c701d982877feed3ef0aeb9ef5365999094a76ea92e9767b255277d67c48f27f8db8d2692ae7397a192405b81e32142ed33c151c3e247c6e93d8c6e0a0c4bc1028ca3ef2590c331f954ac6ba09d96f1a367647845f6a3a366a7210ba63d4a0bc6e5d55008997f4859418954a744c93b006885ec8308ac084bcaebd0ae098c88500c333e201630ee446fe96594146fd67ca6aac2fcd67abdfaf0b759d5a73fac3e2294edd2788a3c6eb18dfad420531d9055aaf2b43c8a2f1f753fff62f71b41ecabced63c5bca78ce89e26191598164dabb4accfe776e6c8005ddeb340d6f2a9fff15a18a154976b27b45826aa13cdd75a643df1fbec29af2d10c871918996a30a65b980820e2b9483f237433dad6a9893bd63ef759459dcc0e510f8c8a44aeda808158c587a844d8f2b7ac3255a833de62db778dd66a9f310460b989f4d66a577963e7094d67940a49948fd5e9fc9060a651a64e139249b2d605067705de0c87352130150d7e4efa6710187f0549c4e9e06418c890e15843187f4f2e4dff2f2195eb24ee7609ceb6f687fd76a5c0c008706e4b3cea629544d35e83d1749740efd7462556580f086f98353f77225c654aeeaa25c52b28d878e09dbd6aa5995b561e6fcbfebc644d8756ec83df5ca60ce3c67b696987ad68f2565bdb454ade070c22e93277a85f60c43cd7fc29f12e1c9327701141df0686f60a571bdbe0510d6893fb8f38bb32e28744c5ad28d51c1a2e3b0efb90284a21f02a7a3c43ea430def770fe1445d12b427b2509f8c217dc92b7c385189ea47189c2427459bbdb9460277eb3dadd4d03304d77427acdb7c5366fe35a5e760934d9f07272841fdf8d8a6c2e44b4df28078912df305fd86ca34ff291e67a9049f85b31aaf8d4c9a8c7772aa05e7ee9813021538e37364f33c44c95563f2269e724303ccc6257e627b0dccc5bb5c42621fcd422091dcdd199a09befb98f6937de122180d5d19004842d745a83e3d3be1b5b06a473a781d3812e55b7f328bb3ee006feecaaa1418aeccd0cf6fb51e01a9d25f9d6434e27853b6b4bd72050d17a70359fcbcf01b2f757a7885f786b669cd13606681cd3c65ac445029135120102d825bf750cb4e60c37fa75acf5b5948b012332400b6edeef6a2ea9b1b28217c81754b58f72105e9ba0d189076ca7a0d7d275ba518d6e92fe0db5c8193dbb2cb96902f2700ce75ab7fc29c15974639be9b887291e4fe9fd68d5e0e72f97fc517c754ef5de2ad38f492fdc1f458f5a9117594d13000aaf567386a20fa58355edf0bf529dd3847a2c1882d2225187c151fd72175e5decf35130ad1314b2d352b5dff6d8442b75bfcb8ee5e360664caac052e7f786</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#7 Applications</title>
      <link href="/2020/06/02/MIT%20Linear%20Algebra#7%20Applications/"/>
      <url>/2020/06/02/MIT%20Linear%20Algebra#7%20Applications/</url>
      
        <content type="html"><![CDATA[<h2 id="图和网络">图和网络</h2><p>图是一些工程问题的抽象，比如电路网络：<br /><img src="https://img-blog.csdnimg.cn/20200525210820863.png" alt="在这里插入图片描述" /><br />我们可以用<span class="math inline">\(A_{54}\)</span>表示图中的信息，每行代表一条边，每列代表一个结点，1表示电流流入，-1表示流出： <span class="math display">\[A=\begin{bmatrix}   -1 &amp; 1 &amp; 0 &amp; 0 \\   0 &amp; -1 &amp; 1 &amp; 0 \\   -1 &amp; 0 &amp; 1 &amp; 0 \\   -1 &amp; 0 &amp; 0 &amp; 1 \\   0 &amp; 0 &amp; -1 &amp; 1 \\  \end{bmatrix}\]</span> <span class="math inline">\(edge3=edge1+edge2\)</span>，前三行线性相关，在图中表现为形成环路。<br />我们比较关注<span class="math inline">\(A\)</span>的零空间，也即如何组合各列以得到零列<span class="math inline">\(Ax=0\)</span>，即： <span class="math display">\[Ax=\begin{bmatrix}   x_2-x_1\\   x_3-x_2\\   x_3-x_1\\   x_4-x_1\\   x_4-x_3\\  \end{bmatrix}=\begin{bmatrix}   0\\ 0\\  0\\  0\\   0\\  \end{bmatrix}\]</span> 根据前面的学习，<span class="math inline">\(dim(N(A))=n-r(A)=4-3=1\)</span>，并且可以求出零空间：<span class="math inline">\(x=c\begin{bmatrix}  1\\  1\\  1\\  1\\  \end{bmatrix}\)</span>，如果<span class="math inline">\(x_i\)</span>表示<strong>结点<span class="math inline">\(i\)</span>的电势</strong>，那么从结果可以看出来四个点等电势，一旦确定某个点的电势(接地为0)，即可确定其余各点。</p><p>再研究一下<span class="math inline">\(A\)</span>的左零空间，即<span class="math inline">\(A^Ty=0\)</span>，<span class="math inline">\(dim(N(A^T))=m-r(A)=5-3=2\)</span>，不妨看看转置后的鬼样子： <span class="math display">\[\begin{bmatrix}   -1 &amp; 0 &amp; -1 &amp; -1 &amp; 0 \\  1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 1 &amp; 1 &amp; 0 &amp; -1 \\  0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\  \end{bmatrix}\begin{bmatrix}   y_1\\   y_2\\  y_3\\ y_4\\ y_5\\  \end{bmatrix}=\begin{bmatrix}   0 \\ 0 \\ 0 \\  0 \\  \end{bmatrix}\]</span> 变为简化行阶梯<span class="math inline">\(R\)</span>就会发现：pivot col是第一列、第二列和第四列，对应到图中的三条边，可以看到是没有环路的，实际上是一棵<strong>最小生成树</strong>。如果用<span class="math inline">\(y_i\)</span>表示<strong>边<span class="math inline">\(i\)</span>的电流值</strong>，不妨写出这个方程组： <span class="math display">\[\begin{cases}-y_1-y_3-y_4=0&amp; \text{结点1流出之和为0}\\y_1-y_2=0&amp; \text{结点2流入流出相等}\\y_2+y_3-y_5=0&amp; \text{...}\\y_4+y_5=0&amp; \text{...}\end{cases}\]</span> 类似地，可以求出这个左零空间的一组基： <span class="math display">\[\begin{bmatrix}   1\\ 1\\  -1\\  0\\   0\\  \end{bmatrix}、\begin{bmatrix}   0\\ 0\\  1\\  -1\\   1\\  \end{bmatrix}\]</span> 这组基对应到图中也是很明确的：第一个向量对应回路1(边1/2/3)的电流，第二个向量对应回路2(边3/4/5)的电流，当然也可以选择大的回路作为基的一个组成。<br />由此也可以看出：<span class="math inline">\(dim(N(A^T))=m-r=\#loops=\#edges-(\#nodes-1)\)</span>，这也就是著名的欧拉公式：<span class="math inline">\(\#nodes-\#edges+\#loops=1\)</span>。</p><p>回顾整个过程：</p><ul><li>通过电势求得电势差：<span class="math inline">\(Ax=e\)</span>；</li><li>通过欧姆定律<span class="math inline">\(y=Ce\)</span>可以求得结点间的电流值<span class="math inline">\(y_i\)</span>；</li><li>通过<span class="math inline">\(A^Ty=0\)</span>验证了Kirchhoff's current law。</li></ul><p>如果有外接电流源，那么整个过程可以描述为<span class="math inline">\(A^TCAx=f\)</span>。</p><h2 id="马尔可夫矩阵">马尔可夫矩阵</h2><p>马尔可夫模型最初是研究人口迁徙的模型，马尔可夫矩阵有2个特点： - <span class="math inline">\(a_{ij}&gt;0\)</span> - 每一列和为1</p><p>我们要研究随着时间变化，人口最终的分布情况，即稳态。 根据一阶差分<span class="math inline">\(u_k=A^ku_0=c_1\lambda_1^kx_1+c_2\lambda_2^kx_2+...\)</span>，<strong>马尔可夫矩阵有一个特征值为1</strong>，其余的绝对值都小于1，那么最终的稳态就是<span class="math inline">\(c_1x_1\)</span>。<br />举例来看： <span class="math display">\[\begin{bmatrix}   u_{cal}\\   u_{mass}\\  \end{bmatrix}_{t=k+1}=\begin{bmatrix}   0.9 &amp; 0.2\\  0.1 &amp; 0.8\\  \end{bmatrix}\begin{bmatrix}   u_{cal}\\   u_{mass}\\  \end{bmatrix}_{t=k},u_0=\begin{bmatrix}   0\\   1000\\  \end{bmatrix}\]</span> 矩阵表示加州的人有0.9留在加州，0.1迁徙到麻省。求得<span class="math inline">\(A\)</span>的特征值和特征向量，再用<span class="math inline">\(u_0\)</span>求得系数<span class="math inline">\(c\)</span>，就可以得到<span class="math inline">\(u_k\)</span>。</p><h2 id="傅里叶级数">傅里叶级数</h2><p>我们知道，向量空间内任意向量都可以表示为一组标准正交基的线性组合： <span class="math display">\[v=x_1q_1+x_2q_2+...+x_nq_n=Qx,x=Q^{-1}v=Q^Tv\]</span> 那么对于任意的函数<span class="math inline">\(f(x)\)</span>，也可以表示为一组正交基的线性组合： <span class="math display">\[f(x)=a_0*1+a_1cosx+b_1sinx+a_2cos(2x)+b_2sin(2x)+...\]</span> 这组基<span class="math inline">\(1,cosx,sinx,cos(2x),sin(2x),...\)</span>是正交的，即： <span class="math display">\[f^Tg=\int_0^{2\pi} f(x)g(x) dx=0\]</span> 要求得级数得系数，比如<span class="math inline">\(a_1\)</span>，只要等式两边同乘<span class="math inline">\(cosx\)</span>并积分即可： <span class="math display">\[\int_0^{2\pi} f(x)cosx dx=\int_0^{2\pi} a_1cos^2(x) dx\]</span></p><h2 id="复矩阵">复矩阵</h2><p>复向量<span class="math inline">\(Z=\begin{bmatrix}  z_1\\  ...\\  z_n\\  \end{bmatrix}\)</span>的模<span class="math inline">\(||Z||^2=\bar Z^TZ=||z_1||^2+...+||z_n||^2\)</span>，内积也变为共轭转置<span class="math inline">\(\bar y^Tx\)</span>。<br />复数意义下的对称是<span class="math inline">\(\bar A^T=A\)</span>，也叫Hermitian矩阵；<br />复数意义下的正交是<span class="math inline">\(\bar q_i^Tq_j=\begin{cases} 0,i\neq j\\ 1,i=j\\ \end{cases}\)</span>，这样组成的正交阵<span class="math inline">\(\bar Q^TQ=I\)</span>，<span class="math inline">\(Q\)</span>也叫unitary矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#6 Linear Transformations</title>
      <link href="/2020/06/01/MIT%20Linear%20Algebra#6%20Linear%20Transformations/"/>
      <url>/2020/06/01/MIT%20Linear%20Algebra#6%20Linear%20Transformations/</url>
      
        <content type="html"><![CDATA[<h2 id="线性变换">线性变换</h2><p>顾名思义，所谓线性变换即某种变换满足线性性质： <span class="math display">\[\begin{cases}T(v+w)=T(v)+T(w)&amp; \text{}\\T(cv)=cT(v)&amp; \text{}\\\end{cases}\]</span> 投影变换、旋转变换满足线性，这种映射可以通过左乘矩阵完成。<br />如果要知道对整个空间的线性变换，只需要知道对基的变换结果即可，因为任意向量都可表示为基的线性组合：<span class="math inline">\(v=c_1v_1+c_2v_2+...+c_nv_n\)</span>，<span class="math inline">\((c_1,c_2,...,c_n)\)</span>是该向量在这组基下的<strong>坐标</strong>，那么<span class="math inline">\(T(v)=c_1T(v_1)+...+c_nT(v_n)\)</span>。</p><p>线性变换可以用矩阵表示，不同基下对应的矩阵是不同的，如果要求该矩阵：<br />假设输入基是<span class="math inline">\(v_1,...v_n\)</span>，输出空间的基是<span class="math inline">\(w_1,...w_m\)</span>，<strong><span class="math inline">\(A\)</span>的第一列就是<span class="math inline">\(T(v_1)\)</span>在<span class="math inline">\(w\)</span>下的坐标</strong>，因为输入<span class="math inline">\(v_1\)</span>，其在<span class="math inline">\(v\)</span>下的坐标就是<span class="math inline">\(\begin{bmatrix}  1\\  0\\  ...\\  0  \end{bmatrix}\)</span>，<span class="math inline">\(A\)</span>乘以该坐标就是取<span class="math inline">\(A\)</span>的第一列，同理可得其他列。<br />容易验证<span class="math inline">\(T=\frac{d}{dx}\)</span>也是线性变换，输入基如果选择<span class="math inline">\(1,x,x^2\)</span>，输入是<span class="math inline">\(c_1+c_2x+c_3x^2\)</span>，那么输出是<span class="math inline">\(c_2+2c_3x\)</span>，输出基是<span class="math inline">\(1,x\)</span>，那么用矩阵表示就是： <span class="math display">\[A\begin{bmatrix}   c_1\\   c_2\\   c_3\\  \end{bmatrix}=\begin{bmatrix}   c_2\\   2c_3\\  \end{bmatrix}\]</span> 当然可以用上面的方法求矩阵，这里比较简单<span class="math inline">\(A=\begin{bmatrix}  0 &amp; 1 &amp; 0\\  0 &amp; 0 &amp; 2\\  \end{bmatrix}\)</span>。</p><h2 id="基变换">基变换</h2><p>选择合适的基，可以对图像进行压缩：<br />对于原始信号<span class="math inline">\(x\)</span>，可以通过基变换得到另一组基下的坐标<span class="math inline">\(c\)</span>，这一步是无损的，这些系数里可能含有大量的0，通过去掉这些项可以压缩大小，这一步是有损的，即<span class="math inline">\(\hat x=\Sigma \hat c_iv_i\)</span>。<br />目前比较好的有Fourier基和小波基，都是将原始图片分割为若干小块处理。<br />8<em>8Fourier基： <span class="math display">\[\begin{bmatrix}   1 &amp; 1 &amp;... &amp; 1 \\   1 &amp; w&amp;... &amp; w^{n-1} \\   ... &amp; ... &amp; ...\\    1 &amp; w^{n-1}&amp;... &amp; w^{(n-1)^2} \\  \end{bmatrix}\]</span> 8</em>8小波基： <span class="math display">\[W=\begin{bmatrix}   1 &amp; 1 &amp;1 &amp; 0 &amp; 1&amp;0&amp;0&amp;0\\   1 &amp; 1 &amp;1 &amp; 0  &amp; -1&amp;0&amp;0&amp;0\\   1 &amp; 1 &amp;-1 &amp; 0 &amp;0&amp;1&amp;0&amp;0\\  1 &amp; 1 &amp;-1 &amp; 0 &amp;0&amp;-1&amp;0&amp;0\\  1 &amp; -1 &amp;0&amp; 1 &amp;0&amp;0&amp;1&amp;0\\  1 &amp; -1 &amp;0 &amp; 1 &amp;0&amp;0&amp;-1&amp;0\\  1 &amp; -1 &amp;0 &amp; 1 &amp;0&amp;0&amp;0&amp;1\\  1 &amp; -1 &amp;0 &amp; 1 &amp;0&amp;0&amp;0&amp;-1\\  \end{bmatrix}\]</span> 标准基下的像素值在基变换后： <span class="math display">\[p=\begin{bmatrix}   p_1\\   ...\\   p_8\\  \end{bmatrix}=W\begin{bmatrix}   c_1\\   ...\\   c_8\\  \end{bmatrix}=Wc\]</span> 所以在新的基下的坐标是<span class="math inline">\(c=W^{-1}p\)</span>。<br />就性能而言：我们需要<span class="math inline">\(W^{-1}\)</span>可以快速求得，这一点<span class="math inline">\(W^{-1}=W^T\)</span>；另外还要求只需要少量基向量就可以逼近原始信号。</p><h2 id="左右逆伪逆">左右逆/伪逆</h2><p>对于满秩的情况<span class="math inline">\(r=m=n\)</span>，左逆和右逆都存在，即<span class="math inline">\(AA^{-1}=I=A^{-1}A\)</span>；<br />对于列满秩<span class="math inline">\(r=n&lt;m\)</span>，比如<span class="math inline">\(\begin{bmatrix}  1 &amp; 2\\  1 &amp; 3\\  2 &amp; 4\\  \end{bmatrix}\)</span>，<span class="math inline">\(A_{left}^{-1}=(A^TA)^{-1}A^T\)</span>；<br />对于行满秩<span class="math inline">\(r=m&lt;n\)</span>，<span class="math inline">\(A_{right}^{-1}=A^T(AA^T)^{-1}\)</span>；<br />对于不满秩的情况<span class="math inline">\(r&lt;m,r&lt;n\)</span>，这样<strong>不论<span class="math inline">\(A^TA\)</span>还是<span class="math inline">\(AA^T\)</span>都是奇异的</strong>，所以不可能有左逆或者右逆。这种情况在统计学上多次出现，就提出了伪逆的概念，记作<span class="math inline">\(A^+\)</span>。<br />找伪逆可以通过SVD，<span class="math inline">\(A=U\Sigma V^T\)</span>，这里我们的特征值是不完整的，即<span class="math inline">\(\Sigma_{mn}=\begin{bmatrix}  \sigma_1 &amp; ... &amp; 0&amp;0 \\  ... &amp; ... &amp; ...&amp;0\\  0 &amp; ... &amp; \sigma_r &amp;0\\  ...\\  0 &amp; ... &amp; 0&amp;0 \\  \end{bmatrix}\)</span>，那么<span class="math inline">\(\Sigma_{nm}^+=\begin{bmatrix}  1/\sigma_1 &amp; ... &amp; 0&amp;0 \\  ... &amp; ... &amp; ...&amp;0\\  0 &amp; ... &amp; 1/\sigma_r &amp;0\\  ...\\  0 &amp; ... &amp; 0&amp;0 \\  \end{bmatrix}\)</span>，这样<span class="math inline">\(A^+=V\Sigma^+U^T\)</span>。</p><h2 id="作业">作业</h2>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#5 Eigenvalues and Eigenvectors</title>
      <link href="/2020/05/31/MIT%20Linear%20Algebra#5%20Eigenvalues%20and%20Eigenvectors/"/>
      <url>/2020/05/31/MIT%20Linear%20Algebra#5%20Eigenvalues%20and%20Eigenvectors/</url>
      
        <content type="html"><![CDATA[<h2 id="特征值特征向量">特征值/特征向量</h2><p>矩阵作用于列向量<span class="math inline">\(x\)</span>得到列向量<span class="math inline">\(Ax\)</span>，矩阵的作用相当于函数，对于大部分列向量<span class="math inline">\(Ax\)</span>，其方向是不同于<span class="math inline">\(x\)</span>的，我们感兴趣的是其中<strong>平行于</strong><span class="math inline">\(x\)</span>的：<span class="math inline">\(Ax=\lambda x,x\neq0\)</span>。即：向量<span class="math inline">\(x\)</span>在矩阵<span class="math inline">\(A\)</span>的作用下，方向不变，只进行比例系数为<span class="math inline">\(\lambda\)</span>的伸缩。<br />特征向量所在直线上的向量都是特征向量，并且包含了所有特征向量，组成了特征空间。如果我们不断左乘矩阵<span class="math inline">\(A\)</span>，得到的列向量会越来越贴合最大特征值对应的特征空间（只对实数而言）。<br />对于二阶投影矩阵<span class="math inline">\(P\)</span>而言：如果<span class="math inline">\(x\)</span>已经在列空间的平面上，那么<span class="math inline">\(Px=x,\lambda=1\)</span>；如果<span class="math inline">\(x\)</span>垂直于列空间的平面，则<span class="math inline">\(Px=0,\lambda=0\)</span>，除此之外， 没有任何<span class="math inline">\(x\)</span>可以在投影后与原<span class="math inline">\(x\)</span>平行。<br />若<span class="math inline">\(A\)</span>是奇异阵，那么<span class="math inline">\(Ax=0\)</span>必有非零解，所以<span class="math inline">\(\lambda=0\)</span>必是一个特征值。<br />特征值还有两条简单的性质： <span class="math display">\[\Sigma_{i=1}^{n}\lambda_i=trace(A),\lambda_1...\lambda_n=det(A)\]</span> 有了理解后，求解<span class="math inline">\(\lambda,x\)</span>也很自然： <span class="math display">\[(A-\lambda I)x=0有非零解，A-\lambda I必奇异\]</span> <span class="math display">\[特征方程det(A-\lambda I)=0\]</span> 解出<span class="math inline">\(\lambda\)</span>，进而求出<span class="math inline">\((A-\lambda I)x=0\)</span>的零空间即可。<br />举个交换阵的例子：<span class="math inline">\(A=\begin{bmatrix}  0 &amp; 1 \\  1 &amp; 0\\  \end{bmatrix}\)</span>，从物理意义上，交换<span class="math inline">\(x_1=\begin{bmatrix}  1\\  1\\  \end{bmatrix}\)</span>的两行仍然与原向量平行，此时<span class="math inline">\(\lambda=1\)</span>；类似地，交换<span class="math inline">\(x_2=\begin{bmatrix}  1\\  -1\\  \end{bmatrix}\)</span>的两行仍然与原向量平行，只是变成了相反向量，此时<span class="math inline">\(\lambda=-1\)</span>。<br />如果再看<span class="math inline">\(A+3I=\begin{bmatrix}  3 &amp; 1 \\  1 &amp; 3\\  \end{bmatrix}\)</span>，特征值变为了<span class="math inline">\(\lambda+3=2,4\)</span>，特征向量没有改变。<br />接着可以看看特征值不为实数的例子：对于<strong>反对称</strong>矩阵<span class="math inline">\(\begin{bmatrix}  0 &amp; -1 \\  1 &amp; 0\\  \end{bmatrix}\)</span>，<span class="math inline">\(\lambda=i,-i\)</span>，从几何上看：该矩阵的作用是将向量旋转90度，旋转之后的向量不可能与之前的平行，所以也就没有实数特征值。</p><h2 id="对角化">对角化</h2><p>这一节的前提是<span class="math inline">\(A\)</span><strong>有<span class="math inline">\(n\)</span>个线性无关的特征向量</strong>，这样后面由<strong>特征向量组成的矩阵</strong><span class="math inline">\(S\)</span>才可逆。<br />对于满足前提的矩阵： <span class="math display">\[AS=A\begin{bmatrix}x_1&amp;...&amp; x_n \\\end{bmatrix}=\begin{bmatrix}\lambda_1x_1&amp;...&amp; \lambda_nx_n \\\end{bmatrix}=\begin{bmatrix}x_1&amp;...&amp; x_n \\\end{bmatrix}\begin{bmatrix}   \lambda_1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \lambda_n \\  \end{bmatrix}=S\Lambda\]</span> 这样<span class="math inline">\(S^{-1}AS=\Lambda\)</span>。<br />如果<span class="math inline">\(A\)</span>的所有特征值互异，必可对角化；如果有重复特征值，那么<strong>不一定</strong>有<span class="math inline">\(n\)</span>个线性无关的特征向量，也不一定可以对角化。</p><p><span class="math inline">\(A\)</span>可以被分解为<span class="math inline">\(A=S\Lambda S^{-1}\)</span>。由此不难得到<span class="math inline">\(A\)</span>的幂：<span class="math inline">\(A^K=S\Lambda^K S^{-1}\)</span>，特征值加倍，但特征向量不变。<br />当<span class="math inline">\(K\rightarrow+\infin\)</span>，如果所有<span class="math inline">\(|\lambda_i|&lt;1\)</span>，那么<span class="math inline">\(A^K\rightarrow0\)</span>。<br /><span class="math inline">\(A\)</span>的幂有一个应用：一阶差分方程<span class="math inline">\(u_{k+1}=Au_k\)</span>，通过递推不难发现<span class="math inline">\(u_k=A^ku_0\)</span>，如果直接用<span class="math inline">\(A^K=S\Lambda^K S^{-1}\)</span>求解，求逆开销是不可忽视的，所以我们换一种方式：<br />我们知道，线性无关的特征向量可以作为基表示其它向量： <span class="math display">\[u_0=c_1x_1+...+c_nx_n=Sc,Au_0=S\Lambda S^{-1}u_0=S\Lambda S^{-1}Sc=S\Lambda c\]</span> <span class="math display">\[A^ku_o=c_1\lambda_1^{k}x_1+...+c_n\lambda_n^{k}x_n=S\Lambda^{k}c\]</span> 很清楚地看到：<span class="math inline">\(u_k\)</span>的增长速度由<span class="math inline">\(\Lambda\)</span>决定，并且越大的特征值起的作用越大。<br />因此求解差分方程需要三步：</p><ol type="1"><li>求解矩阵<span class="math inline">\(A\)</span>的特征值和特征向量；</li><li>将<span class="math inline">\(u_0\)</span>在特征向量上展开，求出向量<span class="math inline">\(c\)</span>；</li><li>按照<span class="math inline">\(u_k=S\Lambda^{k}c\)</span>计算即可。</li></ol><p>这里非常经典的例子就是<a href="https://www.cnblogs.com/EIMadrigal/p/11478906.html">斐波那契数列</a>。</p><h2 id="微分方程">微分方程</h2><p>我们知道：对于常系数线性微分方程<span class="math inline">\(\frac{dy}{dt}=\lambda y\)</span>，其解为<span class="math inline">\(y(t)=Ce^{\lambda t}\)</span>。现在要研究的是未知函数是向量的情况：<span class="math inline">\(\frac{du}{dt}=Au\)</span>，不难验证<span class="math inline">\(u(t)=e^{\lambda t}x\)</span>是特解，并且微分方程组满足线性性质。<br />举例来看： <span class="math display">\[\begin{cases}\frac{du_1}{dt}=-u_1+2u_2&amp; \text{}\\\frac{du_2}{dt}=u_1-2u_2&amp; \text{}\\\end{cases},u(0)=\begin{bmatrix}   1\\   0\\  \end{bmatrix}\]</span> <span class="math inline">\(A=\begin{bmatrix}  -1 &amp; 2 \\  1 &amp; -2\\  \end{bmatrix}\)</span>，求解出<span class="math inline">\(\lambda=0,-3\)</span>，从特征值可以看出：<span class="math inline">\(\lambda=-3\)</span>的项会随着<span class="math inline">\(t\)</span>的增加而消失，<span class="math inline">\(\lambda=0\)</span>的项最终会是稳态。 特征向量<span class="math inline">\(x_1=\begin{bmatrix}  2\\  1\\  \end{bmatrix},x_2=\begin{bmatrix}  1\\  -1\\  \end{bmatrix}\)</span>，这样可以写出通解： <span class="math display">\[u(t)=c_1e^{\lambda_1 t}x_1+c_2e^{\lambda_2 t}x_2=\frac{1}{3}\begin{bmatrix}   2\\   1\\  \end{bmatrix}+\frac{1}{3}e^{-3t}\begin{bmatrix}   1\\   -1\\  \end{bmatrix}\]</span> 当<span class="math inline">\(t\rightarrow+\infin\)</span>，<span class="math inline">\(\frac{1}{3}\begin{bmatrix}  2\\  1\\  \end{bmatrix}\)</span>这一项将是稳态。 因此从特征值的角度，<span class="math inline">\(||e^{(-3+6i)t}||=e^{-3t}\)</span>，<span class="math inline">\(||e^{6it}||=1\)</span>，在单位圆上运动，所以最终的状态取决于特征值的实部：</p><ul><li><span class="math inline">\(Re(\lambda)&lt;0,e^{\lambda t}\rightarrow0,u(t)\rightarrow0\)</span></li><li>某个特征值为0，其余实部小于0，最终收敛于常量</li><li><span class="math inline">\(Re(\lambda)&gt;0\)</span>，无法收敛</li></ul><p>回头去看上述的微分方程，<span class="math inline">\(u_1\)</span>和<span class="math inline">\(u_2\)</span>耦合在一起，下面我们尝试用特征向量<strong>解耦</strong>：<br />令<span class="math inline">\(u=Sv\)</span>，则微分方程变为<span class="math inline">\(S\frac{dv}{dt}=ASv,\frac{dv}{dt}=S^{-1}ASv=\Lambda v\)</span>，那么： <span class="math display">\[\begin{cases}\frac{dv_1}{dt}=\lambda_1v_1&amp; \text{}\\\frac{dv_2}{dt}=\lambda_2v_2&amp; \text{}\\...\end{cases}\]</span> 换种思路，如果直接求解<span class="math inline">\(\frac{dv}{dt}=\Lambda v\)</span>，那么类似于标量的答案<span class="math inline">\(v(t)=v(0)e^{\Lambda t},u(t)=Sv(t)=Se^{\Lambda t}S^{-1}u(0)=e^{At}u(0)\)</span>，这里就得到了一个新的概念：<strong>矩阵指数</strong><span class="math inline">\(e^{At}\)</span>。<br />如果你还记得高数里的泰勒展开： <span class="math display">\[\frac{1}{1-x}=\sum\limits_{n=0}^{\infin}x^n,e^x=\sum\limits_{n=0}^{\infin}\frac{x^n}{n!}\]</span> 那么矩阵指数同样可以展开： <span class="math display">\[(I-At)^{-1}=I+At+(At)^2+...,e^{At}=I+At+\frac{1}{2}(At)^2+...+\frac{(At)^n}{n!}+...\]</span> <span class="math inline">\(e^{At}\)</span>一定是收敛的，因为阶乘的增长速度远远大于其它运算，接着将它写成矩阵形式： <span class="math display">\[e^{At}=I+S\Lambda S^{-1}t+\frac{1}{2}S\Lambda^2S^{-1}t^2+...=Se^{\Lambda t}S^{-1}\]</span> <span class="math inline">\(e^{\Lambda t}\)</span>也是一个矩阵指数，可以写作<span class="math inline">\(\begin{bmatrix}  e^{\lambda_1t} &amp; ... &amp; 0 \\  ... &amp; ... &amp; ...\\  0 &amp; ... &amp; e^{\lambda_nt} \\  \end{bmatrix}\)</span>，这里也可以有相似的收敛性：</p><ul><li>对于矩阵指数<span class="math inline">\(e^{\Lambda t}\)</span>，若<span class="math inline">\(Re(\lambda)&lt;0\)</span>，则收敛；</li><li>对于矩阵幂<span class="math inline">\(A^K=S\Lambda^K S^{-1}\)</span>，若<span class="math inline">\(||\lambda||&lt;1\)</span>，则收敛。</li></ul><p>微分方程也可以像上一节一样，将二阶<span class="math inline">\(y&#39;&#39;+by&#39;+ky=0\)</span>转为一阶，构造： <span class="math display">\[\begin{cases}y&#39;&#39;+by&#39;+ky=0&amp; \text{}\\y&#39;=y&#39;&amp; \text{}\\\end{cases}\]</span> 令<span class="math inline">\(u=\begin{bmatrix}  y&#39;\\  y\\  \end{bmatrix}\)</span>，则<span class="math inline">\(u&#39;=\begin{bmatrix}  y&#39;&#39;\\  y&#39;\\  \end{bmatrix}=\begin{bmatrix}  -b &amp; -k \\  1 &amp; 0\\  \end{bmatrix}\begin{bmatrix}  y&#39;\\  y\\  \end{bmatrix}=Au\)</span>。</p><h2 id="实对称阵正定阵">实对称阵/正定阵</h2><p><strong>实对称矩阵的特征值必为实数，特征向量正交</strong>。证明略。对于复矩阵，只有<span class="math inline">\(A=\bar A^T(共轭转置)\)</span>，性质才成立。<br />上一节我们知道：如果<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个线性无关的特征向量，那么可以被分解成<span class="math inline">\(A=S\Lambda S^{-1}\)</span>。对于正交阵而言<span class="math inline">\(Q^T=Q^{-1}\)</span>，故<span class="math inline">\(A=Q\Lambda Q^{-1}=Q\Lambda Q^{T}\)</span>，如果进一步计算： <span class="math display">\[A=\begin{bmatrix}q_1&amp;...&amp; q_n \\\end{bmatrix}\begin{bmatrix}   \lambda_1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \lambda_n \\  \end{bmatrix}\begin{bmatrix}   q_1^T\\   ...\\   q_n^T\\  \end{bmatrix}=\lambda_1q_1q_1^T+...+\lambda_nq_nq_n^T\]</span> <span class="math inline">\(q_iq_i^T\)</span>是投影矩阵，实对称矩阵可以由投影矩阵线性组合而来，这些投影矩阵我个人感觉非常像矩阵的基，也就是说实对称阵可以完全由其特征值和特征向量确定。</p><p>接着我们来看正定阵，<strong>正定阵的前提是对称阵</strong>，有3个充要条件：</p><ul><li><span class="math inline">\(\lambda_i&gt;0\)</span></li><li><span class="math inline">\(pivot_i&gt;0\)</span></li><li>所有子行列式为正</li></ul><p>实际上，<span class="math inline">\(\#正主元=\#正特征值\)</span>，并且<span class="math inline">\(\Pi pivot=\Pi\lambda_i=det(A)\)</span>。<br />利用正定阵可以研究二次型的最小值：<br /><span class="math display">\[f(x,y)=x^TAx=ax^2+2bxy+cy^2\]</span> 如果<span class="math inline">\(A\)</span>正定，那么<span class="math inline">\(除(0,0)外,f(x,y)&gt;0\)</span>。<br />取<span class="math inline">\(A=\begin{bmatrix}  2 &amp; 6 \\  6 &amp; 20\\  \end{bmatrix}\)</span>，那么<span class="math inline">\(f(x,y)=2x^2+12xy+20y^2\)</span>，配方<span class="math inline">\(f(x,y)=2(x+3y)^2+2y^2&gt;0\)</span>，注意各项的系数：两个平方项前的系数是<span class="math inline">\(A\)</span>的两个<strong>主元</strong>，括号中的3是矩阵消元时所用的<strong>乘数</strong>。如果把<span class="math inline">\(A\)</span>做LU分解会看得更清楚：<span class="math inline">\(A=LU=\begin{bmatrix}  1 &amp; 0 \\  3 &amp; 1\\  \end{bmatrix}\begin{bmatrix}  2 &amp; 6 \\  0 &amp; 2\\  \end{bmatrix}\)</span>。<br />从几何上看，<span class="math inline">\(f(x,y)\)</span>就像是一个<strong>碗</strong>的形状，在<span class="math inline">\((0,0)\)</span>处取极小值0，<span class="math inline">\(f(x,y)=1\)</span>则是椭圆截面。<br />对于三阶的情况：<span class="math inline">\(A=\begin{bmatrix}  2 &amp; -1 &amp; 0 \\  -1 &amp; 2 &amp; -1 \\  0 &amp; -1 &amp; 2 \\  \end{bmatrix}\)</span>，可以求得<span class="math inline">\(\lambda=2-\sqrt2,2,2+\sqrt2\)</span>，那么此时 <span class="math display">\[f=x^TAx&gt;0\]</span> 这在几何上已经上升到四维，必然有3个轴，并且轴的方向由相应的特征向量决定，轴的长度由特征值决定，<span class="math inline">\(f=1\)</span>是一个椭球。</p><p>最后，如果<span class="math inline">\(A_{mn}\)</span>的各列线性无关，那么<span class="math inline">\(A^TA\)</span>必然正定，证明可以从<span class="math inline">\(x^TAx&gt;0\)</span>入手。</p><h2 id="相似阵">相似阵</h2><p>前面我们见过<span class="math inline">\(S^{-1}AS=\Lambda\)</span>，那么<span class="math inline">\(A\sim\Lambda\)</span>。比较正式的说法是：存在可逆阵M，使得<span class="math inline">\(B=M^{-1}AM\)</span>，则称<span class="math inline">\(A\sim B\)</span>。相似阵可以看作一个家族，这个家族的共同点就是<strong>特征值相同</strong>。<br />之前我们知道：如果<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个不同的特征值，那么必可相似对角化。如果有重复的特征值，未必可以对角化：<br />现在考虑<span class="math inline">\(\lambda_1=\lambda_2=4\)</span>的情况，满足条件的矩阵有很多，比如<span class="math inline">\(A=\begin{bmatrix}  4 &amp; 0 \\  0 &amp; 4\\  \end{bmatrix}\)</span>，但如果我们去找<span class="math inline">\(A\)</span>的相似阵，我们尝试用<span class="math inline">\(M^{-1}AM=A\)</span>，无论任何<span class="math inline">\(M\)</span>，最终的结果都是<span class="math inline">\(A\)</span>自己，不会增加任何新的矩阵，矩阵<span class="math inline">\(A\)</span>单独组成了一个家族。<br />如果去看其余满足条件的矩阵，比如<span class="math inline">\(B=\begin{bmatrix}  4 &amp; 1 \\  0 &amp; 4\\  \end{bmatrix},C=\begin{bmatrix}  4 &amp; 0 \\  17 &amp; 4\\  \end{bmatrix}...\)</span>，这些只有1个特征向量的矩阵虽然不能对角化，但是我们可以找一个<strong>最接近对角阵</strong>的，也就是<span class="math inline">\(B\)</span>，称为Jordan Form。<br />对于<span class="math inline">\(\begin{bmatrix}  0 &amp; 1 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 1 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  \end{bmatrix}和\begin{bmatrix}  0 &amp; 1 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  \end{bmatrix}\)</span>，尽管特征值全为0，但并不相似。只有2个线性无关的特征向量，所以就有2个Jordan Block，每个Jordan Block长这样： <span class="math display">\[J_i=\begin{bmatrix}   \lambda_i &amp; 1 &amp;...&amp; 0 \\  0 &amp; \lambda_i  &amp; 1 &amp; ...\\  ...&amp;...&amp;...&amp;...\\  0 &amp; 0 &amp; \lambda_i  &amp; 1 \\   0 &amp; 0 &amp; 0 &amp; \lambda_i  \\  \end{bmatrix}\]</span> 每个块只能有1个特征向量，这样做的意义在于任意的矩阵<span class="math inline">\(A\)</span>，即使不能相似对角化，但是都有<span class="math inline">\(A\sim J=\begin{bmatrix}  J_1 &amp; ... &amp; 0 \\  ... &amp; ... &amp; ...\\  0 &amp; ... &amp; J_d \\  \end{bmatrix}\)</span>。</p><h2 id="svd分解">SVD分解</h2><p>假设我们在行空间有一组标准正交基<span class="math inline">\(v_1,v_2,...,v_r\)</span>，左乘矩阵<span class="math inline">\(A\)</span>进入列空间，将结果表示为列空间中的一组标准正交基<span class="math inline">\(u_1,u_2,...,u_r\)</span>： <span class="math display">\[AV=A\begin{bmatrix}v_1&amp;...&amp; v_r \\\end{bmatrix}=\begin{bmatrix}u_1&amp;...&amp; u_r \\\end{bmatrix}\begin{bmatrix}   \sigma_1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \sigma_r \\  \end{bmatrix}=U\Sigma\]</span> 故<span class="math inline">\(A\)</span>可以分解为<span class="math inline">\(A=U\Sigma V^T\)</span>。 如果<span class="math inline">\(A=\begin{bmatrix}  4 &amp; 4 \\  -3 &amp; 3\\  \end{bmatrix}\)</span>，试着分解下，关键问题就是如何求得等式右边的3个矩阵。<br />先来搞定<span class="math inline">\(V\)</span>，最好能去掉<span class="math inline">\(U\)</span>，我们的技巧是用<span class="math inline">\(A^TA\)</span>： <span class="math display">\[A^TA=V\Sigma^TU^TU\Sigma V^T=V\begin{bmatrix}   \sigma_1^2 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \sigma_r^2 \\  \end{bmatrix}V^T\]</span> 由于<span class="math inline">\(A^TA\)</span>实对称，所以我们得到了<span class="math inline">\(Q\Lambda Q^{T}\)</span>的形式，接下来只要搞定<span class="math inline">\(A^TA\)</span>的特征值和特征向量即可得到<span class="math inline">\(V\)</span>和<span class="math inline">\(\Sigma\)</span>；<br />同样地，为了求<span class="math inline">\(U\)</span>，最好先搞掉<span class="math inline">\(V\)</span>： <span class="math display">\[AA^T=U\Sigma V^TV\Sigma^TU^T=U\begin{bmatrix}   \sigma_1^2 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \sigma_r^2 \\  \end{bmatrix}U^T\]</span> 只要求得<span class="math inline">\(AA^T\)</span>的特征值和特征向量即可得<span class="math inline">\(U\)</span>。</p><h2 id="作业">作业</h2><p>Suppose we have the rank-r svd of a rank 1 matrix <span class="math inline">\(A = U\Sigma V^T\)</span>. Describe the nullspace of <span class="math inline">\(A\)</span> in terms of possibly <span class="math inline">\(U\)</span>, <span class="math inline">\(Σ\)</span>, and <span class="math inline">\(V\)</span>.<br />Answer: The nullspace of <span class="math inline">\(A\)</span> is the same as the nullspace of <span class="math inline">\(V^T\)</span>. Since <span class="math inline">\(A\)</span> is rank 1, <span class="math inline">\(V\)</span> is a vector. So the nullspace of <span class="math inline">\(V^T\)</span> is a hyperplane given by <span class="math inline">\(V^Tx=0\)</span>, i.e., the space of all the vectors that are perpendicular to <span class="math inline">\(V\)</span>.</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#4 Determinants</title>
      <link href="/2020/05/29/MIT%20Linear%20Algebra#4%20Determinants/"/>
      <url>/2020/05/29/MIT%20Linear%20Algebra#4%20Determinants/</url>
      
        <content type="html"><![CDATA[<p>行列式本质上是要通过一个数字反应矩阵的某些信息，目前看来不是很重要，快速过一遍。 ## 性质 引入是通过3个基本性质：</p><ol type="1"><li><span class="math inline">\(det(I)=1\)</span></li><li>交换两行，行列式的值变号：置换矩阵<span class="math inline">\(det(P)=\begin{cases} 1&amp; \text{交换偶数次}\\ -1&amp; \text{交换奇数次}\\ \end{cases}\)</span></li><li><span class="math inline">\(\left|\begin{array}{cccc} ta &amp; tb\\ c &amp; d\\ \end{array}\right|=t\left|\begin{array}{cccc} a &amp; b\\ c &amp; d\\ \end{array}\right|,\left|\begin{array}{cccc} a+a&#39; &amp; b+b&#39;\\ c &amp; d\\ \end{array}\right|=\left|\begin{array}{cccc} a &amp; b\\ c &amp; d\\ \end{array}\right|+\left|\begin{array}{cccc} a&#39; &amp; b&#39;\\ c &amp; d\\ \end{array}\right|\)</span></li></ol><p>由3个基本性质可以推出若干：</p><ol type="1"><li>若两行相等，则<span class="math inline">\(det(A)=0\)</span><br />交换相等的2行，矩阵不变，行列式的值不变，根据性质2：<span class="math inline">\(det(A)=-det(A)\)</span>，得证。</li><li>初等行变换不改变行列式的值 <span class="math display">\[\left|\begin{array}{cccc}a &amp; b\\ c-la &amp; d-lb\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; b\\ c &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}a &amp; b\\ -la &amp; -lb\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; b\\ c &amp; d\\\end{array}\right|\]</span></li><li>有一行全为0，行列式为0</li><li><strong>上三角矩阵的行列式等于主对角线元素之积</strong>：<span class="math inline">\(det(U)=d_1d_2...d_n\)</span><br />对于任意矩阵，通过初等行变换可以得到<span class="math inline">\(U\)</span>，接着向上消元并提出对角线的因子，可以得到<span class="math inline">\(I\)</span>。<br />这也是Matlab求行列式的方法。</li><li><span class="math inline">\(det(A)=0\Leftrightarrow A是奇异矩阵(消元后有全0行)\)</span><br /><span class="math inline">\(det(A)\neq0\Leftrightarrow A可逆\Rightarrow U\Rightarrow d_1d_2...d_n\neq0\)</span></li><li><span class="math inline">\(det(AB)=det(A)*det(B) \Rightarrow det(A^{-1})=\frac{1}{det(A)}\)</span></li><li><span class="math inline">\(det(A^T)=det(A)\)</span>，可以通过LU分解去证，这也意味着对行成立的性质对列也成立。</li></ol><h2 id="计算方法">计算方法</h2><p>上一节中介绍了消元化上三角求行列式的方法，本节介绍2种不常用的方法，所有计算都可以通过上一节的3个基本性质获得：<br />对于二阶，拆解后有2个非零项： <span class="math display">\[\left|\begin{array}{cccc}a &amp; b\\ c &amp; d\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; 0\\ c &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}0 &amp; b\\ c &amp; d\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; 0\\ c &amp; 0\\\end{array}\right|+\left|\begin{array}{cccc}a &amp; 0\\ 0 &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}0 &amp; b\\ 0 &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}0 &amp; b\\ c &amp; 0\\\end{array}\right|=ad-bc\]</span> 对于三阶，拆解后有6个非零项： <span class="math display">\[\left|\begin{array}{cccc} a_{11} &amp; a_{12} &amp; a_{13}\\ a_{21} &amp; a_{22} &amp; a_{23}\\ a_{31} &amp; a_{32} &amp; a_{33}\\ \end{array}\right|=\left|\begin{array}{cccc} a_{11} &amp;  &amp; \\  &amp; a_{22} &amp; \\  &amp;  &amp; a_{33}\\ \end{array}\right|+\left|\begin{array}{cccc} a_{11} &amp;  &amp; \\  &amp;  &amp; a_{23}\\  &amp;  a_{32}&amp; \\ \end{array}\right|+\left|\begin{array}{cccc}  &amp;a_{12}  &amp; \\  a_{21}&amp;  &amp; \\  &amp;  &amp;a_{33}\\ \end{array}\right|+\left|\begin{array}{cccc}  &amp;a_{12}  &amp; \\  &amp;  &amp;a_{23} \\  a_{31}&amp;  &amp;\\ \end{array}\right|+\left|\begin{array}{cccc}  &amp;  &amp;a_{13} \\  a_{21}&amp;  &amp; \\  &amp;a_{32}  &amp;\\ \end{array}\right|+\left|\begin{array}{cccc}  &amp;  &amp;a_{13} \\  &amp;a_{22}  &amp; \\  a_{31}&amp;  &amp;\\ \end{array}\right|\]</span> 接着可以通过交换行得到对角阵并求得结果。<br />如果我们观察每一项：从第一行到最后一行，<strong>列下标</strong>是<span class="math inline">\((1,2,3)\)</span>的某个全排列，因此可以知道展开以后非零项一共有<span class="math inline">\(n!\)</span>项(第一行有<span class="math inline">\(n\)</span>种选择，第二行有<span class="math inline">\(n-1\)</span>种选择...)，于是可以得到第二种计算行列式的方法： <span class="math display">\[det(A)=\Sigma_{n!项}\pm a_{1x}a_{1y}...a_{1w},(x,y,...w)是(1,n)的某个全排列\]</span> 正负号取决于交换了几次得到<span class="math inline">\((1,2,3...)\)</span>这种朴素的排列。<br />举例来看： <span class="math display">\[\left|\begin{array}{cccc} 0 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0\\ 1 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 1\\ \end{array}\right|\]</span> 可以先取<span class="math inline">\((1,3)\)</span>位置，接着只能取<span class="math inline">\((2,2)\)</span>，接着<span class="math inline">\((3,1)\)</span>，最后<span class="math inline">\((4,4)\)</span>，所以列的排列是<span class="math inline">\((3,2,1,4)\)</span>，交换一次可得<span class="math inline">\((1,2,3,4)\)</span>，故有一非零项-1；<br />还可以先取<span class="math inline">\((1,4)\)</span>，接着<span class="math inline">\((2,3)\)</span>，<span class="math inline">\((3,2)\)</span>，最后<span class="math inline">\((4,1)\)</span>，列的排列是<span class="math inline">\((4,3,2,1)\)</span>，交换2次可得<span class="math inline">\((1,2,3,4)\)</span>，故有一非零项1，除此以外，没有别的选择，所以行列式的值是0。</p><p>如果我们对上述拆解三阶行列式的结果提取公因子： <span class="math display">\[det(A)=a_{11}(a_{22}a_{33}-a_{23}a_{32})+a_{12}(-a_{21}a_{33}+a_{23}a_{31})+a_{13}(a_{21}a_{32}-a_{22}a_{31})\]</span> 我们穷举了第一行的3种可能的选择<span class="math inline">\(a_{11},a_{12},a_{13}\)</span>，对于每种选择，当前行与当前列都不能再用，括号中的式子叫做<strong>代数余子式</strong><span class="math inline">\(C_{ij}\)</span>：去掉<span class="math inline">\(a_{ij}\)</span>所在行列的<span class="math inline">\(n-1\)</span>阶行列式，并且正负号取决于<span class="math inline">\(i+j\)</span>的奇(-)偶(+)。<br />这样我们得到了求行列式的第三种方法： <span class="math display">\[det(A)=a_{11}C_{11}+a_{12}C_{12}+...+a_{1n}C_{1n}\]</span> 举例来看，对于三对角行列式： <span class="math display">\[\left|\begin{array}{cccc} 1 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 1\\ \end{array}\right|\]</span> 容易知：<span class="math inline">\(det(A_1)=1,det(A_2)=\left|\begin{array}{cccc} 1 &amp; 1\\ 1 &amp; 1\\ \end{array}\right|=0,det(A_3)=\left|\begin{array}{cccc} 1 &amp; 1 &amp; 0\\ 1 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1\\ \end{array}\right|=-1\)</span>。<br />对于四阶，我们<strong>按第一列展开</strong>：<span class="math inline">\(det(A_4)=1*det(A_3)-1*det(A_2)=-1\)</span>，此式可以推广：<span class="math inline">\(det(A_n)=det(A_{n-1})-det(A_{n-2})\)</span>，可以发现上述三对角行列式是以6为周期的。</p><h2 id="应用">应用</h2><ul><li>求逆矩阵<br />记得当年矩阵求逆教了一种伴随矩阵的方法：<span class="math inline">\(A^{-1}=\frac{1}{det(A)}C^T\)</span>，不知为何物？<br />只要证明<span class="math inline">\(AC^T=det(A)I\)</span>即可： <span class="math display">\[\left[\begin{array}{cccc} a_{11} &amp; ... &amp; a_{1n}\\ ... &amp;  &amp; ...\\ a_{n1} &amp; ... &amp; a_{nn}\\ \end{array}\right]\left[\begin{array}{cccc} C_{11} &amp; ... &amp; C_{n1}\\ ... &amp;  &amp; ...\\ C_{1n} &amp; ... &amp; C_{nn}\\ \end{array}\right]=\left[\begin{array}{cccc} det(A) &amp; ... &amp;0\\ ... &amp;  &amp; ...\\ 0 &amp; ... &amp; det(A)\\ \end{array}\right]\]</span> 对于主对角线上的元素：<span class="math inline">\(a_{11}C_{11}+...+a_{1n}C_{1n}=det(A)\)</span>；<br />对于其它元素：<span class="math inline">\(a_{11}C_{n1}+...+a_{1n}C_{nn}=\left|\begin{array}{cccc} a_{11} &amp; ... &amp; a_{1n}\\ ... &amp; &amp; ...\\ a_{11} &amp; ... &amp; a_{1n}\\ \end{array}\right|=0\)</span>。</li><li>求解<span class="math inline">\(Ax=b\)</span><br />求解：<span class="math inline">\(x=A^{-1}b=\frac{1}{det(A)}C^Tb\)</span>，那么考虑<span class="math inline">\(x_1=\frac{1}{det(A)}(b_1c_{11}+..+b_nc_{n1})\)</span>，<span class="math inline">\(b_1c_{11}+..+b_nc_{n1}\)</span>其实是将矩阵<span class="math inline">\(A\)</span>的第一列换为<span class="math inline">\(b\)</span>，按照第一列展开求行列式的值即可，同理可以求得其它<span class="math inline">\(x_i\)</span>，这种差到没人用的方法竟然被国内教材奉为圭臬。</li><li>求体积<br /><span class="math inline">\(det(A)\)</span>的绝对值可以定义为一个平行六面体的体积，正负表示左手系还是右手系。<br />将三阶矩阵<span class="math inline">\(A\)</span>的每行(列)当作平行六面体的一条边，如果<span class="math inline">\(A=I\)</span>，我们得到一个标准的单位立方体；如果<span class="math inline">\(A=Q\)</span>，我们得到一个旋转过的单位立方体，体积仍然为1，可以通过<span class="math inline">\(Q^TQ=I\)</span>验证。<br />如果是二维情况，那么<span class="math inline">\(det(A)\)</span>的绝对值就是平行四边形的面积： <span class="math display">\[S=\left|\begin{array}{cccc}a &amp; b\\ c &amp; d\\\end{array}\right|=ad-bc\]</span> 那么三角形的面积就是<span class="math inline">\(\frac{1}{2}S\)</span>，推广到向量的起始位置不在<span class="math inline">\((0,0)\)</span>的情况： <span class="math display">\[S_{三角形}=\frac{1}{2}\left|\begin{array}{cccc}x_1 &amp; y_1 &amp; 1\\ x_2 &amp; y_2 &amp; 1\\ x_3 &amp; y_3 &amp; 1\\ \end{array}\right|\]</span> 可以通过平移到原点去证明。</li></ul><h2 id="作业">作业</h2><p>A Hadamard matrix H is a matrix with entries ±1 and orthogonal columns. What is the determinant of H as a function of n? (Hadamard matrices are conjectured to exist for every n that is a multiple of 4, but nobody knows if there is such a matrix even for n=668).<br />由于<span class="math inline">\(H\)</span>各列正交，故<span class="math inline">\(H^TH=cI\)</span>；又<span class="math inline">\(H\)</span>的元素只有±1，故<span class="math inline">\(c=n\)</span>。所以<span class="math inline">\(det(H)^2=n^n,det(H) = \pm\sqrt{n^n}\)</span>，即<span class="math inline">\(n\)</span>阶Hadamard矩阵的行列式既可以为正，也可以为负。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#3 Orthogonality</title>
      <link href="/2020/05/27/MIT%20Linear%20Algebra#3%20Orthogonality/"/>
      <url>/2020/05/27/MIT%20Linear%20Algebra#3%20Orthogonality/</url>
      
        <content type="html"><![CDATA[<h2 id="正交向量">正交向量</h2><p>初中时候我们学过勾股定理，现在用<strong>向量</strong>的形式表示： <span class="math display">\[|x|^2+|y|^2=|x+y|^2\]</span> 模长的平方也可以表示为<span class="math inline">\(x^Tx\)</span>，做一些计算，就有两个向量正交的判断条件<span class="math inline">\(x^Ty=0\)</span>。</p><p>向量正交有些简单，让我们上升到子空间正交。一个比较直观的<strong>错误</strong>的例子就是地板和墙壁的关系，两者并<strong>不正交</strong>，因为子空间正交要求子空间<span class="math inline">\(S\)</span>中的每个向量都和子空间<span class="math inline">\(T\)</span>中每个向量正交。根据定义，任意两个子空间若相交于某非0向量，那么两者必然不正交。<br />将正交的概念应用于前面学过的四个基本子空间：<br />对于零空间<span class="math inline">\(Ax=0\)</span>，我们有<span class="math inline">\(\begin{bmatrix}  row1\\  ...\\  rowm  \end{bmatrix}x=\begin{bmatrix}  0\\  ...\\  0  \end{bmatrix}\)</span>，<span class="math inline">\(x\)</span>和每一行都是正交的，那么<span class="math inline">\(x\)</span>和各行的线性组合也正交，由此可见<strong>零空间和行空间是正交的</strong>。<br />我们还知道：在<span class="math inline">\(R^n\)</span>中，需要<span class="math inline">\(n\)</span>个基向量张成整个空间，<span class="math inline">\(dim(C(A^T))=r,dim(N(A))=n-r\)</span>，这两个正交的子空间将<span class="math inline">\(R^n\)</span>一分为二，有个专门的术语<strong>正交补</strong>就描述了这种关系，意即零空间包含了所有垂直于行空间的向量。<br />类似地，可以证明<span class="math inline">\(C(A)\)</span>和<span class="math inline">\(N(A^T)\)</span>也是正交补的关系，将<span class="math inline">\(R^m\)</span>一分为二。<br />最后，我们为下一节留一个引子：考虑<span class="math inline">\(Ax=b\)</span>，当方程个数<span class="math inline">\(m\)</span>大于未知数个数<span class="math inline">\(n\)</span>，方程组很可能无解，那么怎么找到一个最为近似的解呢？听起来可能有些难理解，举个例子来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 1\\   1 &amp; 2\\   1 &amp; 5\\  \end{bmatrix}\begin{bmatrix}   x_1\\   x_2\\  \end{bmatrix}=\begin{bmatrix}   b_1\\   b_2\\     b_3\\  \end{bmatrix}  \]</span> <span class="math inline">\(A\)</span>的列空间是<span class="math inline">\(R^3\)</span>中的一个平面，但是向量<span class="math inline">\(b\)</span>极有可能不在列空间中，此时方程组无解。但是我们想找到<span class="math inline">\(b\)</span>在列空间的<strong>投影</strong>，进而求出最为近似的解。<br />做法是在<span class="math inline">\(Ax=b\)</span>两边同乘<span class="math inline">\(A^T\)</span>，求解<span class="math inline">\(A^TA\hat x=A^Tb\)</span>，<span class="math inline">\(\hat x\)</span>即是要求的近似解。这里牵涉到一个非常重要的矩阵<span class="math inline">\(A^TA\)</span>，它是对称阵，并且<span class="math inline">\(N(A^TA)=N(A),r(A^TA)=r(A)\)</span>，如果<span class="math inline">\(A\)</span>的各列线性无关，那么<span class="math inline">\(A^TA\)</span>就是可逆的。这样做的原因后面会逐渐揭晓。</p><h2 id="子空间投影">子空间投影</h2><p>这一节非常重要。上一节的最后我们说到：在<span class="math inline">\(Ax=b\)</span>无解的情况下，我们要将<span class="math inline">\(b\)</span>微调成最靠近<span class="math inline">\(C(A)\)</span>的某个向量<span class="math inline">\(p\)</span>，从而求解<span class="math inline">\(A\hat x=p\)</span>，<span class="math inline">\(p\)</span>就是<span class="math inline">\(b\)</span>在列空间的<strong>投影</strong>。</p><p>我们首先看看<span class="math inline">\(R^2\)</span>的情况：<br /><img src="https://img-blog.csdnimg.cn/20200526204930131.png" alt="平面上有向量a,b，" /><br />从图中可以看到：<span class="math inline">\(e=b-p=b-xa\)</span>，再由正交关系：<span class="math inline">\(a^Te=a^T(b-xa)=0\)</span>，可以计算出乘数<span class="math inline">\(x=\frac{a^Tb}{a^Ta}\)</span>，进而可以将投影<span class="math inline">\(p\)</span>表示为<span class="math inline">\(p=xa=\frac{aa^T}{a^Ta}b=Pb\)</span>，这里的<span class="math inline">\(P=\frac{aa^T}{a^Ta}\)</span>即投影矩阵。<br /><span class="math inline">\(r(P)=1\)</span>，<span class="math inline">\(P\)</span>的列空间即为过<span class="math inline">\(a\)</span>的直线。此外，投影矩阵还有两条性质：<span class="math inline">\(P^T=P,P^2=P\)</span>，从几何上解释即投影2次和投影1次效果完全一样。</p><p>接着看看<span class="math inline">\(R^3\)</span>的情况：<br />两个<strong>线性无关</strong>的列向量<span class="math inline">\(a_1,a_2\)</span>生成的列空间是一个平面，令<span class="math inline">\(A=\begin{bmatrix}  a_1 &amp; a_2\\  \end{bmatrix}\)</span>。类似地，<span class="math inline">\(p\)</span>是向量<span class="math inline">\(b\)</span>在平面上的投影，<span class="math inline">\(e=b-p\)</span>垂直于平面。<strong>因为<span class="math inline">\(p\)</span>在<span class="math inline">\(A\)</span>的列空间中</strong>，所以可以表示为<span class="math inline">\(p=A\hat x=\hat x_1a_1+\hat x_2a_2\)</span>，我们就是要找到<span class="math inline">\(\hat x\)</span>。</p><p>根据<span class="math inline">\(e\)</span>和平面的垂直关系，可以得到： <span class="math display">\[\begin{cases}a_1^T(b-A\hat x)=0&amp; \text{}\\a_2^T(b-A\hat x)=0&amp; \text{}\end{cases}\]</span> 写出矩阵形式： <span class="math display">\[\begin{bmatrix}   a_1^T\\   a_2^T\\  \end{bmatrix}\begin{bmatrix}  b-A\hat x \\  \end{bmatrix}=\begin{bmatrix}   0\\   0\\  \end{bmatrix}  \]</span> 即<span class="math inline">\(A^T(b-A\hat x)=0\)</span>，<strong>这里<span class="math inline">\(b-A\hat x=e\)</span>在<span class="math inline">\(N(A^T)\)</span>中</strong>，故<span class="math inline">\(e\)</span>垂直于<span class="math inline">\(C(A)\)</span>。<br />接着化简，我们<strong>得到了上一节中同乘<span class="math inline">\(A^T\)</span>的原因</strong>：<span class="math inline">\(A^TA\hat x=A^Tb\)</span>，继续：<span class="math inline">\(\hat x=(A^TA)^{-1}A^Tb\)</span>。这里注意不能继续化简，因为<span class="math inline">\(A\)</span>不是方阵，<span class="math inline">\(A^{-1}\)</span>不存在。<br />得到组合系数<span class="math inline">\(\hat x\)</span>后，就可以写出投影<span class="math inline">\(p=A\hat x=A(A^TA)^{-1}A^Tb\)</span>，同样地，投影矩阵<span class="math inline">\(P=A(A^TA)^{-1}A^T\)</span>，可以验证，<span class="math inline">\(P^T=P,P^2=P\)</span>仍然成立。</p><p>最后我们考虑极端一些的情况：</p><ul><li>若<span class="math inline">\(b\)</span>在<span class="math inline">\(A\)</span>的列空间中，投影后仍然是<span class="math inline">\(b\)</span>自己：<span class="math inline">\(b=Ax-&gt;Pb=PAx=Ax=b\)</span>；</li><li>若<span class="math inline">\(b\)</span>垂直于<span class="math inline">\(A\)</span>的列空间，投影后是<span class="math inline">\(0\)</span>：<span class="math inline">\(b\)</span>在<span class="math inline">\(N(A^T)\)</span>中，<span class="math inline">\(A^Tb=0-&gt;Pb=0\)</span>。</li></ul><p>换句话说，<span class="math inline">\(b\)</span>被分解为<span class="math inline">\(p\)</span>和<span class="math inline">\(e\)</span>，<span class="math inline">\(p\)</span>在<span class="math inline">\(C(A)\)</span>中，<span class="math inline">\(e\)</span>在<span class="math inline">\(N(A^T)\)</span>中，并且<span class="math inline">\(b=p+e=Pb+(I-P)b\)</span>。</p><h2 id="最小二乘法">最小二乘法</h2><p>这是投影的一个应用，主要用来拟合直线，举例来看：<br /><img src="https://img-blog.csdnimg.cn/20200526221325518.png" alt="在这里插入图片描述" /><br />有三个点，需要找到一条最佳拟合直线，方程组形式： <span class="math display">\[\begin{cases}C+D=1&amp; \text{}\\C+2D=2&amp; \text{}\\C+3D=2&amp; \text{}\\\end{cases}\]</span> 矩阵形式： <span class="math display">\[Ax=\begin{bmatrix}   1 &amp; 1\\   1 &amp; 2\\   1 &amp; 3\\  \end{bmatrix}\begin{bmatrix}   C\\  D\\  \end{bmatrix}=\begin{bmatrix}   1\\   2\\     2\\  \end{bmatrix}=b  \]</span> 显然是无解的，要找到最优拟合系数<span class="math inline">\(CD\)</span>，就要用到投影： 清除outlier(离群值)后，定义每个点的误差：<span class="math inline">\(|e|^2=|Ax-b|^2\)</span>，那么优化目标变为最小化：<span class="math inline">\(e_1^2+e_2^2+e_3^2=(C+D-1)^2+(C+2D-2)^2+(C+3D-2)^2\)</span>，如何找到<span class="math inline">\(\hat x=\begin{bmatrix}  C\\  D\\  \end{bmatrix}\)</span>?<br />求偏导当然是一种方法，从线性代数的角度，回顾下上节中<span class="math inline">\(A^TA\hat x=A^Tb\)</span>，我们已经证明，<strong>这样解得的<span class="math inline">\(\hat x\)</span>可以微调<span class="math inline">\(b\)</span>使其最靠近<span class="math inline">\(C(A)\)</span></strong>，也就是我们要的最优估计。<br />所以我们有： <span class="math display">\[A^TA\hat x=\begin{bmatrix}   3 &amp; 6\\   6 &amp; 14\\  \end{bmatrix}\begin{bmatrix}   C\\  D\\  \end{bmatrix}=\begin{bmatrix}   5\\   11\\  \end{bmatrix}=A^Tb  \]</span> 这样就得到了所谓的Normal Equation： <span class="math display">\[\begin{cases}3C+6D=5&amp; \text{}\\6C+14D=11&amp; \text{}\\\end{cases}\]</span> 解得<span class="math inline">\(C=\frac{2}{3},D=\frac{1}{2}\)</span>，我们的最佳拟合直线即为<span class="math inline">\(b=\frac{2}{3}+\frac{1}{2}t\)</span>。</p><p>最后要注意的一点：<span class="math inline">\(\hat x\)</span>可解的前提是<span class="math inline">\(A^TA\)</span>可逆，只要<span class="math inline">\(A\)</span>的各列线性无关，这点即可满足。<br />不妨做一些证明：<br />要证明<span class="math inline">\(A^TA\)</span>可逆即证明<span class="math inline">\(A^TAx=0\)</span>只有零解；<br /><span class="math inline">\(x^TA^TAx=0,(Ax)^TAx=0,Ax=0\)</span>，<span class="math inline">\(A\)</span>的各列线性无关意即<span class="math inline">\(Ax=0\)</span>只有零解，得证。</p><h2 id="正交化">正交化</h2><p>我们都知道，对于<strong>标准正交向量</strong>，有： <span class="math display">\[q_i^Tq_j=\begin{cases}0&amp; \text{$i\neq j$}\\1&amp; \text{$i=j$}\\\end{cases}\]</span> 正交矩阵写作<span class="math inline">\(Q=\begin{bmatrix}  q_1 &amp; q_2 ... &amp; q_n\\  \end{bmatrix}\)</span>，很容易验证： <span class="math display">\[Q^TQ=\begin{bmatrix}   q_1^T\\   ...\\     q_n^T\\  \end{bmatrix}\begin{bmatrix}   q_1 &amp; ... &amp; q_n\\  \end{bmatrix}=I\]</span> 如果<span class="math inline">\(Q\)</span>是方阵，那么<span class="math inline">\(Q^T=Q^{-1}\)</span>。正交矩阵的例子有很多：以前学习过的置换矩阵、<span class="math inline">\(\begin{bmatrix}  cos\theta &amp; -sin\theta\\  sin\theta &amp; cos\theta\\  \end{bmatrix}\)</span>，还有一种叫做Adhemar的系列矩阵也是正交阵：<span class="math inline">\(\frac{1}{\sqrt{2}}\begin{bmatrix}  1 &amp; 1\\  1 &amp; -1\\  \end{bmatrix}\)</span>、<span class="math inline">\(\frac{1}{2}\begin{bmatrix}  1 &amp; 1 &amp; 1 &amp; 1\\  1 &amp; -1 &amp; 1 &amp; -1\\  1 &amp; 1 &amp; -1 &amp; -1\\  1 &amp; -1 &amp; -1 &amp; 1\\  \end{bmatrix}\)</span>...<br />有了这些了解后，就可以解答为什么需要正交矩阵：<br />还记得上一节中的投影矩阵<span class="math inline">\(P\)</span>吗？将矩阵<span class="math inline">\(A\)</span>变为正交阵<span class="math inline">\(Q\)</span>后，这时再把<span class="math inline">\(b\)</span>投影到<span class="math inline">\(C(Q)\)</span>中，投影矩阵就变为了<span class="math inline">\(P=Q(Q^TQ)^{-1}Q^T=QQ^T\)</span>，如果<span class="math inline">\(Q\)</span>是方阵，那么<span class="math inline">\(P=QQ^T=I\)</span>，这也非常好解释：<span class="math inline">\(Q\)</span>是方阵必然可逆，<span class="math inline">\(C(Q)\)</span>就是整个空间，<span class="math inline">\(P=I\)</span>相当于没有进行投影。<br />还有我们在求最优估计时用到的<span class="math inline">\(A^TA\hat x=A^Tb\)</span>变为了<span class="math inline">\(Q^TQ\hat x=Q^Tb\)</span>，即<span class="math inline">\(\hat x=Q^Tb\)</span>，求解<span class="math inline">\(\hat x_i\)</span>就简化为了<span class="math inline">\(\hat x_i=q_i^Tb\)</span>。</p><p>所以接下来的问题就是如何将各列线性无关的<span class="math inline">\(A\)</span>变为正交阵<span class="math inline">\(Q\)</span>，这项工作就是Gram-Schmidt正交化，先从两个向量的情况开始：<br /><img src="https://img-blog.csdnimg.cn/20200527120631653.png" alt="在这里插入图片描述" /><br />工作分2步进行：</p><ul><li>由线性无关的2个向量<span class="math inline">\(a,b\)</span>得到2个正交的向量<span class="math inline">\(A,B\)</span>： 这一步主要是改变方向，<span class="math inline">\(A=a\)</span>即可，<span class="math inline">\(B=e=b-p=b-\frac{A^Tb}{A^TA}A\)</span>。</li><li>将<span class="math inline">\(A,B\)</span>变为标准正交向量<span class="math inline">\(q_1,q_2\)</span>： 这一步主要是改变长度，<span class="math inline">\(q_1=\frac{A}{|A|},q_2=\frac{B}{|B|}\)</span>。</li></ul><p>如果是3个线性无关的向量，必然生成整个三维空间，<span class="math inline">\(A,B\)</span>不会变，<span class="math inline">\(C\)</span>其实是垂直于<span class="math inline">\(AB\)</span>子空间的那个<span class="math inline">\(e\)</span>，即减去在<span class="math inline">\(A,B\)</span>两个方向的投影(可以用三支笔模拟)，故<span class="math inline">\(C=c-\frac{A^Tc}{A^TA}A-\frac{B^Tc}{B^TB}B\)</span>。<br />观察上述工作，可以发现：我们所有的工作都是在<strong>同一个列空间</strong>中进行，只是开始的线性无关的基计算量太大，我们想要一组更加简化计算的互相垂直且长度为1的基。<br />正因为是在一个空间中进行，所以必然存在<span class="math inline">\(q\)</span>的线性组合可以得到<span class="math inline">\(a\)</span>，即<span class="math inline">\(A=QR\)</span>，并且<span class="math inline">\(a_1\)</span>只与<span class="math inline">\(q_1\)</span>有关、<span class="math inline">\(a_2\)</span>只与<span class="math inline">\(q_1,q_2\)</span>有关、<span class="math inline">\(a_3\)</span>只与<span class="math inline">\(q_1,q_2,q_3\)</span>有关，故<span class="math inline">\(R\)</span>必为<strong>上三角矩阵</strong>，也即： <span class="math display">\[\begin{bmatrix}   a_1 &amp; a_2 &amp; a_3\\  \end{bmatrix}=\begin{bmatrix}   q_1 &amp; q_2 &amp; q_3\\  \end{bmatrix}\begin{bmatrix}   q_1^Ta_1 &amp; q_1^Ta_2 &amp; q_1^Ta_3\\   0 &amp; q_2^Ta_2 &amp; q_2^Ta_3\\   0 &amp; 0 &amp; q_3^Ta_3\\  \end{bmatrix}\]</span> 这里<span class="math inline">\(R=Q^TA\)</span>。</p><h2 id="作业">作业</h2><p>Suppose a square <span class="math inline">\(A\)</span> has an LU factorization <span class="math inline">\(A=LU\)</span> where <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are invertible. If <span class="math inline">\(A=QR\)</span>, what is <span class="math inline">\(r_{11}\)</span> in terms of possibly elements of <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>?<br />在QR分解中，<span class="math inline">\(r_{11}=q_1^Ta_1=\frac{a_1}{||a_1||}a_1=||a_1||\)</span>，即<span class="math inline">\(A\)</span>第一列的模；第一列即<span class="math inline">\(L\)</span>各列的线性组合，系数是<span class="math inline">\(U\)</span>的第一列(只有<span class="math inline">\(U_{11}\)</span>一个元素)，所以<span class="math inline">\(r_{11}=U_{11} \sqrt{\sum_i L_{i1}^2}\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#2 Vector Spaces and Subspaces</title>
      <link href="/2020/05/25/MIT%20Linear%20Algebra#2%20Vector%20Spaces%20and%20Subspaces/"/>
      <url>/2020/05/25/MIT%20Linear%20Algebra#2%20Vector%20Spaces%20and%20Subspaces/</url>
      
        <content type="html"><![CDATA[<h2 id="向量空间">向量空间</h2><p>向量空间对于该空间内任意向量的线性组合(数乘/加法)都是封闭的，并且必然包含零向量(数乘0)。<br /><span class="math inline">\(R^2\)</span>本身就是一个向量空间，它的子空间有下面几种：</p><ul><li>过原点直线；</li><li>零向量。</li></ul><p><span class="math inline">\(R^3\)</span>本身也是一个向量空间，它的子空间：</p><ul><li>过(0,0,0)的平面；</li><li>过(0,0,0)的直线；</li><li>零向量。</li></ul><p>从矩阵构造的角度来看，假设<span class="math inline">\(A=\begin{bmatrix}  1 &amp; 3\\  2 &amp; 3\\  4 &amp; 1  \end{bmatrix}\)</span>，<span class="math inline">\(A\)</span>的每一列属于<span class="math inline">\(R^3\)</span>，<span class="math inline">\(A\)</span>的col1和col2的所有线性组合构成了一个向量空间，称作<strong>列空间</strong>，记作<span class="math inline">\(C(A)\)</span>。<br />从列空间的角度重新来看<span class="math inline">\(Ax=b\)</span>： <span class="math display">\[A=\begin{bmatrix}   1 &amp; 1 &amp; 2\\   2 &amp; 1 &amp; 3\\   3 &amp; 1 &amp; 4\\   4 &amp; 1 &amp; 5  \end{bmatrix}\]</span> <span class="math inline">\(A\)</span>的所有列向量的线性组合构成了<span class="math inline">\(R^4\)</span>的一个子空间，<span class="math inline">\(Ax\)</span>恰是<span class="math inline">\(A\)</span>的所有列向量的线性组合，即列空间<span class="math inline">\(C(A)\)</span>，故只有<span class="math inline">\(b\)</span>在<span class="math inline">\(C(A)\)</span>中时方程组才有解。<br />3列无论怎样线性组合，都无法充满整个4维空间，同时注意到<span class="math inline">\(col1+col2=col3\)</span>，即使去掉第三列，仍然可以生成原来的列空间，<span class="math inline">\(col3\)</span>与<span class="math inline">\(col1\)</span>和<span class="math inline">\(col2\)</span>是<strong>线性相关</strong>的，所以实际上矩阵<span class="math inline">\(A\)</span>的列空间只是<span class="math inline">\(R^4\)</span>中的2维子空间。</p><p>再来看看<span class="math inline">\(Ax=0\)</span>，所有解<span class="math inline">\(x\)</span>构成了<span class="math inline">\(A\)</span>的<strong>零空间</strong>，记作<span class="math inline">\(N(A)\)</span>。 <span class="math display">\[Ax=\begin{bmatrix}   1 &amp; 1 &amp; 2\\   2 &amp; 1 &amp; 3\\   3 &amp; 1 &amp; 4\\   4 &amp; 1 &amp; 5  \end{bmatrix}\begin{bmatrix}  x_1\\  x_2\\  x_3  \end{bmatrix}=\begin{bmatrix}  0\\  0\\  0\\  0  \end{bmatrix}\]</span> 虽然<span class="math inline">\(A\)</span>的每一列都属于<span class="math inline">\(R^4\)</span>，但是零空间研究的是<span class="math inline">\(x\)</span>，<span class="math inline">\(x\)</span>属于<span class="math inline">\(R^3\)</span>。<br />傻子都看得出来<span class="math inline">\((0,0,0)\)</span>是一组解，此前我们知道<span class="math inline">\(col1+col2=col3\)</span>，所以<span class="math inline">\(c(1,1,-1)\)</span>也是一组解，所有解其实就是<span class="math inline">\(R^3\)</span>中的一个子空间，一条直线而已，也就是<span class="math inline">\(A\)</span>的零空间<span class="math inline">\(N(A)\)</span>。<br />如果<span class="math inline">\(Ax=b\)</span>中<span class="math inline">\(b\neq0\)</span>，那么<span class="math inline">\(x\)</span>是不能构成子空间的，因为其中没有零向量。</p><p>由此我们可以得到构造子空间的两种方法：</p><ul><li>矩阵各列的所有线性组合；</li><li>方程组满足特定条件，让<span class="math inline">\(x\)</span>生成子空间。</li></ul><h2 id="求解零空间">求解零空间</h2><p>在上一节中我们知道，求解<span class="math inline">\(A\)</span>的零空间其实就是求解<span class="math inline">\(Ax=0\)</span>，还是要用到高斯消元。 <span class="math display">\[A=\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2\\   2 &amp; 4 &amp; 6 &amp; 8\\   3 &amp; 6 &amp; 8 &amp; 10  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2\\   0 &amp; 0 &amp; 2 &amp; 4\\   0 &amp; 0 &amp; 0 &amp; 0  \end{bmatrix}=U\]</span> 很显然，主元(每一行中第一个非零元素)是<span class="math inline">\(U(0,0)=1\)</span>和<span class="math inline">\(U(2,3)=2\)</span>，pivot col是第一列和第三列，第二列和第四列是free col，也可知<span class="math inline">\(rank(A)=\#pivots=2\)</span>，<span class="math inline">\(\#自由变量=n-rank(A)\)</span>，于是写出化简后的方程组： <span class="math display">\[\begin{cases}x_1+2x_2+2x_3+2x_4=0&amp; \text{}\\2x_3+4x_4=0&amp; \text{}\end{cases}\]</span> 对自由变量<span class="math inline">\(x_2\)</span>和<span class="math inline">\(x_4\)</span>，一般取<span class="math inline">\((0,1)\)</span>和<span class="math inline">\((1,0)\)</span>，所以特解(<strong>零空间的一组基</strong>)为： <span class="math display">\[\begin{bmatrix}  -2\\  1\\  0\\  0  \end{bmatrix}、\begin{bmatrix}  2\\  0\\  -2\\  1  \end{bmatrix}\]</span> 两个特解的线性组合即是整个零空间，也即是<span class="math inline">\(Ax=0\)</span>的全部解： <span class="math display">\[x=c\begin{bmatrix}  -2\\  1\\  0\\  0  \end{bmatrix}+d\begin{bmatrix}  2\\  0\\  -2\\  1  \end{bmatrix}\]</span> 其实矩阵<span class="math inline">\(U\)</span>还可以变得更加简单，可以化为简化行阶梯<span class="math inline">\(R=\begin{bmatrix}  1 &amp; 2 &amp; 0 &amp; -2\\  0 &amp; 0 &amp; 1 &amp; 2\\  0 &amp; 0 &amp; 0 &amp; 0  \end{bmatrix}\)</span>，即主元全部为1。<br />仔细观察矩阵<span class="math inline">\(R\)</span>，如果将pivot col全部移到左边，将free col移到右边，我们可以得到<span class="math inline">\(R\)</span>的一般形式：<span class="math inline">\(R=\begin{bmatrix}  I &amp; F\\  0 &amp; 0\\  \end{bmatrix}\)</span>，由此得出<span class="math inline">\(x\)</span>的一般形式：<span class="math inline">\(x=\begin{bmatrix}  -F\\  I\\  \end{bmatrix}\)</span>。</p><h2 id="求解axb">求解Ax=b</h2><p>上一节中我们求解了<span class="math inline">\(Ax=0\)</span>，接着看看更加复杂的情况： <span class="math display">\[[A\ b]=\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\   2 &amp; 4 &amp; 6 &amp; 8 &amp; b_2\\   3 &amp; 6 &amp; 8 &amp; 10 &amp; b_3  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\   0 &amp; 0 &amp; 2 &amp; 4 &amp; b_2-2b_1\\   0 &amp; 0 &amp; 0 &amp; 0 &amp; b_3-b_2-b_1  \end{bmatrix}\]</span> 我们知道，当<span class="math inline">\(b\)</span>属于<span class="math inline">\(C(A)\)</span>时方程组有解，不妨设<span class="math inline">\(b=(1,5,6)\)</span>，那么化简的矩阵为<span class="math inline">\(\begin{bmatrix}  1 &amp; 2 &amp; 2 &amp; 2 &amp; 1\\  0 &amp; 0 &amp; 2 &amp; 4 &amp; 3\\  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \end{bmatrix}\)</span>，求解过程有3步：</p><ul><li>特解：一般令自由变量取0，即<span class="math inline">\(x_2=x_4=0\)</span>，求主变量： <span class="math display">\[\begin{cases}x_1+2x_3=1&amp; \text{}\\2x_3=3&amp; \text{}\end{cases}\]</span> 所以特解<span class="math inline">\(x_p=\begin{bmatrix}  -2\\  0\\  1.5\\  0  \end{bmatrix}\)</span></li><li>求零空间，即<span class="math inline">\(Ax=0\)</span>的解<span class="math inline">\(x_{null}\)</span>；</li><li>所有解<span class="math inline">\(x=x_p+x_{null}\)</span>。<br />因为<span class="math inline">\(Ax_p=b, Ax_{null}=0\)</span>，故<span class="math inline">\(A(x_p+x_{null})=b\)</span>。</li></ul><p>对于矩阵<span class="math inline">\(A_{mn}\)</span>，我们知道<span class="math inline">\(r(A)=\#pivots\)</span>，所以<span class="math inline">\(r\leq m\)</span>，<span class="math inline">\(r\leq n\)</span>。<br />先看看<strong>列满秩</strong>的情况：每列都有主元，<span class="math inline">\(r=n&lt;m\)</span>，没有自由变量，零空间只有零向量：<br />举例来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 3\\   2 &amp; 1\\   6 &amp; 1\\   5 &amp; 1  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0\\   0 &amp; 1\\   0 &amp; 0\\   0 &amp; 0  \end{bmatrix}=\begin{bmatrix}   I\\   0\\  \end{bmatrix}\]</span> 如果特解恰好存在，有1个解，否则无解。<br />接着看看<strong>行满秩</strong>的情况：每行都有主元，<span class="math inline">\(r=m&lt;n\)</span>，<strong>自由变量有<span class="math inline">\(n-r=n-m\)</span>个</strong>，零空间有<span class="math inline">\(n-m\)</span>个基，<span class="math inline">\(Ax=b\)</span>有无穷多解：<br />举例来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 2 &amp; 6 &amp; 5\\   3 &amp; 1 &amp; 1 &amp; 1  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0 &amp; a &amp; b\\   0 &amp; 1 &amp; c &amp; d  \end{bmatrix}=\begin{bmatrix}   I &amp; F\\  \end{bmatrix}\]</span> 还有<strong>满秩</strong>的情况：<span class="math inline">\(r=m=n\)</span>，没有自由变量，零空间只有零向量，必有唯一的特解：<br />举例来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 2\\   3 &amp; 1\\  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0\\   0 &amp; 1\\  \end{bmatrix}=I\]</span> 最后一种情况就是<strong>不满秩</strong>：<span class="math inline">\(r&lt;m\)</span>，<span class="math inline">\(r&lt;n\)</span>，<span class="math inline">\(R=\begin{bmatrix}  I &amp; F\\  0 &amp; 0\\  \end{bmatrix}\)</span>，如果特解存在，就有无穷多解；否则无解。</p><h2 id="线性相关基维数">线性相关/基/维数</h2><p>我们知道，对于矩阵<span class="math inline">\(A_{mn}(m&lt;n)\)</span>，因为有<span class="math inline">\(n-r\geq n-m\)</span>个自由变量，将这些自由变量赋一些非零值，即可解得主元，所以<span class="math inline">\(Ax=0\)</span>必有非零解。<br />对于一组向量<span class="math inline">\(x_1, x_2..., x_n\)</span>，除了系数全0以外，没有其他的线性组合可以得到零向量，那么这组向量<strong>线性无关</strong>，即<span class="math inline">\(c_1x_1+c_2x_2+...+c_nx_n\neq0(c_i不全为0)\)</span>。<br />举例来看：二维空间中的三个向量必然线性相关： <span class="math display">\[A=\begin{bmatrix}   2 &amp; 1 &amp; 3\\   1 &amp; 2 &amp; -1\\  \end{bmatrix}\]</span> 因为<span class="math inline">\(n-r&gt;0\)</span>，故必然有自由变量，所以<span class="math inline">\(Ax=0\)</span>必有非零解，即线性相关。<br /><strong>基</strong>也是一组向量<span class="math inline">\(v_1, v_2..., v_d\)</span>，不过要满足2个条件：</p><ul><li>线性无关；</li><li>可以生成整个空间。</li></ul><p><strong>空间维度</strong>即可以生成该空间的<strong>基向量的个数</strong>，前面我们知道：<span class="math inline">\(r(A)=\#pivot\ cols\)</span>，所以<span class="math inline">\(dim(C(A))=r(A)\)</span>，因为只需要pivot col就能生成整个列空间，并且列空间属于<span class="math inline">\(R^m\)</span>，因为每个基向量都有<span class="math inline">\(m\)</span>个元素。<br />对于零空间来说，特解的个数就是自由变量的个数，也就是基向量的个数，即<span class="math inline">\(dim(N(A))=\#自由变量=n-r(A)\)</span>，并且零空间属于<span class="math inline">\(R^n\)</span>，因为每个解向量都有<span class="math inline">\(n\)</span>个元素。</p><h2 id="四个基本子空间">四个基本子空间</h2><p>前面我们学习了列空间和零空间，很自然地，就会有行空间和<span class="math inline">\(A^T\)</span>的零空间：<br />行空间，顾名思义，即是矩阵行向量的所有线性组合生成的向量空间，其实就是<span class="math inline">\(C(A^T)\)</span>，<span class="math inline">\(dim(C(A^T))=r(A)\)</span>，属于<span class="math inline">\(R^n\)</span>；<br /><span class="math inline">\(A^T\)</span>的零空间，即<span class="math inline">\(A^Tx=0\)</span>的所有解向量生成的向量空间，即<span class="math inline">\(N(A^T)\)</span>，<span class="math inline">\(dim(N(A^T))=m-r(A)\)</span>，属于<span class="math inline">\(R^m\)</span>。<br />回忆消元的过程，我们不停地进行初等行变换，这个过程中，行空间没有改变，列空间改变，最终的行空间就是<span class="math inline">\(R\)</span>矩阵的前<span class="math inline">\(r(A)\)</span>行生成的向量空间。<br />对于<span class="math inline">\(N(A^T)\)</span>，即<span class="math inline">\(A^Ty=0\)</span>，转置即有<span class="math inline">\(y^TA=0\)</span>，所以<span class="math inline">\(N(A^T)\)</span>又叫<strong>左零空间</strong>。<br />学习消元时我们知道，左乘一系列的初等阵可以将<span class="math inline">\(A\)</span>化为<span class="math inline">\(R\)</span>： <span class="math display">\[E\begin{bmatrix}   A_{mn} &amp; I_{mm}\\  \end{bmatrix}-&gt;\begin{bmatrix}   R_{mn} &amp; E_{mm}\\  \end{bmatrix}\]</span> 矩阵<span class="math inline">\(E\)</span>记录了我们的变换过程，举例来看： <span class="math display">\[EA=\begin{bmatrix}   -1 &amp; 2 &amp; 0\\   1 &amp; -1 &amp; 0\\   -1 &amp; 0 &amp; 1  \end{bmatrix}\begin{bmatrix}   1 &amp; 2 &amp; 3 &amp; 1\\   1 &amp; 1 &amp; 2 &amp; 1\\   1 &amp; 2 &amp; 3 &amp; 1  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0 &amp; 1 &amp; 1\\   0 &amp; 1 &amp; 1 &amp; 1\\   0 &amp;  0&amp; 0 &amp; 0  \end{bmatrix}=R\]</span> <span class="math inline">\(dim(N(A^T))=m-r(A)=3-2=1\)</span>，左零空间中唯一一个基向量即<span class="math inline">\(E\)</span>的最后一行，因为<span class="math inline">\(\begin{bmatrix}  -1 &amp; 0 &amp; 1  \end{bmatrix}A=0\)</span>。</p><h2 id="矩阵空间">矩阵空间</h2><p>前面我们研究了若干向量生成的空间，上升一个高度，若干矩阵也可以构成一种特殊的向量空间，即矩阵空间。<br />所有的三阶矩阵构成矩阵空间<span class="math inline">\(M\)</span>，也就是<span class="math inline">\(R^{3*3}\)</span>。<br /><span class="math inline">\(M\)</span>的子空间有上三角矩阵<span class="math inline">\(U\)</span>和对称矩阵<span class="math inline">\(S\)</span>(可以用封闭性验证)。明确了空间后，就要研究该空间的维数和基向量。<br /><span class="math inline">\(dim(M)=9\)</span>，因为需要9个矩阵构成一组基，而且我们可以写出一组基： <span class="math display">\[\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 0 &amp; 1\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0  \end{bmatrix}  ...\begin{bmatrix}   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}\]</span> <span class="math inline">\(dim(S)=6\)</span>，因为需要对角线的3个元素和对角线下面(上面)3个元素；<br /><span class="math inline">\(dim(U)=6\)</span>，因为需要对角线的3个元素和对角线上面3个元素。<br />再来看看<span class="math inline">\(S\bigcap U\)</span>，既是上三角矩阵又是对称矩阵，其实就是对角阵，<span class="math inline">\(dim(S\bigcap U)=3\)</span>；<br />那么<span class="math inline">\(S\bigcup U\)</span>呢？属于上三角或者对称，很显然这无法构成子空间；<br />那么<span class="math inline">\(S+U\)</span>呢？对应元素求和，实际上这就是<span class="math inline">\(M\)</span>。<br />由此我们得到一个性质： <span class="math display">\[dim(S)+dim(U)=dim(S\bigcap U)+dim(S+U)\]</span> 对于向量空间和基，不应局限于线性代数中，例如熟悉的微分方程： <span class="math display">\[\frac{d^2y}{dx^2}+y=0\]</span> 它的所有解<span class="math inline">\(y=c_1cosx+c_2sinx\)</span>也构成零空间，那么<span class="math inline">\(cosx\)</span>和<span class="math inline">\(sinx\)</span>就是一组基，并且解空间的维数是2。</p><p>最后看一种很有趣的矩阵，秩为1的矩阵：<br />对于这种矩阵，有<span class="math inline">\(dim(C(A))=dim(C(A^T))=r=1\)</span>，不妨举个例子： <span class="math display">\[A=\begin{bmatrix}   1 &amp; 4 &amp; 5\\   2 &amp; 8 &amp; 10  \end{bmatrix}=\begin{bmatrix}   1\\   2\\  \end{bmatrix}\begin{bmatrix}   1 &amp; 4 &amp; 5\\  \end{bmatrix}=uv^T\]</span> 用一个例子作为结尾： 在<span class="math inline">\(R^4\)</span>中，<span class="math inline">\(v=\begin{bmatrix}  v_1\\  v_2\\  v_3\\  v_4  \end{bmatrix}\)</span>，<span class="math inline">\(s\)</span>是满足<span class="math inline">\(v_1+v_2+v_3+v_4=0\)</span>的所有<span class="math inline">\(v\)</span>，那么<span class="math inline">\(s\)</span>显然是子空间，并且可以写成矩阵形式<span class="math inline">\(Av=\begin{bmatrix}  1 &amp; 1 &amp; 1 &amp; 1\\  \end{bmatrix}v=0\)</span>，接着看看<span class="math inline">\(A\)</span>的四个基本子空间：</p><ul><li>零空间：<span class="math inline">\(dim(N(A))=n-r=4-1=3\)</span>，给每个自由变量赋值后，得到一组特解(基)： <span class="math display">\[\begin{bmatrix}-1\\1\\0\\0  \end{bmatrix}、\begin{bmatrix}-1\\0\\1\\0  \end{bmatrix}、\begin{bmatrix}-1\\0\\0\\1  \end{bmatrix}\]</span></li><li>列空间：<span class="math inline">\(dim(C(A))=r=1\)</span>，基可以取任意一列；</li><li>行空间：<span class="math inline">\(dim(C(A^T))=r=1\)</span>，基向量即第一行；</li><li>左零空间：<span class="math inline">\(dim(N(A^T))=m-r=0\)</span>，基向量只有零向量。</li></ul><h2 id="作业">作业</h2><p>Under what possible conditions is the matrix <span class="math inline">\(A=uv^T+wz^T\)</span> not of rank 2?<br />对于<span class="math inline">\(uv^T=\begin{bmatrix}  a\\  b\\  c\\  \end{bmatrix}\begin{bmatrix}  v_1&amp;v_2&amp;v_3\\  \end{bmatrix}\)</span>，结果就是<span class="math inline">\(u\)</span>的线性组合<span class="math inline">\(\begin{bmatrix}  v_1u&amp;v_2u&amp;v_3u\\  \end{bmatrix}\)</span>，所以<span class="math inline">\(C(uv^T)\subset C(u)=xu,x\in R\)</span>；同样地，<span class="math inline">\(C(wz^T)\subset C(w)=yw,y\in R\)</span>，如果<span class="math inline">\(u\)</span>和<span class="math inline">\(w\)</span>共线，那么<span class="math inline">\(C(A)=xu\)</span>，即<span class="math inline">\(r(A)\leq1\)</span>；<br />从行向量组合的角度：<span class="math inline">\(uv^T=\begin{bmatrix}  av^T\\  bv^T\\  cv^T\\  \end{bmatrix}\)</span>，故<span class="math inline">\(uv^T\)</span>的行空间<span class="math inline">\(\subset v^T\)</span>的行空间<span class="math inline">\(=xv^T\)</span>，<span class="math inline">\(wz^T\)</span>的行空间<span class="math inline">\(\subset z^T\)</span>的行空间<span class="math inline">\(=yz^T\)</span>，所以如果<span class="math inline">\(v\)</span>和<span class="math inline">\(z\)</span>共线，那么行空间就可以合并，即<span class="math inline">\(r(A)\leq1\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#1 Solving Linear Equations</title>
      <link href="/2020/05/23/MIT%20Linear%20Algebra#1%20Solving%20Linear%20Equations/"/>
      <url>/2020/05/23/MIT%20Linear%20Algebra#1%20Solving%20Linear%20Equations/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵消元">矩阵消元</h2><p>求解三元一次方程组<span class="math inline">\(Ax=b\)</span>的方法就是<strong>消元</strong>： <span class="math display">\[\begin{cases}x+2y+z=2&amp; \text{E1}\\3x+8y+z=12&amp; \text{E2}\\4y+z=2&amp; \text{E3}\end{cases}\]</span> 用<span class="math inline">\(E2-3*E1\)</span>，再用<span class="math inline">\(E3-2*E2\)</span>，增广矩阵的变化： <span class="math display">\[\begin{bmatrix}   A &amp; b\\  \end{bmatrix}=\begin{bmatrix}   1 &amp; 2 &amp; 1 &amp; 2\\   3 &amp; 8 &amp; 1 &amp; 12\\   0 &amp; 4 &amp; 1 &amp; 2  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 1 &amp; 2\\   0 &amp; 2 &amp; -2 &amp; 6\\   0 &amp; 4 &amp; 1 &amp; 2  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 1 &amp; 2\\   0 &amp; 2 &amp; -2 &amp; 6\\   0 &amp; 0 &amp; 5 &amp; -10  \end{bmatrix}=\begin{bmatrix}   U &amp; c \\  \end{bmatrix}\]</span> 注意到变换过程中<span class="math inline">\(A\)</span>的pivots(主对角线元素)均不为0。<br />接着可以得到消元后的方程组： <span class="math display">\[\begin{cases}x+2y+z=2&amp; \text{}\\2y-2z=6&amp; \text{}\\5z=-10&amp; \text{}\end{cases}\]</span> 从最后一个方程解起，并不断<strong>回代</strong>，就可以求得<span class="math inline">\((x,y,z)\)</span>的值。</p><p>如果回顾刚才的变换过程，并且用矩阵形式去表示：<br />第一步：将<span class="math inline">\((2,1)\)</span>位置的值变0，即<span class="math inline">\(E2-3*E1\)</span>： <span class="math display">\[E_{21}A=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   -3 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}\begin{bmatrix}   1 &amp; 2 &amp; 1\\   3 &amp; 8 &amp; 1\\   0 &amp; 4 &amp; 1  \end{bmatrix}=\begin{bmatrix}   1 &amp; 2 &amp; 1\\   0 &amp; 2 &amp; -2\\   0 &amp; 4 &amp; 1  \end{bmatrix}  \]</span> 其实这个过程就是对单位阵做相同的行变换得到<span class="math inline">\(E_{21}\)</span>，<span class="math inline">\(E_{21}\)</span>的第一行乘以<span class="math inline">\(A\)</span>本质上就是<span class="math inline">\(A\)</span>的各行的线性组合：<span class="math inline">\(1*row1+0*row2+0*row3=[1\ 2\ 1]\)</span>；同样的，<span class="math inline">\(E_{21}\)</span>的第二行乘以<span class="math inline">\(A\)</span>本质上还是<span class="math inline">\(A\)</span>的各行的线性组合：<span class="math inline">\(-3*row1+1*row2+0*row3=[0\ 2\ -2]\)</span>...<br />第二步：将<span class="math inline">\((3,2)\)</span>位置的值变0，即<span class="math inline">\(E3-2*E2\)</span>： <span class="math display">\[E_{32}(E_{21}A)=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0\\   0 &amp; -2 &amp; 1   \end{bmatrix}\begin{bmatrix}   1 &amp; 2 &amp; 1\\   0 &amp; 2 &amp; -2\\   0 &amp; 4 &amp; 1  \end{bmatrix}=\begin{bmatrix}   1 &amp; 2 &amp; 1\\   0 &amp; 2 &amp; -2\\   0 &amp; 0 &amp; 5  \end{bmatrix}  \]</span> 这个过程就是对单位阵做相同的行变换得到<span class="math inline">\(E_{32}\)</span>，<span class="math inline">\(E_{32}\)</span>的第三行乘以<span class="math inline">\((E_{21}A)\)</span>本质上就是<span class="math inline">\((E_{21}A)\)</span>的各行的线性组合：<span class="math inline">\(0*row1+(-2*row2)+1*row3=[0\ 0\ 5]\)</span>； 所以整个变换过程用矩阵形式表示：<br /><span class="math display">\[E_{32}(E_{21}A)=U-&gt;(E_{32}E_{21})A=U(矩阵乘法结合律成立，交换律不成立)\]</span><br />非常重要的结论就是<strong>左行右列</strong>： <span class="math display">\[\begin{bmatrix}   1 &amp; 2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}  row1\\  row2\\  row3  \end{bmatrix}=1*row1+2*row2+7*row3(矩阵左乘向量即行向量的线性组合)  \]</span> <span class="math display">\[\begin{bmatrix}   col1 &amp; col2 &amp; col3\\  \end{bmatrix}\begin{bmatrix}  3\\  4\\  5  \end{bmatrix}=3*col1+4*col2+5*col3(矩阵右乘向量即列向量的线性组合)  \]</span> <strong>线性组合</strong>的思想也是矩阵乘法的核心，再举一例： <span class="math display">\[\begin{bmatrix}   0 &amp; 1\\   1 &amp; 0\\  \end{bmatrix}\begin{bmatrix}   a &amp; b\\   c &amp; d\\  \end{bmatrix}=\begin{bmatrix}   c &amp; d\\   a &amp; b\\  \end{bmatrix}  \]</span> 结果的第一行即：<span class="math inline">\(0*[a\ b]+1*[c\ d]\)</span>，第二行即：<span class="math inline">\(1*[a\ b]+0*[c\ d]\)</span>，交换行。<br />类似的，交换列(<strong>列向量的线性组合</strong>)： <span class="math display">\[\begin{bmatrix}   a &amp; b\\   c &amp; d\\  \end{bmatrix}\begin{bmatrix}   0 &amp; 1\\   1 &amp; 0\\  \end{bmatrix}=\begin{bmatrix}   b &amp; a\\   d &amp; c\\  \end{bmatrix}  \]</span></p><h2 id="乘法和逆矩阵">乘法和逆矩阵</h2><p>回顾上一节的内容，对于<span class="math inline">\(AB=C\)</span>：<br /><span class="math inline">\(C\)</span>的第<span class="math inline">\(i\)</span>列是<span class="math inline">\(A\)</span>的列向量的线性组合，组合系数即是<span class="math inline">\(B\)</span>对应的列<span class="math inline">\(col_i\)</span>，即：<span class="math inline">\(A*col_i\)</span>；<br /><span class="math inline">\(C\)</span>的第<span class="math inline">\(i\)</span>行是<span class="math inline">\(B\)</span>的行向量的线性组合，组合系数即是<span class="math inline">\(A\)</span>对应的行<span class="math inline">\(row_i\)</span>，即：<span class="math inline">\(row_i*B\)</span>。<br />从这点出发，对于任意的矩阵乘法，都可以有： <span class="math display">\[AB=\Sigma(col_A*row_B)\]</span> 举例来看： <span class="math display">\[\begin{bmatrix}   2 &amp; 7\\   3 &amp; 8\\   4 &amp; 9  \end{bmatrix}\begin{bmatrix}   1 &amp; 6\\   0 &amp; 0\\  \end{bmatrix}=\begin{bmatrix}   2\\   3\\   4  \end{bmatrix}\begin{bmatrix}   1 &amp; 6  \end{bmatrix}+\begin{bmatrix}   7\\   8\\   9  \end{bmatrix}\begin{bmatrix}   0 &amp; 0  \end{bmatrix}  \]</span> 再来看看<span class="math inline">\(A=\begin{bmatrix}  1 &amp; 3\\  2 &amp; 6\\  \end{bmatrix}\)</span>，能否找到一个<strong>非零向量</strong><span class="math inline">\(x\)</span>，使得<span class="math inline">\(Ax=0\)</span>呢？<br />答案是肯定的，因为<span class="math inline">\(A\)</span>是不可逆的。<br />解决不可逆这种特殊情况之前，先搞定足够好(可逆)的矩阵： <span class="math display">\[AA^{-1}=\begin{bmatrix}   1 &amp; 3\\   2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}   a &amp; c\\   b &amp; d\\  \end{bmatrix}=\begin{bmatrix}   1 &amp; 0\\   0 &amp; 1\\  \end{bmatrix}=I  \]</span> 要求出<span class="math inline">\(A^{-1}\)</span>，从列向量线性组合的角度： <span class="math display">\[\begin{bmatrix}   1 &amp; 3\\   2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}   a\\   b\\  \end{bmatrix}=\begin{bmatrix}   1\\   0\\  \end{bmatrix}，\begin{bmatrix}   1 &amp; 3\\   2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}   c\\   d\\  \end{bmatrix}=\begin{bmatrix}   0\\   1\\  \end{bmatrix}  \]</span> 此时又回到了消元法解方程组，不过这里我们可以偷个懒，用Gauss-Jordan一次解出2个方程组： <span class="math display">\[\begin{bmatrix}   A &amp; I\\  \end{bmatrix}=\begin{bmatrix}   1 &amp; 3 &amp; 1 &amp; 0\\   2 &amp; 7 &amp; 0 &amp; 1\\  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0 &amp; 7 &amp; -3\\   0 &amp; 1 &amp; -2 &amp; 1\\  \end{bmatrix}=\begin{bmatrix}   I &amp; A^{-1}\\  \end{bmatrix}  \]</span> 再次回顾上一节的内容：消元过程中所作的变换都可以通过<strong>左乘初等阵</strong>实现，将变换过程中所有初等阵的乘积记作<span class="math inline">\(E\)</span>，我们得到了一个激动人心的求解逆矩阵的方法： <span class="math display">\[E\begin{bmatrix}   A &amp; I\\  \end{bmatrix}=\begin{bmatrix}   I &amp; A^{-1}\\  \end{bmatrix}  \]</span> 因为经过变换，<span class="math inline">\(EA=I\)</span>，所以<span class="math inline">\(E=A^{-1}\)</span>，比国内的伴随矩阵不知道好到哪里去了。</p><h2 id="a的lu分解">A的LU分解</h2><p>在了解为什么进行LU分解之前，我们先来看看高斯消元的时间复杂度：<br />回想整个过程，如果矩阵<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个元素，不难发现耗费的时间<span class="math inline">\(n^2+(n-1)^2+...+1^2\approx \frac{n^3}{3}\)</span>，即<span class="math inline">\(O(n^3)\)</span>；对于右侧的列向量<span class="math inline">\(b(有m个元素)\)</span>，耗费<span class="math inline">\(O(m^2)\)</span>。<br />在很多时候，求解<span class="math inline">\(Ax=b\)</span>时矩阵<span class="math inline">\(A\)</span>是不变的，只有<span class="math inline">\(b\)</span>在变化，如果每次都用消元法去解，每次的复杂度都会是<span class="math inline">\(O(n^3)\)</span>，那么如果采用LU分解<span class="math inline">\(A=LU\)</span>，只要预先准备好<strong>下三角矩阵</strong><span class="math inline">\(L\)</span>和<strong>上三角矩阵</strong><span class="math inline">\(U\)</span>，这一步复杂度<span class="math inline">\(O(n^3)\)</span>，以后求解时：<span class="math inline">\(Ax=LUx=b\)</span>，只要求解：</p><ul><li><span class="math inline">\(Ly=b\)</span>，得到<span class="math inline">\(y\)</span>，<span class="math inline">\(O(n^2)\)</span>；</li><li><span class="math inline">\(Ux=y\)</span>，得到<span class="math inline">\(x\)</span>，<span class="math inline">\(O(n^2)\)</span>。<br />以后每次求解只需要<span class="math inline">\(O(n^2)\)</span>，大大提高了效率。</li></ul><p>明白了原因后，我们看看具体的过程：<br />我们知道，消元过程中矩阵<span class="math inline">\(A\)</span>可以通过左乘矩阵<span class="math inline">\(E\)</span>变为上三角矩阵<span class="math inline">\(U\)</span>，即<span class="math inline">\(EA=U\)</span>，那么<span class="math inline">\(A=E^{-1}U=LU\)</span>。<br />举例来看：<br />如果<span class="math inline">\(E_{32}E_{21}A=U\)</span>，那么<span class="math inline">\(A=E_{21}^{-1}E_{32}^{-1}U=LU\)</span>，假设<span class="math inline">\(E_{32}=\begin{bmatrix}  1 &amp; 0 &amp; 0\\  0 &amp; 1 &amp; 0\\  0 &amp; -5 &amp; 1  \end{bmatrix}\)</span>，<span class="math inline">\(E_{21}=\begin{bmatrix}  1 &amp; 0 &amp; 0\\  -2 &amp; 1 &amp; 0\\  0 &amp; 0 &amp; 1  \end{bmatrix}\)</span>，那么求<span class="math inline">\(L\)</span>即是求<span class="math inline">\(E_{21}^{-1}和E_{32}^{-1}\)</span>，当然可以通过上一节中的拼单位阵来求解，但是对于初等阵，可以不用这么麻烦，以<span class="math inline">\(E_{21}^{-1}\)</span>为例：<br />这个变换是<span class="math inline">\(row2-2*row1\)</span>，那么<strong>逆矩阵就是要undo这个操作</strong>，即<span class="math inline">\(row2+2*row1\)</span>，所以<span class="math inline">\(E_{21}^{-1}=\begin{bmatrix}  1 &amp; 0 &amp; 0\\  2 &amp; 1 &amp; 0\\  0 &amp; 0 &amp; 1  \end{bmatrix}\)</span>，同理可得<span class="math inline">\(E_{32}^{-1}=\begin{bmatrix}  1 &amp; 0 &amp; 0\\  0 &amp; 1 &amp; 0\\  0 &amp; 5 &amp; 1  \end{bmatrix}\)</span>，按照<strong>列线性组合</strong>的思想，<span class="math inline">\(L=E_{21}^{-1}E_{32}^{-1}=\begin{bmatrix}  1 &amp; 0 &amp; 0\\  2 &amp; 1 &amp; 0\\  0 &amp; 5 &amp; 1  \end{bmatrix}\)</span>。</p><h2 id="置换">置换</h2><p>前面的消元过程中，当主元为0时，可能需要<strong>交换行</strong>来使消元继续下去，交换行的操作可以通过左乘置换矩阵实现，即<span class="math inline">\(PA=LU\)</span>，前提是<span class="math inline">\(A\)</span>可逆，否则再怎么交换，都会有零行。<br />3阶矩阵的置换可以有<span class="math inline">\(3!=6\)</span>种： <span class="math display">\[\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}、\begin{bmatrix}   0 &amp; 1 &amp; 0\\   1 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}、\begin{bmatrix}   0 &amp; 0 &amp; 1\\   0 &amp; 1 &amp; 0\\   1 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 1\\   0 &amp; 1 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1\\   1 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 0 &amp; 1\\   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0  \end{bmatrix}\]</span> 置换矩阵一个重要性质是：<span class="math inline">\(P^T=P^{-1}\)</span>。</p><h2 id="作业">作业</h2><p>Suppose <span class="math inline">\(A = \begin{pmatrix} a &amp; b \\ c &amp; d \end{pmatrix}\)</span> is factored into a 2x2 rotation <span class="math inline">\(Q=\begin{pmatrix} \cos \theta &amp; -\sin \theta \\ \sin \theta &amp;\cos \theta \end{pmatrix}\)</span> times a 2x2 lower triangular matrix <span class="math inline">\(L=\begin{pmatrix} x &amp; 0\\ y &amp; z \end{pmatrix}\)</span>. Write <span class="math inline">\(x,y,z\)</span> and <span class="math inline">\(θ\)</span> in terms of <span class="math inline">\(a,b,c\)</span> and <span class="math inline">\(d\)</span>.<br />这道题不难，但容易漏解：<br />容易得到：<span class="math inline">\(\begin{pmatrix} x\cos{\theta}-y\sin{\theta} &amp; -z\sin{\theta} \\ x\sin{\theta}+y\cos{\theta} &amp; z\cos{\theta} \end{pmatrix} = \begin{pmatrix} a &amp; b\\ c &amp; d \end{pmatrix}\)</span>，故<span class="math inline">\(b^2+d^2 = z^2\)</span>。对于旋转矩阵，<span class="math inline">\(0\leq\theta\leq2\pi\)</span>。</p><ul><li><span class="math inline">\(z = \sqrt{b^2+d^2}\)</span>：<span class="math inline">\(\cos{\theta} = \frac{d}{\sqrt{b^2+d^2}},\sin{\theta} = -\frac{b}{\sqrt{b^2+d^2}}\)</span> 因为<span class="math inline">\(L=Q^{-1}A\)</span>： <span class="math display">\[\begin{pmatrix} \cos{\theta} &amp; \sin{\theta} \\ -\sin{\theta} &amp; \cos{\theta}\end{pmatrix}\begin{pmatrix} a &amp; b\\c &amp; d\end{pmatrix} = \begin{pmatrix}a\cos{\theta}+c\sin{\theta} &amp; b\cos{\theta}+d\sin{\theta} \\ -a\sin{\theta}+c\cos{\theta} &amp; -b\sin{\theta}+d\cos{\theta} \end{pmatrix} = \begin{pmatrix} x &amp; 0 \\ y &amp; z\end{pmatrix}\]</span> 所以有： <span class="math display">\[x = \frac{ad - bc}{\sqrt{b^2+d^2}}, y = \frac{ab+cd}{\sqrt{b^2+d^2}}, \theta = \begin{cases}\arccos\frac{d}{\sqrt{b^2+d^2}},b\le0\\\\\arccos{\frac{d}{\sqrt{b^2+d^2}}}+\pi, b&gt;0\end{cases}\]</span> <span class="math inline">\(\arccos\theta\)</span>的值域是<span class="math inline">\([0,\pi]\)</span>。</li><li><span class="math inline">\(z = -\sqrt{b^2+d^2}\)</span>：<span class="math inline">\(\cos{\theta} = -\frac{d}{\sqrt{b^2+d^2}},\sin{\theta} = \frac{b}{\sqrt{b^2+d^2}}\)</span> <span class="math display">\[x = \frac{- ad + bc}{\sqrt{b^2+d^2}}, y = -\frac{ab+cd}{\sqrt{b^2+d^2}}, \theta = \begin{cases}2\pi-\arccos\frac{d}{\sqrt{b^2+d^2}},b\le0\\\pi-\arccos{\frac{d}{\sqrt{b^2+d^2}}}, b&gt;0\end{cases}\]</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra 0 Introduction to Vectors</title>
      <link href="/2020/05/22/MIT%20Linear%20Algebra#0%20Introduction%20to%20Vectors/"/>
      <url>/2020/05/22/MIT%20Linear%20Algebra#0%20Introduction%20to%20Vectors/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><em>前言</em></h4><p><em>线性代数应该是大部分工科和商科同学的必修课，然而很不幸的是：国内的线代教学简直一团糟。如同国内大学的其他课一样，一上来就是一堆不知所云的概念、定义和性质，然后是没有什么道理的计算技巧训练，期末考完试一切结束。如果你有时间看看MIT的18.06，相信绝对会刷新你对这个学科的认知，Gilbert Strang完美遵循了现实生活中遇到了什么问题、为什么会有这些问题、该如何解决、更好的方法这一教学链条。循循善诱、环环相扣，你会觉得上课、学习数学是一种享受。</em></p><h4 id="方式"><em>方式</em></h4><p><em>这门课我强烈建议去看Gil老爷子的视频，2020年的Lecture真心觉得不太良心，看完视频可以做做20版的作业加深理解。<br />我会在Blog中专门记录这门课的笔记和理解，并且覆盖一些有趣的作业题。废话不多说，开始吧~</em></p><hr /><h2 id="笔记">笔记</h2><p>课程的引入是通过初中的二元一次方程组： <span class="math display">\[\begin{cases}2x-y=0&amp; \text{}\\-x+2y=3&amp; \text{}\end{cases}\]</span> 从几何上来看：就是二维平面上两条直线相交于<span class="math inline">\((1,2)\)</span>。<br />从Row Picture来看：可以很直观地写作： <span class="math display">\[\begin{bmatrix}   2 &amp; -1 \\   -1 &amp; 2  \end{bmatrix}\begin{bmatrix}   x \\   y  \end{bmatrix}=\begin{bmatrix}   0 \\   3  \end{bmatrix}\]</span> 这种思考方式也是国内灌输的，第一行乘以第一列得到0，第二行乘以第一列得到3，但其实更重要的是从<strong>向量(列)的线性组合</strong>角度去考虑： <span class="math display">\[x\begin{bmatrix}   2 \\   -1  \end{bmatrix}+y\begin{bmatrix}   -1 \\   2  \end{bmatrix}=\begin{bmatrix}   0 \\   3  \end{bmatrix}\]</span> 这样从几何上解释就是：有两个向量<span class="math inline">\(\begin{bmatrix}  2 \\  -1  \end{bmatrix}\)</span>、<span class="math inline">\(\begin{bmatrix}  -1 \\  2  \end{bmatrix}\)</span>，要找到某个组合<span class="math inline">\((x,y)\)</span>可以得到向量<span class="math inline">\(\begin{bmatrix}  0 \\  3  \end{bmatrix}\)</span>。<br />类似地，三元一次方程组也可以从列向量线性组合的角度考虑，几何上扩展到三维空间。<br />由此推广到更加一般的情形：<span class="math inline">\(Ax=b\)</span>，自然而然地，我们想知道：是否对于任意的<span class="math inline">\(b\)</span>，此方程都有解？或者换句话：对于三元一次方程组，<strong>列向量的线性组合是否能充满整个三维空间？</strong><br />如果三个向量共面，那么最多只能生成一个平面，也就是不能保证可以生成任意的<span class="math inline">\(b\)</span>(有解)。后面会知道，有解的条件就是<span class="math inline">\(A\)</span><strong>可逆</strong>。<br />这节课最重要的一点就是要用<strong>Column Picture去思考<span class="math inline">\(Ax=b\)</span></strong>，为了加深理解，再举例： <span class="math display">\[\begin{bmatrix}   2 &amp; 5 \\   1 &amp; 3  \end{bmatrix}\begin{bmatrix}   1 \\   2  \end{bmatrix}=1*\begin{bmatrix}   2 \\   1  \end{bmatrix}+2*\begin{bmatrix}   5 \\   3  \end{bmatrix}=\begin{bmatrix}   12 \\   7  \end{bmatrix}\]</span></p><h2 id="作业">作业</h2><ol type="1"><li>Draw two non-colinear vectors v and w, and the region that consists of all combinations cv+dw where 0 ≤ c ≤ 1 and 0 ≤ d ≤ 1. Now consider the linear transformation of the unit square (all points (c,d) with 0 ≤ c ≤ 1 and 0 ≤ d ≤ 1) by the 2x2 matrix with first column v and second column w. Are these two regions the same?<br />答：两个区域相同。 对<span class="math inline">\((c,d)\)</span>做线性变换，也即 <span class="math display">\[\begin{bmatrix}   v&amp;w \\  \end{bmatrix}\begin{bmatrix}   c \\   d  \end{bmatrix}=cv+dw(矩阵乘以列向量，即矩阵各列的线性组合)\]</span></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变态的高等教育</title>
      <link href="/2020/05/22/%E5%8F%98%E6%80%81%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%99%E8%82%B2/"/>
      <url>/2020/05/22/%E5%8F%98%E6%80%81%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%99%E8%82%B2/</url>
      
        <content type="html"><![CDATA[<p>作为一个局内人，经历了四年的本科教育，后来接触了美帝学校的课程，对比之下越发觉得差距天大。丝毫不夸张地说，随便找一门美帝TOP 50学校的公开课，质量都可以吊打国内99%的学校课程。</p><h2 id="重蹈覆辙">重蹈覆辙</h2><p>一届又一届的学生进入高校，被统一的流程加工几年之后扔进市场，工厂会召回次品，但没人会为学生负责，这样的故事仍然在不断上演，以我所在的EE为例：</p><ul><li>四年中要上若干门思政课，并且浪费很多时间去写作业、开会讨论、做pre。XJTU的这些课期末考试都是闭卷，君不见考前的图书馆走廊，到处都是拿着《毛概》笔记认真背书的同学，我曾经也是其中的一员，看似司空见惯的事情现在想来真的非常荒诞。</li><li>每学期动辄10几门课、30几个学分。大三的第一学期堆积了5门硬核专业课，外加电设和FPGA实验，以及不知道为什么存在的金工实习，更遑论还有选修课。这样的培养方案使得学生根本没有时间和精力仔细钻研，能应付完平时作业、大作业和期末考已经不易。</li><li>更为严重的是：专业课上时常可以见到PPT Reader般的老师，往往这类老师对签到这种事情非常在乎，好像在维护自己的权威，除了这些，看不出他/她对课程有什么见解。PPT往往都是10几年前的版本，排版、错别字惨不忍睹，就这样一代代流传下来，还是在EE/CS这样更新极快的学科中。至今记忆犹新的微机原理的某个女老师，上课总是在炫耀自己去THU学习人家的计组课程，要做一台计算机云云...这位老师上课时竟然将汇编程序的后缀写作<code>.acm</code>。。。</li><li>关于实验课，更是无力吐槽，你的成绩基本取决于实验报告的长度，所以内卷之风日益兴起，甚至一个小小的物理实验，有同学写出了20多页的报告。。。试想如果老师仔细评阅每份报告，自然不会按照长度打分，但是老师还要忙着做很多重要的事情，怎么会有时间呢？</li></ul><p>这样的结果就是本科学的东西考完试就还回去了，下次要用还得重新学，浪费几倍的时间重新学习，这也是我最讨厌的地方。</p><h2 id="追根溯源">追根溯源</h2><p>曾经我觉得：本科教育的失败只是某个学校做的不好，也可能只是西部高校做得不够好，可是随着很多很多不可思议的事情发生，我开始怀疑即使是顶尖大学也会烂到一塌糊涂。如果你有兴趣搜索这些内容，你会看到哪怕THU、SJTU这些国内名校也是如此，只是恶劣的程度有所不同而已。所以我一直觉得交大在我黄金般的4年里没起到什么作用，甚至起的是负面作用，我没有斯德哥尔摩情节，不会感谢学校提供了如此巨大的阻力，是为了锻炼学生。</p><ul><li>本科教育并不会影响职称评定，没有相应的考核要求，不如灌paper、拉项目来的实在。教学评估也是可笑，只会评估课堂出勤率高不高、实验报告写得长不长，压根不会有领导在乎课堂质量。</li><li>钱，还是钱：我上过Harvard的计算机导论课，整个课程有70+ TA，还有Amazon的计算资源免费支持，这样精心设计的课程怎么可能不是翘楚？</li></ul><h2 id="惩前毖后">惩前毖后</h2><p>怪不得在《上海交通大学学生生存手册》中，有学长疾呼：</p><blockquote><p>国内绝大部分大学的本科教育，不是濒临崩溃，而是早已崩溃。</p></blockquote><p>我自己意识到这一点实在太晚，穷屌丝也读不起master::&gt;_&lt;::<br />我很感谢国家的政策，让我掏很少的钱就能接触到大学教育。但是希望赶路者能意识到：国内的高等教育就是shit，如果按照学校的计划走下来，进社会迟早被安排地明明白白，越努力，越傻逼。</p><p>Sad but true，研究生的教育只会更加差劲，我不想再被继续残害下去，说说自己的打算(在达到毕业要求的前提下)：</p><ul><li>我不否认有大神可以从课堂上学会关键知识，但是对于我们普通人来说，只能把有限的时间用来做出最好的选择。适合自己的方式才是最好的。</li><li>能不去的课就不去了，尽量选水课(不签到/考试水/给分高)。用尽可能多的<strong>自由支配时间</strong>学习更加优质的教学资源。</li><li>和老师交流要看情况，主要还是科研方向问题。</li></ul><h2 id="他山之石">他山之石</h2><p>我只列举一些我看到过的观点，并不代表个人看法。</p><ul><li><a href="http://www.houxiaodi.com/assets/misc/manual.pdf">《上海交通大学学生生存手册》</a></li><li><a href="https://blog.csdn.net/wangkechuang/article/details/8125062">清华梦的粉碎——写给清华大学的退学申请</a></li><li><a href="https://www.zhihu.com/question/60444527/answer/267271327">西安交通大学和其它几所2+7相比有什么优势和不足？</a></li></ul><blockquote><p>本来不想来打扰准备昏睡至死的人。</p><p>如果只是XJTUer来知乎自问自答寻求廉价的满足感，我从来不会浪费自己的时间来反驳他们。毕竟他们抱着发霉的C9头衔和上世纪的择校观念自娱自乐开心就好。</p><p>但是看到题主只是一名高中生，并且已经成功意识到了XJTU既存的缺陷（我当年为什么没有获得这些信息？！），应该是一位相当重视自己未来并且希望它最优的人。实在不希望那些高票回答毁人不倦。</p><p>不错，你确实应该对排名有一个清醒的认识：不要再拿XJTU和清北华五以及华科北航等学校比，它不配。生源/就业质量/出国率这些硬参数XJTU全方面垫底。这时候会有XJTUer跳出来说三大奖排名才是货真价实的比较，那么根据<a href="https://www.sohu.com/a/154387981_111981">近五年各大高校国家“三大奖”</a>中国农大排名11名，中科大排名19落后于苏州大学江南大学等高校，请问这个排名货真价实在哪里？每种排名都有一些对应的“利好高校”，三大奖之于XJTU，类似武书连排名之于WHU。就算前者更客观，也只不过是一方面。更何况WHU都不拿武书连说事儿了，XJTU还在西部一隅拿三大奖自慰呢！</p><p>XJTU的腐朽、低效、没落，就算是孜孜不倦来洗地的各位，想必也是深有体会吧。彩虹楼甲醛、彭康楼甲醛、女生宿舍和主楼女厕偷窥偷拍事件、xx书院房顶掉落，还有很多我暂时没回忆起来的，以上这些，XJTU官方有过任何一个让人满意的答复吗？可笑的是，很多XJTUer作为受害者身边的人甚至受害者自身，还在试图说服自己去对XJTU“培养一种满足和自豪感”。就我个人来说，很多小事都折射着XJTU的低效和颓败。</p><p>1）上学期办英文成绩单，学校教务处的人告知要先在哪里开原始成绩单，然后找谁和谁签字，等费劲周折终于完成，回来盖章的时候，又说按规定今天不行，下周一下午来吧。结果又浪费了好几天（后来才知道，给教务处那个负责盖章的求求情就能立刻完成，呵呵）。</p><p>2）大三的暑期实习答辩，基本水出天际，只要你的实习盖章签字没问题。同期去XJTU钦定的陕西鼓风机动力集团和渭河电厂打扑克玩手机的同学，答辩就算千篇一律漏洞百出，照样稳过。当时本人没有去学校“偏好”的公司实习，答辩被刁难了近一个月。据我所知还有机械那边的学长大三暑假在DJI实习，结果回来学院死活不认可，被迫大四暑假补上XJTU认证的不知道在干嘛的实习。那些响应XJTU号召去签约的野鸡公司划水的乖乖同学们，能不能通过DJI面试都是问题。以及有大神翘课去MSRA科研，期末考的也很好，但是XJTU不给登成绩的事就不细说了。</p><p>3）老师们绝大部分都是重科研轻本科教学，时不时会遇到PPT朗读员般的极品老师。不过这个貌似是中国高校通病，XJTU具有也是理所当然？？XJTUer，你们是这么认为的吗？另外，科研也不是你想象的那样，50%以上是论文灌水+项目拉钱，极少数是高质量研究。</p><p>4）本学期老师给的一门CS相关课程的PPT，拿到一看，最后修改时间2007年，十年过去了，连页脚的日期，正文的错别字都没有变，就这样年复一年的给陕西省一流大学的学生们使用着，而且还是CS这种更新极快的课程方向，让人忍俊不禁...</p><p>5）XJTU大部分老师都是本校本硕博一条龙的教育。一个开放的、优秀的、吸引人才的大学，这种情况不会这么严重。不信可以去美国的大学任何一个系的faculty list看一看，以及去中国东部的排名靠前的学校官网看看。另外，XJTU很多老师根本就不更新自己的主页，publications停留在几年前，甚至一些英文论文标题都有错词，总之不知道他们每天都在做些什么。</p><p>关于“XJTU这些年已经止颓了，正在稳步上升，你看创新港建的多好”这类说法，我只想说我们都是普通人，只能力争用有限的时间做出最优的选择。你不能把自己四年最宝贵的时间赌在一个未知数上。建了一堆大楼就改善了对本科生个体的关怀，也不现实。走出家乡去发达地区拥抱更多的机会和更广阔的视野，就算上了一个看起来不如XJTU的学校（也只是看起来不如而已），比起在知乎上埋头洗地的XJTUer来，你已经优秀太多了。</p><p>如果非要客观地介绍一下XJTU屈指可数的优势：</p><p>1.机械能动材料等传统工科科研实力强势（与本科生关系并不大，本科发顶会paper的是极少数）。如果确实热爱这方面的科研并且愿意忍受相对较低的工资，同类高校请选择XJTU。CS EE相关工科，选择北航北邮华科这些学校，不要选择XJTU。</p><p>2.目前还算在市中心，生活和交通便利。</p><p>最后的最后，你的选择权由你的高考成绩/自招成绩决定。</p></blockquote><ul><li><a href="https://www.zhihu.com/answer/437601713">如何评价西安交大计算机系？</a></li></ul><blockquote><p>看到很多人的批评，还是想多说两句，表达我的想法：</p><p>我从来都很感激西安交大，学校的补贴让我不用花钱出国交流，好心的老师给我写推荐信，学校的名声让我的简历能进入全国的大公司，2W元四年的学费让我收获了自认为超过100万的好处。</p><p>但是这都是我对学校本身的感激和爱戴，是学校或者是国家的好政策培养了我。而不是那些搞小山头的老师，僵化的管理人员，不尊重学生的制度。这些人现在越来越多，我认为并不配代表西安交大。我对这些毒瘤的批评也并不能代表对交大的否定。</p><p>交大计算机的培养计划确实存在着很大的问题，说交大计算机本科毕业不会写代码，我觉得完全没毛病，95%的学生四年下来写过的代码不会超过1000行，一半是for循环。剩下一半是在纸上写的。</p><p>其次我不同意也不想反驳如下的论点：“你来了交大就别BB，BB不如去复读”，“母校只允许自己黑，不能让别人说半句不是“，这基本等同于“你对政府不满就出国，不然老老实实受着”。</p><p>很多人都只是挑了西交计算机的缺点，这是十分有偏见的，本着为校争光的原则，在此列举一些西交计算机的优点：</p><p>1。西交计算机系的编程作业很少，给了学生们充分的自学时间。众所周知，计算机是一门自学的专业，很多三本的大神都是自学成才。而学校领导和老师们充分认识到了这一点，作业能出原题就出原题，能用笔写绝不用电脑，能让助教改绝不机考。比如一个下午就能写完一学期的C++作业，看了一学期mooc的数据结构，上机不到10个学时的操作系统。这对学生的自学能力提出了很高的要求，极大地提升了同学们的自学能力。</p><p>2。重视经典和原创。上课的教材能用本校就用本校的，能自己编就自己编，充分地体现了很多老师本人的风格和只可意会的专业水平。甚至体育都有自己本校的教材，印象中有太极拳等等，为了防止学生练武走火入魔，学校可谓用心良苦。PPT也都极其经典，有10年前的，5年前的，表现了尊重经典，坚持传统的精神。</p><p>3。必修很多看似与计算机无关的课，比如工程制图和生物实验等等。虽然国内很多知名高校，比如清华计算机是不修的，但是世界一流大学MIT，Caltech都是有生物必修课。这充分表现了西交与国际接轨，争做世界一流大学的决心。要知道生物作为21世纪的专业，可谓前途无量。虽然西交除了生化实验班之外的生物系学生大多转行了，但未来需要的是计算机和生物的交叉人才，正需要计算机系的学生去开拓和发展。</p><p>4。计算机系经常受到自动化某所的强烈关怀和支持。前任校长郑南宁深刻地意识到，集中力量才能办大事。于是常年把电信学院的经费奋力拨到自动化系，通过自动化系的发展反过来带动计算机系，正契合了天朝早年“先富带动后富”的理念。可以预料，通过院系之间的互帮互助，计算机系必将获得长足的发展和进步。</p><p>5。上课严格考勤。除了某些特殊关照班级之外基本不能出去实习／科研，这充分体现了学校领导关心同学的心。要知道西交计算机教学水平一流，出去实习能学到什么？对于拿到了某些实习offer的同学，学校就会百般刁难，参见<a href="https://www.zhihu.com/question/281289820">如何看待西安交通大学不断地被黑?</a>某回答，这充分锻炼了同学们艰苦奋斗，逆境求生的品质，而这种精神在同学毕业之后几十年的人生都是非常重要的，凸显了领导眼光的长远。</p><p>6。在编程作业很少的同时，实验和考试则是非常硬核的。楼上有人提到计算机课程电类太多，其实有点狭隘，不才在清华计算机系学习过一年，模电下半学期的电路分析和数电的“数字点亮人生”实验也都十分繁重，而信号与系统是计算机一小半研究方向的必须基础之一，不学就开玩笑了，所以说并没有黑到点子上。而西交的考试要求则更高，动辄成吨的概念题，对记忆力的要求极高，这不仅体现了学校希望将计算机这门学科文科化的创新精神，更是锻炼了同学们的背诵能力。试想别的学校同学还在对着C++官方文档写代码的时候，西交的同学们已经背完了文档，这必将极大地提升同学们写代码的速度和水平。</p><p>7。新任教师基本是本校博士，充分体现了学校的团结。参考<a href="http://jfzx.xjtu.edu.cn/info/1006/3210.htm">最近三年的新入职教师</a>，之前三年的计算机系，软院的老师多为本校土博，在现在很多二本都要求海归博士的大背景下，西交还能有如此魄力，团结一心，不崇洋媚外，这是何等难能可贵的精神！</p><p>8。在以上这些令人振奋的进步之余，西交的创新港也在如火如荼地建设着。2个月前据某前去规划建设的老师称，一共近5000亩地租出去了3200亩，剩下1800亩尚在建设之中。不得不说学校领导眼光之长远，懂得把经济利益放在第一位，先赚钱再建设，这样才有长远的发展。可想而知，假以时日创新港必将成为下一个曲江校区，为西交之崛起增光添彩。</p><p>以上只列举了西交计算机众多优点中的几个，还有太多可圈可点之处，在计算机学科蓬勃发展的今天，西交计算机必将成为国内一流，享誉世界！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inflation</title>
      <link href="/2020/05/20/Inflation/"/>
      <url>/2020/05/20/Inflation/</url>
      
        <content type="html"><![CDATA[<p>虽然以前辅修过金融学，但是对于许多内容还是一知半解，也很难形成体系。最近又看了一些资料，就作为笔记记录在此。 ## 定义 Wikipedia对于通货膨胀的定义是：</p><blockquote><p>In economics, inflation is a sustained increase in the general price level of goods and services in an economy over a period of time. When the general price level rises, each unit of currency buys fewer goods and services; consequently, inflation reflects a reduction in the purchasing power per unit of money - a loss of real value in the medium of exchange and unit of account within the economy.</p></blockquote><p>直观来看，就是因为货币发行量大于实际流通中所需的货币量，单位货币购买力下降，<strong>物价持续上升</strong>。<br />那么印多少钱合适呢？有这样一个式子： <span class="math display">\[流通中所需的货币量=\frac{商品价格总额}{流通次数}\]</span> 举例来看：A用1元买了B的面包，B用这一元买了C的牛奶，C用这一元买了A的水果。面包、牛奶、水果的价格总额是3元，流通了3次，所以实际只需要1元就够了。</p><h2 id="作用">作用</h2><p>适当的通胀率(可以用CPI衡量)是可以促进经济发展的，比如适当的物价上涨，你当然希望立即就去购买商品，而不是等它涨价之后再去购买，这样就刺激了经济发展。<br />相反，如果通胀很严重(一般认为大于2%)，尤其是想要通过货币超发刺激经济(货币型通胀)，控制不好就可能成为下一个津巴布韦。<br />再来看看国内的一些例子：2008年全球经济危机，中国为了保持经济高速增长，向市场投放4万亿，货币供给大量增加，所以我总感觉08年之后物价就涨得有点快~地方政府为了拉动GDP，房价一路飙升。大家买不起？没关系，首付少一些，银行多放些贷款，过量放贷导致物价上升。</p><h2 id="例子">例子</h2><p>我们都知道：商品买的人越多，越火，价格也就越高。投机商就会借机涌入市场，因为即使不是刚需，我也可以买一些，等以后涨了再卖出去，这样就可以赚取差价套利。<br />随着刚需和投机商的大量涌入，需求持续增加，远远大于供给，价格继续增长。<br />涨到很多人凭个人收入都买不起，不论刚需还是投机者钱都不够了，怎么办？<br />贷款。<br />银行钱也不够了，怎么办？<br />开印钞机，大家需求这么旺盛，拉动经济的大好机会。<br />大家都有了钱，泡沫持续繁荣，价格越来越高，自己腰包里的钱没有涨，怎么办？只能自己少出一点，多向银行借点，这样等到超出个人的偿还能力，就是<strong>次贷</strong>。<br />地方政府、开发商和投机者赚得盆满钵满，大家一看，卧槽这么赚钱，都把钱扔进了房地产，制造业被挤压的没有生存空间。<br />当房价到顶，大家都绝望的时候，投机商就开始抛售，供给增加，需求减少，价格下跌，这很可能引发经济断崖式下跌，GDP没有了，银行的贷款无法收回，完蛋。<br />那么所谓的软着陆是什么？<br />银行不准借给投机者，刚需的如果不还钱，加入黑名单。还要多把钱借给刚需，如果价格下跌，刚需的钱一定可以收回来。限购令、交税都是为了限制投机商进入。<br />但是房价还不能跌得太快，怎么办？刺激刚需：买房有补贴，首付继续降低。什么？这样还不买，好，不买房的不给上户口，子女不能上学，于是就只能为国接盘，谁的利益受到了损害，这是很明显的事情。这部分需求填补了投机者退出去的那部分，需求还在，就不会暴跌。渐渐地，泡沫消失，一切回归正常。但是这损害了未来的消费能力，再加上老龄化社会到来，前景不容乐观。</p><p><a href="https://www.zhihu.com/question/19894997/answer/123847049">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Economics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Image Filter and Recover</title>
      <link href="/2020/05/03/Image%20Filter%20and%20Recover/"/>
      <url>/2020/05/03/Image%20Filter%20and%20Recover/</url>
      
        <content type="html"><![CDATA[<p>这是CS50的第四次大作业，顺便学习了图像的入门知识。 ## 基础 黑白图(bitmap)的每个像素点只能取值0/1，1代表白色，0代表黑色。<br />常见的图片格式有JPEG/PNG/BMP，这些格式都支持RGB，每个像素点可以用多个bit表示，常见的是24-bit，红、绿、蓝分别由8bit表示，范围0~255。<br />BMP图的开始位置有两个header，第一个叫<code>BITMAPFILEHEADER</code>，14B；第二个叫<code>BITMAPINFOHEADER</code>，40B。接下来的每个像素点是按照BGR的顺序存储的。</p><h2 id="过滤器">过滤器</h2><p>Image Filter就是对原图的像素点的像素进行操作，得到一幅新图。主要有下面几种：</p><ul><li>Grayscale<br />将RGB图变为灰度图。将每个像素点的R/G/B的值改为相同，值越大，亮度越大。一般取三色的平均值。</li><li>Sepia<br />比较像怀旧滤镜，有很多算法可以做，主要就是对3种颜色乘一些系数，做一些加减运算。</li><li>Reflection<br />左右翻转。</li><li>Blur<br />图像模糊，对每个像素点的每种颜色，取其周围3*3格子的平均值。</li><li>Edges<br />边缘检测，可以用Sobel Operator去做：<br />Blur是对周围的格子取平均，Sobel是求一个加权和，对于x和y方向，有两个kernel：<br /><img src="https://img-blog.csdnimg.cn/20200502165239931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />对每个像素点的每种颜色，用周围3*3格子的对应颜色分别去乘Gx/Gy，得到加权和sumx/sumy。<br />以x为例，如果左右两边差不多，那么加权和接近0，否则得到一个大正数/负数，说明很有可能是<strong>两个物体的分界</strong>。<br />综合考虑x和y方向，取<span class="math inline">\(\sqrt{sumx^2+sumy^2}\)</span>，再四舍五入到0~255之间。<br />对于边缘的格子，可以做padding，围一圈全黑(0)的格子，相当于不用计算。</li></ul><h2 id="图片恢复">图片恢复</h2><p>JPEG的前三个字节分别是<code>0xff, 0xd8, 0xff</code>，第四个字节的前四位是<code>1110</code>，这些可以唯一标识JPEG文件。<br />记忆卡上所有图片是连续存储的，最小单位每块512B，不到一块的后面补0，不影响显示，每张图片可能占若干块。<br />可以每次读512B扔到buffer里，如果是jpeg，就将其写入新文件、继续读512B，直到遇到下一个jpeg。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computational Geometry</title>
      <link href="/2020/04/20/Computational%20Geometry/"/>
      <url>/2020/04/20/Computational%20Geometry/</url>
      
        <content type="html"><![CDATA[<h2 id="线段重叠">线段重叠</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start1 &lt;= end2 &amp;&amp; end1 &gt;= start2</span><br></pre></td></tr></table></figure><h2 id="矩形重叠">矩形重叠</h2><p>看过某司一道笔试题：给<span class="math inline">\(n\)</span>个矩形左下和右上坐标（不能斜放），求重叠最多处矩形个数。<br />这道题本身不难：可以遍历所有矩形边界组成的点，计算<strong>该点被多少矩形包围</strong>，从而选出最大值。<br />由此引申出一个问题：<strong>判断两个矩形重叠</strong>。</p><ul><li>如果正向思考，会有很多种情况：包含、重叠某个角、交叉...</li></ul><p>那么如果逆向思考：什么情况两个矩形不重叠？无非就是<span class="math inline">\(A(p_1, p_2)\)</span>在<span class="math inline">\(B(p_3, p_4)\)</span>的上下左右： <span class="math display">\[(p_2.y&gt;=p_3.y)\vee(p_4.y&gt;=p_1.y)\vee(p_3.x&gt;=p_2.x)\vee(p_1.x&gt;=p_4.x)\]</span> 取反后用De Morgan's law化简就是重叠的情况： <span class="math display">\[(p_2.y&lt;p_3.y)\wedge(p_4.y&lt;p_1.y)\wedge(p_3.x&lt;p_2.x)\wedge(p_1.x&lt;p_4.x)\]</span></p><h2 id="线段交点">线段交点</h2><p>联立方程组求解当然没问题，也可以用几何的方法解：<br /><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDQvMTI2MDU4MS0yMDIwMDQyMDA5Mjk1NTI0OS05MzA1Nzg4NjkucG5n?x-oss-process=image/format,png" /><br />易知，<span class="math inline">\(\frac{AO}{BO}=\frac{AE}{BF}=\frac{S_{ACD}}{S_{BCD}}\)</span>，两个三角形面积可以用叉积求得，又<span class="math inline">\(\vec{AO}=\frac{AO}{AB}\vec{AB}=\frac{AO}{AO+BO}\vec{AB}\)</span>，所以<span class="math inline">\(\vec{O&#39;O}=\vec{O&#39;A}+\vec{AO}\)</span>，即可求得<span class="math inline">\(O\)</span>点坐标。</p><h2 id="线段覆盖">线段覆盖</h2><p>有若干线段<span class="math inline">\([l_i,r_i]\)</span>以及目标线段<span class="math inline">\([a,b]\)</span>，需要用尽可能多的线段去覆盖目标线段，且线段之间不相交，线段长度之和最小。<br />直观上看：我们的策略首先以长度为准则：显然不妥，选了黑的就不是最优<br /><img src="https://img-blog.csdnimg.cn/20200729213724839.png" alt="在这里插入图片描述" /><br />按照起始点：<br /><img src="https://img-blog.csdnimg.cn/20200729213754372.png" alt="在这里插入图片描述" /><br />按照结束点：最优<br /><img src="https://img-blog.csdnimg.cn/20200729213857178.png" alt="在这里插入图片描述" /><br />从前向后取区间，最小化对后面的影响，选择最早结束的区间。</p><h2 id="向量旋转">向量旋转</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDQvMTI2MDU4MS0yMDIwMDQyMDA5NDU1Mzg4My0xOTgxNzI0NjU3LnBuZw?x-oss-process=image/format,png" /><br />三角变换可得： <span class="math display">\[\vec b=(xcos\alpha-ysin\alpha,ycos\alpha+xsin\alpha)\]</span></p><h2 id="多边形面积">多边形面积</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDQvMTI2MDU4MS0yMDIwMDQyMDEwMTQxNjU5NC0xMjc1OTkyNDExLnBuZw?x-oss-process=image/format,png" /><br />三角剖分： <span class="math display">\[S_{ABCDEF}=\frac{\vec{OA}\times\vec{OB}+\vec{OB}\times\vec{OC}+...+\vec{OF}\times\vec{OA}}{2}\]</span> 即： <span class="math display">\[S=A_n\times A_1+\sum_{i=1}^{n-1}A_i\times A_{i+1}=x_ny_1-y_nx_1+\sum_{i=1}^{n-1}x_iy_{i+1}-y_ix_{i+1}\]</span></p><h2 id="凸包">凸包</h2><p>包围所有给定点并且周长最小的多边形。</p><p><img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229164832081-268323827.jpg" alt="image" /><br />直接求不好算，需要旋转坐标轴：<br /><img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229164921157-1565408775.png" alt="image" /><br /><img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229164931460-670765424.png" alt="image" /> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloest</span>(<span class="params">self, x, y, l, w, yaw</span>):</span></span><br><span class="line">        <span class="comment"># 原始坐标系逆时针旋转theta = yaw - 90得到坐标系(xx,yy)</span></span><br><span class="line">        theta = math.radians(yaw - <span class="number">90</span>)</span><br><span class="line">        xx = x * math.cos(theta) + y * math.sin(theta)</span><br><span class="line">        yy = -x * math.sin(theta) + y * math.cos(theta)</span><br><span class="line"></span><br><span class="line">        points = [(xx + w / <span class="number">2</span>, yy + l / <span class="number">2</span>), (xx - w / <span class="number">2</span>, yy - l / <span class="number">2</span>), (xx + w / <span class="number">2</span>, yy - l / <span class="number">2</span>), (xx - w / <span class="number">2</span>, yy + l / <span class="number">2</span>)]</span><br><span class="line">        dis = [a ** <span class="number">2</span> + b ** <span class="number">2</span> <span class="keyword">for</span> a, b <span class="keyword">in</span> points]</span><br><span class="line">        ans = points[dis.index(<span class="built_in">min</span>(dis))]</span><br><span class="line">        ans_x = ans[<span class="number">0</span>] * math.cos(theta) - ans[<span class="number">1</span>] * math.sin(theta)</span><br><span class="line">        ans_y = ans[<span class="number">0</span>] * math.sin(theta) + ans[<span class="number">1</span>] * math.cos(theta)</span><br><span class="line">        <span class="keyword">return</span> ans_x, ans_y</span><br></pre></td></tr></table></figure></p><hr /><p><em>reference</em> <em><a href="https://zhuanlan.zhihu.com/p/68617952">洛谷日报#142 计算几何初步</a></em></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 5</title>
      <link href="/2020/04/13/INTERVIEW%205/"/>
      <url>/2020/04/13/INTERVIEW%205/</url>
      
        <content type="html"><![CDATA[<h2 id="笔试">笔试</h2><p>150min，3题，每题100分，自己果然还是个蒟蒻呢~<br />最近状态好差，虽然做了一些题，但还是考得稀烂，大概有几点需要加强：</p><ul><li><strong>独立</strong>做题，不要一边看板子一边写代码，更不要一开始就看题解；</li><li>对之前研究过的一些<strong>专项模板</strong>，要非常熟练敲出来；</li><li>“题海”战术要继续，薄弱算法要<strong>专项练习</strong>：即使内推，也免不了笔试，保持手感很重要。</li></ul><p>先补下题：</p><h2 id="no.-1">No. 1</h2><p><img src="https://img-blog.csdnimg.cn/20200413151415498.png" alt="在这里插入图片描述" /> Pass 90% 开始觉得BFS可以做，但不知道怎么写，于是转去从<code>(x-l,y-l)</code>遍历到<code>(x+l,y+l)</code>，写了一下发现<code>l</code>会变，下一轮循环遍历范围可能增大，不知道怎么写下去，又转去DFS，因为DFS每一次递归都可以自动更改<code>l</code>的值，不知道为毛没有AC。 其实只要每一次都搜索整个图，去吃满足条件的补给品，直到<strong>剑的长度不变</strong>。<br />我TM竟然没想到用长度作为终止条件，而且暴力时候太谨慎，不敢把整个图过一遍(只有500*500的数据范围啊，蠢哭了)，自己给自己增加难度~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> m, l;</span><br><span class="line">        cin &gt;&gt; m &gt;&gt; l;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(m, vector&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                cin &gt;&gt; g[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l != ans) &#123;</span><br><span class="line">            ans = l;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g[i][j] &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">dist</span>(x, y, i, j) &lt;= l) &#123;</span><br><span class="line">                        l += g[i][j];</span><br><span class="line">                        g[i][j] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="no.-2">No. 2</h2><p><img src="https://img-blog.csdnimg.cn/20200413151429730.png" alt="在这里插入图片描述" /> Pass 10%<br />并查集都能写挂，真无语了。。。唉，菜是原罪<br />后来发现是自己模板有问题，结果一直T：<strong>大多数情况下T的原因不在于输入输出，而在于算法</strong>，血的教训。。。<br />回头看以为是个裸题，但是涉及到并查集的删除操作，索性直接用<code>vector&lt;int&gt;</code>存每个元素到其集合的映射关系，这样看来更是简单(一看到题就陷入树结构的并查集。。。)：<br />做题要看<strong>数据范围</strong>！！！<span class="math inline">\(10^7\)</span>普通并查集<span class="math inline">\(O(n)\)</span>可以过！！！而且题目很明显涉及到<strong>删除</strong>和<strong>求集合中元素个数</strong>的操作，在树结构的并查集中实现复杂！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            setNum.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (setNum[x] != setNum[y]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; setNum.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (setNum[i] == setNum[y]) &#123;</span><br><span class="line">                    setNum[i] = setNum[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getOut</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>(x) != <span class="number">1</span>) &#123;</span><br><span class="line">            setNum[x] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; setNum.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (setNum[x] == setNum[i]) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; setNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="function">UF <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> op, x, y;</span><br><span class="line">            cin &gt;&gt; op;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">                uf.<span class="built_in">unio</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                uf.<span class="built_in">getOut</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                cout &lt;&lt; uf.<span class="built_in">size</span>(x) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="no.-3">No. 3</h2><p><img src="https://img-blog.csdnimg.cn/2020041315143877.png" alt="在这里插入图片描述" /> 开始就知道暴力过不了，想着骗点分算了，枚举A的所有错排<span class="math inline">\(\{B_1,B_2...\}\)</span>，计算A与B的最小距离即可，不知道为什么WA，结果爆零。。。<br />贴下暴力代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span>  <span class="comment">// INT_MAX</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; w[a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[i]) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = <span class="built_in">find</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b[i]) - a.<span class="built_in">begin</span>() - i;</span><br><span class="line">                    cur += w[b[i]] * <span class="built_in">abs</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较正派的做法我有想到一点，不过当时第2题没过，心情有点烦躁，净想着骗分去了~<br />要使<code>dist</code>最小，就要求错排的每个位置移动尽可能少，使得<code>pos</code>之差尽可能小。<br />如果n是偶数，相邻位置两两互换，<code>pos</code>之差为1；<br />如果n是奇数，会多一个奇数位置的坑(有点贪心的意思)，这样必然要有一个奇数位置的数移动2次，当然选择权值最小的那个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">            sum += w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w[i] &lt; w[minIdx]) &#123;</span><br><span class="line">                    minIdx = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += w[minIdx];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试">面试</h2><p>收到面试通知很意外，唯一一个机会，还是面的完爆了呢。<br />这几天一直在看面经，说实话不难，而且很多人都没手撕代码，就有了侥幸心理。。只看了面经的代码，easy的题目都没有做出来。<br />第一次真正面试中写代码，紧张情绪下与平时状态完全不一样，第一次理解错题意，也没有确认就开始写，写完后才发现搞错了。。。<br />不知道是面试官表达能力有问题，还是我理解能力有问题，从一开始的基础知识、到后来的智力题、再到编程题，五次三番误解他的意思，总之聊的很不愉快！！！面试有时候也看运气吧~<br />简单做个总结吧：</p><ul><li>回答问题、手撕代码前一定要问清楚！！！！确认函数签名等细节，还可以先描述下自己的思路；</li><li>只看面经不行，复习范围很局限，还是要系统学习、疯狂练习，平时有100%状态，面试才可能有70%状态；</li><li>多参加面试，锻炼下高压下的思路和码力，任何时候都要冷静分析。</li></ul><p>很难过了，后面应该还会再投一些公司吧。</p><p><a href="https://www.zxpblog.cn/2020/04/11/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E7%AC%94%E8%AF%95-2020-4-11/">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TOP-K Problems</title>
      <link href="/2020/03/31/TOP-K%20Problems/"/>
      <url>/2020/03/31/TOP-K%20Problems/</url>
      
        <content type="html"><![CDATA[<h2 id="最小的k个数">最小的K个数</h2><ul><li>直接数组排序，取出前K个。复杂度<span class="math inline">\(O(nlogn)\)</span>。</li><li>分治<br />此题只要求出最小的K个数，并不要求这K个数有序。<br />我们可以借鉴快排中的<code>partition</code>做法，将比第K个数小的都放前面，其余都放后面，即得到答案，但是这种方法会<strong>改变原有数组</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">        <span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">                end = index - <span class="number">1</span>;</span><br><span class="line">                index = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                start = index + <span class="number">1</span>;</span><br><span class="line">                index = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(<span class="built_in">begin</span>(nums), <span class="built_in">begin</span>(nums) + k);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>() || l &lt; <span class="number">0</span> || r &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> pivotIndex = <span class="built_in">randomNum</span>(l, r);</span><br><span class="line">        <span class="built_in">swap</span>(nums[pivotIndex], nums[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> smaller = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[r]) &#123;</span><br><span class="line">                ++smaller;</span><br><span class="line">                <span class="built_in">swap</span>(nums[smaller], nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++smaller;</span><br><span class="line">        <span class="built_in">swap</span>(nums[smaller], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> smaller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">randomNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));  <span class="comment">// use system time as seed</span></span><br><span class="line">        <span class="keyword">return</span> x + <span class="built_in">rand</span>() % (y - x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以得到递归关系：<span class="math inline">\(T(n)=T(n/2)+n\)</span>，由主定理可知复杂度<span class="math inline">\(O(n)\)</span>。<br />与快排不同的是：快排要处理2个子问题，故为<span class="math inline">\(T(n)=2T(n/2)+n\)</span>，复杂度<span class="math inline">\(O(nlogn)\)</span>。<br />关于复杂度，还可以用代入法证明： <span class="math display">\[T(n)=T(n/2)+n=T(n/4)+n/2+n=T(n/8)+n/4+n/2+n=...\]</span> 重复k次后： <span class="math display">\[T(n)=T(n/2^k)+n/2^{k-1}+...+n/2+n\]</span> 故：<span class="math inline">\(T(n)=n+n/2+n/4+...+1=2n+1\)</span></p><ul><li>堆/红黑树<br />主要思路是用容器存储K个数，之后不断更新：如果当前值小于容器最大值，替换最大值。<br />用最大堆作为容器，删除及插入<span class="math inline">\(O(lgk)\)</span>，故总复杂度<span class="math inline">\(O(nlgk)\)</span>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// max heap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">priority_queue&lt;<span class="keyword">int</span>&gt; <span class="title">topKMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(*it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.<span class="built_in">top</span>() &gt; * it) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">push</span>(*it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然也可以使用红黑树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        multiset&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; ms;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ms.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                ms.<span class="built_in">insert</span>(*it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (*ms.<span class="built_in">begin</span>() &gt; * it) &#123;</span><br><span class="line">                    ms.<span class="built_in">erase</span>(ms.<span class="built_in">begin</span>());</span><br><span class="line">                    ms.<span class="built_in">insert</span>(*it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(ms.<span class="built_in">begin</span>(), ms.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之所以说这种解法适用于海量数据，是因为很多时候不能一次性把数据读入内存处理，这种解法可以从硬盘一次读一个，判断是否放入容器即可，只需要在内存中存储容器即可。</p><h2 id="最常出现的k个数">最常出现的K个数</h2><ul><li>统计出现频率，按频率排序后取出前K个。复杂度<span class="math inline">\(O(nlgn)\)</span>。</li><li>小根堆。维护K个数，如果新数的频率大于堆顶，替换之。复杂度<span class="math inline">\(O(nlgk)\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ++cnt[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : cnt) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(p.second, p.first);</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;++i) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().second);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>快速选择。</p></li><li><p>桶排。用很多桶记录不同频率到对应数字的映射。时间<span class="math inline">\(O(n)\)</span>，空间<span class="math inline">\(O(n)\)</span>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxFre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            maxFre = <span class="built_in">max</span>(maxFre, ++cnt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; bucket;  <span class="comment">// freq -&gt; nums</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : cnt) &#123;</span><br><span class="line">            bucket[p.second].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = maxFre;i &gt; <span class="number">0</span>;--i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a : bucket[i]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(a);</span><br><span class="line">                <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Egg Dropping Puzzle</title>
      <link href="/2020/03/22/Egg%20Dropping%20Puzzle/"/>
      <url>/2020/03/22/Egg%20Dropping%20Puzzle/</url>
      
        <content type="html"><![CDATA[<h2 id="the-two-egg-problem">The Two Egg Problem</h2><p>曾经是Google的一道经典题。<br />题意：有一个百层高楼，鸡蛋在<span class="math inline">\(L\)</span>层及以下扔都不碎，在<span class="math inline">\(L\)</span>层以上都会碎。现在某人有<span class="math inline">\(k\)</span>个鸡蛋，问在<strong>最坏情况下</strong>，至少扔多少次(用<span class="math inline">\(m\)</span>表示)可以确定<span class="math inline">\(L\)</span>的值。<br />分析：先来考虑<span class="math inline">\(k=1\)</span>的情况。只有1个鸡蛋，为了得到一个确定的<span class="math inline">\(L\)</span>，只能从第一层开始，逐渐尝试增加楼层高度，因此<span class="math inline">\(m=100\)</span>时，无论<span class="math inline">\(L\)</span>的值是多少，都可以被确定。<br />再来考虑<span class="math inline">\(k=\infty\)</span>的情况。这种情况就变为了binary search的问题，先拿一个在50层扔，如果碎，则在25层扔；如果不碎，则在75层扔...即<span class="math inline">\(m=7\)</span>。<br />最后来考虑<span class="math inline">\(k=2\)</span>的情况。因为<span class="math inline">\(k=1\)</span>只能一层一层试，所以第一个鸡蛋应该尽可能缩小搜索空间，但是如果第一个鸡蛋的楼层间隔太小(比如在2层、4层...)，无疑会增加<span class="math inline">\(m\)</span>。不妨取第一个鸡蛋在10层、20层...，共10次；假如第一个在10层没碎，在20碎了，那么第二个鸡蛋可以尝试11、12...19，共9次；故<span class="math inline">\(m=19\)</span>。<br />上面方案的问题在于：如果临界楼层比较高，那么第二个鸡蛋的次数是确定的，但第一个就需要多试几次，总次数就会增加。<br />那么如何使得不论临界楼层在哪，<span class="math inline">\(m\)</span>的值都不会波动呢？<br />很简单，只要第一个多扔一次，确定的范围(第二个要试的次数)减小，总次数就会均衡。<br />对于第一个鸡蛋，第一次在<span class="math inline">\(a\)</span>层扔，如果不碎，第二次向上增加<span class="math inline">\(a-1\)</span>层...直到最后只向上增加<span class="math inline">\(1\)</span>层：<span class="math inline">\(a+(a-1)+...+1\geq100\)</span>，故<span class="math inline">\(a\geq13.7\)</span>。<br />鸡蛋一：在14层、27层、39层、50层、60层、69层、77层、84层、90层、95层、99层、100层扔，共12次；<br />鸡蛋二：如果蛋一在14层碎了，蛋二要扔13次，共14次；如果蛋一在27层碎了，蛋二要扔12次，共14次...故<span class="math inline">\(m=14\)</span>。</p><h2 id="super-egg-problem">Super Egg Problem</h2><p>对于<span class="math inline">\(k=2\)</span>，我们有了一个比较好的解决方案。那么现在有<span class="math inline">\(k\)</span>个鸡蛋，楼高<span class="math inline">\(n\)</span>层，<a href="https://leetcode.com/problems/super-egg-drop/">问题</a>(记作<span class="math inline">\(m(k,n)\)</span>)又该如何解决？<br /><span class="math inline">\(k=1\)</span>和<span class="math inline">\(n=1\)</span>的情况比较简单： |n1|2|3|4|...| |--|--|--|--|--|--| |1|1|1|1|1| |2|2| |3|3| |...| | 那么如果我们递归地思考：任选一层<span class="math inline">\(h\)</span>扔第一个鸡蛋，无非有碎和不碎2种情况：<br />碎：临界楼层在1~h之间，问题规模缩小为<span class="math inline">\(m(k-1,h-1)\)</span>；<br />不碎：临界楼层在h~n之间，问题规模缩小为<span class="math inline">\(m(k,n-h)\)</span>。<br />所以：<span class="math inline">\(m_h(k,n)=1+max\{ m(k-1,h-1),m(k,n-h)\}\)</span>。<br />对于<span class="math inline">\(h\)</span>，可以采用枚举的方法，计算<span class="math inline">\(m_h(k,n)\)</span>，在其中选出一个最小的值，故问题得到解决： <span class="math display">\[m(k,n)=min\{m_h(k,n)\},h=1,2,...n\]</span> Base Case就是<span class="math inline">\(k=1\)</span>和<span class="math inline">\(n=1\)</span>。<br />时间复杂度<span class="math inline">\(O(KN^2)\)</span>，空间复杂度<span class="math inline">\(O(KN)\)</span>。<br />记忆化递归：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">memo</span>(K + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(K, N, memo);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[K][N]) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[K][N];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;++i) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">superEggDrop</span>(K - <span class="number">1</span>, i - <span class="number">1</span>), <span class="built_in">superEggDrop</span>(K, N - i)));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[K][N] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述最直观的解法复杂度太高，无法通过Leetcode的数据。如何优化呢？<br /><span class="math inline">\(m(K,N)\)</span>表示该问题的解，如果鸡蛋数<span class="math inline">\(K\)</span>固定，随着楼层数<span class="math inline">\(N\)</span>增加，问题的解一定是增加的。<br />我们又把问题分解为了2个子问题<span class="math inline">\(m(k-1,h-1)\)</span>和<span class="math inline">\(m(k,n-h)\)</span>，<span class="math inline">\(m(k-1,h-1)\)</span>随<span class="math inline">\(h\)</span>单调递增，<span class="math inline">\(m(k,n-h)\)</span>单调递减(<a href="https://zhuanlan.zhihu.com/p/92288604">图源</a>)：<br /><img src="https://img-blog.csdnimg.cn/20200319150302530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />此时<span class="math inline">\(min(max(...))\)</span>就是求中间的折点，可以使用Binary Search，时间复杂度降为<span class="math inline">\(O(KNlgN)\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">memo</span>(K + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(K, N, memo);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[K][N]) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[K][N];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = N + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> broken = <span class="built_in">helper</span>(K - <span class="number">1</span>, m - <span class="number">1</span>, memo), noBroken = <span class="built_in">helper</span>(K, N - m, memo);</span><br><span class="line">            <span class="keyword">if</span>(broken &gt; noBroken) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="number">1</span> + broken);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="number">1</span> + noBroken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        memo[K][N] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，此题还有<span class="math inline">\(O(KN)\)</span>的做法，甚至还有一种数学做法可以达到<span class="math inline">\(O(KlgN)\)</span>的时间复杂度和<span class="math inline">\(O(1)\)</span>的空间复杂度，由于本人水平实在有限，就不再探索。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>风雨混沌 曙光难觅</title>
      <link href="/2020/03/21/%E9%A3%8E%E9%9B%A8%E6%B7%B7%E6%B2%8C%20%E6%9B%99%E5%85%89%E9%9A%BE%E8%A7%85/"/>
      <url>/2020/03/21/%E9%A3%8E%E9%9B%A8%E6%B7%B7%E6%B2%8C%20%E6%9B%99%E5%85%89%E9%9A%BE%E8%A7%85/</url>
      
        <content type="html"><![CDATA[<p>懵懵懂懂的少年，夏日刺眼的阳光，还有，操场飘飞的国旗~</p><blockquote><p>我志愿加入中国共产主义青年团</p><p>坚决拥护党的领导</p><p>遵守团的章程，执行团的决议</p><p>履行团员义务，严守团的纪律</p><p>勤奋学习，积极工作</p><p>吃苦在前，享乐在后</p><p>为共产主义事业而奋斗！</p></blockquote><p>那时的我，有着初中生独特的稚气，涉世未深，但满怀激情。</p><p>并不太理解口中的誓词，但仍然高举右拳。声音高亢洪亮，目光笃定坚毅。</p><p>虽渺小，却坚定。我相信，风雨永远阻挡不了彩虹！</p><p>可是，成长了七年之后，我却愈发难以判断这个世界的真伪！</p><p>因为我的认知已经被完全颠覆 <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200320115313972-500146240.png" alt="img" /> 一个无数青年向往的团体，千千万中国学子的梦想源地，究竟都在做些什么？</p><p><strong>或许这再也不是我熟悉的那个共青团了，永远都不是了。</strong></p><p>北京，中产，却连自己的孩子都保护不了。</p><p>祖国的花朵还不曾来得及绽放，就已烙下了深深的童年阴影。不久后，事情不了了之的时候，那些所谓的“叔叔医生、爷爷医生”会逍遥法外（如果还有法律的话），继续它们的生活，仿佛从未出现一样......可是受伤的心灵又由谁来抚慰呢？</p><p>【我有一个长长的望远镜，一直能伸到你的家里，你说什么话做什么事，我都知道。】</p><p>略显艺术的欺骗，让人恐怖、胆寒。</p><p>长长的望远镜难道不应该用来看星星吗？</p><p>事后，有人冷眼相望，有人造谣撞骗，有人疯狂洗地......</p><p>很欣慰的是：<strong>正义永远不会缺失。</strong></p><p>很多媒体人，顶着压力去探求真相；很多明星，站出来追问谴责；很多你我一样的普通人，持续关注着后续进展，尽力去捍卫孩子们的权益。</p><p>我说，很温暖，谢谢你，谢谢你们！ <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200320115322124-352552867.png" /> 前苏联总理Nikolai Rizhkov在反省苏联垮台时曾说：</p><blockquote><p>我们监守自盗，行贿受贿，无论在报纸、新闻还是在讲台上，都谎话连篇，我们一面沉溺于自己的谎言，一面为彼此佩戴奖章。而且所有人都在这么干，从上到下，从下到上！</p></blockquote><p>很失望，很愤怒。</p><p>但我想，重要的是：</p><p>在洞透人性的善恶后，我们依然渴望曙光，那是对生命的尊重！</p><p align="right">写于2017年11月29日，知乎</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Volunteer Teacher</title>
      <link href="/2020/03/20/A%20Volunteer%20Teacher/"/>
      <url>/2020/03/20/A%20Volunteer%20Teacher/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c3d956fc9cd69cb082c1ab35e27d07803c57fe4cac00a7be46a91a2adcd74062">c172f4ee74b2b6d246b20cbfdc0b877ef99b505fa5d8131a572537fff9fcf68d041b93d42c6c1278280dfcfee4bdb9fe1c863eae62b9323324532b70860897fa86cba8524b498298a0da470d3141fa5827c38dc5199e2a8ca943b94e6d260d86151c9ba93e86ccf304411cf1e16f27f69604cbffd5edbf8e9b312c0113e9f86bd07a5aed20810595bfe7ff1da13d9adec52e88d5f70e89cdd05aad7dee4ef754ff428b6c1900d2a4895c1c3826850bdb3906c17bce1897db0a2b984d0bad81df04f8449e89940c2010a687c17d3f709938801eb85f8aad91fa2d56afdd759589214d3d92f098663c4e9653763982034843972a35da3a867c47c1382e6d55095ac407b10587e974f162ff7f3ebd54e8b3e427fafffe8990378d2412d50363f5035af724815fea878bcddd51f680d6de8ee5726e7db691b9ecf54759b28390f88222063ee90d9e516dd86d4df668813074377261ff0103e836f3eeb3b4961c9fd2db721a215379e7ce545e6be29a00474e983b755de68e573342ce44f9f7f55477b645b84c315b366102383a3d28ebfbaf837fd6db1abc99bba7dea6f45456a6690410905f72fafe971eea54dc189a79c4089f350a8df364d46066e0a14b5dec11b1695637d2dae957341549231d0f1b075bab80bebb46ce2a7bfafab94163313f4db44ad9906e2b5aae3c786df878e876831f2e07165a8bf76b8667cbe518e242bcadd9a0ac24e71300ef429e0665413d1808f10e173ce9398a6a934c4dd8cd7f65c28cc378df69ee7d10cf362142e1a9fd89e9101a44d19ba5d38aecb0c7a6dfbbc6132babad35f57382422a423324f70b7a5006e286f55614edc4320333fee160e897c61f162af219e7a6b71e5e40dc0840db8303e8f354d6fe662190ade77d7a60949a2e3907019b725a6dca09c98245936eeb203aea296e1c15cd7e51eabd0eb0565da88f4cca59f611f5c2e76be5b7f50d065c38f4f633549462080b454fd057cf7a1e576b41f9d182b5d5edb8c319239e21e8610919509e3151398e4570d22a0aa18b9246a5f2991c4b5107dc9c7cb50229d143f3da44fef18f923be5538b89bf8b85ca2821d39a45460742dbdb1ab57fb4bddb4f4b36a223f4f7c5e0061c962162a8b9151d63a953e0cc4b09bb843e5d1a36fe7d2f88bc06d91384445df84dbcf8abd57e9e95a52e3ab5dd7fdc76d4fb20403bb9807e2ce16e178f88ae6cec69f3fe0bff088a4c38aac9751651fb6f6f8c313a6ef02d55030743427d2b8275de7165b3e6148cdc4eb312b8db1b4e3ca1cdffce461a7b6abcdc57ee733763db3b4569045af76b94711770ffb3d3d28a2a0d0132a692d814bbea1b7566a2e87a09a3af935cfc7499dba3c6d7161d54515dc7727ae87133c2356faed9137d0c2f88694115caee632e0d348889e3606a257d27ac929490b3481f957caac9ce5aa0eab199bbfa8b7110d2f5ea0e7b29572ef3f4b1466d00dee8b4355825413e65461c9fb3fc9fa00db4216bc14fa000a80cf97b74724c7b4f87ca0cfec71a62b21dd2cbac1b904db222281659c73cc995205b7a097a1a005da957872b4a69503f14f95c6d9e4c880980cf258d209616c5ea22a7dc407b57f6833ba0a10d67732e83fd10519a56f4e5f6517c0f67bc4a46256ea08e70519cb6e1f105de1b470c3144ff375f58102bd8377497317654640e7744f3170e238c388ee5e62d85891d64b0ebabb635f000c5b2551a3f81695854d221d259640bba60af8fb20af1c95f818dd834d6fdfc5b928b2b6051fa3cf44800127289f15cf185d08c08521a167d134b190f04d0f13b1fc2664638b246ef9567932eb5764c17f18b81cfd3bcdab148c04a95213ed667bf61cc1089fc5faced9fbcb6085f15319828e5a1490465662e0f6b696a04d7c0a091f9fce3473372b1b38cd30f82ce198914fe0d290359d5ba26601d705e122ac2d5a8dc7c8daa97aa7d9648a900c3ed8f57c30162044817c3928f7996e5cf2585f075f4df3504852418cbaaae1504f69193678d1aacf654aee0e38f803b17f15fe0c32d67ba31495b379ce6688e6329427e9ad32d226f5497511a3139c7c4f2ec5551df6aeb0e2e2c6da3981725be792ab35e6a095abde72bbf85d3bb764ad89ece353291b3f01a9bc4900d4244d581a9cd0add8737a5696468872502be3a6715933b1250aaf08a89c919a16fce5a2021aa2c3cafbd1c80e4171dab54421b5e6732da85774b8c7fdffe817d574c936f8987c4a949e682253b2c4e14dafe91fdd2b28061c3f37b4fa7cf8f153a31bebc6be194499d1025943d3efcc0bc932c3667cb0e3ba2af236d1b71415de0c1536e0b87593a1a871f92dfb4ab55040044a335396b508944188421b3d134f628b366f3ccae5b68629d830b072ce76a2d9b2ea6411570e5208bb59cba9b3fa797c489a29ab179790fb7e792b3467919688ff14f97dd8b51dc5da55d676653f3b6d96c6c83af3b60866155c20f699899e5ca22efefa448a35b7d71eeabaf28adaefe5c02cc6fd132ac1fddbc6126d7002bb2ed21401792618521bf8d8edb9912ee5c0be6a68902aa22063d01af924ebf290da98d4bc85682d93739b57587973c2b2b2d3c5d9d3f3c1226382ba6e8b7c92a6e48c199c9a1b7c5d39e3a90e32433673e94e5da6a4bcd67ad11f3bf9e4580bbeeee5ca912316ae37a512a7a9fe2847cb965908cf168d575ca2332e5346bc602d29a80504fe3017f78fb85bb077e00af3ad2da7d4743638375c0f4eb1d512dac795a86717837c433fa5e956d38e93349960632edf494054b422a4156c248756e17a5f00db415b6f7fc120007a9f95b3e410c7d25b91d874c8a64a608617991d2534786f739b69be516932d0d19b2530001c524e5946149f758005652bf2d9fbb5737fe7748872963c93577cdb7e53ef00968257ca662f21b2a6c69b2725e6ff64b31e5b137bf008fefb2921f2107f220939323b4a170264e8eba99fdb21a6e188343f01061187a0eabe02f6e2571ec0faffb778345d6c06658a8c0a4e5fdb49fe8c0b9940c954f63634d7d4b2c338720f79cb4ac3ec911ff4657c484661c63ca39959fca43bba53ee0408a6b5bd582b1afd829ab9c95b94c85d4ffad43cd6d7ee95f3b75faea8f76006cde92d899a4fb12a96e34452504375ac6f63c53d62b5d7bce1584c77dba700eec1210ee8097d9afafb9231c62c7e506574334d1c303bfda309eac2333b837130720dbfaee3b1d1a71f2ba4b88c107f9f1ff3bf077d7b70fc5463399714fb920ed5a8f5488f9939528c9a1f681937dfaee7e6352884f6c0873c3288a40b0a5e9c2491aea770ae70693936fb9663dd3586ca765912f3082f00bbef547e5487e8113b4964500396924361a58d454711dcfe93f81565078858222c8e9ab9dead11fca44d8e27e24ff59f716d7afa91eb83f12f8022c3d9e4aae7e079e9cf1d1d989d6da0a484f77c27d8bdf616e556d90666ee1a7a1555707784407e124dfcc26604cfeb64f3588f45872c0cc9fc117de4bf3b22a08e64b645717695cf25fa17a44f1d8cbeff67843613f1b00c763a27403bbdbfc850243208dc5c72ce434246b7ad5ca4bf7d1d47bc3d3dd72fef3158e50b3e9a5fbfb4967e55a28c537ec3f1d9b09be8d992fbd1fc2690c6be235c4c7f191a7f461c0109bbcea68956a026652d23f5201599a51121bbd96a853fb45889028b1d6e87869ff008c982d53046307fe2da23c50bbfb4de11102b6d0b0fbad0ce094516d7333514d75a95e2457482330ff9278a913744e46d17f229b5c3942a76926f66059fe27bd2f283b6739efa1a18a2a89705dd8e887e7d952f18db1e40ca101ae409b1b3476102aac8f90bd4d78436b9e3b70aea2f1901e5102255b89dcfdd844fbaea63fbb705b33d87aaa88b7fafa1c13dfac09e0ce04b40b23579d31f7b967bf8d7f6679ee2f5a1ce03b76198489d2247e50ed67e06095a385b754d7b451d0abbc127db0cb322a40d4e7e274e8de9df948413cd20a58423b0e82fea561cb8fd0cd124b085ee108394e0851854dc0a8f9c1dfbbf7a284fffc6850dd60096b0d77a2a175a7f468eb1aca5f888dfd9757ceed6def090d579fb151e1699a2e32ec837617af4f548d45d056284669c14068ca292fd311e81748ffb4d5dd277ee5dc19739a397c68b8d21c82051e309234da104683f8d80a4ed39ff8323fb8d6d0b0df0f45cec4299fd236cd7d6795d0f3c69c569d0aa4676291a161a6093038b06b32df020b6fff71f8351621ae70b258391320140d257725293da446b80bcc641f335f35aa12813ab617a2e244c733a4c16e6ecb78ace05cd62eb497a0e2942100c4115a6f34c0ecc1d46f33912b30905bb57ec3402b29237b3c27652227ee1216e38b0582e10752300149fcdc87f193583d2d5a15123c350ab10ab946f4268e6003284ddb5664cb5890ce2f557e7544628ef3c78bbdf33a4dbc409c3e5e6ed109f1af5fd5c956f3cf0a3fd73c25a63040404bc6da78593fcf64491628c48b96aee4108072e2fc8704717f973f2387229c0ca80eb0e1d727ff2c3c7fbcb09a79d06fbdab4a650b8ded11d57e6f7552c6c775a69e80615924f5a14801a48107013858b68ac679ad2e1203c081bef4cd63853c9898f9d0a40238ef2ba3df24d47853363d5e43992424616b337b4bc833c58616009ae4ad56b950f07d88519d33717c3884a4e4b5921e7f074d10b5318d2ed8bcc3a504e9f105913e4353c96a2dc3dd3ca4b84798a5069f27a7f3d164fca9361b5ef32aeddb1da12a55f2106245901c8fb136a56cbe6f6382591f71b722d1b61d59ab395659390d9d5a31a0aabf479f65ec8f333dd442f83160ab969e5fbb9eab17b002a88f438f6ee6bec910608f16eea54c589a2e1f355faa0db92816ee754486488440d8e680191114e97d7394e84c5359a2c47a05666b3f93b196d0aacc58bee51c92a5c7078374d97b611641260899174f753f91b9420e0e1e1250055030513b5228048dc6ec5ef36d230adbe9cafa226654616841b551d11c547b33df99bcf377aff3ab75526ddbbe6b7782f444e0df7e6d07bcd821c5768188392954718e31abecf408e29a8cdb613cf028f4eba54c1cff7264f5a619f4c8aec1bbde4d1d2a2cccfb62c00f9e7af62bda82f5183f393d77140e69354aa8c54af82e77fca449523759e7de8c9996d504d024162d6295fea4079114114aac92cd7bb2425030b54699d6d0f77a14dcc3d10bdd89666a1cb25d9d516877d2c3b1ec8a651fc2c386d335b3bf124ad4ce887de6d4724867b025763ba5fc6398e3dfc881a21fa7b5f4c8daede66d9dcd9afd8cb73a9839d1ea400c8e93985728268174d661218f7e9ba00ef31bce8742e117570ec63cefcd07ba3219092fef6ed14dbdc37802a11cfb288f3ee15ea12e3de74734c234083ee032184599fb1ac29cc8e1a18858fec9e9f7a9bebc29a9157bb628600538e5ddbcf1671ed8bc300f21b3b7f215b83bcc8a78b9dccaae3d021d18e0df5d88fcbcfcb4944b707fee8215e3157075e84672d041f8b096fffeea777b1e9f81f217bf9a953eba4608630da0ac8e9a55bc33f7987f5d147e50b8e9e0d1334a9dfcdb74ab61ead6f7e7374cccd229f68da10fe7b73cd69819471cb180a3b9a6e002cce011393a952d71a2a4e5829379593a477025465b2f69f0fa0d035c5845e54d599042e7831ada4d2cb3580d5b169d1aae8b09df1410e0ffd63487ee8bfdc1503a5174bb26c0be04fbb3ff82515317f203f339b37f5e7e29f26bd235ae344ff4711cf5cd31090a508dff1de33333da9c72c7d3bccdc20252fd9f8552270068f151596a6d3d529fbad51c917597bc379b4bbe9b9b89837d0d8410e15010f04995f01aefe56cfceccb88a599701247775d03980bad4904544ea406ad0ade5087646afa56285d6e4b1d293b26ed27d63214001a44516c6945ab21ebeb06743a64bec20e23b94b9b52b8ad5d68da1a9b37394d14850c6dfc5df80cf62ba0a746624b5d689c79d7765b89c4ef602302d4ec2aa6ccc5f040f9b0f5d8cae256c7b3f55a50602ec49a94cf466ecca6fa3eb61b41989705f79e04be3d0d1b198ced81ef3ba22bf87981f1141ac8ff4f057d75dac722659034684ef6adfaf523d874c4ff68951518f485445ba63b6aeca17b559e307c20755bcbced3d4062feb532e672d455c03f639a750b9df7d07594793dfe25ebb5f1428e6c03399561a4eef1deb267da8fbef06032976e9905ecf39756fa2ebb710a333c63d79d9046a43f7555aa856cc775f8fca791530274b351030ed82ed0684ad1a8d835b999b655ef3e9c3b303c16245a9a53ca0f43fdd5b5ff2db793ad0bd407e53cd995f60fe2b423d29d5105619e9f08d868d00f023f10b730d6c1453fbd84a002c963ffb34209ea99c757a6d7ea9dabf1a7ef557e3ad678b417f768da11c9b6bf7ac582b0e437d86b86ad6c2921802b26aee815046c5f9c1a1b67e47675354357d8cd56d322b73fd82005ebfc23bfdfc40c5ff1553ea621b40b1fb76e569a1d6ffe19f6630b6f4833fe27374b3a99988be64255af7ed9afc5c5e72282de1d1dfd0ed6f11b58404d8433ad0e8adbec9901bd2a35e7bad532c0ec1fbe22da2cec92a37f56364fe9cdd24aee77b9d7c97ef5593b3cced2033e4ba75c51d9689bbe364cb5c440e4b7ec2b9074b69be0ad25e658ed0b1cb469f2b61ea349ef5c85f5f5a91b9721b0d700ff8f7c83fc8628314d85f0b1b08bee24307520ad335bcf6cd8d20f2836d09be88564b2360a24c52aea313aa28d904a43fbe49bd1dc8945cab34834100b2b1993e1495e4b0d44eb1ad0598e76c15c1ec513e292a487cb481539d7e634a1a75a6e95edd5695cfa46cc93bbc88f5141b66059c5e0fbb6d6d698e3ca3f5a64a8e975e90f07666b1a58dba53eabfeb1f3d97e5186b525546af53055764840d6306fddc67ef458b6d2e2c4cd3c155a4d1ec52b0d03c8b476dc7a14686ca0bf7453adb003e26f90736a7ba7a8ca7b7c55d7d582671d22eb798dc894c9f8884abbf39b41f06e581652c045cb4159f387c9b99bad72233e81814c0c688b5b90256f292f3dc444274c8fcdb9fadbacc4f5fa474749f144c16a98d5d9a56ff5cd60c48998698fc1747515a04132c001acb42cd91b8bb46fec4f3e3e52f82d6578e44f4523d4785dd2f89fcb5692331c806dcfc4332b43b266c2092097cd741eb14a9dec99104d0cbdbcf25c51d047b0369e5dbd4936e2bf9f61a93f100ec022228ed257292d2334b385cbae0dbe13610c87154319be748423b5949ccdd2c9ed908d1ad6d635381114f9e9e70ad17e6cffe2191518049dbc04ca4c652e58947f13b9079239957433ad326e94f1873074918fbf49e43d9f6aebfd06a28e2398498f471be6436fd43a55e9d9b2cb301c5c107c348938bf994f5438beeedde341f0cb298c05b9c3f2783a04715682cd12c0ac6d9547c193c27f9b5ad316fb085f3fb9b37455fd495f65d1cd5be736b9090dbfcc5b1f5decf13805c02cace351d24c602eccfb7e936e4896347b04ccafb09a8c27aec9046228cae1c615b2537fd76c71913cae7d9fe776167d58ac8ec33afd9de2433122797595df54c1aa24164b92e697a876ca545bf6c7451e5d923eac5de3ce2992fca0bf5437d787f6644c2e7e8b67c7d8633649fbd4ba6d92d24d8f7655843e3292bf168e1426c55ad2f66febf8f3bf2a4791ef26b74dadf1154d0b3956487f8d41614c186121067fbc14312be2c3c92b4fed5a966a9e8863e3b79b010acb725a8a95ea8173e169924675d485a57db4f669b56adb20d49a22126e05c013115bd7067edf6d671b0161dc0c18b190bb760f41fe5e3ae0207661c0fe85bf9b70b2daf2a0e167e171f32e959212ba34107589f4852d54271612ae613f1e25ce4fa9663ee8d9092692aba7514be1fe3530da63c9bcddea0c60a81285c4cc68c1b5d780f752ed6e7a521205b90de5380142705fea5216549f00eba600508227c3545631fd3546f8fd0f98ce96e4f7bc91c7da790caf817ba45364d960519b8102df745b6b8b48abd3960fdc56e433b947cc7082673102428fa667b797eef024b178e2c62c3e64b50f22ab0ac6dfd95fb9fb4838e68ca3fca430249e3a9bcfaf5f8662bd3e655d467270f332671a15dc2d3e3798b609f06b9b8749b7b1490ef9362de71d72aca52a8d3e9162f748f9309639aa7a48610ef954b8f058694441a095a78e29366803b8e691ec62693519fbe11aaa7ed7a1485f3a08131d323547d906fd5ea0223f9170486a20329734d912986417fa2d01feb775daf57790e88b87274b9a99edda65a92a56a022eb487764576bae2f60f885bba34c2b5ad20892d66cc7a2f0963763699dfabc243d8fd436fdf13e5023034656c11250e530d1a2d2c6e701dfcc548f93f6764a8b194e73cbe219524a6c73b42e7b56b35366c2269ff1c581d4881aa6846f5cca8fe1197252ae765d4a0ad450baeb14c09132154b859828b5f0e83609af0eb090769f01f2da3c4becf2093155559c549ea762a468a1ab3639c873fef8acc50a72472f447866a69de74682314d56a511c1a9653712c0c15b4d46a2d59548e414d030f2fad78ca2622b8284f9aff1ecefa83261049320686e0fb496b359c13d320d228d46b5eb4beb8e11534b4c4c58fca788b5d8f25535d29d25e486b184565dc0ee06eadc5ebcb5e8288385936e76b6ecac873abfef1a294bde065abdabd9f1917ab566af87edac1e5015c9d42c4a610126d248c8a3229c3605aec558b4b9474c57511f3d6007e2d316fafb6efaae7c01e350d16bb185c37203cc21686e1f17ea76b97b13a74555e610c17f61876277fc73e01750b0ef1e99d10bef71d87093101afd16070d7c817d4bf4319945c11a23293ce2f7617c1f9904f590ae874cdda0ebf01a576a8bc8faff1b5a9d26839a843dfe4d74c8a6cce05bd03416635ff5a28fea968deeea41536dce109191c96239f2cca44f7eb43822ded5097b96b5c58089e3e2091c1d9760f947bb84c1486e3dd2274384208538153c280a7fa6ad7974c56a5eae0787bb222ae61fe223d3fc0613f2a11f6e09ef3d23c4bb942b89b8d8abf727ccba99ff8bd7b531dc5065395674a15caf9b107d1aa9b46de223e59af206a71f1c41571069b957b36f4e9d57647f947063d2927f1092fe7a022f0da4d3669afaaf54dfa13c11eed4e9f6df03e2f01635f41f4ec6e6e9d28a797df18157cc1c76f3fd7ee4ec3fb1193658b2e17c159293d03a8b79c3f4c82a11c7e04f3922524b5a5030cbae19081d4552a6ae9cdab3ece1af735c50532ec7dd3a3b252021ae8a7f3efe678296468ffbfabefd536308a05aaeab2916c94497265401e9a7ab1adab84c537dd4c91400fca44457228878296cfa723f37205a7832bd8e42765ea8103db1b1afc57f7b93a4f46fe40ee6cab9108a08370c5bd413012be29b58bff9599e744bf2a2f6b94896230a8e08aef595e96c6d4242bd042b78f3a9adc54645a13691a8307d9f6ee0ba7207ee80607b57c557f16c92c1d29133607598bea03f84dd585051d03b4dfaf86fea970353cef7685913505484a543d80f961676caab400058bead2af994c04a0b84f3e87cde841f5ad0dfecfa8d353420c3b09fcad3aaa26e8ff581d046323f54776921f73854cfd1206948d06b4a4b2472ed421321c973530201c8ec918f3374e7db0cf75502d709e05103131c0451179603e6c2ddcc78e81df78f262b0263c9afd4181ca296a4326ed159465d5e102d4b508b53d524fdce7e9e57279dfc1a80188b00d448b89a0be8fc1e047e2bc45f03cf3ac623c5302c7fd35f506dadbc29de7d21acce913b27bd21cda5a057233f99ef754cbada9266fef77ce485afd2b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Football Memory</title>
      <link href="/2020/03/19/Football%20Memory/"/>
      <url>/2020/03/19/Football%20Memory/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="6253cfbe6abff5f7ce22135cc2c42238e1820f64311d1d8fe0810b40362819d3">418fac4f173397084caccc18ab9f089e69927f0d8d0ec9a30dd19758ed758a6b270be7b76dbba6b804251b45ad5685a60efe969b09187278a052d91e22dba9942dd0ac6c68b9372365226006542d33c828a4733ddebc876fd05548ebae4edd96e8347a71d86fff65748b9f73d6fc3f9c082a07a337bbfffbe28e0ffbb39ad30dc25a4cbeda30893fa92d10f2b4a058a91adc671857f4c01e6ecebe7b1fd99d1fcbb120c0118341eb3c21ef6a8a3e16ca7f1a4163ca9997a44e97bcf949e376d2ba077ccb983415f326127806071a1ade280d71dd6d151bd0dd29f68568018c915c4581e80038e42aeb502909c036164d10b6a226bfff3fbe54bbe4ffa6936431a248273decb8cac84df5d891880238f455df52379ef75fca8970a541ec6e3a48683a3059e6e078e5f2c6e118b81877229fd5936b95c841c80eca9c8bb1ab067265db40a8e4c1b343c85828602583b952993a7bac0ce9ba74b53f6c3ef33d75d3818940a408acbeb247835bd6e1a12a00a7509a7dc2de59180d0442c919a4e7011b90e39022414cdd0dc3ea2566a2e00a15719f24dcddc5f82a261edfd8ec3193a2f69e187412efb00688222ed701ae47613d03e2b53ddc9bfd71d9174cd818462b536cf6507cf6114d3dd353a97a6c742593540196365c566190a33fb98fa3bde733e1a45923dff17a853a43b388a0b738b3aa0f8a199fc423ee785abd195992d4b235bf2bc5090266b8c2407f465494e55e1c6ab290c8a166b90da069b4f2899f8dab431ec576be90b03a0d0d27954ca21f48d996e4cb76a83da4eb163c6e034dad0acd2f89edec934db83c949131933cd475ea8eef16eb9a0b0362312472ea93a06b0b2189cba025b38ab10e420ba303fb2d19e8a40e65aa32fe58b3479cf3dac4cd0b26325802ed85856fc565f1e96d0d716d6c7805014dea19b3f8d5e6022911d8b87570e2bffca8fede417158699baae1d8c543110e30810798fcc8d1223de689001955ff7e174bab313645ed92dd9d493ca4798c5e4be3d23d0832420f2d5600f29dd2d93ddc678508d55f7c785a5d20da8f5bba3b6983881c844299e356ca5ce7ca35f514f10c4f5727610a8c995889cd46128e20f5c10e31d7b8cedb3d515654b4b6897f8ba7f4df50408c8ecea371e8b7701d1d72d7e89dd135b97d98af2b22c4b7852009e9e08702ecc467c77999523576a6145ee34b9d8649b133781fe550d3dd6ec617d0be6ee1f02c212038d4a3e53c3f1b5d093496f68df684d46869527a5713618783c96c20be420ac85be0ddb9a244c1482b3dc455f93cf651ea07362fbcda509d51f74b28bf7aa6159387be7b7545ce1b3ad740321cdb4c40219459b433d91f850121c54b923a5d403f32507698483d099eb291eed59e023a226eb8e51ca1a9db703d38fd7de9f35c615fbdc2054d907b8396b58f6868295c683790ce43eb5d168b543acf5fe176a0fa6de5e662ab986010e2473c478d682d26aa2b148ba41d5230945f703f1715a7038fd31f37acdd7662a39bc121f7c4919791832fb358baa80205fe1994335203e58a729ea403e98a61ea000101bc0624a4d36c14b33208520450883169ecf58fc0c3c4e8ec775cef6541413c72c4e3b160c02f241a305b9684d766e4d7b7ddb4959d930069bc31ee4599974f382306f2da987174f6b0e8822179f018a0cb8ab454537d3a05810e598cc85781a66649ccfa21c174c81525ae15ef78a429c4e8598697d1104f52d7d09e71ef1668cfbf97ed6dcf620d5e66e123acd952fad92de0fa4da6479dfb8138659599dd1a272fe96cfed4312f23a0e77fdc77ad8111c776b76e959a496235d7b95c88a17fc7b645f18830c00e8539e8bf557d10cecb153f0726621717906a9dc65cf03b16f77d6b4e07e968fa09a6f401493365193be30d453c62ebedc962e0b5107d0832a9ed7d0ee2e040278c2c1435982a1cae0b90a13aca69fb4ae95c22f65495439851986b6aa6ccdbc3b37479fa6702182b7f47848c8a6e1524b2ac9564dc3642e56f70ea4094d8f4a69be2f5aa5a3efecfc57ffdb39523b9f67827f868a4d7f2d5f92063cf8a81e792ec372d97c47e5586215709ce0400ddccc88ae9b1f33ca161fc1f23e1e294504e4d265259434a2fe5c12b09286046dc8d87482dc976ea68562de5c76cac89ae2c555ebfff2bc9d63b16f38ef167bb7c4109c247cd26aca221424b6e0d28c52335b2999bcc576153008bab90fe01e23027f38ddaf9ff1a18942effa0717d841ae47ee8e47be33331dfda7a5b6e06a6cfa1eb7723823466e882ef8cff6f216a6957a34884ad897386db397586fcdf684f3e1ef62537c35e7c9bae37fcc97710222f1b33993d17e29aeba69e2dc4ee3675d911db4f2a66b2e3fcc68f2d90a44e74120dd1bb9093af4b36453c503a58ff8ec4bdeae79b1c9e975570fe831dfe0be63f02fd9c120370a80e88dcd7512bc541ab2f221e8a8a4485c1e0717b4e45695fa2cdb49bd53302a00554c74c489d0db3912c3acaf199b4a768202ace5252d19927870c6c66fb2e58aa147839339d5dd6f02e606dfa030fc1d8d021910144eda780e6afdeab0584a70e64f5faaa57ff7f7cad46eb9e30a01f37a48508718ed9d13de52ff82ccc72836aa119f53a394fadee7f2930832240c1776f6c360fea533c1e7ba01b42d121a7b2df42aba21525459958c9c5541f39590eb9c81ef62043dd7d07de9e1f3dc135f4d21f468143d53657fb3276f06ece13c9c2a1322e12f000914ed5804ab1aea8b6357c40a3f47c7e711678ecf03cddf5275346534de5ce2a168168769eb514fccb0f495d4990e47a386a8a3871e007a6b227fdc35688d4d605f20fbd1a94b20d7d122fcd78d486be8cef940891a12a5a9a8fd839bb013bd0949578a0a2d8e1879f9f9aba75e9e4d91c3711d67e85e411a505981c6344fed3c722bb09e27eb470276d19edab06c927be35ba8ff8c8b922a32c8e70b690a377852d9e3d14b026e7a926fd890c9ae9fa9f1520f7841035dc3d26ffabae12b9532dfbb35592012431b56945c03832b70e54f18179f4d582fc94c08f5cb004ac81ff56fe36018d738f275b2b033dc12db0ae0989f5bb5e66184a6865ad1a4d0745386d739742a7efef8d060948f98d0f2f0d41d7c1cff44cf6eb20c1c1b7aed04e6311a505769498b0b2bb0f01bdbd28d64842085b14484b71a2d53a0cf5be61503ef51ebd939eaf4c7aad50e2f7e0cbc5bd70f04077a5f206e115a59438d9b6df414401fe1628410949ba2a3d6b9baa4d314fd9027ac789dbff364d71fe4a51659ad9a3ed8f01e23885a856f543337a2af30ff9d4311b75f8af5249fb9bf4e735b3abc348ac8411d16c5c0a200509e6e0056e9b4acba85a2767afafc23bd7e3807a26ff5276b154efe67d8c89438cf965f81ca32ff7496259feff501d87c5da53e344482f1b2c55d7ac218b47547a39276f99653ea53af1f17633ca845335a16beb9b4ed5525c3ebf17e5e2ce9bb65899c927b5e6deb3ce1e14b12fdc66f561bef8d62a003669505a1df92b11368ac88608ff1ecd40d0531c39bb6b39ee9fa5784a32c0b47394d4015a9ff2052a97a852cc5279ac8bacb62c7c2fa90d38d9bc6e832c680b3957c32661a3bd77af0a465029b59990d303d070260f39905f845b70791ad8f4f702bde8b77b4673685eb1adf4feb8ab7690143bcdc8f352a5069f4a62855e6648f755d5605db73bca4dd573beb0165dfd825b4bfb353e0d2f3b4378442db1b0791a13c931ad3e9e101eaf5dbc5182854666efe220e4010578db0eefcb88dd658b2d580f703ad97dd18a3fa5c3370adf181ed66162d71b64666c09f5fa34d6d1b71e21314a3b237a08e7e5cb1662f343ae4bb0e80f3ca34c38a28cc0f1145593c284b901fda7726a10bbaa3df87e9d03cb53ab756988de5cfbf68e112daba125fffe570ac7b3dd053af0664738fb4255c70af796704888249660972d7fbf955c42900a64f01e12747447bfe9bcbfcf598422f09648e9933af81feecff1ef3f4b56b84e4c649c52f90ff303f24c70b47ffc44319734df686c9e402a6aac81dd5e68757524f43b8d111b1d2a3adad46dfc80756762e9b23991d44649cc9e9ba8829e0dac2046927b6ce75437184dc007a37a2d997cd6d1d39c2fbc66f23f7a9881fb1c88fe8d03936ecf735516ec7561bbf760e797281c582acf7901b91429526b728ff2e6941fa054c5924210ebb2ad41e9bef13cd441f4096dca8790d62ace907058964b052b6f923b1ebfd70edfc43405df921484681b80740467c554bc1dd4c9bcba816be9e3c5541f3e2e369273bdf8cfb566f6dcbf0eb918317b3d0279f3ff38e2739203f06e73b4333bdaf3f0521b22111516a9b51aaa855cfca8c2f223fd5e0fb2a7efb55199c396aa8784774247d512f1d492fbd580aa15f75c56591a2e5b675ed8ddfd5eae71f6496569d226383a6c5edf6f50a97d6bf7174bc06cfc38e732a6e24e8415f189a7db7537fc7889ec63cb155ccab18e27ce628e147655944f5b0211694c77d7d44c62d5d3c7b078678aa12645ddd94c60762f215df5395b057023e4cfc42f21b9cef7a7389907c41aa1c4dc15fbc6332693692a3e9ed0aef9736be48eb8c39401602e4d3edeced7f1de02b5a3887477f05d762936d1b45236f67b812921a429ce47c5d0f6e816ec41f2932d82e436763aee40efd670d434708b07d169491983171afa0b41aeff08509ccca7d812e7a897c63865033432ae57976f6feb414f63ad9b497094e90060f2f6601dedf55a40ee603190a70d3df7bd3e173e9ebae2c2536eb1f12e29b380e20fdd464d69ad1d2dc6dccd541775514bffa3beecf00eb6e5eb4ebebdc19a98d45abaaa9aaa75b7f1a5cd84497c25ba74a434883861302cc51efce877e2eb4f7b169ef7ff7f33d3ed401742a8c207cc0f9c92a91bbb2cc0c60eb531f08fdc0aa2e827266443acf22690263addd6c6b3118fc04f60404a871083078f67c88c332ffc33418a58f11cd72475840c1e19108bafcbd81dc1c4437290d9a5cea10ce94bf62d39fdca4222b6069d9bc190dca38a913d9adae649113823b49d6be2318638cff7e6ff3cb4d1df550bbdf46926b73a7d2ff5931a5175305e5c9a2a70fc4c358af755d0af02a9bff5e3786c5a1fb2be8e1187450da66c2837a789e4c71305a3910c01a0d54c986dc51fdb9f14f33edb162b81738f1f52f8bf4bd133012916c5c7da2c4f53b5f308c16d0fa993d3c8025a563348cc8f1f5eb7dac478922dedb87758f7f4d1e02a21da46179efcba5408e6376c3697fd43d936d48dd6e84f33bce379b5e99f73f4c9e4706cbb5ee0cf2f5348223e462edb4e8991f0a6f35bbdb875f857fa84c19ec6824a10599d39058c367a39b038a7fd1f936c211a9f1673a5d25310e63ffd9812b49c1b751e22655c4c8064e740d0ceb1793932c5dd28edbd888b40254450fad10a9b2493d054ada5c96419a40cebfb64d79949f67b8810dbdd4b243c3f87bbfcd15e2dbe7f40a1544387abc9ee3d06a446a7b05789ef47e349d86226cb33606f10a43d0c79e16127b9e3355a601ffa32856a8e3564cfaedef701b55692869fe3d94021617db394b74d0e06c158397ddc8a897107d00b038045d1fc73a224b7e01767ddb76dd10b593fc0798aac68902a16e3e7e03b7a2cc7ca4dd67046aa4ca4b1ed3b14ff1e4d49f512b255beb80d98de5e61d5d974f820d5d847eb2c516e038a380c32b408866bde178fb9a16b71e84601d500dc95ce55e3b2fbdf2676fe4da10f6a7cda5afe2b14c3b09dc22ded71dc45beb0e61b7fe04de0f02118bd455a85ad8303b59c6234bee37dface9d7439c74114331bd94b531add9322175e8fa895d33c94658587745404a15709cec95a0695aa842776bcd2b389511f3b3979d959599d16015152b9a105b18c16a01f8012adf9098368dc2da2ba1bf829cb929431cd1f347d64c2de87c202a7fb211dc3bbc35d41231da1e7ff5b7486b5e2648ae3d5189e1b3b8ea4b224f6579ce16f2e33220fc679dd338f1dd8a8dbfdbdbe2b2e54c02de3edab02a0c93f055cb2b0f9053767a0d8f532cd02e45501e38302b461e154dc06546d82e2635d57c6b2f5be6eac48982201bbf41bb115cf4e15d846a677fc838e2fc18f287976cea70ead3862d9d6d349eed2b059356807f8a144f45f14deb9dad127482e56b30dfacb38abac400c851353330fd39d72f34c9d8c56f1535b5fac29bf5335b59be128fcb7c9b91c62a9cf970c60a2e210653e00a26380c67e87cb319f6a23f36f26906b90755282227614c0821cf1b86917ec48dd20b9ee3600ad41fd8ed639e8eb54e64528db59b2f7bf79f57104438d3151b969a3486af24c01b3434b018dc19a3b8aa7b0d2c6672e61b90920e6417590be7aec3d2da711a975226027760dab6ed4fcf8d69ad6bc88a7077f2b3949e63abea25815676f02f8fc4fcfa174623a61a8b2bc4e2766dc48570e59d82bf72d590e9eef78a20c79bb0fff4933c86d01751144393633839f4d3d6a8529923e0719fce2d79ad0badf0b53a34aa8f4cc00ded05aa8c5f3006750cd1d35da4801e9b7904694a7af4fe3700168dec8177d25c71f5e081a02ff49f6298b29abecf837bcb8cccde7fbe837d0c8579e43ede13f8da4eba394d1a37444cd9b8097edd714c1737365c0640cb68b1f5724ddb8ee1f7d6ff1e7267be5781a4fc7940704439c5da50d58f1e4cb57bbc67c67a89a7898dc7ff3b692313b985f5acd9e4110c36cf6634ba3b3f64fce7299aceae7853611e6b448e7e577a7709578adda9ca3b7a587121d60d62a0f2c595325dc2073535e613b02e82fa460226e1bdf666f44962fbdd2545a496c78334c995ffe4c2569de0ebbcf3cae9007d91efad3b98c8e88cf026ea6fea36453cb18419cdf0931e506dcd58caa7cdb248238f32bf129f2f07432b3fe3f778f763fd692f3d6ab8cb25d712894ae3bd2ee21e4f90e6cdc440b2837562fe4eec2767741444fcfdb532c1ebe25e72d2aab85778a54acdcb80bfd118f85e23ad5167ca898d4c275895fb8ea6c87134e40808ebf620ed4a58723f612c65815f8937492379397cb8910759bf48cfac0857bd250741c646504759387bdb2c6d985dd4f6e1bfa17156b7d1b219a2beb20ff7db364f966d3358e4307dfddfdda1cabfa3aaeeeb511585757885598bac9a951572be8c7cc58c259a6955fdf3f4c30fb4c3afaa8e67e172401a15522327b8d713fca74070f7c67c6124b0ae2f7f49c20d619ed08af113a52263637644e33acae896d107e4225a5b1bc9f7f879ee85bf3a66b88c660872f2d8cc9a49f33948d837ebf8a55799a4e892975ebe03e4cfcf1155df62bd5af803e3c2c728dd06ae219e78e6842a2f0e69d5efce54ebada1cd930d170085e4292c4d6546c70d779e17f2da820e48ffe020fad1a6104d4dbf4c9ab8272e08d6782127c50320ef6d58d56af8f4614eba1f39bfc62b3e59c03dc70476e86ea360779f4993d3e1bfca0d87a721c661e5eaee6fd169255c12e0870153d71ac1fe5dd6837def1552e5f98a8c2c91c2c34b51fc90721b3b437b5a75fe9a1ac11451c7f808dd3286abba9184ca433d2f316fbff38bc046b20ea8434fd97dcf5552cefe14055f13515e37edcf1feab007fcaa8b16ce570b2940e62e48b124dfa0f5786124dc39bc32cd04537fa5b9f83360b30949b9898793c7376e0cdb30218c3ba27630dba035b673e9a57dd1649d6a00982d556615889e79f6753704065c50df87f64ed4741746e185a091dfcfa50048de27bb49a66b49d3f3023f9109e2168c4080c91e39ae634ba2afd7ba8ab53f0b30301d7468fa2ab7d1b45b30962061d8719fef0be1a4a40497262901de4855c423f8653901a081da7a3234de4ad4b27fe0b81230b36af4a7671455264dac4fc63f55c2c1780712f5b7cd4243817ae3c32989c062786e31a28558f14177ceb9fe673ec445d50c442d22d553558a96e9b29a0747991020e10cb8bf06f96cee19ae0a6813a303dc907dd91a4575fc67ea3f0845fc25ffec8380b77d23b1d46d32760dceea189a5a431508eb68a8f44e55c60116d576ea71f33f987e16fcd6ff01c8379b37ad3c72c6094cefbb8e8ca43fea9a367e477f022ad2f5b5e818af31013fc39fb1481a0b7529a4ec3970870b810a17694aa2c19e910107b45bf9dcba4159269cf219663fb4425d087ddf083e84d086f72711a1c18377f5cac4fb23c497e85710a5201e5ab25b1fd150337b1646cbb758f6e401c3e2e9b23c66d93f4875d13242bfb72b2929283c37ecce53ca9bf3c3e788893fc8c8cc26218</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Senior Year</title>
      <link href="/2020/03/18/Senior%20Year/"/>
      <url>/2020/03/18/Senior%20Year/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0fbdc338852741362fc7a369bbfd1974ec7a15e415794efb2a23056138e06d4c">c172f4ee74b2b6d246b20cbfdc0b877ed71a37ad3f3dc5c83807f39da0639778285ce6c8953780dda0003c3ae6e46404b484c83d52214fe291ecb618e22e87c3a4a9151beb371c63500725c8c540eaceb89628e679f98babba0660c82f6118ecb390798e05b33b9ad7c6870c1d8f866c715b648eddb572ad9ac1a3029ce75c78c049e8e1191a093d9aca9474cd8d348f7996c6da617c23c804f7bcd6f7af63bf9f52d691086a685eb6d07fa92b6bd26f3892dff6eb3ca862a6dc7dfc7e3ce3b619f7b213bd55890147a1084f501a73ce6e5537ca1689eb6847dd656a66e64159cc2f986a43de5e03490c269ad200d90e9952191510c7f785f6727411ffba76c65c9036895cd54e1394dd1497cccafc5ae48ce49ef2b0840db4574c250853e0213ae6dda07274efbb327b2454134097b5dd465cba1f1584b1db7cd02ee61b771f03dc56da5189c55252464f2b0ee02a344bda1b6675a52c063c32651cdecb858a82e0d33f82803932cb7944d7e97ade26ac65763c92feb8f05a679d18dc60d33656725fe60faa03b9646130a644fe7756dea74e15619f94a995b6401b44c6bd7bddcc81088e258007aafa8a53716b3d0fc432e82a1bb2333bcd8560a83b20fb059bc2a4da26602f2fe7312836de024640b5fdedc542784118a2fdf3afdb397c3d5f657d37b56c3588e2f351a09d3b6b4a4f29e3a39e538248f9d19e52ca39108c1bcbff8bfa56735a77c33ec418defd8377e62f1b6a33d81f4eb702be7789646075f2cc82c192501b5b2c615bd1a69097d10d9f4dd8397755cdcc3ecb7f097bdd6d397a0628c3ebfbae0aa184876ba2faa35a8a65bd211b8220fb03f37f79dcab2646e22de1b24198d46c06a54072e50942ac2bfe47fe16fb07426b6ba32a7128cb989657197acbdfd127a2bb71a63560b5dcb6f43e6ae44ee86ea26571100e3c0786fd9810ac81981ea7e15c78595dc4818eef64d6506acb22ad5a0f1cf85a1ca4515c081daf6975f4fd7a113a5a28dcb0619b5d6bb8e55aefa3276b4d9b5153d12127d33b08dc15124491bb2bd728305fc664814ebaea6518185c17af2cac622654a963259f9238b6c33b1ec76b0752ea46582cc5b0d84184efcf32eb8ee1021fad7a04c66788d3b9670535d401bfeef1c0d940891dba8c487143a87a249af1ad7f499a3d6c1116753698ce81cc5ec45cb80d1d594df345729d5b905c9a77377e3cf3b44567f22d16df86b047d8edc74a499d37061235dc76d0ce8f8a831d984fe9d808db7d9c3e46fd8509a3dd1873515ac96320379c5ed09d369d81d0e973141160bdd15b2d033a231361d1d75e8954f9abdb695912f710c66abb677e638c718ae10a20360695a14f8b4b971046c98cd5149a3a9eecb17091ada5224fdf7cdfdb44b17f591bf056183651a3097abe818cf72307de9b020173164be0a912f0db52ac19a94bee7a03137394095a3c17366bb3c9f3e9c3114f408db4ec28a320c6b45311984ed43af924ff6b915a017dc9ddbe138ade62dc32403b693910e0afc22d51d7355c8bf97535eb394cd1e31143a7ce4042319621e9540ce6da8608c245b6ab63d7bdad0f58c5be12e4c920ab5c9c5dd7a903162ba0d9d99b0ef39f074c0de6aa3f8a9caf56e2f0882eb3df50f9b4d1f5428e879e862bcd0bf32c7c10ed79892fcce7e78819fbcae095e5b0a285507bbebe5f2769e04f69e28b6a7a37140755d129eeb6bef631321baded09c477bdac4e81536e08ae765c42df509358a1f2d57f992b5af2449e04514b0f280d1ca6d65dc43f8a7b67c82f35001f3f885a798991c5ea10a9070491d5f3afacae66c64220586890f675fb10641882aa31dba8c8417247382c2d367aa74fc39a5411e712a3e931bfaa373e8b44200c269fb491f23c294db1af1c922a28826b4a4a940d3f5c18dd4ed44e558fbc47be46de4a764a3c5322989d4555b6d375e4c5fb0724e1573c2db4329f76eb82f40a2edb3935edbc0462e02d86be4ea23a55a65d968f06c94010ee22f47c590b4ca9522661f8297bac3540b11d19566a7e65863d934b4cbc44534bcda785d03b59ac6ad7991347323036b6982031fe2492c4370432908ff7fc99f00100239b057f6ca9ad0442f80b0f2f34c619b931fe29d2dfb72923224c4ccebf148a208abfea29c767cbdc8eb1563946a9a3c20d435ba4a6fea82feaf342a63982cb3e28e40e84ec92161b1a843cb29fc2d1e17fca28c8abc00f14534234618dbdcb541837fc3af4f7a8a8a6927cfb53c2b568e6504c95b30f91d686e60a2072f069f4d3a1750b7a89596a9ba07af539d4dc126b00cf2dfafbaf38fb96f20f1fa8d8fa5853a7cc0b2e37856af1dd8e2d3185a6603e478fc0c398248e918a5de285284b15454a1d334e57a1e3d3b03e216ffa387bf5d021a5104ce45f34e0fd50057f0fc2922bf123bcacd67a16683cafd3437270362dc0211402cc7473ae17206096fb2a4a838f74d84613d2d4aefc1167008a1a3cfb9abb41e97d8583452ebffecdbac4bebfed81a10b4e3f50765d57bf9ae5b97e0d2e502030f428e671ae2d0b96eaf3810ed8de933deb23352a6166913fdc007aae28de748e732801a6e5af59428afabc9f318e2d9d7cd68c8dab7560c793d2cbea84b0eb2d3a3b77cb124e664ebe6ed90a6cff2113f18ef0e99ec833122da7d2a2318f464835eee8452d458c953b7348b96ac2a0165f0b30826d10b908e133aa2e203f05511e92de2ef305aaaaffb026f52dff2663b2ec3e56a6de48fc1c6a8bfe56432672f308a175340947a8b7f4f9d753f0294fa1eca77299a8a67cd83965b3ab51a890a8733652421160adb2fe6cb160c5f16e2c913507a7fbdb38abafe24cbe5f576c71462bcc1381c9eb0213527f5e50b39c483d27c26e7b0a8c884bcc6f962dfc7e8460d490e0721dd7be59f7cf0f999ec8a5b7f5b7c3bce1b6e3264679ab6b6dd24b45d8211ef0c7bd4175eccbe81812ee17f04760fdf9eef452858d15e28fec82d46ac4ff139807b01042a26f94d336c09b50bbd855c1c7dacad146e4d0ce95bfbe7fa26dbf711dadd6275dd032834133a2be0f53266925441dedf19c9042ff392d8ca3f026b74cdfe877786ce2d8a7ee6d096d3b52d18adc542d55da4453cf4f529a7310a374d9814bd90441b9dc8b63ee05fb16ee990256b46171d1ead3898a14ad4f488e25533be0054b77e6f3112eefda16ceeffbbeff83d003b0f764134edd09eb316c0c3380810f0e1c7120f6f585b78b24c6cb8dd3c746ec7df228e046d5e37e3008d3ee05d9b090831ccf0db3c1ceefc3ada731f2520a1a55736c2b5f37b63865d3e90342b5409863efaa60247dd54773c83fef98ac1b8cb8c764a7cf7c2190253c9a687c764bde66839511697a23ce7ed2b5e159a6f01e14b51bb14d2c8120f64a246e1b17e70826db8b836f553b0a461745a7a6dac30c24e5d932efb25555230fff94306660b6c21e2f343e77934de5708216279463808c81fa366aa265389c278e69b777ab15a37351e7eedf406ce52a117993f083cdd57c3e33b22e1581a153994d3f2976956733ea98bfef37bc6bc2acf7d41711a1d251eba8eb1aea2fc48dc1f099b2004778bcf6ab0a802144b183eb3aaa0356316b03fefa35cd15abc9c990a8171c37358a5c1849dbdbec80be7aac1ec45ef194afc6fa9a8e8a2235abaa31124990447063f800de4c10e314086f4219adee299a764b246f3b782b7077a7ffec630ad79156b3f37aa2f56efb7b57b2b72071f2b9ba0acc041fe3a0aa5a6d19956669bab82eec543caccc1fbc26ca8d11bb73f933d32d6e7c7a7009acf211bf8883b90cbe259d0d83b0e705ee3110b8e1d8a1a0d1ecd17bfcf86bce400df4edda0f8ff4d213a812f42865b0a8a864cc13e3d909e1b0f1ddb1fc027afd0567fc54b71c847135a162574b098589113b8533a93daa70975289a10ce14f56251727c03675df548a67d7b29810cf053b5b7914843c9e7898491944e50caaecc954e06c2fe4d8dbd0fd2ee95d4aa1794df8b5b8f29143c7745790c546a8a9c312d316b5055f1a7258f294a5b4fa603138eb47c0d58e5b665e951d5b5dacc0d280e83cf6a58242e878a20915dd55374bc8f97683b142b896e5ce89661108c78af5e076247542451a81e1b0de85f5a5e3ea9b8f9e4eea1d23d925812f693f25507777adc054e0f532aaba872f46e5ff134b6bcda15d177eb3adc1b0aa5c17940353d668fbbd55d0bc151b0b0d19736d2bbb11ef02c719b42ecc7b60aa6341d886a6e5f53ef2493ec043d107a5e5e0b7b2e9678b5917494d5668cff48c60745c6399488b95379f66a45dc96ecceaf9bd7dc89783312067fbcfbe0f22bc4bdc0c978c763acf022328a28ee2ce9ad5b95f6ba99058909c661c5fbe0be14a62e8a4c448f068e6be902b869e89d41fe9ef4f85289bc9826855b068c503418b1c9071f21874548fba0880aa07d448bd7ab3acc4c784548f9ff79593bbee9351f7dfa93417eb8f77ed413fb3eaf3c61faf0a2a67bac5da027c040dca826abff9b5f879e22ac9feb61c9b68fbfe150f967498f8856143727c34cb736a29a63bd4bb1abb755c09ba1c33c2ecb7639aec6ad4e58eee8e97ab6d47cf1ee473220804e6d9b207e01cb01a71f8706f0883d2dfa0e34e1597bc9f24cf4135fe2bc03c5c677dd2ae980bea6f4a760ae1836cd3a33c403544042235c54f3bf64de0249d9a72b0a83d47c100192ad308028975452eca388c179a47590cf97378c6d452bb7f77e9b4ba7ffb31ef13e537b5c675e83e9fe4aba6837d2b3a3c65291b7ab45ff3ece936134cc3ac67f44af9f5cd9dca895356528fa38b0daef9b0b3a3008ed8833c5978fa27db734919e913c36b12c0948fc125a5b67c914fd57955625697d6d6147b2f5d194e481bc946efeabbad0423ba856ba1b753f224c05ec820a02e82431ae643f8cc9ebb6051e01be5b433630ca69d58c711776a64411820040b97f62f80bd2f46272d8f47bbc9268dc566991573ae50a9213072e4ea49360d8b786081957577b7c473c824f4077e8c1e611d7f1391537a9a7b1583879a37041f70e84d46f6cecff9df2232a492966e9a090eb5ed53c1958d816dc40492465ebd28cb687d019f0256f421777af0bfd606bfad9cda47b1c831fb35634fa3fdae0e96eb8486996cebd1bb12bce30806586f2a4204f5bda03ab9b87da61dd43e69c27775f5e9fd663ab6ccab783d39be963b5f79c15661cfe8b4a94b018ece7d2b3c7740221c2a713e80725f5cfb94c06863984d172d5c8ef246a08a0124af93ceae9fd2bd6ac7d14fcb23732bbbf143d62e322757cdba2b5ac84b36c725c4da5ee5ee4ecaa8e2ae16b00c3b2cc78d9160ce8128a33c3a166ead5694d10a9546a70a0ed3c474248182942b32ba1efd1eb8f777c5cac7303c909a6fc1628ca5e764f02e3e48e2570f3f498e6a9d9a30d8e8a9962a6ecd9f802c0a175ea5f67f6cba5913c5e9af9b1ccd436a14cd3ba2fb63ce2301abff48895fd0eed142ad0e2a78b7217a520920bbce62d8d8cc7dd9da0cd12900581f67485bc9a5352c8255422064dc53151444ecb02746fa845dddb257b6615b3568ae73cbd9e53cb3bd32eb9bfdddde159923a383e680ecd2bc649edbdf9000346f1eb11b058747a6bd2dc11c74f1c2a4e158da879d1da4498a5f2670aba369ff020ff415f857ea28449315aa0e0284a95eae5cd328e05374e950809c9d1d3e4eeffa6ba52bff30ba75a85bb90a81aaaf4bf84a52f61ad811008bfe471159caa664a5e40e752d8fc2f882ab3a36aa7d57d2dc33dd23cc15d0a6132e684b8754efb15d0332021add13a895c1bac8fdb64192e8f6e1324fe7b643aaee9c8066ed6f5a36b90b9f5f03e0b948ba4d64433d08ebb98d8166b782c2fa497230a1e2925a7bedc10f0f1fac0e16c066ab3c891863007c4f7cd8950f725066bf8773f6bb526fb09e7f0b9051936badf7b303d2761f84289aac5095956c58a8267d36c28a5b86760ba5ba7dd64c778d0ce4492d663b599569810f9c9c51a8befcd13b89b0e596efcc5f236908376826413c91781bbf4a73a1b8b174b8372f47ce846b8a95a38a7c77a0ae36e91017fd36367888d3a2ad58cc61e5f601274bfee798965ac87ba7c36b793a5086cadd58aa74ffcc2a468085f0b2b3e1b06bfd057cc1e8c3d4bdcd974db557d7184d2bda222103b26e6851b94a0d042eef129e623b1ea8ff276d406c73419949411a752c8e53105bb38fc46e4b6d8cb9f9bbf806b5779682e2005ef2d906623d86953559370f813dc4c4e727fecd76b1ef4081fe8e92db9f3d37cb86dcafc440cb258a7eb66f57fd8382caaae65577fd5a6d6ad7f1db5862abf9308a29e3960f4af7f35c57fd227436708ea3915da54029cf265dfb8e397ab46c667c5964ab49427384a2ac48194ddab119b42a03db4793e1b1289d7d171cf7aedde5e54be7cc5608d15cdfa8a6afa244df1219c2a40eab9726fd343578a5304af1e5a494ceb5dd58ec27f18869484cc26a4058301155bfb3f98f73ad508024544dc1532993071f698422273a72e48c484d6de589509f51f51069785d1e86066e8d4df49d3ec464508408b0b1b99179b7f39afa4ba9927609f2ec64748148063dae0d849eb4cbd7b99a69c958d3a1278a1625766d8dd3a17ee018f3ffd994476568454bdee5d8b7c7afedc27271857684f230d747b4a8ce7b0bf6fdb2a030b2933d9395b475dc68eb49f7535abead52c8b27e42ffeab8a3d65f64d21923780d48474df69d179b2a71cc91dd92486c89af2d143619e8eda90af3225872169e1c783a4d77a0a1ea990a28b17323560bc0242a28ce6f502c39758db734db4e8149efb0391c379bccb7a7d3d36c5ce316d1fcecb45ad4130a82d2188eab0a9dc47b1d513aa6d14966aedda999097b7e5bd578678887445a4b4375e2d05059fb6bfee416773e61b4ccb1c8f85a1c4d0bbe90271d5bb1fb833a3d3f8d34941d5bd288eb84d140b73bd78c239d6320e29f721b25f76058b1939a60321a1b7e7f442a951b2e74ad6029af255be791c7d0acf42f0c4e1d0d2e3f45dcf2be4d9bba7c5554befa82b07481823d59ea9db80f0b72ff0d2711fa4d2487e1baa150e73487cd9db7dbba038e78533f85b29e4639d3d79a39caa0eb1006e47852284b97b2ef9f6570ce5b058c030061af44b2efa0d31da2ae7ca38ca85ef91f043bd6f1fcc7a60f022d5c26f78d24abad792926dd7b4f3bfb783d34e1f401107aa8c548383ac8031c4f96b2c55e25d17f3cdde121912fe1b8be12a487e605e9e18d38e6d64b1a08ba446a805fdab9ec725b41b10537a1cf2c3ce35bfb8bd7e590955abe61f89e25e9ef0ba7034679ef077e5dcabfb53860aec264be100dbe25840153fbc5bbab1b6ae60bbd12481ded3df3df7c5d07a0c83b866017a73d38eb68e5909988e187f480d6c29631d142c58af2b531f50b209f06c27eef0ebcc52fe202751d96b67ad8e69575a40e711a974e37bea11cb44e39a1217c06b840c3b809d5c179b380fc40ca49dd7e0eb003a33264dbaa9d34bc1cfc690fdf9c199b631876b14683f80d757b1b29b3ef107e13e22da2930330d59f61e197f3db8cd4deb8046c7b55512237faa96d5acfc1c4ed589a5cc4539065d914ded43e0615b24ac05a538d23c16933f2f9ecd190c51e90d6ab9a4ce646768b7ffbb5ffafcd60d0156006ee18fbbbf4cfb82a8d67902576a0029b3418a73037ce68cb9dabdf11308f058495e252071f52e259550ffb672fc82d6b60059cacf2595ff4c302035c1bfa4b06fa422149ed606cdaf773519a36bd10e7ea2b80782871520335ca0aaac3af004a15b2adf30979ac23e7219337e8ba6d99d86718e3307c93671030ab8483a143302ebd990ce6cf54754880c92d08d66ddc2923537dcc9bc042a53aa5d14cdd3fdf7275b8786441ba5b8cf8cc729f1bbbf3aa9f82f5f93d2f04d79fd8eb8c15d2048dbf59a8e901c156d61079523c801b67c0f90d4ac1b37099842f7edbedaaa32738a7f739afb7adc14ac1e1d8055e254a2b79faab8f898f7d03301057b16e0f60e8fe395d28420e406cbe6500cbfe2268ad44093aef87752188cd4f31bd233b40e7e593a05da8ed271c2d35954658b09887a9c3634d3b30f99c32088f662ab1d8399b0f1291ceef898c475e58132327ad70dcfd3f492f928372222141d3e8fa87799c6a46c4da7713a8105fd785a3cb8de2ae2e64762df7107eb3e14246221579d98114d07df9eb38adef7770e64b143b847dccfe71563b90d22704490753f2ebfec73a7a878ba523661a3c559fd3cef8894f33d587d1f877cfebdcd483efa3940ababde72d3ef7107f9b776c3af4ab12876a986b22fea500e77b47ba1721152e020c34ecba2bc2848ce5ed276afe1f0122bce60ee8fcfe9a5e0b2629161c2281c11bfd3de6c29c6e9d179a230e275ae5dece7ee7a9108aef30fe0a307b3b184a0185a126f38520462c4ba5f89c11259a160a2579c5c492635232a0f3d083775007ce97a15f4343c1dd65183ca4616ce40d383c56a7127add8b76ad97abd481d2df3538d1a945fcfc5c37a9676f7353938c2c46d94a789e5eecf6e51d6e5ee4cf88037f152dc77337c4ff98fdaf53ccf91b675eb1714a3be10c50f59790381fe5b746d934e3028219e235a474298782e8bc38e0cec2c4aa7057400fbb6b5021f6040c32327c4e8b693f26ee657fb4062eac1b44afb2bbc35683f9e804db095a2d5820888a7026518d71fbcb5a96f642dff68de090003b714c09225ce03eacc281784c859f3ec4252371072d84d3136c22d8e75710525c99dda8213597f108c879ab8f9a6d1bd8ee90eb68bf2e5d396c82bbf57221b06dd0c96cdad354f432cb7d9993b813d88c5954ea700cc67b2e73828ba297a068fdc6c9d9365eace25b9bf6fa22bea43068735c33a81b835073839449b8a5b13b12eb8f0838c21d8c6f73fdd34ba66eaa4f104f5b3e2ec1fdaaad8fc0f17a6ac958595973a179c59f8a14523056a0e3d74d4f47c04fbab5bc8609672b19ec66d45e492cd655850485ddfbc2b310b1e7deacc8f90217b3bff92d385aa7d7ae89f23790b92d90b4625786794a8de4cc6ee05522bd830f931e2e702b0cdf14bd91096398443ccc67590dd38421097090166b57ed5011913b0a55754be313839612b6838fca412c83224cead53380573d2e18e47178e0de1d30dd8f1693b304fcc3a1c29a1faf3e7c1894abcdae17f71e1865f88984afa2f9200f9bb59f806e6094da34ce95d8da61ba6267847c8f3e9513231f0ef18c5b12072b7d4e17c43a3a6c4ddbff755e360080e56d23dddabd418edf0c5958ae53727dbae250baac26dc8cc3aadd1849b60294aa160fd567bb8459913722c56da137a3a7bc5a00fde44ca1aaeb4408c900a8c68d908750d236588134f2e8e4caef832d93149a0435be907c04748c2a0c88d8565d0deba2eec804f9f35d45f4944ab204e7c5a1ba4412a6a73d302d1c6236159250b465972e79c707c9eb820b56c554bf085a868e75f655a85f9086e4f7bb205ab438059cc7ff4a24129b4e71d1be198c21471cd2c2ed738d715021efb24bde722e3f83d9295e0e4de15566216e3893a251290a7a6841ac7778130454418126064be80466f0916dbda2df01879a49815b7bef0b29861f368493d39047e3182836307734cfa615688987bbef3d4911eac8aaa8c0ecf379fabab7e7dfbc32950a0092179656ea2a81432226bb9a0ab40c52a7e9eb0236065e2095c273de3c2f90ea3d572df9115c9772e58da23e25064ad8a4bc3fa875e4ea97da819b9102c34149fe1cb0377b18b0a3ddcf064a2fef3615536aea05af6ef4c906028a82335c466611d22ae98dc229806125b66aa81b55ed9b4f36e9f4918a10cbdf30a2676936d13b363d3941876c7283457b2ed07b7698d9e7abbc4528474f5f3a0fd846f7ab3dd9fcfa5e1016927b3ae801a407f8e5212467c48462ab75aaf2dd72fdcc62d780a7d3280e481763b1b6c3b8a00bd274b3feeb3f87c99d87f99ff0c59211f5188b58dc35898a86c005227284ccbd2e7e7d4ac7e2386e8dcfa7462b06f32ff432c6a4482e0a49f88000d01fa7fb7abb5c54406cdb6d4c894550b7ededdad4d8564b7c5f810cd3a25104d56016597096cc422e964714b91e0f8e9cdccea6406c4754fbddcf8fc39b8eac5bf8a3c1cec583103b4cf6fe52eacc49f074943a5137330c2a8e969d796a3c0aa10bfad454bb627dd26be47438637359e6bb607fd6bc5f5c0718e6647bd66eb3a38406155df952e17efa92749212aef0b139643ef6757cfd4c46d1621158174b9035211fd6218517f1d5b490775e6d0a1264dd7c2c7a1479e73e39b4219fc75749dc12c5e9adce366886cd47d323db7663927028f279f02dcee422c2d3f71dd187f900bf187ccf6d0fe069d2388e98cd71b9d07ff7f22014bf7e82c7e91db4fcd67bb2b2247dc21cc26bf9913b510b0f2cde943ea5a4b20ddf18b873dd30c58461704ce2679960f792c011e73f9f3c8c3bfe39ca5371615b7fdffa517d2bef5f077b0768af727f3bddc90518becf9d9ac09f47b9c7a046b6584f24624a0bd107911e46adeefb9509a2928ca5f07a6e52ecf2ab518a7ea20292aa180af801a1db3feaf8fe38ed267dbf1ade50859546c672d967d96b7b1e99f025d7823304392f366a4c5bfe3219b56c542b8330ef62a90cf0d0a1fa9f21a0cf9d82fa96ea01a3a88851160e92576d38af0cf94e9986970b633de1e5eb71060443cb752a64f1641028d5629ff7dce7af964ff7a047a8573af222a9cb9ba58a87b671e5b400a7b2757ffb0d3151130867a4048100cedba3f1118cb60e6bd133e5d216e356fb89a63dd7a590b9ec0071cf4e042a0783cd080639a72b8cd2bba79d739b1a0c56d460ea73b757254708b33551223d3e4b0e39856b7a1d75fe9dd3cc221d0044544166d51e0b94a55c10b3d38ca603b8837add7276c53eb49d3c76d58864fe12ad0141ce05fab786d1673d209996b5b1940f6ef04f88d0a35b12bd40226e1f3cfff721b9332f75132543fe5fe186a1927f8ac040481d0992e63616c68e48449c628e53418023165f027fd38d0c45f63a02331a866176bcadad80f11eb34bab177cf1b7d5f87aac58b165013c8d8abc2d0809c308ee644863317d8afda436715b0e130a1b7c8461c9b413fa1aedbaa375c3b737f57bbe02b573d02f50af1e98593edc112637decd810fd76fa5cc1a18afd261a10c01cad6122ab49133bca718fc34b7017c5550c7116b2fa2689891eb8c4ad7b21419c9ed12047c29b658b30a14ee3f79f51f3e8155b5d76067027cd5ea9d132305f0aa6a5bfad87d866bb900ee0ed0870b9bcff93b9c334b5a3b8fd168e224b9c9668cd8025b471aa05378ac1454f2cc5b9e9bfd31409e496bbf2447f7bad8aaf7d2962871c4354992b0406816af0b5d1f2f3238a10cb6e5dbb317119dbb2b6b15ffee27830ad445785bf18b40cb2037f63b67b95aceefa7aa8c1a8bee6c2403e23c1456b79d3a4cb0e8f525cdf06fe57811c1e72f8ae3cf594e7beb2e8a866bc6adc1f103de4c650e2672e5c32af320d3ccff9b448042e06e263bcab2caed1390e12576fc3fe6aaab84706f0b178f2e5f90167f9b8a3b495c90ecb0d4f7fef2dd8cb828cb3b5c0c025789a851666004ddb061e841baa4612e7e2e444ce4e4a19de90c96b723c54f3e5972b8b0af5824eb7ac387f1fd1e35a45215d5f04d6351fa394323d1957e4faab0211449b8bd3f7bd762f323f5c6c48bffe1195160d2695eab24c0c85760e9dae893cee06b497a449642213e24f32765edf3bb5be0146b71ced3b3158087ab78d2eaa361f27deebca5f5b2a040e96cc109125ad74589e30ba2c196601df80f4334244862ea06fd75b106cc89f50c366e25667020942ddab54b46aedfc2169162895e9e5b1e6ca33963d63fa64b4646b3e14651d1adeafcbbec41520234580dfa0768bdddae76b574cc95dd69465aecb1e7f1aa52dbe9f89450aa4e4f30a3e2c592e28d5c507c7153eeffe88fd09a441f1dfbfd595289f8a687f709c00f3c6da5a059ed1aa4ae94e6658547ede82d266146eea6ba71314010c75b4aef8a26096a88f5ecf750d9ae8d0bbb7b3c970dbc9dc0f7582e7096da980ef44cce2f692df0aa1a4c12e168eb79ef07ba997fd129d0453309941cd1208b41dfe69069ea7a9f480367dbb79feb617952c36724f989d133b45ca6a2f13ff2e07b8aa136a9d4d8950c20b606659b594d0dd7e6fb0e894d32b9988ae9978b6a9cf3e5d9b470eaf04aa8b54ca14f2ae26cc1e1a18be6e4db918a49cad56039257229b900a3a20b5650c19542f8ce9aa77642278999e16bed64cfa4852a3bb670aa74123a8fd18a2af4b4213defc61cc5086a7d6f780a5195176b8199f5b5eb6b2d8421e14d5322dd5387743ef47285a482c7bb776ee851f1e4654baeb0270a88aa1d8293fb47f0657a2622c7f7a2901fb51d30cbcf3ea89f0ce97b5f9d67941d726dbd57d06b69897a06ea23674912cc03b6e0bedf3cf787718b3b58f92a458ecab639db9770d6a49aadfeacc66b716beb23d8a1320d9677154a13bb00a84bdaaa61aa2b5e618a94bfee302365079e08d581bbb91351d8a31145a097ee38b589f354c818a3347aaaf7ddac68f4d27011aad365e574a8661f07bb6e647da72667cf82187b33fd2320984c057d76bc0a0dcaf978aaeecf7c8e5576ee0848a112e92bd851c436f90d6c2f952c4ff05673e86fd62cbc8d60b5fbe78354b3127690ac6d706eb3f8c61f1ee0e316271fb5443b1c1d652737b60fe07218c6fc7ff6c3600b2b55604b49efbdac13c079908629d392e602e72b8000706663667280b747d6478e825c41f90ff49424ed8bf157ce897d8168064a9d942dbf920f88869d991fced2fc03918cdbe2fe71aafdbbf45631a1a736536f56d15683f017f200d815342970dbb03f683f0311064f5ab5a89fa490ab1849815213c496ba9b961bef2c877277236a4a5021765d46a644aae918c600a4337afbe30d313a1e2c982b4473154d16e6a2c577d889ffdb6b081773ff11cc0a6e7fa8baaf14e36a3d4a7d5127ae3a1941b584090bc55886ee0310119f5af43205f683c63ea66536bfce513e860a8c6c23b9df7281a2c7d6eb212ebaa10f1b1200f5e6372b6db603ee69b34db5f46c402a8cc3799b609218bf75417b02c674e311363d2a65cba031f3777d06d8cf0435d789076f3ea35fe8fe76605091143579ba4c0fc18a9e518fbb7296391e7be4cb738f5cf7779b7859537daaf343402807f0ee61d78652586a2c28b77f3639bbe868231c76037bd08c540d23842565513f50555316a7ff0253bc9a4e2003b7b504c929d06307f708e8b160239eece0d8266ab0993aab4ae6f4ff8bf0cbf63e647d643d6db58923fc9375b9b80389d3d1e15757898c8552de01ab18ccd4e0c4ea9bf1504b16e1d39fea4775699fc9331d4f6a6ea8aaed23e148b41a000792355a42a5a7fc7aeaba205e93800001028c089cd41e45f85786db856894d92980abd892b00d7d82ccdb5a66322f2d2e713f528d335270801f8ce115157b2ab2019a610a58acec04c7f81b8660d0bb2675158943b4c9c895342ccaf0e696208566dfaf6011caba0b691fb4bb025b5bc4d2c624ebfa572d33052b0bea01068296c417c31842104498d6f6e3829fe5f37e5799fdc54bf1655e15c1af40a54588a2813c54a8538b5b362995a1140a45b760c49f5e167e2f26e11eed377d5448a389465e2f49a61667076624de09a23a21aef4733d66ecd05b0e53e7f046da2899a1f778c9bafedae043ba8f00585d52104c8233751353fccc197c6f47b47155d911024da59ad3a22c9e4e01787d7c4c5ae3aa60423afbba2645e453d7bbc402dee8edf57d80ca97629ee1716f47b55558cb62350b65b8aff4569dca6eb62283fad2e7b67c6ed59a9ef68c0927fc9b3bc12bcc39c9066908d118f96d9adb7df003301ec7999dedd2bc5fe03863be244458105349f32bd9b5455ec755e212ebe359e634636c19abd4eb599fa4f7b25255b9e8e48b3ed78e5f8fcf4c5f92f1efb901cf4568f501ad130673c223326d567ca01dacd74cc666489498a505f1915282cc18ca0f00a80c4b8226b729765273030ff44e41e4fd5fe452aec1726bbf33d59953e71b0a53a4a440553ecaae1b9f74e849ce219a8d44f2a3b63ec328569a7cc2434f1fed064afae850641973b91dce9e578846fa7e87a451a9b268b755ff10c7efaaba6e90775ab29e4e86ec191219c9bdf4b86dbd3502cbcba7669c7177e898689ba210f0abde9dbbf70e78d882c6dbd706cb284d483a70ab9553d54ba8b4f831f601f3ddc0d4aae2d4a98e82d757e9f1c9311bcc179443eceb4df5ff73a3df5f89cfe96dc8f328d2d64f669d7f55c2acee19c353cdb5fbcb540e3e8acfe4dd51d7b57e5a306522b92cd588ac3f9b77c546c55eddb2fa5c0804e1099ad72723fda7cdd6679fb8df830a31824514bdffa37fb33977f9dca6bdbb1d6c482a4f0372594593840387fffb5454d67002d1917de5f658c1fe23a7bb9cc1258009e99915b708c42624c9bbe06b53998be401ded6b7569b8252e1f9d5157f5c1bbfe60447a670a4f3bb93101ec8dae1213a164a162fac455c5f0b98964e5907b854883e8c8edca82f4d6276221f661cc2298ec84ca76f135700ab6ae852685a2dca810f71aba39a81d287ce8171a911a8478870c4cb267ef6e2bb285747d4cce11f2835c7f5498e87eafbfcb718375bb85b16c32bb5e329997226cbfc1402a824d31b65872206d4a448efada3e6a95668175228f8c17c74ed231a6e82cde27be2424b85f5f0e1039dd90212e079dba1d230230626eb5d11f2d8b0a70237e1bc3a208d92eec52237fecab1ab3a13dddd2e2f04f64992a6282740d30a1f1b8adc9e67b9d427a579bf12a81dd34823dbc95a15146040f64d7b02ce20067842c86f4d0dcd3e88ab6effd41d03abfef5e2313711c83e44f93925053f2ee61609d25b65614702c1bcaabe1d1114433f34f3877f5cb971fa1679be8110093d1f57de7cf382052131d3e67509045f8c4a7bc6ab599c68ab6bd6ea09fff61c6b0bef8bdcb7c91d422adde3732296f856da71dd074f5c46e51024f6a6a367cb3273e6e4feb140d14ba589edf559d6644dead466ac817c7ee641c7f66ce0308a91a8a4a6838a2b15ca1956bb618559790484363eb07205c06ce4cc346bb97d3d1a9155435fb91ff099df71eb87bbbbf9c48d700c8013e88d0545bf5f043236f6785d7fc1ddf53ceed585d2163be9133b25a410c19b77ff1238d2b7e3d0f8bb0a4acbe2bd9d3da45f7ca43f02015409593284b23a377a49773f90b466f466dee48192b26c3f9867b56970c7800b95f7cc4032cdd5205502f12ede55e2898ad2b1691ea19d0dd4802a639f9d78c3f5b9dc4ef2086254da4d4bf6343d1ae55fea12e5462f33a4bec3cf5fc2964fe2405dee12590212eec8e4fab0691e2434a14ca6fa1748f02d3cf760b786d267f439d9e013623879e3eefb1c8dfc758d06fe4bd3053029981527248527f86b54368faad2d1309f5abd245f2e5a6fd00bfb4be39d4a5dbd286808f6590b8214cced6a6bba50466397f1b4588e09794392bc0a05d6b52468aa00b4af7def01b3bedc317559e1698dd5a2a66989021a423bda36df3b3126ff747674dd2171fddf589f45b6e686ca850f2975c7421c8a1f42302d49cc7e024307ec227bf7569c03085e119eb49fcef47d69bdf3c271c829320b7d878cf8dd540243b9c663144b78b2720e6b847c68fa3799d7a26a1596a395535126e82d951dba86760fa8b31a6fc1c42190dce7dc993fa55e665934040ac0025fd3496e7c6271adc7d52138b183ea63d113cafb89cc0624714a7b7e3a67a81f8e47035170d49230008475d2300bd83c3ee4c7213f3ddd5c08b99ccc24a76f1b402812858faff2f5967577a53db0902c583278e84a9c4177c63d1a276fda2eab809f930c9337df3e6101c4d49efb8d48fec9f10906f3df694d3eee73e8e6d3340cf42c04cea94cbbbeb2b84f0c4a69323c7be5d5ed0c25131b418189d640e0431c1dbb0bc89a84a2e5320e3098d3d91aad2e2aafd31b4ea9425dd2849077713fb462c4c548c6977c571dc86e893c1038dd28042cf6594fe86cce49b23faa44343b6f44dc6de5d43f689741cfd9ccb0a5d053646b464799ed4cd2db945b1b6436290c1eaf1801deba51b752e94d8fa51a93c4aab668ec0b5eb8a87d5c174f1e4feb45f01a8fde10142f4cdfbec8ebf942fa5906da566c4b308a1db1ea86cc844859ca7dc195ba9ed0f8f7ee60520ef522121347322ee2403461fab2cde769142e520ca715c566ccc9364827f4eb393d100b4b547641ba3a19cadfc42d7b17fec9dc8de54dffdfa3bf6ba4b364792b6e8a47e1218536efe277fed0680170d5d92ea3ac7d9f451cfb4b55a1555edc9b08c63ef3dd493f88c7dedaca5b97b9f5d9546dbfc0da0b064993815b0d90373f2d80e3865f1a457e6bcffff0b1a4b6f84fbd3c00ae3704534299c721c4315ef4ad6a82cce81fbab2bb9200669efd44e685779580a193d68424597c5a541e761b24b8a878382913845e360b54b8156cdb759f0a4d84d40fd7f6a7d7b106473c744f4bdd3b99bbf1075774bb510eef7e2d723b4247ca01dcc68cd063bccb3ec03dca1912708b62a8a54bea3223d5b3d5c60837bf154b5ef3bee0ab4ba2fdfd49817f4890e4a68a71a42d0e3a3973e04af3c284d440b77e4b97664d467365eaa830baad17eb3b260b6d6b3aba7614a7362d02a8e7d1bd314c5b9695fd452d4b47c90b811e85c516dc45b009b22e15d09462bd041f54418207c93ed72aec7294c223dec365ad63229d60553b6aa82dea40f8d5eb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>High School Memory</title>
      <link href="/2020/03/17/High%20School%20Memory/"/>
      <url>/2020/03/17/High%20School%20Memory/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="23d57a104ff6c96500b42878b8e3af98be9fb058ccf38dc368116463f2725c69">c172f4ee74b2b6d246b20cbfdc0b877e2b129380ee78f2cb7ea1ab5639df61da4146bad64171f2ae5719bd4430d696cac8d02f075e6529231acb2eef6ce149e4096d7ee9754dd490480ddf2723bc554c931ff51315ab047dcba5bdbc30c7ba615665a6caf019c69407eeca97e2d991948e4954810fb7015c1c52a3aa603618f8226b4dc6035408b60606b81f860561da1240f1f934d362cd000a34917a96761690932545ac908da1996787d364855773622d3112760cb2c7be71df88141dcf2913a8b889332f6b2081a320739cd6bcb37b9f7cc029a6ccfc276b2b7b13f6fd92c1af3a890f01cf430a4fd341c9e8b9bbe6dffe1f21c424a3bede5ab9abe5970c82c6ed21369f8f225b79f11f44df30f11ee5c94ee944928d3c147bcee847111737c539706fb7d5fce8896a49b601fe4237f9b7035e3ab66f29d7e684e206eaaa59e87f05eb61c5d3a43dc0fa2b9dc99947a330bab007f1aa7e8ef8f4c51b95a791f82cae32912cb26505e0f25c2edc151bbfafc6cb4e18f25a4fc8e26aa993ab932c3fe69a5b6fe3fd6b3f20767372bbd1de02d382f2023ceb23e1cab4b65fe4bea7ec935a0fff4196b0dc16b234e54751d67ddfb37d7430246b29e0fb223bfe89901cfc56c80fa034425aaefdbfd402779e31af9d6d8113be0cb9137d59c728efcef1e37c042d4e74bc9dcd9cfd13f52f07f777af2c952965a7c7ee61bb14e1abdd9851d51118bb6b082a2d66d9fb969e3d1302d092aa6a764eeee78937d5c890eaaa62b0e601c7420b20315f54b2945b8777741d2a40117dbe937b17f97ff64592b0384fdadb766c67b878fae2482843e1e59d565740867855ef9413fd2a2b8f6ed33bdcc0c4405338a69e3c49a13a8e8182b3d045d630a6a4b4f88bc92845cc5d1baef46a8d790b793661e223c69043b0bc241081084780430a66789d64c8190d63458271633b9247e571a0c4b70cba725a685c33797f968e5f6e519daf1d8b9fba20ec501d3831248168b219be10bdc23a0a12e6b4ec2460df532dcc82aeb2568454a761ba6f0c3d57f79af6887a15af306923ea4316f783c043c0065c5ec20f1d2f12390ea790e014df79599df934f76441d96536ddfaaf86e0d58bc46a4051e391d321bdcef918472d0fd4513b17ed1ab44c55aa9a54f2538b7d25fc832aa7887ba8a667fc63ef3f0c592cd6994b0f8fa04fb3132d01f101b82f5e7b94a512107e9f277dbef4f4856c32d07c71bab388319fcb32cd1cc5757161725290f2aecd0156f00534567e1eb6c0910a35e6b67b5347d3b0fa6d154c6ffff2267249053af3f454075adeeb4e3c66ef81e9dd5cd2349b706100230e486917c943373a424eb462fe4a43708c78021baaf3504b66c35e1037f68b4faf112b7ec50d4af5cc56d7667302dfe19152394d9ae32c48ac6d774403a8c06d17a2ef2efef2803fc14e22fddb729282e18de3635dd8d122b5dd7370464c0a131311d15476eba43c711ebfac636fa90940e45dce6dc2faef331ed743d2b0435aba4d97afe356497ab919773af0f64f6888b633569b6d93622dfbed7f24057adfb8634a56e59546e242b9901e3e9e0ef17f1f5c784620c31669a5de02647d9da7df31a19262ae64a05d8dbedb8a42e37b79e935da0d4ab3d2293e00fb630935c6883f68dd3b009c2a251429bbce1b223a7404802de75115ad7812532c6450d24c028abd24bceff5084696e23bc432ace7c6d862f99d9f26e5157dc69f829ea6d876d2b72b461952dd1a15712fbf49e2cadc00f9fea42cca0a070c4ae76f73e1bbe9ff466be20d377eb78625263a32abf5a94bb86d3075a3d2dadcbe9645ecb79363e702ad510f91198d9f48d1e4846e5e63e2c69a08d2a7a72a27aa118cae6e7ee847cadd0ca2aa5262ef2ead8dbe658c0bd5bb6e194eaa27a05e01b0c23bdc1d277a480309e54fa3543bce5d14fc5ff6b4666b2403b4266fd8bf3c5af369d764cac3a3b04e0fdfcd97702352567186f58dba5203cccd506bed4ec09e8ba330c6a9b0aaa388fe7a116a2800716e4e73401a3cdb594465ff13c6e5cbad3d9eca1b64b659cdb5161afff65c926aeda193c355917062320773d32f613a37ac47ff0c71041e821b750633d45be62cb1fea5e0b54c16048a890adebc9c11d73c499e11e5805714d31949608f05924ec26d98d15ff4dfb95687c739b93d0db88353a9a45da8db0039aef657e03a611435f8085566f8fc341209b7cb99dab6b501bdbb0776f7c4da68e2b099818fac0d454c1084cd94e54495de7da4d43a8a139d3df83bfa8b9f1bc5b2f40d41681a3e9eea6ee7b1c94a55d896228164ddd2100dd546294bbad2d20093c4bd4e6b8af1fcdf41a2c642d4570328aecb14619b3f2a67b28e5611bc7951fa36ff9747f281c7488dbc4eef3a9b0cd5e7127208fdab40fcd78546afd7dae172eb5c3bc9d433b2f70de8a322680c95ff9fa0f7da6bb3daa9dab62b1418f24780a950012088941bf8c2690fc3c34b07309628ea0333b018694ff2f7845a0de64096dbb805dd42215c75353c618482fd11a3bfc2efbd7d2fe209a1822ff0053ccd0abd097208141ceaed4a57857445e60486e0d967577ddc335b042057b4a11a4349b73269e6f8f0955346d24b91bc639cc1fbc688bc4bc8a4630574308ed4be6c54399a5c810f397155419de441d7c2f8d1c18ee199b46ffe58b1075e170600f54292f304c426b091326eedad3f617f8a9d32e28c2085ea77f2a2f5b5e7aa8b32ae7f1827fa509788424740462075acc918cf0fe687d4cbd55411bc1065c2edcd6b597b5427fb68008e295cfce4e27dc2b77aaea127a90a04b870cb1f23fcb7da6068bd76582c7f0a1e10d70d88f30c12d5f6beffb06563b30d8eb0589e9721eda8277aa26013359cfc4619a9d4752bb77f8726f3552a4736ce84170398398d3bbf1ca38052a0e944a7553681087520ca487a4719642805c5ac071d562601a083af5129b76d5083abd66d26d4418935c3060598491d60050c9f3bd59052d8cacdca71dce99f519648866953db7a884dbb032a19bce576425cb47d44921fa5b6cb7094e2e8dde0aecde43f545d45d9e420d4a135305b45015e66b7a6baa8afa404edc00f9ad53fe4033e7bd406739ab5b9f6a2168bf33a2999e0be7d67459623e3e0d959cd17ea6688941698ec818397aa1d62006a3a57a8a7be49e55da8389503efd77b679620a10f4f4b8f526f2bcf1227248a2d058a7075f47a8bf4b3ce87de3ceba2bc41003b7c86d893c6b66eb29e7b49773f93392ba983d24cf32fd6a6cdc080bc3c25a7b6fd1034484db710fe4a95505a389597185cc4d9785df00ab3ee7179af23a5b3034741b013b2d33ebde6694ea50cb189df6f4e2604d1936c6d4eccc64cb5d621bfb4e2771525176a8979612b9cdfd4e54fe97e31ae32b66ea5aae945db2ff41b8083cf2b69a3f77c23fd58af3def2bfbaa1bf03867b8739e8b9db0b7c97972bd5987b36b383c0e84be28265048e2cf90f4a6346a0b14349c2b656a5360a70f89ec3377c45d1e02285765af3951c6a9690646359e27d4a504578590866f06d9fa1e49fc1fe2b32f9cdc4271eb8e724e7fe3ae0c05201bdc72dcbd9a75d96adaac76258fb39e9a7dacba06afdb98ef8666f83e727ac04c31e036b4a41c9b7fde84b576b10580d7a5498093c9934aae2a06474f5fd86244312d06ed5bfbb06d5e15511b99416c0ada3aebde4bc256339395a260e76864b4d1372ff4ae51373f5a1a359c5091abfb2cfa660993507be5309e9b3c6fd0089e73812cebeb958731c142408924b4f555ab4ca3ac09dcd9508f12a69f478b5f07ea85cbd38f77141260cdb9bf3f0b944e5c5bb0910a502b817df845f4545fece909193b1e8a032ea5149d217fcf6b4da4ef811e1c6c6b6777f6dac66347dc87615f99d1e2d9cb59fad8ace219fc4dbc1c5a25f3be318b88f03beafd38ba46c5c41a9fc10f6e6d65b7eb99803ba56b5470dc297c034ea025d22c05596494b3dab7adfb1be980b181acf0fcc7bb378f08085322ffe638cce604842968cf742a12b6e4ac36082e6c6dfbec509953906adbd94cd6c4cd411d3599b8a3c654fcde15af85122d0786abc18136afa781abeca9fd406ad8c4cc627e413b5c7648966bcc6a106caf130df92eb4ef6ea25f6725ce8e970565944fcaa6299be3680fbbe4c1de371ad77971edc3d821593828c0a35eceb6afff80719e824a33076e3ced014354a492a243031eacfd01fb8002b51ec64a760623e588642e305cc4a89ac7a4db6ae78c6d93d3e461f4962e87924a482c5dc5c2163738a7e1837c1b126e5689989736c5cd6aa28fa2d606d33007f4b4f0830849ff77ea830da0b15716024e045915bfa0a50368ebe937d5fdc426f288228b55cce3110ccd6c6afb7bf831ae407c0382462795ebc023b21bd01838f308a52548c7b93ce08a4c42dfe4f12f09b91b2cf5dd0e6f277e67d9ba14dac93949dd5430f58dea5e8a1d40412ceebc377ce82fca9129b721541f8c883044e2287d04c0382e8b541217e70f65a663d3292cd6dc73bfc6a94c41e91c758d256b259d30f9d97ec0f173ed8374eed57d68e8b6dfd886501248768702ad2c72f9e9a703fd48e481ab56e3ff7030cdcb99337cdb86da4c1cb59a6b3cf1b11f9d042ef3087836902561692971cd24d1ab0338ed0f170a2f71c505a06d6d1ceb0b87635384c73ca4ac526e79510ca03e5cfa4c47e91b8075cbddc01c55d5dcd3728a1d2a2e7a8d5931edf52bef74eaf49468f538e2dddc7280814ac5f1066bc82018b3f64ae93af53dd2f03e0ec449d6ac0532a8aefd97591f763af1269bd3b3a186b424174502ccf913cd6082436655249c25c02ac510d5e923a88aaac196339599c80ecb0c7de99878fa56ff56066b53d8b2676a2b0b5780799375fe28ce97d34efa7c15ff1691c97665854a2a210c6cfcd200d8b81b09c6f4b854e5a524f7d3d61136b3d8987f6aa760bdfc7d701289d7d9143a1e6e7e54235fbc04c8d99c7349c8dfc072cd76037b3c4205571d094ba4140a44ab1c979078cede572c6c8c8b12409d2f97ba87851c2db6758a1b404307739e9c228923a5883bb2767e481ee4709ed696b209d9a73f0ed09748fd55f2dfb1c245afdaa120e2500422564eb27989c92bc525f774371de40fc655ffad3d41ab42476c549b853233a570c8749eafdb22de89b75dffb69c29b6759d886180316bfdc6de4404b932fcccce78f86d11d187ddc496752643f5b16e8795ce00046edfbe0bb19907611b2de70e61642020ba9427dea41a130402a9b39efc7b7ff2649289fc6d62bdcac528fa0556066465a8105182e69cf8083494f07aff8fa8d5e355850c5efccaaf9b4b48a78a3658401c379a59b7bc35bd666b4ff13d1f7f6145bbb0290cc09cc6558867f25a08253c1d162e90018129f95fa5f0afcbced598747a21a4190607561aa8da34569f50c4c5bcc5df8f689f896912532e8e073b312b6be5ffcd447b8be5a0bbb0399270dc4312d3f8bdc8db4e1d58ca64171e491dba10b48f96b0dc60f2a6dc72e85a7edeea172c6d1d6fffdb8a4e15c06f69ad764cfe1af9daa7c77f87f72794d36092fbb8d92b62b098d5867ed9faa907e976f5a72d712dc6aeea9a97caf6849e912bc6872bb3d7576bb29720e68a7cd3b5bc7e0883c95ac35d5fdb7df52548d1a49a1a1761ca85144ec8c42cbaee6bd807238cbf09587c464c53e53ca6c8f2c04381bcd4677abe02c8fdd3c525d765ccd0882a08f83ba5fe9d04b17da5a1d3f8a29f097a902ec3c34f6ba8fb324cd9f12d35c660bcc5c19cb0908efd89cad6f27017818f819cbaac4226891a006b86071fd481f812db5dc9c6117cb016c206b522d077b8011dd734bd47a9b8b1281de9b4c10f1ec2ec4c08106dff11955e813f5f71ddb76facd91e90806fad330ea63f2dcb4487025136e479c1ff07adf78d310c8f2faf4bc36fc2153c1f65e60ae11cceafdb35c4f7430221c9c2777fa14e65ccf19e73719833caf265de68a242d2d25058cb19bf59035f97c7b402ba5147295825de05ff7d7d3028a4d157dfe52f21d98d81dc7fc178b494de22569860377eaae9daf33d390c357938fe544b2878a2147c3c1027129755055cab416f9e3514dbb382bde7eeb5688c3d210ae47177acd96977665722b9a26a6614c4cc8c62cbd1dbf097f8b645ace130c1bc05a3226ac358846daa038a3fa8eddd36cc05f2516d7ac27151e4994606c2383ddedd914981b436485f761358c9ccdd4c39a956e28368c59ea1db861a223b17f5677fac588e123fbfbd031073aaa3d66e512fca64e00a6f29df51dad60bcf566c4ed45481ea831929fab6633cf9df2b533ccc70763d49833848a0b5b7f684540de728cb9d4dd22f93bb144e6da1eb5bad23064115b876bb67e4db529ff843fc457b48ed6459060b23c2c582bc6bfa720b2e8e607f43152d494b57f42107282f5e95f2720e6789be65ef003a02b198a3000a24f7220e3d4699da15642c49b0ae1e28a8e7ee435604fddd9cb661da5639ac831a51302b2850e6cd12ddeba94c7ccb07cec1f74dcf92cf0ba42473f33756aa288266c9996f3231abcff02436a63ed2c424340cc01761d92c326f5d6f77c45709dc6bf698e3cfc70cd9105d82bfd060d5a8fe4c67e9a9763b299d60c3eb6e011b9b2cdab2ff321fa2e140bf0111d25497fc5a9eda6949ddb8869500bbff073f0ad38bd4d6b4ca148b446f10cc1111900c54c4bac4743b644633e8cde6e1d8db9cd5da79d1c559bad111ace1dd27f4ef1389fc8e5f022b9ca14994371fbd3871832ad446e3cd0f5b4c8de1dd717e352de8d90c2fcb6b8d44e1e723ab8a8bf5bb58a98c8ccd5eed6239007862bef33936000db76bfabb18b509e0b572cd0bd627780ec635917721fbc1f8505328f588059bd32b1305d1bf24e6467026ac97f0b42a2e9e8a8e8d2ff15ca75ddf7c08ebdb6ae3b86ca0b2c1ba34b5500850a5473e52f1113ca7b856b13322d413cc1909fa73950350f425fb2be3f9c989116334190729ebc702694fa7c51eb8a7c27d9b2174cbcc513c6d62bda612579de4b1f9ed47c20f136243d5d46d5e97a9e0fd00b5bbff76445ab43407e5746eab3893d40123decf234f9a90d71d894a5ec45ffc650121abc90d3dc6fdf23f861a2f8c2375ac461948bb80caebc9a1fb6a1ec4278083b8eca5087594fadd7e7a39188e3ecccd99e5f1cae2b51741582a85b4bfd76447e182e1e0c6faa59e83a0154c24e0e19db2fd1fc64d4af245d1e6b99565ca963923e9b8707c7ac6eb78db460b7604fd1ec59c0ba3a39208268eb46b324ce354b2901d1079404c072fd980e3a3949be7d52ae788f16615ced1e7f4c4a211d58ebe9a1126677cc78aac036df289e8ce485f7ba2d24177a832018dbb6f9dcbaa3dac8d62893ef57e2818336a9cd636c514512058071c187541efa3c98cb44f04fd6f38a6e9b30ab0ef86f4862940b75704c287d49445f926f2a488335e809307ef93d156c05ded5415d46d392c34753c873736af2f7e1d85cda7b792eef285eeaeaf3403954d545eda9f5354e6c43e842f1eeaf2c23badf000fba3d7b7c6f584d1389a48d484ee6b8746ca0c8e4acbea5e89af45c2ac36321c35a42773880f07874ea8e3a7ad0369df8d3489ae41f30be0f22bc86b0d1209cd01f460815e943e498d06c234bf04ed374da3d348ca9785254b82144c377362ad2dd3d6df87d3263965724b5380e1952d3d4ea1498babc793bc7411f200e707607ec1602e257701ad90ede4f23c6807d024ee0372540b1f36efc51ef2e0bf5d13bc8b4ebabdb39a21a4bc1e12360dc65b9d244a2200ff0b6f082233460da26bb6687e5fcf073a65fa431fa97294d54d92b1325fb85737f39b2b4a33cdfbcab3f63349900b8f54043a77805d5147f44b8eb6465dd48d5791344471643bef626b0dbfd22d46006984eaa6c1954ef375cfdcfd87978c0c997898e2a3709d84e0e079b99e3b46abffd48d38e7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>士兵突击随想</title>
      <link href="/2020/03/16/%E5%A3%AB%E5%85%B5%E7%AA%81%E5%87%BB%E9%9A%8F%E6%83%B3/"/>
      <url>/2020/03/16/%E5%A3%AB%E5%85%B5%E7%AA%81%E5%87%BB%E9%9A%8F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>这部2006年上映的作品豆瓣评分9.3，时至今日仍然有人乐此不疲地讨论剧情和启发，我想称之为经典应该不算过分。<br />这部剧我至少完整看过3遍，随着阅历增加，对某些角色的体会也变得更深刻。</p><h2 id="许三多">许三多</h2><p>许三多是幸福的。从老马、史今到袁朗，他的成长，总有贵人相助，再加上自身近乎于偏执地努力，成为“兵王”并非意外。<br /><strong>每个开始，总会艰难一些。</strong><br />初来乍到，面对自家坦克，他举手投降，连长怒了。于是，红三连，五班。<br />就像初入社会，没什么朋友，周围的东西和我们格格不入，许三多的境遇大抵如此了。<br />那个“无数班长的坟墓，所有孬兵的天堂”，他活得很简单、很纯粹：负重跑步、整理内务，日日如此，还为连队修了条路。<br /><strong>无人问津的地方，你有得选择。</strong>你可以放弃，可以混日子；也可以认真，可以努力。<br />重回钢七连，仍然没有人相信他，除了班长，那个有过承诺的班长。<br />说实话，那个时候，我讨厌许三多。讨厌他的愚笨，讨厌他不争气，最讨厌的，他拖垮了史今。<br />史今的心思全部倾注给了许三多，那么优秀的班长，在天安门前抱头痛哭，怎叫人不心疼！<br />有人说，史今给许三多打好了地基，袁朗则在地基上盖好了房子。<br />是的，没有史今，就不会有后来的许三多。<br />333个腹部绕杠，许三多开始了自己的蜕变。<br />七连改编，他又把“不抛弃，不放弃”诠释到了极致。<br />不焦虑，耐得住寂寞。<br /><img src="https://img-blog.csdnimg.cn/20200316141449843.png" alt="在这里插入图片描述" /><br />在最绝望的情况下，在完全失去理想和希望的情况下，也会尽自己最大的努力。<br />失手杀掉毒贩，他也怀疑过自己，怀疑过这支部队，因为他相信人性本善，每个人都可以好好活。<br />不过历经波折，最终还是艰难地完成了心智的转变。<br />无意批评，许三多是好兵，但他绝非将才。可能与他成长的家庭有关，父亲的教育方式让他绝对服从、勇于认错，但他缺乏思考。<br />没有思考，就没有大局观；没有大局观，自然不能指挥别人。</p><h2 id="吴哲">吴哲</h2><p>吴哲我比较喜欢，尽管被塑造得稍稍理想了些。<br />年少有为，技术出众。<br />他对自己有着清醒的认识，对这个世界同样如此。<br />一如演习后他对袁朗所说：</p><blockquote><p>我成为不了他，而他亦取代不了我。</p></blockquote><p>不会畏惧权威，永远坚持理想。<br />当他发现现实环境与期望之所相距甚远，他会质疑、会抗议，会去维护自己的理想。<br />理想让他仰望星空，“平常心”使他脚踏实地。<br /><img src="https://img-blog.csdnimg.cn/20200316141511696.png" alt="在这里插入图片描述" /><br />附上袁朗的点评</p><blockquote><p>我不会践踏你们的理想和希望，我不能，因为那是我最珍惜的部分，也是我选择你们的第一要素，我只是想，你们在没有这些东西的情况下也能生存，在更加真实和残酷的环境里还能生存。<br />我敬佩一位老军人，他说他费尽心血却不敢妄谈胜利，他只想他的部下能在战场上少死几个，他说这是军人的人道。<br />这个人略显轻浮，但心理稳重。坚持自己的原则，充满希望和乐观。重要的是，他能跟许三多这样的兵交朋友，这一点，就不会毁于他很容易产生的优越感。</p></blockquote><h2 id="袁朗">袁朗</h2><p>最完美的人，也是无数人想成为的人。<br />他似乎总是站在上帝视角，洞悉一切，指点迷津。<br />军事素养拔尖，一举枪，便打掉了成才的狙击梦。<br />有能力、有思想，也有情义。<br />老A选拔的最后，伍六一放弃，我明明看到了袁朗强忍的泪水。 许三多决定复员，他并不是强行挽留。给他钱，给他假，给他自由，我想，这么做，他心里是有底的。<br />演习评估的剧情，异常精彩。袁朗手术刀般精准地评价了每个人，他看得透他们。<br />“不抛弃，不放弃”，他理解的深刻得多。正因为如此，他给了成才第二次机会；也正因为如此，才有了许三多坠落后，他对成才说的话：</p><blockquote><p>百万大军数年心血，人走人留，抛家舍业，一切数据和非数据的结果都要在这几天检验，最后得不出一个公平的结果，因为我的战士要在战场上和他的朋友重拾友谊。<br />你开始珍惜，可你真懂珍惜了吗？不抛弃，不放弃，你倒记住了，你也这样告诉许三多，那么先想想，做到这六个字的人抛弃了什么，放弃了什么。想吧，现在。</p></blockquote><p>初次看这段，我也一脸懵逼。<br />后来才知，许三多为了胜利付出了鲜血，他创造的机会才是真正值得珍惜的，抓住机会获取胜利、为军队改革提供经验，远比立刻抢救队友意义重大的多。<br />他循循善诱，告诉成才一个指挥官应该做什么，告诉他战场上应该怎样取舍。<br />袁朗说自己年轻时最像成才，比吴哲更专心，比成才更知道自己想要什么。<br />我想，袁朗最终也算是给自己找到了接班人吧。<br /><img src="https://img-blog.csdnimg.cn/20200316140043328.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/2020031614005371.png" alt="在这里插入图片描述" /></p><h2 id="成才">成才</h2><p>相比之下，成才的路的确坎坷的多。<br />经历了荣光，也熬过了低谷，最后做到了出众。<br />这个人物塑造地很真实，他会为了个人利益抛弃战友，但也会在需要理智时做出正确选择，而许三多感情用事更多一些，这在战场上是致命的，尤其对于指挥官而言。<br /><img src="https://img-blog.csdnimg.cn/202003161416111.png" alt="在这里插入图片描述" /><br />袁朗曾经对他寄予厚望，但演习后一切似乎又戛然而止：</p><blockquote><p>你老把一切当成你的对立，总想征服一切，费了这么大的力，我们只想在你们没有战争的时候，就经历第一场战争。战争中伤亡最重的总是新兵，因为没有心理经历，没有适应时间。<br />理由你太见外，任何个人和团体很难在你的心里占到一席之地。你很活跃，也很有能力，但你很封闭，你总是在自己的世界里，想自己的，做自己的。成才，我们这伙人不只是为了对抗，你的战友，甚至你的敌人，需要你去理解、融洽和经历。<br /><strong>你经历的每个地方、每个人、每件事，都需要你付出时间和生命，可你从来没付出感情，你总是冷冰冰的把它们扔掉，那你的努力是为了什么？为一个结果虚耗人生？</strong> 你该想的不是怎么成为一个特种兵，是善待自己做好普通一兵。<br />七连只是你的一个过路的地方，如果再有更好的去处，这儿也是你过路的地方，我们不敢跟这样的战友一起上战场。<br />我对你很失望，我一直在想，这么一个优秀的兵，为什么不能把我们当成他的战友。从那天起我开始对你失望，你们是团队的核心、精神、唯一的财富，其它都是虚的，我无法只看你们的表现，我更看重的是人。<br />我终于发现这世界上还有你在意的人，可这并不能说明你就学会了珍惜。</p></blockquote><p>很多时候，觉得世界并非纯粹的黑白，每个人的选择，也不能简单地用对错衡量。<br />第一次收看的时候，我十分讨厌这个家伙：自私、虚伪、圆滑，为了成绩不顾一切。他被淘汰出局时，观众看得很解气。作为对比，许三多单纯、团结、向上，虽然早期经历挫折，但后期军旅之路愈发风顺，这也是观众喜闻乐见的情节。<br />但随年岁增长，我们会发现许三多这样的人几乎不存在，而早期的成才则比比皆是。<br />能从五班重新走回老A，大多数人看到了他超乎寻常的冷静和神乎其神的枪法，却少有人关心他在五班的日子是怎么渡过的。要知道：从山峰跌落，要远比在平地上摔倒疼的多。唯一关心他的只有许三多（有这样的朋友，真是不知道交到什么好运气了）：</p><blockquote><p>你说他逃避了你设计的经历，这个你在意，可他真实经历了什么，你根本就不在意。你设计的几个小时，难道比他过的这段日子还要难吗？你要是去过五班就不会这样。</p></blockquote><p>后来他说自己只是草原上一个跑丢了的兵。 草原五班的这段经历弥足珍贵，成才学着知足常乐、学着善待别人，他真的后悔了。<br />浴火重生，他真该感谢袁朗，让他重新起跑，而且跑得不算太晚。<br />最后的演习，很显然，他唯一的机会了。<br />这次没有让袁朗失望：</p><blockquote><p>你像个指挥员开始思考问题了。 吴哲领路，我不在的时候成才领队。</p></blockquote><p>事实上，这就是对成才的肯定。<br />袁朗故意暴露，一是掩护行动，二可能也想培养成才吧。</p><blockquote><p>你的路还很长，比许三多要长的多，同时你的迷茫要比他多得多，如果这是你的路，你愿意来老A吗？</p></blockquote>成才可算成才了~<br /><p align="right">写于2018年8月28日，知乎</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest XXX</title>
      <link href="/2020/03/11/Longest%20XXX/"/>
      <url>/2020/03/11/Longest%20XXX/</url>
      
        <content type="html"><![CDATA[<h2 id="longest-common-substring">Longest Common Substring</h2><ul><li>Brute Force<br />遍历<code>a</code>和<code>b</code>所有位置的组合，向后延伸，直到遇到两个不同的字符，复杂度是<span class="math inline">\(n^3\)</span>级别。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回所有结果</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">longestCommonSubstring</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                string cur;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = i, n = j; m &lt; a.<span class="built_in">size</span>() &amp;&amp; n &lt; b.<span class="built_in">size</span>(); ++m, ++n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[m] != b[n]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur += a[m];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.<span class="built_in">size</span>() &amp;&amp; cur.<span class="built_in">size</span>() &gt;= maxLen) &#123;</span><br><span class="line">                    maxLen = cur.<span class="built_in">size</span>();</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>DP<br />暴力解有很多重复计算：比如以<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>为起点去向后延伸，我们可能需要比较<span class="math inline">\(i+1\)</span>和<span class="math inline">\(j+1\)</span>、<span class="math inline">\(i+2\)</span>和<span class="math inline">\(j+2\)</span>...而以<span class="math inline">\(i+1\)</span>和<span class="math inline">\(j+1\)</span>为起点时，仍然要比较<span class="math inline">\(i+2\)</span>和<span class="math inline">\(j+2\)</span>，<strong>重叠子问题</strong>给动态规划带来了可能。<br />暴力做法是将每个<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>作为起点，现在我们考虑将<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>作为终点，令<span class="math inline">\(L(i,j)\)</span>表示text1[0...i]和text2[0...j]中的最长子串的长度（不是非要以<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>作为结尾）： <span class="math display">\[L(i,j)=\begin{cases}1+L(i-1,j-1)&amp; \text{a[i]=b[j]}\\0&amp; \text{a[i]!=b[j]}\end{cases}\]</span> 为了简便，假设下标从1开始，那么边界条件：<span class="math inline">\(L(0,j)=0,L(i,0)=0\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">L</span>(<span class="number">1</span> + a.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> + b.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    L[i][j] = <span class="number">1</span> + L[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    L[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen, L[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显然时间降为<span class="math inline">\(O(n^2)\)</span>，空间升为<span class="math inline">\(O(n^2)\)</span>。仔细观察，计算<span class="math inline">\(L(i,j)\)</span>只需要左上方<span class="math inline">\(L(i-1,j-1)\)</span>的信息，所以我们按照斜线方向计算，可以将空间优化到<span class="math inline">\(O(1)\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// from the up-right corner</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (row &lt; a.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = row, j = col; i &lt; a.<span class="built_in">size</span>() &amp;&amp; j &lt; b.<span class="built_in">size</span>(); ++i, ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                    ++curLen;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    curLen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen, curLen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (col &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                --col;  <span class="comment">// 斜线左移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ++row;   <span class="comment">// 斜线下移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(TODO)输出所有的最长公共子串</p><h2 id="longest-common-subsequence">Longest Common Subsequence</h2><p>实现见<a href="https://github.com/EIMadrigal/LeetCode/blob/master/DP/%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97.md">Github</a></p><ul><li>Brute Force<br />找到<code>a</code>的所有子序列，判断是否是<code>b</code>的子序列，指数级复杂度，也就没有写出来的必要了。</li><li>DP<br />重叠子问题很明显，而且LCS具有最优子结构，令<span class="math inline">\(L(i,j)\)</span>表示text1[0...i]和text2[0...j]的LCS长度（不是非要以<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>作为结尾）： <span class="math display">\[L(i,j)=\begin{cases}1+L(i-1,j-1)&amp; \text{a[i]=b[j]}\\max\{L(i-1,j),L(i,j-1)\}&amp; \text{a[i]!=b[j]}\end{cases}\]</span> 为了简便，假设下标从1开始，那么边界条件：<span class="math inline">\(L(0,j)=0,L(i,0)=0\)</span>。</li></ul><p>时间和空间都是<span class="math inline">\(O(mn)\)</span>。类似的，<span class="math inline">\(L(i,j)\)</span>依赖于左上角<span class="math inline">\(L(i-1,j-1)\)</span>、左边<span class="math inline">\(L(i,j-1)\)</span>、上边<span class="math inline">\(L(i-1,j)\)</span>，可以只存储上一行和当前行的<span class="math inline">\(L\)</span>。进一步考虑：可以只存储当前行的<span class="math inline">\(L\)</span>，外加一个变量<span class="math inline">\(pre\)</span>存储左上角<span class="math inline">\(L(i-1,j-1)\)</span>，空间可以优化到<span class="math inline">\(O(min(m,n))\)</span>：</p><h2 id="longest-increasing-subsequence">Longest Increasing Subsequence</h2><p>具体实现见Github</p><ul><li>DP<br /><span class="math inline">\(dp[i]\)</span>表示从左向右扫描直到以a[i]元素结尾的序列所形成的LIS的长度，且子序列包含a[i]： <span class="math display">\[dp[i]=max\{dp[i],1+dp[j]\}, 0\leq j&lt;i,a[i]&gt;a[j]\]</span></li></ul><p>最终答案即是<span class="math inline">\(dp\)</span>数组的最大值： 时间<span class="math inline">\(O(n^2)\)</span>，空间<span class="math inline">\(O(n)\)</span>。</p><ul><li>DP+Binary Search<br />遍历数组的过程中，不停填充<span class="math inline">\(dp\)</span>数组，维护<span class="math inline">\(dp\)</span>数组使得其存储递增序列：<br />如果<span class="math inline">\(nums[i]&gt;dp[-1]\)</span>，将<span class="math inline">\(nums[i]\)</span>加入dp数组；<br />否则，在dp数组中二分查找<span class="math inline">\(nums[i]\)</span>的位置，并将<code>lower_bound</code>位置更新为<code>nums[i]</code>, 增大后续递增的可能性.<br />举例来说，<span class="math inline">\(nums=[0,8,4,12,2]\)</span>，<span class="math inline">\(dp\)</span>数组：<br /><span class="math inline">\([0]\)</span><br /><span class="math inline">\([0,8]\)</span><br /><span class="math inline">\([0,4]\)</span><br /><span class="math inline">\([0,4,12]\)</span><br /><span class="math inline">\([0,2,12]\)</span><br />虽然<span class="math inline">\(dp\)</span>数组最终存储的不是LIS，但长度确是LIS的长度. 时间<span class="math inline">\(O(nlogn)\)</span>，空间<span class="math inline">\(O(n)\)</span>。</li></ul><h2 id="longest-palindromic-substring">Longest Palindromic Substring</h2><ul><li>Brute Force<br />枚举每个子串的起始和结束位置，判断是否回文。时间<span class="math inline">\(O(n^3)\)</span>，空间<span class="math inline">\(O(1)\)</span>。</li><li>DP<br />假设输入<code>ababa</code>，如果我们已经判断了<code>bab</code>是回文的，那么<code>ababa</code>就不需要再扫描一遍，因为两端都是<code>a</code>。 所以一个很直观的动规： 令<span class="math inline">\(dp(i,j)\)</span>去<strong>记忆</strong><span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>之间的串是否回文，那么转移方程： <span class="math display">\[dp(i,j)=dp(i+1,j-1)\&amp;\&amp;s[i]=s[j]\]</span> 边界条件<span class="math inline">\(dp(i,i)=true,dp(i,i+1)=(s[i]=s[i+1])\)</span>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充方向：由边界条件dp(i,i)向其他地方扩展，只需要填充j&gt;i的三角形部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">length</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">length</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                    end = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][i + <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; s.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j] &amp;&amp; maxLen &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                        start = i;</span><br><span class="line">                        end = j;</span><br><span class="line">                        maxLen = end - start + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(n^2)\)</span>，空间<span class="math inline">\(O(n^2)\)</span>。 - Expand Around Center<br />回文串都是镜像对称的，可以遍历整个串，从当前位置向两边延伸，直到遇到不相等的字母。这里要考虑字符串长度的奇偶：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = <span class="built_in">expandCenter</span>(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = <span class="built_in">expandCenter</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">max</span>(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; end - start + <span class="number">1</span>) &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expandCenter</span><span class="params">(string s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.<span class="built_in">length</span>() &amp;&amp; s[start] == s[end]) &#123;</span><br><span class="line">            --start;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end - start - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(n^2)\)</span>，空间<span class="math inline">\(O(1)\)</span>。</p><ul><li>Manacher's Algorithm（待填）<br />时间<span class="math inline">\(O(n)\)</span>。</li></ul><h2 id="longest-palindromic-subsequence">Longest Palindromic Subsequence</h2><ul><li>DP<br />令<span class="math inline">\(dp(i,j)\)</span>表示介于<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>间的LPS的长度，那么状态转移方程： <span class="math display">\[dp(i,j)=\begin{cases}2+dp(i+1,j-1)&amp; \text{s[i]=s[j]}\\max\{dp(i+1,j),dp(i,j-1)\}&amp; \text{s[i]$\neq$s[j]}\end{cases}\]</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; n;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(n^2)\)</span>，空间<span class="math inline">\(O(n^2)\)</span>。<br />同样，空间可以优化到<span class="math inline">\(O(n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i) &#123;</span><br><span class="line">            pre = dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; n;++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                    dp[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                    dp[j] = pre + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = tmp;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oliver Twist</title>
      <link href="/2020/03/07/Oliver%20Twist/"/>
      <url>/2020/03/07/Oliver%20Twist/</url>
      
        <content type="html"><![CDATA[<p>对于济贫院那些绅士们而言，贫民好吃懒做、贪得无厌。他们消耗的食物即是对教区最大的威胁。</p><p>绅士们的利益得不到满足时，孤儿们只能被驱之而后快，甚至被“加价出售”。</p><blockquote><p>然而，眼泪这种东西根本无法触及Bumble先生的灵魂，他的心是防水的。</p></blockquote><p>小Oliver被卖到棺材店做学徒，受尽欺凌，却从未忘记反抗。<br /><img src="https://img-blog.csdnimg.cn/2020030720431780.png" alt="Oliver Twist" /><br />逃离了魔窟，迎来的并非光明，而是欺骗。</p><p>骗他少不更事，骗他无依无靠，差点把他骗成了小偷。</p><blockquote><p>与其说这是白昼的诞生，不如说是黑夜的死亡。</p></blockquote><p>全书随处可见反讽口吻，英国的很多社会问题跃然纸上。</p><p>Oliver很幸运，Brownlow先生收留了他，照顾他，让他拥有了第一段短暂而又美妙的时光——小孩子应得的时光。</p><p>可是那种社会，善总是被恶击败。</p><p>无奈，重入贼巢。</p><blockquote><p>诡计多端的老犹太已经使这孩子误入歧途，他用孤独与忧郁去熏陶奥利弗的心，让他感到在这样一个阴森凄凉的地方，无论与谁为伍都比独自一人沉浸在忧愁苦恼中好受一些，他现在正将毒汁缓慢地注入Oliver的灵魂，企图熏染他，将那颗心变黑，永远改变它的颜色。</p></blockquote><p>他曾寄希望于Nancy，而Nancy亦没有辜负他。</p><p>先是保护他免遭毒打，后又不顾危险，报信给Brownlow先生。</p><p>幸运女神再一次光顾了小Oliver，枪伤让他与死神擦肩而过，来到希望的田野。</p><p>就这样开始了第二段毫无忧虑的时光。</p><blockquote><p>在睡梦中的孩子发出微笑，彷佛这些怜悯的表示唤醒了某种令人愉快的梦境，那里有他从未领略过的爱心与温情。有的时候，一支亲切的乐曲，一处幽静地方的潺潺水声，一朵花的芳香，甚而只是说出一个熟悉的字眼，会突然唤起一些模糊的记忆，那是一些不曾出现过的场景，它们会像微风一样飘散，彷佛刹那间唤醒了某种久以别离的、比较快乐的往事，而这种记忆单靠苦思冥想是怎么也想不起来的。</p></blockquote><p>Nancy是悲惨的，明明有机会逃离苦海，却因为不合时宜的爱情（也许是爱情吧）葬送了自己。</p><blockquote><p>她觉得自己积重难返，难以抛弃过去的生活，即使她讨厌它。</p></blockquote><p>天真地以为Bill会和她一起去过一些“干净”的日子。</p><p>恶的外表下隐藏着善，这无疑是可悲的，令人唏嘘的。</p><p>或许她的死亡是在救赎过去犯下的罪，是一种解脱，也是她很好的归宿了吧。</p><p>善恶终有报。</p><p>Bill杀人后疯狂地救火，不过只是掩饰自己犯下的罪行、求得一丝可怜的心理安慰而已，繁忙过后，留给他的只有煎熬和无尽的苦痛。</p><p>至于Fagin，那个恶魔</p><blockquote><p>这是他的最后一夜，一种意识到自己已经濒临绝境的幻灭感正向他那晦暗的灵魂全力袭来。</p></blockquote><p>抠抠索索一辈子，绞刑架确是他最终的栖息地。</p><p>如书中所言，</p><blockquote><p>在生活中我们不是置身事外的观众，而是粉墨登场的演员。</p></blockquote><p>降生后的角色是上帝赋予的，我们无能为力。</p><p>能做的，只是像小Oliver一样，永怀希望与感恩。</p><p align="right">写于2018年8月26日，知乎</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Knapsack Problem</title>
      <link href="/2020/02/23/Knapsack%20Problem/"/>
      <url>/2020/02/23/Knapsack%20Problem/</url>
      
        <content type="html"><![CDATA[<figure><img src="https://img-blog.csdnimg.cn/824d4e63a6e34090847dac97a84a3806.png" alt="" /><figcaption>背包问题分类</figcaption></figure><h2 id="背包">0-1背包</h2><ul><li>描述：N件物品，第i件的重量是w[i]，价值v[i]。有一个容量为W的背包，求将哪些物品放入背包可使总价值最大。每件物品可以用<strong>0或1次</strong>。</li><li>分析：根据题意，可以写出表达式： <span class="math display">\[max(\Sigma v_ix_i), s.t. \Sigma w_ix_i&lt;=W, x_i\in\{0, 1\}\]</span> 最直接的思路就是：对于每件物品，都有yes/no两种选择，尝试所有的组合，记录每个组合的价值，选出满足重量条件的最大价值。时间复杂度<span class="math inline">\(O(2^n)\)</span>，空间复杂度<span class="math inline">\(O(n)\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// backtracking</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">knapsack01</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v, string&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="function">string <span class="title">cur</span><span class="params">(w.size(), <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, W, w, v, cur, ans);</span><br><span class="line">        <span class="keyword">return</span> maxV;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> curW, <span class="keyword">int</span> curV, <span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v, string&amp; cur, string&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 到达叶子结点，得到一个解，所以在这里更改最终结果</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= w.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxV &lt; curV) &#123;</span><br><span class="line">                ans.<span class="built_in">assign</span>(cur);</span><br><span class="line">                maxV = curV;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// as for goods s, two choices</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            cur[s] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curW + i * w[s] &lt;= W) &#123;</span><br><span class="line">                curW += i * w[s];</span><br><span class="line">                curV += i * v[s];</span><br><span class="line">                <span class="built_in">dfs</span>(s + <span class="number">1</span>, curW, curV, W, w, v, cur, ans);</span><br><span class="line">                curW -= i * w[s];</span><br><span class="line">                curV -= i * v[s];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxV = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的程序可以通过剪枝进行优化，下来换一种思路：<br />令<code>dp[i][j]</code>表示有前i件物品可选，背包容量为j时具有的最大价值，问题转化为求<code>dp[N][0...W]</code>的最大值，边界条件： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一列全0，第一行取决于物品0体积与背包大小关系</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(w.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = w[<span class="number">0</span>]; j &lt;= W; ++j) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = v[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 假设3件物品，<span class="math inline">\(w=\{1,1,2\}\)</span>，<span class="math inline">\(v=\{1,2,4\}\)</span>，<span class="math inline">\(W=2\)</span>，先用递归形式分析，每件物品只有yes/no两种状态： <img src="https://img-blog.csdnimg.cn/20200223185930802.png" alt="在这里插入图片描述" /> 可以看到，求解过程中有很多<strong>重叠子问题</strong>，故可以采用记忆化递归求解，时间复杂度即为子问题数量<span class="math inline">\(O(NW)\)</span>，空间复杂度<span class="math inline">\(O(NW)\)</span>。<br />记忆化递归可以写成自底向上的动态规划，状态转移方程： <span class="math display">\[dp[i][j]=max\{dp[i-1][j], v[i]+dp[i-1][j-w[i]]\}\]</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp-&gt;space complexity O(NW)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">knapsack01</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], v[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N][W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 前i件物品只依赖于前i-1件物品，<span class="math inline">\(dp\)</span>数组的更新方向为： <img src="https://img-blog.csdnimg.cn/20200223200829966.png" alt="在这里插入图片描述" /><br />所以可以使用滚动数组降低空间复杂度为<span class="math inline">\(O(W)\)</span>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp-&gt;space complexity O(W)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">knapsack01</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="comment">// iterate j reversely, avoid dp override</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= w[i - <span class="number">1</span>]; --j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], v[i - <span class="number">1</span>] + dp[j - w[i - <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[W];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 01背包有一些细节需要注意：</p><ul><li>两个for循环的先后：核心在于当前值取决于其正上方的值和上一行前面的某个值，二维中行优先和列优先都可以保证更新当前值之前其需要的两个值已经更新，故可以颠倒；一维中列优先是不可以的，因为上一行前面的某个值会被覆盖</li><li>二维和一维j的遍历顺序：二维正反都可以；一维只能反向，否则会被覆盖</li></ul><p>有一道比较类似的题目<a href="https://leetcode.com/problems/target-sum/">Target Sum</a>，分析下此题顺便再练习下DP的套路。<br />题意是这样：给定一些<strong>非负</strong>数字，可以给每个数字添上<code>+</code>或<code>-</code>号，使得添加后的所有数字之和等于<code>S</code>。数组大小不超过20，<code>S</code>大小不超过1000。<br />我第一次做感觉这是个纯暴力DFS，枚举所有可能，复杂度<span class="math inline">\(O(2^n)\)</span>。 这道题和0/1背包不同之处在于：数组里的所有数字都必须用到。</p><p>接着我们试着做一些优化：<br />换种方式看问题：在这堆数字中选一些作为正数集合<span class="math inline">\(P\)</span>，剩下作为负数集合<span class="math inline">\(N\)</span>，那么有<span class="math inline">\(sum(P)-sum(N)=S\)</span>，<span class="math inline">\(sum(P)+sum(N)+sum(P)-sum(N)=sum(nums)+S=2*sum(P)\)</span>，故<span class="math inline">\(sum(P)=(sum(nums)+S)/2\)</span>，同时注意到<span class="math inline">\(sum(nums)+S\)</span>是偶数。<br />所以问题转化为在数组中寻找一些数作为正数，使得这些数的和为<span class="math inline">\((sum(nums)+S)/2\)</span>，求这样的组合有多少种。这就转化为了0/1背包问题。</p><p>我们用<span class="math inline">\(dp(i,j)\)</span>表示从前i个数中选出和为j的方案数目，有状态转移方程<span class="math inline">\(dp(i,j)=dp(i-1,j)+dp(i-1,j-nums[i])\)</span>，如果纯粹暴力递归，有很多重叠子问题（类似背包问题的那个图）。Base Case就是，<span class="math inline">\(dp(0,0)=1\)</span>，即选出和为0的方案，就是每个都不选一种；否则当<code>i = 0 || j &lt; 0</code>时，<span class="math inline">\(dp(i,j)=0\)</span>。</p><p>所以先用记忆化搜索：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">memo</span>(<span class="number">21</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">1001</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> sum &lt; S || (sum + S) &amp; <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">cnt</span>(nums, memo, nums.<span class="built_in">size</span>(), (sum + S) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp;memo, <span class="keyword">int</span> idx, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!idx &amp;&amp; !sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!idx || sum &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (memo[idx][sum] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[idx][sum];</span><br><span class="line">        memo[idx][sum] = <span class="built_in">cnt</span>(nums, memo, idx - <span class="number">1</span>, sum) + <span class="built_in">cnt</span>(nums, memo, idx - <span class="number">1</span>, sum - nums[idx - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> memo[idx][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改一下Bottom-Up的形式，更新方向从左到右、从上到下，注意这里j不能从<code>nums[i - 1]</code>开始，否则j的前半部分无法更新到正确的值，后面如果用到就是错误的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S || (sum + S) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">21</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">1001</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 不能for (int j = nums[i - 1]; j &lt;= (sum + S) &gt;&gt; 1; ++j)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= (sum + S) &gt;&gt; <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()][(sum + S) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后来优化空间：<span class="math inline">\(dp(i,j)\)</span>取决于<span class="math inline">\(dp(i-1,j)\)</span>和<span class="math inline">\(dp(i-1,j-num[i-1])\)</span>，所以只要用一个一维数组<span class="math inline">\(dp(j)\)</span>记录上一行的所有值即可，这里必须反向更新，因为如果正向，上一行的j-num[i-1]位置已经被新值覆盖，计算结果出错。如果反向：上一行需要的2个位置都没有被覆盖：<span class="math inline">\(dp(j)=dp(j)+dp(j-nums[i-1])\)</span>。<br />初始时候(0,0)位置为1，即<span class="math inline">\(dp(0)=1\)</span>，以后<span class="math inline">\(dp(0)\)</span>会不断更新。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt; S || (S + sum) &amp; <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">numSubsetSum</span>(nums, (S + sum) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubsetSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">/* 等价写法</span></span><br><span class="line"><span class="comment">        for (int j = target; j &gt;= 0; --j)&#123;</span></span><br><span class="line"><span class="comment">if (j - nums[i] &gt;= 0)</span></span><br><span class="line"><span class="comment">dp[j] += dp[j - nums[i]];</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line">            <span class="comment">// 只有j&gt;=nums[i]才更新，否则沿用上一行的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i]; --j) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="完全背包">完全背包</h2><ul><li>每件物品可以使用<strong>任意多次</strong>。</li><li>一个Naive的思路： 虽然题目描述每件物品可以使用任意多次，但实际上由于W的限制，每件物品最多使用<span class="math inline">\(\lfloor W/w[i] \rfloor\)</span>次。这样我们可以将每件物品拆为<span class="math inline">\(\lfloor W/w[i] \rfloor\)</span>件，问题就转化为了0-1背包。子问题仍然有NW个，但是求解每个子问题需要<span class="math inline">\(O(W/w[i])\)</span>，总的时间复杂度<span class="math inline">\(O(\Sigma (W/w[i])*W)\)</span>，也即<span class="math inline">\(O(W*拆后物品件数)\)</span>。</li><li>更tricky的做法：W无法改变，只能改变<strong>拆后物品件数</strong>。这里可以使用二进制的思想：假设我们某件物品可以使用<span class="math inline">\(10=8+2\)</span>次，原本需要复制出10件，现在只要复制出2件，价值和重量是原来的8倍和2倍，这样就降低了复杂度。</li><li>完全背包有<span class="math inline">\(O(NW)\)</span>的算法</li></ul><p><span class="math inline">\(dp(i,j)=max\{dp(i-1,j-kw[i])+kv[i]\},0\leq kw[i]\leq j\)</span><br />为了得到更加简洁的表示，考虑： <span class="math display">\[dp(i,j-w[i])=max\{dp(i-1,j-w[i]-aw[i])+av[i]\},0\leq aw[i]\leq j-w[i],a\geq 0 \\=max\{dp(i-1,j-(a+1)w[i])+av[i]\},0\leq aw[i]\leq j-w[i],a\geq 0 \\=max\{dp(i-1,j-kw[i])+(k-1)v[i]\},0\leq (k-1)w[i]\leq j-w[i],k\geq 1 \\=max\{dp(i-1,j-kw[i])+kv[i]\}-v[i],0\leq (k-1)w[i]\leq j-w[i],k\geq 1\]</span> 因此当<span class="math inline">\(k\geq 1\)</span>时有<span class="math inline">\(max\{dp(i-1,j-kw[i])+kv[i]\}=dp(i,j-w[i])+v[i]\)</span><br />综上有<span class="math inline">\(dp(i,j)=max\{dp(i-1,j),dp(i,j-w[i])+v[i]\}\)</span>，状态<span class="math inline">\(dp(i,j-w[i])\)</span>包含了第i件物品被选择若干次后的最大价值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsackUnbounded</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], v[i - <span class="number">1</span>] + dp[i][j - w[i - <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsackUnbounded</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i - <span class="number">1</span>]; j &lt;= W; ++j) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], v[i - <span class="number">1</span>] + dp[j - w[i - <span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完全背包两个for循环的顺序也可以颠倒，但是j的遍历只能而且应该正向。</p><h2 id="多重背包">多重背包</h2><ul><li>每件物品最多可以使用<span class="math inline">\(num[i]\)</span>次。</li><li>同样，Naive的思路就是将每件物品都复制<span class="math inline">\(num[i]\)</span>次，问题转化为0-1背包，复杂度<span class="math inline">\(O(\Sigma nums[i]*W)\)</span>。</li><li>将<span class="math inline">\(num[i]\)</span>用二进制表示，价值和重量变为原来的相应倍，降低复杂度。</li></ul><h2 id="future">Future</h2><p>后续还有混合背包、二维费用的背包等，详情可以学习<a href="https://comzyh.com/upload/PDF/Pack-PDF-Comzyh.pdf">背包九讲</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shortest Path</title>
      <link href="/2020/02/18/Shortest%20Path/"/>
      <url>/2020/02/18/Shortest%20Path/</url>
      
        <content type="html"><![CDATA[<h2 id="dijkstra">Dijkstra</h2><p>BFS可以用来求无权图的最短路径，Dijkstra是<strong>单源最短路径</strong>算法，<a href="https://www.zhihu.com/question/21620069">一般的DIJ算法不能用于含负权边的图</a>，本质上还是贪心思想：</p><ol type="1"><li>将所有结点分为两类：已经确定最短路径的点集<span class="math inline">\(u\)</span>、未确定最短路径的点<span class="math inline">\(v\)</span>；</li><li>初始化<span class="math inline">\(dis[start]=0\)</span>，其余结点<span class="math inline">\(dis\)</span>设为无穷大；</li><li>找出一个<span class="math inline">\(dis\)</span>最小的<span class="math inline">\(v\)</span>中的点<span class="math inline">\(x\)</span>，将其标记为<span class="math inline">\(u\)</span>，遍历<span class="math inline">\(x\)</span>的所有<strong>邻接点</strong><span class="math inline">\(y\)</span>，若<span class="math inline">\(dis[y]&gt;dis[x]+w[x][y]\)</span>，则更新<span class="math inline">\(y\)</span>点到源点的最短路径长度<span class="math inline">\(dis[y]=dis[x]+w[x][y]\)</span>；</li><li>重复，直到所有点都在<span class="math inline">\(u\)</span>中。</li></ol><p>邻接矩阵版，适合顶点比较少的图，复杂度<span class="math inline">\(O(2V^2)\)</span><br />邻接表版，复杂度<span class="math inline">\(O(V^2+E)\)</span></p><p>寻找点<span class="math inline">\(x\)</span>的循环可以用堆来优化，使得复杂度降为<span class="math inline">\(O(VlogV+E)\)</span>。</p><p>堆的优化要注意2点:</p><ul><li>小根堆要按照<span class="math inline">\(dis\)</span>组织，但是在调整时要保证<span class="math inline">\(dis\)</span>到顶点索引的映射关系，所以堆存储<span class="math inline">\((index,dis)\)</span></li><li>松弛时堆里已经有某些顶点，这些顶点更新后的新值也要压入堆，原先堆里的顶点既无法更新，也无法删除。所以我们允许堆里出现相同的顶点，但是对于<code>marked</code>标记过的点直接<code>pop+continue</code>即可。</li></ul><p><a href="https://github.com/EIMadrigal/Recap/blob/main/Templates/Basics/dijkstra.cpp">C++实现在这里</a> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    pq = []</span><br><span class="line">    heapq.heappush(pq, (<span class="number">0</span>, s))</span><br><span class="line"></span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    parent = &#123;s : <span class="literal">None</span>&#125;</span><br><span class="line">    dis = &#123;s : <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g:</span><br><span class="line">        <span class="keyword">if</span> v != s:</span><br><span class="line">            dis[v] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(pq) &gt; <span class="number">0</span>):</span><br><span class="line">        pair = heapq.heappop(pq)</span><br><span class="line">        cur_dis = pair[<span class="number">0</span>]</span><br><span class="line">        cur_vertex = pair[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur_vertex <span class="keyword">in</span> marked:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        marked.add(cur_vertex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur_vertex].keys():</span><br><span class="line">            <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked <span class="keyword">and</span> cur_dis + g[cur_vertex][adj] &lt; dis[adj]:</span><br><span class="line">                heapq.heappush(pq, (cur_dis + g[cur_vertex][adj], adj))</span><br><span class="line">                parent[adj] = cur_vertex</span><br><span class="line">                dis[adj] = cur_dis + g[cur_vertex][adj]</span><br><span class="line">    <span class="keyword">return</span> parent, dis</span><br></pre></td></tr></table></figure></p><h2 id="bellman-ford">Bellman-Ford</h2><p>可以计算含有负权的边，检测是否存在一个从源结点可以到达的权重为负值的环路（负权环）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellmanFord</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edge, vector&lt;<span class="keyword">int</span>&gt;&amp; dis, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == start)</span><br><span class="line">            dis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dis[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edge.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            dis[edge[j][<span class="number">1</span>]] = <span class="built_in">min</span>(dis[edge[j][<span class="number">1</span>]], dis[edge[j][<span class="number">0</span>]] + edge[j][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> negCycle = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (dis[edge[i][<span class="number">1</span>]] &gt; dis[edge[i][<span class="number">0</span>]] + edge[i][<span class="number">2</span>]) &#123;</span><br><span class="line">            negCycle = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> negCycle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度<span class="math inline">\(O(VE)\)</span>。</p><h2 id="floyd-warshall">Floyd-Warshall</h2><p>多源最短路径算法。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> k = <span class="number">0</span>;k &lt; m.<span class="built_in">size</span>();++k)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; m.<span class="built_in">size</span>();++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// m不能用INT_MAX初始化，会溢出，用0x3f3f3f3f</span></span><br><span class="line">                <span class="keyword">if</span> (m[i][k] + m[k][j] &lt; m[i][j])</span><br><span class="line">                    m[i][j] = m[i][k] + m[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>不能用于有累加和为负的环的图</strong>，这种图不存在最短路径。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompressIt</title>
      <link href="/2020/02/13/CompressIt/"/>
      <url>/2020/02/13/CompressIt/</url>
      
        <content type="html"><![CDATA[<h2 id="结构">结构</h2><p>压缩软件的核心在于压缩算法。基于Huffman编码的压缩算法思路：</p><ol type="1"><li>以<strong>二进制方式</strong>读取源文件，按照每8bits作为一个字符；</li><li>统计每个字符的出现频率即为叶子结点的权值，按照Huffman算法得到每个叶子的编码；</li><li>对源文件的每个字符，将新的编码组合为二进制流，按照每8bits一个单位写入压缩文件。</li></ol><p>举例来看：<br />假设我们有待压缩源文件<code>hello</code>，<code>h</code>的ASCII码为<code>01101000</code>，同理可得整个文件的二进制形式<code>0110100001100101011011000110110001101111</code>，共5B，40bits。<br />根据Huffman算法：得到<code>h</code>的编码为<code>00</code>，同理可得整个文件的Huffman编码为<code>0001111110</code>，末尾不够8bits，采用补0的方法可得<code>0001111110000000</code>，按照每8bits一个单位，写入压缩文件的是<code>31</code>和<code>255</code>对应的字符，共2B，16bits。<br />解压缩流程是压缩的逆过程：</p><ol type="1"><li>以<strong>二进制方式</strong>读取压缩文件；</li><li>每次取1bit，从Huffman树的根结点出发，找到某个叶子即为源字符。</li></ol><h2 id="效果">效果</h2><p>做一个简单的比较：</p><table><thead><tr class="header"><th>压缩软件</th><th>测试文件</th><th>压缩率</th><th>测试文件</th><th>压缩率</th></tr></thead><tbody><tr class="odd"><td>CompressIt</td><td>txt(840B)</td><td>70.4%</td><td>png(282KB)</td><td>101%</td></tr><tr class="even"><td>WinRaR</td><td>txt(840B)</td><td>14.4%</td><td>png(282KB)</td><td>100%</td></tr></tbody></table><p>压缩率和压缩时间和专业软件没法比。之所以出现压缩文件大于源文件，是因为压缩文件中还存储了Huffman树等信息，为解压所需。<br />对于不同内容的文件，得到的压缩文件大小也不尽相同，这主要与Huffman编码的性质有关。</p><h2 id="理论分析">理论分析</h2><p>Huffman编码依赖于信源的统计特征，其背后的原理在于为出现频率高的字符分配尽可能短的码长，这样就可以降低平均码长： <span class="math display">\[L=\Sigma p_il_i\]</span> 使得<span class="math inline">\(L\)</span>最短的编码就是最优编码，可以证明Huffman编码是一种最优编码。<br />同时Huffman编码还是前缀码，简化了解码过程。<br />假设一种理想情况：源文件长<span class="math inline">\(len\)</span>很大，共有<span class="math inline">\(m\)</span>种不同字符，每个字符用8bits表示，并且每种字符出现频率<span class="math inline">\(\frac{len}{m}\)</span>相同，忽略掉存储Huffman树等信息所需的空间。<br />这棵完全二叉树共有结点<span class="math inline">\(n=2*m-1\)</span>个，那么树深度为<span class="math inline">\(h=1+\lfloor log_2n \rfloor\)</span>，每个字符的压缩长度为<span class="math inline">\(h-1=\lfloor log_2n \rfloor\)</span>，故压缩后的串长度为<span class="math inline">\(\frac{(h-1)*len}{8}\)</span>，可得压缩率<span class="math inline">\(\frac{h-1}{8}\)</span>，即： <span class="math display">\[\alpha=\frac{\lfloor log_2(2*m-1) \rfloor}{8}\]</span> 源文件中不同字符种类<span class="math inline">\(m\)</span>越小，即源文件分布越集中，压缩效果越好。<br />如果和定长编码比较，可以得到压缩率： <span class="math display">\[\alpha=\frac{\lfloor log_2(2*m-1) \rfloor}{\lceil log_2(m) \rceil}\]</span> <span class="math inline">\(m\)</span>取值256时，Huffman树是一棵满二叉树，压缩率为100%，并不比8位固定长度编码更高效。</p><h2 id="收获">收获</h2><ul><li><code>EOF</code>和<code>feof()</code> <code>EOF</code>是一个定义在<code>cstdio</code>头文件中的宏，一般为-1：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOF (-1)</span></span><br></pre></td></tr></table></figure><p>但是如果按照二进制读取文件，对于文件中的-1又该如何处理？<br />阮一峰的博客说：</p><blockquote><p>在Linux系统之中，EOF根本不是一个字符，而是当系统读取到文件结尾，所返回的一个信号值（也就是-1）。至于系统怎么知道文件的结尾，资料上说是通过比较文件的长度。</p></blockquote><p>我们通常会写出下面程序来读取文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = <span class="built_in">fgetc</span>(fp)) != EOF) &#123;</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>fgetc()</code>在到达文件结尾和发生读取错误的情况下都会返回<code>EOF</code>，所以上述代码不严谨，采用<code>feof()</code>函数来判断文件结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">feof</span>(fp)) &#123;</span><br><span class="line">    ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是采用<code>feof()</code>也有一个问题：读取最后一个字符后，<code>feof()</code>仍然返回0，进入循环，<code>fgetc()</code>再向后读取一个字符，<code>feof()</code>才返回1，这样程序会多循环一次。<br />所以比较安全的写法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line"><span class="keyword">while</span> (ch != EOF) &#123;</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line">    ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">feof</span>(fp))</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End-of-File reached.&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Something went wrong.&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>虚析构函数<br />基类的析构函数一般写成虚函数，做个测试：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>() &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor in base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f in base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derive</span> :</span><span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">derive</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">derive</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor in derive&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;f in derive&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">base* p = <span class="keyword">new</span> derive;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f in derive</span><br><span class="line">destructor in derive</span><br><span class="line">destructor in base</span><br></pre></td></tr></table></figure><p>如果基类的析构函数不是虚函数，输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f in derive</span><br><span class="line">destructor in base</span><br></pre></td></tr></table></figure><p>结果并没有调用派生类的析构函数，造成内存泄漏。<br />所以基类的虚析构函数的作用是：<strong>当一个基类指针删除一个派生类对象，确保调用派生类的析构函数</strong>。 - 二进制文件<br />在压缩过程中，对于不同格式源文件的读取都是采用二进制方式<code>rb</code>。<br />实际上二进制文件和文本文件并没有本质区别，你所看到的内容取决于打开文件的软件对二进制流的解释方式，文件扩展名帮助计算机知道应该用哪种解释方式，通常的文本文件的解释方式有ASCII码和Unicode码。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Union-Find</title>
      <link href="/2020/01/26/Union-Find/"/>
      <url>/2020/01/26/Union-Find/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>并查集是一种用来维护集合的数据结构，底层通过<code>parent</code>数组实现，每个集合只有唯一的根结点，并将其作为该集合的标志。</p><p>并查集有两个基本操作：</p><ol type="1"><li>并：合并两集合；</li><li>查：查询某元素的父结点。</li></ol><p>初始化所有元素都是一个独立的集合： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> parent[MAXN];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    parent[i] = i;    <span class="comment">// i元素的父结点初始化为自己，也可以初始化为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="合并与查找">合并与查找</h2><p><a href="https://github.com/EIMadrigal/Recap/blob/main/Templates/Basics/union_find.cpp">实现在这里</a></p><ul><li>Find<br />查找某个元素属于哪个集合（如果单独成集就返回自己），返回该集合的代表元素（即parent为-1的那个元素/parent为自身的那个元素）。<br />查找的同时可以通过<strong>路径压缩</strong>来将均摊复杂度降低为<span class="math inline">\(O(1)\)</span>。查找某个结点时，将其经过的全部结点直接连到根结点，这样下次的查询次数就会急剧减小。</li><li>Union<br />合并时可以遵循<strong>按秩合并</strong>原则，将秩小的树合并到秩大的树，降低合并时路径压缩的开销。<br />将两个不同的集合合并，只要将其中一个集合的根结点的<code>parent</code>指向另一个集合的根结点即可。<br />对于属于同一个集合的两个元素的合并没有意义，所以我们一般只对两个不同的集合进行合并，这样避免同一个集合成环，因此并查集的每个集合都是一棵树。</li></ul><p>并查集可以将均摊复杂度变为<span class="math inline">\(O(1)\)</span>，但如果涉及到删除元素、计算每个集合元素个数等操作时，实现会有些复杂；<br />好吧！计算每个集合元素个数以及统计有多少个集合并不复杂，计算元素个数可以开一个数组cnt初始全为1，每次merge都更新cnt即可，cnt[i]即为根为i的集合包含的元素个数<br />统计多少个集合遍历所有元素，遇到不同的根结点就更新ans。</p><p><a href="https://www.zxpblog.cn/2020/02/17/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%AD%97%E5%85%B8%E6%A0%91%E5%92%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/">最原始的并查集</a>虽然复杂度稍差，但是可以完成的功能比较多。<br /><a href="https://www.cnblogs.com/EIMadrigal/p/12693959.html">原始并查集实现</a></p><p>一道例题：<a href="https://www.luogu.com.cn/problem/P1551">亲戚</a><br />不做路径压缩可以求<a href="https://www.nowcoder.com/profile/135924065/codeBookDetail?submissionId=83987857">最小环长</a></p><h2 id="无向图判环">无向图判环</h2><p>并查集可以用来检测无向图是否有环.<br />初始时认为每个节点都是独立的集合, 如果在加入边<span class="math inline">\((i,j)\)</span>之前节点<span class="math inline">\(i\)</span>和节点<span class="math inline">\(j\)</span>已经同属一个集合, 意味着节点<span class="math inline">\(i\)</span>和节点<span class="math inline">\(j\)</span>必然有某条其他路径连通, 该路径和边<span class="math inline">\((i,j)\)</span>必然构成环. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;  <span class="comment">// edge list</span></span><br><span class="line">g.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">g.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">g.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> rootx = <span class="built_in">Find</span>(g[i].first);</span><br><span class="line">        <span class="keyword">int</span> rooty = <span class="built_in">Find</span>(g[i].second);</span><br><span class="line">        <span class="keyword">if</span> (rootx == rooty) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Union</span>(rootx, rooty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="种类并查集todo">种类并查集（TODO）</h2><p>普通并查集的特点就是只有一个集合，比如上述例题只有亲戚一个集合。如果涉及到多个集合，就需要种类并查集。<br />假如有n个集合，常用的手法就是开一个n倍大小的并查集。<br /><a href="https://www.luogu.com.cn/problem/P2024">食物链</a><br /><a href="https://www.luogu.com.cn/problem/P1892">团伙</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List-3</title>
      <link href="/2020/01/26/Linked%20List-3/"/>
      <url>/2020/01/26/Linked%20List-3/</url>
      
        <content type="html"><![CDATA[<p>第一篇<a href="https://www.cnblogs.com/EIMadrigal/p/12130882.html">终结Linked List（一）</a>、<a href="https://www.cnblogs.com/EIMadrigal/p/12130892.html">终结Linked List（二）</a>主要讲了单链表的基础知识，接下来的第二篇主要讲一些比较经典的问题。</p><h2 id="一count">一、<code>Count()</code></h2><p>给一个单链表和一个整数，返回这个整数在链表中出现了多少次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Given a list and an int, return the number of times </span><br><span class="line">that int ocucurs in the list.</span><br><span class="line">*/</span><br><span class="line">int Count(struct node* head,int searchFor)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    struct node* cur = head;</span><br><span class="line"></span><br><span class="line">    while (cur != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (cur-&gt;data == searchFor)</span><br><span class="line">            cnt++;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用<code>for</code>循环实现。</p><h2 id="二getnth">二、<code>GetNth()</code></h2><p>给一个单链表和一个index，返回index位置上的数值，类似<code>array[index]</code>操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Given a list and an index, return the data in the nth</span><br><span class="line">node of the list. The nodes are numbered from 0.</span><br><span class="line">Assert fails if the index is invalid (outside 0..length - 1).</span><br><span class="line">*/</span><br><span class="line">int GetNth(struct node* head,int index)</span><br><span class="line">&#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    struct node* cur = head;</span><br><span class="line"></span><br><span class="line">    while (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        if (len == index)</span><br><span class="line">        &#123;</span><br><span class="line">            return cur-&gt;data;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(0);  //如果走到这一行，表达式的值为假，断言失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三deletelist">三、<code>DeleteList()</code></h2><p>给一个单链表，删除所有节点，使<code>head</code>为<code>NULL</code>。 删除链表<code>&#123;1,2,3&#125;</code>的示意图：<br /><img src="https://img-blog.csdnimg.cn/201904071952350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void DeleteList(struct node** headRef)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* cur = *headRef;  //deref headRef to get the real head</span><br><span class="line"></span><br><span class="line">    while (*headRef)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = *headRef;</span><br><span class="line">        *headRef = cur-&gt;next;</span><br><span class="line">        free(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四pop">四、<code>Pop()</code></h2><p>给一个链表，删掉头节点，返回头节点的数据。<br />内存示意图：<br /><img src="https://img-blog.csdnimg.cn/20190407230157807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">The opposite of Push().Takes a non-empty list and </span><br><span class="line">remove the front node, and returns the data which was in that node.</span><br><span class="line">*/</span><br><span class="line">int pop(struct node** headRef)</span><br><span class="line">&#123;</span><br><span class="line">    assert(*headRef != NULL);</span><br><span class="line">    int ans = (*headRef)-&gt;data;  //pull out the data before the node is deleted</span><br><span class="line"></span><br><span class="line">    struct node* cur = *headRef;</span><br><span class="line">    *headRef = (*headRef)-&gt;next;   //unlink the head node for the caller</span><br><span class="line">    free(cur);    //free the head node</span><br><span class="line"></span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五insertnth">五、<code>InsertNth()</code></h2><p>可以在<code>[0,length]</code>的任意位置插入指定元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">A more general version of Push().</span><br><span class="line">Given a list, an index &#x27;n&#x27; in the range 0..length,</span><br><span class="line">and a data element, add a new node to the list so that</span><br><span class="line">it has the given index.</span><br><span class="line">*/</span><br><span class="line">void InsertNth(struct node** headRef,int index,int data)</span><br><span class="line">&#123;</span><br><span class="line">    //position 0 is a special case</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(headRef, data);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        struct node* cur = *headRef;</span><br><span class="line"></span><br><span class="line">        while (cnt &lt; index - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            assert(cur != NULL);   //if this fails, the index was too big</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assert(cur != NULL);    //tricky:you have to check one last time</span><br><span class="line"></span><br><span class="line">        Push(&amp;(cur-&gt;next), data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码坑有点多，可以通过<strong>画图</strong>或者<strong>单步跟踪</strong>的方法调试。<br /><code>InsertNthTest()</code>可以用来测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void InsertNthTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;   //start with the empty list</span><br><span class="line">     </span><br><span class="line">    InsertNth(&amp;head, 0, 13);   //&#123;13&#125;</span><br><span class="line">    InsertNth(&amp;head, 1, 42);    //&#123;13,42&#125;</span><br><span class="line">    InsertNth(&amp;head, 1, 5);     //&#123;13,5,42&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六sortedinsert">六、<code>SortedInsert()</code></h2><p>给定一个有序链表和一个节点，将该节点插入到合适的位置。 共有三种方法： 1、Uses special case code for the head end <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void SortedInsert(struct node** headRef,struct node* newNode)</span><br><span class="line">&#123;</span><br><span class="line">    //Special case for the head end</span><br><span class="line">    if (newNode-&gt;data &lt;= (*headRef)-&gt;data || *headRef == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        newNode-&gt;next = *headRef;</span><br><span class="line">        *headRef = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //Locate the node before the point of insertion</span><br><span class="line">        struct node* cur = *headRef;</span><br><span class="line">        while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;data &lt; newNode-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2、Dummy node strategy for the head end 用<code>dummy node</code>这种方法一般不需要处理特殊情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void SortedInsert2(struct node** headRef,struct node* newNode) &#123;</span><br><span class="line">    struct node dummy;</span><br><span class="line">    struct node* cur = &amp;dummy</span><br><span class="line">    dummy.next = *headRef;</span><br><span class="line"></span><br><span class="line">    while (cur-&gt;next &amp;&amp; newNode-&gt;data &gt;= cur-&gt;next-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;next = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = newNode;</span><br><span class="line"></span><br><span class="line">    *headRef = dummy.next;  //头指针永远指向dummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Local references strategy for the head end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void SortedInsert3(struct node** headRef,struct node* newNode)</span><br><span class="line">&#123;</span><br><span class="line">    struct node** curRef = headRef;</span><br><span class="line"></span><br><span class="line">    while (*curRef &amp;&amp; (*curRef)-&gt;data &lt;= newNode-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        curRef = &amp;((*curRef)-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;next = *curRef;  //Bug:(*curRef)-&gt;next  is incorrect</span><br><span class="line"></span><br><span class="line">    *curRef = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表反转">链表反转</h2><p>链表反转的题目都是套路, 如果要反转<span class="math inline">\([l,r)\)</span>内的部分, 需要记录l的前一个结点. 让<code>cur = l, prev = r</code>, 循环次数等于<span class="math inline">\([l,r)\)</span>内的结点数, 每次循环都是标准操作: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp = cur.next  </span><br><span class="line">cur.next = prev  </span><br><span class="line">prev = cur  </span><br><span class="line">cur = tmp </span><br></pre></td></tr></table></figure></p><p>最终<code>cur</code>指向r, <code>prev</code>指向反转后的第一个结点即原链表的r - 1.<br />头结点主要看你是反转整个链表还是一部分，反转整个链表就没必要了，因为l直接指向头结点<br />92题可以直接按照上述方法做，但是开始要把r指向正确的位置，相当于多走了一遍，因此开始把prev设置为None，反转结束先通过l前一个结点修正l的指针指向cur，再让l前一个结点指向prev</p><p>25题因为要分组反转，所以需要判断剩余的结点够不够k个，因此r必然需要向后走一遍去判断，因此[l,r)肯定要走2遍。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minimum Spanning Tree</title>
      <link href="/2020/01/26/Minimum%20Spanning%20Tree/"/>
      <url>/2020/01/26/Minimum%20Spanning%20Tree/</url>
      
        <content type="html"><![CDATA[<p>最小生成树算法用来在<strong>无向带权图</strong>中寻找一组边的集合, 该边集使得图中所有顶点连通, 没有环路并且权值和最小. 常见的MST算法包括Kruskal和Prim. <a href="https://github.com/EIMadrigal/Recap/blob/main/Templates/Basics/mst.cpp">实现在这里</a></p><h2 id="kruskal">Kruskal</h2><p>将所有边的权值递增排序, 如果选择权值最小的边加入后不构成回路, 则将该边加入MST, 直到MST中有<span class="math inline">\(n-1\)</span>条边或<span class="math inline">\(n\)</span>个顶点.</p><p>那么如何判断加入边是否构成回路呢? 方法有很多啦, <strong>并查集</strong>是一个不错的选择. 每次加边时如果该边的两顶点<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>在同一个集合, 就判断下条边, 否则将该边加入答案并合并<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>.</p><p>遍历完成后, 所有顶点都同属一个集合, 因此可以通过判断顶点<span class="math inline">\(i\)</span>和<span class="math inline">\(i+1\)</span>是否同属一个集合, 进而判断该图是否连通.</p><p>用<strong>边集</strong>表示图比较方便, 复杂度<span class="math inline">\(O(ElogE)\)</span>, 适合边稀疏而顶点相对多的图.</p><h2 id="prim">Prim</h2><p>Prim算法的思想是:</p><ol type="1"><li>整个顶点集为<span class="math inline">\(V\)</span>，初始选一个起点<span class="math inline">\(s\)</span>，令集合<span class="math inline">\(U=\{s\}, V=\{\}\)</span>;</li><li>在集合<span class="math inline">\(U\)</span>与集合<span class="math inline">\(V-U\)</span>中的点组成的边中，选一条权值最小的边<span class="math inline">\(u_0v_0\)</span>加入MST，并且将<span class="math inline">\(u_0\)</span>加入<span class="math inline">\(U\)</span>;</li><li>重复直到MST有<span class="math inline">\(n-1\)</span>条边或<span class="math inline">\(n\)</span>个顶点为止.</li></ol><p>因此, 需要一个<code>unordered_set</code>表示已经访问过的顶点集合<span class="math inline">\(U\)</span>, 还需要一个<code>priority_queue</code>维护集合<span class="math inline">\(U\)</span>与集合<span class="math inline">\(V-U\)</span>之间的边权和dest.</p><p>用<strong>邻接表</strong>表示图比较方便, 复杂度<span class="math inline">\(O(V^2)\)</span>, 适合边稠密的图.</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯学习</title>
      <link href="/2020/01/18/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/01/18/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>贝叶斯概率理论是由Thomas Bayes在1764年提出，采用一种概率的方式进行推理。贝叶斯学习有2个假设： - 观察到的样本实例并非确定性事件，而是随机的，服从某种概率分布； - 通过对观测数据样本和相关的概率特性进行推理学习能够得到最优的决策或分类。</p><p>贝叶斯学习为衡量多个假设的置信度提供了定量的方法，其依赖于贝叶斯决策理论（Bayesian Decision Theory）。贝叶斯决策理论是一种统计学上的方法，用来定量化地描述使用概率做出的不同决策以及这些决策付出的代价之间的权衡。首先假设一些概率值是已知的，然后根据这些已知概率推理一些未知情况下的概率值，最终利用这些推理的概率值进行决策。</p><p>以分类问题为例，假设有2种鱼分别是鲑鱼和鲈鱼，将w定义为观测到的鱼的类型，令<span class="math inline">\(w=w_1\)</span>代表鲈鱼，<span class="math inline">\(w=w_2\)</span>代表鲑鱼，定义<span class="math inline">\(P(w_1)\)</span>表示下一条鱼是鲈鱼的先验概率，<span class="math inline">\(P(w_2)\)</span>表示下一条鱼是鲑鱼的先验概率。先验概率反映了人们根据经验和背景知识对事物的判断，即在看到下一条鱼之前对于<span class="math inline">\(P(w_1)\)</span>和<span class="math inline">\(P(w_2)\)</span>的判断。如果没有经验上的偏好，就可以设置为均匀先验<span class="math inline">\(P(w_1)=P(w_2)\)</span>；如果有诸如海域因素、时间等背景，便可以为<span class="math inline">\(P(w_1)\)</span>和<span class="math inline">\(P(w_2)\)</span>设置不同的先验概率。另外假设只有这2种鱼，即<span class="math inline">\(P(w_1)+P(w_2)=1\)</span>。在仅有先验概率的情况下，选择先验概率大的作为最终决策，这种情况下决策错误的概率为<span class="math inline">\(min\{P(w_1),P(w_2)\}\)</span>。</p><p>贝叶斯决策理论是很多重要的学习算法的基础，例如朴素贝叶斯分类器、贝叶斯信念网络以及EM算法等。另外，贝叶斯决策理论为许多非贝叶斯的学习算法提供了很好的数学和框架性理论基础，对某些学习任务而言，贝叶斯学习是最实用的方法之一。</p><p>贝叶斯学习有以下特点： - 每个观测到的训练样本都可以很小程度上增大或减小某个假设正确的概率； - 先验知识可以和观测数据结合起来决定某个假设的最终概率，可以计算显式的假设概率； - 新实例的预测可以结合多个假设输出概率的加权值； - 通常需要一些背景知识或先前经验来确定先验概率，选出贝叶斯最优分类器计算代价比较大。</p><h2 id="贝叶斯定理">贝叶斯定理</h2><p>贝叶斯定理是贝叶斯学习的基石，给定训练数据集D，在假设空间H中寻找最优的假设h，最优假设可以定义为给定数据集D以及H中不同假设的先验概率条件下的最可能的假设。 利用贝叶斯定理，在已知假设的先验概率、观测数据以及给定假设下观测到特定数据的概率就可以计算出最有可能的假设。</p><p>给定数据集D以及假设空间H，定义如下记号： - 先验概率P(h)：没有训练数据前假设h的初始概率，反映了根据人们的相关认知背景，假设h成为正确假设的概率，如果没有先验知识，可以将每一个候选假设的先验概率设置为相同的。 - 先验概率P(D)：训练数据D的先验概率，即不知道哪个假设成立的前提下观测到D的概率。 - 观测数据的条件概率P(D|h)：在假设h成立的条件下观测到数据集D的概率。 - 后验概率P(h|D)：给定观测到的训练数据集D时假设h成立的概率，反映了观测到的训练数据是D时h成立的置信度。</p><p>利用贝叶斯定理可以计算给定训练数据集D下任一假设的后验概率： <span class="math display">\[P(h|D)=\frac{P(D|h)P(h)}{P(D)}\]</span></p><p>贝叶斯推理得到的结果很大程度上依赖于先验概率，并且不是完全接受或拒绝假设h，而是给出假设为真的可能性。因此可以计算每个假设的概率，输出其中概率最大的，称为最大后验概率准则（Maximum A Posteriori）。</p><p><span class="math display">\[h_{MAP}=\underset{h\in H}{\operatorname{\argmax}}\ P(h|D) \\=\underset{h\in H}{\operatorname{\argmax}}\ \frac{P(D|h)P(h)}{P(D)} \\=\underset{h\in H}{\operatorname{\argmax}}\ P(D|h)P(h)\]</span></p><p>如果假设空间中每个假设的先验概率都是相同的，即<span class="math inline">\(P(h_i)=P(h_j),\forall h_i\in H \wedge \forall h_j\in H\)</span>，那么只需要考虑给定假设h下数据D的似然P(D|h)，这样最大后验概率准则就变为了最大似然估计（Maximum Likelihood）： <span class="math display">\[h_{ML}=\underset{h\in H}{\operatorname{\argmax}}\ P(D|h)\]</span></p><h2 id="最小描述长度原则">最小描述长度原则</h2><p>根据奥卡姆剃刀原则，其它条件相同时选择最简单的假设，最简单的假设可以定义为描述长度最小的假设，即给定假设空间H和数据集D，应该寻找一个假设或者假设组合使得D被最大程度地压缩。定义<span class="math inline">\(L_{C}(x)\)</span>表示在编码机制C下编码x需要的最少的比特数为编码机制C下的x的描述长度。 <span class="math display">\[h_{MDL}=\underset{h\in H}{\operatorname{\argmin}}\ L_{C_1}(h)+L_{C_2}(D|h)\]</span></p><p><span class="math inline">\(L_{C_1}(h)\)</span>是假设的描述长度即比特数，反映了模型的复杂程度；<span class="math inline">\(L_{C_2}(D|h)\)</span>是当采用假设h编码后数据的描述长度，反映了错误的数目。通常会发现：一个非常复杂的假设（<span class="math inline">\(L_{C_1}(h)\)</span>大）会有一个比较好的拟合（<span class="math inline">\(L_{C_2}(D|h)\)</span>小），反之一个非常简单的假设（<span class="math inline">\(L_{C_1}(h)\)</span>小）会有比较差的拟合（<span class="math inline">\(L_{C_2}(D|h)\)</span>大）。因此希望寻找一个假设：既不会过于复杂同时还可以对数据有比较好的拟合。</p><p>如果对MAP的公式进行变形： <span class="math display">\[h_{MAP}=\underset{h\in H}{\operatorname{\argmax}}\ P(D|h)P(h) \\=\underset{h\in H}{\operatorname{\argmax}}\ log_2P(D|h)+log_2P(h) \\=\underset{h\in H}{\operatorname{\argmin}}\ -log_2P(h)-log_2P(D|h) \\\]</span></p><p>可以看到：第一项<span class="math inline">\(-log_2P(h)\)</span>对应了最优编码机制<span class="math inline">\(C_1\)</span>下h的描述长度<span class="math inline">\(L_{C_1}(h)\)</span>，第二项<span class="math inline">\(-log_2P(D|h)\)</span>对应了最优编码机制<span class="math inline">\(C_2\)</span>下数据的描述长度<span class="math inline">\(L_{C_2}(D|h)\)</span>。两者的优化目标是一致的。</p><h2 id="贝叶斯最优分类器">贝叶斯最优分类器</h2><p>通过MAP准则可以求出在给定训练数据下的最有可能的假设，那么如何求出给定训练集下一个新实例的最优预测呢？可以对新实例使用MAP准则，求得最大的假设然后进行分类。</p><p>但是最优的结果应该是结合所有假设的预测结果对新实例进行分类，结合的方法是通过后验概率加权： <span class="math display">\[\underset{v_j\in V}{\operatorname{\argmax}}\ \sum_{h_i\in H}P(v_j|h_i)P(h_i|D)\]</span></p><p>V表示所有可能的预测结果，<span class="math inline">\(v_j\)</span>是其中一种预测分类。<span class="math inline">\(P(v_j|h_i)\)</span>表示假设<span class="math inline">\(h_i\)</span>将新实例预测为<span class="math inline">\(v_j\)</span>的概率大小，<span class="math inline">\(P(h_i|D)\)</span>表示假设<span class="math inline">\(h_i\)</span>的后验概率。</p><p>例如假设空间<span class="math inline">\(H=\{h_1,h_2,h_3\}\)</span>，可能的预测结果<span class="math inline">\(V=\{+,-\}\)</span>，对于一个新实例假设有： <span class="math display">\[P(h_1|D)=0.4, P(-|h_1)=0, P(+|h_1)=1 \\P(h_2|D)=0.3, P(-|h_2)=1, P(+|h_2)=0 \\P(h_3|D)=0.3, P(-|h_3)=1, P(+|h_3)=0 \\\]</span></p><p>那么有： <span class="math display">\[\sum_{h_i\in H}P(+|h_i)P(h_i|D)=0.4 \\\sum_{h_i\in H}P(-|h_i)P(h_i|D)=0.6 \\\]</span> 因此最终选择将新实例分类为-。</p><p>可以看到：贝叶斯最优分类器最大化了新实例被正确分类的概率，在使用相同假设空间和先验知识的条件下，没有其他方法比贝叶斯最优分类器的平均效果好，最终的预测结果可能对应一个不包含于<span class="math inline">\(H\)</span>的假设。</p><p>虽然效果很好，但是贝叶斯最优分类器计算代价非常大： - 需要遍历假设空间中的所有假设； - 当假设空间非常大时这种方式是不可行的。</p><p>因此可以通过吉布斯算法（Gibbs）解决。吉布斯算法根据假设的后验概率分布随机选取一个假设对新实例进行分类。可以证明：在特定条件下，该方法的期望误差最多是贝叶斯最优分类器的两倍。还可以通过采样多个假设并求其预测结果的平均值来提高吉布斯算法的性能，例如可以使用马尔科夫蒙特卡洛采样（MCMC）。</p><h2 id="bagging分类器">Bagging分类器</h2><p>虽然可以使用吉布斯算法来降低计算代价，但是从后验概率分布P(h|D)采样是比较困难的： - P(h|D)的计算本身就比较困难 - 对于不是基于概率的分类器例如SVM等P(h|D)是无法计算的 - 当假设空间很大时P(h|D)计算结果会很小</p><p>为了解决上述问题，引入Bagging的思想，通过对训练样本的采样实现对后验分布P(h|D)的采样。假设给定的数据集D包含m个样本，自助采样法（Bootstrap sampling）步骤如下： - 从D中有放回地采样m个样本构成数据集<span class="math inline">\(D^i\)</span> - D中大约有37%的样本不会被采样到</p><p>Bagging算法步骤如下： - 创建k个自助采样的数据集<span class="math inline">\(D^1,D^2,...,D^k\)</span> - 在每个数据集<span class="math inline">\(D^i\)</span>独立训练分类器<span class="math inline">\(h_i\)</span> - 通过相等权重的投票法来对新实例进行分类：</p><p><span class="math display">\[c^*(x)=\underset{c}{\operatorname{\argmax}}\ \sum_{i=1}^{k}P(c|h_i,x)\]</span> 由于自助采样法几乎和直接从后验概率分布P(h|D)采样相同，因此Bagging产生的分类器也近似于贝叶斯最优分类器。通常Bagging产生的分类器效果要优于单独的分类器，因为其有效地降低了模型的方差。</p><h2 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h2><p>假设训练集D中的每条实例x均可以被n个属性的组合<span class="math inline">\(&lt;a_1,a_2,...,a_n&gt;\)</span>描述，并且<span class="math inline">\(v(x)\in V\)</span>是一个有限的集合。那么贝叶斯方法对于新实例的分类是选择一个最有可能的目标值： <span class="math display">\[v_{MAP}=\underset{v_j\in V}{\operatorname{\argmax}}\ P(v_j|a_1,a_2,...,a_n)\]</span></p><p>通过贝叶斯定理进行变形： <span class="math display">\[v_{MAP}=\underset{v_j\in V}{\operatorname{\argmax}}\ \frac{P(a_1,a_2,...,a_n|v_j)P(v_j)}{P(a_1,a_2,...,a_n)}\]</span></p><p>那么要如何计算<span class="math inline">\(P(v_j)\)</span>和<span class="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>呢？ - <span class="math inline">\(P(v_j)\)</span>可以通过每个目标值<span class="math inline">\(v_j\)</span>在训练数据中出现的频率来估算 - 在训练数据集很小的情况下，<span class="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>的估算是不可能的，不同的<span class="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>的数目等于所有可能的目标值的数量与所有可能的样本数目的乘积。</p><p>为了解决上述问题，提出了朴素贝叶斯假设，即在给定目标值下样本属性之间是条件独立的： <span class="math display">\[P(a_1,a_2,...,a_n|v_j)=\prod_{i}P(a_i|v_j)\]</span></p><p>因此朴素贝叶斯分类器即为： <span class="math display">\[v_{NB}=\underset{v_j\in V}{\operatorname{\argmax}}\ P(v_j)\prod_{i}P(a_i|v_j)\]</span></p><p>其中，<span class="math inline">\(v_{NB}\)</span>是朴素贝叶斯分类器的预测输出，<span class="math inline">\(P(a_i|v_j)\)</span>是训练数据中目标值<span class="math inline">\(v_j\)</span>时属性<span class="math inline">\(a_i\)</span>的频率。不同的<span class="math inline">\(P(a_i|v_j)\)</span>的数目等于不同的目标值数量与属性数量的乘积，该数值远小于不同的<span class="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>的数目。</p><p>下面举一个朴素贝叶斯分类器的例子，假设训练数据如下： <img src="https://img-blog.csdnimg.cn/286e8b45687d4d259b1ef6ba87433c2f.png" alt="在这里插入图片描述" /></p><p>需要对于一个新实例{Outlook=sunny, Temperature=cool, Humidity=high, Wind=strong}进行分类，所有可能的目标值是{yes, no}。因此分类器为： <span class="math display">\[v_{NB}=\underset{v_j\in \{yes,no\}}{\operatorname{\argmax}}\ P(v_j)\prod_{i}P(a_i|v_j)\]</span></p><p>从训练数据可知，<span class="math inline">\(P(v_j)\)</span>即不同目标值的概率为： <span class="math display">\[P(yes)=9/14=0.64, P(no)=5/14=0.36\]</span></p><p>条件概率<span class="math inline">\(P(a_i|v_j)\)</span>为： <span class="math display">\[P(Wind=strong|yes)=3/9=0.33 \\P(Wind=strong|no)=3/5=0.60 \\...\]</span></p><p>因此可以计算： <span class="math display">\[P(yes)P(sunny|yes)P(cool|yes)P(high|yes)P(strong|yes)=0.0053 \\P(no)P(sunny|no)P(cool|no)P(high|no)P(strong|no)=0.0206 \\\]</span></p><p>故最终的预测结果为no。</p><h2 id="贝叶斯信念网络">贝叶斯信念网络</h2><p>贝叶斯最优分类器应用起来代价太大，朴素贝叶斯分类器虽然使用条件独立假设降低了代价，但是很多情况下条件独立假设都难以满足。因此，贝叶斯信念网络做了一个折衷，允许对属性集合的子集应用条件独立假设。</p><p>贝叶斯信念网络是一种概率图模型，通过有向无环图（DAG）来表示一系列变量及它们的条件依赖关系和变量集合的联合概率分布。通常用结点表示变量，可以是观测变量、隐藏变量、未知参数和假设等等；用边表示结点间的依赖关系；条件概率表的每个元素对应图中唯一的结点，存储该结点对于其所有直接前驱结点的联合条件概率。</p><p>贝叶斯信念网络一条非常重要的性质是：每个结点在其直接前驱结点的值给定后，该结点条件独立于其所有非直接前驱结点。条件独立的定义是：在给定Z的条件下X的概率分布与Y的取值无关，即： <span class="math display">\[\forall x_i,y_j,z_k\ P(X=x_i|Y=y_j,Z=z_k)=P(X=x_i|Z=z_k)\]</span></p><p>条件独立的定义可以扩展到多个变量的情形：即在给定变量<span class="math inline">\(Z_1,...,Z_n\)</span>的条件下，变量集合<span class="math inline">\(X_1,...,X_l\)</span>的概率分布与变量集合<span class="math inline">\(Y_1,...,Y_m\)</span>的取值无关： <span class="math display">\[P(X_1,...,X_l|Y_1,...,Y_m,Z_1,...,Z_n)=P(X_1,...,X_l|Z_1,...,Z_n)\]</span></p><p>朴素贝叶斯分类器即使用了条件独立假设使得<span class="math inline">\(P(X,Y|Z)=P(X|Y,Z)P(Y|Z)=P(X|Z)P(Y|Z)\)</span>。</p><p>贝叶斯网络也可以看作是表示变量之间因果性的因果图，可以进行原因推理或结果预测。例如，假设草坪是湿的记作变量W，那么有多大概率是因为下雨（记作变量R）造成的？那么可以利用贝叶斯网络进行原因推理： <span class="math display">\[P(R|W)=\frac{P(W|R)P(R)}{P(W)}=\frac{P(W|R)P(R)}{P(W|R)P(R)+P(W|\sim R)P(\sim R)}\]</span></p><p>同样可以进行结果的预测，假设洒水器打开记作事件S，那么有多大概率草坪是湿的是因为S导致的？即洒水器和下雨都可能导致草坪是湿的： <span class="math display">\[P(W|S)=P(W|R,S)P(R|S)+P(W|\sim R,S)P(\sim R|S) \\=P(W|R,S)P(R)+P(W|\sim R,S)P(\sim R)\]</span></p><p>随着贝叶斯网络的结点与边的增加，可以进行更加复杂的因果推断。</p><h2 id="总结">总结</h2><p>贝叶斯学习为基于先验知识的概率学习方法提供了理论基础，在先验知识的基础上，根据观测数据修正先验知识，计算出每个假设的后验概率进而进行预测。可以选择出在给定观测数据下的最有可能的假设即MAP假设，贝叶斯最优分类器通过后验概率的加权结合了所有可能假设的预测结果去得到新实例的最有可能的预测结果。朴素贝叶斯分类器通过条件独立假设增强了其实用性，在很多实际应用中表现很好。贝叶斯信念网络提供了一种条件独立的变量之间更强大的表示方法，使得其可以有更加广泛的应用场景。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Segment Tree</title>
      <link href="/2020/01/15/Segment%20Tree/"/>
      <url>/2020/01/15/Segment%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="引言">引言</h2><p><a href="https://leetcode.com/problems/range-sum-query-mutable/">Leetcode307</a>这道题如果没有优化, 那么单次query的时间复杂度<span class="math inline">\(O(n)\)</span>, 单次update复杂度<span class="math inline">\(O(1)\)</span><br />如果用前缀和数组, 那么单次query的时间复杂度<span class="math inline">\(O(1)\)</span>, 单次update复杂度<span class="math inline">\(O(n)\)</span>, 因为update(i)会使得前缀和数组i以后的元素均更新</p><p>因此如果query和update非常多次, 上面的2种方式效率都比较低.</p><p>这道题除了使用树状数组，还可以使用线段树。<br />线段树是一种平衡二叉树，支持快速区间查找<span class="math inline">\(O(lgn+k)\)</span>和更新<span class="math inline">\(O(lgn)\)</span>。</p><h2 id="线段树">线段树</h2><p><a href="https://github.com/EIMadrigal/Recap/blob/main/Templates/Advanced/segment_tree.cpp">具体实现在这里</a> 线段树核心思想是叶子结点负责保存原始信息，非叶结点负责其孩子表示范围的union，可以是求和、最值等： <img src="https://img-blog.csdnimg.cn/20200115103411544.png" alt="在这里插入图片描述" /> 对于每个结点，需要存储起始点、终止点、值、左右指针：</p><p>建树可以通过递归方式进行：</p><p>对于<strong>更新</strong>操作，只要找到叶子结点，一路向上更新至根结点，复杂度<span class="math inline">\(O(lgn)\)</span>：</p><p>对于<strong>查询</strong>操作，查询范围有三种情况：</p><ol type="1"><li>范围正好和根结点负责的范围一致，直接返回；</li><li>范围由某个下层结点负责，找到该结点返回其值；</li><li>范围由两个下层结点组合负责，返回两个结点的sum。</li></ol><p>查询最好情况复杂度<span class="math inline">\(O(1)\)</span>，最坏情况<span class="math inline">\(O(lgn+k)\)</span>，<span class="math inline">\(k\)</span>是某层结点的数目：</p><h2 id="reference">Reference</h2><ul><li><a href="https://zxi.mytechroad.com/blog/sp/segment-tree-sp14/">花花酱 Segment Tree 线段树 SP14</a></li><li><a href="https://www.cnblogs.com/TenosDoIt/p/3453089.html">一步一步理解线段树</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Indexed Tree</title>
      <link href="/2020/01/13/Binary%20Index%20Tree/"/>
      <url>/2020/01/13/Binary%20Index%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="引言">0 引言</h2><p><a href="https://leetcode.com/problems/range-sum-query-mutable/">Leetcode307</a> 这道题给一个<strong>可变</strong>数组，求从<span class="math inline">\(i\)</span>到<span class="math inline">\(j\)</span>的元素之和。 一个naive的做法是，每次查询都从<span class="math inline">\(i\)</span>累加到<span class="math inline">\(j\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        nums_ = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        nums_[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = i;l &lt;= j;++l)</span><br><span class="line">            ans += nums_[l];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法每次更新的复杂度为<span class="math inline">\(O(1)\)</span>，<strong>每次查询</strong>的复杂度为<span class="math inline">\(O(n)\)</span>。</p><h2 id="树状数组">树状数组</h2><p>树状数组可以在<span class="math inline">\(O(lgn)\)</span>时间复杂度内完成下面两个操作： 1. 计算前缀和（意味着可以快速区间查询） 2. 单点更新</p><p>BIT并不需要定义树的结点和指针，而是维护了一个特殊的前缀和数组<code>prefix_sum_</code>，下面的例子均是1-indexed，调用BIT时需要传入原始索引+1。填充<code>prefix_sum_</code>的过程是这样的： <img src="https://img-blog.csdnimg.cn/259f7f2172354cdd86e4283efaa79e14.png" alt="在这里插入图片描述" /> 1. 按照索引的二进制表示，先看最低位，将所有最低位为1的数值直接存入T 2. 再看次低位为1的（即10结尾的），将该数和前一个数（共2个数）的和存入T 3. 再看以100结尾的，将该数及之前的3个数（共4个数）的和存入T 4. 再看以1000结尾的，将8个数的和存入T，以此类推...</p><p>填充好<code>prefix_sum_</code>后，就可以查询原始数组的前缀和并且更新原始数组。</p><h2 id="查询">查询</h2><p>假设要求前缀和A[1]+...+A[7]即<code>query(7)</code>，只需要<code>query(7)+query(6)+query(4)</code>即可，从二进制来看就是<code>query(00111)+query(00110)+query(00100)</code>，即每次将最后一位1翻转然后累加直到i变为0。</p><h2 id="更新">更新</h2><p>假设要更新A[4]即<code>update(4, 10)</code>，需要更新T[4]和T[8]，即<code>00100</code>和<code>01000</code>，即每次将最后一位1左移直到i超出数组长度，移位过程中更新相应的T[i]。</p><p>填充<code>prefix_sum_</code>可以直接调用<code>update</code>。</p><p>那么我们的tree： <img src="https://img-blog.csdnimg.cn/20200113151522944.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 0是dummy node，将结点的二进制表示的最后一个1翻转，就能得到其父结点。</p><p>下来填充这棵树： <span class="math inline">\(1=0+2^0\)</span>，存储从下标0开始的前1个数的和：3（0，0）； <span class="math inline">\(2=0+2^1\)</span>，存储从下标0开始的前2个数的和：5（0，1）； <span class="math inline">\(3=2^1+2^0\)</span>，存储从下标2开始的前1个数的和：-1（2，2）； <span class="math inline">\(4=0+2^2\)</span>，存储从下标0开始的前4个数的和：10（0，3）； <span class="math inline">\(5=2^2+2^0\)</span>，存储从下标4开始的前1个数的和：5（4，4）； <span class="math inline">\(6=2^2+2^1\)</span>，存储从下标4开始的前2个数的和：9（4，5）； <span class="math inline">\(7=2^2+2^1+2^0\)</span>，存储从下标6开始的前1个数的和：-3（6，6）； <span class="math inline">\(8=0+2^3\)</span>，存储从下标0开始的前8个数的和：19（0，7）； <span class="math inline">\(9=2^3+2^0\)</span>，存储从下标8开始的前1个数的和：7（8，8）； <span class="math inline">\(10=2^3+2^1\)</span>，存储从下标8开始的前2个数的和：9（8，9）； <span class="math inline">\(11=2^3+2^1+2^0\)</span>，存储从下标10开始的前1个数的和：3（10，10）； 填充后的tree： <img src="https://img-blog.csdnimg.cn/20200113154240511.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 接下来就可以根据这棵树来计算<code>prefixSums_</code>： 假如要计算<span class="math inline">\(0-5\)</span>的和，从下标6出发，一直加到dummy node，得到<code>prefixSums_[6]=9+10=19</code>； 要计算<span class="math inline">\(0-9\)</span>的和，从下标10出发，一直加到dummy node，得到<code>prefixSums_[10]=9+19=28</code>。 以计算<span class="math inline">\(0-9\)</span>的和为例，结点10存储的是（8，9）的<strong>部分和</strong>，结点8存储的是（0，7）的<strong>部分和</strong>，所以加起来就是<span class="math inline">\(0-9\)</span>的和。</p><h2 id="快速实现">快速实现</h2><p>上面求结点的父结点、将下标拆解为二进制去填充树的方式很慢，来看一种稍快的方式。 <strong>查询</strong>时，我们需要计算从某结点到dummy node的和，这就涉及计算该结点的parent： 假如要求结点7的parent，7的二进制原码为<code>111</code>，-7的补码为<code>001</code>，将原码和补码按位与得<code>001</code>，用原码减去<code>001</code>，得<code>110=6</code>，即7的父结点是6。 <strong>更新</strong>时，我们需要更新所有包含该结点的部分和结点： 假如更新了结点1，1的二进制原码为<code>001</code>，-1的补码为<code>111</code>，将原码和补码按位与得<code>001</code>，用原码加上<code>001</code>，得<code>010=2</code>，即还要更新结点2，更新了结点2，还要更新结点4...... 最后来看下非常<a href="https://github.com/EIMadrigal/Recap/blob/main/Templates/Advanced/binary_index_tree.cpp">简洁的实现</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) : <span class="built_in">matrix_</span>(matrix), <span class="built_in">tree_</span>(matrix.<span class="built_in">size</span>(), matrix[<span class="number">0</span>].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                tree_.<span class="built_in">update</span>(i + <span class="number">1</span>, j + <span class="number">1</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        tree_.<span class="built_in">update</span>(row + <span class="number">1</span>, col + <span class="number">1</span>, val - matrix_[row][col]);</span><br><span class="line">        matrix_[row][col] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree_.<span class="built_in">query</span>(row2 + <span class="number">1</span>, col2 + <span class="number">1</span>) + tree_.<span class="built_in">query</span>(row1, col1) - tree_.<span class="built_in">query</span>(row1, col2 + <span class="number">1</span>) - tree_.<span class="built_in">query</span>(row2 + <span class="number">1</span>, col1);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; matrix_;</span><br><span class="line">    BIT tree_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// NumMatrix numMatrix(matrix);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(0, 1, 2, 3);</span></span><br><span class="line"><span class="comment">// numMatrix.update(1, 1, 10);</span></span><br><span class="line"><span class="comment">// numMatrix.sumRegion(1, 2, 3, 4);</span></span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><a href="https://youtu.be/CWDQJGaN1gY">Fenwick Tree or Binary Indexed Tree</a><br /><a href="https://zxi.mytechroad.com/blog/sp/fenwick-tree-binary-indexed-tree-sp3/">花花酱 Fenwick Tree / Binary Indexed Tree SP3</a><br /><a href="youtube.com/watch?v=uSFzHCZ4E-8">Fenwick Tree</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search</title>
      <link href="/2020/01/11/Binary%20Search/"/>
      <url>/2020/01/11/Binary%20Search/</url>
      
        <content type="html"><![CDATA[<h2 id="基本型">基本型</h2><p>对于一个<strong>有序</strong>数组，查找某个元素，存在返回其index，否则返回-1。<br />二分查找有4个地方容易混淆：</p><ol type="1"><li><code>l</code>和<code>r</code>的初始化，即区间定义。可以是<span class="math inline">\([l,r]\)</span>，也可以是<span class="math inline">\([l,r)\)</span></li><li><code>while</code>的循环条件：可以是<code>&lt;</code>/<code>&lt;=</code></li><li><code>l</code>和<code>r</code>的更新：可以是<code>mid</code>/<code>mid+1</code>/<code>mid-1</code></li><li>返回值：可以是<code>l</code>/<code>r</code>/<code>mid</code>/其他值</li></ol><p>如果区间初始化为左闭右闭，循环条件就应该是小于等于，因为等于时待检查区间还有1个元素，需要继续；并且r的更新应该是mid-1，因为已经确定mid不是target且右边界是闭的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果区间定义为左闭右开，此时循环条件小于，等于时表示区间为空；当mid&gt;target时r应该为mid，因为mid不是target且右边界开，即下一次不会考虑mid。这种情况如果没找到最终必然有l==r</p><p>我最常用的板子是左闭右开<code>[l, r)</code>，因为这种方式保留了所有的可能性，比如在l位置插入或者在r位置插入，保留了r位置成为答案的可能。</p><p>一些隐晦的问题都隐藏着<strong>单调性</strong>，需要发掘最大值最小化/最小值最大化，或者说当你按顺序尝试每个可能的解并且要在其中找到最小或最大的时候，就考虑二分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums[m]) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[m]) l = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微扩展一些的题目有<code>lower_bound()</code>和<code>upper_bound()</code>:<br />对于<code>lower_bound()</code>，即查找满足<span class="math inline">\(x\geq target\)</span>的最小index： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; nums[m]) l = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可变形为查找最后一个小于<span class="math inline">\(target\)</span>的数：即<span class="math inline">\(l-1\)</span>。<br />对于<code>upper_bound()</code>，即查找满足<span class="math inline">\(x&gt;target\)</span>的最小<span class="math inline">\(x\)</span>的index： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[m]) l = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可变形为查找最后一个小于等于<span class="math inline">\(target\)</span>的数：即<span class="math inline">\(l-1\)</span>。</p><p>Leetcode 704/35/34/69/367</p><h2 id="rotated-sorted-array"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Rotated Sorted Array</a></h2><p>Find the index of the target if it is in the array, else return -1. All values of the array are <strong>unique</strong>.</p><p>We can find that at least half of the elements are sorted, so we should find out whether it's on the left or the right.</p><p>Let's see an example: [0,1,2,3]{all sorted}, [3,0,1,2]{right}, [2,3,0,1]{left or right}, [1,2,3,0]{left}.<br />Another example: [0,1,2,3,4]{all sorted}, [4,0,1,2,3]{right}, [3,4,0,1,2]{right}, [2,3,4,0,1]{left}, [1,2,3,4,0]{left}. It is important to know that the sorted side is <strong>at least half of the array</strong> (longer). So the mid is in this side.</p><p>We can compare nums[mid] with nums[left] (or nums[right]) to decide which side is sorted. If <code>nums[mid]&gt;nums[left]</code>, then left half is sorted, else right is sorted.</p><p>The second step is to compare the target with nums[mid] to narrow down the range.</p><ul><li>Left half is sorted.<br />If target&gt;nums[mid], it must lie in the right interval. So we can make left pointer forward left = mid + 1.<br /><img src="https://img-blog.csdnimg.cn/20210303220721888.png" alt="在这里插入图片描述" /><br />If target&lt;nums[mid], there exists 2 situations:<br /><img src="https://img-blog.csdnimg.cn/20210303214903684.png" alt="在这里插入图片描述" /><br />The first graph means target is less than mid but bigger than or equal to left, we move the right pointer toward left right = mid.<br />The second graph means target is less than left, thus we move the left pointer towards right left = mid + 1.</li></ul><p>Finally if nums[mid]==nums[left], it means that left and mid are pointing to the same element due to the distinct values. In this case right must be mid or mid + 1. Where is the target? It must be on the right side of mid (actually nums[right]) or it do not exist. So we can move the left pointer by 1 to see nums[right] is equal to target or not.</p><ul><li>Right half is sorted. You can analysis this by yourself.</li></ul><p>We can write the following code based on the previous discussion:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[m]:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]: <span class="comment"># left side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &gt; nums[m]:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &gt;= nums[l]:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]: <span class="comment"># right side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &lt; nums[m]:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt;= nums[r]:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="rotated-sorted-array-ii"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">Rotated Sorted Array II</a></h2><p>It is the same as the last one except that the array may contains <strong>duplicates</strong>. And you do not need to find the index but return true or false.</p><p>The code is the same except that you should return T or F.</p><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Find Minimum in Rotated Sorted Array</a> shares the same idea:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, nums[m])</span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[l])</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[m])</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="rotated-sorted-array-yyds"><a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/">Rotated Sorted Array yyds</a></h2><p>In this case you should return the index of the target in a duplicated array. If you do not know the idea above, this will be a little harder to solve since there are many corner cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[m]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, m)</span><br><span class="line">                r = m - <span class="number">1</span> <span class="comment"># do not return since there might be smaller index</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]: <span class="comment"># left side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &gt; nums[m]:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &gt;= nums[l]:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]: <span class="comment"># right side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &lt; nums[m]:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; nums[r]:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> target &gt; nums[r]:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> target == nums[l]:</span><br><span class="line">                            ans = <span class="built_in">min</span>(ans, l)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ans == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regular Expression</title>
      <link href="/2020/01/10/Regular%20Expression/"/>
      <url>/2020/01/10/Regular%20Expression/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p></blockquote><p>先看一个判断Email地址是否合法的例子： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\\w+@\\w+(\\.\\w&#123;2,3&#125;)*\\.\\w&#123;2,3&#125;&quot;</span></span><br></pre></td></tr></table></figure> 一般Email地址的格式为：<code>X@X.com</code>，<code>X</code>表示一个或多个字符，<code>.com</code>后面可能还会跟有<code>.cn</code>等。总结这些规律，我们用上述的regex来匹配。<br />当然，这种匹配可能会遗漏某些特殊的Email地址，想要更大范围的覆盖，还需要更为复杂精巧的设计。<br />接着解释下上面的regex：<br /><code>\\w</code>表示匹配字母/数字/下划线/汉字；<br /><code>+</code>表示字符可以出现一次/多次；<br /><code>(\\.\\w&#123;2,3&#125;)*</code>表示类似<code>.edu</code>格式的字符串可以出现零次/多次。<br /><code>\</code>在计算机科学中一般表示转义，形如<code>\w</code>的叫做<strong>元字符</strong>，类似的还有：</p><table><thead><tr class="header"><th>元字符</th><th>意义</th></tr></thead><tbody><tr class="odd"><td>.</td><td>除换行符外任意字符</td></tr><tr class="even"><td>数字</td><td></td></tr><tr class="odd"><td></td><td>字母/数字/汉字/下划线</td></tr><tr class="even"><td>单词的开始/结束</td><td></td></tr><tr class="odd"><td>^</td><td>字符串的开始</td></tr><tr class="even"><td>$</td><td>字符串的结束</td></tr></tbody></table><p>还可以通过<code>[]</code>表示元字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;[abc]23&quot;</span></span><br></pre></td></tr></table></figure><p>这样<code>a23</code>，<code>b23</code>，<code>c23</code>都是匹配的字符串。<br />形如<code>+</code>，<code>*</code>叫做<strong>修饰限定符</strong>，用来控制某类串重复多少次：</p><table><thead><tr class="header"><th>修饰限定符</th><th>意义</th></tr></thead><tbody><tr class="odd"><td>*</td><td>0次/多次</td></tr><tr class="even"><td>+</td><td>1次/多次</td></tr><tr class="odd"><td>？</td><td>0次/1次</td></tr><tr class="even"><td>{n}</td><td>n次</td></tr><tr class="odd"><td>{n,}</td><td>n次/更多次</td></tr><tr class="even"><td>{n,m}</td><td>n~m次</td></tr></tbody></table><p>很多语言和文本编辑器都集成了正则表达式引擎，以Java为例来测试下上述例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regex = <span class="string">&quot;\\w+@\\w+(\\.\\w&#123;2,3&#125;)*\\.\\w&#123;2,3&#125;&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;hello@stu.edu.cn&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.matches(regex))</span><br><span class="line">            System.out.println(<span class="string">&quot;Valid Address!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述内容只是最最基本的关于正则表达式的知识，还有零宽断言、递归匹配等更加复杂的内容有待挖掘~</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/2020/01/06/Dynamic%20Programming/"/>
      <url>/2020/01/06/Dynamic%20Programming/</url>
      
        <content type="html"><![CDATA[<p>DP是算法学习中非常重要的一种思想，关于动态规划的解释，可以参考<a href="https://www.zhihu.com/question/23995189/answer/613096905">这篇文章</a>。</p><h2 id="概念">概念</h2><p>使用DP三个条件：</p><ol type="1"><li>最优子结构：待解决的问题可以被分解为若干子问题，并且递归地找到子问题的最优解，从而得到全局最优解；</li><li>重叠子问题：在解决子问题的过程中，很多子问题都会被求解多次，第一次计算后存储该子问题的解，以后就可以直接使用，即降低了时间复杂度。如果子问题没有重叠，那么这就是<strong>分治</strong>的问题；</li><li>无后效性：子问题的最优解是确定的，完全可以用来解决更大的子问题。</li></ol><p>DP一般有两种形式：</p><ul><li>Top-down/memoization: 记忆化递归可能stackoverflow</li><li>Bottom-up：迭代计算</li></ul><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;  <span class="comment">// memory dict</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(i, j, ...)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">base_case</span><span class="params">(i, j)</span></span></span><br><span class="line"><span class="function"><span class="keyword">return</span> ...</span>;</span><br><span class="line">    <span class="keyword">if</span> (i, j) <span class="keyword">not</span> in hash</span><br><span class="line">        hash[(i, j)] = <span class="built_in">f</span>(...);</span><br><span class="line">    <span class="keyword">return</span> hash[(i, j)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">f</span>(n, m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DP</span></span><br><span class="line"><span class="keyword">int</span> dp[][];   <span class="comment">// need padding sometimes</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = ...;   <span class="comment">// base case</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j =  <span class="number">0</span>;j &lt; m;++j)</span><br><span class="line">        dp[i][j] = ...  <span class="comment">// 状态转移</span></span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br></pre></td></tr></table></figure><h2 id="分类">分类</h2><ul><li>基础题：LeetCode 509/70/746/62/63/343/96/<a href="https://www.cnblogs.com/EIMadrigal/p/11478906.html">Fibonacci</a></li><li>背包问题：<ul><li><a href="https://www.cnblogs.com/EIMadrigal/p/12345051.html">0/1 Knapsack</a>：LeetCode 416/1049/494/474</li><li><a href="https://www.cnblogs.com/EIMadrigal/p/12345051.html">Unbounded Knapsack</a>：LeetCode 518/377/70/322/279/139</li></ul></li><li>House Thief：LeetCode 198/213/337</li><li>股票问题：LeetCode 121/122/123/188/309/714</li><li>Longest Common Substring/Subsequeunce：LeetCode 300/1143/1035/674/718/53/392/115/583/72/647/516</li></ul><h2 id="步骤">步骤</h2><p>一般来讲，都是通过暴力-&gt;记忆化递归-&gt;Bottom-up三部曲，当然熟悉后可以快速判断这是一个DP问题，然后直接写出Bottom-up的解法。<br />我个人认为最难的一步在于判断出你的暴力解法满足DP的性质（你要能认出来这是一个DP问题），可以用DP去优化暴力解法。</p><ul><li>确定问题分类</li><li>确定状态：需要几个变量来跟踪目前的状态，一般来讲至少需要index，因为这决定了我们已经考虑过了哪些值，没考虑哪些值，正在考虑哪些值。选定的变量组合要能唯一确定一个状态</li><li>状态转移：为了达到base case，当前状态怎么才能由之前的状态得到。也就是Top-down逐渐分解问题，每一次递归调用都会分解一下</li><li>base case：一般比较简单，不废话了</li><li>code：思路清楚了，也不难</li><li>优化：一般优化空间复杂度</li></ul><h2 id="ref">Ref</h2><p><a href="https://leetcode.com/problems/target-sum/discuss/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions.">DP IS EASY! 5 Steps to Think Through DP Questions.</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是P问题、NP问题和NPC问题</title>
      <link href="/2020/01/01/%E4%BB%80%E4%B9%88%E6%98%AFP%E9%97%AE%E9%A2%98%E3%80%81NP%E9%97%AE%E9%A2%98%E5%92%8CNPC%E9%97%AE%E9%A2%98/"/>
      <url>/2020/01/01/%E4%BB%80%E4%B9%88%E6%98%AFP%E9%97%AE%E9%A2%98%E3%80%81NP%E9%97%AE%E9%A2%98%E5%92%8CNPC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>很久之前观看WJMZBMR特奖答辩时听到了<span class="math inline">\(P!=NP\)</span>，一直似懂非懂，看了Matrix67的<a href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a>，<del>特意作文纪念</del> 。</p><p>一张图就可以解释三者间的关系：<img src="https://img-blog.csdnimg.cn/20190728150856295.png" alt="在这里插入图片描述" /></p><h2 id="什么是p问题np问题和npc问题">什么是P问题、NP问题和NPC问题</h2><p>这或许是众多OIer最大的误区之一。<br />你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是NPC问题是一个多大的错误。</p><p>还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有<span class="math inline">\(O(1)\)</span>的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是<span class="math inline">\(O(n)\)</span>，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于<span class="math inline">\(O(n^2)\)</span>的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是<span class="math inline">\(O(a^n)\)</span>的指数级复杂度，甚至<span class="math inline">\(O(n!)\)</span>的阶乘级复杂度。不会存在<span class="math inline">\(O(2*n^2)\)</span>的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，<span class="math inline">\(O (n^3+n^2)\)</span>的复杂度也就是<span class="math inline">\(O(n^3)\)</span>的复杂度。因此，我们会说，一个<span class="math inline">\(O(0.01*n^3)\)</span>的程序的效率比<span class="math inline">\(O(100*n^2)\)</span>的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终<span class="math inline">\(O(n^3)\)</span>的复杂度将远远超过<span class="math inline">\(O(n^2)\)</span>。我们也说，<span class="math inline">\(O(n^{100})\)</span>的复杂度小于<span class="math inline">\(O(1.01^n)\)</span>的复杂度。</p><p>容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是<span class="math inline">\(O(1),O(log(n)),O(n^a)\)</span>等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是<span class="math inline">\(O(a^n)\)</span>和<span class="math inline">\(O(n!)\)</span>型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p><p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。The Halting Problem就是一个著名的不可解问题，在我的Blog上有过专门的介绍和证明。再比如，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p><p>下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。哪些问题是P类问题呢？通常NOI和NOIP不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。</p><p>接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100 小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。</p><p>之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。</p><p>很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。</p><p>NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。</p><p>目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p><p>为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。</p><p>简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。</p><p>“问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。</p><p>很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。</p><p>现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。</p><p>当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p><p>好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p><p>NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</p><p>既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p><p>顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p><p>不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。下文即将介绍它。</p><p>下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。</p><p>逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。<br />什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。<br /><img src="https://img-blog.csdnimg.cn/20190728155740104.png" alt="在这里插入图片描述" /><br />这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。</p><p>有输出无论如何都不可能为True的逻辑电路吗？有。下面就是一个简单的例子。<br /><img src="https://img-blog.csdnimg.cn/20190728155803196.png" alt="在这里插入图片描述" /><br />上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。</p><p>回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。</p><p>逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。</p><p>有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pointers and Memory</title>
      <link href="/2020/01/01/Pointers%20and%20Memory/"/>
      <url>/2020/01/01/Pointers%20and%20Memory/</url>
      
        <content type="html"><![CDATA[<p><em>Stanford CS Education Library #102</em> ## Basic Pointers 指针主要有两个用途：使不同的代码段共享信息、方便链表（树）的处理。<br />指针示意图：<br /><img src="https://img-blog.csdnimg.cn/2019041619200938.png" alt="在这里插入图片描述" /><br /><code>dereference</code>操作会根据指针的值去找到它的<code>pointee</code>。<br /><code>NULL</code>是一个特殊的指针值（一般是地址0），表示这个指针不指向任何<code>pointee</code>。<br /><img src="https://img-blog.csdnimg.cn/20190416193109659.png" alt="在这里插入图片描述" /><br />指针的赋值会使得两个指针指向相同的<code>pointee</code>，但<code>pointee</code>本身不会改变：<br /><img src="https://img-blog.csdnimg.cn/20190416192708547.png" alt="在这里插入图片描述" /><br />传指针vs传值：<br /><img src="https://img-blog.csdnimg.cn/20190416193445969.png" alt="在这里插入图片描述" /><br />定义一个指针后，这个指针是没有被初始化的：<br /><img src="https://img-blog.csdnimg.cn/2019041619372662.png" alt="在这里插入图片描述" /><br />这时候如果进行<code>dereference</code>操作会发生Runtime Error.<br />对于Java、LISP等语言，当定义一个指针时，系统会将其设置为<code>NULL</code>，并且会在<code>dereference</code>操作时检查其值，这也是Java比较慢的原因之一。<br /><img src="https://img-blog.csdnimg.cn/20190416194404553.png" alt="在这里插入图片描述" /><br />一个比较典型的指针错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BadPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p;  <span class="comment">//allocate the pointer, but not the pointee</span></span><br><span class="line">    *p = <span class="number">42</span>; <span class="comment">//serious RE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>*p</code>时：<br /><img src="https://img-blog.csdnimg.cn/20190416195104100.png" alt="在这里插入图片描述" /></p><h2 id="local-memory">Local Memory</h2><p>函数开始运行时，会为局部变量分配内存，结束运行会回收内存。<br />看一个错误的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TAB -- The Ampersand Bug function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">TAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">return</span> (&amp;temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Victim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ptr;</span><br><span class="line">    ptr = TAB();</span><br><span class="line">    *ptr = <span class="number">42</span>;    <span class="comment">//The pointee was local to TAB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于<code>TAB()</code>返回了一个局部变量的地址，但这个局部变量的空间已经被回收，<code>ptr</code>指针没有<code>pointee</code>。</p><h2 id="reference-parameters">Reference Parameters</h2><p>传值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> worth)</span> </span>&#123;</span><br><span class="line">    worth++;</span><br><span class="line">    <span class="comment">// T2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> netWorth = <span class="number">55</span>;  <span class="comment">//T1</span></span><br><span class="line">    B(netWorth);</span><br><span class="line">    <span class="comment">// T3 -- B() did not change netWorth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190416203356234.png" alt="在这里插入图片描述" /><br />传指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>* worthRef)</span> </span>&#123;</span><br><span class="line">    (*worthRef)++;</span><br><span class="line">    <span class="comment">// T2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> netWorth = <span class="number">55</span>;  <span class="comment">//T1</span></span><br><span class="line">    B(&amp;netWorth);</span><br><span class="line">    <span class="comment">// T3</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190416203939385.png" alt="在这里插入图片描述" /><br />传指针在c++中可以通过<strong>传引用</strong>的方式实现：<br /><img src="https://img-blog.csdnimg.cn/20190416205349526.png" alt="在这里插入图片描述" /></p><h2 id="heap-memory">Heap Memory</h2><p>分配示意图：<br /><img src="https://img-blog.csdnimg.cn/20190416205821650.png" alt="在这里插入图片描述" /><br />释放示意图：<br /><img src="https://img-blog.csdnimg.cn/20190416210059909.png" alt="在这里插入图片描述" /><br />释放后，指针虽然还在，但却不可以在使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size以字节为单位，分配成功返回指针，失败返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要size，因为heap manager之前已经记录过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* heapBlockPointer)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190416211219354.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20190416211242340.png" alt="在这里插入图片描述" /><br />一个<code>StringCopy()</code>的例子：<br /><img src="https://img-blog.csdnimg.cn/20190416211900707.png" alt="在这里插入图片描述" /><br />对于分配的堆内存，只有一个负责释放的，要么是<code>caller</code>，要么是<code>callee</code>：<br /><img src="https://img-blog.csdnimg.cn/20190416212610387.png" alt="在这里插入图片描述" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List-2</title>
      <link href="/2020/01/01/Linked%20List-2/"/>
      <url>/2020/01/01/Linked%20List-2/</url>
      
        <content type="html"><![CDATA[<h2 id="三编码技巧">三、编码技巧</h2><p><strong>1、遍历链表</strong><br />先将<code>head</code>指针赋值给一个局部变量<code>current</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//return the number of nodes in a list (while-loop version)</span><br><span class="line">int Length(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    struct node* current = head;</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (current = head; current != NULL; current = current-&gt;next) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>2、通过传递<code>reference pointer</code>改变某个指针</strong><br />看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Change the passed in head pointer to be NULL</span><br><span class="line">//Uses a reference pointer to access the caller&#x27;s memory</span><br><span class="line">void ChangeToNull(struct node** headRef)  //takes a pointer to the value of interest</span><br><span class="line">&#123;</span><br><span class="line">    *headRef = NULL;//use * to access the value of interest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ChangeCaller()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head1;</span><br><span class="line">    struct node* head2;</span><br><span class="line"></span><br><span class="line">    ChangeToNull(&amp;head1);//use &amp; to compute and pass a pointer to</span><br><span class="line">    ChangeToNull(&amp;head2);//the value of interest</span><br><span class="line">    //head1 and head2 are NULL at this point</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块的思想是和（一）中的<code>Push()</code>类似。<br />内存示意图：<br /><img src="https://img-blog.csdnimg.cn/20190330151133187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br /><strong>3、通过<code>Push()</code>建立链表（头插法）</strong> 这种方式的优点是速度飞快，简单易行，缺点是得到的链表是逆序的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct node* AddAtHead()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;head, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //head == &#123;5,4,3,2,1&#125;;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、尾插法建立链表</strong> 这种方法需要找到链表最后一个节点，改变其<code>.next</code>域：<br /><img src="https://img-blog.csdnimg.cn/20190330155111506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><ul><li>插入或者删除节点，需要找到该节点的前一个节点的指针，改变其<code>.next</code>域；</li><li>特例：<strong>如果涉及第一个节点的操作，那么一定要改变<code>head</code>指针。</strong></li></ul><p><strong>5、特例+尾插法</strong> 如果要构建一个新的链表，那么头节点就要单独处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithSpecialCase()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line">    struct node* tail;</span><br><span class="line">    </span><br><span class="line">    //deal with the head node here, and set the tail pointer</span><br><span class="line">    Push(&amp;head, 1);</span><br><span class="line">    tail = head;</span><br><span class="line"></span><br><span class="line">    //do all the other nodes using &quot;tail&quot;</span><br><span class="line">    for (int i = 2; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;(tail-&gt;next), i);   //add node at tail-&gt;next</span><br><span class="line">        tail = tail-&gt;next;     //advance tail to point to last node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head;    //head == &#123;1,2,3,4,5&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、临时节点建立</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithDummyNode()</span><br><span class="line">&#123;</span><br><span class="line">    struct node dummy;   //dummy node is temporarily the first node</span><br><span class="line">    struct node* tail = &amp;dummy;   //build the list on dummy.next</span><br><span class="line"></span><br><span class="line">    dummy.next = NULL;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;(tail-&gt;next), i);</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //the real result list is now in dummy.next</span><br><span class="line">    //dummy.next == &#123;1,2,3,4,5&#125;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、本地指针建立</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithLocalRef()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line">    struct node** lastPtrRef = &amp;head;   //start out pointing to the head pointer</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(lastPtrRef, i);  //add node at the last pointer in the list</span><br><span class="line">        //advance to point to the new last pointer</span><br><span class="line">        lastPtrRef = &amp;((*lastPtrRef)-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head;  //head == &#123;1,2,3,4,5&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块可能有些抽象：<br />1）<code>lastPtrRef</code>开始指向<code>head</code>指针，以后指向链表最后一个节点中的<code>.next</code>域；<br />2）在最后加上一个节点；<br />3）让<code>lastPtrRef</code>指针向后移动，指向最后一个<strong>节点的<code>.next</code>域</strong>。 <code>(*lastPtrRef)-&gt;next</code>可以理解为<code>*lastPtrRef</code>指针指向的节点的<code>next</code>域。<br /><img src="https://img-blog.csdnimg.cn/20190403193507385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="四代码示例">四、代码示例</h2><p><strong>1、AppendNode()</strong> 1) 不使用<code>Push()</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct node* AppendNode(struct node** headRef, int num)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = *headRef;</span><br><span class="line">    struct node* newNode;</span><br><span class="line"></span><br><span class="line">    newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">    newNode-&gt;data = num;</span><br><span class="line">    newNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //special case for length 0</span><br><span class="line">    if (current == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        *headRef = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //Locate the last node</span><br><span class="line">        while (current-&gt;next != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>使用<code>Push()</code>函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct node* AppendNode(struct node** headRef, int num)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = *headRef;</span><br><span class="line"></span><br><span class="line">    //special case for length 0</span><br><span class="line">    if (current == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(headRef, num);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //Locate the last node</span><br><span class="line">        while (current-&gt;next != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Build the node after the last node</span><br><span class="line">        Push(&amp;(current-&gt;next), num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、CopyList</strong><br />用一个指针遍历原来的链表，两个指针跟踪新生成的链表（一个<code>head</code>，一个<code>tail</code>）。</p><ol type="1"><li>不使用<code>Push()</code>函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* newList = NULL;   //head of the new list</span><br><span class="line">    struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (newList == NULL)    //special case for the first new node</span><br><span class="line">        &#123;</span><br><span class="line">            newList = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">            newList-&gt;data = current-&gt;data;</span><br><span class="line">            newList-&gt;next = NULL;</span><br><span class="line">            tail = newList;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            tail-&gt;data = current-&gt;data;</span><br><span class="line">            tail-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 内存示意图：<br /><img src="https://img-blog.csdnimg.cn/20190407094454488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li><li>使用<code>Push()</code>函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList2(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* newList = NULL;   //head of the new list</span><br><span class="line">    struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (newList == NULL)    //special case for the first new node</span><br><span class="line">        &#123;</span><br><span class="line">            Push(&amp;newList, current-&gt;data);</span><br><span class="line">            tail = newList;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Push(&amp;(tail-&gt;next), current-&gt;data);   //add each node at the tail </span><br><span class="line">            tail = tail-&gt;next;       //advance the tail to the new last node;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>使用<code>Dummy Node</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList3(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line">    struct node dummy;            //build the new list off this dummy node</span><br><span class="line"></span><br><span class="line">    dummy.next = NULL;</span><br><span class="line">    tail = &amp;dummy;      //start the tail pointing at the dummy</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;(tail-&gt;next), current-&gt;data);   //add each node at the tail</span><br><span class="line">        tail = tail-&gt;next;                    //advance the tail to the new last node</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>使用<code>Local References</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList4(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* newList = NULL;   //head of the new list</span><br><span class="line">    struct node** lastPtr;           </span><br><span class="line"></span><br><span class="line">    lastPtr = &amp;newList;      //start off pointing to the head itself</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(lastPtr, current-&gt;data);   //add each node at the lastPtr</span><br><span class="line">        lastPtr = &amp;((*lastPtr)-&gt;next);    //advance lastPtr</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想是使用<code>lastPtr</code>指针指向每个节点的<code>.next</code>域这个指针，而不是指向节点本身。</p><ol start="5" type="1"><li>使用<code>Recursive</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList5(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;</span><br><span class="line">    if (head == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        struct node* newList = (struct node*)malloc(sizeof(struct node));  //make one node</span><br><span class="line">        newList-&gt;data = current-&gt;data;</span><br><span class="line"></span><br><span class="line">        newList-&gt;next = CopyList5(current-&gt;next);    //recur for the rest</span><br><span class="line">        return newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List-1</title>
      <link href="/2020/01/01/Linked%20List-1/"/>
      <url>/2020/01/01/Linked%20List-1/</url>
      
        <content type="html"><![CDATA[<p>链表一直是面试的重点问题，恰好最近看到了Stanford的一篇<a href="http://cslibrary.stanford.edu/">材料</a>，涵盖了链表的基础知识以及派生的各种问题。<br />第一篇主要是关于链表的基础知识。</p><h2 id="基本结构">基本结构</h2><p><strong>1、数组回顾</strong><br />链表和数组都是用来存储一堆数据的集合，其中单个元素的类型可以有很多种。<br />通过数组下标可以直接访问数组中的元素，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ArrayTest()</span><br><span class="line">&#123;</span><br><span class="line">    int scores[100];</span><br><span class="line"></span><br><span class="line">    //初始化前3个元素</span><br><span class="line">    scores[0] = 1;</span><br><span class="line">    scores[1] = 2;</span><br><span class="line">    scores[2] = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的是：整个数组被分配了一整块内存：<br /><img src="https://img-blog.csdnimg.cn/2019032615150057.png" /><br />数组元素之所以能被快速访问，原因在于其地址的计算是通过首地址加上偏移值得到的，只有一次乘法和一次加法运算而已。<br />数组的缺点在于：</p><ul><li>数组的大小是固定的：数组的规模在编译时就被确定，当然你可以在运行时通过<code>malloc</code>在堆中改变数组的大小，不过很麻烦；</li><li>由于上述原因，所以很多人就会定义一个很大的数组，不过这又会导致两个问题：<br />1）数组的大部分空间可能被浪费掉；<br />2）如果程序需要更大的空间，就会崩溃。</li><li>在数组前面插入元素代价很大，需要移动很多元素。<br />链表也有自己的优缺点，只不过和数组刚好互补：链表会在需要时为每个节点单独分配内存。<br /><strong>2、指针回顾</strong><br />指针存储了变量的地址，如果指针的值是<code>NULL</code>（c/c++中<code>NULL</code>可以表示逻辑<code>false</code>），那么该指针不指向任何变量。<br />在c/c++中，没有初始化的指针就是野指针，对野指针进行<code>dereference</code>操作可能导致程序崩溃。<br />两个指针的赋值结果就是都指向相同的内存区域。<br /><code>malloc()</code>函数用来在堆中申请一块内存，并且返回一个指向该块的指针，如果申请失败，会返回<code>NULL</code>，使用后，需要用<code>free()</code>去释放。这些堆函数原型都在<code>stdlib.h</code>头文件中声明。<br /><strong>3、链表</strong><br />一个包含<code>&#123;1,2,3&#125;</code>三个元素的链表：<br /><img src="https://img-blog.csdnimg.cn/20190326161911717.png" alt="在这里插入图片描述" /><br />空链表的<code>head</code>的值是<code>NULL</code>，<strong>编程时要考虑到这种边界情况</strong>。</li></ul><p>节点的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指向节点的指针类型是<code>struct node*</code>。<br />接着看看上图中的链表是怎么建立的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Build the list &#123;1,2,3&#125; in the heap and store</span><br><span class="line">its head pointer in a local stack variable.</span><br><span class="line">Returns the head pointer to the caller.</span><br><span class="line">*/</span><br><span class="line">struct node* BuildOneTwoThree()</span><br><span class="line">&#123;</span><br><span class="line">    //there are three pointers in the stack, but pointer assignment link the list.</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line">    struct node* second = NULL;</span><br><span class="line">    struct node* third = NULL;</span><br><span class="line"></span><br><span class="line">    //allocate 3 nodes</span><br><span class="line">    head = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">    second = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">    third = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    head-&gt;data = 1;    //setup first node</span><br><span class="line">    head-&gt;next = second;   //note:pointer assignment rule</span><br><span class="line"></span><br><span class="line">    second-&gt;data = 2;    //setup second node</span><br><span class="line">    second-&gt;next = third;</span><br><span class="line"></span><br><span class="line">    third-&gt;data = 3;    //setup third node</span><br><span class="line">    third-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //at this point, the linked list referenced by &quot;head&quot;</span><br><span class="line">    //matches the list in the drawing.</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何求链表中的元素个数呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Given a linked list head pointer, compute </span><br><span class="line">and return the number of nodes in the list.</span><br><span class="line">*/</span><br><span class="line">int Length(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，传递进函数的只是头指针，这样调用者和被调用者都有了头指针，但是却共享了整个链表。</p><ul><li><code>current</code>指针占据的空间会被自动释放，但是堆中的链表仍然保留；</li><li><code>while</code>循环已经考虑了空链表的情况；</li><li><code>current</code>最后的值会是<code>NULL</code>。<br />调用<code>Length()</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void LengthTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* myList = BuildOneTwoThree();</span><br><span class="line">    int len = Length(myList);    //results in len == 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用<code>Length()</code>之前：<br /><img src="https://img-blog.csdnimg.cn/20190326172043909.png" alt="在这里插入图片描述" /></li><li>执行<code>Length()</code>过程中：<br /><img src="https://img-blog.csdnimg.cn/20190326172354519.png" alt="在这里插入图片描述" /></li></ul><h2 id="链表建立">链表建立</h2><p>用<code>BuildOneTwoThree()</code>函数来建立链表未免有些古板，下面用头插法建立链表：</p><p>1、分配节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct node* newNode;</span><br><span class="line">newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">newNode-&gt;data = data_client_wants_stored;</span><br></pre></td></tr></table></figure><p>2、让新节点的<code>next</code>指向当前链表的第一个节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newNode-&gt;next = head;</span><br></pre></td></tr></table></figure><p>3、让<code>head</code>指针指向链表的第一个节点： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = newNode;</span><br></pre></td></tr></table></figure> 整理下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void LinkTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();  //suppose this builds list &#123;2,3&#125;</span><br><span class="line">    struct node* newNode;</span><br><span class="line"></span><br><span class="line">    newNode = (struct node*)malloc(sizeof(struct node));  //allocate</span><br><span class="line">    newNode-&gt;data = 1;</span><br><span class="line">    </span><br><span class="line">    newNode-&gt;next = head;   //link next</span><br><span class="line"></span><br><span class="line">    head = newNode;   //link head</span><br><span class="line"></span><br><span class="line">    //now head points to the list &#123;1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图： <img src="https://img-blog.csdnimg.cn/20190326205401503.png" alt="在这里插入图片描述" /><br /><em>先看一个错误的示范：</em> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void WrongPush(struct node* head,int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    head = newNode;    //NO this line does not work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WrongPushTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();  </span><br><span class="line">    </span><br><span class="line">    WrongPush(head, 1);    //try to push 1 on front -- doesn&#x27;t work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个问题就在于C语言的<strong>值传递</strong>，在<code>WrongPush()</code>中对<code>head</code>指针的改变不会影响到<code>WrongPushTest</code>中的我们需要的<code>head</code>指针。<br />这个问题传统的解决方案是传递当前值的指针给函数而不是传递一份当前值的拷贝，即：<br />要改变调用者中<code>int</code>的值，就传一个<code>int*</code>给被调用者。在这个例子中，要改变<code>struct node*</code>，就要传递<code>struct node**</code>。也即：<code>head</code>的类型是<code>pointer to a struct node</code>，想要改变这个指针，就需要传一个指向该指针的指针<code>pointer to a pointer to a struct node</code>。<br /><strong>规则就是：<code>to modify caller memory, pass a pointer to that memory.</code></strong></p><p><em>所以正确的代码如下：</em> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Takes a list and a data value.</span><br><span class="line">Creates a new link with the given data and pushes it</span><br><span class="line">onto the front of the list.</span><br><span class="line">The list is not passed in by its head pointer.</span><br><span class="line">Instead the list is passed in as a &quot;reference&quot; pointer</span><br><span class="line">to the head pointer -- this allows us to modify the caller&#x27;s memory.</span><br><span class="line">*/</span><br><span class="line">void Push(struct node** headRef,int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = *headRef;//the * to dereferences back to the real head </span><br><span class="line">    *headRef = newNode;    //ditto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PushTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();//suppose this returns the list &#123;2,3&#125;</span><br><span class="line">    </span><br><span class="line">    Push(&amp;head, 1);    //note the &amp;</span><br><span class="line">    Push(&amp;head, 13);</span><br><span class="line"></span><br><span class="line">    //head is now the list &#123;13,1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 内存示意图：<br /><img src="https://img-blog.csdnimg.cn/20190330143627528.png" alt="在这里插入图片描述" /><br />如果是C++，那么可以用<strong>引用</strong>完成上述工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Push in C++ -- We just add a &amp; to the right hand side of the head parameter type,</span><br><span class="line">and the compiler makes that parameter work by reference. So this code changes the </span><br><span class="line">caller&#x27;s memory, but no extra uses of * are necessary -- we just access &quot;head&quot; directly,</span><br><span class="line">and the compiler makes that change reference back to the caller.</span><br><span class="line">*/</span><br><span class="line">void Push(struct node*&amp; head,int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = head;//No extra use of * necessary on head -- the compiler</span><br><span class="line">    head = newNode;    //just takes care of it behind the scenes.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PushTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();//suppose this returns the list &#123;2,3&#125;</span><br><span class="line">    </span><br><span class="line">    Push(head, 1);    //No extra use &amp; necessary -- the compiler </span><br><span class="line">    Push(head, 13);   //takes care of it here too. Head is being changed by these calls. </span><br><span class="line"></span><br><span class="line">    //head is now the list &#123;13,1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海量数据处理</title>
      <link href="/2020/01/01/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2020/01/01/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="ip白名单系统">IP白名单系统</h2><p>设计一个10亿级别的IP白名单系统，支持增删改查。</p><p>如果用string存储每个IP，那么大约需要15GB的内存； 如果直接将每一位看作十进制的数，用int存储，但是单个int无法存储255.255.255.255这么大的数；</p><p>如果将每个小段都用二进制表示，那么所有的IP地址都可以用32位的unsigned int表示。</p><p>所以采用<span class="math inline">\(2^{32}-1\)</span>大小的bit数组来映射所有的IP地址，大约需要内存512MB。</p><p>首先看增加操作，将IP地址转为unsigned int后，将bit数组中对应位置1即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> byte = ip / <span class="number">8</span>, bit = ip % <span class="number">8</span>;</span><br><span class="line">    arr[byte] = arr[byte] | <span class="number">1</span> &lt;&lt; (<span class="number">7</span> - bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看查找操作，只需判断该IP地址对应位置是否为1即可： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> byte = ip / <span class="number">8</span>, bit = ip % <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> arr[byte] &amp; <span class="number">1</span> &lt;&lt; (<span class="number">7</span> - bit) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后续还有IP地址转unsigned int以及非法判断，并发处理等问题。</p><h2 id="找众数">找众数</h2><p>一个文件包含40亿个32位的无符号整数，使用内存限制1GB找到众数。</p><p>32位无符号数范围是<span class="math inline">\(0\sim 2^{32}-1(4,294,967,295)\)</span></p><p>傻白甜做法就是用一个Hashmap统计每个数的频率，key是4B，value是4B，一条记录8B，最差情况下40亿个数都不同，共需40亿*8B大约32GB。</p><p>哈希分割+多线程</p><p>https://www.bilibili.com/video/BV13g41157hK?p=11 29min</p><h2 id="spark">Spark</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老实人的摸索与反思---写在高考七年后</title>
      <link href="/2019/12/02/%E8%80%81%E5%AE%9E%E4%BA%BA%E7%9A%84%E6%91%B8%E7%B4%A2%E4%B8%8E%E5%8F%8D%E6%80%9D---%E5%86%99%E5%9C%A8%E9%AB%98%E8%80%83%E4%B8%83%E5%B9%B4%E5%90%8E/"/>
      <url>/2019/12/02/%E8%80%81%E5%AE%9E%E4%BA%BA%E7%9A%84%E6%91%B8%E7%B4%A2%E4%B8%8E%E5%8F%8D%E6%80%9D---%E5%86%99%E5%9C%A8%E9%AB%98%E8%80%83%E4%B8%83%E5%B9%B4%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<p><em>说明：本文是徐国曦老师写于2018年6月，我第一次看到此文是在2019年4月中旬。鉴于我当时状态很糟糕，此文给了我极大的震撼与启发，每每读来都有不同的感受，遂摘录于此。 附：<a href="https://zhuanlan.zhihu.com/p/37859452">原文链接</a></em></p><hr /><p>说明：上篇《老实人的归国与失身》获得了超过预想的关注，文中虽声明“本故事纯属虚构”，但实际上真实情况与艺术加工大约各占一半。上篇文章想要表达的主题可能并不十分清楚，不同人看到的东西会有极大不同。因此在今天这篇文章中我将详细讲一下这些年来发生的事情以及自己的一些思考，本文句句事实，不说一句大话、假话、空话，不贩卖焦虑，不灌任何鸡汤和毒鸡汤。我也不讳言自己身上出现的问题，曾经的生活充满不堪，有些遮蔽在眼前的玻璃滤镜总要有需要被打破的一天。</p><p>时至今日，我也是时候与过去的自己告别，开始新的第二人生了。我也希望将自己的经历写出来，给境遇相似的人提供一些可能的思考或警示。几年折腾下来，不敢说积累了多少人生经验，但是讲教训我这里是有很多的，这篇文章的目的也在于用亲身经历指出我自己及处境相似的年轻人思维和行动上的误区。其中的一些个人想法可能不完善或者不成熟，也欢迎批评指教。</p><hr />认真投决定命运的硬币，却不知道最后要去哪里。<p align="right">——题记</p><h2 id="section">0</h2><p>在文章开始之前，先放几篇在某段时间内引发广泛讨论的微信文，读者们或多或少可能看过其中一些：</p><ol start="0" type="1"><li><a href="https://www.zhihu.com/question/277691008">《老实人的归国与失身》</a> 作者是我自己</li><li><a href="https://www.zhihu.com/question/50766928">《T大本科舍友阶级分化实录，该何去何从？》</a></li><li><a href="https://www.zhihu.com/question/44186681">《凭什么我辛苦二十年，现在却比别人差那么多？》</a></li><li><a href="https://www.zhihu.com/question/52031149">《我上了985 211才发现自己一无所有》</a></li><li><a href="https://www.zhihu.com/question/65098412">《一个月就辞职，一个北大女生的求职悲欢》</a></li></ol><p>这些文章可能可以或多或少的反映当前包括我在内部分名校学生所面临的现实问题与认知偏差。也因此，因为视角有限，必然不代表整个年轻人群体的普遍现象，更不能说契合多数人的价值观，请带着批判的眼光看到上面提到的所有文章，也包括我这篇。</p><h2 id="section-1">1</h2><p>好了废话不多说，开始讲故事，十年经历，尽在此篇。如果觉得故事过长，请直接看最后的结论。</p><p>美西时间2018年6月6日下午，我上完了学生时代的最后一节课程，只待最后的考试、毕业、回国、入职。打开朋友圈，看到大家都在怀念当年的高考，作为一个上了大学后就基本没再怎么提起高考这茬事的人，突然觉得这个事情好遥远。不过从尘埃落定以来我也一直想找个机会分享一下我个人几年来遇到的事情，就索性在高考七年之后学生时代临近结束的时候，进行一次彻底的总结，向过去的自己说再见，轻装迎接未知的未来。这篇的主题其实和高考本身没有多大关系，不过还是像上篇一样，从高中时代讲起。</p><p>如同《老实人的归国与失身》当中讲到的那样，我十年之前升入一个高考大省省会的重点高中，虽然管理并非变态到监狱式的程度，但是由于升学压力的缘故，大部分学生的日子还是过得相对波澜不惊。在一个在郊区住校，一两周回一趟家，手机都不一定人手一部，诺基亚N95就能称霸，上QQ空间可能是最好的娱乐活动的时代，我们的日常生活也不像十年之后的今天有着各种各样的诱惑。如同我现在看到快手抖音和知乎上的00后们接受着我们从没想过的信息，做着我们想追求却曾经不敢去做的事情，18岁的他们姿势水平可能完爆25岁的自己，就觉得时代的发展如同车轮一般，而90后已经成了被冲在沙滩上的前浪。</p><p>而在那样的环境下，可想而知，学生当中最受欢迎的群体并不是只知道好好学习的书呆子（虽然我自己可能并不是），而永远都是绯闻缠身的帅哥靓女们，家里有一些背景考到一本线就能上本地985的关系户，手机一周一换的富二代，carry大家打游戏的大咖，带着些许叛逆的所谓不良少年，甚至高中时代成熟的早偷尝禁果还顺便能给朋友们性启蒙的人。虽然当我之后见到更大的世界之后发现这都不算什么，但放在当时，这些现象还是对很多十五六岁经历一片空白的少男少女有着一定杀伤力的。</p><p>在这些人面前，我竟有些自卑，说不清楚自己除了成绩稍微好一些之外还有什么优点，更何况成绩根本没好到可以完爆他们的程度。而我个人的课余生活就更是单调，<strong>上晚自习看《萌芽》追连载小说得到的快乐，可能并不亚于几年之后在国际期刊发表一作文章的快乐</strong>。人在成长过程中都是这样，小时候得到个玩具就能高兴好几天，可是长大之后很有可能金钱和权力等这些世俗成功标准的降临都带不来一样的感动了。人的阈值总是随时间而增长的，这是好事还是坏事呢？</p><p>我在这所高中成绩比较稳定位于年级中上，课余和寒暑假的时间都用来搞竞赛，虽然略吃力但也有所收获。正常情况下单凭高考考到中等985学校没问题，如果竞赛保送可以去前十学校。我自己高中时候的目标是上清华北大，但由于从当时的情况看来过于不切实际，因此也很少跟别人提起。到了高三，竞赛获了省一拿到了保送资格，报了清华和另外一所华五学校，清华没考过线，另外一所学校过了录取线却把我调剂到了法医专业。由于实在是不想读这个专业，不得不放弃保送资格强行拼高考。高三一年各次模拟考试我的成绩稳定在六百三四十（虽然事后看来，模拟题和高考真题完全不是一个路数），即便加上竞赛加分，离梦想的学校也相距太远。以至于到了高三的五月，我竟觉得“就这样吧，考到哪算哪”。</p><p>于是高考前最后的一个月我连作业都懒得做了，每天用几乎全部的时间研究历年高考真题，琢磨里面的规律。2011年高考的三天也波澜不惊的过去了，甚至高考之后答案都懒得去对，抱着出了分之后随便报个志愿的弃疗态度就去睡了十五天大觉。结果出乎意料的是超常发挥了近三十分，莫名其妙的考到了全市前五全省前五十，竟然可以真的报清北了。</p><p>鉴于当时的确不知道自己喜欢什么和适合什么专业，当天急急忙忙的就和清华签了约，而专业也是招生老师推荐给我的，我想都没想就接受了，身边的长辈也全都给我说：</p><p><strong>“你都上了清华了，学什么专业不重要”。</strong></p><p>那个时候自己对未来的想法只有： <strong>“我想做一个科学家”</strong></p><p>（然而可能连什么是科学家都不甚清楚），看到是个理工科专业，就糊里糊涂接受了。这就是一个典型的战术上勤奋战略上懒惰的例子。</p><p>我本人并非小县城出身，与“学霸”这个词更是八竿子打不着。但是，可能时至今日我自己身上仍然还有一些小县城学霸思维方式的残余。尤其在高考大省，我们很多人在18岁之前除了学习什么都不懂，而工人阶级或者知识分子的父母从小告诉我们的就是“<strong>读书改变命运</strong>”甚至是“<strong>考个好大学什么都不用愁了</strong>”。</p><p>固然在他们那个时代可能是这样，但是如今，这样的“<strong>努力就能得到回报</strong>”、“<strong>一分耕耘一分收获</strong>”的单线程的、线性的思维方式在更大程度上是对生活的一种不完全归纳甚至是片面归纳。从小地方考入最高学府，必须承认眼界和见识必然比不过一部分同龄人：2017年夏天我在斯坦福带过一个国内初中生组成的所谓“游学团”，平均年龄十三四岁，平均去过十几二十个国家，有的甚至是来美国开独奏会的，聊天当中处处被教做人，甚至有白比他们年龄长一倍的感觉，这样的眼界和见识怎么比？</p><p>事实上，比无头苍蝇乱撞般瞎努力更重要的是选择，比选择更重要的是信息，还有历史行程、社会形势、贵人相助以及运气等因素。<strong>有时候必须承认人与人的差距可能努力程度占三分，而其他因素，占七分，甚至九十七分</strong>。也因此，小县城学霸以及我这样的伪“小县城学霸”到了顶尖名校之后不可避免会有一定失落感，这也是现实存在的一个问题。</p><h2 id="section-2">2</h2><p>从这一刻起，没有金刚钻却强行揽了瓷器活的日子开始了。德不配位，必会撞墙。不过话说回来，如果没有当年的撞墙也不会有如今的成长。下面所有的故事，可以称为“<strong>一个名校（主流价值观中的）差生的试错与教训</strong>”。整个过程，也就是跟自己的局限、幼稚与无知斗争的过程。</p><p>虽然从考上清华那一刻开始自己就隐隐约约感觉到，高考一次的成功不能说明太多问题，更没有一劳永逸的感觉，然而现实永远比想象的更加要命。大一第一学期我和高三的辛苦程度差不多，但是期中考试的成绩竟然是（大约）年级倒数前三（年级100人左右），有一门差点没及格。看到成绩的时候我突然懂得了很多事情，而大学四年的目标，也由在本领域做出点成绩变成了安全毕业。</p><p>我当时的想法就是，既然学术（单说成绩方面）这条路走不通，那索性就去多试试别的。于是我从那之后几乎每学期都选35-40学分的课，想拓展自己的视野，找找自己可能能行的方面究竟在哪里。同时加了学生会，加了社团，认识了一些从当时看来闪闪发光的牛人，甚至还有过做了个互联网信息平台差点创业的经历。故事发展到这里，从外界看来似乎我的大学生活将要过得风生水起，然而似乎并没这么简单。</p><p>到了大二，我逐渐认识到自己对本专业并没有像自己想象的那般兴趣，而且学习也越来越吃力。带着困惑，我去咨询了一些前辈，前辈给的建议都是“好好学专业课，好好做科研，当你用到你所学的知识的时候你自然会喜欢的”（这是我唯一能得到的信息，尽管帮助着实有限）。于是我进了实验室（这在当时已经算起了个大早），然而发现根本不知道自己学的知识能够如何用到科研当中。此时此刻，同年级里有的同学已经开始接独立课题，有的同学已经有文章发表（非一作，不过放到现在，大二发一作的也已经不计其数了）。我在想，成绩拼不过不要紧，科研别输给他们。</p><p>终于在大三的时候，换过好几个实验室，我在一个交叉学科方向找到了自己的兴趣，而且这个方向一做就是四年。至于成绩，好的时候年级倒数1/3，差的时候年级倒数1/6，已经不在乎了。凭这样的成绩直接申国外博士几乎是不可能的，保研本系或者本校也差一点，于是不得不通过读硕士找个跳板，试图积累成绩以外的其他资源。其实在这个阶段，我也想过未来发展的其他可能性，但苦于真的不知道该去哪寻找信息（甚至那个时候大部分出国党都不知道有暑期研修这东西存在，反观今日，没个海外研修都不好意思出国），周围以我的眼界所能听到的声音也是“万般皆下品，唯有科研高”这样的价值观占主导，所以我并不觉得这里面有什么问题，或者并不知道自己选择这条路有多少是出于自己真心所想，而又有多少是出于随大流或者生活的惯性。</p><p>于是我算是在两眼一抹黑的情况下申请出国，匆匆忙忙准备申请材料，运气还算好，也拿到了较为不错的录取，还提前联系好了将来想跟的导师和实验室。再加上大四一年拼命科研，虽然到最后成绩仍然在倒数1/4，但国内国际期刊均有论文收获，这对于大学四年没得过任何荣誉（如果课余参加的一些数学物理方面的竞赛不算的话，只算官方荣誉）没拿过任何奖学金甚至很少受到赏识的自己来说也觉得没白来一遭。四年来受到的自信心打击太多，甚至到了最后已经被碾压到心如止水了，也越来越觉得有些时候人与人的差距不是通过努力能够追上的。即便如此，最后也涉险毕业，准备去美国开始一段新的人生，虽然直到本科毕业，我连一次出国经历也都没有。</p><h2 id="section-3">3</h2><p>在另一段“没有金刚钻却强行揽了瓷器活”的经历开始之前，我觉得这里有必要评价一下<strong>名校学渣</strong>这种客观存在且无数人经历过或正在经历的状态。</p><p>曾经知乎上有个问题，叫“在清华大学当学渣是种怎样的体验？”，回答者甚众，甚至在我本科时代的周围，包括我自己在内，都有很多人实实在在的经历过这样的挫折。很多时候当我们分享起自己被碾压的经历，会换来别人的不理解，甚至是“何不食肉糜”。然而这里面的痛苦却是真实的，我也见过有人因为学习成绩跟不上，退学的有之，休学的有之，抑郁的有之，甚至自杀的都存在。<strong>在很多情况下成绩成了衡量一个人唯一或者最重要的标准，赢者通吃，而在这一评价体系下没有胜出的人就很难得到主流舆论体系的承认。</strong></p><p>本科毕业之后我曾经跟一些这种处境的学弟学妹聊过，看到他们的迷茫我似乎也看到了当年自己的影子。那种自卑、焦虑、挫折、不被承认的感觉是的的确确困扰着我们当中很多人的，更何况名校学生对自己的期待和现实很难不产生心理落差。</p><p>由于人与人的痛苦是不共通的，每个人的解决方案也不尽相同。放在我身上，当我被学习成绩打击的时候，我当时的选择是在学生会做好事情，去实验室做好科研，而身边一些人可能是通过外出实习、体育运动、恋爱等方式排解。当被主流评价体系打击到怀疑自己存在的价值和意义时，我现在能给出的建议是，<strong>出去申请实习（甚至完全不必是自己对口行业的实习）</strong>，真正接触一下工作是怎样的，破除单一价值观带来的禁锢（不管这种单一价值观是外界强加的还是自己想象的），你会发现原来自己还能做出这样的贡献。我们在学校里的跑道只有一条，但实际上现实生活中的跑道有无数条。树挪死人挪活，换个环境很多时候都会带来不错的发挥。</p><p>现在，我想提出这样一个问题：<strong>如果读者作为名校毕业生，在大学四年过去之后，享受了较好的教育资源，你认为在什么方面自己应该具有一定优势</strong>？文章的最后我将谈一下自己对这个问题的看法。</p><h2 id="section-4">4</h2><p>2015年夏天，我仍然是在两眼一抹黑的情况下来到了美国。清华四年的经历虽然洗刷掉了我所有的骄傲和大部分的自信心，让我明白自己其实实力也就是中人之资，但还是模模糊糊抱着一个想当科学家的梦想。可是此时，我面临的主要矛盾已经变成了看到了更大的世界和自己内心可怜的信息量和姿势水平之间的矛盾。</p><p>本科期间我对象牙塔里的这一些规则或者体系有了一定的了解，但对社会的认知其实比刚入大学的时候并没有多少长进。在国内的时候，本身和其他背景的人交流就不多，科研压力也让我每天都在闷头向前赶，却很少抬起头来想想为什么，或者看看周围更广阔的风景。结果就是，到了美国，当不得不睁眼看世界的时候，发现身边的人一个比一个生活多姿多彩光鲜亮丽，而自己就像一个只知道埋头干活反而连活都干不好的傻B。</p><p>诸位别笑，这的确是我来到美国的第一感觉。一个见识有限的人突然到了一个大环境当中，不可避免有一种刘姥姥进了大观园的感觉。很多人的经历也让我大开眼界，有好的也有坏的，好的让我觉得“我大学期间都错过了什么”，而不好的让我觉得“原来还有这样的人存在，服气服气”。也因此，来到美国一两个月，我的三观就几乎被刷新了一遍。</p><p>在科研领域遇到的挫折（实际上什么都没做出来）让我发现这条路并非这么容易，生活中遇到过不靠谱的人和事太多我也只能说自己曾经太傻太天真。经历了刚出国换环境的阵痛，我再次陷入了不知道将来想做什么的困惑当中。但是所不同的是，这一次，我知道的信息更多，有一定可以选择的余地，也做好了试错的准备。</p><p>但是主业也容不得耽误，于是匆匆忙忙填完了博士申请，结果在关键时刻一篇投往顶级期刊的一作文章被拒，唯一可以拿得出手的砝码丢了，拿到的是隔壁学校降转硕士的录取（按照当时的情况留本校可能可以拿到博士，但在当时的环境下过得实在是太不开心，加之所在的研究方向不喜欢，不想一直这样下去）。</p><p>虽然不甘心但是也没办法，实力不济加上运气不好，只能接受现实，第一时间联系好了自己想做的方向的导师，因为正常情况下做得好是能留下来读博的。同时我利用这当中的空闲时间，投过咨询机构的实习，尝试了他们的思维方式。之后又投了几家金融业的实习，虽然做的也并不愉快。我试图通过这个，去弥补本科期间，甚至更早的时候，对这个社会，对各个将来可能从事的行业认知的缺失。然而事实告诉我，你还是太年轻，想的太简单。</p><p>说到这里，我想谈一下我们很多年轻人对这个社会认知的问题。我们在真正独立走上社会之前，接受的宣传是通过主流价值观为主的。但即使这样，这样的信息也难免偏颇，很多时候我们只看到了事物的A面，而没有看到B面，甚至可能还有S面。就单说科研领域，社会告诉我们的是做出成果无尽荣光，可是却不会告诉我们一将功成万骨枯，以及很多领域象牙塔和工业界存在脱节。金融领域我们看到从业者西装革履光鲜亮丽，但是背后却有朝八晚三不为人知的辛酸。创业圈更是这样，有人ICO，IPO一夜暴富，可更多的却是亏完了钱打水漂睡沙发的窘迫。</p><p>打个比方，我所在的城市高楼林立科技发达，然而当夜幕降临在一些不为人知的角落，也存在流浪者、大麻甚至是枪击。很多时候我们带着有色的，甚至可能是带着粉红泡泡的眼镜去看待社会，这个滤镜是我们了解社会的为数不多的途径，即便它存在失真。因此初出茅庐的人很容易去带着单纯的心态去相信A面是社会的全貌，然而当撞到南墙的时候，可能会遭到这样的批评：“<strong>你对社会的认知存在偏差，这锅你不背谁背</strong>？”你总觉得哪里不对，却无法反驳。</p><p>确实我们在往上攀登和向广阔的未知天地进发的时候，每一步都在离开自己的舒适区，这也就意味着我们在小圆内对世界的认知是没法向外延拓的。每一步都存在风险，每一步都在跳未知的坑，再加上人生不如意十之八九，难免怀疑人生，其实到最后不管是焦虑还是佛系，都是挣扎之后的结果。打碎面前的云山雾罩似乎很容易，但是人总愿意去相信事物对自己有利的一面，而潜意识的厌恶可能存在的风险。到了这里，闭关自守也罢，虚无主义也罢，随着这样的恶性循环慢慢成了我们挥之不去的绊脚石。也因此，很多时候虽然道理就在那里摆着，但唯有撞南墙尝苦果，才能让我们冲破这层人性原罪的束缚，去认知更大的更全面的新世界。</p><h2 id="section-5">5</h2><p>如果说刚刚出国的时候的情况是两眼一抹黑，那么一年之后的状态就是面前摆着几条道路，每条似乎都通向光明的前途，你却根本不知道该选哪一条。所幸导师对我很好，不管是在学术方面还是在生活方面都给了我很多人生经验和指引，让我有一种发自内心的因为受到知遇之恩所以必须要好好干活的感觉。受到这样的激励，我也立志在科研领域做出自己的一份贡献，然而由于接触的世界越来越大，我开始听到了很多不同的声音，而这些声音是我从来没有想象过的。</p><p>就比如说2016年很火的两篇帖子<a href="https://www.zhihu.com/question/50766928">《T大本科舍友阶级分化实录，该何去何从？》</a>与<a href="https://www.zhihu.com/question/44186681">《凭什么我辛苦二十年，现在却比别人差那么多？》</a>。从局外人的角度看来，我们可以说里面的主人公书生气过重，博士快要毕业了仍然没有认清楚一个事实，即你的学习成绩和学术成果和你将来在世俗评价标准下的成功只有很弱的相关性。可是话说回来，这样的谴责虽然道理正确，但并无助于解决问题，而且难免有一种站着说话不腰疼的感觉。更重要的是，久居象牙塔中的我们（包括我在内，也曾具有上述的思维误区），<strong>跟社会的接触少了，就很容易用这种单一的线性的价值观去评判自己和他人，尤其是和别人一比较，各种不如意便会纷至沓来</strong>。而且还是那个问题，人总愿意去相信对自己有利的观点，这就很容易用战术上的勤奋去掩盖战略上的懒惰（即便我在很长时间的科研当中也是如此，没仔细想why就去想how并亲身实践了无数种错误的how，结果自然是充满了无用功和南辕北辙）。</p><p>从上面这个现象引申出来另一个现象，即对部分存在产学研脱节现象学科的劝退，想必大家都了解了许多。如今信息比以前通畅得多，大学新生选择专业以及高校毕业生选择行业的时候比几年之前更懂得去参考历史的行程决定个人的发展方向，其实也未尝不是个好事。我个人曾经也是一个劝退者，但是如今，我觉得更应该做的是，消除信息不对称，也就是让了解信息有限的人们不仅认识到学术这条路的A面，更要了解其B面，对将来可能面临的风险有一个充分的估计，想明白自己追求的是什么。<strong>经过深思熟虑之后做出的选择，要比冲着高大上的标签或者七大姑八大姨的期待做出的选择，要更加理性</strong>。在这个方面，我自己就是活生生的目标不明确东一榔头西一棒子乱打的反例。</p><p>不得不承认做科研的经历是有一定痛苦的（其实任何事情都这样，不存在既高大上又光鲜亮丽的事情）。在自己的课题研究过程中，无数次遇到解不出来的公式，跑不出来的程序，和理论不一样的实验结果，以及各式各样用尽世间已有知识解释不了的问题。与此同时，周围的很多人在积极谋求转行，而金融和互联网成为了转行的首选。在这样的气氛中，除非是自己心里有明确目标且能塌下心来坐得住的人，否则包括我在内的很多人也难免被舆论影响，盖因心里虽然有目标但目标根本不坚定。此时此刻，我再次陷入迷茫，经常思考两个问题：1. 我为什么要来这里？2. 我将来到底想做什么？</p><h2 id="section-6">6</h2><p>时间到了2017年，在社会经历着指数型的科技发展浪潮的过程当中，一种名为勃学的新思潮发展的如火如荼。简而言之，勃学基于失败学，我们每个人都有自己的失败，我们要对自身的失败有清醒的认识。从外界看来，取得了一定世俗成就的人本应是成功的，这样的失败是不是何不食肉糜呢？但是确实，这种思潮确实反映了一部分通过自我奋斗达到一定高度，所看到的世界却灰暗了许多的人们的认同感，尤其是名校毕业生和中产人士。为什么明明已经得到了很多，它们却带来了无尽的挫败感呢？</p><p>这里不谈阶级固化、精英主义等高大上的话题，只想举一个例子。我们的祖辈可能一生都没有走出过小镇，日出而作日落而息生活简单而充实。我们每个人都有那种小学初中同学，早早离开学校进入社会，在我本人朋友圈里看到的一些例子是，他们没有离开家乡，在家乡做着一些相对低收入低技术含量的工作，例如摆摊开店，大部分已经结婚生子，看起来十分快乐，现世安稳岁月静好。而我们很多人，从高考的残酷竞争中杀出来进入名校，可能还出国见了更大的世界，或是找到了高收入的工作，可为什么得不到他们的那种快乐呢？</p><p>我们或许可以这样思考，古人提出过人生三境界，如果我们永远不走出自己的舒适区，那么就是“<strong>看山是山看水是水</strong>”，或者说“我未入过繁华之境，未听过喧嚣的声音，未见过太多生灵，未有过滚烫心情，所以也未觉大洋正中有多么安静”。也因此，对客观世界的认知符合自己的常识，可以很轻易的通过自己的常识得到快乐。</p><p>然而到了第二境界，“<strong>看山不是山看水不是水</strong>”，当我们见了更大的世界，发现自己的一套体系已经不足以解释自己看到的世界，就比如苦心孤诣探索学术十几年，主观上做出了足够的努力，却在客观上收获不了自己想要的“书中自有黄金屋，书中自有颜如玉”，认知崩塌陷入对自己的怀疑，不管归因于“错的是我”抑或是“错的是世界”，价值观就会解体重塑。无论是打破幻影还是打破枷锁，这个过程都是十分痛苦的。</p><p>然而大部分人终其一生也很难达到第三境界，“<strong>看山还是山看水还是水</strong>”，没有一定经历和成就，这一层是连想都很难想象到的。即便是”众里寻他千百度；蓦然回首，那人却在灯火阑珊处“的”啊，原来你也在这里“，不经历一番”昨夜西风凋碧树，独上高楼，望尽天涯路“和”衣带渐宽终不悔，为伊消得人憔悴“的苦痛挣扎也是无法实现的。由于我自己远远没有达到这一境界，因此不多赘述。但总之，”你所认为的世界运行的规律“和”世界真实的运行规律“两者之间大部分情况下存在夹角，甚至有时候夹角还是钝角。因此，你不得不不断地调整自己对世界的认知，而这里面的阻力和惯性，以及调整之后与之前状态的错位，就容易让人怀疑自己所想所做到底对不对。</p><p>曾经有两篇阅读量极高的文章，<a href="https://www.zhihu.com/question/52031149">《我上了985 211才发现自己一无所有》</a>和<a href="https://www.zhihu.com/question/65098412">《一个月就辞职，一个北大女生的求职悲欢》</a>。虽然和勃学并未有联系，但反映的问题却是共通的。有些人对这种现象的批评，包括”无病呻吟“也罢，”庸俗矫情“也罢，其实仔细想想是站不住脚的，由于痛苦不共通，这就像问抑郁症的人为啥要自杀一样缺乏同理心，更何况我相信每个人都有过这样的怀疑和纠结，只是程度不同而已。人生对每个人都只有一次，进入社会见到更大的世界，必然面临着自我和世界的冲突，而处在冲突当中的个人，很容易将自己遇到的问题放大，陷入痛苦，就像小时候辛苦搭好的积木倒塌之后仿佛失去了全世界一样。从这个意义上来说，我倒是觉得同为年轻人的自己和这里面提到的主人公有一定共鸣。同是天涯沦落人，相逢何必曾相识？不过话说回来，该类文章其实反映了一个问题，就是“<strong>学区房值钱（个人奋斗几十年都不一定买得起）</strong>”和“<strong>学历不值钱（名校毕业生的世俗成就达不到内心期望）</strong>”之间的矛盾。所以，这个错位背后，是哪里错了呢？（这个问题我也没有想明白）。</p><h2 id="section-7">7</h2><p>人生总有想不明白的哲学问题，就像科研也永远不能一路顺风一样。2017年发生过太多的事情，以至于刚脱胎换骨一遍的三观又被现实撕得粉碎。其间遇到了转博被拒的挫折，认识了硅谷科技界上百的IT工作者，回国看到了祖国翻天覆地的变化，也经历了对自己价值的彻底怀疑，人际关系的全面崩溃，甚至无数次夜不能寐在凌晨四点的帕罗奥图的天空下失声痛哭。</p><p>然而，冥冥之中总有个声音对我说：</p><p>“<strong>你得到今天的这一切，本来就是运气眷顾，你还想要什么呢</strong>？”</p><p>对啊，能走到今天，我所拥有的东西本来就不是和自己的能力匹配的，你是不是太贪得无厌了？</p><p><strong>“将寄托于花朵的思念用言语来表达出来，我丝毫不想伤害这个世界，如果没有聆听者的话，你就可以放任自己为所欲为吗？</strong></p><p><strong>然而，然而，你却把打算摘给别人的花留下，然后看到他的时候，却为了能得到赞扬把花送给他。</strong></p><p><strong>能找到这么漂亮的花，我是个好孩子吧。我来告诉你怎样去摘这朵花吧！</strong></p><p><strong>像这样假装亲切，好好炫耀一番。 以花为借口亲近他，伪君子。”</strong></p><p align="right">——《School Days》 清浦刹那</p><p>我真的问心无愧吗？</p><p>我的初心是什么？为什么扭曲成了现在这个鬼样子？你看重的东西真的不是虚无缥缈的吗？</p><p>是不是一开始一切都错了呢？</p><p>为什么在给别人建议的时候从未失手，到自己身上就撞南墙撞得头破血流了呢？</p><p><strong>为什么会这样呢？？？</strong></p><p>2017年的冬天格外寒冷，在无尽的挣扎当中，整个冬天不仅科研没有进展，甚至什么都没干，极端的时候甚至想用安眠药一了百了。<strong>（题外话：我知道很多人曾经有过这样的想法，但是在这种时候，请一定一定去找自己信得过的人倾诉，或者去找专业的人员帮助解决心理问题</strong>。如果没有，我本人愿意做一个倾听者，也承诺保密所了解到的一切信息，毕竟我曾经在这样的痛苦中挣扎过。这种情况的人，我彻夜长谈过的，至少有三个，他们现在都已走出了内心的阴影，重获了生活的快乐。）</p><p>人们对于坏消息的第六感往往是非常准确的，尤其是在人生境遇处在低谷的时候。当转博被拒的时候我就觉得有些一厢情愿的事情可能就要到头了。于是我通过各种途径联系了外校的部分教授，硬着头皮再次投了一次博士申请，但是越来越觉得我想要的东西和我正在做的事情已经完全南辕北辙了。</p><p>2017年12月，由于对人生的怀疑和对现实的弃疗，我时常和各种人聊天，谈论各种各样的迷茫及困苦。与三十五岁恋爱都没谈过的博后促膝长谈，也与四十几岁孤身一人漂泊美国的研究员对月举杯。这就是我曾经想做的事情的B面，可是如果换成我，我愿意去赌这一个未知的未来吗？扪心自问，答案是否定的。</p><p><strong>“差一点骗了自己骗了你</strong></p><p><strong>爱与被爱不一定成正比</strong></p><p><strong>我知道被疼是一种运气</strong></p><p><strong>但我无法完全交出自己”</strong></p><p align="right">——《可惜不是你》 梁静茹</p><p>所以，你确定自己不是叶公好龙吗？</p><p>这条路上所需要的努力（1分）、热情（3分）、运气（6分），你一个也没有。</p><p>你的初心可能没错，但是你所做的所想的，和你所追求的东西，完全是两个不同的方向。</p><p>这场持续三年的梦境，是时候该落幕了。</p><p>转过头来2018年到了，雨神似乎笼罩了湾区，终日不见阳光，让人的心情不由得也变得压抑。但是，梦醒了，是时候该回到原点重新开始了。</p><p>留下来读博做不到我不惊讶，联系好的教授放了我鸽子我也不惊讶，反正已经习惯了，起了个大早赶了个晚集的人又不止一个。然而收到第一个offer的时候我心里却五味杂陈。</p><p>一月的寒风中我前所未有的点上了一根烟让自己冷静下来（虽然我这25年来抽过的烟用两只手都能数过来）。烟雾中幻化出无数个平行世界，平行世界A中的我读完博士拿到教职走上人生巅峰令人艳羡，BCD中的我费了九牛二虎之力读完博士转行拿到了和别人本科毕业一样的工作，EFG……而平行世界XYZ中的自己，一生碌碌不得志，最后变成了MITBBS上的戾气溢出屏幕的精神已经不正常的中年loser。</p><p>路是自己选的，将来不管收获的是果，还是锅，也都是自己的。人生没有后悔药，做决策的时候多想想未来，而不要考虑沉没成本。</p><p><strong>“在终于释怀的那一刻</strong></p><p><strong>找回了久违的快乐”</strong></p><p align="right">——《我决定》 梁静茹</p><p>自己辛苦追寻的金刚钻终究没有得到，瓷器活也只能另请高明了。</p><h2 id="section-8">8</h2><p>2018年3月，我来到洛杉矶参加了一场学术会议，算是亲手给自己的追寻（本专业的）学术成就之路画下一个句号。讲完自己海报的一刻，突然有一种神清气爽的感觉，来不及放下东西，直奔加州理工去拜访几个多年未见的好朋友。此时此刻，我终于彻底想明白了一个道理，“<strong>科研和世俗成功两者之间即便不是垂直，夹角也至少有88°</strong>”。有人问88°是怎么得来的，我说用量角器量出来的。量出这个角度，我花了三年，而另一些人，甚至是十三年，三十年。饭桌上跟几个博士在读的朋友聊过，发现原来他们这等神人也有世俗的烦恼（虽然这是废话，但我的思维始终没有转过这个弯来）。家家有本难念的经，我们都是普通人，为什么要互相比较一些有的没的来给自己增加不必要的烦恼呢？求仁得仁，想要什么，就冲着那个方向放手一搏吧。</p><p>于是在几个月的刷题和几年来积累的计算机方面的知识、能力和项目经历的基础上，3月下旬的某一天我一夜之间通过各路朋友的内推向国内互联网公司投了五十份简历。虽然自己这几年来学术上不敢说有所收获，但是人脉和软实力上所积累的一切是我至今不悔留美三年的一个很重要的原因。虽然自己的知识体系必然不系统，但是我个人觉得自己的水平和科班CS大三大四的水平还是比较相当的（除了没有相关科研及实习经历以外）。闻道有先后，术业有专攻，如是而已，终究亡羊补牢也没晚多少。由于名校牌子的加成，整个求职过程还算顺利，连轴面试将近一个月，国内最后拿到4个offer，美国这边也投了几个小公司并都走到了最后一面，由于国内的offer到了，加之我个人在这里实在是过得不快乐，所以就没再继续面下去。本着此心安处是吾乡的原则，选完城市，再选公司，兜兜转转回到了最熟悉的五道口，加入一家蒸蒸日上的创业公司。（题外话：在五道口的前辈和友人们欢迎到时找我约饭。）</p><p>由于我实力有限加上并非走的正常校招流程，具体的求职细节就不在这里讲了，以防班门弄斧。如果同为转专业且对这个过程有兴趣将来可以私聊。当然不得不承认，由于求职始于匆忙，中间各种问题也出过不少，还出过一个差点没法毕业的乌龙，不过最终的结果还算不错，经过了几年的尝试，用了无数次排除法，在此刻虽然我也不敢说自己一定喜欢做什么，但是有把握说自己不喜欢做什么。这就像一个深度优先搜索一样，撞了南墙再回头，虽然有时候走了不少冤枉路撞了不少南墙，比别人晚到了目的地，可是看到的东西也更多了。</p><p>我曾经想过，如果高中多搞一门竞赛会怎样，大学选择一个不同的专业会怎样，研究生期间年年暑假出去实习会怎样，再仔细一想，在没有信息的情况下有多少人能做出这样的选择，而从最终结果看起来也不过是小的得失而已。有些事情放在当时看，重要吗？的确重要。可是从更长远的时间看来，什么都不是。如同幼儿园丢了个小红花，中学错过了喜欢的人，高考失利，求职遇挫，每个人都会对此做出应激反应，可是几年之后回首，也不过是饭桌上的一件谈资而已。</p><p>在上篇《老实人的归国与失身》中我曾经提到，求职过程中受到高中同学的内推，文中提到的高中同学本科位于家乡普通一本，通过考研来到了北京，积累了无数的实习经历最终在另一家独角兽企业独当一面。文中结尾提到的“明明是我先来的，为什么会变成这样呢？”本来是一个出自《白色相簿2》的梗，招致了一些不懂背景的人的误会。什么叫做线性思维/学生思维？这就是。早起的人不一定能赶上集，生活本来也没有先来后到。更何况别人在另一些方面比自己先来，比如工业界经验，比如对社会的认知，这都是象牙塔本身所给不了自己的。该篇文章中的主人公可能也是幸存者偏差的产物。</p><p>前段时间和朋友讨论，说到了不同的人在不同阶段所做的努力和承受的痛苦。从高考大省杀出来固然需要拼命，但从考研大省逆袭何尝不需要努力，而且艰苦程度也是非亲历者不能想象。我们能看到的例子是通过个人奋斗逆袭走上人生巅峰的人们，可是在这背后的B面，多少人在这一过程中折戟撞墙，最终成为了默默无闻的普通人，他们的故事又如何去表达出来呢？</p><p>什么是幸存者偏差？2018年高考全国二卷的作文就很能说明问题。</p><p><img src="https://img-blog.csdnimg.cn/20191202223556152.png" alt="在这里插入图片描述" /> 2018年6月，在即将离开美国的时候，我与科研大佬聊过他们申请教职当中的悲与喜，与硅谷科技从业者谈到科技下一步的发展方向，与现在的牛人本科生讨论他们的梦想，与00后一代学习他们的价值体系和处世方式，也与在国内的本科同学们交流不同行业的求职经历，以及当前日新月异的一线城市。曾经的自己只顾脚下的一条路，以为这就是整个世界，到头来路越走越窄以至于痛撞南墙。而抬起头来，发现参差多态乃是幸福本源，生活的跑道比自己想象的还要多得多。而这个时代恰恰也是信息量爆炸的时代，每个人都在追寻自己的梦想，就看谁能把握住这里面的机会。</p><p><strong>“回想起历往云烟终于让我全都看透</strong></p><p><strong>闭着眼低头走过那份温柔”</strong></p><p align="right">——《涙の理由》 栗林美奈实</p><p>总之，运气眷顾，在一个新的领域，我在不知道自己有没有金刚钻的情况下又接下了瓷器活。可如今最大的不同就是，即便没有金刚钻，我也知道如何去获得它。即便无法获得，我也知道如何打磨现有的资源使之无限接近真正的金刚钻。几年的摸索告诉了我这样的方法论，也算是不虚此行了。感谢一路上遇到的前辈和同辈，感谢他们给我的指引和人生经验，感谢遇到的挫折使我想明白自己内心深处究竟想要的是什么，感谢命运待我还算不薄。路还很长，所以更要心无旁骛望着远方。</p><p>最后放一张图，描述在这么多年来我”想当一名科学家“的这个愿望的强烈程度是如何变化的。虽然走到现在，这条路上的追寻暂时鸣金收兵了，但失之东隅收之桑榆，我也看到了更广阔的风景，开始了另一条路上新的追寻。</p><figure><img src="https://img-blog.csdnimg.cn/20191202223756684.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="section-9">9</h2><p>时光飞逝，我自己的学生时代即将结束。清华四年经历告诉了我自己的能力是有局限的，而美国三年经历告诉了我天有多高地有多厚。虽然初心只是自己幼稚时候的一厢情愿，但人在长大的过程中都会变的，甚至在半年之前我都没有料到今天是这样的结局，计划永远赶不上变化，而未知的未来可能信息量更大。有时候我在思考一个问题：我一路以来享受了最好的教育资源，可是有没有做出相符的成绩和贡献呢？如果没有的话，我从中积累了什么优势呢？眼界，人脉，还是对更大的世界的认知，对自己较为全面的评价？</p><p>如果限制我们的成就的是外在因素，很多时候我们只会惋惜命运待人不公。就如同如果基础教育能够普及，广袤的非洲能走出多少科学家？可是这里面无数的聪明人就因为食不果腹而终其一生无法为人类的发展做出贡献。而我自己，出身明明优于90%的同辈人，享受着最好的教育资源，不缺天时地利人和，想要找到贵人相助也不难，在人生的重要选择关口也不乏运气垂青，理应有着更大的使命，为这个世界做出自己更大的贡献。然而，有时候事情的发展偏离了预想的轨道，现实情况和自我期待出现错位，明明自己能力达不到却不得不去努力争取，明明追寻的东西就在眼前看似唾手可得但就是得不到，那种失落和不甘心，如同差一点爬到高峰又狠狠摔下，带来的痛苦就要比在平地上跌倒要强烈得多。</p><p>我的经历和反思讲完了，在最后，我觉得有必要给出一些简单的结论：</p><p><strong>（0）选择正确的方向比努力更重要，而信息的通畅是做出明智选择的保证。将获取信息的能力从1提到2，边际效应要远远胜过努力程度由9提到10。</strong></p><p><strong>（1）对于名校同学，有时候我们自身带着一种骄傲，但在校内评价体系下受到的打击会令我们自卑，两者叠加在一起会让我们很难对自己有准确的定位。然而，既然享受着资源优势，而且终究都要走出象牙塔走向社会（即便是立志从事科研工作也不能免除与更大的世界打交道），不如早点接触真实的工作环境，在找到自己价值所在的同时，提前排除错误选项或者选定正确选项，不至于到最后赢在了成绩却输在了社会经验。</strong></p><p><strong>（2）对于非名校同学，高考、毕业学校这些东西和将来的成绩的相关度是很弱的，通过主动获取信息做出明智的选择，避免无头苍蝇一般的无效努力，进而比名校学生优秀的也大有人在。没有那种小心翼翼瞻前顾后患得患失，反而更大胆去试错和总结经验，这些都不是从书本上能够学到的。</strong></p><p><strong>（e）(e=2.718281828) 综上所述，高考考的如何和去什么学校读书真的没那么重要，在需要努力的时候尽力而为，但永远记得仅仅是努力本身是没有价值的。打怪升级获得的奖励，从来都不是和打怪的难度成正比。</strong></p><p><strong>（3）老实人们会习惯性认为，努力读书、努力工作等等才是能力，然而，真相却是，“不老实”可能是一种比个人奋斗更重要的能力。</strong></p><p><strong>（π）(π=3.141592654) 因此，老实，其实并不是一个好事。</strong></p><p>满纸荒唐言，一把辛酸泪。</p>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Predecessor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 590</title>
      <link href="/2019/10/02/Codeforces%20Round%20#590/"/>
      <url>/2019/10/02/Codeforces%20Round%20#590/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1234">Round #590</a><br />题目答案：<a href="https://codeforces.com/blog/entry/70233">官方Editorial</a>、<a href="https://github.com/EIMadrigal/CF">My Solution</a></p><h2 id="a.-equalize-prices-again">A. Equalize Prices Again</h2><p>签到题还WA了一发，向上取整有点问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my wrong code, 1.0 * sum返回double</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">1.0</span> * sum / n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//right code</span></span><br><span class="line">(<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="number">1.0</span> * sum / n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ceil()原型</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p><code>float</code>能保证6位精度（有效数字），<code>double</code>能保证15位精度。但是<code>float</code>和<code>double</code><strong>默认都只显示6位有效数字</strong>，所以一旦<code>1.0 * sum / n</code>大于6位，函数返回的<code>double</code>就显示不全，造成精度损失（比如结果应该是<code>5336844</code>，但返回<code>5.33684e+006</code>），故进行强制类型转换。</p><h2 id="b1.-social-network-easy-version">B1. Social Network (easy version)</h2><p>题意：屏幕可以容纳<span class="math inline">\(k\)</span>条短信，有若干朋友发来<span class="math inline">\(n\)</span>条短信。如果某个朋友已经在屏幕上，不做改变；否则将其他朋友下移，新收到的朋友置顶。求最终自顶向下显示在屏幕上的朋友。<br />思路：按照题意模拟，我搞得有些繁琐（用<code>queue + set</code>来考虑是否将新来的短信放入屏幕，再用<code>queue.size()</code>和<span class="math inline">\(k\)</span>判断是否需要将旧短信<code>pop()</code>，最后将队列中的元素逆序输出）。</p><h2 id="b2.-social-network-hard-version">B2. Social Network (hard version)</h2><p>数据量变到了<span class="math inline">\(10^5\)</span>级别，官方题解和我在B1中的思路一致。不过最后输出我是先压栈，题解是先存入<code>vector</code>，再用<code>reverse()</code>函数逆序，复杂度<span class="math inline">\(O(nlogk)\)</span>。</p><h2 id="c.-pipes">C. Pipes</h2><p>模拟题：比赛时候发现了既然可以无限旋转，那么管道一共有2类：<span class="math inline">\(12\)</span>一样，<span class="math inline">\(3456\)</span>一样。<br />水流到<span class="math inline">\(12\)</span>这类，只能水平向右流；<br />流到<span class="math inline">\(3456\)</span>这类，那么另一行对应的位置也必须是<span class="math inline">\(3456\)</span>类，水就会换一行流动（异或即可换行），否则水没法继续流动。<br />最后判断水能否流到第二行第<span class="math inline">\(n\)</span>列。</p><h2 id="d.-distinct-characters-queries">D. Distinct Characters Queries</h2><p>题意：给一字符串和<span class="math inline">\(q\)</span>次查询，查询分为两类：一类是替换字符串中某个字母，另一类是求子串中非重复字符的个数。<br />比赛时的思路是：遇到第一类查询就按规则替换，第二类先拿到子串，依次把子串的每个字符放入<code>set</code>中，最后返回<code>set.size()</code>即是非重复字符个数。<br />此题的教训就是要学会根据数据量级猜算法：1s/2s时限，C++运算次数大约在<span class="math inline">\(10^7\)</span>，本题的数据范围<span class="math inline">\(10^5\)</span>，我傻傻地把<span class="math inline">\(O(n^2)\)</span>的算法交了三次，TLE了三次，我还以为是<code>cin</code>的问题。。。<br />参考下大佬经验：<a href="https://www.acwing.com/blog/content/32/">由数据范围反推算法复杂度</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 587</title>
      <link href="/2019/09/23/Codeforces%20Round%20#587/"/>
      <url>/2019/09/23/Codeforces%20Round%20#587/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1216">Round #587</a><br />题目答案：<a href="https://codeforces.com/blog/entry/69954">官方Editorial</a>、<a href="https://github.com/EIMadrigal/CF">My Solution</a></p><h2 id="a.-prefixes">A. Prefixes</h2><p>题意：给一字符串，只含有<code>'a'</code>或<code>'b'</code>，需要改变某些位置（<code>'a'</code>变<code>'b'</code>或<code>'b'</code>变<code>'a'</code>），使得该字符串任意偶数长度前缀中<code>'a'</code>和<code>'b'</code>个数相等，求改变的最少次数以及更改后的字符串。</p><p>题解：遍历，判断<code>s[2i]</code>和<code>s[2i+1]</code>是否相等。如果相等，需要一次更改，并将其中一个改为不同字母。</p><h2 id="b.-shooting">B. Shooting</h2><p>题意：给<span class="math inline">\(n\)</span>个编号<span class="math inline">\(1\)</span>~<span class="math inline">\(n\)</span>的射击目标，每个目标有不同的耐久度，假设已经击倒了<span class="math inline">\(x\)</span>个目标，将要射击第<span class="math inline">\(i\)</span>个目标，那么需要<span class="math inline">\(a_i*x+1\)</span>次才可以击倒该目标，<span class="math inline">\(a_i\)</span>为第<span class="math inline">\(i\)</span>个目标的耐久度。求击倒所有目标的最少射击次数以及射击次序。</p><p>题解：贪心。想要射击次数最少，就要先射击耐久度大的目标，所以按照耐久度由大到小排序，同时记录对应的目标序号。</p><h2 id="c.-white-sheet">C. White Sheet</h2><p>题意：给定三个矩形，两黑一白，判断两个黑色矩形是否可以完全覆盖白色矩形，不能完全覆盖输出<code>YES</code>。</p><p>题解：分两种情况，记白色矩形面积为<span class="math inline">\(S_w\)</span>，一个黑色矩形与白色矩形交叉面积为<span class="math inline">\(S_{wb1}\)</span>，另一个黑色矩形与白色矩形交叉面积为<span class="math inline">\(S_{wb2}\)</span>，两黑色矩形交叉面积为<span class="math inline">\(S_{bb}\)</span>：<br />1、两黑色矩形无交叉：只要<span class="math inline">\(S_{wb1}+S_{wb2}&lt;S_w\)</span>，就可以看到白色矩形；<br />2、两黑色矩形有交叉：如果<span class="math inline">\(S_{wb1}+S_{wb2}-S_{bb}&lt;S_w\)</span>，可以看到白色矩形。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Online Judge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Recursion and Backtracking</title>
      <link href="/2019/09/16/Recursion%20and%20Backtracking/"/>
      <url>/2019/09/16/Recursion%20and%20Backtracking/</url>
      
        <content type="html"><![CDATA[<p>DFS是一种图的遍历算法:</p><ol type="1"><li>从任意结点v开始</li><li>将v标记为已访问</li><li>递归访问v的所有未访问过的邻居</li></ol><p>对于树而言, 有向无环, 不用担心结点被访问2次, 因此不需要标记. 无向图可以看作双向有向图, 因此始终是有环的, 也需要标记.</p><h2 id="tree-recursion">Tree Recursion</h2><p>递归是计算机科学中一个非常重要的概念，对于斐波那契那种比较简单的递归，分析起来比较容易，但是由于二叉树涉及指针操作，所以模拟下遍历过程中系统栈的情况。<br />以二叉树中序遍历为例演示： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 中序遍历的递归实现：<br /><img src="https://img-blog.csdnimg.cn/20190915232047750.png" alt="在这里插入图片描述" /><br />假设二叉树如图所示： <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDE5MDkvMTI2MDU4MS0yMDE5MDkxNTIzMTQyMDE5MS0xMTMxOTk2Nzc2LnBuZw?x-oss-process=image/format,png" /><br />其中序遍历序列为<span class="math inline">\(2413\)</span>，可以在VS中用单步调试的方法跟踪相应的变量：<br />当<code>root==NULL(root指向2的左孩子)</code>时，此时的系统栈（将1和2都压栈，因为中序遍历需要先访问左孩子）：<br /><img src="https://img-blog.csdnimg.cn/20190916223229149.png" alt="在这里插入图片描述" /><br />这时<code>if</code>不成立，执行83行的<code>return</code>语句，接着退栈，回到78行，此时的<code>root指向2(因为此时程序已经来到了新的栈顶)，并且向这个新栈顶返回了一个空的seq</code>：<br /><img src="https://img-blog.csdnimg.cn/20190916223847870.png" alt="在这里插入图片描述" /><br />接着执行79行(因为这是上一个函数<code>return</code>的，所以不会再一次执行78行)，将2存入<code>seq</code>中；<br />执行80行（<code>root</code>指向4），进而执行78行，<code>root</code>指向4的左孩子，此时的系统栈（很明显可以看到从<strong>栈底到栈顶依次存放根结点到当前<code>root</code>结点的路径</strong>上的结点）：<br /><img src="https://img-blog.csdnimg.cn/20190916225924483.png" alt="在这里插入图片描述" /><br />同样，执行<code>return</code>语句，退栈，将<code>seq</code>(里面只有2)返回到这一层，这一层的<code>root</code>指向4，接着将4存入<code>seq</code>；<br />到80行，调用<code>inOrder()</code>使得<code>root</code>指向4的右孩子，右孩子为空，所以返回并退栈，<code>root</code>重新指向4，此时80行执行完毕，整个<code>if</code>执行完毕，返回<code>seq</code>并退栈，<code>root</code>返回到了2，以2为根结点的子树中序遍历完毕，系统栈：<br /><img src="https://img-blog.csdnimg.cn/20190916230804141.png" alt="在这里插入图片描述" /><br />继续执行，return到78行，<code>root</code>指向1，将1存入seq，以此类推，就可以得到整个的遍历序列。</p><p>最关键的是：之所以要递归调用<code>inOrder</code>，就是因为现在还不想访问当前的结点（对于中序，要先找到最左边的结点），所以通过递归的方式将当前暂时不想访问的结点压入系统栈，找到了想访问的结点后，访问它并利用退栈操作返回父结点。<br />有关树的问题，有一些通用的模板： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one root</span></span><br><span class="line"><span class="function">func <span class="title">solve</span><span class="params">(root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)  <span class="keyword">return</span> ...</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">f</span>(root) <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">solve</span>(root-&gt;left);</span><br><span class="line">    r = <span class="built_in">solve</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(root, l , r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// two roots</span></span><br><span class="line"><span class="function">func <span class="title">solve</span><span class="params">(p, q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == null &amp;&amp; q == null)  <span class="keyword">return</span> ...</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">f</span>(p, q)  <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">solve</span>(p.child, q.child);</span><br><span class="line">    r = <span class="built_in">solve</span>(p.child, q.child);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(p, q, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典递归">经典递归</h2><p>除了树这种本身就是递归定义的结构外，还有一些search的问题也可以通过递归解决： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">length</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>] == s[s.<span class="built_in">length</span>() - <span class="number">1</span>] &amp;&amp;</span><br><span class="line">        <span class="built_in">isPalindrome</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>, s.<span class="built_in">length</span>() - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NotFound = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSearch</span><span class="params">(vector&lt;string&gt;&amp; v, <span class="keyword">int</span> start, <span class="keyword">int</span> stop, string key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; stop) <span class="keyword">return</span> NotFound;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (start + stop) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == v[mid])</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; v[mid])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSearch</span>(v, mid + <span class="number">1</span>, stop, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSearch</span>(v, start, mid - <span class="number">1</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == k || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C</span>(n - <span class="number">1</span>, k) + <span class="built_in">C</span>(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(string soFar, string rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            string next = soFar + rest[i];</span><br><span class="line">            string remaining = rest.<span class="built_in">substr</span>(<span class="number">0</span>, i) + rest.<span class="built_in">substr</span>(i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">permute</span>(next, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无重复值</span></span><br><span class="line"><span class="comment">// call stack只有该层所有for循环结束才回退 因此不能传vector&lt;int&gt; path</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; used, vector&lt;<span class="keyword">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">permutation</span>(nums, used, path, ans);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对数组a的[l, r]做全排列</span></span><br><span class="line"><span class="comment"> * 每个数字都要充当第一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[l], a[i]);  <span class="comment">// 第i个元素充当第一个</span></span><br><span class="line">        <span class="built_in">perm</span>(a, l + <span class="number">1</span>, r);  <span class="comment">// 剩余元素全排列</span></span><br><span class="line">        <span class="built_in">swap</span>(a[l], a[i]);  <span class="comment">// 恢复状态，保证下个做第一个元素的状态正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200704153124426.png" alt="在这里插入图片描述" /> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">com</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == d) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">com</span>(nums, n, d + <span class="number">1</span>, i + <span class="number">1</span>, cur, ans);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsets</span><span class="params">(string soFar,string rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// add to subset, remove from rest, recur</span></span><br><span class="line">        <span class="built_in">subsets</span>(soFar + rest[<span class="number">0</span>], rest.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// do not add to subset, remove from rest, recur</span></span><br><span class="line">        <span class="built_in">subsets</span>(soFar, rest.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200704153731705.png" alt="在这里插入图片描述" /><br />从递归树可以看到：Permutation和Subsets都是关于<em>选择</em>的问题，树的深度代表选择的次数，每层的宽度代表每次决定时的选项。这种都是Exhaustive Recursion，所以复杂度很高。</p><h2 id="backtracking">Backtracking</h2><figure><img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211129144559235-1738742177.png" alt="" /><figcaption>image</figcaption></figure><p>主要可以解决<strong>组合问题</strong>、<strong>排列问题</strong>、<strong>子集问题</strong>、<strong>字符串切割问题</strong>、<strong>棋盘问题</strong>，这些问题都可以抽象为<strong>多叉树的搜索问题</strong></p><figure><img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211129090136628-461210128.png" alt="" /><figcaption>image</figcaption></figure><p>回溯用来搜索选择性问题（a series of choices）的所有/部分解，每做一次选择，就递归一次，如果约束条件不满足，需要<strong>回退到上一层递归的参数状态</strong>。通常在返回上层之前，要将本层节点的状态还原。<br />通过约束条件的剪枝可以避免对整个搜索空间的穷举，从而提高效率。</p><p>三个关键点：</p><ol type="1"><li>Choice<br />明确要做的决定，<strong>每次递归代表一次决定，每次的决策结果都保存在这一层的call stack中</strong>。<br />eg. 遍历二叉树时，当处在某一层的某结点时，下一次递归调用是向左还是向右。</li><li>Constraints<br />怎样剪枝，当前状态已经invalid，不必再从该状态继续搜索，直接返回。</li><li>Goal<br />找到target后，就要回溯到上一层，进行其它可能性的搜索。</li></ol><p>Pattern： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// backtracking</span></span><br><span class="line"><span class="keyword">bool</span>/<span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(configuration conf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (no more choices)  <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> (conf is goal state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (all available choices) &#123;</span><br><span class="line">        <span class="keyword">try</span> one choice c:</span><br><span class="line">        <span class="comment">// solve from here, if works out, you are done</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(conf with choice c made))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        unmake choice c;   <span class="comment">// explore other solutions</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// tried all choices, no soln found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>几个例子：</p><ol type="1"><li>N-Queens<br />对照N皇后问题，明确三个关键点：<br />1）对于每一列，要做的决定是将Q放在哪一行，每次递归都会进入下一列的决策；<br />2）约束条件：不能出现在同一行、同一列、同一斜线；<br />3）目标：当在最后一列成功放置Q后，就可以回溯到上一层去探索其它解。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(grid&lt;<span class="keyword">bool</span>&gt;&amp; board, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (col &gt;= board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rowToTry = <span class="number">0</span>; rowToTry &lt; board.<span class="built_in">size</span>(); ++rowToTry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSafe</span>(board, rowToTry, col)) &#123;</span><br><span class="line">            <span class="built_in">placeQueen</span>(board, rowToTry, col);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(board, col + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">removeQueen</span>(board, rowToTry, col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>Sudoku<br /><img src="https://img-blog.csdnimg.cn/20200704162901848.png" alt="在这里插入图片描述" /><br />将1-9放入格子，要求每行、每列、每块不能有重复数字。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(Grid&lt;<span class="keyword">int</span>&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the gird to check, we should check all the grids</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all grids assigned successfully</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">findUnassigned</span>(grid, row, col)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; ++num) &#123; <span class="comment">// options are 1-9</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">noConflict</span>(grid, row, col, num)) &#123;</span><br><span class="line">            <span class="built_in">grid</span>(row, col) = num; <span class="comment">// try assign</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(grid)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">grid</span>(row, col) = UNASSIGNED; <span class="comment">// undo and try again</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明白了回溯的基本流程，那么一个问题呼之欲出，什么时候需要回溯，什么时候不需要？</p><p>之所以需要回溯，是因为来到<span class="math inline">\((x,y)\)</span>这个状态后，我们不清楚是否要选择该状态，因此先尝试去选择该状态<code>vis(x,y)=True</code>，然后继续向后搜索<code>dfs(x+i,y+j)</code>。如果发现这样的选择无法得到正确的结果，就尝试不选择该状态<code>vis(x,y)=False</code>，看看能否获得期望的结果。</p><p>从实践的角度，当某个状态可能被多条DFS共同访问时（如全排列问题），通常完成一条DFS后需要回溯。当状态只需要访问一次就可以获取最终的结果（如岛屿数量问题），那么无需回溯，这种情况下回溯通常会导致错误的重复计算。</p><h2 id="主定理">主定理</h2><p>子问题规模相等 <span class="math display">\[T(N)=aT(\frac{N}{b})+O(N^d)\]</span></p><ul><li><span class="math inline">\(log_ba&lt;d\rightarrow O(N^d)\)</span></li><li><span class="math inline">\(log_ba&gt;d\rightarrow O(N^{log_ba})\)</span></li><li><span class="math inline">\(log_ba=d\rightarrow O(N^dlogN)\)</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>球员归化</title>
      <link href="/2019/09/10/%E7%90%83%E5%91%98%E5%BD%92%E5%8C%96/"/>
      <url>/2019/09/10/%E7%90%83%E5%91%98%E5%BD%92%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="历史时刻">历史时刻？</h2><p>2019年9月10日，2022年卡塔尔世界杯亚洲区预选赛，马尔代夫对阵中国。 归化球员Elkeson身披11号球衣，代表中国男足首发出战。 不久之前，Elkeson加入中国国籍，甚至连自己中文名字（艾克森）还不会写、国歌都不会唱，却成为了国家队的一员。</p><h2 id="福还是祸">福还是祸？</h2><p>我个人一直是坚定地反对无血缘归化，可是舆论好像支持的比较多。 回顾历史，国足只在2002年打进过一次世界杯。受到零几年黑球、假球的影响，我们的足球人才出现了严重的断档，自然国家队的水平也长期徘徊在亚洲二三流。 长期无缘世界杯让我们的球迷焦躁不安，更是由于老大喜欢足球，并且多次在公开场合表示要把中国足球搞上去，中国足协出了各种各样的奇葩政策：</p><ol type="1"><li>高薪聘请国外教练：里皮、阿里汉、卡马乔，解约卡马乔时支付5000万违约金；</li><li>在中超联赛施行U23政策，俱乐部也是上有政策、下有对策：U23球员的出场时间非常可怜，只是满足足协最低要求而已；</li></ol><p>可惜，就是不把主要精力放在青训上，总想着捷径：当然，这也是官僚一贯的急功近利作风，前人栽树后人乘凉的事想都不要想。 中超联赛踢得如火如荼，可是没有跑道的专业球场屈指可数； 外援垄断了射手榜和关键位置，国内球员只是陪跑； 如果静下心来踏踏实实做好青训，规范我们的联赛，开展俱乐部各级梯队的比赛，做好校园足球的普及和推广，就像姚明对中国篮球的改革一样，那么我们10年后一定可以打进世界杯，可惜领导从来不会有这样的耐心。 其实我们的目标只是打进世界杯而已，从来就不是提高中国足球的水平。围绕这个任务，所有的一切也都得到了非常合理的解释：在恒大建立国家集训队、无血缘归化...... 有人说归化可以带动中国足球水平的提高，让越来越多的孩子走上职业联赛，并且归化和青训可以同时进行。。。 就足协那个尿性，一旦从归化中尝到了甜头，还有谁愿意冒着风险、付出成本去做青训？ 我对Elkeson并不反感，从2013年亚冠就开始看他的比赛。在俱乐部层面，他给中国足球带来了亚冠冠军；平时生活中对中国文化也很尊重； 加入中国国籍可能有对于这个国家的热爱，但是背后是8~9位数的薪资以及复杂的利益纠缠，否则怎么会那么轻易主动放弃自己祖国国籍？ Elkeson只是第一个，后面可能还有高拉特、费尔南多、阿洛伊西奥......这就是恒大许老板所谓的“全华班”？ 这样即使打进世界杯，看着巴西人组成的前锋线，球迷心里真的还会有那份民族自豪感吗？ 另外，归化对于联赛的公平运作也是毁灭性的打击。其他俱乐部的外援都去恒大，足协钦定的政策谁敢不从？ 喊了这么多年联赛职业化，可惜中超的职业化只是政治因素下的可笑的玩物！ 曾经，国家队的每场比赛我都不会错过：赢了我激动地欢呼，输了我会难过好几天。见过它的高光，也陪伴它走过低谷。 这次我是真的失望到无法接受：从今天开始，我不会再关注中国足球的任何消息，这潭泛着恶臭的死水已经开始恶心到我了！ 以后就看看梅西、阿森纳和西班牙就行了~</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Football </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高墙与鸡蛋</title>
      <link href="/2019/09/06/%E9%AB%98%E5%A2%99%E4%B8%8E%E9%B8%A1%E8%9B%8B/"/>
      <url>/2019/09/06/%E9%AB%98%E5%A2%99%E4%B8%8E%E9%B8%A1%E8%9B%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="村上在耶路撒冷">村上在耶路撒冷</h2><p>2009年春天，村上春树获得了“耶路撒冷文学奖”。当时巴勒斯坦和以色列之间的冲突愈演愈烈，很多人都劝阻村上不要去以色列领奖，何况村上其实对公开场合发表演讲、接受采访这些事是比较排斥的。 他最终还是决定出席（原因他在演讲时解释了），并且发表了极为精彩的演说--“高墙与鸡蛋”。 全文还是不太好找，不过最终在林少华先生的博客中找到了中文版（林少华先生是村上小说很重要的翻译家）：<a href="http://blog.sina.com.cn/s/blog_48f36ce00100e3qd.html">原文链接</a></p><blockquote><p>我作为一个小说家，换句话说，作为以巧妙说谎为职业的人来到这里、来到耶路撒冷市。</p><p>当然，说谎的不都是小说家。诸位知道，政治家屡屡说谎，外交官和军人说谎，二手车推销员、肉铺和建筑业者也说谎。但小说家说谎和他们说谎的不同之处在于：小说家说谎不受道义上的谴责。莫如说谎说得越大越高明，小说家越能得到人们的赞赏和好评。为什么呢？</p><p>这是因为，小说家能够通过巧妙说谎、通过栩栩如生的虚构而将真相拽到另一场所投以另一光照。以其固有的形式捕捉真相并予以准确描述在许多情况下是不可能的。惟其如此，我们才要把真相引诱出来移去虚构地带，通过将其置换为虚构形式来抓住真相的尾巴。但为此必须首先在自己心底明确真相的所在，这是巧妙说谎所需要的重要资格。</p><p>可是今天我不准备说谎，打算尽可能说实话。一年之中我也有几天不说谎，今天恰好是其中的一天。</p><p>实话实说好了。关于此次来以色列接受耶路撒冷文学奖，不少人劝我最好拒绝。甚至警告说如果前来，将开展不买我的书的运动。无须说，理由在于加沙地区的激战。迄今为止，已不止一千人在被封锁的城区丧生，据联合国报告，大多数是儿童、老人等手无寸铁的平民。</p><p>接到获奖通知以来，我本人也一再自问：这种时候来以色列接受文学奖果真是妥当的行为吗？不会给人以支持作为纷争当事者一方、拥有占绝对优势的军事力量并积极行使的国家及其方针的印象吗？那当然不是我所希望的。我不认可任何战争，不支持任何国家。同时，自不待言，我的书在书店被人拒买也不是我所希求的。</p><p>然而，经过深思熟虑，我重新坚定了来这里的决心。原因之一，就在于有那么多人劝我最好别来。或许我有一种大部分小说家都有的“犟脾气”--别人叫我“别去那里”、“别干那个”、尤其那样警告我的时候，我就偏偏想去或想干，此乃小说家的nature（天性）。为什么呢？因为小说家属于这样一种人：无论刮怎样的逆风，也只能相信自己实际目睹、自己实际手摸的东西。</p><p>正因如此，我才出现在这里。较之不来，选择了来；较之什么也不看，选择了看点儿什么；较之什么也不说，选择了向诸位说点儿什么。</p><p>有一句话（message）请允许我说出来，一句个人性质的话。这句话在我写小说时总在我脑袋里挥之不去。它并非写在纸上贴在墙壁，而是刻于我的脑壁。那是这样一句话：</p><p><strong>假如这里有坚固的高墙和撞墙破碎的鸡蛋，我总是站在鸡蛋一边。</strong></p><p>是的，无论高墙多么正确和鸡蛋多么错误，我也还是站在鸡蛋一边。正确不正确是由别人决定的，或是由时间和历史决定的。假如小说家站在高墙一边写作--不管出于何种理由--那个作家又有多大价值呢？</p><p>那么，这一隐喻到底意味什么呢？在某种情况下它是简单明了的。轰炸机、坦克、火箭、白燐弹、机关枪是坚硬的高墙。被其摧毁、烧毁、击穿的非武装平民是鸡蛋。这是这一隐喻的一个含义。</p><p>但不仅仅是这个，还有更深的含义。请这样设想好了：我们每一个人都或多或少分别是一个鸡蛋，是具有无可替代的灵魂和包拢它的脆弱外壳的鸡蛋。我是，你们也是。再假如我们或多或少面对之于每一个人的坚硬的高墙。高墙有个名称，叫作体制（System）。体制本应是保护我们的，而它有时候却自行其是地杀害我们和让我们杀人：<strong>冷酷</strong>地、高效地、而且系统性地（Systematically）。</p><p>我写小说的理由，归根结底只有一个，那就是为了让个人灵魂的尊严浮现出来，将光线投在上面。经常投以光线，敲响警钟，以免我们的灵魂被体制纠缠和贬损。这正是故事的职责，对此我深信不疑。不断试图通过写生与死的故事、写爱的故事来让人哭泣、让人惧怕、让人欢笑，以此证明每个灵魂的无可替代性--这就是小说家的工作。我们为此而日复一日地认真编造故事。</p><p>我的父亲去年夏天去世了，活了九十岁。他是个退休教师，也是个兼职佛教僧侣。在研究生院就读期间被征召入伍，参加了中国大陆的战斗。我小的时候，他每天早上都在饭前向佛坛献上长长的深深的祈祷。一次我问父亲为什么祈祷，他回答为了在战场死去的人，为了在那里--无论友方敌方--失去性命的人。每次看见父亲祈祷的身姿，我都觉得那里似乎漂浮着死亡的阴影。</p><p>父亲去世了，其记忆--还没等我搞清是怎样的记忆--也彻底消失了。但是，那里漂浮的死亡气息仍留在我的记忆中。那是我从父亲身上继承的少数然而宝贵的事项之一。</p><p>我在这里想向诸位传达的只有一点：我们都是超越国籍、种族和宗教的一个一个的人，都是面对体制这堵高墙的一个一个的蛋。看上去我们毫无获胜的希望。墙是那么高那么硬，那么冰冷。假如我们有类似获胜希望那样的东西，那只能来自我们相信自己和他人的灵魂的无可替代性并将其温煦聚拢在一起。</p><p>请这样想想看。我们每一个人都有可以拿在手中的活的灵魂，体制则没有。不能让体制利用我们，不能让体制自行其是。不是体制创造了我们，而是我们创造了体制。</p><p>我想对诸位说的仅此一点。</p><p>荣获耶路撒冷奖，我很感谢。感谢世界很多地方都有看我书的人。我要向耶路撒冷的每一位读者致以谢意。毕竟是因了你们的力量我才出现在这里的。但愿我们能够共同拥有什么--非常有意义的什么。我很高兴得以来此向诸位讲话。</p></blockquote><p>村上的小说一直强调个人的自由，他也一直希望每个个体都能拥有独特的生活方式、活出自我，而不是被体制化（Institutionalization）。 其实发表演讲时，如果不是因为战争的背景以及村上的解释，那么我对于<strong>永远站在鸡蛋一边</strong>是无法苟同的：试想如果鸡蛋（弱势者）的行为的确非常过分，那么如此绝对地站队是不是有些混淆是非呢？ 不过村上的浅层隐喻是在讽刺战争对平民的伤害，更深层次的是对体制的搏斗以及自由的向往，这些观点足以让我信服。</p><h2 id="hard-boiled">Hard-Boiled</h2><p>这篇演说比较有趣的地方在于：村上这个系统建构狂魔为读者解释了他的一本小说的名字（这个我也是从杨照老师那里了解的）：《世界末日与冷酷仙境》。 这本小说本来是直接用英语命名，把英语写成日语外来语起名。原来叫做Hard-Boiled Wonderland and the End of the World，Wonderland比较明显出自于Alice's Adventures in Wonderland（爱丽丝梦游仙境），但是Hard-Boiled只看字面意思的话，很难理解为什么会翻译成冷酷，应该是沸腾加热这种意思才对啊~ Hard-Boiled一般就只用在美国人吃早餐时候：服务员会问你要的eggs是要soft-boiled or hard-boiled？全熟的蛋也不能叫做冷酷吧？ 美国在上世纪有一类流行小说叫做Hard-Boiled Detective Story，村上一直受西方文学影响，而且很喜欢这种类型的小说。 所谓硬汉侦探小说，其实并不是大家想象中的那种超级英雄：无坚不摧、拯救世界。 这种Hard-Boiled“硬汉”其实只是看起来很酷，戴个墨镜，实际上只是在逞强而已，他们是在社会上摸爬滚打多年、不断受挫，内心很柔弱、很受伤的一群人，成为侦探是因为他们和罪犯有着相似的生活经历，所以了解他们。 这种类型的硬汉虽然不会轻易认输，但是其实也是在苦苦支撑而已，就像是早餐店里那种Hard-Boiled eggs，以为自己成熟了，但是如果这种蛋碰到墙上，那么破碎的必然是蛋，而高墙不会有任何损失。 即使这样，村上也还是会<strong>永远站在鸡蛋一边，无论高墙多么正确和鸡蛋多么错误。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
            <tag> Haruki Murakami </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻唱与抄袭</title>
      <link href="/2019/08/31/%E7%BF%BB%E5%94%B1%E4%B8%8E%E6%8A%84%E8%A2%AD/"/>
      <url>/2019/08/31/%E7%BF%BB%E5%94%B1%E4%B8%8E%E6%8A%84%E8%A2%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="缘由">缘由</h2><p>曾经，《老男孩》风靡一时，无数人热泪盈眶，我也感动得一塌糊涂。筷子兄弟也凭借此歌迅速走红，获得无数粉丝青睐。 我起初对日本音乐了解甚少，平时也不太接触。偶然听到山口百惠、中森明菜等一些昭和时代歌姬的演唱之后，才逐渐开始欣赏日本音乐。 毫不夸张地说，日本音乐在亚洲绝对顶级水准。这也造就了一大批靠翻唱、抄袭日本曲目成名的歌手，以及一些我们曾经为之泪流满面的歌曲。 当然，拿到原创的允许进行翻唱无可厚非，但是没有版权、重新填词并公开商演又是一种怎样的行为呢？</p><h2 id="ありがとう">ありがとう</h2><p>大桥卓弥的《ありがとう》（谢谢），就是《老男孩》的原曲。 <a href="https://b23.tv/av22011510">原曲</a>关于亲情的MV非常感人。</p><p>筷子兄弟在没有授权的情况下填词发布，后来面临起诉时才购买版权。这种“先上车后补票”的行为并不少见，据说《父亲》的旋律是把福山雅治的《milk tea》副歌部分和宫本笑里的《stay with me》副歌部分拼凑到一起的，不过并没有实锤。有人戏谑（ありがとう网易云热评）：“在知道老男孩是翻唱的之后，我一点也不好奇为什么筷子兄弟的曲风一下从老男孩变成了小苹果”。</p><h2 id="反思">反思</h2><p>很多网友戏称：中岛美雪养活了大半个华语音乐圈。 很不幸，国内许多歌手的代表作都是翻唱美雪阿姨的：任贤齐的《伤心太平洋》、王菲的《容易受伤的女人》...... 刘若英的《后来》是翻唱Kiroro的《未来へ》，《很爱很爱你》也是翻唱这个组合的同一张专辑...... 再看最近，自称“原创歌手”的花粥代表作《盗将行》、《出山》都涉嫌抄袭； <a href="https://b23.tv/av45107069">《出山》原曲</a> 附上<a href="https://b23.tv/av45298740">左右声道对比</a></p><p>神曲《起风了》也是翻唱高桥优的《ヤキモチ》（吃醋），附上<a href="https://b23.tv/av23618612/p1">MV链接</a> 真的太多太多了，我曾经在贴吧看过一个统计，国内知名歌手翻唱日本歌手的歌曲一共列了好几十个页面...... 说这些不是为了引战，我们要正视差距，填词都很不错，优秀的作曲真的太少太少，所以周杰伦才那么难能可贵。 反观日本，几乎每个歌手都是创作者，作品的旋律也非常优美，能把人深深吸引进故事里，而不是写一些口水歌。 唱功再好，最多就是个singer，成为不了musician~</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Norwegian Wood</title>
      <link href="/2019/08/26/Norwegian%20Wood/"/>
      <url>/2019/08/26/Norwegian%20Wood/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>《挪威的森林》是村上春树很有名的一部小说，但我想大多数人阅读的时候都只是把书名当作一个符号，而不是作为故事去追究。 我国台湾知名文学评论家杨照先生说过：村上的书里有太多太多典故，如果你只是把这些典故当作符号看待，那么会少很多阅读的乐趣。你探寻这些典故越深，就越能体会村上想要表达的意思。 那么《挪威的森林》是怎么来的？</p><h2 id="the-beatles">the Beatles</h2><p>了解村上的人都知道：他生命中最重要的几件事就是写作、听音乐、长跑和翻译。 Norwegian Wood(This Bird Has Flown)是Beatles在1965年发行的歌，这首歌的歌词非常简单：</p><blockquote><p>I once had a girl Or should I say she once had me She showed me her room Isn't good Norwegian wood?</p></blockquote><blockquote><p>She asked me to stay And she told me to sit anywhere So I looked around And I noticed there wasn't a chair I sat on a rug biding my time</p></blockquote><blockquote><p>Drinking her wine We talked until two and then she said "It's time for bed" She told me she worked In the morning and started to laugh I told her I didn't And crawled off to sleep in the bath</p></blockquote><blockquote><p>And when I awoke I was alone This bird had flown So I lit a fire Isn't it good Norwegian wood?</p></blockquote><p>歌词的寓意很明显：这个女孩喜欢男孩，想和他滚床单，男孩激动地陪她喝酒聊天。 等他早上醒来的时候，发现女孩已经走了，本来在他手里的鸟飞走了，好似喝醉后的一场梦，转瞬无影踪。 可是Norwegian wood为什么莫名其妙出现在这里？</p><h2 id="故事">故事</h2><p>这首歌基本上是John Lennon完成的，歌词原本是<strong>Isn't good? Knowing she would</strong> 创作完成后，唱片公司觉得歌词的意味太明显，在60年代这样的歌词有些太过直白。 唱片公司要求John修改歌词，调皮的John就利用谐音把<strong>Knowing she would</strong>改成了<strong>Norwegian wood</strong> 改完之后，起初录音时候他还是唱<strong>Knowing she would</strong>，于是唱片公司下了最后通牒：如果还这样唱，那这首歌不能收录。 就这样，John Lennon唱出了<strong>Norwegian wood</strong>，村上听着<strong>Norwegian wood</strong>写出了<strong>Norwegian wood</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Literature </tag>
            
            <tag> Haruki Murakami </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog Customization</title>
      <link href="/2019/08/19/Blog%20Customization/"/>
      <url>/2019/08/19/Blog%20Customization/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>从大二开始写博客，主要为了记录自己学习过程中的问题。尝试使用过CSDN、博客园等公共服务，也用Github pages搭建过自己的博客，但效果都不令人满意。CSDN广告太多，界面乌烟瘴气，而且很多博客内容都是抄袭而来；博客园模板比较单一，而且对Markdown的支持不友好；Github pages很自由，但是搭建以及发布文章比较麻烦。<a href="https://eimadrigal.blogspot.com/">blogspot</a>对国内用户很不友好。</p><p>后来在网上浏览别人的博客园时，才发现原来是可以自己定制博客的，遂写此文。</p><h2 id="皮肤">皮肤</h2><p>皮肤也就是博客的背景，博客园提供了一些模板，可以在管理-&gt;设置-&gt;博客皮肤中选择。<br />如果你对于CSS比较熟悉，那完全可以自己写一个网页的样式，然后勾选禁用模板默认CSS。<br /><img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825184956989-1010438394.png" alt="img" /><br />如果你不熟悉Web开发，可以找一些别人写好的页面定制代码，复制到页面定制CSS代码框中。 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Monokai Sublime style. Derived from Monokai by noformnocontent http://nn.mit-license.org/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">pre &#123;</span><br><span class="line">    <span class="comment">/*控制代码不换行*/</span></span><br><span class="line">    <span class="attribute">white-space</span>: pre;</span><br><span class="line">    <span class="attribute">word-wrap</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cnblogs-markdown</span> <span class="selector-class">.hljs</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1.3em</span> <span class="number">2em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#272822</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFF</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">700px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs</span>,</span><br><span class="line"><span class="selector-class">.hljs-tag</span>,</span><br><span class="line"><span class="selector-class">.hljs-subst</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f8f8f2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-strong</span>,</span><br><span class="line"><span class="selector-class">.hljs-emphasis</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#a8a8a2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-bullet</span>,</span><br><span class="line"><span class="selector-class">.hljs-quote</span>,</span><br><span class="line"><span class="selector-class">.hljs-number</span>,</span><br><span class="line"><span class="selector-class">.hljs-regexp</span>,</span><br><span class="line"><span class="selector-class">.hljs-literal</span>,</span><br><span class="line"><span class="selector-class">.hljs-link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ae81ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-code</span>,</span><br><span class="line"><span class="selector-class">.hljs-title</span>,</span><br><span class="line"><span class="selector-class">.hljs-section</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-class</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#a6e22e</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-strong</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-emphasis</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-keyword</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-tag</span>,</span><br><span class="line"><span class="selector-class">.hljs-name</span>,</span><br><span class="line"><span class="selector-class">.hljs-attr</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f92672</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-symbol</span>,</span><br><span class="line"><span class="selector-class">.hljs-attribute</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#66d9ef</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-params</span>,</span><br><span class="line"><span class="selector-class">.hljs-class</span> <span class="selector-class">.hljs-title</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f8f8f2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-string</span>,</span><br><span class="line"><span class="selector-class">.hljs-type</span>,</span><br><span class="line"><span class="selector-class">.hljs-built_in</span>,</span><br><span class="line"><span class="selector-class">.hljs-builtin-name</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-id</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-attr</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-pseudo</span>,</span><br><span class="line"><span class="selector-class">.hljs-addition</span>,</span><br><span class="line"><span class="selector-class">.hljs-variable</span>,</span><br><span class="line"><span class="selector-class">.hljs-template-variable</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#e6db74</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-comment</span>,</span><br><span class="line"><span class="selector-class">.hljs-deletion</span>,</span><br><span class="line"><span class="selector-class">.hljs-meta</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#75715e</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 黑色主题makedown代码结束 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*makedown行间代码样式 */</span></span><br><span class="line"><span class="selector-class">.cnblogs-markdown</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#c7254e</span>;</span><br><span class="line">    <span class="attribute">border</span>: none <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f9f2f4</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: sans-serif <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*引言样式*/</span></span><br><span class="line"><span class="selector-tag">blockquote</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*博客顶部容器包括标题、副标题、导航栏*/</span></span><br><span class="line"><span class="comment">/* 博客标题和副标题 */</span></span><br><span class="line"><span class="selector-id">#blogTitle</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blogTitle</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blogTitle</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*博客导航栏 */</span></span><br><span class="line"><span class="selector-id">#navList</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#navList</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.blogStats</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*sideBar博客侧边栏容器*/</span></span><br><span class="line"><span class="selector-id">#sideBar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.newsItem</span>, <span class="selector-class">.catListComment</span>, <span class="selector-class">.catListEssay</span>, <span class="selector-class">.catListView</span>, <span class="selector-class">.catListFeedback</span>,</span><br><span class="line"><span class="selector-id">#blog-calendar</span>, <span class="selector-id">#sidebar_postcategory</span>, <span class="selector-id">#sidebar_postcategory</span>, <span class="selector-id">#sidebar_postarchive</span>, <span class="selector-id">#sidebar_search</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">2px</span> <span class="number">3px</span> <span class="number">#A7A8AD</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sideBarMain</span> <span class="selector-tag">h3</span>, <span class="selector-class">.newsItem</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">0.5em</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">http://www.cnblogs.com/skins/red_autumnal_leaves/images/titlebg.png</span>) no-repeat left center <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sideBarMain</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-left-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-right-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sideBarMain</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*侧边栏公告*/</span></span><br><span class="line"><span class="selector-id">#blog-news</span> &gt; <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="comment">/*头像*/</span></span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#profile_block</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#profile_block</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*公告结束*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日历 */</span></span><br><span class="line"><span class="selector-id">#blog-calendar</span>, <span class="selector-id">#calendar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">td</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#59a020</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">table</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#59a020</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">    <span class="attribute">background</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">table</span> u &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*日历结束*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置背景色和字体大小*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*mainContent主体内容容器*/</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">95%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#mainContent</span> <span class="selector-class">.forFlow</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">310px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#mainContent</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">310px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#post_detail</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标题title样式 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#topics</span> <span class="selector-class">.postTitle</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cb_post_title_url</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: left center;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主体内容样式 */</span></span><br><span class="line"><span class="selector-class">.postBody</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="comment">/*标题h2*/</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#d6dbdf</span>8a;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> <span class="selector-tag">h4</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#topics</span> <span class="selector-class">.postDesc</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 个性签名 */</span></span><br><span class="line"><span class="selector-id">#MySignature</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">8px</span> <span class="number">1px</span> <span class="number">10px</span> <span class="number">#989898</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#FFF</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">17px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: solid <span class="number">5px</span> <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#F3F3F3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">50%</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">2.4</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">40px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#MySignature</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#4183c4</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#MySignature</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#MySignature</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关注收藏等几个按钮 */</span></span><br><span class="line"><span class="selector-id">#green_channel</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#green_channel</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>: none;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 禁用下划线 */</span></span><br><span class="line"><span class="selector-class">.postBody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-class">.postBody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>, <span class="selector-class">.postBody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上一篇下一篇 */</span></span><br><span class="line"><span class="selector-id">#post_next_prev</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#535353</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*底部隐藏作者，隐藏推荐和反对*/</span></span><br><span class="line"><span class="selector-id">#author_profile</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#div_digg</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*隐藏广告*/</span></span><br><span class="line"><span class="selector-id">#ad_t2</span>, <span class="selector-id">#cnblogs_c1</span>, <span class="selector-id">#under_post_news</span>, <span class="selector-id">#cnblogs_c2</span>, <span class="selector-id">#under_post_kb</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*评论*/</span></span><br><span class="line"><span class="comment">/*评论列表*/</span></span><br><span class="line"><span class="selector-id">#blog-comments-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.feedback_area_title</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">//www.cnblogs.com/skins/red_autumnal_leaves/images/titlebg.png</span>) no-repeat left center <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*侧边评论*/</span></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-class">.recent_comment_body</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交评论按钮 */</span></span><br><span class="line"><span class="selector-id">#btn_comment_submit</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#fd6d0d</span>d1 <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fd6d0d</span>d1 <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="标题和导航栏">标题和导航栏</h2><figure><img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825185903232-1879765133.png" alt="" /><figcaption>img</figcaption></figure><p>标题和子标题的修改也在管理-&gt;设置中；<br />导航栏的控件在管理-&gt;选项中勾选，这里还包含侧边栏的控件，可以根据需要自行选择。<br /><img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825190124197-141259783.png" alt="img" /></p><h2 id="侧边栏公告">侧边栏公告</h2><figure><img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825190343070-1772796324.png" alt="" /><figcaption>img</figcaption></figure><p>这部分的修改也在管理-&gt;设置中，不过修改前需要发邮件给博客园后台申请JS权限。<br />这里主要有3点：<br />一、动态时钟<br />这个我是copy了<a href="https://www.cnblogs.com/jingmoxukong/p/7826982.html">详谈如何定制自己的博客园皮肤</a>；<br />二、背景音乐<br />背景音乐的添加需要进入网易云音乐网页后，找到喜欢的音乐，生成外链播放器，然后复制那段HTML代码到侧边栏公告即可。<br /><img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825191108110-1169449336.png" alt="img" /><br />这里要注意：博客园不支持iframe插件，所以只能采用flash插件！<br />三、访客统计<br /><img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825191224704-336517055.png" alt="img" /><br />这个功能可以去<a href="http://www.flagcounter.com/">flagcounter</a>完成，同样复制HTML代码到侧边栏公告即可。我的博客把这个放到了页脚html代码中，所以可以看到这个在左下角显示。<br />完整的博客侧边栏公告代码，注意：其中的网易云音乐和访问人数需要自己生成外链！ <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!---  自定义侧边栏  ---&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mySideBar&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p_b_follow&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;follow(&#x27;ca5022e9-4171-4a38-e168-08d4ef52ecb5&#x27;)&quot;</span>&gt;</span>+Follow Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>student@XJTU<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Email：andrew_ren@163.com<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--- 动态时钟  ---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">wmode</span>=<span class="string">&quot;transparent&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://files.cnblogs.com/files/jingmoxukong/honehone_clock_tr.swf&quot;</span> <span class="attr">quality</span>=<span class="string">&quot;high&quot;</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#FDF6E3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;240&quot;</span> <span class="attr">height</span>=<span class="string">&quot;110&quot;</span> <span class="attr">name</span>=<span class="string">&quot;honehoneclock&quot;</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">allowscriptaccess</span>=<span class="string">&quot;always&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/x-shockwave-flash&quot;</span> <span class="attr">pluginspage</span>=<span class="string">&quot;http://www.macromedia.com/go/getflashplayer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--- 网易云音乐  ---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;//music.163.com/style/swf/widget.swf?sid=26511658&amp;type=2&amp;auto=1&amp;width=320&amp;height=66&quot;</span> <span class="attr">width</span>=<span class="string">&quot;340&quot;</span> <span class="attr">height</span>=<span class="string">&quot;86&quot;</span>  <span class="attr">allowNetworking</span>=<span class="string">&quot;all&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--- 访问人数  ---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://info.flagcounter.com/myYT&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s01.flagcounter.com/count2/myYT/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_4/viewers_0/labels_1/pageviews_1/flags_0/percent_0/&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Flag Counter&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--- 导入js库  ---&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"> <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;c_n4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;860&quot;</span> <span class="attr">height</span>=<span class="string">&quot;968&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: fixed; top: 0px; left: 0px; z-index: -1; opacity: 0.5;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure> 最后点击保存即可。</p><h2 id="自适应手机屏幕">自适应手机屏幕</h2><p>博客园的模板并没有自适应手机屏幕，可以参考<a href="https://www.cnblogs.com/lvdabao/p/5245247.html">这篇博文</a>修改CSS中的参数，就可以得到自适应移动设备的网页。</p><h2 id="reference">Reference</h2><p>当前使用的是在<a href="https://github.com/Summertime-Wu/make_cnblogs_better">这个</a>基础上做了一些魔改。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Front-End </tag>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2019/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式">单例模式</h2><p>顾名思义就是某些类全局只需要一个实例。 1. 饿汉模式 只要系统开始运行便创建实例，不管是否需要，需要时直接调用。</p><ol start="2" type="1"><li>懒汉模式</li></ol><h2 id="简单工厂模式">简单工厂模式</h2><h2 id="reference">Reference</h2><p><a href="https://www.zhihu.com/question/308850392/answer/1324509357">如何学习设计模式</a> <a href="https://www.cnblogs.com/ccdev/archive/2012/12/19/2825355.html">线程安全的单例模式</a><br /><a href="https://immortalqx.github.io/2022/02/04/cpp-notes-5/">ccc</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Naïve Bayes</title>
      <link href="/2019/06/08/Na%C3%AFve%20Bayes/"/>
      <url>/2019/06/08/Na%C3%AFve%20Bayes/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><h2 id="details">Details</h2><h2 id="example">Example</h2><h2 id="implementation">Implementation</h2><h2 id="properties">Properties</h2><p>NBC有坚实的数学基础，稳定的分类效率，超参数少（先验），对缺失数据不敏感，算法简单。<br />如果属性较多且相关性比较大，决策树优于NBC，否则NBC性能很好。</p><p>垃圾邮件分类器<br />事先做一个vocabulary存放常用的单词，如果邮件中包含vocabulary的第j个单词，特征向量中<span class="math inline">\(x_j=1\)</span><br />朴素贝叶斯假设给定标签前提下各个属性是独立的（条件独立）： <span class="math inline">\(P(x_1,...,x_d|y)=P(x_1|y)P(x_2|y,x_1)...P(x_d|y,x_1,...,x_{d-1})=P(x_1|y)P(x_2|y)...P(x_d|y)\)</span><br /><span class="math inline">\(P(x_2|y,x_1)\)</span>表示在<span class="math inline">\((y,x_1)\)</span>的条件下<span class="math inline">\(x_2\)</span>发生的概率<br /><span class="math inline">\(P(junk|D)=\frac{P(junk)P(D|junk)}{P(D)},P(normal|D)=\frac{P(normal)P(D|normal)}{P(D)}\)</span><br />P(junk)/P(normal)根据邮件库的比例即可<br />P(D|junk)=P(word1,word2,...,wordn|junk)，联合概率分布的数据是稀疏的，在垃圾邮件集合中出现与当前邮件相同的邮件概率。<br />P(word1|junk)P(word2|word1,junk)P(word3|word2,word1,junk)...<br />如果条件独立假设成立，<br />P(word1|junk)P(word2|junk)P(word3|junk)...只要统计垃圾邮件中每个单词的频率</p><p>拼写纠正<br />max P(猜测用户希望输入的单词|实际输入单词) <span class="math inline">\(P(h_1|D),P(h_2|D)\)</span><br /><span class="math inline">\(P(h|D)\propto P(h)P(D|h)\)</span><br />对给定的观测数据，一个猜测的好坏正比于先验和这个猜测生成观测数据的可能性大小（似然）</p><p>假设实际输入D=thew,h1=the,h2=thaw<br /><span class="math inline">\(P(h_1|D)=\)</span>the本身在词典中的出现概率及输入the前提下输thew的可能</p><p>ID3（Iterative Dichotomiser 3）迭代二叉树3代，启发式算法<br />以信息增益做属性选择，选择分裂后信息增益最大的属性进行分裂</p><ol type="1"><li>top-down贪心遍历可能的决策树空间</li><li>核心问题在于如何选择划分属性</li><li>按照信息增益选择分类能力最好的属性</li><li>属性的每个值产生一个分支，将训练数据放在合适的分支，不回溯考虑之前的选择</li></ol><p>都知道熵用来衡量随机变量的不确定性，在这里就是刻画数据集的不纯度<br />条件熵是指在某个条件下，随机变量的不确定性<br />信息增益即熵-条件熵，即某条件下信息不确定性减少的程度<br />举例来看：明天下雨的熵为2，阴天条件下下雨的熵是0.01（即阴天下雨的可能性很大，所以不确定性很小），信息增益=2-0.01=1.99，获知阴天后，下雨的不确定性减少了很多，信息增益很大，所以阴天对下雨这一推断很重要，意味着这个特征很关键。</p><p>IG衡量给定属性区分训练样例的能力<br /><span class="math inline">\(Entropy(S)=\sum_{i=1}^{c}-p_ilog_2p_i\)</span>，c表示该属性有c个取值，Pi表示子集中样例占总数的比例。介于[0,1]之间，所有样例属于1类，最纯，熵为0；平分熵最大为1</p><p>一个属性的IG意味着用该属性分割样例导致的熵减的期望，<br /><span class="math inline">\(IG(S,A)=E(S)-\sum_{i=1}^{c}\frac{|S_i|}{|S|}E(S_i)\)</span></p><p>C4.5用信息增益率作为属性选择的依据，构造过程中会进行剪枝（不考虑只有几个元素的结点，避免过拟合）<br />率即用相对性衡量（10经过10s到20，1经过1s到2，虽然前者的增益大，但如果用速度增加率即加速度衡量是一样的）</p><p>可以处理非离散数据和不完整数据</p><p>当前数据集S，当前属性A有c个取值，S需要被分割为c个子集 <span class="math inline">\(GainRatio(S,A)=\frac{IG(S,A)}{SplitInfo(S,A)}\)</span> <span class="math inline">\(SplitInfo(S,A)=-\sum_{i=1}^{c}\frac{|S_i|}{|S|}log_2\frac{|S_i|}{|S|}\)</span><br />如果A能完全分割，那么splitinfo=0；如果对半分，那么=1，即splitinfo阻碍选择值均匀分布的属性<br />如果splitinfo=0，可以先计算每个属性的信息增益，选择增益&gt;平均值的属性再去应用增益比率，因为如果splitinfo=0，即A能完全分割，意味着信息增益=0，不可能&gt;平均值</p><p>实际中决策树的过拟合是比较严重的，C4.5克服了ID3用IG选择属性时倾向选择取值多的属性的不足。</p><p>马尔可夫随机过程：<br />s1：名词<br />s2：动词<br />s3：形容词<br />转移矩阵A=0.3 0.5 0.2;0.5 0.3 0.2;0.4 0.2 0.4即A11表示s1后面跟着s1的概率</p><p>若某段话第一个词为名词s1，那么该句子是“名动形名”的概率是多少？<br /><span class="math inline">\(P(s1,s2,s3,s1|model)=P(s1)P(s2|s1)P(s3|s2)P(s1|s3)=1*A12*A23*A31=0.004\)</span>？？？ 马尔科夫链：转移弧上有概率的非确定有限状态自动机，圈代表状态，每个结点的出度加起来是1<br />隐马尔可夫模型HMM：状态转换是不可观察的</p><p>EM（expectation maximization）<br />假设数据点是围绕k个核心点的k个正态分布源产生，目标是根据已知点推断正态分布的核心及参数，这也是一个贝叶斯问题</p><p>矛盾之处在于：蛋与鸡的问题<br />只有已知哪些点属于同一个圈，才能预测参数<br />只有参数靠谱，才能知道哪些点属于哪个圈</p><p>解这种问题，一般要先随机给蛋或鸡，随便猜一个参数，计算每个点属于哪个圈，接着重新评估参数，直至最后参数基本不变，有点kmeans那味。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Week7 Neural Networks Learning</title>
      <link href="/2019/06/07/#Week7%20Neural%20Networks%20Learning/"/>
      <url>/2019/06/07/#Week7%20Neural%20Networks%20Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="一cost-function-and-backpropagation">一、Cost Function and Backpropagation</h2><p>神经网络的损失函数： <span class="math display">\[J(\Theta) = - \frac{1}{m} \sum_{i=1}^m \sum_{k=1}^K \left[y^{(i)}_k \log ((h_\Theta (x^{(i)}))_k) + (1 - y^{(i)}_k)\log (1 - (h_\Theta(x^{(i)}))_k)\right] + \frac{\lambda}{2m}\sum_{l=1}^{L-1} \sum_{i=1}^{s_l} \sum_{j=1}^{s_{l+1}} ( \Theta_{j,i}^{(l)})^2\]</span><br /><img src="https://img-blog.csdnimg.cn/20190520213954195.png" alt="在这里插入图片描述" /><br />这个cost function是在logistic regression基础上演变而来，只是神经网络有很多输出结点，而logistic regression只有一个输出结点，所以这个cost function只是把所有的K个输出结点的损失函数进行累加。</p><p>得到cost function后，为了寻找使得<span class="math inline">\(J(\theta)\)</span>最小的那组参数<span class="math inline">\(\theta\)</span>，我们需要知道<span class="math inline">\(J(\theta)\)</span>关于每个<span class="math inline">\(\theta\)</span>的偏导数，而后向传播算法可以帮助我们计算偏导数：<br /><img src="https://img-blog.csdnimg.cn/20190520215248992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />对于每个训练样本，先利用forward propagation计算每一层的<span class="math inline">\(a\)</span>：<br /><img src="https://img-blog.csdnimg.cn/20190520215514406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />接着利用样本真实标签<span class="math inline">\(y^{(t)}\)</span>计算最后一层的误差值；</p><p>之后从右向左计算每一层（输入层除外）的误差：<br /><img src="https://img-blog.csdnimg.cn/20190520215848578.png" alt="在这里插入图片描述" /><br />这样每个样本一次正向、一次反向来更新误差矩阵：<br /><img src="https://img-blog.csdnimg.cn/20190520220141936.png" alt="在这里插入图片描述" /><br />向量化表示：<br /><img src="https://img-blog.csdnimg.cn/2019052022020666.png" alt="在这里插入图片描述" /><br />最后，就可以得到偏导数：<br /><img src="https://img-blog.csdnimg.cn/20190520220255255.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20190520220307411.png" alt="在这里插入图片描述" /></p><h2 id="二backpropagation-in-pratice">二、Backpropagation in Pratice</h2><p>为了使用<code>fminunc</code>等高级的优化方法来求得cost function的最小值，所以将<span class="math inline">\(\theta\)</span>这个矩阵展成向量传入<code>fminunc</code>，完成后可以通过<code>reshape</code>从向量中提取<span class="math inline">\(\theta^{(1)}、\theta^{(2)}\)</span>等：<br /><img src="https://img-blog.csdnimg.cn/20190521193802355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>为了确保我们使用Backpropagation求得的偏导数的正确性，可以使用Gradient Checking（<strong>很慢</strong>）来检验：<br />根据偏导数定义： <span class="math display">\[\dfrac{\partial}{\partial\Theta_j}J(\Theta) \approx \dfrac{J(\Theta_1, \dots, \Theta_j + \epsilon, \dots, \Theta_n) - J(\Theta_1, \dots, \Theta_j - \epsilon, \dots, \Theta_n)}{2\epsilon}\]</span> <span class="math display">\[一般\epsilon=10^{-4}\]</span> 通过将这种方式计算的偏导数与之前Backpropagation求得的偏导数比较，即可得知Backpropagation的正确性。</p><p>之前在Linear Regression和Logistic Regression，我们可以用全0来初始化<span class="math inline">\(\theta\)</span>，但在神经网络中，这样做会有问题，所以采用<strong>随机初始化</strong>：<br /><img src="https://img-blog.csdnimg.cn/20190521195045220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />最后，从整体捋一遍流程：<br />1、选择网络结构： <img src="https://img-blog.csdnimg.cn/20190521195351245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />2、训练神经网络：</p><p>对每一个训练样本：<br /><img src="https://img-blog.csdnimg.cn/20190521195432613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multilayer Perceptron</title>
      <link href="/2019/06/06/Multilayer%20Perceptron/"/>
      <url>/2019/06/06/Multilayer%20Perceptron/</url>
      
        <content type="html"><![CDATA[<h2 id="non-linear-hypotheses">Non-linear Hypotheses</h2><p>线性回归和逻辑回归在特征很多时，计算量会很大。<br />一个简单的三层神经网络模型： <span class="math display">\[a_i^{(j)} = \text{&quot;activation&quot; of unit $i$ in layer $j$}\]</span><span class="math display">\[\Theta^{(j)} = \text{matrix of weights controlling function mapping from layer $j$ to layer $j+1$}\]</span> <img src="https://img-blog.csdnimg.cn/20190519144739691.png" alt="在这里插入图片描述" /><br />其中：<span class="math display">\[a_1^{(2)} = g(\Theta_{10}^{(1)}x_0 + \Theta_{11}^{(1)}x_1 + \Theta_{12}^{(1)}x_2 + \Theta_{13}^{(1)}x_3)\]</span><span class="math display">\[a_2^{(2)} = g(\Theta_{20}^{(1)}x_0 + \Theta_{21}^{(1)}x_1 + \Theta_{22}^{(1)}x_2 + \Theta_{23}^{(1)}x_3)\]</span><span class="math display">\[a_3^{(2)} = g(\Theta_{30}^{(1)}x_0 + \Theta_{31}^{(1)}x_1 + \Theta_{32}^{(1)}x_2 + \Theta_{33}^{(1)}x_3)\]</span><span class="math display">\[h_\Theta(x) = a_1^{(3)} = g(\Theta_{10}^{(2)}a_0^{(2)} + \Theta_{11}^{(2)}a_1^{(2)} + \Theta_{12}^{(2)}a_2^{(2)} + \Theta_{13}^{(2)}a_3^{(2)})\]</span></p><h2 id="vectorized-implementation">vectorized implementation</h2><p>将上面公式中函数<span class="math inline">\(g\)</span>中的东西用<span class="math inline">\(z\)</span>代替： <span class="math display">\[a_1^{(2)} = g(z_1^{(2)})\]</span><span class="math display">\[a_2^{(2)} = g(z_2^{(2)})\]</span><span class="math display">\[a_3^{(2)} = g(z_3^{(2)})\]</span> 令<span class="math inline">\(x=a^{(1)}\)</span>： <span class="math display">\[z^{(j)} = \Theta^{(j-1)}a^{(j-1)}\]</span> 得到： <span class="math display">\[\begin{aligned}z^{(j)} = \begin{bmatrix}z_1^{(j)} \\ z_2^{(j)} \\ \cdots \\z_n^{(j)}\end{bmatrix}\end{aligned}\]</span></p><p>这块的记号比较多，用例子梳理下：<br />实现一个逻辑与的神经网络：<br /><img src="https://img-blog.csdnimg.cn/20190321105245428.png" alt="在这里插入图片描述" /><br />那么：<br /><img src="https://img-blog.csdnimg.cn/20190321105438230.png" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20190321105453184.png" alt="在这里插入图片描述" /><br />所以有：<br /><img src="https://img-blog.csdnimg.cn/20190321105628787.png" alt="在这里插入图片描述" /><br />再来一个多层的，实现XNOR功能（两输入都为0或都为1，输出才为1）：<br /><img src="https://img-blog.csdnimg.cn/20190321110644318.png" alt="在这里插入图片描述" /><br />基本的神经元：</p><ul><li>逻辑与<br /><img src="https://img-blog.csdnimg.cn/2019032111133091.png" alt="在这里插入图片描述" /></li><li>逻辑或<br /><img src="https://img-blog.csdnimg.cn/20190321111355954.png" alt="在这里插入图片描述" /></li><li>逻辑非<br /><img src="https://img-blog.csdnimg.cn/20190321111411429.png" alt="在这里插入图片描述" /><br />先构造一个表示后半部分的神经元：<img src="https://img-blog.csdnimg.cn/20190321111519333.png" alt="在这里插入图片描述" /><br />这样的：<br /><img src="https://img-blog.csdnimg.cn/20190321111806888.png" alt="在这里插入图片描述" /><br />接着将前半部分组合起来：<br /><img src="https://img-blog.csdnimg.cn/20190321112023420.png" alt="在这里插入图片描述" /></li></ul><h2 id="multiclass-classification">Multiclass Classification</h2><figure><img src="https://img-blog.csdnimg.cn/20190321165848893.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><h2 id="motivation">Motivation</h2><h2 id="implementation">Implementation</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> FashionMNIST</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>():</span></span><br><span class="line">    <span class="comment"># My data is in ../data/FashionMNIST/raw &amp; ../data/FashionMNIST/processed</span></span><br><span class="line">    train_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    test_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    train_iter = DataLoader(train_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    test_iter = DataLoader(test_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> train_iter, test_iter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">W1 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (num_inputs, num_hiddens)), dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">b1 = torch.zeros(num_hiddens, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">W2 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (num_hiddens, num_outputs)), dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">b2 = torch.zeros(num_outputs, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># W1 = nn.Parameter(torch.randn(num_inputs, num_hiddens, requires_grad=True) * 0.01)</span></span><br><span class="line"><span class="comment"># b1 = nn.Parameter(torch.zeros(num_hiddens, requires_grad=True))</span></span><br><span class="line"><span class="comment"># W2 = nn.Parameter(torch.randn(num_hiddens, num_outputs, requires_grad=True) * 0.01)</span></span><br><span class="line"><span class="comment"># b2 = nn.Parameter(torch.zeros(num_outputs, requires_grad=True))</span></span><br><span class="line">params = [W1, b1, W2, b2]</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">    param.requires_grad_(requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="keyword">return</span> torch.<span class="built_in">max</span>(<span class="built_in">input</span>=X, other=torch.zeros(X.shape))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">X</span>):</span></span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>(<span class="params">X</span>):</span></span><br><span class="line">    X = X.reshape((-<span class="number">1</span>, num_inputs))</span><br><span class="line">    H = relu(torch.matmul(X, W1) + b1)</span><br><span class="line">    output = torch.matmul(H, W2) + b2</span><br><span class="line">    <span class="keyword">return</span> softmax(output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span>(<span class="params">y_predict, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> -torch.log(y_predict[<span class="built_in">range</span>(<span class="built_in">len</span>(y_predict)), y])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sgd</span>(<span class="params">params, lr, batch_size</span>):</span></span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.data -= lr * param.grad / batch_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy</span>(<span class="params">net, data_iter</span>):</span></span><br><span class="line">    acc_sum, n = <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        acc_sum += (net(X).argmax(dim=<span class="number">1</span>) == y).<span class="built_in">float</span>().<span class="built_in">sum</span>().item()</span><br><span class="line">        n += y.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> acc_sum / n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, batch_size=<span class="number">256</span>, lr=<span class="number">0.1</span>, params=<span class="literal">None</span>, optimizer=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_loss_sum, train_acc_sum, n = <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            y_predict = net(X)</span><br><span class="line">            l = cross_entropy(y_predict, y).<span class="built_in">sum</span>()</span><br><span class="line">            l.backward()</span><br><span class="line">            sgd(params, lr, batch_size)</span><br><span class="line"></span><br><span class="line">            W1.grad.data.zero_()</span><br><span class="line">            b1.grad.data.zero_()</span><br><span class="line">            W2.grad.data.zero_()</span><br><span class="line">            b2.grad.data.zero_()</span><br><span class="line"></span><br><span class="line">            train_loss_sum += l.item()</span><br><span class="line">            train_acc_sum += (y_predict.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().item()</span><br><span class="line">            n += y.shape[<span class="number">0</span>]</span><br><span class="line">        test_acc = evaluate_accuracy(net, test_iter)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch %d, loss %.4f, train_acc %.4f, test_acc %.4f&#x27;</span></span><br><span class="line">              % (epoch + <span class="number">1</span>, train_loss_sum / n, train_acc_sum / n, test_acc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span></span><br><span class="line">    train_iter, test_iter = load_data()</span><br><span class="line">    train(net, train_iter, test_iter, cross_entropy, <span class="number">10</span>, lr=<span class="number">0.1</span>, params=params)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.init <span class="keyword">as</span> init</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> FashionMNIST</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>():</span></span><br><span class="line">    <span class="comment"># My data is in ../data/FashionMNIST/raw &amp; ../data/FashionMNIST/processed</span></span><br><span class="line">    train_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    test_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    train_iter = DataLoader(train_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    test_iter = DataLoader(test_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> train_iter, test_iter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_inputs, num_outputs, num_hiddens</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.l1 = nn.Linear(num_inputs, num_hiddens)</span><br><span class="line">        self.relu1 = nn.ReLU()</span><br><span class="line">        self.l2 = nn.Linear(num_hiddens, num_outputs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        X = X.view(X.shape[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line">        o1 = self.relu1(self.l1(X))</span><br><span class="line">        o2 = self.l2(o1)</span><br><span class="line">        <span class="keyword">return</span> o2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_params</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> self.parameters():</span><br><span class="line">            init.normal_(param, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy</span>(<span class="params">net, data_iter</span>):</span></span><br><span class="line">    acc_sum, n = <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        acc_sum += (net(X).argmax(dim=<span class="number">1</span>) == y).<span class="built_in">float</span>().<span class="built_in">sum</span>().item()</span><br><span class="line">        n += y.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> acc_sum / n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, batch_size=<span class="number">256</span>, lr=<span class="number">0.1</span>, params=<span class="literal">None</span>, optimizer=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_loss_sum, train_acc_sum, n = <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            y_predict = net(X)</span><br><span class="line">            l = loss(y_predict, y).<span class="built_in">sum</span>()</span><br><span class="line">            l.backward()</span><br><span class="line"></span><br><span class="line">            optimizer.step()</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">            train_loss_sum += l.item()</span><br><span class="line">            train_acc_sum += (y_predict.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().item()</span><br><span class="line">            n += y.shape[<span class="number">0</span>]</span><br><span class="line">        test_acc = evaluate_accuracy(net, test_iter)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch %d, loss %.4f, train_acc %.4f, test_acc %.4f&#x27;</span></span><br><span class="line">              % (epoch + <span class="number">1</span>, train_loss_sum / n, train_acc_sum / n, test_acc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">net = Net(num_inputs, num_outputs, num_hiddens)</span><br><span class="line">net.init_params()</span><br><span class="line"></span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    train_iter, test_iter = load_data()</span><br><span class="line">    train(net, train_iter, test_iter, loss, <span class="number">10</span>, optimizer=optimizer)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advice for applying ML &amp; ML System Design</title>
      <link href="/2019/06/05/Advice%20for%20applying%20ML%20&amp;%20ML%20System%20Design/"/>
      <url>/2019/06/05/Advice%20for%20applying%20ML%20&amp;%20ML%20System%20Design/</url>
      
        <content type="html"><![CDATA[<h2 id="一the-problem-of-overfitting">一、The Problem of Overfitting</h2><p><img src="https://img-blog.csdnimg.cn/20190320163616569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20190320164216967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />欠拟合（high bias）：模型不能很好地适应训练集；<br />过拟合（high variance）：模型过于强调拟合原始数据，测试时效果会比较差。<br />处理过拟合：<br />1、丢弃一些特征，包括人工丢弃和算法选择；<br />2、正则化：保留所有特征，但减小参数的值。</p><h2 id="二cost-function">二、Cost Function</h2><p>过拟合一般是由高次项引起，那么我们可以通过增加某些项的cost，来降低它们的权重。<br />在梯度下降过程中，要使损失函数变小，那么<span class="math inline">\(\theta\)</span>就会变得很小，所以假设函数中的<span class="math inline">\(\theta\)</span>就会变小，该项的权重就会降低。</p><p>如果不知道要惩罚哪些特征，可以一起惩罚（除了<span class="math inline">\(\theta_0\)</span>）。<br />将代价函数改为：<br /><img src="https://img-blog.csdnimg.cn/20190320165635129.png" alt="在这里插入图片描述" /><br /><span class="math inline">\(\lambda\)</span>是正则化参数。<br />如果<span class="math inline">\(\lambda\)</span>过大，那么所有的参数都会最小化，那么假设就会变为<span class="math inline">\(h_\theta(x)=\theta_0\)</span>，造成欠拟合。</p><h2 id="三regularized-linear-regression">三、Regularized Linear Regression</h2><p><span class="math inline">\(\theta_0\)</span>没有正则化处理，所以梯度下降要分情况：<br /><img src="https://img-blog.csdnimg.cn/20190320170642494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />化简下：<br /><img src="https://img-blog.csdnimg.cn/20190320170825316.png" alt="在这里插入图片描述" /><br />可以看到：<br />正则化后的参数更新比原来多减小了一个值。</p><p>再看线性回归的另外一个工具：常规方程。<br /><img src="https://img-blog.csdnimg.cn/20190320171502423.png" alt="在这里插入图片描述" /><br />推导过程省略......</p><h2 id="四regularized-logistic-regression">四、Regularized Logistic Regression</h2><p>对于逻辑回归的代价函数，同样增加一个正则化表达式：<br /><img src="https://img-blog.csdnimg.cn/2019032019010815.png" alt="在这里插入图片描述" /><br />梯度下降算法与线性回归相同，不过<span class="math inline">\(h_\theta(x)\)</span>不同。<br /><img src="https://img-blog.csdnimg.cn/20190320190430424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="一evaluating-a-learning-algorithm">一、Evaluating a Learning Algorithm</h2><p>训练后测试时如果发现模型表现很差，可以有很多种方法去更改：</p><ol type="1"><li>用更多的训练样本；</li><li>减少/增加特征数目；</li><li>尝试多项式特征；</li><li>增大/减小正则化参数<span class="math inline">\(\lambda\)</span>。</li></ol><p>那么该怎么去选择采用哪种方式呢？<br />一般将70%的数据作为训练集，30%的数据作为测试集。<br />先用训练集最小化<span class="math inline">\(J_{train}(\Theta)\)</span>，得到一组参数值<span class="math inline">\(\Theta\)</span>；<br />然后计算测试集误差<span class="math inline">\(J_{test}(\Theta)\)</span>：<br />对于<strong>线性回归</strong>：<br /><img src="https://img-blog.csdnimg.cn/20190603210422113.png" alt="在这里插入图片描述" /><br />对于<strong>逻辑回归</strong>：<br /><img src="https://img-blog.csdnimg.cn/20190603210631921.png" alt="在这里插入图片描述" /><br />测试集的平均误差（分类错误的比率）：<br /><img src="https://img-blog.csdnimg.cn/20190603210807680.png" alt="在这里插入图片描述" /><br />假设要选择用几次多项式<span class="math inline">\(d\)</span>去作为假设函数，那么做法就是不断尝试<span class="math inline">\(d\)</span>，选择一个在测试集上损失最小的<span class="math inline">\(d\)</span>，以此作为模型泛化能力的衡量。但是这样是有问题的，因为<span class="math inline">\(d\)</span>相当于是被测试集训练的，再用测试集去测试，很不公平。所以一般将数据集分为3部分：60%训练集、20%交叉验证集、20%测试集：<br /><img src="https://img-blog.csdnimg.cn/20190605102227988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="二bias-vs.-variance">二、Bias vs. Variance</h2><p>看图：<br /><img src="https://img-blog.csdnimg.cn/20190719151251691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="图来自知乎" /><br /><img src="https://img-blog.csdnimg.cn/20190605102435642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />正则化和Bias/Variance的关系：<br /><img src="https://img-blog.csdnimg.cn/20190605102608526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br />训练集大小与Bias/Variance的关系：<br /><img src="https://img-blog.csdnimg.cn/20190605102730371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><br /><img src="https://img-blog.csdnimg.cn/20190605102745765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>## 三、Error Analysis Andrew推荐的流程：<br /><img src="https://img-blog.csdnimg.cn/20190605103603490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>## 四、Handling Skewed Data 如果数据集中正负类的数据规模差距过大，只用误差衡量模型是不可靠的，此时需要查准率和召回率两个指标。<br /><img src="https://img-blog.csdnimg.cn/20190605104947575.png" alt="在这里插入图片描述" /><br />如何权衡这两个指标，一般使用<span class="math inline">\(F1\)</span>得分： <span class="math display">\[F_1=2\frac{PR}{P+R}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logistic Regression</title>
      <link href="/2019/06/04/Logistic%20Regression/"/>
      <url>/2019/06/04/Logistic%20Regression/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>If y only takes a finite set of discrete values such as {0,1}, then using Linear Regression to predict a <span class="math inline">\(\hat y&gt;1/\hat y&lt;0\)</span> does not make sense at all. But fortunately we can fix Linear Regression to produce a value between [0,1].</p><h2 id="details">Details</h2><p>We choose sigmoid/logistic function to map the value: <span class="math display">\[h_\theta(x)=g(\theta^Tx),g(z)=\frac{1}{1+e^{-z}}\]</span> <img src="https://img-blog.csdnimg.cn/20190516212200143.png" alt="在这里插入图片描述" /> We can assume that: <span class="math display">\[h_\theta(x)=P(y=1|x;\theta)\\1-h_\theta(x)=P(y=0|x;\theta)\]</span> Or more compactly: <span class="math display">\[p(y|x;\theta)=[h_\theta(x)]^y[1-h_\theta(x)]^{1-y}\]</span> Now we will use maximum likelihood to fit parameters <span class="math inline">\(\theta\)</span>, assume n training examples are independent, then the likelihood of the parameters is: <span class="math display">\[L(\theta)=p(\vec y|X;\theta)=\prod_{i=1}^{n}p(y^{(i)}|x^{(i)};\theta)=\prod_{i=1}^{n}[h(x^{(i)})]^{y^{(i)}}[1-h(x^{(i)})]^{1-y^{(i)}}\]</span> To make life easier, we use the log likelihood: <span class="math display">\[l(\theta)=log\ L(\theta)=\sum_{i=1}^{n}y^{(i)}log\ h(x^{(i)})+(1-y^{(i)})log\ (1-h(x^{(i)}))\]</span> Let's first take out one example <span class="math inline">\((x,y)\)</span> to derive the stochastic gradient ascent rule: <span class="math display">\[\frac{\partial}{\partial\theta_j}l(\theta)=[y\frac{1}{g(\theta^Tx)}-(1-y)\frac{1}{1-g(\theta^Tx)}]\frac{\partial}{\partial\theta_j}g(\theta^Tx) \\=[y\frac{1}{g(\theta^Tx)}-(1-y)\frac{1}{1-g(\theta^Tx)}]g(\theta^Tx)(1-g(\theta^Tx))\frac{\partial}{\partial\theta_j}\theta^Tx \\=[y(1-g(\theta^Tx))-(1-y)g(\theta^Tx)]x_j=(y-h_\theta(x))x_j\]</span> Then we can update the parameters: <span class="math display">\[\theta_j=\theta_j+\alpha(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}\]</span></p><p>Here we use maximum likelihood to get the update rule. Generally we would like to minimize the object function. So we can add a negative sign to the maximum likelihood's formula, it is called <strong>logistic loss</strong>. Thus there exists another way to understand it.</p><p>The loss on a single sample can be formulated as follows: <span class="math display">\[cost(h_{\theta}(x),y)=\left\{\begin{aligned}-log(h_{\theta}(x))\ \ \ if\ y=1\\-log(1-h_{\theta}(x))\ \ \ if\ y=0\end{aligned}\right.\]</span> If y=1 and the prediction=1, then loss=0; else if y=1 and the prediction=0, then loss=<span class="math inline">\(+\infty\)</span> is a huge penalty for the totally wrong prediction. It is the same for y=0.</p><p>We can unify the two cases together and the loss for the whole training data is: <span class="math display">\[cost((h_{\theta}(x),y))=-ylog(h_{\theta}(x))-(1-y)log(1-h_{\theta}(x))\\=-\frac{1}{m}\sum_{i=1}^{m}[y^{(i)}log(h_{\theta}(x^{(i)}))+(1-y^{(i)})log(1-h_{\theta}(x^{(i)}))]\]</span> Here the reason why we don't use the MSE loss such as Linear Regression is that the <span class="math inline">\(J(\theta)\)</span> is non-convex and very hard to optimize for the global optimum.</p><p>To make life easier again, we can write the formula as the vectorized version: <span class="math display">\[h = g(X\theta),J(\theta) = \frac{1}{m} \cdot \left(-y^{T}\log(h)-(1-y)^{T}\log(1-h)\right)\]</span> Then our goal is to minimize <span class="math inline">\(J(\theta)\)</span> and get appropriate parameters <span class="math inline">\(\theta\)</span> and use <span class="math inline">\(h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}\)</span> to get our predictions.</p><p>Since it is a little complex to get answer analytically, so we still use Gradient Descent to minimize the loss numerically. The update rule is the same as the above one: <span class="math display">\[\theta_j=\theta_j+\alpha\frac{1}{m}\sum_{i=1}^{m}(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}\]</span> Here you should notice that all <span class="math inline">\(\theta_j\)</span> should be updated simultaneously when you program. Again the vectorized version: <span class="math display">\[\theta=\theta-\frac{\alpha}{m}X^T[g(X\theta)-y]\]</span> It is the same formula as the Linear Regression except that <span class="math inline">\(h_\theta(x)\)</span> is different.</p><h2 id="牛顿法">牛顿法</h2><p>除了用梯度上升法去最大化<span class="math inline">\(l(\theta)\)</span>，牛顿迭代法也能干这件事。</p><p>普通同学都是在求方程的零点<span class="math inline">\(f(\theta)=0\)</span>时接触到牛顿法，其更新规则为： <span class="math display">\[\theta=\theta-\frac{f(\theta)}{f^{&#39;}(\theta)}\]</span> 这个规则可以理解为：我们一直在用一个线性函数去近似<span class="math inline">\(f\)</span>，因此希望下一次迭代的<span class="math inline">\(\theta\)</span>就是该线性函数的零点： <img src="https://img-blog.csdnimg.cn/20210616190823439.png" alt="在这里插入图片描述" /> 再结合一点高中数学，<span class="math inline">\(l(\theta)\)</span>极大值点处的一阶导数为0，因此只要令<span class="math inline">\(l^{&#39;}(\theta)=0\)</span>就能解出对应的<span class="math inline">\(\theta\)</span>： <span class="math display">\[\theta=\theta-\frac{l^{&#39;}(\theta)}{l^{&#39;&#39;}(\theta)}\]</span> 由于逻辑回归中<span class="math inline">\(\theta\)</span>是向量而非scalar，因此需要稍稍改变下更新规则： <span class="math display">\[\theta=\theta-H^{-1}\nabla_{\theta}l(\theta)\]</span> 其中，Hessian阵中的元素为<span class="math inline">\(H_{ij}=\frac{\partial^2l(\theta)}{\partial\theta_i\partial\theta_j}\)</span>。</p><p>牛顿法通常比梯度上升收敛快得多，因为利用了<span class="math inline">\(l(\theta)\)</span>的二阶信息，但是存储和求解<span class="math inline">\(H^{-1}\)</span>开销会比较大。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Regression</title>
      <link href="/2019/06/03/Linear%20Regression/"/>
      <url>/2019/06/03/Linear%20Regression/</url>
      
        <content type="html"><![CDATA[<h2 id="线性回归模型">线性回归模型</h2><p><span class="math display">\[h_{\theta}(x)=\sum_{i=0}^{d}\theta_ix_i=\theta^Tx=x^T\theta\]</span> 其中，<span class="math inline">\(x_0=1\)</span>，<span class="math inline">\(d\)</span>表示<span class="math inline">\(x\)</span>的特征数量。</p><p>在给定训练集下，需要用学习算法确定参数<span class="math inline">\(\theta\)</span>，使得模型的预测值<span class="math inline">\(h(x)\)</span>与真实值<span class="math inline">\(y\)</span>尽可能接近。为了精确地描述这种接近程度，定义损失函数： <span class="math display">\[J(\theta)=\frac{1}{2}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2\]</span> 问题转化为选择一组<span class="math inline">\(\theta\)</span>使得<span class="math inline">\(J(\theta)\)</span>最小，这里有2种求解方法：</p><ol type="1"><li>梯度下降</li><li>Normal Equation</li></ol><h2 id="梯度下降">梯度下降</h2><p>梯度下降的motivation非常直观，首先随机选择一组参数<span class="math inline">\(\theta\)</span>，接着沿<span class="math inline">\(J(\theta)\)</span>下降最快的方向更新<span class="math inline">\(\theta\)</span>，经过若干次迭代就有望找到令<span class="math inline">\(J(\theta)\)</span>收敛的参数<span class="math inline">\(\theta\)</span>： <span class="math display">\[\theta_j=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)\]</span> 将<span class="math inline">\(J(\theta)\)</span>的偏导数代入即得到所谓的batch gradient descent更新规则： <span class="math display">\[\theta_j=\theta_j-\alpha\sum_{i=1}^{n}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}\]</span> 其向量化表示为： <span class="math display">\[\theta=\theta-\alpha\sum_{i=1}^{n}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}\]</span> 由于损失函数<span class="math inline">\(J(\theta)\)</span>是凸二次函数，因此总能收敛到唯一的全局最小值。</p><p>batch gradient descent一次更新需要计算所有训练样本，开销较大，因此有同学提出了stochastic gradient descent，每遇到一个训练样本就进行一次参数更新： <span class="math display">\[\theta=\theta-\alpha(h_\theta(x^{(i)})-y^{(i)})x^{(i)}\]</span> stochastic gradient descent一般比batch gradient descent收敛快，但是有可能在<span class="math inline">\(J(\theta)\)</span>的最优点附近振荡，永远无法收敛到精确最优。不过一般选择最优点附近的参数也可以接受，还可以通过递减学习率<span class="math inline">\(\alpha\)</span>确保其精确收敛。</p><p>值得一提的是：梯度下降算法存在“锯齿”效应，因此为了加速收敛，通常要进行归一化处理使得不同特征的尺度相近。</p><h2 id="normal-equation">Normal Equation</h2><p>除了用迭代的方式求解<span class="math inline">\(J(\theta)\)</span>的最小值，还可以用数学工具直接求得闭式解。</p><p>为了简洁地表示后续求导，使得人生不要太过凌乱，我们首先研究下<span class="math inline">\(J(\theta)\)</span>的向量表示：<br />假设训练集<span class="math inline">\(X\)</span>和对应的标签<span class="math inline">\(y\)</span>分别为： <span class="math display">\[X=\left[\begin{matrix} (x^{(1)})^T \\ (x^{(2)})^T \\ \vdots \\ (x^{(n)})^T \\\end{matrix}\right],y=\left[\begin{matrix} y^{(1)} \\ y^{(2)} \\ \vdots \\ y^{(n)} \\\end{matrix}\right]\]</span> 由于<span class="math inline">\(h_{\theta}(x^{(i)})=(x^{(i)})^T\theta\)</span>，所以有： <span class="math display">\[X\theta-y=\left[\begin{matrix} (x^{(1)})^T\theta \\ (x^{(2)})^T\theta \\ \vdots \\ (x^{(n)})^T\theta \\\end{matrix}\right]-\left[\begin{matrix} y^{(1)} \\ y^{(2)} \\ \vdots \\ y^{(n)} \\\end{matrix}\right]=\left[\begin{matrix} h_{\theta}(x^{(1)})-y^{(1)}  \\ h_{\theta}(x^{(2)})-y^{(2)} \\ \vdots \\ h_{\theta}(x^{(n)})-y^{(n)} \\\end{matrix}\right]\]</span> 根据向量运算法则<span class="math inline">\(x^Tx=\sum_ix_i^2\)</span>，终于得到了<span class="math inline">\(J(\theta)\)</span>的简单点的表示： <span class="math display">\[\frac{1}{2}(X\theta-y)^T(X\theta-y)=\frac{1}{2}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2=J(\theta)\]</span> 利用高中数学导数的知识，只要求得<span class="math inline">\(J(\theta)\)</span>关于参数<span class="math inline">\(\theta\)</span>的导数并令其为0，就大功告成了： <span class="math display">\[\nabla_{\theta}J(\theta)=\frac{1}{2}(X\theta-y)^T(X\theta-y)\\=\frac{1}{2}\nabla_{\theta}[(X\theta)^TX\theta-(X\theta)^Ty-y^T(X\theta)+y^Ty]=\frac{1}{2}\nabla_{\theta}[\theta^T(X^TX)\theta-y^T(X\theta)-y^T(X\theta)]\\=\frac{1}{2}\nabla_{\theta}[\theta^T(X^TX)\theta-2(X^Ty)^T\theta]=\frac{1}{2}(2X^TX\theta-2X^Ty)=X^TX\theta-X^Ty\]</span> 哦，高中数学好像不太够，还要知道<span class="math inline">\(a^Tb=b^Ta,\nabla_{x}Ax=A^T,\nabla_{x}x^TAx=(A+A^T)x\)</span>。</p><p>结束了无聊的数学推导，所谓的Normal Equation就来了： <span class="math display">\[X^TX\theta=X^Ty\]</span> 我们暂时先不考虑<span class="math inline">\(X^TX\)</span>不可逆的情况，最终的解析解就是<span class="math inline">\(\theta=(X^TX)^{-1}X^Ty\)</span>。这种方法不需要做Feature Scaling，但是只能用于容易求解的模型。</p><h2 id="probabilistic-view">Probabilistic view</h2><p>当观测数据满足一些假设条件时，就可以自然而然地推导出均方误差形式的损失函数。</p><p>假设观测数据满足： <span class="math display">\[y^{(i)}=\theta^Tx^{(i)}+\epsilon^{(i)}\]</span> 其中，<span class="math inline">\(\epsilon^{(i)}\)</span>表示偏差项，并且<span class="math inline">\(\epsilon^{(i)}\)</span>服从IID的高斯分布，即<span class="math inline">\(\epsilon^{(i)}\sim \mathcal{N}(0, \sigma^2)\)</span>。</p><p>在满足上述假设的条件下，给定<span class="math inline">\(x^{(i)}\)</span>，观测到的<span class="math inline">\(y^{(i)}\)</span>满足概率分布<span class="math inline">\(y^{(i)}|x^{(i)};\theta\sim \mathcal{N}(\theta^Tx^{(i)}, \sigma^2)\)</span>，即： <span class="math display">\[p(y^{(i)}|x^{(i)};\theta)=\frac{1}{\sqrt{2\pi }\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2 \sigma^2})\]</span> 我们希望选择合适的参数<span class="math inline">\(\theta\)</span>，使得在整个训练集上最大化观测数据出现的概率，也就是所谓的极大似然估计： <span class="math display">\[\prod_{i=1}^{n}p(y^{(i)}|x^{(i)};\theta)=\prod_{i=1}^{n}\frac{1}{\sqrt{2\pi }\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2 \sigma^2})=L(\theta)\]</span> To make our life easier，采用对数似然函数的形式去求<span class="math inline">\(L(\theta)\)</span>的最大值： <span class="math display">\[l(\theta)=log\ L(\theta)=nlog\ \frac{1}{\sqrt{2\pi }\sigma}-\frac{1}{2\sigma^2}\sum_{i=1}^n(y^{(i)}-\theta^Tx^{(i)})^2\]</span> 因此，最大化<span class="math inline">\(L(\theta)\)</span>与最小化<span class="math inline">\(J(\theta)=\frac{1}{2}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2\)</span>等价，也就证明了均方误差损失函数的合理性。</p><p>值得一提的是：上述假设并不唯一，存在其它合理的假设同样能够证明均方误差作为损失函数的合理性。</p><h2 id="局部加权线性回归">局部加权线性回归</h2><p>在朴素的线性回归中，训练模型得到的参数<span class="math inline">\(\theta\)</span>是固定的，对于每个要预测的点<span class="math inline">\(x\)</span>计算<span class="math inline">\(\theta^Tx\)</span>就完事了。这种参数化的学习算法在预测时不需要训练数据的支持，非常快捷。</p><p>局部加权线性回归的motivation在于：朴素线性模型强行拟合所有训练样本，因为模型简单往往欠拟合。对于任意一个样本<span class="math inline">\(x\)</span>，如果只根据其周围几个样本来建立局部的线性模型，且距离<span class="math inline">\(x\)</span>越近其在损失函数中的权值越大，就得到了所谓的Locally Weighted Linear Regression： <span class="math display">\[J(\theta)=\frac{1}{2}\sum_{i=1}^{n}w^{(i)}(h_{\theta}(x^{(i)})-y^{(i)})^2\]</span> 直观上看：如果一个点权值较大，其对损失函数的贡献就越大；如果权值较小，那么该点基本可以忽略不计。</p><p>权值一般会设计为指数函数： <span class="math display">\[w^{(i)}=exp(-\frac{(x^{(i)}-x)^T(x^{(i)}-x)}{2\tau^2})\]</span> 其中，<span class="math inline">\(x\)</span>表示待测试样本，<span class="math inline">\(\tau\)</span>负责控制随距离增加权值的衰减快慢。</p><p>另外，与kNN类似，LWR也是一种懒惰学习算法，即只有给出测试样例时才会训练并预测。因此，这种非参数算法在预测时需要存储训练集，并且参数数量会随训练集大小线性增长。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Machine Learning Introduction</title>
      <link href="/2019/06/02/Machine%20Learning%20Introduction/"/>
      <url>/2019/06/02/Machine%20Learning%20Introduction/</url>
      
        <content type="html"><![CDATA[<p>对一个背后的pattern很复杂的问题，我们无法显式编程求解，就需要ML。如果能做到100%正确并且这个过程并不很复杂，就完全没有必要上ML。</p><p>ML我们并没有也不可能直接考虑所有可能出现的情况，然后用对应的方法解决。此时我们编写的程序其实是在操纵一个学习器，它可以根据模型参数的不同灵活应对输入的情况，并且每组参数都可以很好地处理输入的变化。</p><p>现实生活中有许多不同类型的问题，因此学习器也有很多不同的类型，不同类型的学习器针对不同的问题，当然也可以一对多或者多对一或者多对多。训练就是要根据数据获得一组表现良好的参数，下次给出相似类型的输入，我们的模型（参数固定的学习器）可以获得良好的预测表现。此外，还要有一个衡量当前这组参数表现好坏的措施，这就是objective function，训练时要用algorithm去有策略地调整参数，优化objective/loss function。</p><p>数据的难点在于：数量要够只是基本，数据应该合理反应所有可能的类别，对于特定任务的特征选择也应该慎重，比如简历筛选时如果把历史面试结果作为一个特征，那么就很可能在无意中引入historical injustices。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Topological Sort</title>
      <link href="/2019/06/01/Topological%20Sort/"/>
      <url>/2019/06/01/Topological%20Sort/</url>
      
        <content type="html"><![CDATA[<h2 id="拓扑排序">拓扑排序</h2><p>拓扑排序将有向无环图(DAG)的所有顶点排成一个线性序列，满足</p><ul><li>每个结点只出现一次</li><li>任意两个顶点若存在有向边<span class="math inline">\(u\rightarrow v\)</span>，那么在线性序列中<span class="math inline">\(u\)</span>必然在<span class="math inline">\(v\)</span>之前</li></ul><p>非DAG图是不存在拓扑序列的.</p><p>拓扑排序的实现有BFS和DFS的方式，BFS的思想是：</p><ol type="1"><li>将所有入度为0的顶点入队；</li><li>取队首结点输出，删除所有从该结点出发的边，并将这些边到达的顶点的入度减1，若某顶点入度减为0，将其入队；</li><li>重复2，直到队列为空。若进过队的结点数为<span class="math inline">\(n\)</span>，排序成功，否则<strong>图中有环</strong>。</li></ol><p>如果需要按字典序输出，就用优先队列。</p><p>复杂度<span class="math inline">\(O(V+E)\)</span></p><p>dfs version, reverse ans is the topological sequence</p><h2 id="图论判环">图论判环</h2><ul><li>对于<a href="https://blog.csdn.net/myRealization/article/details/107812221">无向图判环</a><br /></li></ul><ol type="1"><li><a href="https://eimadrigal.github.io/2020/01/26/Union-Find/">并查集判环</a></li><li>BFS</li><li>改进DFS</li></ol><p>BFS和改进DFS的基本思想是：对于当前访问的结点cur，将其标记，访问cur的所有邻接点adj，如果adj已经被标记为访问过但是却不是cur的父结点，就表明有环。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycleDFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> adj = g[s].<span class="built_in">begin</span>(); adj != g[s].<span class="built_in">end</span>(); ++adj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[*adj]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">hasCycleDFS</span>(*adj, s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*adj != parent) &#123;  <span class="comment">// 该邻接点已经被访问且不是s的父结点, 存在back edge(环)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycleBFS</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push</span>(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> adj = g[cur].<span class="built_in">begin</span>(); adj != g[cur].<span class="built_in">end</span>(); ++adj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[*adj]) &#123;</span><br><span class="line">                vis[*adj] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(*adj);</span><br><span class="line">                parent[*adj] = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*adj != parent[cur]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>对于有向图判环 拓扑排序有<a href="https://blog.nowcoder.net/n/b2383a6e87454e3da1e09fc635cd9750">DFS和BFS两种版本</a></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">onStack</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycleDirected</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    onStack[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> adj = g[s].<span class="built_in">begin</span>(); adj != g[s].<span class="built_in">end</span>(); ++adj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[*adj]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">hasCycleDirected</span>(*adj)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onStack[*adj]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onStack[s] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><a href="https://stackoverflow.com/questions/19113189/">Detecting cycles in a graph using DFS</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathematics for Machine Learning</title>
      <link href="/2019/05/24/Mathematics%20for%20Machine%20Learning/"/>
      <url>/2019/05/24/Mathematics%20for%20Machine%20Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p><span class="math inline">\(f(\mathbf{x}) = \boldsymbol{\beta}^\top\mathbf{x}\)</span> <span class="math display">\[\frac{df}{d\mathbf{x}} = \begin{bmatrix}\frac{df}{dx_1} \\\vdots \\\frac{df}{dx_n}\end{bmatrix} = \begin{bmatrix}\beta_1 \\\vdots \\\beta_n\end{bmatrix} = \boldsymbol{\beta}\]</span></p><p><span class="math inline">\(\frac{d}{d\mathbf{x}}(\mathbf{x}^\top A \mathbf{x}) = (\mathbf{A} + \mathbf{A}^\top)\mathbf{x}.\)</span></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
            <tag> Probability &amp; Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2019/05/19/Linux/"/>
      <url>/2019/05/19/Linux/</url>
      
        <content type="html"><![CDATA[<h2 id="linux">Linux</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pwd  # print working directoty</span><br><span class="line">cd /  # change directory 输入文件夹部分名按tab自动补全 如果文件夹名字含有空格，需要将文件名用&quot;&quot;括起来</span><br><span class="line">mkdir  # make directory</span><br><span class="line">rmdir  # remove directory</span><br><span class="line">rm a.txt  # remove file</span><br><span class="line">ls -l  # list files</span><br><span class="line">touch filename  # create an empty file</span><br><span class="line">cp lab1/original lab2/dup  # 将original复制为dup</span><br><span class="line">cat a.txt  # capture</span><br><span class="line">less a.txt  # q退出</span><br><span class="line">diff a.txt b.txt</span><br><span class="line">head a.txt -n 5  # 查看前5行</span><br><span class="line">tail a.txt -n 5  # 查看后5行</span><br><span class="line">wc -w a.txt  # 查看单词数目 -l行数 -c字符</span><br><span class="line">mv lab1/a.txt lab2/  # 移动</span><br><span class="line">mv lab1/a.txt lab1/newname.txt  # 重命名</span><br><span class="line">rm filename  # delete</span><br><span class="line">xterm  # open a new terminal window</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">chmod u-r a.txt  # 作者权限删掉r g-r o-r 小组和其他人删除可读权限</span><br><span class="line">chmod u+r a.txt</span><br><span class="line">chmod go-r a.txt</span><br><span class="line">chmod 444 a.txt  # 100 100 100对应u g o的r w x权限</span><br><span class="line"></span><br><span class="line">grep searchword a.txt  # 包含单词searchword的内容，也可正则</span><br><span class="line">grep ^Hello a.txt  # 以Hello开头的内容</span><br><span class="line">grep searchword a.txt | wc  # 命令组合</span><br><span class="line"></span><br><span class="line">ls &gt; a.txt  # 重定向</span><br></pre></td></tr></table></figure><p>脚本<code>test.sh</code>就是一坨命令，执行脚本就是按照顺序执行这些命令。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh test.sh  # 运行脚本</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">a=10  # 赋值不能加空格</span><br><span class="line">echo $a  # 使用变量时加$ echo输出</span><br><span class="line">c=`expr $a + $b`  # 运算符两侧必须加空格</span><br><span class="line">c=`expr $a \* $b`  # \(\)</span><br><span class="line"></span><br><span class="line">if [ $a -gt $b ]  # 比较大小不能用 &gt; &lt; =</span><br><span class="line">then</span><br><span class="line">    echo $a</span><br><span class="line">else</span><br><span class="line">    echo $b</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for x in 1 2 3  # for x in &#123;1 .. 3&#125;</span><br><span class="line">do</span><br><span class="line">    echo $x</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">x=1</span><br><span class="line">while [ $x -le 10]</span><br><span class="line">do</span><br><span class="line">    echo $x</span><br><span class="line">    x=`expr $x + 1`</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">a=&quot;hello&quot;</span><br><span class="line">b=&quot;world&quot;</span><br><span class="line"></span><br><span class="line">read a</span><br><span class="line">read b</span><br><span class="line">c=`expr $a + $b`</span><br><span class="line">echo $a + $b = $c</span><br><span class="line"></span><br><span class="line">if [ $a = $b ]</span><br><span class="line">if [ $a != $b ]</span><br><span class="line">str3=&quot;$str1$str2&quot;  # 拼接</span><br><span class="line">if [ -z $str1 ]  # 是否为空 -n是否为不空</span><br><span class="line"></span><br><span class="line">arr=(1 2 3)  # 只能用bash test.sh</span><br><span class="line">echo $&#123;arr[1]&#125;</span><br><span class="line">for i in $&#123;arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">echo $USER  # global variable 当前登录用户</span><br><span class="line">cd $HOME</span><br><span class="line">cd ~</span><br><span class="line">echo $PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原PATH拼接新路径 不要写成PATH=/home</span></span><br><span class="line">PATH=$PATH:/home/ubuntu/dir  # 可执行程序只能在当前目录下执行，如果要在其他目录执行需要配置环境变量，配置后该目录下的所有可执行程序都可以在任意地方执行</span><br><span class="line"></span><br><span class="line">zip hello.zip *  # 打包所有文件</span><br><span class="line">zip hello.zip -r hello/*  # 递归打包所有子文件夹</span><br><span class="line"></span><br><span class="line">unzip hello.zip</span><br><span class="line"></span><br><span class="line">tar -zcvf hello.tar.gz hello/  # -z使用gzip压缩</span><br><span class="line">tar -zxvf hello.tar.gz  # 解压</span><br><span class="line"></span><br><span class="line">wget url -O newname  # 下载</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Random Forest</title>
      <link href="/2019/05/15/Random%20Forest/"/>
      <url>/2019/05/15/Random%20Forest/</url>
      
        <content type="html"><![CDATA[<h2 id="decision-tree">Decision Tree</h2><h2 id="details">Details</h2><p>决策树的发展经历了CART(Classification and Regression Tree), ID3, C4.5等多个阶段：<br />CART是一种二叉树，分类树采用基尼系数，回归树采用平方误差。<br />ID3主要用于分类，是一种多叉树结构，采用信息增益。<br />C4.5主要用于分类，是一种多叉树结构，采用信息增益比。<br />最终的模型为： <span class="math display">\[f(x)=\sum_{i=1}^{m}C_iI(x\in R_i),I(x\in R_i)=\begin{cases}1, &amp; \text{x$\in$ $R_i$}  \\0, &amp; \text{else}\end{cases}\]</span> m表示数据集被划分的子集数目，<span class="math inline">\(C_i\)</span>表示第i个单元的输出值 ## Example ## Implementation ## Properties</p><h2 id="motivation">Motivation</h2><p>Random Forest is some kind of ensemble learning method, just as its name indicates. The base learner is decision tree and RF uses Bagging to integrate. The difference mainly lies in the word 'Random'. The original decision tree selects the best attribute while RF has two steps to select a split attribute for each base learner:</p><ul><li>Select k attributes from <span class="math inline">\(A\)</span> randomly;</li><li>Select the best attribute from the k attributes. If k=1 then it's total random selection; If k=<span class="math inline">\(|A|\)</span> then it's the same as decision tree. The recommended is <span class="math inline">\(k=log_2|A|\)</span>.</li></ul><p>The intuition behind this is to increase the diversity of the base learners. In original bagging method we just use the sample disturbance of the training data. But in RF we add the attribute disturbance thus making the learner generalize very well.</p><p>As you can imagine, RF's performance is worse than Bagging during the early time of the training process. Since we just use a subset of the attributes so the base learner performs not that well. But with the increase of the number of base learners, it will gradually use the whole information and then has a low generation error. By the way, RF is often faster than Bagging since we only use a subset to train the base learners.</p><h2 id="随机森林回归">随机森林回归</h2><p>决策树回归的叶子结点代表一小片区域，落入该区域的训练样例的均值被用来作为该区域的预测值：<br /><img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211102104210878-1445042394.png" alt="image" /><br />例如上图中右下角的叶子结点的值552.899就是落入该区域的5个样本的均值。<br />随机森林则是由若干棵决策树通过某些“随机”的方式构建而成，包括样本随机和属性随机，最终的预测结果由所有树的平均得到。<br />但是它不像线性回归那样在预测时可以外推，如果仔细观察最终参与决策的树的某一部分：<br /><img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211102105550016-162430821.png" alt="image" /><br />可以看到：在carat&lt;0.905和z&lt;3.915这个区域共有4个训练样本，因此测试集中任意一个落入此区域的样本都会被预测为4个样本的均值2775.75，自然也就不会超过这4个样本的取值极限。<br />如果要预测某个target value超出训练集极限的样例，其预测结果仍然是训练集中某些样本的均值。</p><p>缺失值处理：我在科研中见到的都是先用常数填充训练数据和测试数据，再去扔给模型训练和预测。<br />我使用sklearn中标准的RandomForestRegressor进行了尝试，如果训练数据包含缺失值，那么训练将会报错。 ## Example ## Implementation ## Properties ## Refs <a href="https://neptune.ai/blog/random-forest-regression-when-does-it-fail-and-why">Random Forest Regression: When Does It Fail and Why?</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linked List Cycle</title>
      <link href="/2019/05/11/Linked%20List%20Cycle/"/>
      <url>/2019/05/11/Linked%20List%20Cycle/</url>
      
        <content type="html"><![CDATA[<h2 id="一单链表是否有环">一、单链表是否有环</h2><p><a href="https://leetcode.com/problems/linked-list-cycle/">题目描述</a><br />快慢指针：若链表有环，则两指针必在将来某一时刻相遇：</p><ul><li>直观来看：本质上就是物理上的相对运动。快指针每次2步，慢指针每次1步。<br />如果没有环，快指针先到达链尾，结束；<br />如果有环，相对速度为1，即相当于慢指针静止，快指针每次1步，则必然在一圈之内相遇。</li><li>那如果快指针每次3步，4步呢？由之前的相对运动，我们知道两个指针不一定相遇。那么什么情况下可以相遇呢？<br /><img src="https://img-blog.csdnimg.cn/20200309193026391.png" alt="在这里插入图片描述" /><br />当S第一次到达环口，F可能已经在环里转了n圈。假设S的速度为<span class="math inline">\(v_s\)</span>，F的速度为<span class="math inline">\(v_f\)</span>，环长为<span class="math inline">\(L\)</span>，经过时间<span class="math inline">\(t\)</span>相遇： <span class="math display">\[disS=L_1, disF=L_1+L_2+nL\]</span><br />即问题转化为是否存在正整数<span class="math inline">\(t\)</span>，使得S和F在环内走过的路程相等： <span class="math display">\[v_st\%L=(L_2+nL+v_ft)\%L\]</span> 根据模运算性质： <span class="math display">\[(L_2+nL+(v_f-v_s)t)\%L=0\]</span> 再化简： <span class="math display">\[(L_2+(v_f-v_s)t)\%L=0\]</span> 也就是当<span class="math inline">\(L_2+(v_f-v_s)t\)</span>是环长<span class="math inline">\(L\)</span>的整数倍，快慢指针可以相遇。<br />回头去看最简单的情形：<span class="math inline">\(v_f-v_s=1\)</span>，则<span class="math inline">\(t=mL-L_2\)</span>，取<span class="math inline">\(m=1,t=L-L_2\)</span>。所以经过<span class="math inline">\(t\)</span>步必然相遇。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 单链表定义</span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int x):val(x),next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">    if (head == NULL)</span><br><span class="line">   return false;</span><br><span class="line">  ListNode* fast = head;</span><br><span class="line">  ListNode* slow = head;</span><br><span class="line">  while (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    if(fast == slow)</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二寻找环的入口">二、寻找环的入口</h2><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">题目描述</a><br />设链头距离环的入口距离为<span class="math inline">\(L_1\)</span>，<strong>相遇点</strong>距离入口距离为<span class="math inline">\(L_3\)</span>，环的长度为<span class="math inline">\(L\)</span>：<br /><img src="https://img-blog.csdnimg.cn/20200309203553400.png" alt="在这里插入图片描述" /><br />证明的本质在于求出<span class="math inline">\(L_1\)</span>与<span class="math inline">\(L_3\)</span>的关系。<br />在（一）中我们已经证明了S从入口到相遇只走了<span class="math inline">\(L-L_2&lt;L\)</span>步，即小于1圈。<br />由于快指针走过的路程是慢指针的2倍： <span class="math display">\[L_1+L_2+nL+2(L-L_2)=2(L_1+L-L_2)\]</span> 即： <span class="math display">\[L_1=L_2+nL\]</span> 又<span class="math inline">\(L_3=L-(L-L_2)=L_2\)</span>，故有： <span class="math display">\[L_1=nL+L_3\]</span> n表示S第一次到达入口时，快指针已经绕了<span class="math inline">\(n\)</span>圈。<br />也就是说：设两个指针<span class="math inline">\(p_1, p_2\)</span>，<span class="math inline">\(p_1\)</span>指向链头，<span class="math inline">\(p_2\)</span>指向相遇点，每次都走一步，则两指针必在环的入口相遇。<br />通俗理解：<span class="math inline">\(p_1\)</span>指针先走<span class="math inline">\(L_3\)</span>步，此时<span class="math inline">\(p_1\)</span>距离环入口还有<span class="math inline">\(L_1-L_3=nL\)</span>步，同时<span class="math inline">\(p_2\)</span>也走了<span class="math inline">\(L_3\)</span>步，刚好到环入口。接着<span class="math inline">\(p_1\)</span>继续走<span class="math inline">\(nL\)</span>步，<span class="math inline">\(p_2\)</span>开始绕环<span class="math inline">\(n\)</span>圈，必相遇。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//单链表定义</span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int x):val(x),next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* detectCycle(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        auto fast = head;</span><br><span class="line">        auto slow = head;</span><br><span class="line">        while(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if(fast == slow)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!fast || !fast-&gt;next)   //无环,fast走到尽头</span><br><span class="line">            return nullptr;</span><br><span class="line"></span><br><span class="line">        slow = head;   //一个指向链头,另一个指向相遇点</span><br><span class="line">        while(slow != fast)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;    //找到入口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Subarray</title>
      <link href="/2019/05/05/Maximum%20Subarray/"/>
      <url>/2019/05/05/Maximum%20Subarray/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>给定一个序列<span class="math inline">\(A_0\)</span>、<span class="math inline">\(A_1\)</span>、<span class="math inline">\(A_2\)</span>、...、<span class="math inline">\(A_{n-1}\)</span>，求<span class="math inline">\(A_i+A_{i+1}+...+A_j\)</span>的最大值。</p><h2 id="解一">解一</h2><p>暴力枚举左端点<span class="math inline">\(i\)</span>和右端点<span class="math inline">\(j\)</span>，之后计算<span class="math inline">\(A_i\)</span>和<span class="math inline">\(A_j\)</span>之间的和，时间复杂度<span class="math inline">\(O(n^3)\)</span>，很容易TLE。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define INF 0x7FFFFFFF</span><br><span class="line"></span><br><span class="line">int sub_sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int MAX = -INF;</span><br><span class="line">    for(int i = 0;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = i; j &lt; n; j++)</span><br><span class="line">  &#123;</span><br><span class="line">   int temp = 0;</span><br><span class="line">   for (int k = i; k &lt;= j; k++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp += a[k];</span><br><span class="line">  &#125;</span><br><span class="line">   if (temp &gt; MAX)</span><br><span class="line">   &#123;</span><br><span class="line">   MAX = temp;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解二">解二</h2><p>输入数据时记录前缀和，预处理<span class="math inline">\(sum[i] = A[0] + ... + A[i]\)</span>，因此<span class="math inline">\(A_i+A_{i+1}+...+A_j=sum[j]-sum[i-1]\)</span>，复杂度优化为<span class="math inline">\(O(n^2)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int sub_sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int MAX = -INF;</span><br><span class="line">    for(int i = 0;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = i;j &lt; n;j++&#125;</span><br><span class="line">        &#123;</span><br><span class="line">            int temp = sum[j] - sum[i - 1];</span><br><span class="line">            if(temp &gt; MAX)</span><br><span class="line">                MAX = temp;</span><br><span class="line">            else</span><br><span class="line">                temp = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解三">解三</h2><p>动态规划，复杂度<span class="math inline">\(O(n)\)</span>。<br />定义状态数组<span class="math inline">\(dp[i]\)</span>，表示以<span class="math inline">\(A[i]\)</span>结尾的连续序列的最大和，这样就只有两种情况：<br />1，该连续序列只有<span class="math inline">\(A[i]\)</span>这一个元素；<br />2，该序列有多个元素，从之前的<span class="math inline">\(A[p]\)</span>开始，到<span class="math inline">\(A[i]\)</span>结束。<br />对于1，最大和就是<span class="math inline">\(A[i]\)</span>；<br />对于2，最大和是<span class="math inline">\(dp[i - 1]+A[i]\)</span>，因为<span class="math inline">\(dp[i]\)</span>要求以<span class="math inline">\(A[i]\)</span>结尾，所以即使<span class="math inline">\(A[i]\)</span>为负数，<span class="math inline">\(dp[i]\)</span>仍然等于<span class="math inline">\(dp[i - 1]+A[i]\)</span>。<br />所以<strong>状态转移方程</strong>就是： <span class="math display">\[dp[i]=max{\{A[i],dp[i-1]+A[i]\}}\]</span> 边界是<span class="math inline">\(dp[0]=A[0]\)</span>。<br />所以枚举<span class="math inline">\(i\)</span>，得到<span class="math inline">\(dp\)</span>数组，求出<span class="math inline">\(dp\)</span>数组最大值即可。</p><p>可以看到，每次计算<span class="math inline">\(dp[i]\)</span>只用到<span class="math inline">\(dp[i-1]\)</span>，不直接用到之前的信息，这就是状态的<strong>无后效性</strong>，只有这样，动态规划才可能得到正确结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int dp[5010];</span><br><span class="line">dp[0] = a[0];</span><br><span class="line"></span><br><span class="line">int sub_sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 1;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        //状态转移方程</span><br><span class="line">        dp[i] = max(a[i],dp[i - 1] + a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int k = 0;</span><br><span class="line">    for(int i = 1;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(dp[i] &gt; dp[k])</span><br><span class="line">            k = i;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免使用<span class="math inline">\(dp[]\)</span>数组，可以将空间复杂度优化为<span class="math inline">\(O(1)\)</span>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int allSum = INT_MIN, curSum = 0;</span><br><span class="line">        </span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum = max(nums[i], curSum + nums[i]);</span><br><span class="line">            if(curSum &gt; allSum)</span><br><span class="line">            &#123;</span><br><span class="line">                allSum = curSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return allSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree &amp; Graph Search</title>
      <link href="/2019/05/03/Tree%20&amp;%20Graph%20Search/"/>
      <url>/2019/05/03/Tree%20&amp;%20Graph%20Search/</url>
      
        <content type="html"><![CDATA[<h2 id="tree-search">Tree Search</h2><p>二叉树结点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *left, *right;</span><br><span class="line">    <span class="built_in">Node</span>(): <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> x, Node *left, Node *right): <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多叉树结点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bfs">BFS</h3><ol type="1"><li>二叉树的层序遍历</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">travel</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    queue&lt;Node *&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>多叉树的层序遍历</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">level_order</span>(Node* root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            Node* cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            ans[depth].<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (Node* child : cur-&gt;children) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dfs">DFS</h3><ol type="1"><li>二叉树</li></ol><p>先序遍历： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;left, vec);</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) s.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) s.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>中序遍历： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;left, vec);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">travel</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node *&gt; s;</span><br><span class="line"></span><br><span class="line">    Node *cur = root;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后序遍历： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;left, vec);</span><br><span class="line">    <span class="built_in">travel</span>(root-&gt;right, vec);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代1</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">travel</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node *&gt; s;</span><br><span class="line">    Node *cur = root;</span><br><span class="line">    Node *last_vis = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur &amp;&amp; last_vis != root) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur != last_vis) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;right || cur-&gt;right == last_vis) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            last_vis = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代2</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    stack&lt;Node *&gt; s, res;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *cur = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push</span>(cur);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) s.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) s.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">while</span> (!res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(res.<span class="built_in">top</span>()-&gt;val);</span><br><span class="line">        res.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.bilibili.com/video/BV1NU4y1M7rF?p=14">Morris遍历0:39:00开始</a></p><p><img src="https://img-blog.csdnimg.cn/8138f0b04af941bc91e80728cdf8ea59.png" alt="在这里插入图片描述" /> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morris</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root, *mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) &#123;</span><br><span class="line">                mostRight = mostRight-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mostRight是cur左子树最右结点</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight-&gt;right) &#123;  <span class="comment">// 第一次来到cur</span></span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// mostRight-&gt;right == cur</span></span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morrisPreorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root, *mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) &#123;</span><br><span class="line">                mostRight = mostRight-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mostRight是cur左子树最右结点</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight-&gt;right) &#123;  <span class="comment">// 第一次来到cur</span></span><br><span class="line">                cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// mostRight-&gt;right == cur</span></span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morrisInorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = root, *mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) &#123;</span><br><span class="line">                mostRight = mostRight-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// mostRight是cur左子树最右结点</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight-&gt;right) &#123;  <span class="comment">// 第一次来到cur</span></span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// mostRight-&gt;right == cur</span></span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cur = cur-&gt;right;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">morrisPostorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li>多叉树 先根遍历</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node* root, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    ans.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">for</span> (Node* child : root-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">preorder</span>(child, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cur-&gt;children.<span class="built_in">rbegin</span>(); it != cur-&gt;children.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后根遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node *child : root-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(child, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cur-&gt;children.<span class="built_in">begin</span>(); it != cur-&gt;children.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="graph-search">Graph Search</h2><p>笔试一般化为平时擅长的图表示再去做算法。</p><h3 id="图的表示及转换">图的表示及转换</h3><figure><img src="https://img-blog.csdnimg.cn/20200218153739820.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><ul><li>邻接矩阵</li></ul><table><thead><tr class="header"><th>i/j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr class="odd"><td>0</td><td>0</td><td>-1</td><td>4</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td>1</td><td><span class="math inline">\(\infty\)</span></td><td>0</td><td>3</td><td>2</td><td>2</td></tr><tr class="odd"><td>2</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td>0</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td>3</td><td><span class="math inline">\(\infty\)</span></td><td>1</td><td>5</td><td>0</td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="odd"><td>4</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td>-3</td><td>0</td></tr></tbody></table><p>用<code>vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, INF))</code>表示，<code>g[i][j]</code>表示从顶点<span class="math inline">\(i\)</span>到顶点<span class="math inline">\(j\)</span>的权重，空间复杂度<span class="math inline">\(O(|V|^2)\)</span>，适用于稠密图，用的不多；</p><ul><li>邻接表：链表比较少用，基本都用动态数组。</li></ul><table><thead><tr class="header"><th>0</th><th>(1,-1)</th><th>(2,4)</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr class="odd"><td>1</td><td>(2,3)</td><td>(3,2)</td><td>(4,2)</td><td>-</td><td>-</td></tr><tr class="even"><td>2</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr class="odd"><td>3</td><td>(1,1)</td><td>(2,5)</td><td>-</td><td>-</td><td>-</td></tr><tr class="even"><td>4</td><td>(3,-3)</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>用<code>vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g</code>表示，<code>g[i][j].first</code>表示从顶点<span class="math inline">\(i\)</span>出发到达的顶点<span class="math inline">\(k\)</span>，<code>g[i][j].second</code>表示从顶点<span class="math inline">\(i\)</span>到顶点<span class="math inline">\(k\)</span>的权值，空间复杂度<span class="math inline">\(O(|V|+|E|)\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵转邻接表</span></span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">to_adj_list</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; adj_matrix) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = adj_matrix.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">ans</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj_matrix[i][j] != INT_MAX)</span><br><span class="line">                tmp.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(j, adj_matrix[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表转邻接矩阵</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">to_adj_matrix</span>(vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;&amp; adj_list) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = adj_list.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, INT_MAX));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; p : adj_list[i]) &#123;</span><br><span class="line">            ans[i][p.first] = p.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>边表<br />每个三元组表示一条边，上图的所有边表示为：<span class="math inline">\((0,1,-1),(0,2,4),(1,2,3),(1,3,2),(1,4,2),(3,1,1),(3,2,5),(4,3,-3)\)</span> 用<code>vector&lt;vector&lt;int&gt;&gt; e</code>表示，<code>e[i][0]</code>表示顶点<span class="math inline">\(u\)</span>，<code>e[i][1]</code>表示顶点<span class="math inline">\(v\)</span>，<code>e[i][2]</code>表示<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的权值，空间复杂度<span class="math inline">\(O(|E|)\)</span>。</p></li><li><p>链式前向星<br />空间复杂度<span class="math inline">\(O(n)\)</span>，结合了邻接表和边表，包括边表数组<code>edge</code>和头结点数组<code>head</code>， <img src="https://img-blog.csdnimg.cn/20200725135220669.png" alt="img" /> 从结点2出发的边有4条，第一条边<code>head[2]=8</code>意味着该边存在<code>edge[8]</code>，下一条边存在<code>edge[6]</code>，<code>next==-1</code>表示结束。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, w;  <span class="comment">// 边终点to 下一条边next 权值w</span></span><br><span class="line">&#125; edge[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[<span class="number">1000000</span>];  <span class="comment">// head[i]表示指向i的第一条边的存储位置</span></span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// 记录edge的末尾位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">        edge[i].next = <span class="number">-1</span>;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edge[cnt].to = v;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历结点i的所有邻接点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="bfs-1">BFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    queue = []</span><br><span class="line">    marked = <span class="built_in">set</span>()  <span class="comment"># 避免环造成死循环</span></span><br><span class="line">    parent = &#123;s : <span class="literal">None</span>&#125;  <span class="comment"># for shortest path</span></span><br><span class="line">    queue.append(s)</span><br><span class="line">    marked.add(s)</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(queue) &gt; <span class="number">0</span>):</span><br><span class="line">        cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(cur)</span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur]:</span><br><span class="line">            <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                marked.add(adj)</span><br><span class="line">                queue.append(adj)</span><br><span class="line">                parent[adj] = cur</span><br><span class="line">    <span class="keyword">return</span> parent</span><br></pre></td></tr></table></figure><p>双向BFS <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q1, q2;</span><br><span class="line">    q1.<span class="built_in">push</span>(s), q2.<span class="built_in">push</span>(e);</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; vis1&#123;s&#125;, vis2&#123;e&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q1.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = q1.<span class="built_in">front</span>(); q1.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> nei : cur.neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis1.<span class="built_in">count</span>(nei)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (vis2.<span class="built_in">count</span>(nei)) <span class="keyword">return</span> res;</span><br><span class="line">                    vis1.<span class="built_in">insert</span>(nei);</span><br><span class="line">                    q1.<span class="built_in">push</span>(nei);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q2.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = q2.<span class="built_in">front</span>(); q2.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> nei : cur.neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis2.<span class="built_in">count</span>(nei)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (vis1.<span class="built_in">count</span>(nei)) <span class="keyword">return</span> res;</span><br><span class="line">                    vis2.<span class="built_in">insert</span>(nei);</span><br><span class="line">                    q2.<span class="built_in">push</span>(nei);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="dfs-1">DFS</h3><p>从起点出发，标记走过的点，如果发现没有走过的点，随便选一个向前走，无路可走就回退。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    stack.append(s)</span><br><span class="line">    marked.add(s)</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(stack) &gt; <span class="number">0</span>):</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        <span class="built_in">print</span>(cur)</span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur]:</span><br><span class="line">            <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                marked.add(adj)</span><br><span class="line">                stack.append(adj)</span><br></pre></td></tr></table></figure><p>很不幸的是：上面的代码是错的。举个例子：g有ABCDEF6个结点，边为AB AC BC BD CD CE DE DF，如果走ABDE的话，最终答案应该是ABDECF，但是上述代码的结果是ABDEFC，显然不是合法的DFS结果。</p><p>问题在于标记结点是否访问的时机不对，在D弹出后，直接把EF入栈并标记为已访问，下次到E时发现C已被标记，但此时C很明显并未访问。<br />不应在入栈时标记，而应该在弹出时标记。因为入栈时并没有真正地访问该节点，出栈时才真正访问。<br />可以参考<a href="https://github.com/joepachou/NoteBook/issues/116">CS61B</a>，正确的代码如下，可能会导致重复入栈（有方法避免）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    stack.append(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(stack) &gt; <span class="number">0</span>):</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">            marked.add(cur)</span><br><span class="line">            <span class="built_in">print</span>(cur)</span><br><span class="line">            <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur]:</span><br><span class="line">                <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                    stack.append(adj)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    <span class="keyword">global</span> marked</span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    marked.add(s)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="keyword">for</span> adj <span class="keyword">in</span> g[s]:</span><br><span class="line">        <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">            dfs(g, adj)</span><br></pre></td></tr></table></figure></p><ul><li><p>判断从V出发能否走到终点 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> dfs(v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v <span class="keyword">is</span> terminal) <span class="keyword">return</span> true;</span><br><span class="line">    <span class="keyword">if</span> (vis[v]) <span class="keyword">return</span> false;</span><br><span class="line">    vis[v] = true;</span><br><span class="line">    <span class="keyword">for</span> (u <span class="keyword">in</span> adj(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(u)) <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>判断从V出发能否走到终点，若能，记录路径</p></li></ul><p>栈的作用就是在走投无路之时留给你的退路。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Node path[MAX_LEN];  <span class="comment">// MAX_LEN取节点总数即可</span></span><br><span class="line"><span class="keyword">int</span> depth;  <span class="comment">// 当前点的深度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(V)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (V为终点) &#123;</span><br><span class="line">        path[depth] = V;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (V为旧点) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    将V标记为旧点;</span><br><span class="line">    path[depth++] = V;</span><br><span class="line"></span><br><span class="line">    对和V相邻的每个节点U &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Dfs</span>(U))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    --depth;   <span class="comment">//从V走不到终点，把V排除出数组,回退到V的父节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    所有点标记为新点;</span><br><span class="line">    depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dfs</span>(起点)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= depth; i++) &#123;</span><br><span class="line">            cout &lt;&lt; path[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历图上所有节点 <img src="https://img-blog.csdnimg.cn/20190409225110387.png" alt="在这里插入图片描述" /></li></ul><p>邻接矩阵存储遍历复杂度<span class="math inline">\(O(n^2)\)</span>，因为对每个节点，都要判断其它所有节点是否相邻。 邻接表遍历复杂度<span class="math inline">\(O(n+e)\)</span>。</p><p>1、<a href="http://poj.org/problem?id=1164">城堡问题</a> 给一个地图以及每个格子周围的墙所代表数字之和，求该地图有多少房间，最大房间的面积。</p><p>分析： 要先判断每个格子周围有什么墙，注意到1，2，4，8的二进制形式<code>0001</code>、<code>0010</code>、<code>0100</code>、<code>1000</code>，所以只要将输入数字与1，2，4，8相与，就能知道该方块周围有什么墙。 把方块看作节点，相邻两个方块如果没有墙，就在这两节点之间连一条边，转换为图。 房间个数：图中的极大连通子图个数 <strong>极大连通子图：一个连通子图，加任意一个图中的其他点就不连通，这个子图就是极大连通子图。</strong></p><p>具体： 对每个房间进行DFS，得到该房间所在的极大连通子图，染色所有能够到达的房间，最后统计共用了几种颜色以及每种颜色的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> room[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> color[<span class="number">50</span>][<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;   <span class="comment">//标记方块是否染色,初始都未被访问</span></span><br><span class="line"><span class="keyword">int</span> maxRoomArea = <span class="number">0</span>, roomNum = <span class="number">0</span>, curRoomArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span>   <span class="comment">//从i,j出发遍历极大连通子图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (color[i][j])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    color[i][j] = roomNum;   <span class="comment">//该方块染色</span></span><br><span class="line">    curRoomArea++;</span><br><span class="line">    <span class="keyword">if</span> ((room[i][j] &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i, j - <span class="number">1</span>);  <span class="comment">//没有西墙，向西走</span></span><br><span class="line">    <span class="keyword">if</span> ((room[i][j] &amp; <span class="number">2</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="keyword">if</span> ((room[i][j] &amp; <span class="number">4</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i, j + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ((room[i][j] &amp; <span class="number">8</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i + <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, column;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;row, &amp;column);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;room[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!color[i][j])   <span class="comment">//找到一个新的房间</span></span><br><span class="line">            &#123;</span><br><span class="line">                roomNum++;</span><br><span class="line">                curRoomArea = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">Dfs</span>(i, j);          <span class="comment">//探索该房间（极大连通子图）</span></span><br><span class="line">            &#125;</span><br><span class="line">            maxRoomArea = <span class="built_in">max</span>(curRoomArea, maxRoomArea);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>, roomNum, maxRoomArea);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<a href="http://bailian.openjudge.cn/practice/4103">踩方格</a> 递归，从<span class="math inline">\((i,j)\)</span>出发走n步的方案数就等于先走一步，从其它三个格子走n-1步的方案数之和。 前提就是该方块没走过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isVisited[<span class="number">20</span>][<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//访问过直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isVisited[i][j])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    isVisited[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以走三个方向</span></span><br><span class="line">    ans += <span class="built_in">Dfs</span>(i - <span class="number">1</span>, j, n - <span class="number">1</span>);</span><br><span class="line">    ans += <span class="built_in">Dfs</span>(i, j - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    ans += <span class="built_in">Dfs</span>(i, j + <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回前表示当前格子可以重新被访问，以后的走法可能会访问到</span></span><br><span class="line">    isVisited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Dfs</span>(<span class="number">20</span>, <span class="number">20</span>, n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<a href="http://poj.org/problem?id=1724">ROADS</a> 很多时候，并不需要一条路走到黑，这就是深搜中的<strong>剪枝</strong>。 <img src="https://img-blog.csdnimg.cn/20190414173437346.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储边,不需要起点,G(i)表示从i出发*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Road</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> destination, len, toll;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接表存储图*/</span></span><br><span class="line">vector&lt;vector&lt;Road&gt;&gt; <span class="built_in">G</span>(<span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, n, r;</span><br><span class="line"><span class="keyword">int</span> minLen;   <span class="comment">//探索过的最短的路径</span></span><br><span class="line"><span class="keyword">int</span> totalLen;   <span class="comment">//正在探索的最短路径</span></span><br><span class="line"><span class="keyword">int</span> totalCost;   <span class="comment">//正在探索的花费</span></span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> minL[<span class="number">110</span>][<span class="number">10010</span>]; <span class="comment">//minL[i][j]:从1走到城市i，且花了j块钱的最优路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == n)   <span class="comment">//找到了路径</span></span><br><span class="line">    &#123;</span><br><span class="line">        minLen = <span class="built_in">min</span>(minLen, totalLen);</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">//强制结束函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = G[s].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Road r = G[s][i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*判断有没有足够的钱走到r.destination*/</span></span><br><span class="line">        <span class="keyword">if</span> (totalCost + r.toll &gt; k) <span class="comment">//钱不够，试下一条边</span></span><br><span class="line">            <span class="keyword">continue</span>;     <span class="comment">//可行性剪枝</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!visited[r.destination])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*最优性剪枝*/</span></span><br><span class="line">            <span class="comment">//当前走过的路长度已经大于之前的minLen，就没必要走下去</span></span><br><span class="line">            <span class="keyword">if</span> (totalLen + r.len &gt;= minLen)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//走到r.d时花费同样的钱走过的路长度大于之前相同花费的路长度</span></span><br><span class="line">            <span class="keyword">if</span> (totalLen + r.len &gt;= minL[r.destination][totalCost + r.toll])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            minL[r.destination][totalCost + r.toll] = totalLen + r.len;</span><br><span class="line"></span><br><span class="line">            totalLen += r.len;</span><br><span class="line">            totalCost += r.toll;</span><br><span class="line">            visited[r.destination] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(r.destination);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*不走r.destination*/</span></span><br><span class="line">            visited[r.destination] = <span class="number">0</span>; <span class="comment">//换下条边之前将访问标志清0</span></span><br><span class="line">            totalLen -= r.len;</span><br><span class="line">            totalCost -= r.toll;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从城市1开始深搜整个图，找到所有能到达n的，选最优的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;n, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> source;</span><br><span class="line">        Road r;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;source, &amp;r.destination, &amp;r.len, &amp;r.toll);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (source != r.destination)</span><br><span class="line">        &#123;</span><br><span class="line">            G[source].<span class="built_in">push_back</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">    totalLen = <span class="number">0</span>, totalLen = <span class="number">0</span>;</span><br><span class="line">    minLen = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;   <span class="comment">//置为无穷大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">110</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10010</span>; j++)</span><br><span class="line">            minL[i][j] = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    visited[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);  <span class="comment">//走完了所有路</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minLen &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, minLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、<a href="http://poj.org/problem?id=1190">生日蛋糕</a> <img src="https://img-blog.csdnimg.cn/20190414175732766.png" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/20190414182524737.png" alt="在这里插入图片描述" /> <a href="http://bailian.openjudge.cn/practice/2816/">练习1</a><br /><a href="http://bailian.openjudge.cn/practice/2488/">练习2</a><br /><a href="http://bailian.openjudge.cn/practice/1321/">练习3</a></p><h2 id="refs">Refs</h2><p><a href="https://www.icourse163.org/learn/PKU-1001894005?tid=1205957211#/learn/content?type=detail&amp;id=1210422520">郭炜老师MOOC</a><br /><a href="http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/Data_Structures/binary_tree_traversals.html">Binary Tree Traversals</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Character Array and Character Pointer</title>
      <link href="/2019/04/29/Character%20Array%20and%20Character%20Pointer/"/>
      <url>/2019/04/29/Character%20Array%20and%20Character%20Pointer/</url>
      
        <content type="html"><![CDATA[<p>最近复习数据结构实验时，碰到这么一行代码，看的有点不爽。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef char** HuffmanCode;</span><br></pre></td></tr></table></figure><p>借此梳理下数组和指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int* p; //指针变量p中存的地址代表的内存单元中的数据是整型</span><br></pre></td></tr></table></figure><p>在32位平台下，由于p存的是地址，故p的值是32位。<br />不论p指向什么类型的数据，指针变量p本身都是整型。</p><p>c中没有<code>string</code>类型，所以一般用字符数组表示字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char str[15] = &quot;Hello World&quot;;</span><br></pre></td></tr></table></figure><p>c规定数组名表示数组在内存中的首地址，就是<code>str = &amp;str[0]</code>，我们一般输出字符串时<code>printf("%s",str);</code>，首地址就可以输出整个字符串。</p><p>在c中可以这么干：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *s;</span><br><span class="line">s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure><p>一个字符串赋值给一个指针变量？？</p><p>事实上，c的编译器会给字符串常量分配内存，假设<code>"Hello"</code>的地址是<code>0x0000000000404000 0x0000000000404001 0x0000000000404002 0x0000000000404003 0x0000000000404004 0x0000000000404005</code>，（我是64位环境）<br />其实是<code>s = "Hello" = 0x0000000000404000</code>，c编译器把这个串看作首地址。</p><p>做个测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%s\n&quot;,s);</span><br><span class="line">printf(&quot;%s\n&quot;,0x0000000000404000);</span><br><span class="line">这两行的效果是一样的。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char str[10];</span><br><span class="line">char* s;</span><br></pre></td></tr></table></figure><p><code>str</code>表示首地址，<code>s</code>也保存首地址，所以可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = str;</span><br><span class="line">但是不可以 str = s;</span><br></pre></td></tr></table></figure><p>因为数组名是一个常量，不能被赋值。<br />事实上，<code>char str[10]</code>编译器会分配10个内存单元，而<code>char* s</code>只是定义了一个指针变量，32位环境下只分配4个字节，用来保存字符串首地址。</p><p>不信测试下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof(str) = 10;</span><br><span class="line">sizeof(s) = 4;   //分配四个字节来保存地址</span><br></pre></td></tr></table></figure><p>所以数组名和指针变量本质上是不同的。</p><p>接下来我们看看<code>char**与char* a[]</code>：<br />对于<code>char* a[]</code>，a实质上还是一个数组，这个数组保存的元素是<code>char*</code>类型的，<code>char*</code>也就是存着地址的变量。</p><p>所以可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* a[] = &#123;&quot;me&quot;,&quot;you&quot;,&quot;him&quot;&#125;;</span><br></pre></td></tr></table></figure><p>这时在32位环境下<code>sizeof(a) = 12</code>，因为a中的3个元素都是<code>char*</code>指针，而指针变量占4个字节。<br />可以打印出来看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%p %p %p\n&quot;,a[0],a[1],a[2]);</span><br><span class="line">printf(&quot;%p %p %p\n&quot;,&amp;a[0],&amp;a[1],&amp;a[2]);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019021915473671.png" alt="在这里插入图片描述" /><br />数组中3个元素保存了3个地址，也就是3个字符串的首地址。</p><p>对于<code>char** s</code>：<br />二级指针变量s保存一级指针<code>char*</code>的地址，我们可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = a;</span><br></pre></td></tr></table></figure><p>数组名<code>a=&amp;a[0]=62FE30</code>，而这个地址中（即a[0]）保存的是<code>404000</code>这个地址，也就是字符串<code>"me"</code>的首地址，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*s = 404000 = &quot;me&quot;;</span><br></pre></td></tr></table></figure><p>易错点1： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char** s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure> 这是错的，因为s是<code>char**</code> ，而"Hello"是<code>char*</code>。<br />虽然都是地址，但是"Hello"表示的地址中内容是H，char型； s存的地址中的内容（<code>*s</code>）是<code>char*</code>型，指针类型。</p><p>易错点2： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char** s;</span><br><span class="line">*s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure> 这样编译不会错，但是运行时<code>printf("%s",*s);</code>就会崩溃。</p><p>假设<code>s=0x1000</code>，在<code>0x1000</code>内存单元中存的是"Hello"的地址<code>0x2000</code>，即<code>*s = 0x2000</code>，这样执行时先找到<code>0x1000</code>，然后是<code>0x2000</code>，没有问题。</p><p>但<code>char** s;</code>，s存的是一个随机的地址，也就是野指针，<code>*s</code>就可能会崩溃。</p><p>所以要先分配一个地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char** s;</span><br><span class="line">s = (char**) malloc(sizeof(char**));</span><br><span class="line">*s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure><p>这样s就有了可用的地址。</p><p>参考： https://blog.csdn.net/liusicheng2008_liu/article/details/80412586</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法构架</title>
      <link href="/2019/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/"/>
      <url>/2019/04/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="基础数据结构">基础数据结构</h2><ul><li>数组/栈/队列<br /></li><li>哈希表：C++的<code>unordered_set</code>与Python的<code>set()/&#123;a&#125;</code>等价的，<code>unordered_map</code>和<code>&#123;&#125;/dict()</code>等价。C++的<code>set</code>和<code>map</code>在Python貌似没有等价的。<br />原地哈希</li><li>字符串</li><li>链表</li><li>堆</li></ul><h2 id="高级数据结构">高级数据结构</h2><ul><li>字典树Trie：</li><li>树状数组BIT：</li><li>线段树：</li><li>单调栈/单调队列：</li><li>B树/B+树/红黑树：</li></ul><h2 id="排序及衍生">排序及衍生</h2><ul><li>4种基础排序：冒泡，选择，插入，希尔</li><li>3种基于比较的：快排，堆排，归并</li><li>3种不基于比较的：计数，基数，桶排</li></ul><h2 id="字符串">字符串</h2><ul><li>滑动窗口</li><li>KMP</li><li>Manacher</li><li>AC自动机</li></ul><h2 id="链表">链表</h2><ul><li>单链表，双链表反转</li><li>链表是否有环，环的入口</li><li>链表相交</li></ul><h2 id="二分">二分</h2><h2 id="贪心">贪心</h2><p>自求多福，策略太多</p><ul><li><a href="https://mp.weixin.qq.com/s/oVtruRMuMbT4N4h8L8itqA">区间问题</a></li></ul><h2 id="树">树</h2><ol type="1"><li>二叉树前序/中序/后序的递归和非递归遍历, 层次遍历, Morris遍历<br /></li><li>序列化和反序列化</li><li>BST问题</li></ol><h2 id="暴力递归和暴搜">暴力递归和暴搜</h2><ul><li>树型暴搜 <a href="https://www.bilibili.com/video/BV1n64y1e7cr?p=13">1:20:00开始</a></li><li>图暴搜</li></ul><h2 id="双指针">双指针</h2><ul><li>快慢指针</li><li>滑动窗口指针</li><li>首尾指针：<br />剑指81：不要求相对位置，首尾指针/快慢指针（快排思想）<br />剑指21：要求相对位置不变，辅助数组/插入/冒泡</li></ul><h2 id="图">图</h2><ul><li>并查集：</li><li>图的表示和转换，建图：</li><li>图的DFS/BFS遍历</li><li>最小生成树：Kruskal和Prim</li><li>最短路径：Dijkstra和堆优化</li><li>拓扑排序：BFS和DFS</li></ul><h2 id="动态规划">动态规划</h2><ul><li>背包问题</li><li>编辑距离</li><li>最长回文子序列/子串</li><li>LCS/LIS</li><li>最大子序和</li><li>股票问题</li></ul><h2 id="数学题">数学题</h2><ul><li>位运算</li><li>计算几何</li><li>其他：lt 169 多数元素：hashmap/排序/摩尔投票</li></ul><h2 id="大数据">大数据</h2><h2 id="技巧">技巧</h2><ul><li>矩阵处理 <a href="https://www.bilibili.com/video/BV1n64y1e7cr?p=10">1:25:00开始</a><br /></li><li>前缀和：原始数组不变，频繁查询区间累加和</li><li>差分数组：频繁对原始数组的区间进行增减</li><li>对拍</li><li>打表找规律<br />数学规律题，输入输出都很简单如<code>int</code></li></ul><h2 id="板子">板子</h2><p><a href="https://github.com/EIMadrigal/LeetCode">我的LC系列题解</a> <a href="https://github.com/EIMadrigal/Recap/tree/main/Templates">我的模板</a><br /><a href="https://zhuanlan.zhihu.com/p/98065331">模板1</a><br /><a href="https://blog.csdn.net/fuxuemingzhu/article/details/101900729">模板2</a><br /><a href="https://greyireland.gitbook.io/algorithm-pattern/">模板3</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 4</title>
      <link href="/2019/04/15/INTERVIEW%204/"/>
      <url>/2019/04/15/INTERVIEW%204/</url>
      
        <content type="html"><![CDATA[<p>120min, 5题。本菜鸡怒跪。</p><ol type="1"><li>变身程序员 <img src="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113449318-2123072016.png" alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(读取时可以按行读取，直到读到空行为止，再对读取过的所有行做转换处理)</span><br><span class="line">输出描述：</span><br><span class="line">如果能将所有的产品经理变成程序员，输出最小的分钟数；</span><br><span class="line">如果不能将所有的产品经理变成程序员，输出-1。</span><br><span class="line">示例1：</span><br><span class="line">输入：</span><br><span class="line">0 2</span><br><span class="line">1 0</span><br><span class="line">输出：</span><br><span class="line">-1</span><br><span class="line">示例2：</span><br><span class="line">输入：</span><br><span class="line">1 2 1</span><br><span class="line">1 1 0</span><br><span class="line">0 1 1</span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">示例3：</span><br><span class="line">输入：1 2</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br><span class="line">输出：</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>此题与<a href="https://leetcode.com/problems/rotting-oranges/">rotting-oranges</a>类似。 基本思想就是将所有的程序员入队，BFS所有的产品经理，最后检查是否还有产品经理存在。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy, <span class="keyword">int</span> t) :<span class="built_in">x</span>(xx), <span class="built_in">y</span>(yy), <span class="built_in">time</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> grid[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*按行读取输入*/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, str))</span><br><span class="line">    &#123;</span><br><span class="line">        col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[row][col++] = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        row++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将所有程序员入队</span></span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(i, j, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    node s;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        s = q.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*四个方向遍历*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> newx = s.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newy = s.y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没有越界并且找到一枚产品经理</span></span><br><span class="line">            <span class="keyword">if</span> (newx &gt;= <span class="number">0</span> &amp;&amp; newx &lt; row &amp;&amp; newy &gt;= <span class="number">0</span> &amp;&amp; newy &lt; col &amp;&amp; grid[newx][newy] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[newx][newy] = <span class="number">2</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(newx, newy, s.time + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li>特征提取 <img src="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113606327-1298909116.png" alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">8</span><br><span class="line">2 1 1 2 2</span><br><span class="line">2 1 1 1 4 2 1 1 2 2</span><br><span class="line">2 2 2 1 4</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">说明：</span><br><span class="line">特征&lt;1，1&gt;在连续的帧中出现3次，相比其他特征连续出现的次数大，所以输出3</span><br><span class="line">备注：</span><br><span class="line">如果没有长度大于2的特征运动，返回1</span><br></pre></td></tr></table></figure><p>可以使用pair存储当前特征，使用map存储当前特征上一次出现的行数以及当前特征连续出现的长度。 <del>还是对C++不熟唉</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, fea_num, res;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;M);</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>=&quot;&quot;&gt; cur;</span><br><span class="line">        <span class="comment">//当前特征上一次出现的行数以及连续出现的长度</span></span><br><span class="line">        map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>=&quot;&quot;&gt;, <span class="keyword">int</span>&gt; lastIndex, length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;fea_num);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; fea_num; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;cur.first, &amp;cur.second);</span><br><span class="line">                <span class="keyword">if</span> (lastIndex[cur] == i)</span><br><span class="line">                &#123;</span><br><span class="line">                    length[cur]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    length[cur] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIndex[cur] = i + <span class="number">1</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(res, length[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>机器人跳跃 <img src="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113621644-2143156756.png" alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">3 4 3 2 4</span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">示例2：</span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">4 4 4</span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">示例3：</span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 6 4</span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">备注：</span><br><span class="line">1 &lt;= N &lt;= 10^5</span><br><span class="line">1 &lt;= H(i) &lt;= 10^5</span><br></pre></td></tr></table></figure><p><del>据说是小学数学，还想了半天。</del> 根据题意可推出：<span class="math inline">\(dp[k + 1] = 2*dp[k] - H[k + 1]\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">H</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;H[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>)</span></span>;  <span class="comment">//dp[k]表示从第k级开始需要的能量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="built_in">ceil</span>((dp[i + <span class="number">1</span>] + H[i + <span class="number">1</span>]) / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>毕业旅行问题 <img src="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190418161743511-1863478998.png" alt="img" /> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">0 2 6 5</span><br><span class="line">2 0 4 4</span><br><span class="line">6 4 0 2</span><br><span class="line">5 4 2 0</span><br><span class="line">输出：</span><br><span class="line">13</span><br></pre></td></tr></table></figure></li></ol><p>典型的TSP问题，据说动态规划能够得到理论最优解，<del>然而本渣看不懂状态转移方程</del>。 贪心算法：从某城市出发，每次在未到达的城市中选择最近的一个，直到遍历完所有城市，最后回到出发地。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1&lt;&lt;30;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m[<span class="number">20</span>][<span class="number">20</span>], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> edge_count = <span class="number">0</span>, flag[<span class="number">20</span>] = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>, next;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (edge_count &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[j] &amp;&amp; m[cur][j] &amp;&amp; m[cur][j] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                next = j;</span><br><span class="line">                min = m[cur][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += m[cur][next];</span><br><span class="line">        flag[next] = <span class="number">1</span>;</span><br><span class="line">        edge_count++;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res += m[cur][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="5" type="1"><li>过河 <img src="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113646291-699967742.png" alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">4</span><br><span class="line">1 1 1 1</span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>每次过河只能2个或3个人，这种过河问题遵循<strong>能者多劳</strong>原则，即花费时间少的人折返去接其他人。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>], dp[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">        dp[<span class="number">2</span>] = a[<span class="number">1</span>], dp[<span class="number">3</span>] = a[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//前i个人过河的最短时间</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>( dp[i - <span class="number">1</span>] + a[<span class="number">0</span>] + a[i - <span class="number">1</span>],dp[i - <span class="number">2</span>] + a[<span class="number">1</span>] + a[i - <span class="number">1</span>] );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </algorithm></cstdio></cstdio></int></int></vector></cmath></cstdio>&lt;/pair&lt;int,&gt;&lt;/int,&gt;</algorithm></map></utility></cstdio></node></queue></string></algorithm></cstdio></iostream></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Simple Math Problems</title>
      <link href="/2019/04/10/Simple%20Math%20Problems/"/>
      <url>/2019/04/10/Simple%20Math%20Problems/</url>
      
        <content type="html"><![CDATA[<h2 id="最大公约数-最小公倍数">最大公约数 &amp; 最小公倍数</h2><p>Euclid's Algorithm：若<span class="math inline">\(b\neq0\)</span>，那么<span class="math inline">\(gcd(a,b)=gcd(b,a\%b)\)</span><br />若<span class="math inline">\(a&lt;b\)</span>，定理会先交换a和b. 0和任意正整数a的gcd是a <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度<span class="math inline">\(O(lgb)\)</span>，因为每次递归问题规模都会缩减一半以上。<br />最小公倍数<span class="math inline">\(lcm=\frac{a*b}{gcd}\)</span></p><ul><li>扩展欧几里得算法</li></ul><p>可以计算出满足下式的三元组<span class="math inline">\((d,x,y)\)</span>： <span class="math display">\[d = GCD(a, b) = ax + by\]</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">extendEuclid</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == b) &#123;</span><br><span class="line">        *x = <span class="number">1</span>, *y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> gcd = extendEuclid(b, a % b, x, y);</span><br><span class="line">    <span class="keyword">int</span> temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp - (*y) * (a / b);</span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 简单证明：<br /><span class="math inline">\(b=0\)</span>是递归基，易得一组解<span class="math inline">\(x=1,y=0\)</span>;<br /><span class="math inline">\(b \neq0\)</span>时：<br />首先递归求解：<br /><span class="math display">\[d&#39;=gcd(b,a\%b)=bx&#39;+(a\%b)y&#39; \ \ \ \ \  \ \ \ \ \ \ \ \ \ (1)\]</span> 我们知道： <span class="math display">\[d=gcd(a,b)=d&#39;=gcd(b,a\%b)\ \ \ \ \ \ \ \ \ \ \ \ \ (2)\]</span> <span class="math display">\[a\%b=a-b*\biggl\lfloor a/b \biggr\rfloor\ \ \ \ \ \ \ \ \ \ \ (3)\]</span> 将(2)(3)式带入(1)： <span class="math display">\[d=bx&#39;+(a-b\biggl\lfloor a/b \biggr\rfloor)y&#39;=ay&#39;+b(x&#39;-\biggl\lfloor a/b \biggr\rfloor y&#39;)\]</span> 所以，令<span class="math inline">\(x=y&#39;\)</span>, <span class="math inline">\(y=x&#39;-\biggl\lfloor a/b \biggr\rfloor y&#39;\)</span>，就可以满足<span class="math inline">\(d=ax+by\)</span></p><h2 id="分数">分数</h2><p>PAT甲1088是比较经典的分数处理问题，求2个分数的和、差、积、商，输出最简形式。<br />表示、化简、运算、输出，代码阐释得很清楚。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line">        ll nume,deno;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.deno &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                a.deno = -a.deno;</span><br><span class="line">                a.nume = -a.nume;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.nume == <span class="number">0</span>) &#123;</span><br><span class="line">                a.deno = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">int</span> d = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(a.nume),<span class="built_in">abs</span>(a.deno));</span><br><span class="line">               a.nume /= d;</span><br><span class="line">               a.deno /= d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">add</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.deno;</span><br><span class="line">        res.nume = a.deno * b.nume + a.nume * b.deno;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">sub</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.deno;</span><br><span class="line">        res.nume = a.nume * b.deno - a.deno * b.nume;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">times</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.deno;</span><br><span class="line">        res.nume = a.nume * b.nume;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">divide</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.nume;</span><br><span class="line">        res.nume = a.nume * b.deno;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFrac</span><span class="params">(Fraction a)</span> </span>&#123;</span><br><span class="line">        a = <span class="built_in">reduction</span>(a);</span><br><span class="line">        <span class="keyword">if</span>(a.nume &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.deno == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a.nume);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(a.nume) &gt; <span class="built_in">abs</span>(a.deno)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld/%lld&quot;</span>,a.nume / a.deno,<span class="built_in">abs</span>(a.nume) % a.deno,a.deno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,a.nume,a.deno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.nume &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Fraction a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld%lld/%lld&quot;</span>,&amp;a.nume,&amp;a.deno,&amp;b.nume,&amp;b.deno);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; + &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(<span class="built_in">add</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; - &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(<span class="built_in">sub</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(<span class="built_in">times</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; / &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(b.nume == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Inf\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">showFrac</span>(<span class="built_in">divide</span>(a,b));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="素数">素数</h2><ul><li>判断素数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="comment">// 1不是素数，也不是合数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> square_root = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= square_root; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>打素数表</li></ul><p>第一种方法是枚举判断, <span class="math inline">\(O(n^{1.5})\)</span>.<br />第二种是Eratosthenes筛法，复杂度<span class="math inline">\(O(nlog\ logn)\)</span>. <img src="https://img-blog.csdnimg.cn/6187ce5f6b95419d907f6e8d094d163f.png" alt="image" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isprime[<span class="number">100005</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">fill</span>(isprime, isprime + <span class="number">100005</span>, <span class="literal">true</span>);</span><br><span class="line">    isprime[<span class="number">0</span>] = <span class="literal">false</span>, isprime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; <span class="number">100005</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; <span class="number">100005</span>; j += i) &#123;</span><br><span class="line">                isprime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100005</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i]) &#123;</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步的优化是欧拉筛，复杂度<span class="math inline">\(O(n)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isprime[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">fill</span>(isprime, isprime + n + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i])</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isprime[p * i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 分解质因子</p><p>每个数都可以分解为质数的乘机. 注意1要特判.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factor</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,cnt; <span class="comment">//x为质因子,cnt为该质因子个数</span></span><br><span class="line">&#125;fac[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;  <span class="comment">//记录不同因子个数</span></span><br><span class="line"><span class="comment">//枚举小于等于sqrt(n)内的所有质因子,判断哪个是n的因子</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;prime[i] &lt;= <span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % prime[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                fac[num].x = prime[i];</span><br><span class="line">                fac[num].cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(n % prime[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        fac[num].cnt++;</span><br><span class="line">                        n /= primep[i];</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果n仍然大于1,说明n有一个大于sqrt(n)的质因子</span></span><br><span class="line"><span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        fac[num].x = n;</span><br><span class="line">        fac[num++].cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/100051075">素数筛</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mobile Communication</title>
      <link href="/2019/04/03/Mobile%20Communication/"/>
      <url>/2019/04/03/Mobile%20Communication/</url>
      
        <content type="html"><![CDATA[<p>最近面试有被问到LTE，感觉说得不太清楚，重新整理一遍。</p><h2 id="第一代移动通信系统">第一代移动通信系统</h2><p>1G，诞生于1980年左右。<strong>模拟通信系统</strong>，抗干扰性能差，使用FDMA技术，主要用来传输<strong>话音</strong>信号，最拉风的就是“大哥大”。<br />采用蜂窝组网，又叫小区制移动通信。将网络服务区划分为许多cell，每个cell设置一个基站，移动站的发送和接收都要通过基站进行。<br />1G的制式有很多种：瑞士、荷兰、俄罗斯等使用的NMT，美国、澳大利亚使用的AMPS，英国使用的TACS等。</p><h2 id="第二代移动通信系统">第二代移动通信系统</h2><p>2G是<strong>数字通信系统</strong>，因此抗干扰能力大大增强。同时引入了CDMA和TDMA技术，提供了<strong>低速数字通信</strong>（短信）服务。<br />2G的制式主要是欧洲的GSM(Global System for Mobile Communication)。<br />不久，2G就演变为了支持<strong>数据服务</strong>的2.5G（能上网）。2.5G包括了GPRS(General Packet Radio Service)和EDGE(Enhanced Data rate for GSM Evolution)。</p><h2 id="第三代移动通信系统">第三代移动通信系统</h2><p>3G主要采用了CDMA技术，使用混合的交换机制（电路交换、分组交换），可以提供丰富的多媒体服务（话音、数据、视频等）。<br />3G的标准主要有三种：欧洲的WCDMA（中国联通采用）、美国的CDMA2000（中国电信使用）、中国的TD-SCDMA（中国移动使用）。<br />制定标准的过程也是利益冲突与妥协的过程，欧洲这边成立了3GPP组织，美国主导了3GPP2组织，中国当然是加入了3GPP。</p><h2 id="第四代移动通信系统">第四代移动通信系统</h2><p>国际电信联盟（ITU）提出了4G的需求，4G的大名是IMT-Advanced(International Mobile Telecommunications-Advanced)。<br />4G标准的制定者，一个是3GPP，一个是IEEE。<br />3GPP提出了LTE(Long-Term Evolution)和LTE-Advanced，IEEE提出了WirelessMAN-Advanced。<br />LTE是3G和4G之间的过渡技术，也被称为3.9G。由于高通放弃了3GPP2转而投向LTE的怀抱，所以LTE应用得很广泛。</p><p>LTE相比于2G/3G频率变高、频段变宽，根据香农定理，提高频谱带宽或者信噪比可以提高信道容量，但是无线通信中要提升信噪比是比较困难的。高频段频谱资源丰富，相对低频段来说比较纯净，干扰较小，可分配的带宽比较大，同频段的连续频谱进行载波聚合也比较容易。</p><p>缺点的话：高频段路径损耗大、绕射能力差，因此覆盖距离和覆盖深度都不如低频段，当然频段过低可能造成越区覆盖，进而信噪比恶化，切换失败导致掉话。因此需要频段适中来组网。</p><p>EPC(Evolved Packet Core)：<a href="https://www.zhihu.com/question/22365275/answer/21805286">演进的分组核心网</a>是4G的核心网，</p><p>PTN(Packet Transport Network)：3G/4G的分组传送网，用于传输IP包和以太网帧，</p><p>数据通信网络：</p><h2 id="部分部门内网禁止访问互联网">部分部门内网禁止访问互联网</h2><p><img src="https://img-blog.csdnimg.cn/b40f033d64a74b91bb7c24677814398a.png" alt="网络拓扑结构" /> 假设一台PC机为普通部门，可以接入外网；另一台PC机为涉密部门，不能接入外网。两台PC机与三层交换机连接，三层交换机与路由器1连接，路由器通过PTN传输与能连接公网的路由器2连接。<br />可接入外网的PC机在三层交换机当中有路由表，可以通过PTN传输与公网连接，禁止接入外网的PC机无法查到路由表，不能与公网连接。<br />配置三层交换机与两个路由器。路由器通过PTN传输与另一台能访问公网的路由器相连接。</p><p>同一部门位于相同的子网段设置为同一VLAN互通，不同的部门位于不同的网段通过三层交换机的路由功能，实现不同VLAN间互通。</p><p>在配置三层交换机与路由器R1的OSPF协议时，私密部门的网段不加入路由协议中。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Information Engineering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 3</title>
      <link href="/2019/04/01/INTERVIEW%203/"/>
      <url>/2019/04/01/INTERVIEW%203/</url>
      
        <content type="html"><![CDATA[<p><em>菊厂的面试本来没打算记录，因为当时投的是非技术岗（技术支持）。为了全面，就寥做记录。</em> <em>菊厂的面试因为有口头保密协议，所以不能透露具体题目。</em></p><h1 id="群面">0 群面</h1><p>简历通过筛选后，会有短信通知去面试。 非技术岗第一轮是所谓“集体面试”，持续1.5h，菊厂两种形式：小组讨论（6人及以下）、小组辩论（12人分2组，6人/组）。 小组讨论一般是3位面试官会给一个问题，要求讨论之后给出一个解决方案； 小组辩论在分好组之后，会有一个简短的自我介绍环节； 接着拿到辩题，会有15~20Min左右的组内讨论时间； 讨论完毕后，每组需要选一个发言人阐述本方论点（建议口才不是很好的同学不要抢这个发言人）； 再下来就是针对对方的论点论据进行辩论（这时候一定要积极举手回答）； 最后会让每个人选一个要淘汰的本组同学并阐明理由，之后面试官进行总结。 群面结束后，没有通过的人就可以回家了。 我其实比较讨厌辩论，感觉就是两组人围绕着两个极端去互相反驳对方，可是明明很多时候是完全可以trade-off的，并不是非此即彼。</p><h1 id="半技术面">1 半技术面</h1><p>之所以叫做半技术面，是因为菊厂非技术岗的二面有点XX。据说会根据你的专业背景提问，如果不太对口就不会提问技术问题。 很不幸，我的面试官原来也是学通信的。简单聊了下简历上的项目之后，就开始疯狂追问网络问题，我可能没太get到他的point，交流不太顺畅，这一面表现不太好。 不过不知道是不是因为长太帅了（捂脸~），这一面竟然给过了。</p><h1 id="高管面">2 高管面</h1><p>通过二面后，会把你请到一个逼格有点高的地方，等着被高管临幸。 这种聊的就比较随意了，侃天侃地侃人生。 你的人生有嘛规划啊，你遇到最大的挫折是嘛啊，怎么克服的啊，你了解华为公司嘛...... 如果要把你派到非洲，愿不愿意啊，三年你愿意，十年你愿意么？ 总之，华为的文化就是你要绝对服从公司的安排，不怕吃苦，不怕牺牲，为公司倾情奉献。。。 最后你有什么问题的话，可以问他。</p><h1 id="英语测试">3 英语测试</h1><p>如果通过前三轮面试，最后有一个英语测试。 这个不知道什么标准，反正差不多三部分：1、单选题；2、朗读句子？（记不清了）；3、给2个topic，说一段话。 我这感人的口语水平，第三部分噼里啪啦自己都不知道说的啥。。。 全部完成后，就可以回去等消息了。 P.s. 即使四轮面试全部通过，也不意味着就能拿到offer。熟悉菊厂的同学都知道有个资源池，过面试后先进池子里泡着，公司会根据HC和前一批的违约情况从池子里分批捞人，建议不要一棵树上吊死。 <em>其它菊厂面经 ：https://zhuanlan.zhihu.com/p/24427674</em></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 2</title>
      <link href="/2019/03/28/INTERVIEW%202/"/>
      <url>/2019/03/28/INTERVIEW%202/</url>
      
        <content type="html"><![CDATA[<p>吐槽下ZZ的面试安排：面试时间12：30不说了，周围没有饭店，中午就没吃饭。。。不像其他公司给每个人安排不同的面试时间，这样可以节约大家的时间，SPDB是把一大批人都安排在了12：30，而且面试是5个面试官对一个人，生生地把可以并行的工作给整废了，大部分时间都浪费在了无意义的等待上。</p><h2 id="机试">机试</h2><p>50min三道题，考察地很基础，基本之前都练过。利用的是<a href="http://hustoj.com/oj/">华科的OJ</a>，IDE有Dev-C++、Eclipse、PyCharm，Dev-C++没太用过，所以调试得很慢很慢。。。</p><ol type="1"><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2051">十进制转二进制</a> “除基取余，逆序排列”。每次将要转换的数除以基数Q，将余数作为<strong>低位</strong>存储直到商为0，将所有位由高到低输出即可。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, num[<span class="number">40</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            num[len++] = n % <span class="number">2</span>;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>之所以用do...while循环，是因为如果输入为0，用while会直接跳出循环，结果出错。 2. 求出200以内所有3的倍数的数字和 没啥好说的。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(i % <span class="number">3</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 3. <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805415005503488">质因子分解</a> 这题寒假练过，不过机考时候忘了，素数表打的好像有问题。。。幸亏测试数据弱，就手工写了一个数组存了前面20个素数，结果AC了。。。</p><ul><li>如果一个正整数n是一个合数，那么它的因子必然是在<span class="math inline">\(\sqrt n\)</span>左右两侧成对出现；</li><li>推广到质因子，如果n存在[2,n]内的质因子，那么这些质因子要么全部小于等于<span class="math inline">\(\sqrt n\)</span>，要么只有一个大于<span class="math inline">\(\sqrt n\)</span>，其余都小于等于<span class="math inline">\(\sqrt n\)</span>。</li></ul><p>所以算法是： 1）枚举1~<span class="math inline">\(\sqrt n\)</span>内的所有质因子，判断其是否是n的因子； 2）如果1）结束后<span class="math inline">\(n\geq 1\)</span>，那么其必然有且仅有一个大于<span class="math inline">\(\sqrt n\)</span>的质因子，记录该因子； 3）输入是1要特判。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是int范围，数组开10足够了，</span></span><br><span class="line"><span class="comment">//因为2*3*5*7*11*13*17*19*23*29就超过int了，所以我手工写一个数组也足够了。。。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fac</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> cnt;  <span class="comment">//质因子x的个数</span></span><br><span class="line">&#125;fac[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == a)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sqr = <span class="built_in">sqrt</span>(<span class="number">1.0</span>*a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sqr; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(a % i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[maxn], num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//打素数表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primeTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            prime[num++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">primeTable</span>();  <span class="comment">//记得写，我好像没写这句。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">int</span> diffFacNum = <span class="number">0</span>;  <span class="comment">//n的不同质因子个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld=&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == n)  <span class="comment">//特判1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sqr = <span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举2~sqrt(n)的质因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; prime[i] &lt;= sqr; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % prime[i] == <span class="number">0</span>)  <span class="comment">//如果该质因子是n的因子</span></span><br><span class="line">            &#123;</span><br><span class="line">                fac[diffFacNum].x = prime[i];</span><br><span class="line">                fac[diffFacNum].cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//计算该质因子的个数</span></span><br><span class="line">                <span class="keyword">while</span> (n % prime[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fac[diffFacNum].cnt++;</span><br><span class="line">                    n /= prime[i];</span><br><span class="line">                &#125;</span><br><span class="line">                diffFacNum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必有一个大于sqrt(n)的质因子</span></span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fac[diffFacNum].x = n;</span><br><span class="line">            fac[diffFacNum++].cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diffFacNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, fac[i].x);</span><br><span class="line">            <span class="keyword">if</span> (fac[i].cnt &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;^%d&quot;</span>, fac[i].cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="面试">面试</h2><p>面试期间也被问到了一道题： 大致意思就是有一个正整数n，找出一个比n大且每位数字之和=n的每位数字之和的最小数，比如输入050，那么输出104。 我开始的思路是从n开始向上枚举，直到找到满足要求的数； 其实更优的解法是：对于在050~099之间的数根本不用考虑，因为必然不满足每位数字之和=n的每位数字之和，这样可以提高效率。</p><h2 id="其它">其它</h2><p>1、语言：Java多态、C的数据类型； 2、数据结构：链表是否有环（烂大街了）； 3、操作系统：进程状态及转换、进程线程区别。 </cmath></cstdio></cstdio></cstdio></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bias-Variance Analysis</title>
      <link href="/2019/03/25/Bias-Variance%20Analysis/"/>
      <url>/2019/03/25/Bias-Variance%20Analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>对于机器学习模型<span class="math inline">\(g\)</span>的泛化性能的分析不仅可以通过实验的方式进行评估，还可以从理论上进行分析，这也是learning theory研究的一部分。</p><h2 id="推导">推导</h2><p>首先假设无噪，定义在训练集<span class="math inline">\(D\)</span>上学习到的模型<span class="math inline">\(g^{(D)}\)</span>的期望泛化误差为： <span class="math display">\[E_{out}(g^{(D)})=E_x[(g^{(D)}(x)-f(x))^2]\]</span> 先使用小学数学做点预备： <span class="math display">\[E_D[g^{(D)}(x)]=\bar g(x)\\E_D[g^{(D)}(x)^2]-\bar g(x)^2=E_D[(g^{(D)}(x)-\bar g(x))^2]=var(x)\\\bar g(x)^2-2E_D[g^{(D)}(x)]f(x)+f(x)^2=(\bar g(x)-f(x))^2=bias(x)^2\]</span> 不同的方式会生成不同的训练集<span class="math inline">\(D\)</span>，因此<span class="math inline">\(g\)</span>的总的期望泛化误差为： <span class="math display">\[E_D[E_{out}(g^{(D)})]=E_D[E_x[(g^{(D)}(x)-f(x))^2]]=E_x[E_D[(g^{(D)}(x)-f(x))^2]]\\=E_x[E_D[g^{(D)}(x)^2]-2E_D[g^{(D)}(x)]f(x)+f(x)^2]\\=E_x[E_D[g^{(D)}(x)^2]-\bar g(x)^2+\bar g(x)^2-2E_D[g^{(D)}(x)]f(x)+f(x)^2]\\=E_x[var(x)+bias(x)^2]=E_x[var(x)]+E_x[bias(x)^2]=var+bias^2\]</span></p><p>如果数据有噪，还是用MSE推一个漂亮的分解，其他的损失函数可能没有这么好搞：<br />以下推导针对单条测试样例<span class="math inline">\((x,y)\)</span>，其中<span class="math inline">\(y=f(x)+\epsilon,E_D(\epsilon)=0,V_D(\epsilon)=\sigma^2\)</span>，噪声只需要均值为0即可，甚至都不需要是高斯分布。 <span class="math display">\[E_D[(g^{(D)}(x)-y)^2]=E_D[(f(x)+\epsilon-g^{(D)}(x))^2]\\=E_D[\epsilon^2]+E_D[(g^{(D)}(x)-f(x))^2]+E_D[2\epsilon(g^{(D)}(x)-f(x))]\\=V_D[\epsilon]+E_D[\epsilon]^2+E_D[(g^{(D)}(x)-f(x))^2]+E_D[\epsilon]E_D[2(g^{(D)}(x)-f(x)]\\=\sigma^2+E_D[(g^{(D)}(x)-f(x))^2]\\=\sigma^2+E_D[g^{(D)}(x)-f(x)]^2+V_D[g^{(D)}(x)-f(x)]\\=\sigma^2+(f(x)-E_D[g^{(D)}(x)])^2+V_D[g^{(D)}(x)]\\=\sigma^2+(\bar g(x)-f(x))^2+var(x)=\sigma^2+bias(x)^2+var(x)\]</span> 其中测试样例噪声<span class="math inline">\(\epsilon\)</span>与<span class="math inline">\(f(x),g^{(D)}(x)\)</span>均独立，因此拆为乘积。</p><p>可以看到：bias表达的是所有可能的训练数据集训练出的所有模型的平均值与真实值的差异，variance表达的是同等规模的不同的训练数据集学习到的模型之间的差异。<br />当训练数据无穷多时，数据扰动对模型的泛化性能没有影响，variance就为0，此时复杂模型的bias通常更低，泛化能力也就更强。<br />训练数据较少时，复杂模型的variance很大，此时即使训练误差很低，泛化误差也会很高，即所谓的过拟合。</p><h2 id="refs">Refs</h2><p><a href="https://nbviewer.org/github/tournami/Learning-From-Data-MOOC/blob/master/Homework%204.html">Bias and Variance</a><br /><a href="https://engineering.purdue.edu/ChanGroup/ECE595/files/chapter4.pdf">Learning Theory</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java FAQ</title>
      <link href="/2019/03/21/Java%20FAQ/"/>
      <url>/2019/03/21/Java%20FAQ/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>Jar包本来在project structure中，按绿色按钮也可以执行，但从命令行就会报错：找不到对应的包。<br />Idea为了从命令行编译程序，必须将jar包的路径添加到系统变量classpath中，再在idea中project structure中添加该jar，重启计算机。</li></ol><h2 id="多线程">多线程</h2><p>Java有2种方式实现多线程：</p><p>继承<code>Thread</code>类</p><p>单线程程序即只有主方法的线程，该线程由JVM负责启动，其他线程由程序员负责启动。<code>Thread</code>类中实例化的对象代表一个线程，继承后重写<code>run()</code>方法，将该线程的功能实现放在<code>run()</code>方法中，调用<code>Thread</code>类中的<code>start()</code>方法启动线程，<code>start()</code>方法会调用覆盖后的<code>run()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>Runnable</code>接口</p><p>第一种方法的缺陷在于：如果程序需要继承其他类而非<code>Thread</code>类，但Java是单继承语言，此时就无法通过该方式实现多线程，此时就需要采用第二种方法。创建<code>Runnable</code>对象后，将其传递给<code>Thread</code>类的构造方法，调用<code>start()</code>方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较疑惑的地方在于：Java中接口和抽象类是不能实例化的，即<code>Runnable</code>接口是不能实例化的，但是代码中却<code>new Runnable()</code>。这里实际上首先构造了一个<code>implements Runnable</code>的匿名内部类，然后构造了该类的一个实例，接着用<code>Runnable</code>表示该类的类型。</p><p>不使用匿名内部类： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test hello = new Test();</span><br><span class="line">        Thread thread = new Thread(hello);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式</title>
      <link href="/2019/03/11/6824/"/>
      <url>/2019/03/11/6824/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="abf36269f07fd4565b7c0996070855a01666bb9134bd1cc32bba4fc9c2610292">418fac4f173397084caccc18ab9f089e90c7a29408af94da76702e54e165326bd836cbd2a724db6e192604b7c11ba5310b388d49b38ae00607fc677c7015fb1bfb9f5a7e46dfb88124dfa00f2714ef14</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-Nearest Neighbors</title>
      <link href="/2019/03/07/K-Nearest%20Neighbors/"/>
      <url>/2019/03/07/K-Nearest%20Neighbors/</url>
      
        <content type="html"><![CDATA[<p>k-NN可以做分类及回归，对新的测试实例t，在训练集中找与t<strong>最近</strong>的k个实例，用投票法决定t属于哪个类，显然这是一种懒惰学习。</p><p>既然要找最近的k个，就会涉及距离度量问题，下面以2个样本点（每个点有n个维度）间的距离为例枚举一些度量方式：</p><ol type="1"><li>Minkowski距离：<span class="math inline">\(\sqrt[p]{\sum_{i=1}^{n}|x_{1i}-x_{2i}|^p}\)</span>，p=1时是曼哈顿距离，p=2时是欧氏距离，<span class="math inline">\(p\to\infty\)</span>时是切比雪夫距离<span class="math inline">\(max_{i}|x_{1i}-x_{2i}|\)</span></li><li>标准欧式距离：为了克服欧氏距离各个维度数据粒度不一致对最终结果的影响，将每个维度标准化后采用欧氏距离的计算方法：<span class="math inline">\(y_{1i}=\cfrac{x_{1i}-u_i}{s_i}\)</span>，<span class="math inline">\(\sqrt{\sum_{i=1}^{n}(y_{1i}-y_{2i})^2}=\sqrt{\sum_{i=1}^{n}\cfrac{(x_{1i}-x_{2i})^2}{s_i^2}}\)</span></li><li>Mahalanobis Distance：修正了各维度之间的相关性及粒度不一致性<br />样本向量<span class="math inline">\(x\)</span>到均值向量<span class="math inline">\(u\)</span>之间的马氏距离：<br /><img src="https://img-blog.csdnimg.cn/20210201184937356.png" alt="在这里插入图片描述" /><br />样本向量<span class="math inline">\(x\)</span>到样本向量<span class="math inline">\(y\)</span>之间的马氏距离：<br /><img src="https://img-blog.csdnimg.cn/20210201185035296.png" alt="在这里插入图片描述" /><br />如果协方差矩阵是单位阵，即每个维度之间没有相关关系，即欧氏距离；如果协方差矩阵是对角阵，即标准欧氏距离</li><li>Bhattacharyya Distance：衡量概率分布的相似性， <span class="math inline">\(D_B(p,q)=-ln(BC(p,q)),BC(p,q)=\sum\sqrt{p(x)q(x)},BC(p,q)=\int\sqrt{p(x)q(x)}dx\)</span></li><li>余弦相似性</li><li>Jaccard Similarity Coefficient：衡量集合相似性：<span class="math inline">\(J(A,B)=\cfrac{|A\cap B|}{|A\cup B|}\)</span><br />Jaccard Distance：集合区分度：<span class="math inline">\(1-J(A,B)\)</span><br />假设有4个二值维度，样例A={0111}，B={1011}，则<span class="math inline">\(J=\frac{M_{11}}{M_{01}+M_{10}+M_{11}},J^{&#39;}=1-J\)</span>，<span class="math inline">\(M_{11}\)</span>表示A和B中均为1的维度个数</li><li>Pearson Correlation Coefficient：<br />总体Pearson系数：<span class="math inline">\(\rho=\frac{Cov(X,Y)}{\sqrt{DXDY}}\)</span><br />相关距离：<span class="math inline">\(1-\rho\)</span><br />样本Pearson系数：<span class="math inline">\(r=\frac{\sum(X_i-\bar X)(Y_i-\bar Y)}{\sqrt{\sum(X_i-\bar X)^2\sum(Y_i-\bar Y)^2}}=\frac{1}{n-1}\sum(\frac{X_i-\bar X}{S_x})(\frac{Y_i-\bar Y}{S_y})\)</span></li></ol><p>除了距离度量，还有k的选择：k太小容易过拟合，k太大会使得与测试实例较远的训练样例也会起作用。</p><p>kNN的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearestNeighbor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">self, X, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; X is N*D &quot;&quot;&quot;</span></span><br><span class="line">        self.Xtr = X</span><br><span class="line">        self.ytr = y</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; X is N*D &quot;&quot;&quot;</span></span><br><span class="line">        num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># make sure output type matches input type</span></span><br><span class="line">        Ypred = np.zeros(num_test, dtype = self.ytr.dtype)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_test):</span><br><span class="line">            distances = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(self.Xtr - X[i,:]), axis = <span class="number">1</span>)</span><br><span class="line">            min_index = np.argmin(distances)</span><br><span class="line">            Ypred[i] = self.ytr[min_index]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> Ypred</span><br></pre></td></tr></table></figure><p>为了加快预测速度，可以使用k-d tree来存储训练集，本质上也是一种平衡二叉树：<br />建树的过程可以递归进行：</p><ul><li>确定划分域：对训练集，统计每个维度的方差，选择方差最大的属性，意味着沿着该维度数据比较分散，容易获得较高的分辨率</li><li>确定结点：将数据集按照划分域排序，正中间的点选为结点</li><li>确定左(值小于父亲)右（值大于父亲）孩子</li><li>设置左右孩子的parent域</li></ul><p>往往训练样例的维度是很高的，所以很难每个维度都去分割，所以sklearn中的kNN如果用k-d tree实现，会有一个参数<code>leaf_size</code>控制树的深度。<br />建好后，就可以快速查找测试样例的邻居。</p><p>假设训练集为<span class="math inline">\(X_{m\times k}\)</span>，测试集为<span class="math inline">\(Y_{n\times k}\)</span>，此时需要计算训练集中每条样本与测试集中每条样本的距离，为了加速矩阵运算，不能使用循环，最终结果为<span class="math inline">\(R_{m\times n}=X\circ X+Y\circ Y-2XY^T\)</span>，具体推导可以参考<a href="https://zhuanlan.zhihu.com/p/146076139">NumPy之计算两个矩阵的成对平方欧氏距离</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 1</title>
      <link href="/2019/03/06/INTERVIEW%201/"/>
      <url>/2019/03/06/INTERVIEW%201/</url>
      
        <content type="html"><![CDATA[<h2 id="数据对齐存储">数据对齐存储</h2><p>在32位系统中：int占4Bytes，short占2Bytes，char占1Byte，加起来应该是7Bytes，但是下面这段代码输出却是8。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">short</span> y;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>计算机对于基本类型数据在内存中的存/储位置有些限制，即<strong>内存对齐</strong>。 处理器取数据一般不按照单个字节，而是双字节、四字节等进行，假设这种存取粒度为4Bytes，也就是说处理器只能从首地址为4的倍数的地址读取数据。如果没有对齐存储，取数据会很麻烦，可能需要两次读取并且剔除掉无用的字节。 每个编译器都有默认的对齐模数，那么<strong>有效对齐值=min{对齐模数，结构体中最长数据类型长度}。</strong> <strong>规则1：第一个成员offset为0，其后成员的offset=min{有效对齐值，该类型字节数}；</strong> <strong>规则2：结构体总大小必须为有效对齐值的整数倍，否则编译器会自动填充。</strong> 再看前面的例子，int占0<sub>3，short占4</sub>5，char占6，总长度为7，不是4的整数倍，所以地址7是填充字节，共8Bytes。</p><h2 id="栈-堆不是数据结构中的栈和堆">栈 &amp; 堆（不是数据结构中的栈和堆）</h2><ol type="1"><li>内存栈区 编译器自动进行分配和释放，存放局部变量、函数的参数等。 Windows下栈向低地址扩展，大小只有几MB，如果开一个很大的局部数组，就会提示stack overflow。</li><li>内存堆区 malloc或者new返回的内存区域，使用完需要用户free或delete，否则容易内存泄漏。如果程序员不释放，那么结束时由操作系统回收。 堆向高地址扩展，由于系统采用空闲链表存储空闲内存，所以是不连续的。系统在收到内存申请的请求后，会由低地址向高地址遍历空闲链表，找到第一个满足的空闲块，删除该结点，并将该块的首地址返回。如果分配的空间大于申请的，会将剩余部分重新链接回空闲链表。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Heap中开辟10Bytes，同时在Stack中压入p，p的值为10Bytes的首地址</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></li><li>常数区 存放字符串常量等，程序结束由系统回收。</li><li>静态区 存放全局变量或者静态变量，初始化的和没有初始化的分别存放在不同的区域，程序结束后由系统释放。</li><li>代码区 存放程序代码。 ## 其它 排序复杂度、人工智能概念、模型的建立等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ FAQ</title>
      <link href="/2019/03/04/C%20&amp;%20C++%20FAQ/"/>
      <url>/2019/03/04/C%20&amp;%20C++%20FAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="指针和引用">指针和引用</h2><ol type="1"><li>指针是一个新的变量，存储另一个变量的地址，可以通过指针修改另一个变量；引用是一个别名，对引用的操作就是对变量本身的操作。</li><li>指针可以有多级；引用只有一级。</li><li>指针的大小一般4B；引用的大小一般取决于被引用对象大小。</li><li>指针可以为空；引用不能为空。</li><li>传参选择：返回被调函数局部变量的内存时传指针，使用后及时释放避免内存泄漏；返回局部变量的引用没有意义，会自动销毁。传指针需要单独开辟内存；在对栈空间大小敏感时（如递归）传引用，无需创建临时变量，开销更小。类对象作为参数时传引用是C++传递类对象的标准方式。</li></ol><h2 id="空类">空类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sizeof(A) = 1</span></span><br></pre></td></tr></table></figure><p>空类的大小之所以为1，因为标准规定完整对象的大小&gt;0，否则两个不同对象可能拥有相同的地址，故编译器会生成1B占位符。 那么两个对象为什么不能地址相同呢？</p><blockquote><p>There would be no way to distinguish between these two objects when referencing them with pointers.</p></blockquote><p>空类中到底都有什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>();  <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp;);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>();  <span class="comment">// 析构函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;);  <span class="comment">// 赋值运算符</span></span><br><span class="line">    A* <span class="keyword">operator</span>&amp;();  <span class="comment">// 取址运算符（非const）</span></span><br><span class="line">    <span class="keyword">const</span> A* <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;  <span class="comment">// 取址运算符（const）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>仅仅声明一个类，不会创建这些函数。只有当定义类的对象时，才会产生。</p><h2 id="多态polymorphism">多态Polymorphism</h2><p>OOP的特点包括封装、继承和多态。</p><p>封装的目的是将类的<strong>实现</strong>和<strong>使用</strong>分离，隐藏实现细节，保留部分接口和方法供外人使用，避免程序互相依赖，使得模块松耦合。<br />继承是为了复用基类中的属性和方法，实现了代码的可重用性。<br />多态按照字面意思：同一接口的多种不同的实现方式，同种操作作用于不同的对象可以产生不同的行为和执行结果。可以有效避免代码冗余重复，重复是万恶之源！！</p><p>根据状态确定时间分为静态多态和动态多态，静态多态在编译时就确定了，动态多态运行时确定。</p><p>静态多态主要包括函数重载和运算符重载，动态多态主要通过继承和虚函数实现。定义虚函数<code>f</code>，是为了用基类的引用或指针调用派生类的<code>f</code>，最终调用哪个<code>f</code>取决于对象的实际类型（基类还是派生类），即在运行时选择函数的版本，也就是所谓的动态绑定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;animal&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal* animal = <span class="keyword">new</span> Dog;</span><br><span class="line">animal-&gt;<span class="built_in">f</span>();  <span class="comment">// 输出animal  </span></span><br></pre></td></tr></table></figure><p>将函数<code>f</code>改为虚函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;animal&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal* animal = <span class="keyword">new</span> Dog;</span><br><span class="line">animal-&gt;<span class="built_in">f</span>();  <span class="comment">// 输出dog </span></span><br></pre></td></tr></table></figure></p><p>当基类指针指向派生类对象，用该指针调用同名成员函数时，基类声明为虚函数（子类可以不写<code>virtual</code>）就会调用派生类的<code>f</code>，否则调用基类的<code>f</code>。</p><p>如果没有虚函数，管理大量的派生类对象<code>Dog/Cat</code>等就需要声明相应的指针，有虚函数的话，就可以声明为指针数组<code>Animal* animals[5]</code>指向相应的派生类对象，然后直接<code>animals[i]-&gt;f()</code>即可。</p><p>析构函数可以并且应当是虚函数，因为要确保执行相应对象的析构函数。如果基类指针指向派生类对象，会调用派生类的析构函数并释放资源，然后调用基类的析构函数。当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。否则<code>delete animal</code>时调用<code>Animal</code>的析构函数，<code>Dog</code>的资源未释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造时，先调用父类构造函数，再调用子类构造函数</span></span><br><span class="line"><span class="comment"> * 析构时，先调用子类析构函数，再调用父类析构函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 子类构造函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 调用父类构造函数</span></span><br><span class="line"><span class="comment"> *  2. 把CDerived的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  3. 初始化CDerived的成员变量</span></span><br><span class="line"><span class="comment"> *  4. 调用函数Init()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 父类构造函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 把CBase的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  2. 初始化CBase的成员变量</span></span><br><span class="line"><span class="comment"> *  3. 调用函数Init()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 子类析构函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 把CDerived的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  2. 调用函数Uninit()</span></span><br><span class="line"><span class="comment"> *  3. 调用父类CBase的析构函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 父类析构函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 把CBase的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  2. 调用函数Uninit()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造函数或析构函数中调用虚函数与普通函数调用方式一样，相当于调用CBase::Init()</span></span><br><span class="line"><span class="comment"> * 由于编译器对构造函数和析构函数做了特殊处理，因此不会多态</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 虚函数调用过程：</span></span><br><span class="line"><span class="comment"> *  1. 获取this指针的地址</span></span><br><span class="line"><span class="comment"> *  2. 通过this指针得到虚函数表地址，通常this指针指向vptr</span></span><br><span class="line"><span class="comment"> *  3. 虚函数表地址加上函数在表内偏移量得到函数地址</span></span><br><span class="line"><span class="comment"> *  4. 通过call命令调用函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 调用父类还是子类的函数，关键在于vptr指向父类还是子类的虚函数表</span></span><br><span class="line"><span class="comment"> * 构造函数和析构函数中，vptr均设置为指向当前类的虚函数表，因此均调用当前类的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;  <span class="comment">// 重写f</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();  <span class="comment">// 调用派生类的f()</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类指针<code>p</code>调用虚函数<code>f</code>，<code>f</code>作用的可能是基类对象，也可能是派生类对象，这就是多态（同样消息作用于不同类型对象产生不同的行为）的一种方式，即动态多态。 正因为编译器无法确定使用哪个虚函数，所以所有的<strong>虚函数必须定义</strong>，否则编译器会报错。</p><p>构造函数不能是虚函数，因为构造对象时必须明确知道其类型。如果是虚函数，调用时只需要提供接口，编译器无法知道你想构造继承树的哪个类型。</p><p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，<strong>由于对象还未创建成功，编译器无法知道对象的实际类型</strong>，是类本身还是类的派生类等等</p><p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p><p>C++他爹Bjarne Stroustrup是这么说的：</p><blockquote><p>A virtual call is a mechanism to get work done given partial information. In particular, "virtual" allows us to call a function knowing only an interfaces and not the exact type of the object. To create an object you need complete information. In particular, you need to know the exact type of what you want to create. Consequently, a "call to a constructor" cannot be virtual.</p></blockquote><p>构造函数或者析构函数中调用虚函数会怎样</p><p>在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。</p><p>在析构函数中调用虚函数，此时调用的是子类的函数实现方式。</p><p>一个类的所有实例共享同一张虚表：<br />编译器处理虚函数的方法是：<br />如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。<br />为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。 <img src="https://img-blog.csdnimg.cn/20200229202936650.png" alt="在这里插入图片描述" /></p><p>与虚函数必须定义相反，纯虚函数无须定义（要定义必须在类的外部），含有纯虚函数的类是<strong>抽象基类</strong>。 抽象基类定义好接口，继承该类的其他类可以覆盖这个接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 声明纯虚函数</span></span><br></pre></td></tr></table></figure><p>之所以要引入纯虚函数，是因为很多时候基类产生对象是没有意义的。比如动物类可以派生出狗、猪等子类，但动物类生成对象毫无意义。 因此，不能创建抽象基类的对象，派生类必须覆盖(override)以定义自己的<code>f</code>，否则派生类仍然是抽象基类。</p><p>优点是没有函数调用开销，加快运行；缺点是增大代码体积，容易出现page fault从而拖慢性能。 <a href="https://algorithmlixuan.github.io/2018/10/11/c++lession4/">内联函数</a> <a href="https://zhuanlan.zhihu.com/p/48066839">map与unordered_map</a> <a href="https://www.cnblogs.com/linuxAndMcu/p/14621819.html">迭代器失效</a> <a href="https://www.zhihu.com/question/21455159">函数重载按照返回类型</a> <a href="https://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html">C++函数重载</a> 用基类的指针（引用）调用虚函数时就发生动态绑定：运行时，虚函数根据绑定对象的实际类型，选择调用函数的版本。 <a href="https://www.nowcoder.com/questionTerminal/8262288d505d4fc599ebd9c8e7fd86ce">虚函数sizeof</a> <a href="https://zhuanlan.zhihu.com/p/110159656">const</a></p><h2 id="重载-覆盖-重写">重载 &amp; 覆盖 &amp; 重写</h2><ul><li>重载(overload)：在类内部发生。函数名相同，参数个数、参数类型、参数顺序至少有一种不同。返回值类型可以相同，也可不同；</li><li>覆盖(override)：覆盖基类的虚函数。函数名相同，参数相同，基类函数必须是虚函数；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span>B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;  <span class="comment">// 正确：f1与基类中的f1匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：B没有形如f2(int)的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：f3不是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：B没有名为f4的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>重写(overwrite)：派生类的函数屏蔽了同名的基类函数： 派生类函数与基类函数同名，参数不同。不论基类函数是否为虚函数，都会被隐藏； 派生类函数与基类函数同名，参数相同。基类函数不为虚函数，会被隐藏；</li></ul><h2 id="static">static</h2><p>C++中<code>static</code>关键字用来<strong>声明类的成员</strong>：</p><ul><li>类的静态成员变量或函数属于类而非对象，只有一份副本；</li><li>静态成员函数没有<code>this</code>指针，只能访问类的静态数据；</li><li>静态成员函数不能定义为虚函数；</li><li>静态成员变量初始化<code>int Base::name = 0</code></li></ul><p>如果不是在类中声明成员，还有下面用法：</p><ul><li>隐藏作用：多文件编译时，定义的全局变量和函数都是整个工程可见的，只要使用时加上<code>extern</code>关键字即可。如果加上<code>static</code>关键字，那么该变量或函数就变为<strong>仅当前文件</strong>可见，这样我们可以在不同文件中定义同名的变量或函数而不用担心冲突。</li><li>全局生存期：<code>static</code>变量存储在静态数据区，默认值为0，<strong>只被初始化一次</strong>，即使作为局部变量，生存期也为整个程序，但作用域与普通变量相同，退出函数后即使变量存在，但不能使用。</li></ul><p>在C语言中主要有<a href="https://stackoverflow.com/questions/572547/what-does-static-mean-in-c">2种用途</a>:</p><ul><li>函数内的<code>static</code>变量在函数结束后仍然保持其值;</li><li><code>static</code>全局变量/函数只能在其定义的文件中调用, 可以用来进行访问控制和封装.</li></ul><h2 id="const">const</h2><ul><li>定义const对象：一旦创建其值不能改变，故const对象必须初始化。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> bufSize = <span class="number">512</span>;  <span class="comment">// the same as the previous one</span></span><br></pre></td></tr></table></figure><p>由于const对象默认只在文件内有效，所以如果要在文件间共享：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp定义并初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>;</span><br><span class="line"><span class="comment">// file1.h可以仅声明，不初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;</span><br></pre></td></tr></table></figure><ul><li>常量指针（const pointer）：指针本身（存在指针中的地址）不可变，不能指向其他变量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;num;  <span class="comment">// p将一直指向num</span></span><br></pre></td></tr></table></figure><ul><li>指向常量的指针（pointer to const）：无法通过指针修改对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span>* p = &amp;pi;  <span class="comment">// 正确</span></span><br><span class="line">*p = <span class="number">4.1</span>;  <span class="comment">// 错误，不能通过p修改pi的值 </span></span><br></pre></td></tr></table></figure><ul><li>修饰成员函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 不能修改成员变量，const对象不能调用非const成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>修饰类对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A obj;  <span class="comment">// obj为常量对象，任何成员都不能被修改，任何非const成员函数都不能被调用</span></span><br><span class="line">obj.<span class="built_in">f1</span>();  <span class="comment">// 错误</span></span><br><span class="line">obj.<span class="built_in">f2</span>();  <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A* obj  = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">obj-&gt;<span class="built_in">f1</span>();  <span class="comment">// 错误</span></span><br><span class="line">obj-&gt;<span class="built_in">f2</span>();  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><ul><li>转为非const</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pc;  <span class="comment">// pc指向内容不可变</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);  <span class="comment">// 正确，但是通过p写值是未定义行为</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a和b必须是独立内存区域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换">类型转换</h2><p>类型转换分为隐式转换和显式转换。 显式转换有四种：</p><ul><li><code>static_cast</code> 没有底层const都可以，使用比较普遍。 基类-&gt;派生类：不安全 主要执行非多态转换，代替C中的转换。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = &amp;d;</span><br><span class="line"><span class="keyword">double</span>* dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code> 运行时类型检查， 将基类指针或引用安全转换为派生类的指针或引用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type是类，且有虚函数</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type*&gt;(e);  <span class="comment">//e是指针</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e);  <span class="comment">//e是左值</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e);  <span class="comment">//e不是左值</span></span><br></pre></td></tr></table></figure><ul><li><code>const_cast</code> 改变底层const。 常量指针转为非常量指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cp;</span><br><span class="line"><span class="keyword">char</span>* q = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// wrong, static_cast不能用于底层const</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><code>reinterpret_cast</code> 比较危险，不太用。处理无关类型转换，重新解释对象的比特模型。</li></ul><h2 id="newdeletemallocfree">new/delete/malloc/free</h2><p><code>new/delete</code>是C++运算符，需要编译器支持，所以不需要指定大小，返回相应对象类型的指针，分配失败会抛出<code>std::bad_alloc</code>异常，<code>new</code>会调用<code>operator new()</code>申请内存(用<code>malloc</code>实现)，调用构造函数初始化成员变量，返回相应指针，<code>delete</code>先调用析构函数，再调用<code>operator delete()</code>函数释放内存(用<code>free</code>实现)；<br /><code>malloc/free</code>是库函数，不由编译器控制，需要显式指出大小，返回<code>void*</code>，需要强制类型转换，分配失败返回<code>NULL</code>指针，无法完成对象的构造和析构。</p><h2 id="智能指针">智能指针</h2><p><code>new</code>完后没有<code>delete</code>，内存泄漏。为了减少程序员的负担，引入智能指针：</p><ul><li><code>shared_ptr</code> 允许多个指针指向同一个对象。通常与<code>make_shared</code>函数结合食用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p = make_shared&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br></pre></td></tr></table></figure><p>实现方式一般是reference counting，在堆上申请资源并返回指针后，在堆上申请一个共享的引用计数器，每来一个指针指向该对象，++计数器。当计数器为0时，会自动释放指向的对象。<br />2个指针成员，一个指向对象，一个指向计数器<br />面试有可能被要求手撕一个： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySharePtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mySharePtr</span>() :<span class="built_in">refCnt</span>(<span class="literal">nullptr</span>), <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySharePtr</span>(T* res) :<span class="built_in">refCnt</span>(<span class="literal">nullptr</span>), <span class="built_in">ptr</span>(res) &#123;</span><br><span class="line">        <span class="built_in">add</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySharePtr</span>(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; p) :<span class="built_in">refCnt</span>(p.refCnt), <span class="built_in">ptr</span>(p.ptr) &#123;</span><br><span class="line">        <span class="built_in">add</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">mySharePtr</span>() &#123;</span><br><span class="line">        <span class="built_in">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lvalue is assigned, --counter</span></span><br><span class="line">    mySharePtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; that) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;that) &#123;</span><br><span class="line">            <span class="built_in">remove</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;ptr = that.ptr;</span><br><span class="line">            <span class="keyword">this</span>-&gt;refCnt = that.refCnt;</span><br><span class="line">            <span class="built_in">add</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr == other.ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">operator</span>==(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRef</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">            <span class="keyword">return</span> *refCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// if null, create counter = 1, else ++counter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">            ++(*refCnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            refCnt = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --counter, if counter = 0, free memory</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">            --(*refCnt);</span><br><span class="line">            <span class="keyword">if</span> (*refCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> refCnt;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                refCnt = <span class="literal">nullptr</span>;</span><br><span class="line">                ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* refCnt;</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>unique_ptr</code> 看名字就知道，独占对象。</p></li><li><p><code>weak_ptr</code> <a href="https://www.cnblogs.com/yocichen/p/10563124.html">std::weak_ptr</a></p></li></ul><h2 id="指针和引用-1">指针和引用</h2><p>引用只是一个别名，不是一种数据类型，不占存储空间，不能建立数组的引用 引用必须初始化，指针不必 引用初始化后不能改变，指针可以改变指向的对象 不存在指向空值的引用，存在指向空值的指针</p><h2 id="成员变量初始化顺序">成员变量初始化顺序</h2><p>初始化成员列表好处： 1. const成员变量只能初始化不能赋值 2. 引用只能在定义时初始化，不能重新赋值 3. 高效：初始化列表比赋值操作少一次默认构造函数，因为程序要默认构造临时对象（等号右边）后才能赋值</p><h2 id="指针函数和函数指针">指针函数和函数指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针函数: 返回类型是指针的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* s = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(a + b);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> (*func)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*func)(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*minus)(<span class="keyword">int</span>, <span class="keyword">int</span>) = sub;  <span class="comment">// minus是函数指针</span></span><br><span class="line"><span class="keyword">int</span>* m = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">operation</span>(<span class="number">3</span>, *m, minus);</span><br></pre></td></tr></table></figure><p><code>class</code>的成员变量和成员函数默认都是<code>private</code>，<code>struct</code>的成员变量和成员函数默认都是<code>public</code>。<code>class</code>的继承默认是私有继承，<code>struct</code>的继承默认是公有继承，公有还是私有取决于子类而非父类。<code>class</code>可以用作模板，<code>struct</code>不可以。</p><p>基类静态变量/全局变量：静态成员变量必须类外初始化 派生类静态变量/全局变量 基类成员变量：按照在类中定义的顺序，而不是初始化列表中的顺序 派生类成员变量</p><p>范围for循环 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int&amp; i : nums)  // allow modification in nums</span><br><span class="line">for (int i : nums)  // access by value</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">CoordinateArea</span> &#123;</span> ONE, TWO &#125;;</span><br><span class="line">CoordinateArea a = CoordinateArea::ONE;</span><br></pre></td></tr></table></figure><h2 id="todo">TODO</h2><p>函数缺省： 某个参数有默认值，缺省参数仍在后边 调用时如果略去一个参数传递，则略去后面所有</p><p>异常处理： 抛出异常，没有被特定的catch语句捕获，函数调用堆栈会被解退（函数终止，销毁局部变量，控制权转到调用它的那个函数）， 并在下一个外层try..catch捕获，最后没有任何catch捕获，调用terminate，abort退出。</p><p>传参时传引用与传指针效果相同 传引用，没有产生实参的副本，直接对实参操作 传指针，被调函数需要给形参分配空间，可读性差，需要传地址做实参，传引用更简单清晰</p><p>预处理、编译、汇编、链接</p><p>操作系统 * 用户告诉操作系统执行hello程序 * 操作系统到硬盘找到该程序 * 由编译程序将用户源程序编译成若干个目标模块 * 由链接程序将目标模块和相应的库函数链接成装入模块 * 操作系统分配内存，由装入程序将装入模块装入内存 * 为执行hello程序创建执行环境（创建新进程） * 操作系统设置CPU上下文环境，并跳到程序开始处 * 程序的第一条指令执行 * 程序执行与printf对应的系统调用 * 操作系统分配设备 * 执行显示驱动程序 * 窗口系统将像素写入存储映像区</p><p>模板特化、偏特化 内存池</p><p>volatile： 加volatile的关键字不进行编译器优化，保证对特殊地址的稳定访问 不能把他放在cache或寄存器中重复使用 防止优化编译器把变量从内存装入 CPU 寄存器 两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行</p><p>数据库缓存一致： 并发操作导致不一致，本质上修改数据库和删除缓存耦合在一起，使得其他操作有可能读出脏数据 解决方案：解耦，延迟双删：写-&gt;删缓存-&gt;修改数据库-&gt;延时-&gt;再次删缓存 二：内存队列：写修改数据库，将数据id放入队列，消费者线程消费即可</p><p>浏览器： DNS解析（DNS缓存、OS缓存、路由器缓存、递归搜索）、尝试建立TCP连接、发送HTTP请求(get)、服务器处理请求（查询） 返回HTML，浏览器解析渲染、关闭TCP连接</p><h2 id="优先队列">优先队列</h2><p>https://zhuanlan.zhihu.com/p/344121142 https://www.cnblogs.com/shona/p/12163381.html</p><h2 id="左值右值">左值右值</h2><p>https://zhuanlan.zhihu.com/p/335994370 左值：表达式结束后依然存在的持久对象，在内存中占有确定位置的对象 右值：表达式结束后不再存在的临时对象，不在内存中有确定位置 如果能对表达式取地址则为左值</p><p>左值引用：int &amp;ref = 左值表达式 右值引用：int &amp;&amp;ref = 右值表达式</p><p><code>move</code>可以避免不必要的内存拷贝，将对象的所有权从一个对象转移到另一个对象，优化性能</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多线程编程</title>
      <link href="/2019/03/04/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/03/04/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="threads-tasks">Threads &amp; Tasks</h2><p>多线程是指在一个进程中同时有多个线程运行, 这些线程间可能是独立的, 也可能进行通信. C++多线程有2种基本方式:</p><ul><li>Threads: 用<code>std::thread</code>创建, 没有返回值</li><li>Tasks: 用<code>std::async</code>创建, 有返回值</li></ul><p>无论哪种方式, 都可以使用以下3种方法传参:</p><ul><li>pointer to function</li><li>functors</li><li>lambda function</li></ul><p>例如有一个求和函数<code>sum(int&amp; s, int l, int r)</code>, 单线程可能耗时很久, 因此可以用多个线程同时计算多个部分和, 最终累加部分和即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create and start each thread</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(sum, std::ref(partialSum[<span class="number">0</span>]), <span class="number">0</span>, <span class="number">1000</span>/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(sum, std::ref(partialSum[<span class="number">1</span>]), <span class="number">1000</span>/<span class="number">2</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main() gets blocked</span></span><br><span class="line">t1.<span class="built_in">join</span>();  <span class="comment">// wait for threads to end</span></span><br><span class="line">t2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>如果需要很多线程, 可以用数组: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(sum, std::<span class="built_in">ref</span>(partialSum[i]), i * step, (i + <span class="number">1</span>) * step));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (thread &amp;t : threads) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了函数指针, 还可以用Functor Object. 仿函数是实现了<code>operator()</code>的<code>class/struct</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a, <span class="keyword">const</span> <span class="keyword">int</span>&amp; b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过仿函数传参: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sumFunctor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        _sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">            _sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    sumFunctor* functor = <span class="keyword">new</span> <span class="built_in">sumFunctor</span>();</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(std::<span class="built_in">ref</span>(*functor), i * step, (i + <span class="number">1</span>) * step));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>thread()</code>构造函数的第一个参数可以有2种选择:</p><ul><li>functor object: 后续无需使用仿函数的成员变量</li><li>ref(functor obj): 后续需要使用成员变量</li></ul><p>除了用引用搞定返回值, 还可以将其存储到成员变量中供后续使用.</p><p>第3种方式是用lambda function传参: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>([i, &amp;partialSum, step] &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * step; j &lt; (i + <span class="number">1</span>) * step; ++j) &#123;</span><br><span class="line">            partialSum[i] += j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果<code>sum</code>确实需要返回值<code>T</code>, 可以使用<code>std::async</code>生成返回值<code>future&lt;T&gt;</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;future&lt;<span class="keyword">int</span>&gt;&gt; tasks;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// create, start and push each task</span></span><br><span class="line">    tasks.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(sum, i * step, (i + <span class="number">1</span>) * step));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if future value not ready, main() blocks. similar to join()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : tasks) &#123;</span><br><span class="line">    total += t.<span class="built_in">get</span>();  <span class="comment">// wait for tasks to end and read return values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="mutex-conditional-variables">Mutex &amp; Conditional Variables</h2><p>由于多个线程可能需要同时访问共享变量, 因此会产生race condition, 对最终结果造成不确定性. 最经典的例子便是计数器: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(increase));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 100个线程, 每个线程使得<code>cnt</code>增加100, 但是最终结果却未必是10000. 核心原因在于<code>++cnt</code>不是原子操作, 可以粗略拆为3个阶段: 读取, 加一, 写入. 因此2个线程的执行顺序可以是: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1: read(0)         inc  write(1)</span><br><span class="line">t2:        read(0)  inc         write(1)</span><br></pre></td></tr></table></figure> 更麻烦的是, read/write也不是原子操作: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1:    read1            read2 inc write</span><br><span class="line">t2: read     inc  write</span><br></pre></td></tr></table></figure> 另外, 从源码开始, 编译器首先操作一波(reordering/loop unrolling), 接着CPU操作一波(out of order execution/branch prediction), 接着是多级缓存(prefetch/buffering), 最后才访问内存. 因此某个线程自认为的写入也许只是写到了自己的cache, 其他线程并未感知.</p><p>可以发现: 核心在于多个线程需要竞争访问共享资源, 并且线程间执行顺序不合法, 导致undefined behavior. 解决方案有3种:</p><ul><li>mutex and locks: mutex lock/unlock, lock_guard, unique_lock, shared_lock, scoped_lock</li><li><code>std::atomic</code>: memory models</li><li>abstraction: CSP, Actors, Map-Reduce</li></ul><p>所谓mutex(mutual exclusion), 本质上还是为了在同一时间只有单个线程访问共享资源, 使得共享资源的访问原子化.</p><p>所以计数器程序可以更正为: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;  <span class="comment">// mutex is shared by all threads</span></span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// shared memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        ++cnt;  <span class="comment">// critical section</span></span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上述代码虽然是正确的, 但是可能出现意外:</p><ul><li>忘记<code>unlock</code>, 其他线程永远无法进入临界区</li><li>如果临界区抛出异常, 无法调用<code>unlock</code></li></ul><p>需要注意的是: <code>lock()</code>两次或<code>unlock()</code>两次都是未定义行为, 应当避免.</p><p>为了减少意外, C++提供了<code>lock_guard</code>可以自动<code>lock/unlock</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;  <span class="comment">// mutex is shared by all threads</span></span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// shared memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 构造时自动加锁, 析构时(如跳出作用域)自动解锁, 这样上述2个问题就可以避免, 这就是所谓的RAII.</p><p><code>lock_guard</code>没有提供<code>lock/unlock</code>接口, 不够灵活. 因此C++引入了<code>unique_lock</code>: <code>lock_guard</code> + <code>lock/unlock</code>接口. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;  <span class="comment">// mutex is shared by all threads</span></span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// shared memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        ul.<span class="built_in">unlock</span>();</span><br><span class="line">        ul.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了提高并发效率, 可以让多个线程同时读取, 于是就有了<code>shared_lock</code>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::shared_mutex mtx;</span><br><span class="line"><span class="keyword">int</span> cnt;  <span class="comment">// shared memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;shared_mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;  <span class="comment">// unique_lock for writers</span></span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">shared_lock&lt;shared_mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;  <span class="comment">// shared_lock for readers</span></span><br><span class="line">        cout &lt;&lt; cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果需要多个互斥量, 那么要注意避免死锁: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 正确的处理是<code>lock()</code>, 通过all or nothing避免死锁: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">lock</span>(mtx1, mtx2);  <span class="comment">// lock both mutexes without deadlock</span></span><br><span class="line">        <span class="comment">// make sure the locked mutexes unlocked at the end of scope</span></span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::adopt_lock)</span></span>;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::adopt_lock)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 上述代码虽然正确, 但很凌乱, 因此C++17提供了<code>scoped_lock</code>, 仍然通过RAII的方式避免手动解锁: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="function">scoped_lock <span class="title">lck</span><span class="params">(mtx1, mtx2)</span></span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ok, 到此为止解决了互斥访问的问题, 接下来解决线程间通信的问题, 由此引入条件变量. 线程间通信最经典的例子就是生产者-消费者问题, 当准备好数据后, 生产者需要某种方式通知消费者:</p><ul><li>共享内存: 设置共享变量<code>data</code>和<code>ready</code>. 生产者准备好数据后, 将<code>ready=true</code>; 消费者忙等监测<code>ready</code>的状态.</li><li>条件变量: 为了提高效率, 生产者准备好数据后通过条件变量发送通知; 消费者接到通知后才唤醒. It is all about sending a message.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line">data = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data = <span class="built_in">generateData</span>();</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        ul.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        ul.<span class="built_in">lock</span>();</span><br><span class="line">        cv.<span class="built_in">wait</span>(ul, []()&#123; <span class="keyword">return</span> ready == <span class="literal">false</span>; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">// if blocked, ul.unlock() is called automatically</span></span><br><span class="line">        <span class="comment">// if unblocked, ul.lock() is called automatically</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(ul, []() &#123; <span class="keyword">return</span> ready; &#125;);</span><br><span class="line">        <span class="built_in">sample</span>(data);</span><br><span class="line">        ready = <span class="literal">false</span>;</span><br><span class="line">        ul.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        ul.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>wait</code>是需要2件事才能唤醒的:</p><ul><li>收到<code>cv</code>的通知: <code>cv.notify_one()</code></li><li><code>ready == true</code></li></ul><p>之所以仍然需要<code>ready</code>变量, 是因为<code>wait</code>可能出现虚假唤醒的情况.</p><h2 id="生产者消费者">生产者消费者</h2><p>本质上是通过引入缓冲区来平衡生产速度和消费速度，包括单生产者-单消费者，单生产者-多消费者，多生产者-单消费者和多生产者-多消费者。</p><p><a href="">实现在这里</a></p><p>有几个需要注意的地方： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 使用<code>while</code>而不是<code>if</code>，因为<code>wait</code>从阻塞到返回并不一定是由<code>notify_one()</code>造成的，还可能由于其他原因导致，即伪唤醒，这样就会导致后续执行出错。</p><p>由于单独使用<code>mutex</code>可能导致死锁，因此选择使用<code>unique_lock</code>管理互斥锁。之所以不能用<code>lock_guard</code>，因为<code>lock_guard</code>只能是在构造时自动调用<code>lock()</code>上锁，析构时自动释放锁，即所谓的RAII(资源分配即初始化)，没有<code>lock()</code>和<code>unlock()</code>接口供程序员使用。</p><h2 id="多线程顺序打印">多线程顺序打印</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mtx;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lk, [&amp;]() &#123; <span class="keyword">return</span> num == flag; &#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in"><span class="keyword">char</span></span>(<span class="string">&#x27;A&#x27;</span> + num);</span><br><span class="line">        flag = (flag + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(print, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(print, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(print, <span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;main thread&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ref">Ref</h2><p><a href="https://andrew128.github.io/ProducerConsumer/">The Producer Consumer Problem in C++</a><br /><a href="https://gist.github.com/ictlyh/f8473ad0cb1008c6b32c41f3dea98ef5">producer-consumer</a><br /><a href="https://immortalqx.github.io/2022/02/08/cpp-notes-6/">生产者消费者模型</a><br /><a href="https://www.youtube.com/watch?v=3aqxaZsvn80">C++ multithread</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值引用与move</title>
      <link href="/2019/03/04/%E5%8F%B3%E5%80%BC/"/>
      <url>/2019/03/04/%E5%8F%B3%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>事情起源于做CS144 lab时，为了提升buffer的读写效率，将基于内存拷贝的方式改为基于内存所有权转移的方式大大提高了TCP的吞吐量，但自己一直对这些概念模棱两可，希望此文能做一些梳理。</p><h2 id="左值和右值">左值和右值</h2><p>顾名思义，左值指的是位于赋值号左侧，可以用<code>&amp;</code>取地址；右值位于赋值号右侧，无法取地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;  <span class="comment">// a是左值，5是右值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a=<span class="number">5</span>) &#123;</span><br><span class="line">        a_ = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = <span class="built_in">A</span>();</span><br></pre></td></tr></table></figure><p>如果你试图<code>&amp;A()</code>，编译器会报错<code>error: taking address of temporary</code>。因为在该行直接用类生成的是一个临时对象，其生命周期在该行创建，在该行销毁，拿到该对象的地址没有意义。</p><h2 id="左值引用和右值引用">左值引用和右值引用</h2><p>引用是变量的别名，必须与某个变量绑定，传参时传递引用可以避免拷贝。</p><p>普通的左值引用只能指向左值，不能指向右值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref_a = a;</span><br><span class="line"><span class="keyword">int</span>&amp; ref_aa = <span class="number">5</span>;  <span class="comment">// error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure> 引用可以直接修改原对象，右值无地址也无法被修改，故左值引用无法指向右值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int&amp; ref_aa = 5;</span><br></pre></td></tr></table></figure><p>const左值引用不会修改指向的右值，故可以指向右值。因此经常见到使用const引用作为函数参数，如<code>push_back(const int&amp; val)</code>，否则就无法<code>push_back(5)</code>。</p><p>普通的右值引用只能指向右值，不能指向左值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ref_aa = a;  <span class="comment">// error: cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ref_a = <span class="number">5</span>;</span><br><span class="line">ref_a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></p><p>如果希望右值引用指向左值，需要通过<code>move</code>将左值转换为右值： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; ref_aa = <span class="built_in">move</span>(a);</span><br><span class="line">cout &lt;&lt; a;  <span class="comment">// 仍然打印5</span></span><br></pre></td></tr></table></figure></p><p>好像与我们想象的<code>move</code>不太一样，本以为<code>move</code>可以将<code>a</code>中的值移动到<code>ref_aa</code>中，但是<code>a</code>的值却没有变化。所以可以看到<code>move</code>只是完成了强制类型转换<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>，使得右值引用可以指向左值，貌似与性能没什么关系。</p><p>实质上，右值引用之所以能指向右值，其实也是将右值提升为了左值，再用<code>move</code>将左值强制转为右值： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int&amp;&amp; ref_a = 5;  // 等价于下面代码</span><br><span class="line"></span><br><span class="line">int tmp = 5;</span><br><span class="line">int&amp;&amp; ref_a = move(tmp); </span><br></pre></td></tr></table></figure></p><p>直接声明出来的左值引用和右值引用都是左值，但是右值引用也可以是右值，如果有名字就是左值，否则是右值（比如函数返回值）。</p><p>综上：右值引用既可以指向右值，也可以通过<code>move</code>指向左值，比较灵活；普通的左值引用只能指向左值，虽然const左值引用也可以指向右值，但是无法修改指向的变量，相比于右值引用也比较局限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; n)</span> </span>&#123;++n;&#125;  <span class="comment">// 编译失败，const左值引用不能修改指向的变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp;&amp; n)</span> </span>&#123;++n;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="使用场景">使用场景</h2><p>那么认知中的<code>move</code>可以提升性能又是咋回事呢？</p><p>如果没有右值引用，通常一个类如下： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> size) : <span class="built_in">size_</span>(size) &#123;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">int</span>[size_];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数 深拷贝</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; tmp) &#123;</span><br><span class="line">        size_ = tmp.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size_; ++i) &#123;</span><br><span class="line">            data_[i] = tmp.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载 深拷贝</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Array&amp; tmp) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"></span><br><span class="line">        size_ = tmp.size_;</span><br><span class="line">        data_ = <span class="keyword">new</span> <span class="keyword">int</span>[size_];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size_; ++i) &#123;</span><br><span class="line">            data_[i] = tmp.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Array</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* data_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>传参时已经通过左值引用避免了一次拷贝，但是深拷贝仍然还需要一次拷贝。此时移动构造函数就出来了：将源数据移动到新指针，丢弃源指针。为了和拷贝构造函数区分开，需要多一个参数<code>move</code>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="keyword">const</span> Array&amp; tmp, <span class="keyword">bool</span> move) &#123;</span><br><span class="line">    size_ = tmp.size_;</span><br><span class="line">    data_ = tmp.data_;</span><br><span class="line">    tmp.data_ = <span class="literal">nullptr</span>;  <span class="comment">// 防止tmp析构时删除data_</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 但是const左值引用无法修改<code>tmp.data_</code>，如果改为非const，那么可以去掉参数<code>move</code>（只有引用传递和指针传递可以用是否加const重载，故可以和拷贝构造区分），但是<code>Array a = Array(rvalue)</code>就无法使用，因为左值引用无法指向右值，即无法用右值的Array来移动构造。</p><p>所以右值引用就派上用场了： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(Array&amp;&amp; tmp) &#123;</span><br><span class="line">    size_ = tmp.size_;</span><br><span class="line">    data_ = tmp.data_;</span><br><span class="line">    tmp.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 即无需参数<code>move</code>，也可以使用右值来构造，也可以将左值用<code>std::move</code>转为右值再去构造。STL中的vector等均实现了以右值引用传参的移动构造函数和移动赋值重载函数，传递左值则拷贝，传递右值则移动。</p><p>例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span>&amp;&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp; args)</span></span>;</span><br></pre></td></tr></table></figure> 如果需要拷贝对象，但是拷贝后源不再需要，可以使用<code>std::move</code>触发移动语义。</p><h2 id="完美转发">完美转发</h2><p><code>std::forward&lt;T&gt;(u)</code>：当T为左值引用时，u被转换为T类型的左值；否则u被转换为T类型右值。</p><h2 id="reference">Reference</h2><p><a href="zhuanlan.zhihu.com/p/335994370">一文读懂C++右值引用和std::move</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW 0</title>
      <link href="/2019/02/28/INTERVIEW%200/"/>
      <url>/2019/02/28/INTERVIEW%200/</url>
      
        <content type="html"><![CDATA[<h2 id="造成网络延迟的可能原因">造成网络延迟的可能原因</h2><ol type="1"><li>WiFi所有用户上下行流量共用一个信道，当用户太多或者有人在下载大的资源时带宽不够，丢包；</li><li>线路质量不佳导致信噪比太低，比如光纤损耗太大等。</li></ol><h2 id="ipv6优势">IPv6优势</h2><ol type="1"><li>IPv4地址不够用，IPv6有<span class="math inline">\(2^{128}\)</span>个地址；</li><li>使用更小的路由表，转发速度更快；</li><li>扩充了DHCP协议，支持自动配置；安全性更高，有更好的头部格式，允许扩容......</li></ol><h2 id="找到单向无环链表的中间元素若结点总数为偶数返回第二个元素">找到单向无环链表的中间元素，若结点总数为偶数，返回第二个元素</h2><p><a href="https://leetcode.com/problems/middle-of-the-linked-list/">leetcode类似题目</a></p><p>只扫描一遍的做法：设两个指针，初始指向头结点，p1每次走两步，p2每次走一步，p1到达链尾，p2到达中间。假设链表带有头结点。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*单链表定义*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode * <span class="title">middle</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;amp;&amp;amp; fast-&amp;gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&amp;gt;next-&amp;gt;next;</span><br><span class="line">            slow = slow-&amp;gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="给出四个点坐标判断是否是凸四边形">给出四个点坐标，判断是否是凸四边形</h2><p>不妨扩展下该问题，给出任意n个点，判断<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2108">是否凸多边形</a>。</p><p>凸多边形就是所有内角均小于180°，方法有好几种，这里利用定点凹凸性判断： 设当前三个连续的顶点<span class="math inline">\(P_0, P_1, P_2\)</span>，计算向量<span class="math inline">\(P_0P_1\)</span>, <span class="math inline">\(P_1P_2\)</span>的叉积，若结果为正，表示多边形顶点逆时针转；若结果为负，两向量夹角大于180°，则为凹多边形。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;p[<span class="number">600000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cross_p</span><span class="params">(point a, point b,point c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b.x - a.x) * (c.y - b.y) - (c.x - b.x) * (b.y - a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isConvex</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//叉积量值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cross_p</span>(p[i], p[(i + <span class="number">1</span>) % n], p[(i + <span class="number">2</span>) % n]) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isConvex</span>(n))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;convex\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;concave\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="两个位数在10万位以内的数乘法">两个位数在10万位以内的数乘法</h2><p><a href="https://leetcode.com/problems/multiply-strings/">高精度</a></p><p>高精度乘法，模仿我们笔算的过程。每一位<span class="math inline">\(res[i + j]\)</span>的构成：<span class="math inline">\(res[i + j] + carry + a[i] * b[j]\)</span>，注意去掉结果的前导0。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">120</span>], b[<span class="number">120</span>], res[<span class="number">250</span>];</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">        <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lena = num1.<span class="built_in">size</span>(), lenb = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena; i++)</span><br><span class="line">            a[i] = num1[lena - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenb; i++)</span><br><span class="line">            b[i] = num2[lenb - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenb; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i + j] = res[i + j] + a[j] * b[i] + carry;</span><br><span class="line">                carry = res[i + j] / <span class="number">10</span>;</span><br><span class="line">                res[i + j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i + lena] = carry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len_res = lena + lenb;</span><br><span class="line">        <span class="comment">//去掉结果的前导0,若结果为0，保留一个0</span></span><br><span class="line">        <span class="keyword">while</span> (res[len_res - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; len_res &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len_res--;</span><br><span class="line">        &#125;</span><br><span class="line">        　　　　　　　<span class="comment">//使用字符串流将整数转为字符串</span></span><br><span class="line">        stringstream ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len_res - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans &lt;&lt; res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="其它">其它</h2><ol type="1"><li>操作系统：CPU调度，用户态&amp;内核态，IPC，各种锁，实时系统；</li><li>数据结构：判断有向图是否存在回路（拓扑排序、求最短路、关键路径、BFS），排序（快排、冒泡、选择、插入），链表是否有环；</li><li>计网：ARP、TCP/UDP、NAT、802.11ac协议，ping过程；</li><li>C++多态。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 FAQ</title>
      <link href="/2019/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20FAQ/"/>
      <url>/2019/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20FAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="进程线程协程">进程线程协程</h2><ol type="1"><li>联系: 线程存在于进程内部, 一个进程可以有多个线程, 一个线程只能属于一个进程.</li><li>区别: 进程是运行时程序的封装, 是系统进行资源分配和资源调度的基本单位; 线程是进程的子任务, 是CPU分配和调度的基本单位. 进程创建需要系统分配内存, CPU和文件句柄等资源, 销毁时要进行相应的回收, 因此进程的管理开销大; 线程开销小. 进程间不会互相影响; 一个线程崩溃会导致进程崩溃, 从而影响其他线程.</li></ol><p>协程即微线程 协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。 这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p><p>https://zhuanlan.zhihu.com/p/204965836 https://www.zhihu.com/question/50185085/answer/183463734</p><h2 id="进程调度算法">进程调度算法</h2><ol type="1"><li>先来先服务(FCFS): 按照到达任务队列的顺序调度, 非抢占式, 易于实现, 效率低性能差, 有利于CPU繁忙型作业(长作业)不利于IO繁忙型(短作业).</li><li>短作业优先(SJF): 每次从任务队列选择预计时间最短的作业运行, 非抢占式, 性能最优, 平均周转时间最低, 吞吐量大, 不利于长作业, 会出现饥饿现象, 完全未考虑作业的优先级, 不能用于实时系统.</li><li>最短剩余时间优先: 首先选择预计时间最短的作业运行, 如果新作业服务时间小于当前作业的剩余时间, 抢占CPU.</li><li>高响应比优先: 在后备作业队列中选择响应比最高的, 非抢占式, 需要计算响应比耗费资源. <span class="math inline">\(响应比=1+\frac{等待时间}{服务时间}\)</span></li><li>时间片轮转(RR): 可以响应所有用户的请求, 适于分时系统.</li><li>多级反馈队列: UNIX使用的调度算法. 多个不同优先级的队列按照RR调度, 如果未完成就进入下一优先级, 新来进程可以根据优先级抢占.</li></ol><h2 id="死锁">死锁</h2><ol type="1"><li>原因: (1) 系统资源不足; (2) 进程推进顺序不当; (3) 资源分配不当.</li><li>必要条件: (1) 互斥访问: 一个资源每次只能被一个进程访问; (2) 占有并请求: 进程因请求资源阻塞时对已占有的资源保持不放; (3) 不可剥夺: 进程已经获取的资源不能被强制剥夺; (4) 循环等待: 多个进程间形成资源的循环等待关系.</li></ol><h2 id="文件系统">文件系统</h2><p>https://zhuanlan.zhihu.com/p/183238194 https://zhuanlan.zhihu.com/p/106459445 https://zhuanlan.zhihu.com/p/27875337 https://www.zhihu.com/question/284540952 https://www.zhihu.com/question/51329419/answer/125389853</p><p>ext4 https://zhuanlan.zhihu.com/p/27875337</p><h1 id="数据库">数据库</h1><p>事务：一组逻辑操作的集合，满足ACID特性。事务要么全部成功，要么全部失败。</p><p>https://zhuanlan.zhihu.com/p/65281198 原子性：undo log记录事务修改前的数据信息，用来回滚 持久性：redo log记录已经成功提交的事务操作信息，用来恢复数据 隔离性：依靠读写锁和MVCC（多版本并发控制）实现。读写锁包括共享锁和排他锁，MVCC通过为数据添加时间戳实现。</p><p>数据库权限：GRANT REVOKE DENY</p><p>索引最左匹配原则 https://juejin.cn/post/6844903966690508814</p><p>关系型与非关系型 https://www.cnblogs.com/progor/p/8729798.html</p><p>连接器 分析器 优化器 执行器</p><p>数据库八股 https://zhuanlan.zhihu.com/p/403656116</p><h2 id="分布式">分布式</h2><p>云存储 https://www.zhihu.com/question/25834847/answer/348271275 云计算 云网络 云操作系统</p><h2 id="zombie-orphan-process">Zombie &amp; Orphan Process</h2><p>孤儿进程：父进程先于子进程结束，内核控制其被init进程收养。并不是一种单独的状态。<br />僵尸进程：子进程先结束但是父进程并未回收，使得残留资源PCB在内核中，不能用kill杀死，状态是Z。</p><p>处理僵尸进程方法：</p><ol type="1"><li>杀死其父进程，使其成为孤儿进程</li><li>信号机制：子进程退出时向父进程发送SIGCHILD信号，父进程处理该信号，在处理函数中调用wait回收资源。</li></ol><h2 id="ref">Ref</h2><p><a href="https://www.scaler.com/topics/operating-system/zombie-and-orphan-process-in-os/">Zombie &amp; Orphan Process</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Science Roadmap</title>
      <link href="/2019/02/15/Computer%20Science%20Roadmap/"/>
      <url>/2019/02/15/Computer%20Science%20Roadmap/</url>
      
        <content type="html"><![CDATA[<p>有感于国内令人发指的CS教育(尤其某校的计算机基本就是一堆SB在自嗨自娱自乐而已)，决定自学为主。<br />主要资源是四大的比较完整的课程：video+reading+lab</p><ul><li><a href="https://github.com/prakhar1989/awesome-courses">Awesome CS Courses</a></li><li><a href="https://csdiy.wiki/">CS自学指南</a></li><li><a href="https://conanhujinming.github.io/comments-for-awesome-courses/">名校公开课程评价网</a></li><li><a href="https://teachyourselfcs.com/">Teach Yourself Computer Science</a></li><li><a href="https://github.com/huangrt01/CS-notes">RT Huang的自学笔记</a></li><li><a href="https://learn-sys.github.io/">LEARNSYS</a></li><li><a href="https://github.com/ossu/computer-science">OSSU</a></li></ul><p>video比较费时间，而且我看视频总是来不及反应，好像不太适合我，所以一般只在看不懂材料时去针对性地看看视频。(当然一些讲得非常好的视频除外)</p><h2 id="basics">Basics</h2><ul><li><strong>Programming Languages</strong>: 精通C, 熟悉1~2门(Java/Python/C++/Go), 了解一门(Haskell/Rust), 掌握debug技巧</li><li><strong>Tools/Frameworks</strong>: 熟悉Linux系统的各项操作，最好看下源码，掌握Git等工具和框架</li><li><strong>Math</strong>: 线性代数，概率论，数理统计，组合数学，离散数学，微积分. 现用现学</li><li><strong>Core Courses</strong>: DS/Algorithms/OS/Organization/Network/DB</li></ul><h2 id="coding-interview">Coding Interview</h2><p>这方面<strong>很弱很弱</strong>，要勤奋练习，经常性在blog<strong>分析总结</strong>，<strong>穿透做过的题目及变种</strong>.<br />不要抱着可能撞到原题的心态去准备，反复练习提升自己的能力，需要有较多的训练量。</p><p>复杂度最优，Google Doc/白纸练习，Bug-Free<br />easy: 5-10min medium: 15-20min hard: 20-30min</p><p>G实习：中文2轮：45min, 自我介绍+warm-up+hard, 1~2道medium题，白板<br />G校招：4轮（3中+1英），同上</p><ul><li><strong>Data structure</strong>：哈希表、堆、AVL、链表动手实现一遍，B+树啥的都能扯扯~</li><li><strong>Algorithms</strong><br /><a href="https://leetcode-cn.com/problemset/lcof/">《剑指offer》</a><br /><a href="https://leetcode-cn.com/problemset/lcci/">Cracking the Coding Interview</a><br /><a href="https://leetcode.com/">Leetcode</a><br /><a href="https://www.nowcoder.com/">牛客笔试题</a><br /></li><li><strong>System design</strong></li></ul><h2 id="projectspaper">Projects/Paper</h2><p><strong>选一个前沿的、不太讨厌的方向，研究研究，做点小项目</strong>，具体的方向可以参考<a href="http://csrankings.org/">CSRankings</a></p><ul><li>实习项目</li><li>学校大作业</li><li>兴趣项目：AutoML</li><li>开源项目</li></ul><h2 id="关于面试">关于面试</h2><p>每家公司的风格不一, 不过总体上可以分为以下几块:</p><h3 id="笔试">笔试</h3><p>算法题为主, 不需要时空复杂度最优, 需要练习ACM模式. 可以通过牛客网, kickstart, codeforces等训练.</p><h3 id="做题">做题</h3><p>通常需要给出最优解, 多练习就是了.</p><ol type="1"><li>问清题目：数据范围是多少？这个数组的大小范围是多少？能不能给个样例？如果输入是这个，那输出应该是什么<br /></li><li>确认函数签名<br /></li><li>确认思路：修改输入数据<br /></li><li>确认corner case处理方式</li><li>编码过程中不断交流<br /></li><li>主动测试：写完后不要急于告诉面试官写完了，手动跑一个样例：在屏幕上写出中间变量的当前取值，然后用鼠标光标告诉面试官现在程序跑到了哪一行代码，当前各个变量的取值是多少等等<br /></li><li>主动分析复杂度<br /></li><li>讨论算法的trade-off</li></ol><h3 id="八股">八股</h3><p>没啥好说的, 多背就是了.</p><h3 id="项目">项目</h3><p>面国内大厂比较重要, 如果有岗位相关的项目就可以聊天了, 不过一定要熟悉.</p><p>可以是实习项目, Paper, 自学项目等.</p><p>项目/research的背景主要包括场景、问题定义、需求、自己负责的部分扮演的角色等等, 指出项目中的困难点和解决方案.</p><h3 id="软实力">软实力</h3><ul><li>GPA/数学/英语</li><li>比赛奖项</li><li>沟通交流能力: 更是一次需要充满着沟通与交流的谈话，让面试官认为他/她愿意成为你的同事. 虽然我不太懂，但是可以试着说一下, 说出自己的insight:cache不友好. 获得监督信息与正反馈.</li><li>面经和技巧: 面经是告诉你这家公司面试的时候喜欢问哪些知识，而不是告诉你他们喜欢问哪些特定的问题。锦上添花, 最重要的还是及格的实力. Nothing replaces hard work. 先拿一些自己不target的公司练练手. 模拟面试.</li></ul><h2 id="how-to-learn">How to learn</h2><p>It is very important to take classes around my future work. It doesn't matter you learn it slowly, the most important part is that you <strong>take it seriously</strong> and build a <strong>solid foundation</strong>.<br />根据大佬们的经验，一门课大概要花150-300小时，每天2小时至少也要2个半月，所以千万千万不要着急，不要急于求成，总想着完成任务，多多反思自己到底学到了什么？真的透彻地理解了吗？又有多少内化到自身的知识体系？<br />还有就是最好按照他们的课表时间上课，同时上的课最好不要超过2门（经过血泪实践，我只能1门单线程┭┮﹏┭┮，他们课程内容实在太充实了...，然后自己还有一堆屁事...）</p><p><strong>严格遵守学术规范</strong>，独立完成之后可以参考别人，修正自己。</p><p>Recently I've changed my way to learn new things. Previously I just wanted to understand the new things and tried to memorize all the details of a specific problem, or just translated others' materials into my words, which melted my brain and showed a very low efficiency. The reason why I learn things this way (passively) is mostly due to the Chinese's cramming education. But for me, heuristic teaching (actively) is more appropriate. The specific problem/model/algorithm is important, but the <strong>motivation</strong> is much more important. <strong>Everything has its motivation.</strong> So I decide to write my blogs with the following components:</p><ol type="1"><li>Motivation: What problems do we meet? Why propose this one?</li><li>Details: Mathematical derivation or tricky things.</li><li>Example: Use a handy example to illustrate.</li><li>Implementation: Code it out or use it to <strong>solve the problem</strong>.</li><li>Properties: <strong>When</strong> should/can we use the method? When shouldn't/can't? <strong>Why</strong>? What's the benefits and drawbacks if we use it?</li><li>Can we make some improvements on the off-the-shelf method for a specific problem?</li></ol><h2 id="todo-done-list">TODO &amp; DONE LIST</h2><p>Count the courses I've taken so far:</p><ol type="1"><li>Introduction to Computer Science. Harvard University<br />"This is CS 50". It should be the first class of CS rather than Haoqiang Tan's C Programming Language.</li><li>Linear Algebra. Massachusetts Institute of Technology<br />If you want to learn Linear Algebra, just follow this one and you'll be fine.</li><li>Mathematics for Computer Science. Massachusetts Institute of Technology<br />Very interesting course but I only took several lectures. SAD~</li><li>Data Structures. University of California, Berkeley<br />Strong recommend for Data Structure. You'll pick up Java from the interesting projects.</li><li>Introduction to Computer Systems. Carnegie Mellon University<br />If you only want to take one system course, then select this one. But I haven't finished the whole lectures and labs. SAD again~</li><li>Introduction to Database Systems. Carnegie Mellon University<br />Hard for me. Just finished lab1. I'll come back one day~</li><li>Machine Learning. Stanford University<br />It's almost the first course I took after I found the true CS courses. But I forgot a lot. Sorry Andrew~</li><li>Positive Psychology. Harvard University<br />When I start to be anxious or depressed I'll go and find the lecture. Tal is an amazing teacher and I'm sure you'll become happier.</li><li>Convolutional Neural Networks for Visual Recognition. Stanford University<br />High quality, especially its readings.</li><li>Introduction to Computer Networking. Stanford University<br />Lab is amazing!</li></ol><p>CS5412 + 6.828 + 6.824 + 6.031 + SICP + 6.033 + CS262</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 3-Way Handshake</title>
      <link href="/2019/01/04/TCP%203-Way%20Handshake/"/>
      <url>/2019/01/04/TCP%203-Way%20Handshake/</url>
      
        <content type="html"><![CDATA[<p>TCP是面向连接的协议，其数据传输过程分为建立连接、数据传送、释放连接三个阶段。 ## 0 建立连接 建立连接的过程也就是常说的“三次握手”：</p><ul><li>客户端向服务器端发送一个SYN报文（SYN=1表示这是一个连接请求或连接接收报文），并随机选取一个起始序号x；</li><li>服务器端应答一个SYN报文，同时ACK（确认位）置1【ACK=1时TCP报文段首部中的ack（确认号字段）才有效】，随机选取一个服务器端的起始序号y，并将ack字段设为x+1，表示已经收到客户端发来的SYN报文，期待收到序号为x+1的下一个报文；</li><li>客户端应答一个ACK报文，将序号设为x+1，并且ack字段设为y+1，表示已经收到服务器端的SYN报文，期待收到序号为y+1的下一个报文。</li></ul><p><em>注：序列号seq也称ISN(Initial Sequence Number)</em> <img src="https://img-blog.csdnimg.cn/20190920214108996.png" alt="图片来自百度" /><br />之所以要采用三次握手机制而不是两次或四次，要从握手机制的目的说起：<br />握手主要是为了确认<strong>双方的发送、接收能力</strong>是否正常，顺带初始化序号seq，为以后的数据传送做好准备，所以：<br />第一次握手：服务器收到客户端发来的网络包，<strong>服务器就明白</strong>客户端的发送能力、服务器的接收能力正常；<br />第二次握手：服务器发包，客户端收到后，<strong>客户端就明白</strong>服务器的发送、接收，客户端的发送、接收都是正常的；<br />二次握手后，客户端倒是全明白了，但是<strong>服务器端无法确认客户端能否正常接收、服务器是否正常发送</strong>，所以两次握手不够；<br />第三次握手：服务器收到客户端发送的网络包，服务器确认了自己上次的发送正常、客户端接收也正常，所以四次握手是多余的。</p><h2 id="补充问题">1 补充问题</h2><ul><li>序列号(ISN)之所以随机生成，是为了避免被攻击（若固定，则下一次传送的ack就显而易见）；</li><li>前两次握手不可以携带数据，第三次可以携带。第一次握手服务器端接收能力未知，如果携带数据就可能丢失。第二次客户端接收能力未知，如果携带数据也可能丢失。第三次客户端知道服务器接收正常，并且自己已经处于ESTABLISHED状态；</li><li>服务器发出SYN报文后，处于SYN-RCVD状态，此时不同的连接请求会被放在<strong>半连接队列</strong>里，三次握手完成后的连接请求被放在<strong>全连接队列</strong>里。</li></ul><h2 id="连接释放">2 连接释放</h2><p>连接释放的过程也就是常说的“四次挥手”：<br />P.S. <em>图中以客户端发起释放请求为例</em></p><ol type="1"><li>客户端发送释放请求，将FIN（终止位）置1，表示客户端已经发完数据，请求释放；</li><li>服务器发一个ACK报文，确认号ack为u+1，这时从客户端到服务器的连接被释放，处于<strong>半关闭状态</strong>；</li><li>如果服务器也要断开连接，就向客户端发送连接释放报文（FIN=1）；</li><li>客户端发送一个应答报文，序列号seq为u+1，等待一段时间（2MSL）确保服务器收到ACK报文，之后关闭连接。</li></ol><p><img src="https://img-blog.csdnimg.cn/20190920223118842.png" alt="图片源自百度" /><br />客户端之所以要等待2MSL时间才关闭，有两个原因：</p><ul><li>一旦服务器没有收到ACK报文，服务器就会重发FIN报文，客户端再次收到FIN报文，就知道之前发送的ACK报文丢失，会重置时间等待计时器为2MSL并重传ACK报文。<br />如果没有这段等待时间，万一服务器没有正常接收ACK报文，接下来重传的FIN报文段就无法到达客户端，服务器无法正常关闭。</li><li>客户端发完最后一个ACK报文，经过2MSL，本次连接产生的报文都会从网络中消失，避免下一次新连接出现本次旧的连接请求报文段。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈与单调队列</title>
      <link href="/2019/01/03/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2019/01/03/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈">单调栈</h2><p>对无重复元素的数组<span class="math inline">\([3,2,1,7,0,4,5,6]\)</span>，求左侧和右侧第一个比<code>nums[i]</code>大（小）的元素索引：<br />对于greater，左侧的答案为<span class="math inline">\([-1,0,1,-1,3,3,3,3]\)</span>，右侧的答案为<span class="math inline">\([3,3,3,-1,5,6,7,-1]\)</span>；<br />对于smaller，左侧的答案为<span class="math inline">\([-1,-1,-1,2,-1,4,5,6]\)</span>，右侧的答案为<span class="math inline">\([1,2,4,4,-1,-1,-1,-1]\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组中无重复值 first存左侧索引 second存右侧索引</span></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">monotonousStack</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// store index</span></span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; <span class="built_in">ans</span>(nums.<span class="built_in">size</span>());  <span class="comment">// return index</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 求smaller. 若需greater, 改为 nums[i] &gt; nums[s.top()]</span></span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; nums[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            ans[idx].first = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">            ans[idx].second = i;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        ans[idx].first = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        ans[idx].second = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果数组中存在重复元素，比如<span class="math inline">\([3,2,3,4,4,3,1]\)</span>：<br />对于greater，左侧的答案为<span class="math inline">\([-1,0,-1,-1,-1,4,5]\)</span>，右侧的答案为<span class="math inline">\([3,2,3,-1,-1,-1,-1]\)</span>；<br />对于smaller，左侧的答案为<span class="math inline">\([-1,-1,1,2,2,1,-1]\)</span>，右侧的答案为<span class="math inline">\([1,6,6,5,5,6,-1]\)</span></p><p>对于有重复元素，如果直接使用上述无重元素的代码，有以下情况：</p><ol type="1"><li><code>nums[i] &lt; nums[s.top()]</code>：左侧变为<span class="math inline">\([-1,-1,1,2,3,2,-1]\)</span>，即左侧第一个小于等于<code>nums[i]</code>的元素位置，不再是严格小于；右侧不变，仍然严格小于</li><li><code>nums[i] &lt;= nums[s.top()]</code>：左侧不变，仍然严格小于；右侧变为<span class="math inline">\([1,6,5,4,5,6,-1]\)</span>，即右侧第一个小于等于<code>nums[i]</code>的元素位置，不再是严格小于</li><li><code>nums[i] &gt; nums[s.top()]</code>：左侧变为<span class="math inline">\([-1,0,0,-1,3,4,5]\)</span>，即左侧第一个大于等于<code>nums[i]</code>的元素位置，不再是严格大于；右侧不变，仍然严格大于</li><li><code>nums[i] &gt;= nums[s.top()]</code>：左侧不变，仍然严格大于；右侧变为<span class="math inline">\([2,2,3,4,-1,-1,-1]\)</span>，即右侧第一个大于等于<code>nums[i]</code>的元素位置，不再是严格大于</li></ol><h2 id="单调队列">单调队列</h2><p>单调队列主要用来解决: 数组中所有长度为<span class="math inline">\(k\)</span>的区间最值问题.</p><p><a href="https://github.com/EIMadrigal/Recap/blob/main/Templates">实现</a></p><h2 id="ref">Ref</h2><p><a href="https://www.bilibili.com/video/BV1sr4y1X7AN">1:34:00开始</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络FAQ</title>
      <link href="/2019/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20FAQ/"/>
      <url>/2019/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20FAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="tcp和udp区别">TCP和UDP区别</h2><ul><li>TCP面向连接，提供可靠传输，收发数据前要3次握手建立连接，使用ACK对收发数据进行确认；UDP是无连接协议，不管对方是否收到或收到的数据是否正确</li><li>TCP提供流量控制和拥塞控制，UDP无</li><li>TCP对系统资源的要求高于UDP，因此速度稍慢</li><li>TCP数据包没有边界，会出现粘包问题，UDP包是独立的，没有粘包问题</li><li>应用时如果强调数据的完整性和正确性应用TCP，强调性能和速度时用UDP</li></ul><h2 id="tcp连接">TCP连接</h2><p>建立TCP连接的过程需要使用一些系统调用</p><h2 id="tcp可靠传输">TCP可靠传输</h2><ul><li>校验和：伪首部+TCP header二进制相加取反</li><li>seq + ack：接收方按序组织，避免重复，确保收到所有Segments</li><li><a href="https://stackoverflow.com/questions/12956685">超时重传</a>：发送方维护超时时间，没有收到ack就重传，即ARQ（包括停等，go back N，选择重传）。RTO时间采用指数回退，重传超过一定次数（比如8次）就断开连接。</li><li>流量控制：可变大小的滑动窗宽recv_win</li><li>拥塞控制：慢启动，拥塞避免，快速重传，快速恢复<br />发送方维持拥塞窗口cwnd记录网络链路的拥塞程度，发送窗口=min{recv_win, cwnd}</li></ul><ol type="1"><li>慢启动<br />cwnd指数增加{1, 2, 4, 8, 16, ...}，超过阈值时开始拥塞避免算法</li><li>拥塞避免<br />cwnd线性增加</li><li>快速重传<br />要求接收方每收到一个失序的报文段后就立即发出重复确认而不是等待自己发送数据时才捎带确认 发送方只要一连收到三个重复确认就立即重传对方尚未收到的报文段，而不必等待设置的重传计时器到期</li><li>快速恢复<br />当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，为了预防网络拥塞 将拥塞窗口cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法 TCP Tahoe版本与TCP Reno版本的区别：Reno版本在快重传之后采用快恢复算法而不是采用慢开始算法</li></ol><h2 id="udp">UDP</h2><p>UDP对实时性要求高，数据准确性要求不是太高的场合、视频通话、QQ主要UDP为主，TCP为辅 应用场景：实时音视频传输，DNS协议</p><ul><li>对延迟要求高，可靠性要求低，无法忍受重传，需要看到实时的图像和声音，中间丢一帧完全没事。</li><li>网络非常可靠，不需要考虑UDP丢包的问题。</li><li>NAT穿透只能用UDP</li></ul><h2 id="https">HTTPS</h2><p>HTTP协议存在安全问题：</p><ul><li>信息明文传输, 不提供数据加密, 可能被窃听</li><li>未验证通信双方身份, 可能伪装</li><li>未验证报文完整性, 可能篡改</li></ul><p>为了解决上述问题, HTTPS在HTTP的基础上增加了SSL/TLS传输层, 进行安全传输.</p><ul><li>加密: 混合加密方式. 非对称加密传输session key, 对称加密传输信息. 非对称加密需要公钥和私钥，公钥用来加密，私钥用来解密. 安全，不怕泄漏, 速度慢. 常用算法包括RSA，ECC，DSA. 对称加密计算量小，算法速度快，加密效率高, 密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲, 常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES.</li><li>认证: 数字证书验证双方身份. 权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</li><li>完整性保护:</li></ul><p>具体细节可以参考<a href="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂HTTPS的加密原理</a>和<a href="https://www.cnblogs.com/wqhwe/p/5407468.html">HTTP与HTTPS的区别</a>.</p><p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p><ol type="1"><li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li><li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。服务器第一次传给客户端的公钥其实包含在CA对网站信息进行加密的数字证书中</li><li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li><li>Web服务器利用自己的私钥解密出会话密钥。</li><li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li></ol><p>客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）</p><h2 id="tcp异常连接">TCP异常连接</h2><ol type="1"><li>未开启TCP keepalive，双方一直没有数据交互，客户端<strong>主机崩溃</strong>：服务器无法感知客户端崩溃，其TCP连接会一直处于<code>ESTABLISHED</code>状态，直到服务端重启进程。</li><li>未开启TCP keepalive，双方一直没有数据交互，客户端<strong>进程崩溃</strong>：客户端OS能够感知到进程崩溃，发送FIN报文，正常进行四次挥手。</li><li>未开启TCP keepalive，有数据交互，客户端<strong>主机崩溃</strong>，迅速重启：服务端发送的报文无法得到响应，触发超时重传机制，客户端重启完成后接收重传报文。此时如果客户端没有进程监听该报文的目标端口，客户端回复RST报文，断开连接；如果有进程监听，但是之前的TCP连接的数据结构已经丢失，客户端内核协议栈会发现找不到该TCP连接的socket结构体，回复RST报文，断开连接。</li><li>未开启TCP keepalive，有数据交互，客户端<strong>主机崩溃</strong>，一直没有重启：服务端超时重传达到最大次数后，内核判定该连接有问题，通过socket接口通知应用程序，断开连接。</li></ol><h2 id="url解析">URL解析</h2><ol type="1"><li>域名解析，host使用DNS协议将URL解析为相应的IP</li><li>host与server通过三次握手建立TCP连接</li><li>浏览器发送HTTP请求</li><li>服务器响应请求</li><li>host接收响应并渲染</li></ol><p>子网中第一个地址是网络地址，最后一个地址是广播地址</p><p>RST 1. 直接丢弃缓冲区中的包发送RST 2. 收到RST包不必回复ACK包</p><p>常见的发RST的情况：https://zhuanlan.zhihu.com/p/30791159 1. SYN包试图连接一个没有任何服务监听的端口 2. 收到了之前连接的包，但是该连接已经关闭</p><p>SYN泛洪攻击</p><p>服务器收到SYN连接请求后，分配缓冲区等资源，初始化连接变量。 如果客户端的第三次ACK没有收到，服务器首先会重传SYNACK，多次重传后服务器通常会在1min后终止半连接状态并且回收资源。</p><p>客户端可以发送大量的SYN段耗尽服务器的资源，合法的请求得不到响应，就是一种典型的DoS(Denial of Service)攻击。</p><p>一般通过SYN cookies预防：对比第一次和第三次握手hash值是否相同</p><p>HTTP状态码<br />200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 400 - 请求无效 403 - 禁止访问 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误</p><p>https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way</p><h2 id="http请求">HTTP请求</h2><ol type="1"><li>域名解析：首先在浏览器和OS的DNS缓存中查找，如果没有，向DNS服务器发起域名解析请求；</li><li>建立TCP连接；</li><li>发起HTTP请求；</li><li>服务器响应，浏览器获得并解析HTML，请求图片等资源，向用户渲染页面。</li></ol><h2 id="条件变量">条件变量</h2><p>用于多线程间状态的同步，控制其交替执行的先后顺序，条件不满足时相关线程阻塞，满足时唤醒，个人认为原理类似于线程间共享的全局变量，至于该变量如何工作还有待考究。</p><p>锁是用来保护共享资源，但是这两究竟有什么区别，为什么要同时使用，待确定。</p><p>lock guard构造时加锁，局部作用域结束析构释放锁，不够灵活。因此用unique lock</p><p>shared和weak区别 循环引用导致内存泄漏</p><p>GET：完整请求一个资源，没有请求数据 POST：提交表单，文件等</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notations</title>
      <link href="/2018/12/24/Notations/"/>
      <url>/2018/12/24/Notations/</url>
      
        <content type="html"><![CDATA[<p>下面四种记号是为了建立函数间的相对级别。 CLRS上的一张图很直观： <img src="https://img-blog.csdn.net/20180517130818654" alt="这里写图片描述" /></p><h2 id="大o记号"><strong>大O记号</strong></h2><p>定义：如果存在正常数<span class="math inline">\(c\)</span>和<span class="math inline">\(n_0\)</span>，使得当<span class="math inline">\(N\ge n_o\)</span>时<span class="math inline">\(T(N)\le cf(N)\)</span>，记<span class="math inline">\(T(N)=O(f(N))\)</span>。</p><p>举个栗子： 当<span class="math inline">\(N &lt; 1000\)</span>时，<span class="math inline">\(1000N\gt N^2\)</span>，但<span class="math inline">\(N^2\)</span>增长率更大，所以最终<span class="math inline">\(N^2\)</span>会更大，即<span class="math inline">\(O(N^2)=1000N\)</span>。</p><p>也就是说，总会存在某个点<span class="math inline">\(n_0\)</span>，从这个点以后<span class="math inline">\(cf(N)\)</span>至少和<span class="math inline">\(T(N)\)</span>一样大，忽略常数因子，即<span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>小于等于<span class="math inline">\(f(N)\)</span>的增长率。</p><p>那么为什么这个常数因子<span class="math inline">\(c\)</span>可以忽略呢？ 当<span class="math inline">\(N\ge n_o\)</span>时，<span class="math inline">\(T(N)\le cf(N)\)</span>，也就是<span class="math inline">\(\frac{T(N)}{f(N)}\le c\)</span>。此时如果<span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>大于<span class="math inline">\(f(N)\)</span>的增长率，那么<span class="math inline">\(\frac{T(N)}{f(N)}\)</span>不可能小于某个常数，也就是<span class="math inline">\(c\)</span>不存在，与我们的前提条件矛盾，所以说忽略掉常数因子后，<span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>仍然小于等于<span class="math inline">\(f(N)\)</span>的增长率。</p><p>那么既然<span class="math inline">\(T(N)\)</span>是以不快于<span class="math inline">\(f(N)\)</span>的速度增长，也就可以说<span class="math inline">\(f(N)\)</span>是<span class="math inline">\(T(N)\)</span>的一个上界(upper bound)，即<strong>最坏情况</strong>。</p><h2 id="omega记号"><strong><span class="math inline">\(\Omega\)</span>记号</strong></h2><p>定义：如果存在正常数<span class="math inline">\(c\)</span>和<span class="math inline">\(n_0\)</span>，使得当<span class="math inline">\(N\ge n_o\)</span>时<span class="math inline">\(T(N)\ge cg(n)\)</span>，记<span class="math inline">\(T(N)=\Omega(g(n))\)</span>。</p><p>与上述大O的分析类似，可知： <span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>大于等于<span class="math inline">\(g(N)\)</span>的增长率，<span class="math inline">\(g(N)\)</span>是<span class="math inline">\(T(N)\)</span>的一个下界(lower bound)，即<strong>最好情况</strong>。</p><h2 id="theta记号"><strong><span class="math inline">\(\Theta\)</span>记号</strong></h2><p>定义：当且仅当<span class="math inline">\(T(N)=\Omega(h(n))\)</span>、<span class="math inline">\(T(N)=O(h(n))\)</span>时， <span class="math inline">\(T(N)=\Theta(f(n))\)</span>。</p><p>那么这个就是说<span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>等于<span class="math inline">\(h(N)\)</span>的增长率，即<strong>最坏情况和最好情况相同</strong>。</p><h2 id="小o记号"><strong>小o记号</strong></h2><p>定义：若<span class="math inline">\(T(N)=O(p(n))\)</span>且<span class="math inline">\(T(N)\neq\Theta(p(n))\)</span>时， <span class="math inline">\(T(N)=o(f(n))\)</span>。</p><p>与大O不同，小o表示<span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>小于<span class="math inline">\(p(N)\)</span>的增长率，不包括等于。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nakamori Akina</title>
      <link href="/2018/11/18/Nakamori%20Akina/"/>
      <url>/2018/11/18/Nakamori%20Akina/</url>
      
        <content type="html"><![CDATA[<p>听过中森明菜的歌以后，一直想写点什么。恰好前段时间看过她的一个<a href="https://b23.tv/av13810011">访谈</a>，节目里已经39岁左右的明菜看着已经有些衰老，但是那份属于她的天真却好像要溢出屏幕。</p><p>节目里主持人问她为什么不用手机还在用电话卡，像是昭和时代穿越来的一样，她回答说自己没什么朋友去联系，一个人也不怎么去其他地方。看到这，我马上想到了《难破船》的热评：</p><figure><img src="https://img-blog.csdnimg.cn/9a512b2e008947fd8936552a0aafe7dc.png" alt="" /><figcaption>网抑云热评</figcaption></figure><p>你可能很难想象患有严重社交障碍的她当年是怎样的风姿绰约：</p><ul><li>安利1：李健的《车站》大家应该都听过，翻唱的水准很高，不过我还是更喜欢<a href="https://b23.tv/av5270243">《駅》</a>，这是竹内玛莉亚专门为中森明菜创作的歌曲；</li><li>安利2：<a href="https://b23.tv/av7033508">《难破船》</a>的混剪视频，惊为天人。</li></ul><p>上世纪70年代的日本乐坛是山口百惠的天下，然而在1980年，只有20岁的山口百惠突然宣布退出娱乐圈，随后与三浦友和结婚，如此退隐使得日本乐坛出现了一片巨大的空白。</p><p>中森明菜通过选秀节目出道，甜美的外表、独特的嗓音加上经纪公司的宣传，她迅速蹿红，被誉为继山口百惠之后新的“歌姬”。</p><p>80年代中期，凭借《ミ・アモーレ》和《DESIRE -情热-》，中森明菜连续两年获得日本唱片大赏。热情的舞台形象和不俗的唱功使得她成为了当时日本乐坛无可动摇的霸主，甚至被人称为“昭和时代的Lady Gaga”。后来据徐克回忆：《倩女幽魂》的聂小倩本来是邀请中森明菜扮演的，不过被拒绝了。</p><p>与在事业上的蒸蒸日上不同的是，她与近藤真彦的恋情危机开始逐渐爆发。近藤被誉为“日本第一渣男”，与松田圣子、梅艳芳等女星之间有着无数绯闻，媒体的报导更是推波助澜，中森明菜受到了很大的打击。也正是在这时候，她发布了单曲《难破船》，曲风开始变得哀伤深沉。</p><p>爱情的坎坷加上家人的天坑，中森明菜于1989年在近藤的住所割腕自杀，不过在送往医院后得救。在这一年的最后一天，为了挽救不断下滑的人气，近藤哄骗着明菜说会在记者会上宣布两人结婚，并特意在会场挂上了金屏风（婚礼常用装饰）。</p><p>傻傻的明菜出席之后，近藤在记者会上翻脸，把所有错误全部归因于明菜一个人，并且声称明菜的自杀与自己丝毫没有关系，也完全没有和明菜结婚的打算。而深陷爱情之中的明菜一个人承担了所有过错，在发布会上道歉。</p><p>之后近藤迅速与某富家女子成婚，并且利用权势限制明菜的发展。</p><p>回过头来再去听《难破船》，只觉得情到深处无怨尤：</p><blockquote><p>折れた翼広げたまま<br />展开折断的翅膀</p><p>あなたの上に落ちて行きたい<br />好想坠落在你身上</p><p>海の底へ沈んだなら<br />如果能沉入海底</p><p>泣きたいだけ抱いてほしい<br />好想你能拥抱我到尽情哭泣</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Arts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>敏感词过滤</title>
      <link href="/2018/09/24/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"/>
      <url>/2018/09/24/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="需求">需求</h2><p>在一个非常大的文件中存在着很多敏感词，现在需要将这些敏感词全部替换为*，时间响应要求较高（几百毫秒）。</p><h2 id="思路">思路</h2><p>要做这个事，首先需要知道哪些词是敏感的，因此需要有一个敏感词词库。<br />例如文本是"abcdefghi"，长度为<span class="math inline">\(n\)</span>，敏感词库是{"de", "bca", "bcf"}，词库长度为<span class="math inline">\(l_1\)</span>，每个词的长度为<span class="math inline">\(l_2\)</span>。</p><p>比较直接的做法：对每个敏感词，利用暴力匹配或KMP算法查找并作替换，这些单模式串匹配算法的缺点很明显，需要多次扫描文本<span class="math inline">\(O(n(l_1+l_2))\)</span>。</p><p>目前主流的做法主要是多模式串匹配算法：<br />1. Trie树：将敏感词库建树，用3个指针去搞，<a href="https://zhuanlan.zhihu.com/p/65115496">具体在这里</a>，查询复杂度<span class="math inline">\(O(nl_2)\)</span>，建树复杂度<span class="math inline">\(O(l_1l_2)\)</span>。 2. AC自动机：是Trie树的扩展，增加了一个fail指针，避免指针回溯，<a href="https://www.cnblogs.com/shengyang17/p/13719653.html">具体在这里</a>，复杂度一般优于Trie树。 3. DFA确定有穷自动机：利用状态转移，<a href="https://blog.csdn.net/weixin_36586120/article/details/113482752">具体在这里</a>，时间复杂度<span class="math inline">\(O(n)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Onedrive File Open Problem</title>
      <link href="/2018/08/16/Onedrive%20File%20Open%20Problem/"/>
      <url>/2018/08/16/Onedrive%20File%20Open%20Problem/</url>
      
        <content type="html"><![CDATA[<p>在用Onenote 2016写笔记时，同步到Onedrive后就变成了Internet快捷方式，而且直接打开时会出现提示：<br /><img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108200433406-2018295429.png" alt="image" /></p><h2 id="原因">原因</h2><p>用Onenote客户端在Onedrive上创建的笔记本是一种特殊文件，用Onedrive客户端将文件同步到本地的话，就会变成Internet快捷方式，不能直接打开；<br />但是如果用Onedrive网页版的话，就可以正常使用。</p><h2 id="解决">解决</h2><p>在Onenote客户端，“文件”-&gt;“打开”，找到你的笔记本，打开即可看到内容。</p><h2 id="参考">参考</h2><p><a href="http://cn.onenotegem.com/24120352653838239064/-onedrive-onenote-internet-url">onedrive-onenote-internet-url</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON Introduction</title>
      <link href="/2018/07/14/JSON%20Introduction/"/>
      <url>/2018/07/14/JSON%20Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="理解">理解</h2><p>JSON（JavaScript Object Notation），一种轻量级的数据交换格式，基于JS的一个子集，但其数据格式与语言无关。<br />通俗来说，如果你是PHP，要和JS互相发送信息，那么这时候就可以先将PHP发的信息转为JSON，再发给JS。<br />那么有人要问了，为什么自己不能直接学会PHP和JS，直接先将PHP的信息转为JS，不就OK了？<br />没错，但是如果你要发给C++，发给Python，发给其他各种各样的语言呢？难道你要学会所有语言，再去发信息？显然不可能。<br />所以： &gt; You are now able to learn only one programming language, in addition to the communications language, JSON, in order to communicate with ANY other programming language.</p><p>但要注意：JSON并不是编程语言，只是一种规定的数据格式，这种格式的数据便于计算机处理。<br />JSON比较规范的定义是： &gt; JSON is the text grammer/format for the information that is being sent between programming language.</p><p>除了JSON以外，还有一种用于交流的数据格式，XML（Extensiable Markup Language）。但是JSON更加流行。</p><h2 id="格式">格式</h2><p>JSON有两种结构：<br />1，Object：对象用<code>&#123;</code>开始，用<code>&#125;</code>结束，对象中的一系列非排序的pair中，名称和值之间用<code>:</code>分开；<br />2，Array：数组用<code>[</code>开始，用<code>]</code>结束，数组成员之间用<code>,</code>分开。<br />名称（name）是字符串；<br />值（value）可以是：字符串、数值、对象、布尔值、数组或者<code>null</code>。<br />字符串：用<code>""</code>表示；<br />数值：可以是小数或负数，也可用<code>e</code>、<code>E</code>表示为指数格式；<br />对象：就是上述的Object；<br />布尔值：<code>true</code>或<code>false</code>；<br />数组：就是上述的Array。<br />举个栗子： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object &amp; Array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Andrew&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="string">&quot;36&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;number&quot;</span>:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;12345678&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;fax&quot;</span>: <span class="string">&quot;87654321&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;address&quot;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;Beijing&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;10000&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考">参考</h2><p><a href="https://www.quora.com/What-is-JSON-2/answers/50464172?share=8534699f&amp;srid=5OZ0m">quora</a><br /><a href="https://zh.wikipedia.org/wiki/JSON">wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System Call</title>
      <link href="/2018/07/02/System%20Call/"/>
      <url>/2018/07/02/System%20Call/</url>
      
        <content type="html"><![CDATA[<h2 id="内容">内容</h2><p>设计系统调用，将系统的相关信息(CPU型号、操作系统的版本号、系统中的进程等类似于Windows的任务管理器的信息)以文本形式列表显示于屏幕，并编写用户程序予以验证。</p><h2 id="思想">思想</h2><ul><li>系统调用是应用程序和操作系统内核之间的功能接口，可以使用户使用操作系统提供的有关设备管理、输入输出系统、文件系统和进程控制、通信以及存储管理等方面的功能，不必了解系统程序的内部结构和有关硬件细节，从而减轻用户负担、保护系统以及提高系统资源利用率的作用。</li><li>模块是在内核空间运行的程序，实际上是一种目标文件，不能单独运行但其代码可在运行时链接到系统中作为内核的一部分运行或卸载。Linux内核模块是一个编译好的、具有特定格式的独立目标文件，用户可以通过系统提供的一组与模块相关的命令将模块加载进内核，当内核模块被加载后，有如下特点：</li><li>与内核一起运行在相同的内核态和内核地址空间；</li><li>运行时与内核具有同样的特权级；</li><li>可方便地访问内核中的各种数据结构。</li><li>内核模块还可以很容易地被移出内核，当用户不再需要某模块功能时，可以从内核卸载以节省系统主存开销。</li><li>用户修改代码后，只需重新编译加载模块，不必重新编译内核和引导系统。</li></ul><h2 id="基础知识">基础知识</h2><ul><li>内核模块编程与用户态编程的区别：</li></ul><ol type="1"><li>内核模块编程不能使用C函数库，内核模块只能使用一些内核函数。比如，输出信息时使用内核函数<code>printk</code>，而不是标准库函数<code>printf</code>。</li><li>内核模块代码运行在核心态，这意味着函数使用的栈是核心栈，这个空间非常有限，一般是4KB或者8KB，所以不能定义占用很大空间的自动变量。</li><li>内核代码为了节省开销，不能使用浮点运算。</li></ol><ul><li>典型内核模块组成：</li></ul><ol type="1"><li>头文件声明。其中<code>module.h</code>和<code>init.h</code>是必不可少的。<code>Module.h</code>包含加载模块时需要的函数和符号定义；<code>init.h</code>包含模块初始化和清理函数的定义。如果在加载时允许用户传递参数，模块中还应包含<code>moduleparam.h</code>头文件。</li><li>模块许可声明。从内核2.4.10版本开始，模块必须通过<code>MODULE_LICENSE</code>宏声明此模块的许可证，否则在加载模块时会显示"kernel tainted(内核被污染)"的警告信息。从<code>linux/module.h</code>文件中可以看到，被内核接受的许可证有GPL、GPL v2、GPL and additional rights、Dual BSD/GPL、Dual MPL/GPL、Dual MIT/GPL和Proprietaty。</li><li>初始化和清理函数声明。<br />内核模块必须调用宏<code>module_init</code>和<code>module_exit</code>去注册初始化和清理函数。初始化和清理函数必须在宏<code>module_init</code>和<code>module_exit</code>使用前定义，否则会出现编译错误。这两个函数配对使用，例如当初始化函数申请了一个资源，那么清理函数就应该释放这个资源，使得模块不留下任何副作用。除了模块初始化函数和清理函数，还可以根据需要设计编写其它函数。</li></ol><ul><li>proc文件系统 在linux操作系统中，提供了一套在用户态检查内核状态和系统特征的机制，就是进程文件系统(process file system)。<br />Proc文件系统将进程信息、系统的硬件信息(包括CPU、内存状态及网卡等各种硬件设备)、系统相关机制(中断、I/O)等内容全部映射为虚拟的linux文件。它以一种特殊的文件系统的方式，为访问系统内核数据的操作提供接口。这些文件的内容都不存在于任何存储设备上，而是在读/写的时候才根据系统中的有关信息生成出来，或者映射到系统中的有关变量或者数据结构。<br />系统中当前运行的每一个每一个进程都有一个对应的目录在/proc下，以进程的ID为目录名：<br /><img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108195514838-1179859005.png" alt="image" /></li></ul><p>除了与进程有关的子目录，/proc还有一些内核信息的目录：<br /><img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108195533943-914673534.png" alt="image" /></p><h2 id="fork">fork()</h2><p><code>fork()</code>系统调用用来创建一个子进程, 为了避免多余开销, 创建子进程时并不会立即将父进程的内存页面拷贝一份, Linux kernel将所有内存页面标记为只读并由父子进程共享, 只有当需要写入这些页面时才进行拷贝, 即所谓的Copy-on-Write.</p><h2 id="实现">实现</h2><p><a href="https://github.com/EIMadrigal/system_call">源代码、实现过程及结果</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程软中断通信</title>
      <link href="/2018/06/30/%E8%BF%9B%E7%A8%8B%E8%BD%AF%E4%B8%AD%E6%96%AD%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/06/30/%E8%BF%9B%E7%A8%8B%E8%BD%AF%E4%B8%AD%E6%96%AD%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>使用系统调用fork()创建两个子进程，再用系统调用signal()让父进程捕捉键盘上发出的中断信号（即按ctrl+c键），当父进程接收到这两个软中断的某一个后，父进程用系统调用kill()向两个子进程分别发出整数值为16和17软中断信号，子进程获得对应软中断信号，然后分别输出下列信息后终止：<br />Child process 1 is killed by parent !!<br />Child process 2 is killed by parent !!<br />父进程调用wait()函数等待两个子进程终止后，输入以下信息，结束进程执行：<br />Parent process is killed!!</p><p>流程图：<br /><img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194427772-238897206.png" alt="image" /></p><h2 id="实现">实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> wait_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid1,pid2;</span><br><span class="line"></span><br><span class="line">    signal(<span class="number">2</span>,stop1);   <span class="comment">//signal 3 is ctrl+\,signal 2 is ctrl+c</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pid1 = fork()) == <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(pid1 &gt; <span class="number">0</span>)      <span class="comment">//now is in the parent process</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((pid2 = fork()) == <span class="number">-1</span>);   <span class="comment">//creat child process 2</span></span><br><span class="line">        <span class="keyword">if</span>(pid2 &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">5</span>);       <span class="comment">//sleep函数被信号中断后，就会导致延时失效，直接跳到sleep的下一行</span></span><br><span class="line">            kill(pid1,<span class="number">16</span>);  <span class="comment">//kill process1,send 16</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            kill(pid2,<span class="number">17</span>); <span class="comment">//kill process2, send 17</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nParent process is killed!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            signal(<span class="number">17</span>,stop2);   <span class="comment">//wait for 2 about 17</span></span><br><span class="line">            <span class="keyword">while</span>(wait_flag)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nChild process 2 is killed by parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        signal(<span class="number">16</span>,stop2);</span><br><span class="line">        <span class="keyword">while</span>(wait_flag)</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nChild process 1 is killed by parent!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//execute normally and quit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nParent process catches the interruption signal!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nChild process catches the interruption signal!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果">结果</h2><p>5s内没有按终止键：<br /><img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194549740-1526578900.png" alt="image" /></p><p>5s内按下ctrl+c：<br /><img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194609530-785223659.png" alt="image" /></p><h2 id="附">附</h2><p>系统调用signal(sig,function)：捕捉中断信号sig后执行function规定的操作。<br />参数定义：<code>int sig</code>，<code>void* func()</code><br />sig共有19个值：<br /><img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194710456-891175051.png" alt="image" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting Algorithms</title>
      <link href="/2018/05/25/Sorting/"/>
      <url>/2018/05/25/Sorting/</url>
      
        <content type="html"><![CDATA[<h2 id="bubble-sort">Bubble Sort</h2><p>冒泡排序也许是大部分人CS生涯里学到的第一种排序算法，它的基本思想是：依次比较两个相邻记录的关键字，如果逆序就进行交换，直到没有逆序的记录。</p><p>每一趟排序可以将前<span class="math inline">\(i\)</span>个元素的最大值冒泡到最后，因此共需<span class="math inline">\(n-1\)</span>趟；每一趟都要比较<span class="math inline">\(j\)</span>和<span class="math inline">\(j+1\)</span>的值，因此<span class="math inline">\(j\)</span>取值为<span class="math inline">\([0,i-1]\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[k] &gt; nums[k + <span class="number">1</span>])</span><br><span class="line">            <span class="built_in">swap</span>(nums[k], nums[k + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bubble</span>(nums, l, r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序也是可以稍稍优化的：试想如果序列是<span class="math inline">\([2,1,3,4,5]\)</span>，其实我们只需交换前两个元素，即第一趟有交换，走完第二趟发现没有交换时就可以结束了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> has_swap = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; has_swap; --i) &#123;</span><br><span class="line">        has_swap = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">                has_swap = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于最后优化的代码，可以看到：<br />最好的情况就是待排序列已经全部有序，这样要进行<span class="math inline">\(n-1\)</span>次比较，时间复杂度O(n)；<br />最坏的情况就是待排序列全部逆序，需要进行n(n-1)/2次比较，并且还有等数量级的交换，时间复杂度<span class="math inline">\(O(n^2)\)</span>。稳定。</p><h2 id="selection-sort">Selection Sort</h2><p>所谓选择排序，就是持续选择<span class="math inline">\([i+1,n-1]\)</span>中最小的元素并与<span class="math inline">\(i\)</span>交换，因此前面的部分必然全局有序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_id = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[min_id]) min_id = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[min_id]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序需要N次交换以及<span class="math inline">\(\frac{N^2}{2}\)</span>次比较，数据移动次数与数组大小呈线性关系，移动次数是最少的。 时间复杂度<span class="math inline">\(O(n^2)\)</span>，不稳定。</p><h2 id="insertion-sort">Insertion Sort</h2><p>插入排序其实就是打牌：每次拿到一张牌<span class="math inline">\(i\)</span>，从<span class="math inline">\(i-1\)</span>开始向前扫描寻找第一个使得<span class="math inline">\(cur&gt;nums[j]\)</span>的位置<span class="math inline">\(j\)</span>，找到位置后将<span class="math inline">\([j+1,i-1]\)</span>所有元素向后移一位，接着将拿到的牌放到<span class="math inline">\(j+1\)</span>。不能保证前面的部分全局有序，因为后面拿到的牌可能是最小的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; cur &lt; nums[j]) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：元素全部有序，<span class="math inline">\(N-1\)</span>次比较、<span class="math inline">\(0\)</span>次交换；复杂度<span class="math inline">\(O(n)\)</span>。<br />最坏情况：元素全部逆序，大约<span class="math inline">\(\frac{N^2}{2}\)</span>次比较和<span class="math inline">\(\frac{N^2}{2}\)</span>次交换，复杂度<span class="math inline">\(O(n^2)\)</span>。<br />平均情况下：大约<span class="math inline">\(\frac{N^2}{4}\)</span>次比较和<span class="math inline">\(\frac{N^2}{4}\)</span>次交换，复杂度<span class="math inline">\(O(n^2)\)</span>。稳定。</p><p>折半插入排序<br />直接插入排序前面的子序列是有序的，所以如果是顺序表，那么可以先折半查找出元素的待插入位置，再统一移动该位置之后的所有元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void insertionSortOptimized(int A[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    //将A[i]插入到合适位置</span><br><span class="line">    for (int i = 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp = A[i];</span><br><span class="line">        int low = 0, high = i - 1;</span><br><span class="line">        while (low &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = (low + high) &gt;&gt; 1;</span><br><span class="line">            if (A[mid] &gt; tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                high = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                low = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //统一后移元素</span><br><span class="line">        for (int j = i - 1; j &gt;= low; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            A[j + 1] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        A[low] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能：折半插入排序将元素比较次数减少为<span class="math inline">\(O(nlogn)\)</span>，但是移动次数依然是<span class="math inline">\(O(n^2)\)</span>，故总的时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p><h2 id="shell-sort">Shell Sort</h2><p>基本思想：将待排序表分为若干<span class="math inline">\(A[i], A[i+d], A[i+2d]...\)</span>子表，<span class="math inline">\(d\)</span>称为增量，对这些子表执行直接插入排序，当整个表中的元素“基本有序”时，对整个表来一次直接插入排序。</p><p>希尔排序(Shell Sort)是基于插入排序的一种<strong>不稳定</strong>排序方法。<br />1，将整个序列分为h个子序列；<br />2，第一趟将每个子序列进行插入排序；<br />3，第二趟将增量缩小，重复2；<br />4，直至增量为1，就是简单插入排序。</p><p>eg:<br /><img src="20180707130824188.png" alt="这里写图片描述" /><br /><img src="20180707130836718.png" alt="这里写图片描述" /></p><p>希尔排序最优时间复杂度<span class="math inline">\(O(n)\)</span>，最差情况下也突破了平方级别的运行时间。<br />对于最差情况，之前的冒泡、选择要消除逆序，采用交换相邻元素的方法，也就是每次只能消除一个逆序，那么希尔每次交换隔得很远的元素，每次可以消除多个逆序，这样就节省了大量的交换时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = n &gt;&gt; <span class="number">1</span>; d &gt; <span class="number">0</span>; d &gt;&gt;= <span class="number">1</span>) <span class="comment">// 增量选之前的一半</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; n; ++i)  <span class="comment">// 将nums[i]插入有序子表</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - d]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="comment">// 查找插入位置</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - d; j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; nums[j]; j -= d)</span><br><span class="line">                    nums[j + d] = nums[j];  <span class="comment">// 后移</span></span><br><span class="line">                nums[j + d] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能：时间复杂度依赖于选取的增量序列，大约是<span class="math inline">\(O(n^{1.3})\)</span>，最坏是<span class="math inline">\(O(n^2)\)</span>。</p><h2 id="merge-sort">Merge Sort</h2><p>归并排序是将若干有序子表归并为一个新的有序表的算法. 初始时数组可以看作<span class="math inline">\(n\)</span>个有序子表, 一趟2路归并排序可以将其合并为<span class="math inline">\(n/2\)</span>个有序子表:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(high - low + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;  <span class="comment">// 左有序和右有序开始位置</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &lt; num[j]) &#123;</span><br><span class="line">            tmp[k++] = num[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = num[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">        tmp[k++] = num[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">        tmp[k++] = num[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        num[low + i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt;= high)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(num, low, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(num, mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="built_in">merge</span>(num, low, mid, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序需要辅助数组, 因此空间复杂度为<span class="math inline">\(O(n)\)</span>. 时间复杂度的分析与快排完全类似, 也是<span class="math inline">\(O(nlogn)\)</span>, 不过归并排序是一种稳定的排序算法.</p><p>归并排序一个比较重要的点在于归并时可以做一些逆序对的统计等, 参考如下2题:<br /><a href="https://www.nowcoder.com/questionTerminal/8397609ba7054da382c4599d42e494f3">数组单调和</a><br /><a href="https://www.nowcoder.com/questionTerminal/bb06495cc0154e90bbb18911fd581df6">数组中的逆序对</a></p><h2 id="heap-sort">Heap Sort</h2><p>堆是一种将数组看作complete binary tree的数据结构，分为大顶堆（parent&gt;=children）和小顶堆（parent&lt;=children），由于父结点和孩子结点这种奇妙的大小关系，堆也被用来做排序了...对于一颗完全二叉树，结点<span class="math inline">\(i\)</span>的父结点为<span class="math inline">\((i-1)//2\)</span>，孩子结点为<span class="math inline">\(2i+1,2i+2\)</span>。</p><p>排序前先要建堆，有2种主要的建堆方法（以大顶堆为例）：</p><ol type="1"><li>Top-down<br />Top-down的方式主要通过<code>HeapInsert</code>的方法，从空heap开始，每次插入并向上调整<code>sift_up</code>一个元素，复杂度<span class="math inline">\(O(nlgn)\)</span>。</li><li>Bottom-up<br />Bottom-up的方式主要依赖于一种叫做<code>heapify</code>的操作，你也可以叫它嬉皮化。对某个结点a进行<code>heapify</code>非常简单：对比a以及a两个孩子<span class="math inline">\(c_1,c_2\)</span>的值，如果a是最大的，操作结束；否则将a与<span class="math inline">\(max(c_1,c_2)\)</span>交换，递归直到a变为叶子结点或者a是三者中最大值，<code>heapify</code>操作的复杂度为<span class="math inline">\(O(lgn)\)</span>。<br />可以发现：一次<code>heapify</code>下沉操作<code>sift_down</code>只能保证从a向下交换的路径上的每一棵局部小子树满足堆的性质（即只对原数组的部分位置进行了调整），并不能保证整棵树都满足堆的性质，甚至无法保证向下交换的整条路径满足根结点最大（如<code>[3 2 4 0 1 6 8]</code>对根操作后变为<code>[4 2 8 0 1 6 3]</code>），所以为了建堆，需要从最后一个非叶子结点<span class="math inline">\((n-1-1)//2\)</span>（也即最后一个结点的父结点）开始，对之前的每个结点都进行<code>heapify</code>操作，这样就可以保证整棵树都满足堆的性质。时间复杂度为<span class="math inline">\(O(n)\)</span>，<a href="https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity">How can building a heap be O(n) time complexity?</a><br />那么<code>heapify</code>建堆能不能从前向后进行呢？答案是不能，还是上面那个例子。从前往后最大元素调不到堆顶，从后往前则已经保证了父结点是最大的，因此最大元素可以一直向上调。</li></ol><p>建好堆后，堆顶元素即为最大值，此时将堆顶（数组的第一个元素）和最后一个元素交换，则最后一个元素有序（最大值），但破坏了大顶堆性质，对堆顶元素进行<code>heapify</code>下沉操作（只需<code>heapify</code>前n-1个元素），保持大根堆即可： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inserted num is now at idx and sift up</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_insert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (nums[idx] &gt; nums[(idx - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[idx], nums[(idx - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">        idx = (idx - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在[start, end]范围内对nums[start]向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> maxIdx = start, left = <span class="number">2</span> * start + <span class="number">1</span>, right = <span class="number">2</span> * start + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= end &amp;&amp; nums[left] &gt; nums[maxIdx]) maxIdx = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= end &amp;&amp; nums[right] &gt; nums[maxIdx]) maxIdx = right;</span><br><span class="line">    <span class="keyword">if</span> (maxIdx != start) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[maxIdx]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, maxIdx, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapifyIter</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * start + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxIdx = start, left = <span class="number">2</span> * start + <span class="number">1</span>, right = <span class="number">2</span> * start + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= end &amp;&amp; nums[left] &gt; nums[maxIdx]) maxIdx = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= end &amp;&amp; nums[right] &gt; nums[maxIdx]) maxIdx = right;</span><br><span class="line">        <span class="keyword">if</span> (maxIdx == start) &#123;  <span class="comment">// 父亲最大无法继续下沉</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[maxIdx]);</span><br><span class="line">        start = maxIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIdx = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (lastIdx - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums, i, lastIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">buildMaxHeap</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>heapify</code>方式的堆排序时间复杂度<span class="math inline">\(O(nlogn)\)</span>。<br />一般求前<span class="math inline">\(K\)</span>大元素都采用堆排序，因为只需要调整<span class="math inline">\(K\)</span>次，故<span class="math inline">\(O(nlogK)\)</span>，而快排要将所有元素排完后才能取出前<span class="math inline">\(K\)</span>个。</p><h2 id="quick-sort">Quick Sort</h2><p>快排的核心思想是分治, 选一个<code>pivot</code>使得比<code>pivot</code>小的元素都存储在数组的左边, 比<code>pivot</code>大的元素存储在数组右边, 对左右两个子数组递归调用<code>quickSort</code>. 因此如何partition便成为快排的关键, 可以参考<a href="https://www.bilibili.com/video/BV13g41157hK?p=3">01:40:00开始</a>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * partition nums into two regions: &lt;= &gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * [l, small_idx]: &lt;= pivot</span></span><br><span class="line"><span class="comment"> * [small_idx + 1, i - 1]: &gt; pivot</span></span><br><span class="line"><span class="comment"> * [i, r): unvisited</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">int</span> index = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[index], nums[r]);  <span class="comment">// now the pivot is nums[r]</span></span><br><span class="line">    <span class="keyword">int</span> smallerIndex = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[r]) &#123;  <span class="comment">// nums[i] &lt; nums[r]也可</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[++smallerIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[r], nums[++smallerIndex]);</span><br><span class="line">    <span class="keyword">return</span> smallerIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * partition num into 3 regions: &lt; == &gt; （荷兰国旗问题）</span></span><br><span class="line"><span class="comment"> * @return lowerbound and upperbound of pivot inclusive</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * [l, small_idx]: &lt; pivot</span></span><br><span class="line"><span class="comment"> * [small_idx + 1, i - 1]: == pivot</span></span><br><span class="line"><span class="comment"> * [i, big_idx - 1]: unvisted</span></span><br><span class="line"><span class="comment"> * [big_idx, r): &gt; pivot</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">int</span> index = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[index], nums[r]);  <span class="comment">// now the pivot is nums[r]</span></span><br><span class="line">    <span class="keyword">int</span> smallerIndex = l - <span class="number">1</span>, greaterIndex = r;</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; greaterIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[r]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i++], nums[++smallerIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[r]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[--greaterIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[r], nums[greaterIndex]);</span><br><span class="line">    <span class="keyword">return</span> &#123;++smallerIndex, greaterIndex&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, l, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, pivotIndex + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归，用栈保存要操作的范围的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSortIter</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(low);</span><br><span class="line">    s.<span class="built_in">push</span>(high);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> l = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> pivotPos = <span class="built_in">partition</span>(num, l, r);</span><br><span class="line">        <span class="keyword">if</span> (l &lt; pivotPos - <span class="number">1</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(l);</span><br><span class="line">            s.<span class="built_in">push</span>(pivotPos - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pivotPos + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(pivotPos + <span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">push</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = num[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; num[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        num[low] = num[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; num[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        num[high] = num[low];</span><br><span class="line">    &#125;</span><br><span class="line">    num[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当每次划分的两个子问题规模分别为0和n时, 会触发最坏的时间复杂度<span class="math inline">\(O(n^2)\)</span>. 当两个子问题规模相同时, 时间复杂度最好为<span class="math inline">\(O(nlgn)\)</span>. 假设输入数据的所有排列不是等概率的, 那么为了避免最坏情况的发生, 选择pivot可以<strong>随机</strong>进行, 这样被pivot分开的两个子问题规模会接近<span class="math inline">\(n/2\)</span>. 另外, 快排的时间复杂度中常数因子非常小, 所以是实际中使用最广泛的排序算法.</p><p>复杂度的证明既可以用主定理, 也可以自己推导, 在最优情况下: <span class="math display">\[T(n)=2T(n/2)+n \\=2(2T(n/4)+n/2)+n=4T(n/4)+2n \\=4(2T(n/8)+n/4)+2n=8T(n/8)+3n \\... \\=nT(1)+nlogn=n+nlogn\]</span></p><h2 id="counting-sort">Counting Sort</h2><p><a href="https://zhuanlan.zhihu.com/p/270158986">计数排序</a>适用于数据量很大，但是数据类别很少的情况，可以做到线性时间。<br />举例来看：如果有100万个字符串，但只有cat, dog, person三种类型，采用基于比较的排序方式，可以做到<span class="math inline">\(NlogN\)</span>，计数排序采用了一种完全不同的思想：</p><ul><li>新建一个<code>counts[3]</code>，记录每种类型数据的出现次数；</li><li>遍历待排序数组，完成<code>count[]</code>的统计，并创建一个结果数组<code>sorted[]</code>：<br /><img src="https://img-blog.csdnimg.cn/20200624082843898.png" alt="在这里插入图片描述" /><br /></li><li>基于<code>count[]</code>，我们完全可以知道第一个cat应该放置在0，第一个dog应该放置在<code>count[0]=4</code>处，第一个person应该放置在<code>count[0]+count[1]=6</code>处，为了更加清晰，创建一个<code>starts[3]</code>表示每类数据中的第一个的起始位置：<br /><img src="https://img-blog.csdnimg.cn/20200624083353219.png" alt="在这里插入图片描述" /><br /></li><li>接着第二次遍历待排序数组，遇到第一个cat，我们知道它应该放在<code>sorted[starts[0]]</code>；第一个dog应该放在<code>sorted[starts[1]]</code>，第二个dog应该放在<code>sorted[starts[1]+1]</code>。或者可以这样做：每当放置完一个dog，就<code>++starts[1]</code>，这样下一次的dog还是会放在<code>sorted[starts[1]]</code>，最终结果：<br /><img src="https://img-blog.csdnimg.cn/20200624084335135.png" alt="在这里插入图片描述" /></li></ul><p>对于字符串排序，我们需要规定<code>counts[]</code>中每个下标对应哪种类型。如果对于非负整数，我们可以用<code>counts[i]</code>表示i的出现次数，接着遍历<code>counts[]</code>，将整数i放置<code>counts[i]</code>次；如果有负数，可以找到最小值min和最大值max，平移到0~max-min即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(upper + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        cnt[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= upper; ++i) &#123;</span><br><span class="line">        cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cnt[i]: number of elements &lt;= i</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">    <span class="comment">// 从后往前遍历保证排序稳定性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        tmp[cnt[nums[i]] - <span class="number">1</span>] = nums[i];</span><br><span class="line">        cnt[nums[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="built_in">assign</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="radix-sort">Radix Sort</h2><p>计数排序的前提就是需要知道待排序数组的内容/范围，那么如果范围很大，空间上是无法忍受的，由此来看更加general的基数排序：如果给定某种基（二进制2/十进制10/小写字母26）下的待排序数据，基数排序会逐位处理。基数排序有两种方式：</p><ol type="1"><li>MSD(Most Significant Digit)<br />从高位向低位，每一位上可以用计数排序：<br />356, 112, 904, 294, 209, 820, 394, 810；<br />由于对第二位排序不能改变第一位排序的结果，所以要求按位排序算法必须是<strong>稳定</strong>的。</li><li>LSD(Least Significant Digit)<br />从右到左处理，每一位上可以用桶（队列）：<br />[112], [294, 209], [356, 394], [820, 810], [904]；<br />对于每个桶采用类似的方法直到最后一位，以[294, 209]为例，接着处理第二位：[209], [294]。<br />最后收集每个桶中的元素即可。</li></ol><p>比如对于<span class="math inline">\([13,21,11,52,62]\)</span>，准备0-9的10个桶，从个位数字看起，依次放入相应的桶中：<br />1号桶：[21,11]左侧表示先进桶即队头<br />2号桶：[52,62]<br />3号桶：[13]</p><p>接着收集得到<span class="math inline">\([21,11,52,62,13]\)</span>个位已经有序，接着从十位看起：<br />1号桶：[11,13]<br />2号桶：[21]<br />5号桶：[52]<br />6号桶：[62]</p><p>收集得到<span class="math inline">\([11,13,21,52,62]\)</span>，这一过程需要注意11和13两个元素，虽然十位相同，但是个位小的11先进桶并且也要先出桶排在13前面。</p><p>具体的实现可以用队列表达桶，但是一般都用<code>cnt[10]</code>和<code>tmp[n]</code>实现：<code>cnt</code>统计个位每个数字的频率，<code>tmp</code>接收每趟收集的结果并存入原数组。<br />cnt: [0,2,2,1,0,0,0,0,0,0] -&gt; [0,2,4,5,5,5,5,5,5,5]表示在原数组中个位&lt;=2的数有4个<br />对原数组<strong>反向遍历</strong>，62个位为2，cnt[2]=4因此62应该放在<code>tmp[3]</code>上，依次类推得到tmp: [21,11,52,62,13]完成第一趟</p><p>cnt: [0,2,1,0,0,1,1,0,0,0] -&gt; [0,2,3,3,3,4,5,5,5,5]重复上述过程，之所以反向遍历，就是为了模拟进出桶时先进先出的性质。对于11和13，如果正向遍历，先看个位小的11，就会在<code>tmp[1]</code>中先放11然后在<code>tmp[0]</code>中放13违背了顺序。计算cnt前缀和数组时13是追加在11之上的，因此往<code>tmp</code>放置时需要先处理后面的13。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> max_digit_cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; max_digit_cnt; ++d) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = num[i] / radix % <span class="number">10</span>;</span><br><span class="line">            ++cnt[digit];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = num[i] / radix % <span class="number">10</span>;</span><br><span class="line">            tmp[--cnt[digit]] = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            num[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bucket-sort">Bucket Sort</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buckets</span>(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        buckets[num * len / upper].<span class="built_in">emplace_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bucket : buckets) &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(bucket.<span class="built_in">begin</span>(), bucket.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : bucket) &#123;</span><br><span class="line">            nums[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="" /><figcaption>排序</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Random Number Generator</title>
      <link href="/2018/05/24/Random%20Number%20Generator/"/>
      <url>/2018/05/24/Random%20Number%20Generator/</url>
      
        <content type="html"><![CDATA[<p><code>rand()</code>函数可以产生[0,RAND_MAX]之间的均匀的<strong>伪随机数</strong>，它定义在头文件<code>stdlib.h</code>中，函数原型： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>C标准库的实现是： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*rand: return pseudo-number integer on 0...32767*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = next*<span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*srand: set seed for rand()*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果没有初始化“随机数种子”，那么默认初始种子是1，1*1103515245+12345，return得到第一个伪随机数，接着将这个结果作为下次的种子，带入式子得到第二个伪随机数...<br />之所以定义为<code>unsigned int</code>，是防止数值溢出后不会出现负值。<br />直接调用<code>rand()</code>，会导致产生的是同一套随机数，所以我们使用<code>srand()</code>来初始化随机数种子。<br />要注意的是：不同编译器计算随机数的方法不尽相同，所以即使给<code>srand()</code>传递相同的参数，也可能产生不同的随机数序列。<br />举个栗子： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*产生0-9的随机数*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  <span class="comment">//初始化随机数种子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rand()%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用<code>rand()%n</code>产生[0,n)之间的随机数，那么一旦<span class="math inline">\(n&gt;RAND\_MAX\)</span>，这种做法就会失效。<br />如果你对精度的要求不高，可以采用如下办法：<br />先用<code>rand()/RAND_MAX</code>，得到[0,1]之间的随机实数，然后扩大n-1倍，四舍五入，就可得到[0,n-1]之间的随机数。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*产生10个[0,99999]之间的随机数*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">double</span> random_doub;</span><br><span class="line">    <span class="keyword">int</span> random_num;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        random_doub = (<span class="keyword">double</span>)rand() / RAND_MAX; <span class="comment">//生成[0,1]之间的随机数</span></span><br><span class="line">        random_num = (<span class="keyword">int</span>)((n - <span class="number">1</span>)*random_doub + <span class="number">0.5</span>); <span class="comment">//生成[0,n-1]之间的随机数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,random_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="1260581-20220108194141397-884629663.png" alt="image" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Function-time()</title>
      <link href="/2018/05/23/Function-time()/"/>
      <url>/2018/05/23/Function-time()/</url>
      
        <content type="html"><![CDATA[<p><code>time()</code>函数返回自1970年1月1日0点以来经过的秒数，每秒变化一次?<br /><code>time()</code>函数定义在头文件<code>&lt;time.h&gt;</code>中，原型是： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure></p><p>如果<code>arg</code>不是空指针，那么函数返回<code>time_t</code>类型的calendar time，并且把结果保存在<code>arg</code>指向的对象；<br />如果<code>arg == NULL</code>，那么函数只是返回一个值，值不能存储在空指针指向的对象。<br />之前不明白为什么要设计一个参数<code>arg</code>，直接返回一个值就好了啊？<br />有大神说，这是因为：</p><blockquote><p>很久很久以前，据说<code>time_t</code>是个<code>struct</code>，那时候c语言不支持函数返回<code>struct</code>，所以只能用指针传进去。</p></blockquote><p>那么<code>time_t</code>到底是什么类型呢？<br />看看cppreference.com的定义：</p><blockquote><p>The encoding of calendar time in <code>time_t</code> is unspecified, but most systems conform to POSIX specification and return a value of integral type holding the number of seconds since the Epoch.Implementations in which <code>time_t</code> is a 32-bit signed interger(many historical implementations) fail in the year 2038.</p></blockquote><p>就是说：C标准委员会并没有定义<code>time_t</code>的精度，也没有指定标准的Epoch，所以这取决于你的operating system以及你的compiler。<br />如果你的系统支持<strong>POSIX标准</strong>(包括很多类Unix系统、Windows系统)，那么<code>time_t</code>是一个<code>signed int 32</code>，最大表示范围是2147483647秒，标准Epoch是1970年1月1日0点，所以最终时间就是2038年1月19日，这就是著名的<a href="https://en.wikipedia.org/wiki/Year_2038_problem">2038年问题</a>。</p><p>那么这个函数的实现，GNU C Library是这么写的： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span>                <span class="comment">/* For NULL.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Return the current time as a `time_t&#x27; and also put it in *T if T is</span></span><br><span class="line"><span class="comment">   not NULL.  Time is represented as seconds from Jan 1 00:00:00 1970.  */</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span></span></span><br><span class="line"><span class="function"><span class="title">time</span> <span class="params">(<span class="keyword">time_t</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="keyword">time_t</span> result;</span><br><span class="line">  <span class="keyword">if</span> (__gettimeofday (&amp;tv, (struct timezone *) <span class="literal">NULL</span>))</span><br><span class="line">    result = (<span class="keyword">time_t</span>) <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = (<span class="keyword">time_t</span>) tv.tv_sec;</span><br><span class="line">  <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">    *t = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (time)</span><br></pre></td></tr></table></figure></p><p>如果返回<code>time_t</code>类型的值，说明调用成功；<br />如果返回<code>(time_t)(-1)</code>，说明无法取得现在的时间，调用失败。<br />举个栗子，获得当前时间： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> current = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*把日期和时间转为字符串*/</span></span><br><span class="line">    <span class="built_in">string</span> = ctime(&amp;current);</span><br><span class="line">    <span class="keyword">if</span> (current == (<span class="keyword">time_t</span>)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get the current time!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The current time is %s&quot;</span>, <span class="built_in">string</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d seconds since the Epoch)\n&quot;</span>,current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果： <img src="1260581-20220108191119700-2067131670.png" alt="image" /></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FTP Protocol</title>
      <link href="/2018/05/22/FTP%20Protocol/"/>
      <url>/2018/05/22/FTP%20Protocol/</url>
      
        <content type="html"><![CDATA[<p>FTP(File Transfer Protocol)是因特网上的一种文件传送协议。</p><h2 id="基本原理">基本原理</h2><p>FTP协议基于客户/服务器模式，属于应用层，使用TCP可靠的运输服务。<br />FTP的服务器进程由<strong>1个主进程</strong>和<strong>若干从进程</strong>组成：主进程负责接受新请求，从进程负责处理单个请求。这样，1个FTP服务器就可以同时为多个客户进程服务。</p><h2 id="工作过程">工作过程</h2><p>FTP工作分为主动模式和被动模式。<br />不论哪种模式，首先，客户从一个随机的端口N(1024-65535)向服务器的命令端口21发起请求，建立起<strong>控制连接</strong>。</p><ul><li><p>主动模式<br />客户随机打开某个端口(1024-65535)，在这个端口等待服务器的数据，所以要通过控制连接告诉服务器自己用哪个端口传送数据，接着服务器收到文件传送命令以及客户端口号，从自己的数据端口20向客户发起数据连接。<br />FTP传送完一个文件，数据连接就会关闭，而控制连接贯穿整个会话。</p></li><li><p>被动模式<br />如果客户被防火墙限制，不能接受到来的TCP连接，这时候就需要被动模式来传输：<br /><img src="1260581-20220108185312740-1401371750.png" alt="image" /><br />首先，客户通过控制连接向服务器发送命令PASV；<br />接着，服务器向客户发送自己的IP地址和自己打算用来传送数据的端口号；<br />最后，客户通过刚才接收的IP地址和服务器端口号，用自己任意一个端口(1024-65535)向服务器开的那个端口建立数据连接。<br />通俗点，就是：<br />主动模式：建立数据通道，服务器主动去连接客户；<br /><img src="1260581-20220108185349044-1665399483.png" alt="image" /> 被动模式：建立数据通道，服务器被动地被客户连接。<br /><img src="1260581-20220108185409921-1806947979.png" alt="image" /></p></li></ul><p>再通俗点，就是：<br />主动模式：<br />客户：我开了一个端口，你来连我吧；<br />被动模式：<br />客户：mmp，被防火墙搞了，收不到你发来的数据连接了；<br />服务器：哦，没事，我开了个端口，你连我就好了。</p><h2 id="参考">参考</h2><p><a href="www.serv-u.com/kb/1138/Active-and-Passive-FTP-Transfers-Defined">Active and Passive FTP Transfers Defined</a><br /><a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol">wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题小技巧</title>
      <link href="/2018/05/19/%E5%88%B7%E9%A2%98%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/05/19/%E5%88%B7%E9%A2%98%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="文件io">文件IO</h2><p>在刷题测试程序时，为了避免每次都手工输入，我们可以把输入数据保存在文件中；为了避免输出太长，我们将输出也写入文件中，方便与标准答案文件进行比较。<br />文件使用一般有两种方法：输入输出重定向, fopen。</p><ul><li>重定向<br />这种方法比较简单，只要在main()函数的开始加上如下代码, 就可以将标准I/O(键盘输入、屏幕输出)转为读写文件: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure></li></ul><p>万一比赛要求标准I/O，而你还想用文件操作来测试代码时，提交时切记删除上述重定向代码。为了避免忘记这茬，可以如下处理： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>,  <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样本机测试时可以使用重定向；如果要求标准I/O，提交时只需删掉<code>#define LOCAL</code>即可。</p><ul><li>fopen</li></ul><p>如果比赛要求使用文件读写，但禁止重定向方式，这时可以使用fopen方式： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE *fin, *fout;</span><br><span class="line">    fin = fopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fout = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="comment">// 把scanf改为fscanf, 把printf改为fprintf</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fin, <span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">fprintf</span>(fout, <span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line">    <span class="comment">// your code here</span></span><br><span class="line"></span><br><span class="line">    fclose(fin);</span><br><span class="line">    fclose(fout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候，如果需要标准I/O，只需要： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fin = <span class="built_in">stdin</span>;</span><br><span class="line">fout = <span class="built_in">stdout</span>;</span><br></pre></td></tr></table></figure></p><p>最后，简单说下windows下的<strong>文件比较</strong>. 进入cmd: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fc</span> 1.txt 2.txt  <span class="comment"># 两个文件在同一目录</span></span><br><span class="line"><span class="built_in">fc</span> <span class="string">&quot;c:\1.txt&quot;</span> <span class="string">&quot;d:\2.txt&quot;</span>  <span class="comment"># 两个文件不在同一目录</span></span><br></pre></td></tr></table></figure></p><p>可以使用<code>fc /?</code>查看fc命令的一些参数： <img src="https://img-blog.csdnimg.cn/e4b9baab46cb40bb9bb7f21be154d29c.png" alt="在这里插入图片描述" /></p><h2 id="对拍">对拍</h2><p>对拍是说碰见一道题, 想了个解<code>sol</code>但不知道对不对, 但是呢暴力解<code>bf</code>时间复杂度又太高, 所以希望用随机数据根据<code>bf</code>的正确解验证<code>sol</code>.</p><p>除了<code>sol</code>和<code>bf</code>, 还需要<code>random</code>生成随机数据以及<code>pai</code>来对比结果.</p><p>random <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [0, m - 1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">rand</span>() * <span class="built_in">rand</span>() % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\data.in&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">random</span>(<span class="number">100</span>) + <span class="number">5</span>;  <span class="comment">// 点的数目</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1000000000</span>;  <span class="comment">// 取值范围</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">random</span>(m);  <span class="comment">// 数字取值范围[0, m - 1]</span></span><br><span class="line">        <span class="comment">// a[i] = random(2 * m + 1) - m;  // [-m, m]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="built_in">random</span>(<span class="number">1000</span>) + <span class="number">1</span>, n2 = <span class="built_in">random</span>(<span class="number">1000</span>) + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">b</span>(n1, vector&lt;<span class="keyword">int</span>&gt;(n2, <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, n1, n2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; ++j) &#123;</span><br><span class="line">            b[i][j] = <span class="built_in">random</span>(m);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n2 - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sol <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;D:\\FILE\\mycode\\cpp_bishi\\data.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;D:\\FILE\\mycode\\cpp_bishi\\data.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>bf <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\data.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\data.ans&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>pai <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> T = <span class="number">1</span>; T &lt;= <span class="number">100</span>; T++) &#123;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\random.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> st = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\sol.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> ed = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;D:\\FILE\\mycode\\cpp_bishi\\bf.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">system</span>(<span class="string">&quot;fc D:\\FILE\\mycode\\cpp_bishi\\data.out D:\\FILE\\mycode\\cpp_bishi\\data.ans&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;wrong ans&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;accepted, id #%d, time %.0lfms\n&quot;</span>, T, ed-st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2018/05/19/Git/"/>
      <url>/2018/05/19/Git/</url>
      
        <content type="html"><![CDATA[<p>Git是版本控制系统的一种，用来维护多人协作项目的开发进程。</p><p>首先来看看单人开发的需求，最原始的VCS就在你我身边😂：一系列word文档</p><p>假如在本地保存了多个版本，<code>HEAD</code>总是指向最新的版本： <img src="1260581-20211229110354288-1305060165.png" alt="image" /></p><p>如果Version 3出现了严重的bug，可以回退到Version 2继续操作。但是如果Version 3包含了很多我们希望保留的change，就需要将其与Version 2比对，而后将这些changes拷贝到Version 2，一个好的VCS就需要支持<code>diff</code>操作帮程序员们找到两个版本之间的差异。</p><p>除此之外，为了防止本地机器故障，我们希望把本地的所有版本都在云上备份，这样即使你的设备原地爆炸，也不用担心被老板炒鱿鱼。 <img src="1260581-20211229111609065-1819873752.png" alt="image" /><br />另外，你可以借助云的中转实现多地工作。当然偶尔也会出现一些小问题：假如现在云上和本地的稳定版本都是Version 5，你996下班后还想为公司做贡献，就在家里开始对Version 5一顿操作得到了Version 5L却忘了上传，第二天上班在公司又是对Version 5一通different的操作得到了Version 5D并上传，第二天下班从云上直接拉取Version 5D到本地，价值几个亿的Version 5L就再也找不到了...这里就需要<code>merge</code>操作来合并分支。</p><p>更重要的是，程序员们可以随时随地借助云上的备份进行协作，完成超大项目的撕逼工作。<br />为了保证出bug有人背锅，还需要记录who/when/what，VCS里叫做<code>annotate/blame</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git init  # 将该目录用Git管理</span><br><span class="line">git add haha.txt kaka.txt  # 将haha.txt，kaka.txt添加到仓库</span><br><span class="line">git commit -m &quot;upload&quot;  # 将文件提交到仓库，本次提交说明是upload</span><br><span class="line">git remote add origin git@github.com:EIMadrigal/Leetcode.git  # 将本地仓库与远程仓库关联</span><br><span class="line">git push -u origin main  # 将本地库的内容第一次推送到远程仓库</span><br><span class="line">git push origin main  # 以后的推送</span><br><span class="line">git rm -r --cached haha  # 删除文件夹haha</span><br><span class="line">git status  # 查看仓库的状态</span><br><span class="line">git diff  # 查看具体修改的内容</span><br><span class="line">git log  # 查看提交历史纪录</span><br><span class="line">git show  # 提交详情</span><br><span class="line">git checkout -- [file]  # 回退</span><br><span class="line">git reset --hard HEAD^  # HEAD表示当前版本，HEAD^表示上一个版本</span><br><span class="line">git reflog  # 查看命令的历史纪录</span><br></pre></td></tr></table></figure><p><a href="https://www.v2ex.com/t/786515">Windows怎么设置cmd/git bash走代理</a></p><h2 id="refs">Refs</h2><p><a href="https://missing.csail.mit.edu/2020/version-control/">Version Control (Git)</a><br /><a href="https://web.mit.edu/6.031/www/fa21/classes/05-version-control">Reading 5: Version Control</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim Introduction</title>
      <link href="/2018/05/18/Vim%20Introduction/"/>
      <url>/2018/05/18/Vim%20Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="配置">配置</h2><p>安装原生态的Vim之后，界面非常简略：行号，自动缩进，括号匹配都没有.</p><p>为了我们使用的方便，进行一些基本的配置： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vim/vimrc</span><br></pre></td></tr></table></figure> 进入配置文件后可以删掉注释或添加新的配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set number  # 左侧显示行号</span><br><span class="line">set ts=4  # Tab键长度4个空格</span><br><span class="line">set expandtab  # 输入Tab自动转换为空格</span><br><span class="line">set cursorline  # 突出显示当前行</span><br><span class="line">set autoindent  # 自动缩进</span><br><span class="line">set showmatch  # 显示括号匹配</span><br><span class="line">syntax on</span><br></pre></td></tr></table></figure><h2 id="使用">使用</h2><p>Vim有三种模式：输入模式、命令模式和末行命令模式。<br />输入模式用来输入文字，命令模式用来下达编排文件的操作指令，末行命令模式用来进行文件存档、离开编辑器等操作: <img src="vimmode.png" alt="image" /></p><ol type="1"><li>进入及离开 末行模式下： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:w  # 保存当前文件</span><br><span class="line">:x  # 保存文件并退出</span><br><span class="line">:q!  # 放弃此次编辑并强制退出</span><br><span class="line">:wq a.txt  # 保存退出</span><br><span class="line">:syntax on  # 一次性语法高亮</span><br><span class="line">:set number  # 一次性显示行号</span><br></pre></td></tr></table></figure></li><li>基本编辑 命令模式下按v进入visual模式： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d  # 选中目标文字段，按d(delete)剪切</span><br><span class="line">y  # 选中目标文字段，按y(yank)复制</span><br><span class="line">p  # 移动光标到目标位置，按p(put)粘贴</span><br></pre></td></tr></table></figure></li></ol><p>命令模式: hjkl和方向键类似,w可以按词向后移动,b按词向前移动,ctrl+f/ctrl+b与pageup/down功能一样<br />88gg直接跳到第88行 10j向下跳10行 10k向上跳10行<br />/Node高亮所有Node以后 按n后跳 按shift+n前跳<br />cc/dd/yy,按u取消操作 c2c删掉连续2行<br />p粘贴,按u取消操作</p><p>编辑模式:<br />ctrl+n自动补全</p><p>插件:<br />vim plug<br />vim awesome</p><h2 id="中文输入">中文输入</h2><p>确保键盘输入系统选中fcitx，搜狗拼音输入法基于fcitx(Free Chinese Input Toy for X)框架，所以要选中fcitx： <img src="fcitx.png" alt="image" /></p><p>下载并安装搜狗输入法<a href="https://pinyin.sogou.com/linux/?r=pinyin">安装包</a>，切换到安装包所在的目录，改下安装包的名字，不然太长了不方便，我这里改为<code>ha.deb</code>，之后安装： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i ha.deb</span><br></pre></td></tr></table></figure></p><p>这里可能会提示依赖关系不满足(没提示的话跳过即可)： <img src="dependency.png" alt="image" /></p><p>这是由于你的电脑可能没有安装有关fictx的内容，修复依赖关系： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -f</span><br></pre></td></tr></table></figure></p><p>顺利的话，桌面右上角会出现键盘图标：<br /><img src="success.png" alt="image" /><br />可以看到搜狗输入法已经安装。</p><p>如果看不到搜狗的图标(尤其是第一次安装)，重启系统。 右键键盘图标，选择configure(或者搜fcitx configuration)： <img src="configure.png" alt="image" /></p><p>你现在应该没有Sogou Pinyin这一项，点那个+号： <img src="1260581-20211229103646985-2704756.png" alt="image" /></p><p>取消Only Show Current Language前的对号，搜索Sogou Pinyin，点击OK。<br />现在，输入法应该已经安装好了。可以去桌面那个键盘图标看看了~</p><h2 id="ref">Ref</h2><p><a href="https://www.bilibili.com/video/BV1Yt411X7mu">vim教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISA Introduction</title>
      <link href="/2018/05/16/ISA%20Introduction/"/>
      <url>/2018/05/16/ISA%20Introduction/</url>
      
        <content type="html"><![CDATA[<p>介绍一下X86、MIPS、ARM三种指令集：</p><h2 id="x86指令集">X86指令集</h2><p>X86指令集是典型的CISC(Complex Instruction Set Computer)指令集。<br />X86指令集外部看起来是CISC指令集，事实上，它是采用类RISC内核，将部分复杂指令通过micro-op模式进行翻译成简单指令，再处理。<br />X86指令集的几个特性</p><ul><li>后向兼容<br />Intel每推出一代新处理器，总会兼容以前处理器的feature。这是由于长期积累的用户习惯和生态环境不容更改，否则没法赚钱了~<br />后向兼容导致指令集愈发庞大、愈发复杂，同时功耗也会比较大，不过由于Intel超高的工艺水平，这都不是事。</li><li>变长指令<br />X86指令集采用变长指令(1-15Bytes)，一般每条指令为2-3Bytes。这样可以提高码字的利用率，但也使得译码以及读取指令时比较复杂，因为不知道一条指令应该读多长。</li><li>多种寻址方式<br />X86指令集可以采用多种寻址方式，比如立即寻址、寄存器寻址、寄存器相对寻址......</li><li>通用寄存器个数有限<br />X86-32的系统有8个通用寄存器，之后X86-64系统扩展到了16个。</li><li>指令执行时，最多只能有一个操作数在内存里，另一个操作数必为立即数或者寄存器。</li><li>由于后向兼容以及类RISC内核，导致功耗增加；同时，有很多复杂的指令利用率很低。</li></ul><h2 id="mips指令集">MIPS指令集</h2><p>MIPS指令集是典型的RISC(Reduced Instruction Set Computer)指令集。<br />精简指令集系统的设计思想就是：把复杂指令集中一些不常用的指令踢出指令集，这些复杂指令由日益强大的软件技术(编译)去实现，这样使得每个指令的流水线分段比较均匀，充分利用了处理器的流水线结构，提高了主频。<br />MIPS指令集以32个寄存器为中心，只能通过<strong>Load/Store</strong>指令访问内存，其余涉及计算的指令都从寄存器堆中读取数据，并且将计算结果写入寄存器堆中。<br />另外，MIPS指令的格式比较规整，所有指令长度一致，指令操作码都在固定的位置；寻址方式、对于每条指令的操作都很简单。<br />那么CISC与RISC的区别是什么呢？<br />最大的区别在于：RISC只能通过<strong>Load/Store</strong>指令访问内存，而CISC指令集则没有这个限制。</p><h2 id="arm指令集">ARM指令集</h2><p>ARM指令集属于RISC指令集，每条指令32位。<br />ARM也有16位的压缩指令集，这是为了避免32位出现的码字浪费，提高运行速度推出的。</p><ul><li>ARM指令由于属于RISC指令集，一般完成的操作比较简单。程序员可以通过多条简单的指令组合实现一个复杂的操作。</li><li>同样的，ARM指令集也是只能通过<strong>Load/Store</strong>指令读取内存中的数据到寄存器，其余的指令只能对寄存器的操作数进行处理。</li><li>大多数指令长度相同，字段位置(尤其是操作码的位置)固定，且具有“条件执行”模式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fourier Transform</title>
      <link href="/2018/05/06/Fourier%20Transform/"/>
      <url>/2018/05/06/Fourier%20Transform/</url>
      
        <content type="html"><![CDATA[<p>为了在统一框架里分析周期信号与非周期信号，可以给周期信号也建立傅里叶变换。<br />有两种方法求周期信号的傅里叶变换：</p><ol type="1"><li><p>利用傅里叶级数进行构造<br />对于周期信号<span class="math inline">\(x(t)\)</span>，其傅里叶级数展开式为： <span class="math display">\[x(t) = \sum_{k = -\infty}^{+\infty}a_ke^{jkw_0t}\]</span> 系数<span class="math inline">\(a_k\)</span>表示为：<br /><img src="https://img-blog.csdnimg.cn/074ecf83ad964d0b869dceb72a65cf43.png" alt="在这里插入图片描述" /><br />由于 <img src="https://img-blog.csdnimg.cn/d580f672cc624a02bafc1cbcb8eaee2e.png" alt="在这里插入图片描述" /><br />说明周期性复指数信号的频谱是一个冲激，那么我们推广这个关系，可得： <img src="https://img-blog.csdnimg.cn/96285b7fb96e48c1891e4745de9e5256.png" alt="在这里插入图片描述" /><br />表明：周期信号的傅里叶变换由一系列等间隔的冲激函数线性组合而成，每个冲激分别位于信号各次谐波的频率处，其强度是傅里叶级数系数的<span class="math inline">\(2\pi\)</span>倍。</p></li><li><p>周期延拓<br />这种方法先将<span class="math inline">\(x(t)\)</span>在一个周期内截断，得信号<span class="math inline">\(x_T(t)\)</span>，求出<span class="math inline">\(x_T(t)\)</span>的傅里叶变换<span class="math inline">\(X_T(w)\)</span>，再对<span class="math inline">\(X_T(w)\)</span>周期延拓得<span class="math inline">\(X(w)\)</span>。<br />具体来说：<br />根据<span class="math inline">\(\delta\)</span>函数性质，有： <span class="math display">\[x(t) = x_T(t)*\sum_{k = -\infty}^{+\infty}\delta(t - kT)\]</span> 设周期冲激串<span class="math inline">\(\sum_{k = -\infty}^{+\infty}\delta(t - kT)\)</span>的傅里叶变换为<span class="math inline">\(F(w)\)</span>，<br />由时域卷积定理： <span class="math display">\[X(w) = X_T(w)F(w)\]</span> 又时域周期为T的周期冲激串的傅里叶变换在频域是一个周期为<span class="math inline">\(\frac{2\pi}{T}\)</span>的周期冲激串，即： <span class="math display">\[F(w) = \frac{2\pi}{T}\sum_{k = -\infty}^{+\infty}\delta(w - \frac{2\pi k}{T})\]</span> 故可得： <span class="math display">\[X(w) = \frac{2\pi}{T}X_T(w)\sum_{k = -\infty}^{+\infty}\delta(w - \frac{2\pi k}{T})\]</span> 也就是： <span class="math display">\[X(w) = w_0\sum_{k = -\infty}^{+\infty}X_T(kw_0)\delta(w - kw_0)\]</span> 我们对比两种方法得到的结果，可知：<br />周期信号傅里叶级数的系数<span class="math inline">\(a_k = \frac{1}{T}X_T(kw_0)\)</span></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Information Engineering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Process/Thread Synchronization</title>
      <link href="/2018/04/28/Process%20&amp;%20Thread%20Synchronization/"/>
      <url>/2018/04/28/Process%20&amp;%20Thread%20Synchronization/</url>
      
        <content type="html"><![CDATA[<h2 id="进程间同步">进程间同步</h2><p>进程同步是为了控制多个进程的执行顺序，为了做到进程同步，通常需要进程间通信（IPC），在不同进程之间传递消息，常见的方式有以下几种：</p><ul><li>管道（pipe）：包括匿名管道、流管道和命名管道（FIFO）。速度慢效率低，容量有限，只能用于父子进程</li><li>信号量（semaphores）：不能用来传递复杂消息，只能用于同步</li><li>共享内存（shared memory）：高级方式</li><li>消息队列（message passing）：容量有限，消息的复制耗时，不适于信息量大或操作频繁的场景</li><li>信号（signal）：</li><li>套接字（socket）：网络上不同进程通信</li></ul><h3 id="管道">管道</h3><p>对于匿名管道：</p><ol type="1"><li>半双工即数据只能单向流动，有固定的读端和写端</li><li>只能在父子进程或兄弟进程间通信</li><li>可以看作特殊文件并使用read/write读写，只存在于内存中，不属于任何文件系统</li></ol><p>对于命名管道：</p><ol type="1"><li>可以在无关进程间交换数据</li><li>拥有相关联的路径名，以一种特殊设备文件形式存在于文件系统</li></ol><h3 id="消息队列">消息队列</h3><p>消息队列是存放在内核中的消息链表，由队列ID来标识：</p><ol type="1"><li>消息有特定格式和特定优先级</li><li>独立于发送和接收进程，进程终止消息队列仍然存在</li><li>可以根据消息类型有选择地接收信息</li></ol><h3 id="信号量">信号量</h3><p>本质上是一个计数器，用来进程间互斥和同步，而非用于存储进程间通信数据。PV原语操作</p><h3 id="信号">信号</h3><p>异步通信方式</p><h3 id="共享内存">共享内存</h3><p>速度最快，直接对内存存取，需要同步机制，通常与信号量结合使用</p><h3 id="socket">socket</h3><p>不同主机间IPC</p><h2 id="线程间同步通信">线程间同步/通信</h2><p>线程同步机制有以下几种：</p><h3 id="锁机制">锁机制</h3><ul><li>互斥锁（mutex）：排他性访问共享数据，用来保护临界区。某个线程加锁后，其它要加锁的线程将被阻塞，申请失败进入休眠，直到锁被释放。</li><li>读写锁（ReadWriteLock）：用于读者-写者问题，共有三种状态：不加锁、读模式加锁、写模式加锁。每次只有一个线程可以占用写模式的锁，但可以有多个线程占有读模式锁。</li><li>自旋锁（spinlock）：专为多处理器并发引入，不断循环测试锁的状态，申请线程不会休眠，忙等锁。</li><li>条件变量（condition variables）</li></ul><h3 id="全局变量">全局变量</h3><p>在各线程共享的堆上，每个线程私有栈</p><h3 id="事件event">事件event</h3><h3 id="信号量-1">信号量</h3><ul><li>信号量（semaphores）：有更多取值空间，实现更复杂的同步。</li></ul><p>信号量和PV原语的使用可归纳为三种情形：</p><ol type="1"><li>把信号量视为<strong>加锁标志位</strong>，其目的是为了实现对某个<strong>唯一的共享数据</strong>的<strong>互斥访问</strong>，如各个进程间的某共享变量，数据库中的某个记录。<br />共享数据的值与信号量本身的值没有直接关系，信号量的作用仅仅是作为加锁标志位。其特征是<strong>信号量初始值为1</strong>，然后在一个进程内部对它进行配对的PV操作。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P(mutex);  <span class="comment">// mutex的初始值为1</span></span><br><span class="line">访问该共享数据;</span><br><span class="line">V(mutex);</span><br><span class="line">非临界区</span><br></pre></td></tr></table></figure></li><li>把信号量视为某种类型的<strong>共享资源的剩余个数</strong>，目的是实现对这种类型的共享资源的访问，如各种I/O设备。<br />信号量的取值具有实际意义，即为<strong>空闲资源的个数</strong>。多个进程可以同时使用这种类型的资源，直到所有空闲资源均已用完。<br />其特征是信号量的<strong>初始值为<span class="math inline">\(N\geq 1\)</span></strong>，然后<strong>在一个进程内部对它进行配对的PV操作</strong>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P(resource);  <span class="comment">// resource的初始值为N</span></span><br><span class="line">使用该资源;</span><br><span class="line">V(resource);</span><br><span class="line">非临界区</span><br></pre></td></tr></table></figure></li><li>把信号量作为<strong>进程间同步</strong>的工具，利用它来设定<strong>两个进程在运行时的先后顺序</strong>。比如，它可以是某个共享资源的当前个数，但是由一个进程负责生成该资源，而另一个进程负责消费该资源，由此引发了两个进程间的先后顺序。<br />其特征是信号量的<strong>初始值为<span class="math inline">\(N\geq 0\)</span></strong>，然后<strong>在一个进程里对其使用V原语，增加资源个数，而在另一个进程里对其使用P原语，减少资源个数，</strong>从而实现两个进程之间的同步关系。</li></ol><h2 id="reference">reference</h2><p><a href="https://www.cnblogs.com/CheeseZH/p/5264465.html">IPC介绍</a><br /><a href="https://blog.nowcoder.net/n/6fba971da3f34c5c946665cbb189d049">进程间通信</a><br /><a href="https://blog.csdn.net/AJIEIT/article/details/105368896">信号与信号量</a><br /><a href="https://www.cnblogs.com/wsw-seu/p/8036218.html">线程间同步</a><br />https://www.cnblogs.com/meng-chao/p/16323985.html<br />https://www.cnblogs.com/limich/p/7477079.html</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Process Synchronization-Example 2</title>
      <link href="/2018/04/20/Process%20Synchronization-Example%202/"/>
      <url>/2018/04/20/Process%20Synchronization-Example%202/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>理发店有一位理发师，一把理发椅和N把供等候的顾客坐的椅子。<br />如果没有顾客，理发师在理发椅上睡觉；<br />当有一个顾客到来时，他必须先唤醒理发师；<br />如果顾客来时理发师正在理发，如果有空椅子，坐下等待，否则离开。<br />用PV操作解决上述问题中的同步和互斥关系。</p><h2 id="分析">分析</h2><p>将顾客看作N个生产者，理发师是1个消费者。<br />理发师和椅子是临界资源，故顾客间是互斥关系；<br />理发师和顾客是同步关系。</p><p>信号量设置： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore barberReady = <span class="number">0</span>  互斥量，只能取<span class="number">0</span>或<span class="number">1</span>  </span><br><span class="line">Semaphore accessSeat = <span class="number">1</span>  互斥量，如果为<span class="number">1</span>，表明椅子数可以增加或减少，相当于给椅子加锁，避免两个顾客同时坐一把椅子</span><br><span class="line">Semaphore num_wait = <span class="number">0</span>   坐在椅子上等待的顾客数</span><br><span class="line"><span class="keyword">int</span> seat_free    空着的椅子数目</span><br></pre></td></tr></table></figure> <a href="https://en.wikipedia.org/wiki/Sleeping_barber_problem">参考wiki</a></p><h2 id="解答">解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顾客进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(accessSeat);  <span class="comment">//试图坐下</span></span><br><span class="line">        <span class="keyword">if</span>(seat_free &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            seat_free--;  <span class="comment">//坐下</span></span><br><span class="line">            V(num_wait);  <span class="comment">//试图唤醒理发师，</span></span><br><span class="line">            V(accessSeat);  <span class="comment">//不用再锁着椅子</span></span><br><span class="line">            P(baberReady); <span class="comment">//等待理发师ready</span></span><br><span class="line">            理发;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            V(accessSeat);  <span class="comment">//释放加在椅子上的锁</span></span><br><span class="line">            离开;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*理发师进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(num_wait);   <span class="comment">//尝试获得一位顾客，如果没有，去睡觉</span></span><br><span class="line">        P(accessSeat);   <span class="comment">//尝试获得椅子锁，更改空闲椅子数目</span></span><br><span class="line">        seat_free++;    <span class="comment">//空椅子加1</span></span><br><span class="line">        V(baberReady);    <span class="comment">//理发师准备好了</span></span><br><span class="line">        V(accessSeat);    <span class="comment">//无需继续锁着椅子</span></span><br><span class="line">        理发;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Process Synchronization-Example 1</title>
      <link href="/2018/04/11/Process%20Synchronization-Example%201/"/>
      <url>/2018/04/11/Process%20Synchronization-Example%201/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>把学生和监考老师都看作进程，学生有N人，教师1人。考场门口每次只能进出一个人，进考场原则是先来先进。当N个学生都进入考场后，教师才能发卷子。学生交卷后可以离开考场，教师要等收上来全部卷子并封装卷子后才能离开考场。问：</p><ul><li>需要设置几个进程？</li><li>用PV操作解决上述问题的同步互斥关系。</li></ul><h2 id="分析">分析</h2><blockquote><p>考场门口每次只能进出一个人</p></blockquote><p>考场门口是共享资源。</p><blockquote><p>当N个学生都进入考场后，教师才能发卷子<br />教师要等收上来全部卷子并封装卷子后才能离开考场</p></blockquote><p>这是两个同步行为。</p><p>信号量设置： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">door = <span class="number">1</span>    <span class="comment">//能否进出门口</span></span><br><span class="line">mutex1 = <span class="number">1</span></span><br><span class="line">mutex2 = <span class="number">1</span>   <span class="comment">//互斥信号量</span></span><br><span class="line">sr = <span class="number">0</span>   <span class="comment">//学生是否到齐</span></span><br><span class="line">eb = <span class="number">0</span>    <span class="comment">//考试开始</span></span><br><span class="line">eo = <span class="number">0</span>     <span class="comment">//考试结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_stu = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num_paper = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><h2 id="解答">解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*学生进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">student</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(door);</span><br><span class="line">    进门;</span><br><span class="line">    V(door);</span><br><span class="line">    P(mutex1);  <span class="comment">//增加学生人数</span></span><br><span class="line">    num_stu++;</span><br><span class="line">    <span class="keyword">if</span>(num_stu == N)</span><br><span class="line">    V(sr);</span><br><span class="line">    V(mutex1);</span><br><span class="line">    P(eb);  <span class="comment">//等教师宣布开始考试</span></span><br><span class="line">    考试;</span><br><span class="line">    交卷;</span><br><span class="line">    P(mutex2);   <span class="comment">//增加试卷份数</span></span><br><span class="line">    num_paper++;</span><br><span class="line">    <span class="keyword">if</span>(num_paper == N)</span><br><span class="line">    V(eo);</span><br><span class="line">    V(mutex2);</span><br><span class="line">    P(door);</span><br><span class="line">    出门;</span><br><span class="line">    V(door);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*教师进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">teacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(door);</span><br><span class="line">    进门;</span><br><span class="line">    V(door);</span><br><span class="line">    P(sr);  <span class="comment">//最后一个学生唤醒老师</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    发卷子;</span><br><span class="line">    V(eb);     <span class="comment">//开始考试</span></span><br><span class="line">    P(eo);   <span class="comment">//等待考试结束</span></span><br><span class="line">    封装;</span><br><span class="line">    P(door);</span><br><span class="line">    出门;</span><br><span class="line">    V(door);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pattern Matching</title>
      <link href="/2018/04/02/Pattern%20Matching/"/>
      <url>/2018/04/02/Pattern%20Matching/</url>
      
        <content type="html"><![CDATA[<p>字符串模式匹配，即子串的定位操作。就是判断主串S中是否存在给定的子串，如果存在，那么返回子串在S中的位置，否则返回-1。<br />实现这种操作有两种算法：</p><h2 id="朴素的模式匹配算法">朴素的模式匹配算法</h2><p>设主串S长度为n，子串T长度为m。<br />对于主串的每个字符，做长度为m的循环，判断是否与子串匹配。<br />最好的情况就是一开始就匹配成功，时间复杂度<span class="math inline">\(O(1)\)</span>；最坏的情况就是每次匹配失败都是在T的最后一个元素，复杂度<span class="math inline">\(O(nm)\)</span>;平均情况复杂度<span class="math inline">\(O(n+m)\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; j &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[j] == s[i]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == t.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="kmp算法">KMP算法</h2><p>KMP主要分两步：</p><ol type="1"><li>进行t的自匹配，这一步关键在于得到next数组。 next中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度，将Next[0] = -1。<br />举例来说：t=ababaca，前缀为pre，后缀为post。<br />i = 1: 要处理"a", pre = {""}, post = {""}, next[1] = 0;<br />i = 2: 要处理"ab", pre = {a}, post = {b}, Next[2] = 0;<br />i = 3: 要处理"aba", pre = {a, ab}, post = {a, ba}, Next[3] = 1;<br />i = 4: 要处理"abab", pre = {a, ab, aba}, post = {b, ab, bab}, Next[4] = 2;<br />i = 5: 要处理"ababa", pre = {a, ab, aba, abab}, post = {a, ba, aba, baba}, Next[5] = 3;<br />i = 6: 要处理"ababac", pre = {a, ab, aba, abab, ababa}, post = {c, ac, bac, abac, babac}, Next[6] = 0;<br />i = 7: 要处理"ababaca", pre = {a, ab, aba, abab, ababa, ababac}, post = {a, ca, aca, baca, abaca, babaca}, Next[7] = 1;<br />Next数组<span class="math inline">\([-1,0,0,1,2,3,0,1]\)</span></li><li>S与T的匹配，这步的匹配和朴素匹配没有太大差异，只是主串S的指针不用回溯，而将子串的指针j回溯到Next[j]位置。</li></ol><p>从T的第一位开始对自身匹配，在某一位置能匹配的最长长度即是当前位置Next值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">getNext</span><span class="params">(<span class="keyword">const</span> string&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(t.size())</span></span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>, next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i - <span class="number">1</span>] == t[j]) &#123;</span><br><span class="line">            next[i++] = ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next[i++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; next = <span class="built_in">getNext</span>(t);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; j &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[j] == <span class="number">-1</span>) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == t.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进kmp算法">改进KMP算法</h2><p>主要改进了Next数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next_compute</span><span class="params">(<span class="keyword">char</span> T[], <span class="keyword">int</span>* next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == j || T[i] == T[j]) &#123;   <span class="comment">// 自匹配</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i] != T[j])</span><br><span class="line">                next[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[i] = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];  <span class="comment">// 字符不同，j值回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><a href="https://www.bilibili.com/video/BV13g41157hK?p=13">1:28:00开始</a><br /><a href="https://www.zhihu.com/question/21923021"></a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Data Structures</title>
      <link href="/2018/03/29/B%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2018/03/29/B%E6%A0%91%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>为了避免BST退化为单链表，出现了AVL树，但终究是二叉树，难堪大用。</p><h2 id="b-trees">B-Trees</h2><p>B-Trees可以认为是一种泛化的BST，BST的每个结点只存储单个key，因此最好情况下只能将key space划分为两半，查询复杂度<span class="math inline">\(O(log_2n)\)</span>，为了进一步提高查询的效率，可以令每个结点存储任意数量的排好序的key，即所谓的多路查找树，每个结点的k个key可以将key space划分为k+1段，每个子树负责一段。</p><p>m阶B-Tree有着如下性质：</p><ul><li>每个节点最多有<span class="math inline">\(m\)</span>个孩子, <span class="math inline">\(m-1\)</span>个key</li><li>除根节点外, 所有结点最少有<span class="math inline">\(\lceil \frac{m}{2} \rceil\)</span>个孩子</li><li>所有叶子结点都处在同样的深度，即绝对平衡</li></ul><p>4阶B-Tree又叫2-3-4树，因为每个结点可以存储1-3个key，即可以有2-4个分叉，因此得名。</p><p><img src="https://img-blog.csdnimg.cn/18941cde817d4500892631525dfc53b4.png" alt="在这里插入图片描述" style="zoom:50%;" /></p><p>B-Tree的多key存储虽然会减小查询代价，但会导致插入和删除的代价增加，那么人们为啥还要用呢？本质上还是因为磁盘的访问太过耗时，访问磁盘数据的时间由3部分组成：</p><ol type="1"><li>磁头移动到相应的磁道所耗费的时间，大概10ms左右；</li><li>磁头旋转到相应的扇区所耗费的时间，大概4-5ms左右；</li><li>在扇区读写数据所耗费的时间，基本可以忽略。</li></ol><p>因此，任意一块扇区的访问（读或写）大致需要15ms，数据一般被排列为相邻扇区组成的磁盘块，B-Tree可以极大地减少访问次数，尽管使得磁盘块内的读写代价增加，但这些代价相比于磁盘访问耗时可以忽略不计。</p><p>可以通过一个例子感受下B-Tree和BST的差距：假设数据库有<span class="math inline">\(n=10^6\)</span>条记录，每条记录包含4B的key（如id等）和50B的信息，扇区大小512B，指针大小4B。</p><ul><li>如果选择BST来存储，每个结点共有62B（key+value+2*pointer），每个扇区可以存储8个记录，由于访问次序是随机的，因此不太可能接连访问同一个扇区内的记录（该情况磁头无需大规模移动，即访问2个记录的时间和访问1个记录相同），故访问每条记录均需要15ms，在<span class="math inline">\(n=10^6\)</span>条记录中查找任意一条记录最好情况下需要<span class="math inline">\(log_2n=20\)</span>次查询，共耗时0.3s左右。</li><li>如果选择4阶B-Tree来存储，每个结点共有414B（最多7个key+7个数据域+8个孩子指针+1个整数记录当前结点的key数目），在<span class="math inline">\(n=10^6\)</span>条记录中查找任意一条记录需要<span class="math inline">\(log_4n=10\)</span>次结点查询（0.15s）以及在该结点内部查找对应记录的时间（可忽略），性能大大提升。</li></ul><figure><img src="https://img-blog.csdnimg.cn/c21d39e6148343eb8bae5953f21e713b.png" alt="" /><figcaption>3阶B树索引</figcaption></figure><h2 id="b-trees-1">B+ Trees</h2><p>B+ Tree的非叶结点只存储key，叶子结点存储(key, value)并且将所有叶子链成单链表。</p><p>MySQL数据库支持多种存储引擎，不同的存储引擎可能采用不同的索引结构。InnoDB</p><p>B+树相比B树的优势有两方面：</p><ol type="1"><li>由于内部结点只保存key，因此内部结点可以存储更多指针，降低树的高度，减少磁盘I/O次数；</li><li>叶子结点之间通过指针链接，方便区间查询。</li></ol><p>红黑树等二叉树相比于B+树要高得多，因此磁盘I/O更加频繁，更适合在内存中查找。</p><h2 id="红黑树">红黑树</h2><p>是具有如下性质的BST：</p><ul><li>每个结点要么红要么黑；</li><li>根结点是黑；</li><li>红色结点的孩子必须是黑色；</li><li>所有从根到null的路径均含有相同数目的黑色结点。</li></ul><h2 id="跳表">跳表</h2><p>LC 1206<br />https://oi-wiki.org/ds/skiplist/</p><h2 id="reference">Reference</h2><p><a href="https://www.youtube.com/watch?v=aZjYr87r1b8">B Trees and B+ Trees. How they are useful in Databases</a><br /><a href="https://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/02/Small02.pdf">Balanced Trees</a><br /><a href="https://www.cs.utexas.edu/users/djimenez/utsa/cs3343/lecture16.html">B-Trees</a><br /><a href="https://web.stanford.edu/class/cs346/2015/notes/Blink.pdf">B+ Review</a><br /><a href="https://zhuanlan.zhihu.com/p/107228878">为什么Mongodb索引用B树，而Mysql用B+树</a><br /><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a><br /><a href="https://www.jianshu.com/p/d67c637776d6">Mysql索引BTree、B+Tree详细分解</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记本血泪史</title>
      <link href="/2018/03/29/%E7%AC%94%E8%AE%B0%E6%9C%AC%E8%A1%80%E6%B3%AA%E5%8F%B2/"/>
      <url>/2018/03/29/%E7%AC%94%E8%AE%B0%E6%9C%AC%E8%A1%80%E6%B3%AA%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="缘由">缘由</h2><p>我是ACER笔记本，电脑从桌子上重摔，之后几天可以正常使用。可是后来看完视频准备退出的时候，发现所有页面已经卡死了，内存占用已经超过了80%，任务管理器没有反应，不得已按了电源键强制关机。<br />接着就再也启动不了，开机后一直显示No bootable device。<br />进入BIOS发现检测不到硬盘，估计是硬盘损坏了。啊~所有数据全都GG了！！！</p><h2 id="硬盘处理">硬盘处理</h2><p>先是用WinPE启动盘进入DiskGenius查看，没有我的HDD；<br />接着拆机，把硬盘重新插拔一下（也许是连接松了呢~），还是没用；<br />最后用硬盘盒子接到室友电脑，还是无法检测，这下彻底确认硬盘凉了；<br />拿去维修店，专业人员检测后说是磁头坏了，修复数据1T要800RMB，哇穷~<br />换块新的要480，有点坑哦！<br />还是自己买一块希捷的，加上各种优惠，不到300RMB。</p><h2 id="重装系统">重装系统</h2><p>第一次重装系统，折腾了很久，试错的细节记不清了，只说一下大体的步骤：</p><ol type="1"><li>插上新硬盘之后，先用WinPE启动，用DiskGenius将硬盘的MBR格式转为GPT格式，此时不用分区；</li><li>插上U盘启动盘，重启电脑，按F2进入BIOS，切记关掉Boot Security，否则系统无法安装；</li><li>如果出现安装程序无法创建新的系统分区，也无法定位现有系统分区的提示，建议如下处理：<br /></li></ol><ol type="a"><li>在安装界面按Shift+F10进入命令行；<br /></li><li>输入diskpart启动磁盘程序，接着输入list disk查看电脑的硬盘；<br /></li><li>按提示输入select disk 0，选中编号为0的磁盘，输入clean，删除硬盘所有数据；<br /></li><li>输入convert GPT，转换格式，然后list partition，查看分区情况；<br /></li><li>输入<code>create partition efi size*100</code>，创建EFI分区，大小100MB；<br /></li><li>输入<code>create partition msr size*128</code>，创建MSR分区，大小128MB；<br /></li><li>输入<code>create partition primary size*50000</code>，创建主分区，大小50GB。(建议这个系统盘分的大一点，否则以后清理很麻烦)；<br /></li><li>输入list partition，查看分区情况。<br />P.s. 遇到这种情况，网上有的说可以重新插拔u盘启动盘，刷新；或者利用Windows自带的引导文件安装，具体的可以自己试试~</li></ol><ol start="4" type="1"><li>下来一路Next，装系统即可。</li></ol><h2 id="再次遭殃">再次遭殃</h2><p>距离上次硬盘事件已经过去了一年半，当我开心地吃着零食追着剧，想把页面切到咪咕下几首歌时，电脑瞬间卡死。<br />后来反思了一下：一是我习惯长期不关电脑，只是进入睡眠状态，可能资源本身已经占用很多了；二是打开的页面太多，而且切换太过频繁。<br />强制关机后就Game Over了~（遇到这种情况，一定不要继续操作，等着吧！等到听不到硬盘的转动声再按电源键！！！）<br />BIOS偶尔还能检测到HDD，经过专业人士检测：硬盘损坏，600RMB修复1T，好像比上次便宜了一些~<br />一般机械硬盘保修期都是2年，所以就免费换了块新的~<br />建议有条件的直接上固态吧，条件差点的可以固态装系统、机械存文件，没条件的就凑合用吧。。。<br />这次数据损失不大，吃了一堑还是有点用的，不过备份频率得改为一周一次了。<br />重装系统可以去老毛桃做个启动盘，把Windows的ISO镜像拷到U盘根目录，开机进入Win PE系统后，里面有个一键装机的软件~<br />不过不知道是不是由于机型的原因，那个软件我的本用不了（垃圾Acer）：<br />所以就利用UltraISO把ISO镜像写入到U盘，插上之后开机，就会进入Windows的安装引导程序，分区也会在其中的一步引导你去做。<br />不同机型可能稍有差异，具体步骤可以参考<a href="https://blog.csdn.net/weixin_43175701/article/details/84349445">笔记本换硬盘装系统完整教程</a>。</p><p>重装系统一般有2种方法：</p><ol type="1"><li>PE：老毛桃等工具直接把ISO放在u盘就可以一键装机，可能会有捆绑</li><li>msdn+UltraISO：把ISO写入u盘制作启动盘，比较干净，费u盘</li></ol>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fibonacci Sequence</title>
      <link href="/2018/02/07/Fibonacci%20Sequence/"/>
      <url>/2018/02/07/Fibonacci%20Sequence/</url>
      
        <content type="html"><![CDATA[<h2 id="递归">递归</h2><p>斐波那契数列定义： <span class="math display">\[F(n)=\left\{\begin{matrix}0, n=0\\1, n=1\\F(n-1)+F(n-2), n&gt;1\end{matrix}\right.\]</span> 递归解法最直观，但是复杂度也最高：<span class="math inline">\(O(2^n)\)</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="comment">//细节可以处理非法输入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 为了避免重复计算，可以将每一步计算得到的<span class="math inline">\(F(i)\)</span>存起来，这样的话时间复杂度降为<span class="math inline">\(O(n)\)</span>，但空间复杂度升为<span class="math inline">\(O(n)\)</span>。</p><h2 id="通项">通项</h2><p>求解通项的方法有好几种，下面展示一种用线性代数求解的方法：<br />斐波那契数列的递推公式是二阶差分方程，先用一点小技巧将其化为一阶： <span class="math display">\[\begin{cases}F_{k+2}=F_{k+1}+F_{k}\text{}\\F_{k+1}=F_{k+1}\text{}\\\end{cases}\]</span> 我们令<span class="math inline">\(u_k=\begin{bmatrix}F_{k+1}\\F_{k}\\\end{bmatrix}\)</span>，那么<span class="math inline">\(u_{k+1}=\begin{bmatrix}F_{k+2}\\F_{k+1}\\\end{bmatrix}=\begin{bmatrix}1\ 1\\1\ 0\\\end{bmatrix}u_k\)</span>。<br />矩阵<span class="math inline">\(A=\begin{bmatrix} 1\ 1\\1\ 0\\\end{bmatrix}\)</span>，令<span class="math inline">\(det(A-\lambda I)=\lambda^2-\lambda-1=0\)</span>，求得<span class="math inline">\(\lambda=\frac{1\pm \sqrt5}{2}\)</span>，对应于两个特征值的特征向量为<span class="math inline">\(x_1=\begin{bmatrix} \lambda_1\\ 1\\ \end{bmatrix},x_2=\begin{bmatrix} \lambda_2\\ 1\\ \end{bmatrix}\)</span>。<br />求得特征值和特征向量后，我们将<span class="math inline">\(u_0=\begin{bmatrix} F_1\\ F_0\\ \end{bmatrix}=\begin{bmatrix} 1\\ 0\\ \end{bmatrix}=c_1x_1+c_2x_2\)</span>，解得<span class="math inline">\(c_1=-\frac{1}{\sqrt5}, c_2=\frac{1}{\sqrt5}\)</span><br />故<span class="math inline">\(u_k=S\Lambda^{k}c=\begin{bmatrix} c_1\lambda_1^{k+1}+c_2\lambda_2^{k+1}\\c_1\lambda_1^{k}+c_2\lambda_2^{k}\\\end{bmatrix}\)</span><br />所以通项公式可以表示为<span class="math inline">\(F(n)=C_1\lambda_1^n+C_2\lambda_2^n\)</span>。<br />故斐波那契数列的通项公式为：<span class="math inline">\(F(n)=\frac{1}{\sqrt5}[(\frac{1+\sqrt5}{2})^n-(\frac{1-\sqrt5}{2})^n]\)</span><br />用公式求解的复杂度为<span class="math inline">\(O(1)\)</span>，但是由于无理数在计算机中的存储不是精确的，所以结果的精度很难保证。</p><h2 id="分治">分治</h2><p>通过矩阵形式的递推： <span class="math display">\[\begin{bmatrix}F(n)\\ F(n-1)\end{bmatrix}=\begin{bmatrix}1\  1\\ 1\  0\end{bmatrix}\begin{bmatrix}F(n-1)\\ F(n-2)\end{bmatrix}\]</span> 不断向下递推，可以得到： <span class="math display">\[\begin{bmatrix}F(n)\\ F(n-1)\end{bmatrix}={\begin{bmatrix}1\  1\\ 1\  0\end{bmatrix}}^{n-1}\begin{bmatrix}F(1)\\ F(0)\end{bmatrix}\]</span> 接下来就是求解矩阵的高次方，通过<a href="https://baike.baidu.com/item/快速幂/5500243">快速幂</a>可以在<span class="math inline">\(O(logn)\)</span>时间内进行计算：<br />整数的快速幂代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> half = raise(base, <span class="built_in">exp</span> / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> base * half * half;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> half * half;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将传入的参数改为矩阵，乘法改为矩阵乘法，就可以得到矩阵快速幂：<br />以二阶矩阵为例，求解斐波那契数列： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;base,ans;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">multi</span><span class="params">(Matrix a, Matrix b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="comment">//第i行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)  <span class="comment">//第j列</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.a[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                res.a[i][j] += a.a[i][k] * b.a[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base.a[<span class="number">0</span>][<span class="number">0</span>] = base.a[<span class="number">0</span>][<span class="number">1</span>] = base.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    base.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;   <span class="comment">//初始化矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果矩阵初始化为单位阵</span></span><br><span class="line">    ans.a[<span class="number">0</span>][<span class="number">0</span>] = ans.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    ans.a[<span class="number">1</span>][<span class="number">0</span>] = ans.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = multi(ans, base);</span><br><span class="line">        &#125;</span><br><span class="line">        base = multi(base, base);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    QuickPow(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.a[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="动态规划">动态规划</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        ans = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refs">Refs</h2><p><a href="https://www.zhihu.com/question/28062458/answer/39763094">斐波那契数列</a></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hardware Introduction</title>
      <link href="/2018/01/20/Hardware%20Introduction/"/>
      <url>/2018/01/20/Hardware%20Introduction/</url>
      
        <content type="html"><![CDATA[<p>计算机硬件组成可以概括为下图： <img src="https://img-blog.csdnimg.cn/36738bbcb45545f2a2b98519a5d8f838.png" alt="img" /></p><h2 id="cpu">CPU</h2><p>CPU生产商主要是Intel和AMD。<br />Intel的产品主要有四种：</p><ul><li>Celeron(赛扬)：低端处理器</li><li>Pentium(奔腾)：比赛扬强，比酷睿弱</li><li>Xeon(至强)：属于服务器处理器<br />-E3<br />-E5<br />-E7<br /></li><li>Core(酷睿)<br />-i3<br />-i5<br />-i7</li></ul><p>AMD产品主要有三种：</p><ul><li>FX系列：旗舰级多核处理器，AMD FX-8350</li><li>Athlon(速龙)系列：入门级多核处理器，AMD Athlon X4 870K</li><li>A系列(APU)：A4，A6，A8，A10依次增强，集成了核心显卡，A10-7870K</li></ul><p>以Core i7-4770K为例，Core系列i7级别第4代处理器，770代表性能编号，代数相同，编号越大，性能越好；K代表可超频。<br />笔记本CPU可能带有后缀U/Y/M等：</p><ul><li>U：超低功耗笔记本CPU</li><li>Y：极低功耗笔记本CPU，比U更省电</li><li>M：笔记本CPU</li></ul><h2 id="显卡">显卡</h2><p>显卡分为核显和独显，核显集成于CPU内部，独显与CPU独立。<br />独显由GPU(图形处理器)和其他结构(显存，散热模块，PCB板等)组成。<br />目前生产GPU的主流厂商有三家：AMD，NVIDIA，Intel：</p><ul><li>AMD(A卡)<br />-HD系列：AMD HD 7970 x2---第7代高端(数字9代表高端，8中端，7低端)双核GPU，第三位7代表性能，3，5，7，9依次增强，x2代表双核心。<br />-R系列：AMD R9 M290X---R9：R系列高端；M：笔记本GPU；290X：2代高性能增强型GPU。</li><li>NVIDIA(N卡)<br />NVIDIA GTX 980 TI：X表示性能比GT系列更强；980：9代高性能；TI：增强型。</li><li>Intel(I卡)<br />I卡都是核显，有两个系列：<br />-HD系列：HD P4600---P：企业级；4600：代表性能，一般数字越大，性能越好。<br />-Iris(锐炬)系列：Iris Pro 5200---Pro：专业版；5200：代表性能，同上。</li></ul><p>显存：SDDR3，DDR3，GDDR3，GDDR5，同容量下性能依次增加。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang FAQ</title>
      <link href="/2017/01/30/Golang%20FAQ/"/>
      <url>/2017/01/30/Golang%20FAQ/</url>
      
        <content type="html"><![CDATA[<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build  <span class="comment">// 编译</span></span><br><span class="line"><span class="keyword">go</span> run  <span class="comment">// 编译运行</span></span><br><span class="line"><span class="keyword">go</span> fmt  <span class="comment">// format</span></span><br><span class="line"><span class="keyword">go</span> install</span><br><span class="line"><span class="keyword">go</span> get</span><br><span class="line"><span class="keyword">go</span> test</span><br></pre></td></tr></table></figure><p>types of package 1. 可执行包：只有名称为main才是 2. reusable：其它都是库</p><p>bool string int float64</p><p>Go不是面向对象的语言，因此没有class/instance的概念</p><figure><img src="https://img-blog.csdnimg.cn/54aa480dbe924f0a86bdb02b6af3c73a.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><p>数组只能固定长度，传入变量只能创建为定义了size的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">length := <span class="number">5</span></span><br><span class="line">array := [length]<span class="keyword">int</span>  <span class="comment">// error: non-constant array bound length</span></span><br><span class="line">array := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Rabbit and Turtle</title>
      <link href="/2016/10/15/Rabbit%20and%20Turtle/"/>
      <url>/2016/10/15/Rabbit%20and%20Turtle/</url>
      
        <content type="html"><![CDATA[<p>知乎上有这样一个问题：<a href="https://www.zhihu.com/question/22364825/answer/27255001">如果兔子都在拼命奔跑，是什么给了作为乌龟的你前进的动力？</a><br />随着视野的不断开阔，我们难免怀疑自身前进的意义，曾经有很长一段时间我也深陷其中，直到看到余亦多先生的回答才有所感悟。</p><blockquote><p>我想每个人成长的经历中，都会或多或少曾被“自卑”的情绪所笼罩。我自己就是一个一直纠缠于“失败者”情结的人。</p><p>小时候因为痴肥，体育课上在同学面前抬不起头；搬到大城市，因为口音以及内向的性格，成为全班男生的出气筒；到了高中，进到全省理科实验班，才知道有些学霸的智商，是自己一辈子都无法企及的；初到美国，被身边同学认为是FOB，来自第三世界国家的乡巴佬；混进所谓的世界名校，看到身边一大波牛人，陷入平庸的沮丧；好不容易挤到纽约华尔街，看到名校中选出的所谓“精华”，才开始面对自己综合能力的缺失。</p><p>再回到香港，身边很多投行同事的业务能力与人际能力都远胜于我，只能在高压力的环境下苟延残喘；从乙方转到甲方开始做PE投资后，当跟索罗斯的儿子同桌斗智斗勇时，才能深刻体会“家学渊源”与“赢在起跑线”对一个人的意义。</p><p>由外资换到国企，开始看到体制内藏龙卧虎的主流玩家真正在玩什么，才意识到以前在边缘化外资环境下膨胀出各种不接地气的泡沫有多么可笑；随后开始接触到保险、银行以及其他金融领域的强人们，才知道在整个金融大版图中，十倍百倍于自己原来折腾的小池塘规模的资金，是在做什么。</p><p>分享了上面一大段，其实我想说的，最重要是如下几点：<br />1、就像talich老师在我去斯坦福念书以前赠我的那句话：<br />到了那儿，不用指望成为牛人，但至少你知道大海有多宽，能看到牛人在做什么，就够了。<br />对乌龟来讲，兔子存在的意义在于，至少让它知道这世界还有“兔子”的存在，以及兔子跑得有多快。盗用一句标语：让你看到更大的世界，这本身就是最大的意义。<br />2、兔子的存在，能够让乌龟直面自己就是一只乌龟这个事实。有勇气面对真实的自己，才能准确的定位自己的位置，也才能冷静的思考最适合自己的人生规划。而这，很多时候恰恰是最知易行难的事。<br />3、其实人越往后走，越会深刻体会到“阶级”的不可逾越性。愤青的时候会咒骂：“这世界为什么这么不公平。”可当你不再被荷尔蒙冲昏头脑时，也许你会开始思考：既然现在是这种情况，那我应该做点什么呢？当你绞尽心机让自己变得更好的同时，也许你也在让这个世界变得更好。</p><p>当樱木花道完成两万球的训练之后，他才知道流川枫有多厉害。<br />因为在一次比赛中，他看到流川枫的一个中投，这个起跳，这个姿势，这个弧线，竟然是他训练中想象的最完美的画面。<br />他很气，紧握这拳头，又不甘心，他问教练：这只狐狸是从什么时候开始打篮球的？<br />安西教练：你应该好好的盯着流川枫的姿势，尽可能的模仿他，然后用3倍于他的训练量训练。这样，你才有可能在高中阶段之内超越他。<br />流川枫是那只兔子，幸运的是，樱木大概也是。</p><p>题主的困惑在于，樱木是个天才，尚且如此，而你，可能只是木暮。<br />李宗盛有一首歌，歌词是这样的： 最近比较烦比较烦比较烦，我看那远方怎么也看不到岸，那个后面还有一班天才追赶，写一首皆大欢喜的歌，是越来越难。</p><p>中年危机全都是这样的：<br />前面比你牛逼的人一眼都望不到岸，后面一班天才，比你有精力，比你聪明，比你学历高，比你国际化。而你，小孩成绩你得操心，老婆吃秘书的醋你也得操心，父母身体逐渐糟糕，最可怕的是你头发越来越少，身体越来越胖。</p><p>题主的困惑在于，比你天才的那个人，还比你努力；比题主的困惑更可怕的是，这个比你努力的天才，还比你年轻，比你有精力，这意味着，即使你想努力，你也没有那个精力努力。这就更无力了。</p><p>《蜗居》里面，宋思明想抢郭海藻。他比小贝成熟、稳重、懂得女孩的心思，样貌也不差；他有钱，有人际，能帮海藻解决问题。<br />若是宋思明未婚，小贝拿什么跟人家拼？小贝可能一辈子都达不到宋思明的高度，即使拼尽全力。<br />这才是无力感。<br />所以，我们能做什么。</p><p>如果你是个绝对的蠢蛋，那我只能说，请你尽量少的认识这个世界，最好一辈子不要离开你生活的地方，有时候知道的越多，越痛苦。当你看到那么繁华的城市，那么美丽的女孩，那么高端大气上档次的生活都与你无关的时候，更多的痛苦便会袭来。<br />如果你是个笨蛋，又不肯努力，那也请你知道少一点。<br />如果你不是个绝对的蠢蛋，又愿意努力，请你参考第一段安西老师的话：盯着那只兔子的每一个动作，能学多少学多少，然后以他三倍的训练量训练。</p><p>兔子一定会打盹的，即使牛逼如牛顿，30岁之后也再无建树；也不是每个像科比一样的天才，都知道洛杉矶凌晨四点的样子；你知道洛克李吗？火影里那个相信笨鸟先飞的热血少年，他说，努力的天才也是天才。<br />我曾经在一个答案中说过，勤奋，可能是这个世界上最被高估的美德。但是对于一个毫无天赋的人来讲，可以依仗的就只有勤奋了。</p><p>如此，即便你还是追不上兔子，你可以是乌龟里跑得快的那一个。<br />如此，即便你是木暮，你也能做成一个，每天都比昨天好一点点的木暮。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Predecessor </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

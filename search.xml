<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS231n Assignment</title>
      <link href="/2022/01/13/CS231n%20Assignment%20#2/"/>
      <url>/2022/01/13/CS231n%20Assignment%20#2/</url>
      
        <content type="html"><![CDATA[<h2 id="fully-connected-neural-network">Fully-connected Neural Network</h2><p>我好菜啊！！很早就写完代码了，gradient check也过了，但是需要过拟合50张图片的时候一直不太对，调了几下学习率，我看train acc只有0.14左右，loss曲线波动也很大： <img src="https://img2020.cnblogs.com/blog/1260581/202109/1260581-20210912161403754-1113281186.png" alt="image" /> 因为最后要100%的train acc嘛，我看差的挺远的，就开始怀疑是网络哪里写错了，就没管超参数，检查代码检查了好几天tmd，深度学习debug还真是无从下手...后来跑去看了下别人的东西，发现原因竟然是不会调参(T^T)。</p><p>仔细看下，这里还是很明显的，20个epoch训练损失才下降了一点点，说明学习率太小了。 <img src="https://img2020.cnblogs.com/blog/1260581/202109/1260581-20210912162656860-43278840.png" alt="image" /></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的2021</title>
      <link href="/2022/01/01/%E6%88%91%E7%9A%842021/"/>
      <url>/2022/01/01/%E6%88%91%E7%9A%842021/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1bef302f2256732ff3df9e0b76e314e1df593d09af332e633c4b84872982e471">418fac4f173397084caccc18ab9f089eaf702aae8c906633ee725339826bde4ebec23ac7f20a16eaf981ffe22bfb7a3499015a81686afa91db1861abacbb176df1e94c96b801c049372caec75a543b9e364abe51c5ed77d20c37e7d43545c1c0a2510f6fd2dd06cc42980d17257e4fbad82e9369d85dffd9723d3abd468c55f7ca194627ca3afd9a9bbc0583b3761b60958dc579825976d025c787a9116dd6874ffdd782e55914a06bd768bb24fd7e71f1e6fa9fbff74596bfb59cf66b7d91c19d118aca31cd1fb95a411fc6bd5a286ec459c7ace6b32f8f392496a5deae2ec57aff0218f533a49f81f9e9ba820cd4d532c9c319d74622f0ddd669c36177356cf623d68dca635e0bc695e7095334375c4c867027afee9628af94e83c363ab864bbbc03e1c402e4793a6208e524679ab314f923a1e59ec51589405539a8b7868dbbb8671f1e89d62a1f90dc483ae851d7630f58cc76164af1fc7231072af13687100cab5026046e5f04084e2a5f8b04b02cb364bc18b055f3f963723f38d0dcbf458551ab1e083882689cd95f51d4bc2b03b8e15609f488bc6b736559640135c441409104f091df3af6b27bc6e6916d94f7de5cdf1504668e7c0e0dbcd475562cff0a09a31cafbf064a0c54cb18a7b09cfdc5f405ef88af622ed0d7c52f6c6daeae87c5cdef73cf692213a607501c7ab11524dfdbc0cf4a4dcdb91eec1e1942c59149a7c2cae8a3416b4aa5840f5a041e3e2c5a9b2e61e5309576e3733b21e2bd7d8115639d04dffa3f87751b10b7954be00fdcfe54af5db6457d2db4a8f66f60d305e9a7ac3c9d7007fd157768567c5836c2735310d7650de4827cadf2722d9a7b20e35e160f2c7ffff2d3ec0c4253159e6d1d8752d2cae9e2105b2a900b57c2dd29f0b46944d891f1b6d4e2962fe96cdb089aed2d1b9363f2f7386a20c49313e4187206441c56086edc4eb27a77ebe85b7d716b197b9eb90de18ec27792ff18189ff260e93f2f8766088492e45a42dd23093f98e331812abc997c553bd8d8960a0a4011d43791ff07b2fda47703968c10cb67bbb4b1ae57e1cc36692e2fa08de043d82c19e5f73917d8c2578b13a62d6f750606de30c1560b090e8247cd8c03427e582cdf0f4cbe9e54bea52921b9260d6e9ac6705bcdf38a06f0b470ccaa60eed4f9d95dcc60f67cf8b28ce68ec8aacf5b24d396f073f5519088a66aed4ec9b0560cb5ebd4e5439499e42a3e1d439bcd27bbba402dae1bd99c23a8c4fe67e57ccab568f1e47edfa7bced946134658ce88d2aa5de0cb920742a77186a4cf6ba57ef53948fc0f74b6905b70d9553bda30ede83a9b0d78f96c02cf49a58e8bccf5d63f6a142874f4de676ede77e937c556ffcdf31e434ca6f6d92e35c7ea999a4636760b300339225f269f36c3c4bc64a91eca2598c49b3936e0a113af2de7439a44674c9c7d8d08cb7c3e2fcf7bb9fae44595c9df36b43db721e551f7cf531a4d130f44234af5f1c27b79070f524e9b4227fbde10f8a04df6aeb367cc387219d1273e1942b531185a98c85c31cbefb25a5d5ecd161c0759fc017691a2318936563c2893083bd29dbeef16673f48cdc33baf8c1429813f826c8c1e8b34a7a2af75f228172936a1f13dcb974f7455d1dda9dfb0cb54573081a0778fdfaeb056a878ad0406b01eef0b73fca26fa568cba559022ca8332edbbacff728dc1a982f7ffcf58c4e3da1a4cfba971e79dd1fd8c9178250a2cb8fc852c086ca33a4405ea9417d555487bf12fba245a798039ead92a713d34498c9e4e3933e15ed9afcbe48d35cc154348eceb64ac4d2d05a581eed7fb3de9364940a32cfaed0302164a140d377bdc5ef24aa8b14ced9ac186078f56923996233f00e043a8a9855fdb7842838337c30953ea3617788b1cabad8ebb239c9f91adef41009025d6ffea7d002717a06ac843f068c134e621dc6226cfa8a7fb9623b657c1d15a75d6b0fef76f5ba415b8137f66bea058fd5c14a7fac1b88d0ba98be3dfce8231f396e1c820d4a2a287929efb4e46252f054f067b7b9757f42b0f2f47684b8816f1ae9c06c4c387ca229a2be1e9857f4408277983818b51d3e67c443c33f1631ff46b48ddd0bcc4e4741bb08feda16cf9a5b5160f4fcfc0965060860d185a60c3d4ec2bae4560f451ff13cc5078a1afc963c9d3912acc95ddb790dcd2c237c3704d3fb1670dc538ffcadb017771e34384d5a957bbed61ddbd282ce92b63b474406a2c126ecc81847c73d4a9714965b40ea6ed1002e4577745799d73292253049803145d403e331e684a6f8083cbbec6e0a5ad7039132ca8f5a392be0c2638df72db66a4bdcc652651d918079ae8d06b0f1b3f34d85bc52a5146b57590e4a441435febf190d9f85c1174b27cc047f388e0550dae0ec4be6fff3de3422b611e1b538fdab1879843102a55282e8f294e5424eada6b49d131b48f6aa137c7332d9ff36268ccb47b5be287bdca6ea5f9c4a6d2708f548425c98261a72530b266ecb8112904d9e5a645ed844804c0c14b40e5e7f296aeafc952828882d1004043c3e1ea3923c7de768cb8488248199189b43a88702b363cfe27da5c0564a40e572806340df4fcba96305a8873dcb9a5df827dce79ef3e459c5d5b11515ae4d884816043aad526935d9e2098e6ec15f9e90d762801b7e16badc13c714c8e0105f91b6a0b566f050c3939ccdfc5cbe8bde3bbff1ef481241bd68674c9ea4678c0f18045f03542ddf987a040a7ddb776ac163ff8b56a061523402d80b2d0432bf38013cca2fbbf9482012170494940884265c6c7de7eea1e9364070101cd7f6c69941989edc2c173bcc42dedc74c78d90b803dbb96494853c1958c3bfeb56c92801e68d056c6d817490fcfae15b2d8138a6d6fd741422959fa35644243cfd3df4df5722b565fe9cdedab214ed37f720f115c7a3f5e3ce3999f10df557d73d2cb8e749ced40f4b1b735073645df341b89fb733a15e7d7c22f25f14915c05a6b5e28c08d91a3e1c870303802ebd1b3240657d42b9416536a9ff998480a13dc63bb99c9734493a3560dec937e8ac83d4d45453e8932df5073b1d82657e677f7aeec755634d979deb8214980db9ef4fb06ae2b79275b58bedbf93dc2a910498c00cc3a1f4064c05cba82cd7228a7b8de4ace0d433e1fcb6d0358ff3c13db23788edf9992138ddae616129bc4190f1683410de706fcfb5887f85424c3ccf3f482bc06cd9e508bdd0ba3aea2f519a04f95cabc6460f1dc533ba08a0939b2a4518548a4675fe2d6714977ab972e1adcb632fda2b88068a52e5fd971df2c0c0730ac64b907c0258d6ce3c95584eb17cb5bdea677685f3bb6e828a02f7f855b2c6a0c07313c0dbc90bb68348bf4521501fb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Experience </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面筋</title>
      <link href="/2021/12/28/%E9%9D%A2%E7%AD%8B/"/>
      <url>/2021/12/28/%E9%9D%A2%E7%AD%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="语言基础-cc">1. 语言基础 (C/C++)</h1><h4 id="堆和栈有什么区别">（2） 堆和栈有什么区别</h4><ul><li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li><li>堆空间因为会有频繁的分配释放操作，会产生内存碎片</li><li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小 #### （3）堆快一点还是栈快一点？（字节提前批一面） 栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。 #### （4） new和delete是如何实现的，new 与 malloc的异同处 在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</li></ul><p>new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名 #### （5）既然有了malloc/free，C++中为什么还需要new/delete呢？ https://blog.csdn.net/leikun153/article/details/80612130</p><ul><li><p>malloc/free和new/delete都是用来申请内存和回收内存的。</p></li><li><p>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。 #### （6） C和C++的区别 包括但不限于：</p></li><li><p>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。</p></li><li><p>C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete</p></li><li><p>C++中还有函数重载和引用等概念，C中没有 #### （7）delete和delete[]的区别</p></li><li><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p></li><li><p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p></li></ul><h4 id="cjava的联系与区别包括语言特性垃圾回收应用场景等java的垃圾回收机制">（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h4><p>包括但不限于： * C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。 * C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法 * C++有指针，Java没有指针，只有引用 * JAVA和C++都有构造函数，但是C++有析构函数但是Java没有 #### （9）C++和python的区别 包括但不限于： 1. python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。 2. python使用缩进来区分不同的代码块，C++使用花括号来区分 3. C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等 4. python的库函数比C++的多，调用起来很方便 #### （10） Struct和class的区别 * 使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的 * struct的继承默认是public继承，而class的继承默认是private继承 * class可以用作模板，而struct不能 #### （11） define 和const的联系与区别（编译阶段、安全性、内存占用等） 联系：它们都是定义常量的一种方法。</p><p>区别： * define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。 * define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。 * define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。 * const可以定义函数而define不可以。 #### （12） 在C++中const的用法（定义，用途） * const修饰类的成员变量时，表示常量不能被修改 * const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</p><h4 id="c中的static用法和意义">（13） C++中的static用法和意义</h4><p>static的意思是静态的，可以用来修饰变量，函数和类成员。 * 变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。</p><ul><li><p>函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。</p></li><li><p>类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。</p></li></ul><p>【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。</p><p>注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。 #### （14） 计算下面几个类的大小： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl; <span class="number">0</span>;=<span class="string">&quot;&quot;</span> <span class="number">1</span>;=<span class="string">&quot;&quot;</span> <span class="number">4</span>(<span class="number">32</span>位机器)=<span class="string">&quot;&quot;</span> <span class="number">8</span>(<span class="number">64</span>位机器);=<span class="string">&quot;&quot;</span> __vptr，其大小是<span class="number">4</span>字节&lt;br=<span class="string">&quot;&quot;</span> ```=<span class="string">&quot;&quot;</span> ```c++=<span class="string">&quot;&quot;</span> a=<span class="string">&quot;&quot;</span> a;=<span class="string">&quot;&quot;</span> class=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;=<span class="string">&quot;&quot;</span> <span class="built_in">fun</span>()&#123;&#125;=<span class="string">&quot;&quot;</span> <span class="keyword">int</span>=<span class="string">&quot;&quot;</span> <span class="built_in">main</span>()&#123;=<span class="string">&quot;&quot;</span> <span class="keyword">return</span>=<span class="string">&quot;&quot;</span> <span class="keyword">virtual</span>=<span class="string">&quot;&quot;</span> &#123;=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span> &#125;;=<span class="string">&quot;&quot;</span> 因为有虚函数的类对象中都有一个虚函数表指针=<span class="string">&quot;&quot;</span> 在c\+\+中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为<span class="number">0</span>了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。=<span class="string">&quot;&quot;</span> 空类的大小是<span class="number">1</span>，=<span class="string">&quot;&quot;</span> 空类的实例大小就是类的大小，所以<span class="built_in"><span class="keyword">sizeof</span></span>(a)=<span class="string">&quot;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。&quot;</span> 输出=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">```C++</span><br><span class="line">class A &#123; <span class="keyword">static</span> <span class="keyword">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl; ####=<span class="string">&quot;&quot;</span> *=<span class="string">&quot;&quot;</span> ++内存管理（热门问题）=<span class="string">&quot;&quot;</span> <span class="number">0</span>;=<span class="string">&quot;&quot;</span> <span class="number">1.</span>=<span class="string">&quot;&quot;</span> <span class="number">1</span>;=<span class="string">&quot;&quot;</span> <span class="number">1</span>）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，**由于对象还未创建成功，编译器无法知道对象的实际类型**，是类本身还是类的派生类等等=<span class="string">&quot;&quot;</span> <span class="number">2.</span>=<span class="string">&quot;&quot;</span> <span class="number">2</span>）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了=<span class="string">&quot;&quot;</span> <span class="number">3.</span>=<span class="string">&quot;&quot;</span> <span class="number">3657717.</span>html)=<span class="string">&quot;&quot;</span> <span class="number">4.</span>=<span class="string">&quot;&quot;</span> <span class="number">4</span>;=<span class="string">&quot;&quot;</span> <span class="number">5.</span>=<span class="string">&quot;&quot;</span> <span class="number">50688337</span>)=<span class="string">&quot;&quot;</span> <span class="number">51088091</span>)=<span class="string">&quot;&quot;</span> <span class="number">81870219</span>=<span class="string">&quot;&quot;</span> <span class="number">98889139</span>=<span class="string">&quot;&quot;</span> <span class="number">99497160</span>=<span class="string">&quot;&quot;</span> [c++中的静态绑定和动态绑定](https:=<span class="string">&quot;&quot;</span> ```=<span class="string">&quot;&quot;</span> ```c++=<span class="string">&quot;&quot;</span> a=<span class="string">&quot;&quot;</span> a;=<span class="string">&quot;&quot;</span> article=<span class="string">&quot;&quot;</span> b;=<span class="string">&quot;&quot;</span> blog.csdn.net=<span class="string">&quot;&quot;</span> c=<span class="string">&quot;&quot;</span> c++=<span class="string">&quot;&quot;</span> c++中的重载和重写的区别：=<span class="string">&quot;&quot;</span> c++的stl介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等=<span class="string">&quot;&quot;</span> c++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。=<span class="string">&quot;&quot;</span> c++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）=<span class="string">&quot;&quot;</span> class=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;=<span class="string">&quot;&quot;</span> details=<span class="string">&quot;&quot;</span> https:=<span class="string">&quot;&quot;</span> ifumi=<span class="string">&quot;&quot;</span> <span class="keyword">int</span>=<span class="string">&quot;&quot;</span> lihao21=<span class="string">&quot;&quot;</span> list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为<span class="built_in">o</span>(n);=<span class="string">&quot;&quot;</span> list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=<span class="string">&quot;”、“&lt;”等&quot;</span> lizhenghn=<span class="string">&quot;&quot;</span> <span class="built_in">main</span>()&#123;=<span class="string">&quot;&quot;</span> map底层是采用红黑树实现的，插入删除查询时间复杂度都是<span class="built_in">o</span>(<span class="built_in">log</span>(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。=<span class="string">&quot;&quot;</span> p=<span class="string">&quot;&quot;</span> qq_36359022=<span class="string">&quot;&quot;</span> qq_43152052=<span class="string">&quot;&quot;</span> <span class="keyword">return</span>=<span class="string">&quot;&quot;</span> <span class="keyword">static</span>=<span class="string">&quot;&quot;</span> stl中unordered_map和map的区别=<span class="string">&quot;&quot;</span> stl中vector的实现=<span class="string">&quot;&quot;</span> stl中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。=<span class="string">&quot;&quot;</span> stl中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。=<span class="string">&quot;&quot;</span> stl从广义来讲包括了三类：算法，容器和迭代器。=<span class="string">&quot;&quot;</span> stl源码中的hash表的实现=<span class="string">&quot;&quot;</span> unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现=<span class="string">&quot;操作符。&quot;</span> unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过<span class="number">8</span>时，就自动转为红黑树进行组织。=<span class="string">&quot;&quot;</span> vector::iterator和list::iterator都重载了“\+\+”运算符。=<span class="string">&quot;&quot;</span> vector使用的注意点及其原因，频繁对vector调用push_back\(\)对性能的影响和原因。=<span class="string">&quot;&quot;</span> vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以<span class="number">2</span>倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为<span class="built_in">o</span>(n)。=<span class="string">&quot;&quot;</span> vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=<span class="string">&quot;”，“&lt;”等操作符。&quot;</span> weixin_30379911=<span class="string">&quot;&quot;</span> www.cnblogs.com=<span class="string">&quot;&quot;</span> &#123;=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span> &#125;;=<span class="string">&quot;&quot;</span> &#125;;;=<span class="string">&quot;&quot;</span> 为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。=<span class="string">&quot;&quot;</span> 二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找<span class="number">1</span>^<span class="number">2</span>,<span class="number">2</span>^<span class="number">2</span>,<span class="number">3</span>^<span class="number">2</span>,<span class="number">4</span>^<span class="number">2.</span>....i^<span class="number">2</span>个位置。=<span class="string">&quot;&quot;</span> 介绍面向对象的三大特性，并且举例说明每一个。=<span class="string">&quot;&quot;</span> 代码区，存放程序的二进制代码=<span class="string">&quot;&quot;</span> 但由于链表的特点，能高效地进行插入和删除。=<span class="string">&quot;&quot;</span> 使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。=<span class="string">&quot;&quot;</span> 全局=<span class="string">&quot;&quot;</span> 关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。=<span class="string">&quot;&quot;</span> 动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。=<span class="string">&quot;&quot;</span> 包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象=<span class="string">&quot;&quot;</span> 即<span class="number">4</span>个字节=<span class="string">&quot;&quot;</span> 双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。=<span class="string">&quot;&quot;</span> 在c\+\+中，内存分成<span class="number">5</span>个区，他们分别是堆、栈、全局=<span class="string">&quot;&quot;</span> 在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。=<span class="string">&quot;&quot;</span> 在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。=<span class="string">&quot;&quot;</span> 在析构函数中调用虚函数，此时调用的是子类的函数实现方式。=<span class="string">&quot;&quot;</span> 基类的析构函数一般写成虚函数的原因=<span class="string">&quot;&quot;</span> 堆，就是那些由<span class="keyword">new</span>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<span class="keyword">new</span>就要对应一个<span class="keyword">delete</span>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。=<span class="string">&quot;&quot;</span> 多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。=<span class="string">&quot;&quot;</span> 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。=<span class="string">&quot;&quot;</span> 多态的实现（和下个问题一起回答）=<span class="string">&quot;&quot;</span> 多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：https:=<span class="string">&quot;&quot;</span> 大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用<span class="built_in">push_back</span>()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。=<span class="string">&quot;&quot;</span> 如果多重继承和多继承的话，子类的虚函数表长什么样子？=<span class="string">&quot;&quot;</span> 如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。=<span class="string">&quot;&quot;</span> 如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。=<span class="string">&quot;&quot;</span> 如果需要大量的插入和删除，而不关心随机存取，则应使用list。=<span class="string">&quot;&quot;</span> 如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块=<span class="string">&quot;&quot;</span> 实现编译器处理虚函数表应该如何处理=<span class="string">&quot;&quot;</span> 容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。=<span class="string">&quot;&quot;</span> 对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。=<span class="string">&quot;&quot;</span> 对象复用的了解，零拷贝的了解=<span class="string">&quot;&quot;</span> 封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的<span class="keyword">private</span>和<span class="keyword">public</span>；=<span class="string">&quot;&quot;</span> 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。=<span class="string">&quot;&quot;</span> 建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。=<span class="string">&quot;&quot;</span> 开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，stl的hashtable就是采用这种实现方式。=<span class="string">&quot;&quot;</span> 总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;=<span class="string">&quot;&quot;</span> 普通函数也不占用类大小=<span class="string">&quot;&quot;</span> 构造函数为什么一般不定义为虚函数=<span class="string">&quot;&quot;</span> 构造函数或者析构函数中调用虚函数会怎样=<span class="string">&quot;&quot;</span> 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。=<span class="string">&quot;&quot;</span> 浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。=<span class="string">&quot;&quot;</span> 深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。=<span class="string">&quot;&quot;</span> 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）=<span class="string">&quot;&quot;</span> 算法包括排序，复制等常用算法，以及不同容器特定的算法。=<span class="string">&quot;&quot;</span> 纯虚函数=<span class="string">&quot;&quot;</span> 纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承=<span class="string">&quot;&quot;</span> 线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。=<span class="string">&quot;&quot;</span> 继承使得子类可以复用父类的成员和方法，实现了代码重用；=<span class="string">&quot;&quot;</span> 编译器处理虚函数的方法是：=<span class="string">&quot;&quot;</span> 而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。=<span class="string">&quot;&quot;</span> 虚函数：在基类的函数前加上<span class="keyword">virtual</span>关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.=<span class="string">&quot;&quot;</span> 详见：[c++虚函数表剖析](https:=<span class="string">&quot;&quot;</span> 详见：[虚函数的作用及其底层实现机制](https:=<span class="string">&quot;&quot;</span> 详见：https:=<span class="string">&quot;&quot;</span> 输出=<span class="string">&quot;&quot;</span> 迭代器就是在不暴露容器内部结构的情况下对容器的遍历。=<span class="string">&quot;&quot;</span> 重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。=<span class="string">&quot;&quot;</span> 重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。=<span class="string">&quot;&quot;</span> 零拷贝指的是在进行操作时，避免cpu从一处存储拷贝到另一处存储。在linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用<span class="built_in">mmap</span>()来代替read调用。=<span class="string">&quot;&quot;</span> 静态存储区和常量存储区和代码区。=<span class="string">&quot;&quot;</span> 静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部<span class="keyword">static</span>变量，全局<span class="keyword">static</span>变量）、全局变量和常量。=<span class="string">&quot;&quot;</span> 静态成员a不占用类的大小，所以类的大小就是b变量的大小=<span class="string">&quot;&quot;</span> 静态成员存放在静态存储区，不占用类的大小,=<span class="string">&quot;&quot;</span> 静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。=<span class="string">&quot;&quot;</span> 静态绑定和动态绑定的介绍=<span class="string">&quot;&quot;</span> 面向对象的三大特性是：封装，继承和多态。=<span class="string">&quot;&quot;</span> 首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。=<span class="string">&quot;&quot;</span> （<span class="number">15</span>）=<span class="string">&quot;&quot;</span> （<span class="number">16</span>）=<span class="string">&quot;&quot;</span> （<span class="number">17</span>）解决哈希冲突的方式？=<span class="string">&quot;&quot;</span> （<span class="number">18</span>）=<span class="string">&quot;&quot;</span> （<span class="number">19</span>）=<span class="string">&quot;&quot;</span> （<span class="number">20</span>）=<span class="string">&quot;&quot;</span> （<span class="number">21</span>）c++中vector和list的区别=<span class="string">&quot;&quot;</span> （<span class="number">22</span>）=<span class="string">&quot;&quot;</span> （<span class="number">23</span>）=<span class="string">&quot;&quot;</span> （<span class="number">24</span>）=<span class="string">&quot;&quot;</span> （<span class="number">25</span>）=<span class="string">&quot;&quot;</span> （<span class="number">26</span>）=<span class="string">&quot;&quot;</span> （<span class="number">27</span>）=<span class="string">&quot;&quot;</span> （<span class="number">28</span>）=<span class="string">&quot;&quot;</span> （<span class="number">29</span>）=<span class="string">&quot;&quot;</span> （<span class="number">30</span>）=<span class="string">&quot;&quot;</span> （<span class="number">31</span>）=<span class="string">&quot;&quot;</span> （<span class="number">32</span>）=<span class="string">&quot;&quot;</span> （<span class="number">33</span>）=<span class="string">&quot;&quot;</span> （<span class="number">34</span>）=<span class="string">&quot;&quot;</span>&gt;用程序调用<span class="built_in">mmap</span>()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用<span class="built_in">write</span>(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</span><br><span class="line"></span><br><span class="line">#### （<span class="number">35</span>） 介绍C++所有的构造函数</span><br><span class="line">C\+\+中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数</span><br><span class="line">* 默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</span><br><span class="line">* 重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</span><br><span class="line">* 拷贝构造函数是在发生对象复制的时候调用的。 </span><br><span class="line">#### （<span class="number">36</span>） 什么情况下会调用拷贝构造函数（三种情况）</span><br><span class="line">* 对象以值传递的方式传入函数参数 </span><br><span class="line"></span><br><span class="line">  &gt;如 ` <span class="keyword">void</span> <span class="built_in">func</span>(Dog dog)&#123;&#125;;`</span><br><span class="line">* 对象以值传递的方式从函数返回</span><br><span class="line"></span><br><span class="line">  &gt;如 ` Dog <span class="built_in">func</span>()&#123; Dog d; <span class="keyword">return</span> d;&#125;`</span><br><span class="line">* 对象需要通过另外一个对象进行初始化</span><br><span class="line"></span><br><span class="line">详见：[C++拷贝构造函数详解](https:<span class="comment">//blog.csdn.net/lwbeyond/article/details/6202256)</span></span><br><span class="line">#### （<span class="number">37</span>） 结构体内存对齐方式和为什么要进行内存对齐？</span><br><span class="line">因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</span><br><span class="line"></span><br><span class="line">对齐规则：</span><br><span class="line">* 第一个成员在与结构体变量偏移量为<span class="number">0</span>的地址</span><br><span class="line">* 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</span><br><span class="line">* 对齐数=编译器默认的一个对齐数 与 该成员大小的较小值。</span><br><span class="line">* linux 中默认为<span class="number">4</span></span><br><span class="line">* vs 中的默认值为<span class="number">8</span></span><br><span class="line">结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）</span><br><span class="line"></span><br><span class="line">#### （<span class="number">38</span>） 内存泄露的定义，如何检测与避免？</span><br><span class="line">动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</span><br><span class="line"></span><br><span class="line">造成内存泄漏的几种原因：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）类的构造函数和析构函数中<span class="keyword">new</span>和<span class="keyword">delete</span>没有配套</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）在释放对象数组时没有使用<span class="keyword">delete</span>\[\]，使用了<span class="keyword">delete</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是<span class="keyword">virtual</span>，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）没有正确的清楚嵌套的对象指针</span><br><span class="line"></span><br><span class="line">避免方法：</span><br><span class="line"><span class="number">1.</span> malloc/free要配套</span><br><span class="line"><span class="number">2.</span> 使用智能指针；</span><br><span class="line"><span class="number">3.</span> 将基类的析构函数设为虚函数；</span><br><span class="line">#### （<span class="number">39</span>） C++的智能指针有哪些</span><br><span class="line">C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。</span><br><span class="line">* auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。</span><br><span class="line">* unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针。</span><br><span class="line">* shared_ptr可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</span><br><span class="line">* weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。</span><br><span class="line">#### （<span class="number">40</span>） 调试程序的方法</span><br><span class="line">* 通过设置断点进行调试</span><br><span class="line">* 打印log进行调试</span><br><span class="line">* 打印中间结果进行调试</span><br><span class="line">#### （<span class="number">41</span>） 遇到coredump要怎么调试</span><br><span class="line">coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</span><br><span class="line"></span><br><span class="line">* 使用gdb命令对core文件进行调试</span><br><span class="line"></span><br><span class="line">以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</span><br></pre></td></tr></table></figure> mkdir coredumpTest vim coredumpTest.cpp <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在编辑器内键入</span><br></pre></td></tr></table></figure> #include&lt;stdio.h&gt; int main(){ int i; scanf("%d",i);//正确的应该是&amp;i,这里使用i会导致segment fault printf("%d",i); return 0; } <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译</span><br></pre></td></tr></table></figure> g++ coredumpTest.cpp -g -o coredumpTest <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行</span><br></pre></td></tr></table></figure> ./coredumpTest <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用gdb调试coredump</span><br></pre></td></tr></table></figure> gdb [可执行文件名] [core文件名] <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### （42） inline关键字说一下 和宏定义有什么区别</span><br><span class="line">inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</span><br><span class="line"></span><br><span class="line">1、内联函数在编译时展开，而宏在预编译时展开</span><br><span class="line"></span><br><span class="line">2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</span><br><span class="line"></span><br><span class="line">3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</span><br><span class="line"></span><br><span class="line">4、宏不是函数，而inline是函数</span><br><span class="line"></span><br><span class="line">5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</span><br><span class="line"></span><br><span class="line">6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</span><br><span class="line"></span><br><span class="line">7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</span><br><span class="line">#### （43） 模板的用法与适用场景 实现原理</span><br><span class="line">用template \&lt;typename t\=&quot;&quot;&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了</span><br><span class="line"></span><br><span class="line">编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。</span><br><span class="line">#### （44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</span><br><span class="line">成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：</span><br></pre></td></tr></table></figure> class A{ int id; string name; FaceImage face; A(int&amp; inputID,string&amp; inputName,FaceImage&amp; inputFace):id(inputID),name(inputName),face(inputFace){} // 成员初始化列表 }; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。  </span><br><span class="line"></span><br><span class="line">另外，有三种情况是必须使用成员初始化列表进行初始化的：</span><br><span class="line">* 常量成员的初始化，因为常量成员只能初始化不能赋值</span><br><span class="line">* 引用类型</span><br><span class="line">* 没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化</span><br><span class="line"></span><br><span class="line">详见[C++ 初始化列表](https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html)</span><br><span class="line">#### （45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</span><br><span class="line">* 自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</span><br><span class="line">* nullptr</span><br><span class="line">：nullptr是为了解决原来C\+\+中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的</span><br><span class="line"></span><br><span class="line">* lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：</span><br><span class="line">`[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125;`</span><br><span class="line">* thread类和mutex类</span><br><span class="line">* 新的智能指针 unique_ptr和shared_ptr</span><br><span class="line"></span><br><span class="line">* 更多详见：https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</span><br><span class="line">#### （46） C++的调用惯例（简单一点C++函数调用的压栈过程）</span><br><span class="line">函数的调用过程：</span><br><span class="line"></span><br><span class="line">1）从栈空间分配存储空间</span><br><span class="line"></span><br><span class="line">2）从实参的存储空间复制值到形参栈空间</span><br><span class="line"></span><br><span class="line">3）进行运算</span><br><span class="line"></span><br><span class="line">形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</span><br><span class="line"></span><br><span class="line">数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</span><br><span class="line"></span><br><span class="line">当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。</span><br><span class="line">#### （47） C++的四种强制转换</span><br><span class="line">四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</span><br><span class="line"></span><br><span class="line">* 1）static_cast ：</span><br><span class="line">  用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。</span><br><span class="line">  &gt;特性与要点：</span><br><span class="line">    1. 它没有运行时类型检查，所以是有安全隐患的。</span><br><span class="line">    2. 在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</span><br><span class="line">    3. static_cast不能转换const，volatile等属性</span><br><span class="line">* 2）dynamic_cast：</span><br><span class="line">用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。</span><br><span class="line">dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。</span><br><span class="line">dynamic_cast如果不能转换返回NULL。</span><br><span class="line">* 3）const_cast：</span><br><span class="line">用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</span><br><span class="line">* 4）reinterpret_cast</span><br><span class="line">几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。</span><br><span class="line">#### （48）string的底层实现</span><br><span class="line">string继承自basic_string,其实是对char\*进行了封装，封装的string包含了char\*数组，容量，长度等等属性。</span><br><span class="line"></span><br><span class="line">string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</span><br><span class="line">#### （49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</span><br><span class="line">预处理，编译，汇编，链接</span><br><span class="line"></span><br><span class="line">* 预处理： 对预处理命令进行替换等预处理操作</span><br><span class="line">* 编译：代码优化和生成汇编代码</span><br><span class="line">* 汇编：将汇编代码转化为机器语言</span><br><span class="line">* 链接：将目标文件彼此链接起来</span><br><span class="line">#### （50）set，map和vector的插入复杂度</span><br><span class="line">set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。</span><br><span class="line"></span><br><span class="line">unordered_set,unordered_map的插入复杂度是常数，最坏是O(N).</span><br><span class="line"></span><br><span class="line">vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</span><br><span class="line">#### （51）定义和声明的区别</span><br><span class="line">* 声明是告诉编译器变量的类型和名字，不会为变量分配空间</span><br><span class="line"></span><br><span class="line">* 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次</span><br><span class="line">#### （52）typdef和define区别</span><br><span class="line"></span><br><span class="line">#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</span><br><span class="line"></span><br><span class="line">typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</span><br><span class="line"></span><br><span class="line">#### （53）被free回收的内存是立即返还给操作系统吗？为什么</span><br><span class="line">https://blog.csdn.net/YMY_mine/article/details/81180168</span><br><span class="line"></span><br><span class="line">不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</span><br><span class="line"></span><br><span class="line">#### （54）引用作为函数参数以及返回值的好处</span><br><span class="line"></span><br><span class="line">对比值传递，引用传参的好处：</span><br><span class="line"></span><br><span class="line">1）在函数内部可以对此参数进行修改</span><br><span class="line"></span><br><span class="line">2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</span><br><span class="line"></span><br><span class="line">如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</span><br><span class="line"></span><br><span class="line">用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</span><br><span class="line"></span><br><span class="line">但是有以下的限制：</span><br><span class="line"></span><br><span class="line">1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</span><br><span class="line"></span><br><span class="line">2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</span><br><span class="line"></span><br><span class="line">3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 </span><br><span class="line">#### （55）友元函数和友元类</span><br><span class="line">https://www.cnblogs.com/zhuguanhao/p/6286145.html</span><br><span class="line"></span><br><span class="line">友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</span><br><span class="line"></span><br><span class="line">1）友元函数</span><br><span class="line"></span><br><span class="line">有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure> #include <iostream></p><p>using namespace std;</p><p>class A { public: friend void set_show(int x, A &amp;a); //该函数是友元函数的声明 private: int data; };</p><p>void set_show(int x, A &amp;a) //友元函数定义，为了访问类A中的成员 { a.data = x; cout &lt;&lt; a.data &lt;&lt; endl; } int main(void) { class A a;</p><pre><code>set_show(1, a);return 0;</code></pre><p>} <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</span><br><span class="line"></span><br><span class="line">2）友元类</span><br><span class="line"></span><br><span class="line">友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。        </span><br><span class="line">但是另一个类里面也要相应的进行声明</span><br><span class="line"></span><br></pre></td></tr></table></figure> #include <iostream></p><p>using namespace std;</p><p>class A { public: friend class C; //这是友元类的声明 private: int data; };</p><p>class C //友元类定义，为了访问类A中的成员 { public: void set_show(int x, A &amp;a) { a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;} <img src="https:=%22%22%20socket()=%22%22%20stl中的sort()算法是用什么实现的，stable_sort()呢=%22%22%20stl中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。=%22%22%20tcp和udp的区别=%22%22%20tcp和udp相关的协议与端口号=%22%22%20tcp对系统资源的要求高于udp，所以速度也比udp慢。=%22%22%20tcp怎么保证可靠性？=%22%22%20tcp拥塞控制，算法名字？（极其重要）=%22%22%20tcp提供流量控制和拥塞控制，而udp没有。=%22%22%20tcp握手以及每一次握手客户端和服务器端处于哪个状态=%22%22%20tcp数据包是没有边界的，会出现粘包的问题，udp包是独立的，不会出现粘包问题。=%22%22%20tcp断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动=%22%22%20tcp族的协议有http，https，smtp，telnet，ftp等，udp族的协议有dns，dhcp等等。=%22%22%20tcp是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ack对收发的数据进行正确性检验。而udp是无连接的协议，不管对方有没有收到或者收到的数据是否正确。=%22%22%20tcp滑动窗口协议=%22%22%20tcp的三次握手与四次挥手的详细介绍（tcp连接建立与断开是热门问题）=%22%22%20tcp的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等=%22%22%20tcp的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。=%22%22%20tcp给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。=%22%22%20tcp连接与断开详解：=%22%22%20tcp连接的每一方都有固定大小的缓冲空间，tcp的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。tcp使用的流量控制协议是可变大小的滑动窗口协议。=%22%22%20tcp（udp，ip）等首部的认识（http请求报文构成）=%22%22%20time_wait是指四次挥手中客户端接收了服务端的fin报文并发送ack报文给服务器后，仍然需要等待2msl时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入close状态了，但是我们必须假象网络是不可靠的，有可以最后一个ack丢失。如果客户端发送的ack发生丢失，服务器会再次发送fin报文给客户端，所以time_wait状态就是用来重发可能丢失的ack报文。=%22%22%20time_wait的意义（为什么要等于2msl）=%22%22%20timer）。只要tcp的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：tcp规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。=%22%22%20udp如何实现可靠传输=%22%22%20udp的头部则包括：源端口，目的端口，长度，校验和。=%22%22%20volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（cpu的优化是让该变量存放到cpu寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。=%22%22%20wdscq1234=%22%22%20window=%22%22%20write(),=%22%22%20www.cnblogs.com=%22%22%20www.zhihu.com=%22%22%20zhangliangzi=%22%22%20zhuanlan.zhihu.com=%22%22%20%7B=%22%22%20%7D=%22%22%20%7D;=%22%22%20三次握手=%22%22%20三次握手.png" alt="fig=&quot;&quot; 三次握手.png和tcp滑动窗口=&quot;&quot; 81105051=&quot;&quot; 81429627)=&quot;&quot; 8359066.html=&quot;&quot; tcp-ip详解：滑动窗口slidingwindow;=&quot;&quot; a;=&quot;&quot; accept()=&quot;&quot; ack机制，重传机制和窗口确认机制。=&quot;&quot; alifpga=&quot;&quot; answer=&quot;&quot; article=&quot;&quot; bind()=&quot;&quot; blog.csdn.net=&quot;&quot; c=&quot;&quot; c.set_show(1,=&quot;&quot; c;=&quot;&quot; class=&quot;&quot; close(),=&quot;&quot; congestion=&quot;&quot; connect()=&quot;&quot; cwnd=&quot;&quot; details=&quot;&quot; felixzh=&quot;&quot; gettogetto=&quot;&quot; https:=&quot;&quot; information=&quot;&quot; int=&quot;&quot; ip分片和完整ip报文差不多拥有相同的ip头，16位id域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个ip报文的分片。在ip头里面，16位识别号唯一记录了一个ip包的id，具有同一个id的ip分片将会重新组装；而13位片偏移则记录了某ip片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了ip分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对ip数据进行重新组织。=&quot;&quot; ip数据包的头部包括：源ip地址，目的ip地址，协议，校验和，总长度等等=&quot;&quot; junjun150013652=&quot;&quot; listen()=&quot;&quot; main(void)=&quot;&quot; ospf：详见：https:=&quot;&quot; p=&quot;&quot; protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。rip是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。=&quot;&quot; qingjiaowoxiaoxioashou=&quot;&quot; qq_22080999=&quot;&quot; qq_37964547=&quot;&quot; question=&quot;&quot; read(),=&quot;&quot; recv(),=&quot;&quot; recvfrom()=&quot;&quot; return=&quot;&quot; rip“路由信息协议(route=&quot;&quot; send(),=&quot;&quot; sendto()=&quot;&quot; shutdown()=&quot;&quot; shutdown详解" />="" 不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。="" 为什么使用三次握手，两次握手可不可以？="" 举两个例子，第一种是黑客会伪造大量syn请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫syn洪泛攻击。第二种是服务器返回给客户端的ack数据包可能会在传输的过程中丢失，而客户端没有收到该ack数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。="" 会="" 作者：姚冬="" 使用close()时，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接="" 使用友元类时注意：="" 关闭套接字="" 创建套接字="" 友元关系不具有传递性。若类b是类a的友元，类c是b的友元，类c不一定是类a的友元，同样要看类中是否有相应的申明="" 友元关系不能被继承。="" 友元关系是单向的，不具有交换性。若类b是类a的友元，类a不一定是类b的友元，要看在类中是否有相应的声明。="" 发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小="" 发送方维持一个拥塞窗口="" 发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，tcp将丢弃这个报文段和不确认收到此报文段。="" 四次挥手.png)="" 四次挥手.png](fig="" 四次挥手断开连接：="" 因为udp是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq="" 因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（mtu）就是1500字节。如果ip数据包加上头部后大小超过1500字节，就需要分片。="" 在浏览器中输入url后执行的全部过程（如www.baidu.com）="" 垃圾回收会使得c++不适合进行很多底层的操作。="" 如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。="" 客户端接收到http响应，将结果渲染展示给用户。="" 对路由协议的了解与介绍。内部网关协议igp包括rip，ospf，和外部网关协议egp和bgp.="" 就要接收方收到udp之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。="" 建立tcp服务器的各个系统调用="" 建立tcp服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。="" 建立连接="" 当tcp发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。="" 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。="" 当vector在插入的时候，end迭代器肯定会失效="" 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效="" 当网络拥塞时，减少数据的发送。="" 慢启动、拥塞避免、快速重传、快速恢复="" 所以在应用方面，如果强调数据的完整性和正确性用tcp，当要求性能和速度的时候，使用udp更加合适。="" 所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用tcp报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。="" 拥塞控制="" 拥塞控制.png)="" 拥塞控制和流量控制的区别="" 拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。="" 接受连接="" 接收方会在每个ack数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。="" 接收方有即时窗口（滑动窗口），随ack报文发送="" 接着是http连接，客户端向服务器发送http连接请求；="" 数据发送="" 数据接收="" 服务器对客户端发来的http请求进行处理，并返回响应；="" 服务器的系统调用](https:="" 来源：知乎="" 校验和="" 注：单凭tcp是不能保证完整性的，要是有黑客伪造tcp包，是无法识别的。="" 流量控制="" 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？="" 然后建立tcp连接，客户端与服务器通过三次握手建立tcp连接；="" 然后是css解析，将css文件解析为样式表对象来渲染dom树。="" 然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。="" 监听端口="" 确认应答+序列号="" 第一次挥手：当client没有数据要发送给server了，他会给server发送一个fin报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入fin_wait_1的第一阶段="" 第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了syn="1，client_seq=任意值i，发送之后处于SYN-SENT状态，这是第一次握手" 第三次挥手：当server发完所有数据时，他会给client发送一个fin报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成last_ack状态，等着client最后的ack信息，这是第三次挥手="" 第三次握手：client收到server发来的ack信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ack报文，报文中同样包含了ack="1这样的消息，同时呢，还包括了client_ack=k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态" 第二次挥手：当server收到client发来的fin报文后，告诉client：“我收到你的fin消息了，但是你等我发完的”此时给client返回一个ack信息，并且呢ack="seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段" 第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ack报文，这个报文中呢包含了这些字段，标志位syn和ack都为1，而小ack为i+1，此时位于syn-rcvd状态，这是第二次握手="" 第四次挥手：当client收到这个fin报文时，他会对这个消息进行确认，即给server发ack信息，但是它不相信网络，怕server收不到信息，它会进入time_wait状态，万一server没收到ack消息它可以可以重传，而当server收到这个ack信息后，就正式关闭了tcp连接，处于closed状态，而client等待了2msl这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了="" 绑定本机端口="" 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？="" 网络层分片的原因与具体实现="" 网页解析的过程与实现方法="" 考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。="" 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。="" 见上="" 解决这个问题，tcp为每一个连接设置一个持续计时器（persistence="" 计网相关="" 详见="" 详见：[建立tcp="" 详见：[网络编程socket之tcp之close="" 详见：https:="" 说一下volatile关键字的作用="" 超时重传="" 超时重传机制（不太高频）="" 这里仅展示浏览器解析服务器响应的过程，url解析和交互的完整过程在(9)="" 链接：https:="" 防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong>="" 首先是html文档解析，浏览器会将html文档生成解析树，也就是dom树，它由dom元素以及属性节点组成。="" 首先是域名解析，客户端使用dns协议将url解析为对应的ip地址；="" 首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。="" （10）="" （11）="" （12）="" （13）="" （14）="" （15）="" （16）="" （17）="" （18）="" （19）="" （1）="" （1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16="" （20）="" （2）="" （3）="" （4）="" （56）="" （57）="" （58）vector会迭代器失效吗？什么情况下会迭代器失效？="" （58）为什么c++没有实现垃圾回收？="" （5）="" （6）="" （7）="" （8）="" （9）="" （http连接无需额外连接，直接通过已经建立的tcp连接发送）="" （tcp三次握手在调用这个函数时进行）=""&gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p><p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p><p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p><p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd=1，进入慢启动阶段</p><h4 id="http协议与tcp的区别与联系">（21） http协议与TCP的区别与联系</h4><p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p><p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。 建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。 #### （22） http/1.0和http/1.1的区别 HTTP 协议老的标准是 HTTP/1.0 ，目前最通用的标准是 HTTP/1.1 。 HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http/1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p><h4 id="http的请求方法有哪些get和post的区别">（23） http的请求方法有哪些？get和post的区别。</h4><p>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</p><p>get和post的区别： 1. get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源 2. get可以保存为书签，可以用缓存来优化，而post不可以 3. get把请求附在url上，而post把参数附在http包的包体中 4. 浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等 5. post可以传输二进制编码的信息，get的参数一般只支持ASCII #### （24） http的状态码 403 201等等是什么意思 详见 <a href="https://blog.csdn.net/u011630575/article/details/46636535">HTTP状态码的含义</a></p><p>常见的状态码有： &gt;* 200 - 请求成功 &gt;* 301 - 资源（网页等）被永久转移到其它URL &gt;* 404 - 请求的资源（网页等）不存在 &gt;* 500 - 内部服务器错误 &gt;* 400 - 请求无效 &gt;* 403 - 禁止访问 #### （25） http和https的区别，由http升级为https需要做哪些操作 http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443 http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。 https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用 https://www.cnblogs.com/wqhwe/p/5407468.html</p><h4 id="https的具体实现怎么确保安全性">（26） https的具体实现，怎么确保安全性</h4><p><strong>SSL是传输层的协议</strong></p><p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p><ol type="1"><li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li><li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。</li><li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li><li>Web服务器利用自己的私钥解密出会话密钥。</li><li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li></ol><p>服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书</p><p>客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数） #### （27） TCP三次握手时的第一次的seq序号是怎样产生的 第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p><p>seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。 #### （28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？ 65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p><p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。 #### （29） 对称密码和非对称密码体系 https://blog.csdn.net/qq_29689487/article/details/81634057</p><ul><li>对称加密：加密和解密使用的密钥是同一个<ul><li>优点：计算量小，算法速度快，加密效率高 缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li><li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li></ul></li><li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密<ul><li>优点：安全，不怕泄漏 缺点：速度慢</li><li>常用算法：RSA，ECC，DSA #### （30） 数字证书的了解（高频） <img src="fig/数字证书.jpg" alt="fig/数字证书.jpg" /></li></ul></li></ul><p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p><p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。 #### （31） 服务器出现大量close_wait的连接的原因以及解决方法 close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种： * 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法 * 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</p><p>处理方法： * 停止应用程序 * 修改程序里的bug #### （32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面） * 消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p><ul><li>MD5算法介绍： MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</li></ul><ol type="1"><li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li><li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li><li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li><li>遍历所有分组后得到的四个变量即为结果。</li></ol><p>详见：https://blog.csdn.net/weixin_39640298/article/details/84555814</p><ul><li><p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p></li><li><p>加强安全性：加盐（加随机数） #### （33） 单条记录高并发访问的优化 服务器端：</p></li><li><p>使用缓存，如redis等</p></li><li><p>使用分布式架构进行处理</p></li><li><p>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</p></li><li><p>将静态资源尽可能在客户端进行缓存</p></li><li><p>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 = Engine X）</p></li></ul><p>数据库端： * 数据库采用主从赋值，读写分离措施 * 建立适当的索引 * 分库分表 #### （34） 介绍一下ping的过程，分别用到了哪些协议 详见：<a href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html">Ping原理与ICMP协议</a></p><p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p><ul><li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li><li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li><li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li></ul><p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。 #### （35） TCP/IP的粘包与避免介绍一下 因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p><p>导致TCP粘包的原因有三方面： * 发送端等待缓冲区满才进行发送，造成粘包 * 接收方来不及接收缓冲区内的数据，造成粘包 * 由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</p><p>避免粘包的措施： * 通过编程，强制使TCP发生数据传送，不必等到缓冲区满 * 优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等 * 设置固定长度的报文或者设置报文头部指示报文的长度。</p><h4 id="说一下tcp的封包和拆包">（36） 说一下TCP的封包和拆包</h4><p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。 * 封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。 * 拆包：接收方在接收到报文后提取包头中的长度信息进行截取。 #### （37） 一个ip配置多个域名，靠什么识别？ * 靠host主机名区分 * 靠端口号区分 #### （38） 服务器攻击（DDos攻击） #### （39）DNS的工作过程和原理 <img src="fig/DNS查询图解.png" /> DNS解析有两种方式：递归查询和迭代查询 * 递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。 * 迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果 #### （41）OSA七层协议和五层协议，分别有哪些 OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p><p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p><figure><img src="fig/网络协议层.png" alt="" /><figcaption>(fig/网络协议层.png</figcaption></figure><h4 id="ip寻址和mac寻址有什么不同怎么实现的">（42）IP寻址和MAC寻址有什么不同，怎么实现的</h4><p>通过MAC地址寻找主机是MAC地址寻址，通过IP地址寻找主机叫IP地址寻址。它们适用于不同的协议层，IP寻址是网络层，Mac寻址是数据链路层。</p><p>http://c.biancheng.net/view/6388.html</p><p>https://blog.csdn.net/wxy_nick/article/details/9190693</p><p>IP寻址的过程（ARP协议）：主机A想通过IP地址寻找到目标主机，首先分析IP地址确定目标主机与自己是否为同一网段。如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包</p><h1 id="数据库">3. 数据库</h1><h4 id="关系型和非关系型数据库的区别低频">（1） 关系型和非关系型数据库的区别（低频）</h4><ul><li>关系型数据库的优点<ol type="1"><li>容易理解。因为它采用了关系模型来组织数据。</li><li>可以保持数据的一致性。</li><li>数据更新的开销比较小。</li><li>支持复杂查询（带where子句的查询）</li></ol></li><li>非关系型数据库的优点<ol type="1"><li>不需要经过sql层的解析，读写效率高。</li><li>基于键值对，数据的扩展性很好。</li><li>可以支持多种类型数据的存储，如图片，文档等等。 #### （2） 什么是非关系型数据库（低频） 非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</li></ol></li></ul><p>适合使用非关系型数据库的场景： * 日志系统 * 地理位置存储 * 数据量巨大 * 高可用 #### （3） 说一下 MySQL 执行一条查询语句的内部执行过程？ * 连接器：客户端先通过连接器连接到 MySQL 服务器。 * 缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。 * 分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。 * 优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。 * 执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。 #### （4） 数据库的索引类型 数据库的索引类型分为逻辑分类和物理分类</p><p>逻辑分类： * 主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。 * 唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。 * 普通索引 一张表可以有多个普通索引，可以重复可以为空值 * 全文索引 可以加快模糊查询，不常用</p><p>物理分类： * 聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。 * 非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。 #### （5） 说一下事务是怎么实现的 https://blog.csdn.net/u013256816/article/details/103966510</p><p>https://www.cnblogs.com/takumicx/p/9998844.html</p><p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p><ul><li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li><li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li></ul><h4 id="mysql怎么建立索引怎么建立主键索引怎么删除索引">（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h4><p>MySQL建立索引有两种方式：用alter table或者create index。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary key(column_list) #添加一个主键索引</span><br><span class="line">alter table table_name add index (column_list)      #添加一个普通索引</span><br><span class="line">alter table table_name add unique (column_list)     #添加一个唯一索引</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name (column_list)   #创建一个普通索引</span><br><span class="line">create unique index_name on table_name (column_list)  #创建一个唯一索引</span><br></pre></td></tr></table></figure></p><p>Mysql删除索引同样也有两种方式：alter table 和 drop index <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name drop index index_name    #删除一个普通索引</span><br><span class="line">alter table table_name drop primary key         #删除一个主键索引</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on table table_name</span><br></pre></td></tr></table></figure> #### （7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点） https://www.cnblogs.com/wezheng/p/8399305.html * 经常搜索的列上建索引 * 作为主键的列上要建索引 * 经常需要连接（where子句）的列上 * 经常需要排序的列 * 经常需要范围查找的列</p><p>哪些列不适合建索引？ * 很少查询的列 * 更新很频繁的列 * 数据值的取值比较少的列（比如性别） #### （8） 索引的底层实现（重点） 数据库的索引是使用B+树来实现的。</p><p>（为什么要用B+树，为什么不用红黑树和B树）</p><p>B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p><p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p><h4 id="b树和b树的区别重点">（9） B树和B+树的区别（重点）</h4><figure><img src="./fig/Bptree.png" alt="" /><figcaption>./fig/Bptree.png</figcaption></figure><p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。 1. 关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。 2. 存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。 3. 分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。 4. 查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</p><p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。 #### （10） 索引最左前缀/最左匹配 假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。 #### （11） Mysql的优化（高频，索引优化，性能优化） 高频访问： * 分表分库：将数据库表进行水平拆分，减少表的长度 * 增加缓存： 在web和DB之间加上一层缓存层 * 增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</p><p>并发优化： * 主从读写分离：只在主服务器上写，从服务器上读 * 负载均衡集群：通过集群或者分布式的方式解决并发压力 #### （12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别 * InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表 行级锁 * MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用 表级锁 * MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景 * CSV * blackhole #### （13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题） 数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</p><p><strong>A: atom 原子性</strong></p><p>数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p><p><strong>C: consistency 一致性</strong></p><p>数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。 比如在银行转账操作后两个账户的总额应当不变。</p><p><strong>I: isolation 隔离性</strong></p><p>数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p><p><strong>D：durability 持久性</strong></p><p>数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。 如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。 #### （14）什么是脏读，不可重复读和幻读？ 详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a> * 脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。</p><blockquote><p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读 * 不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。 比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。 不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。 * 幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。 比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。 不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p></blockquote><p>避免不可重复读需要锁行，避免幻读则需要锁表。</p><p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。 详见<a href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html">脏读、不可重复读和幻读的区别</a></p><h4 id="数据库的隔离级别mysql和oracle的隔离级别分别是什么重点">（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h4><p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a>和<a href="https://blog.csdn.net/fg2006/article/details/6937413">数据库隔离级别</a></p><p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别： * 读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题 * 读已提交 Read committed: 可以避免脏读的发生 * 可重复读 Reapeatable read: 确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现 * 串行化 Serializaion 最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</p><p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p><p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别 #### （16） 数据库连接池的作用 #### （17） Mysql的表空间方式，各自特点 * 共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 * 独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题 #### （18） 分布式事务 #### （19） 数据库的范式 https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</p><ul><li><strong>第一范式(确保每列保持原子性)</strong></li></ul><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p><blockquote><p>比如 学生 选课（包括很多课程） 就不符合第一范式 * <strong>第二范式(确保表中的每列都和主键相关)</strong></p></blockquote><p>在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。</p><blockquote><p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系 * <strong>第三范式(确保非主键的列没有传递依赖)</strong></p></blockquote><p>在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</p><blockquote><p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级 * <strong>BCNF范式（确保主键之间没有传递依赖）</strong></p></blockquote><p>主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。 #### （20） 数据的锁的种类，加锁的方式 以MYSQL为例， * 按照类型来分有乐观锁和悲观锁 * 根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁） * 根据作用来分有共享锁（读锁）和排他锁（写锁）。 #### （21） 什么是共享锁和排他锁 * 共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。 * 排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</p><p>https://blog.csdn.net/qq_42743933/article/details/81236658 #### （22） 分库分表的理解和简介 #### （23） #### （24）数据库高并发的解决方案 1. 在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。 2. 增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢） 3. 主从读写分离，让主服务器负责写，从服务器负责读。 4. 将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。 5. 使用分布式架构，分散计算压力。 #### （25）乐观锁与悲观锁解释一下 一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</p><p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。 #### （26）乐观锁与悲观锁是怎么实现的 悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p><p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p><p>乐观锁有三种常用的实现形式： * 一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。 * 一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。 * 最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</p><h4 id="对数据库目前最新技术有什么了解吗">（27）对数据库目前最新技术有什么了解吗</h4><h1 id="linux">4. Linux</h1><h4 id="linux的io模型介绍以及同步异步阻塞非阻塞的区别超级重要">（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h4><p>https://blog.csdn.net/sqsltr/article/details/92762279</p><p>https://www.cnblogs.com/euphie/p/6376508.html</p><p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p><ul><li><p>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</p></li><li><p>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</p></li><li><p>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</p></li><li><p>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</p></li><li><p>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。 #### （2） 文件系统的理解（EXT4，XFS，BTRFS） #### （3） EPOLL的介绍和了解 https://zhuanlan.zhihu.com/p/56486633</p></li></ul><p>https://www.jianshu.com/p/397449cadc9a</p><p>https://blog.csdn.net/davidsguo008/article/details/73556811</p><p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p><p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p><p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p><ul><li><p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p></li><li><p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p></li><li><p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。 #### （4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？ （1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024. <img src="fig/select.png" alt="select" /> （2）poll使用链表保存文件描述符，其他的跟select没有什么不同。</p></li></ul><p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。 <img src="fig/epoll.png" alt="epoll" /> 详见 https://www.cnblogs.com/Anker/p/3265058.html</p><h4 id="epoll的et模式和lt模式et的非阻塞">（5） Epoll的ET模式和LT模式（ET的非阻塞）</h4><ul><li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li><li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。 #### （6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义） 详见：https://blog.csdn.net/qq_36357820/article/details/76606113</li></ul><ol type="1"><li>top命令查看linux负载：</li><li>uptime查看linux负载</li><li>w查看linux负载：</li><li>vmstat查看linux负载 #### （7） linux的其他常见命令（kill，find，cp等等） #### （8） shell脚本用法 #### （9） 硬连接和软连接的区别 #### （10） 文件权限怎么看（rwx） #### （11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变 #### （12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令 #### （13）Linux中线程的同步方式有哪些？ #### （14）怎么修改一个文件的权限 chmod 777 (177 277 477 等，权限组合是 1 2 4，分别代表r x w ) #### （15）查看文件内容常用命令 详见： http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</li><li>cat 与 tac <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容</span><br><span class="line"></span><br><span class="line">cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）</span><br><span class="line"></span><br><span class="line">tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令不常用。</span><br><span class="line"></span><br><span class="line">tac语法：tac 文件名。</span><br></pre></td></tr></table></figure></li><li>more和less（常用） <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more</span><br><span class="line"></span><br><span class="line">more的语法：more 文件名</span><br><span class="line"></span><br><span class="line">Enter 向下n行，需要定义，默认为1行； </span><br><span class="line"></span><br><span class="line">Ctrl f 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">空格键 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">Ctrl b 返回上一屏； </span><br><span class="line"></span><br><span class="line">= 输出当前行的行号； </span><br><span class="line"></span><br><span class="line">:f 输出文件名和当前行的行号； </span><br><span class="line"></span><br><span class="line">v 调用vi编辑器； </span><br><span class="line"></span><br><span class="line">! 命令 调用Shell，并执行命令； </span><br><span class="line"></span><br><span class="line">q 退出more</span><br><span class="line"></span><br><span class="line">less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</span><br><span class="line"></span><br><span class="line">less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</span><br><span class="line"></span><br><span class="line">less的语法：less 文件名</span><br></pre></td></tr></table></figure></li><li>head和tail <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容</span><br><span class="line"></span><br><span class="line">head的语法：head [n number] 文件名 (number 显示行数)</span><br><span class="line"></span><br><span class="line">tail的功能恰好和head相反，只显示最后几行内容</span><br><span class="line"></span><br><span class="line">tail的语法:tail [-n number] 文件名</span><br></pre></td></tr></table></figure></li><li>nl <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来</span><br><span class="line"></span><br><span class="line">nl的语法：nl 文件名</span><br></pre></td></tr></table></figure></li><li>vim</li></ol><p>这个用的太普遍了，主要是用于编辑。</p><h4 id="怎么找出含有关键字的前后4行">（16）怎么找出含有关键字的前后4行</h4><h4 id="linux的gdb调试">（17）Linux的GDB调试</h4><h4 id="coredump是什么-怎么才能coredump">（18）coredump是什么 怎么才能coredump</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p><p>coredump产生的条件 1. shell资源控制限制，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。 2. 读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界 3. 使用了线程不安全的函数，读写未加锁保护 4. 错误使用指针转换 5. 堆栈溢出 #### （19）tcpdump常用命令 用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p><p>实用命令实例</p><p>将某端口收发的数据包保存到文件</p><p><code>sudo tcpdump -i any port 端口 -w 文件名.cap</code></p><p>打印请求到屏幕</p><p><code>sudo tcpdump -i any port 端口 -Xnlps0</code></p><p>默认启动</p><p><code>tcpdump</code> 普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。 监视指定网络接口的数据包</p><p><code>tcpdump -i eth1</code> 如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。　 #### （20） crontab命令 详见：https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</p><p>corntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。</p><ul><li><p>crontab命令用来对crontab文件进行管理 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1．命令格式：</span><br><span class="line">crontab [-u user] file</span><br><span class="line">crontab [-u user] [ -e | -l | -r ]</span><br><span class="line">2．命令功能：</span><br><span class="line">通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</span><br><span class="line">3．命令参数：</span><br><span class="line">-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</span><br><span class="line">file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">-i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure></p></li><li><p>crontab文件内容</p></li></ul><p>crond是Linux下的周期性执行系统任务的守护进程，他会根据/etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。</p><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">minute   hour   day   month   week   command</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">minute： 表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</span><br><span class="line">在以上各个字段中，还可以使用以下特殊字符：</span><br><span class="line">星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class="line">逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</span><br><span class="line">中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</span><br><span class="line">正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</span><br></pre></td></tr></table></figure> #### （21） 查看后台进程 * jobs</p><p>查看当前控制台的后台进程</p><p>想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可</p><ul><li>ps</li></ul><p>查看后台进程</p><ul><li>top</li></ul><p>查看所有进程和资源使用情况，类似Windows中的任务管理器</p><p>停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）</p><p>退出top：输入q即可</p><h1 id="操作系统">5. 操作系统</h1><h4 id="linux理论上最多可以创建多少个进程一个进程可以创建多少线程和什么有关">（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</h4><p>答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。</p><p>至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。 #### （3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面） * 存储器：内存 * 控制器：南桥北桥 * 运算器：CPU * 输入设备：键盘 * 输出设备：显示器、网卡 #### （4） 进程之间的通信方法有哪几种 （重点） 进程之间的通信方式主要有六种，包括<strong>管道，信号量，消息队列，信号，共享内存，套接字</strong>。</p><ul><li><p>管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的</p><p>匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。</p><p>管道的底层实现 https://segmentfault.com/a/1190000009528245</p></li><li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。</p></li><li><p>信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的</p></li><li><p>共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p></li><li><p>消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。 消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。 可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p></li><li><p>套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p></li></ul><h4 id="进程的执行过程是什么样的执行一个进程需要做哪些工作">（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</h4><p>进程的执行需要经过三大步骤：编译，链接和装入。 * 编译：将源代码编译成若干模块 * 链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接） * 装入：将模块装入内存运行</p><p>https://blog.csdn.net/qq_38623623/article/details/78306498</p><p>将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p><p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。 #### （6） 操作系统的内存管理说一下 https://www.cnblogs.com/peterYong/p/6556619.html</p><p>https://zhuanlan.zhihu.com/p/141602175</p><p>操作系统的内存管理包括物理内存管理和虚拟内存管理 * 物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等； * 虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；</p><p>（面试官这样问的时候，其实是希望你能讲讲虚拟内存） #### （7） 实现一个LRU算法 用到两个数据结构：哈希+双向链表 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int,list&lt;pair&lt;int,int&gt; &gt; &gt; cache ;// 存放键，迭代器</span><br><span class="line">list&lt;pair&lt;int,int&gt;&gt; auxlist; // 存放 &lt;键，值&gt;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    int cap;</span><br><span class="line">    list&lt;pair&lt;int,int&gt;&gt; l;// front:new back:old 存放值 新的放前面，因为前面的可以取得有效的迭代器</span><br><span class="line">    map&lt;int,list&lt;pair&lt;int,int&gt; &gt;::iterator &gt; cache;// 存放键，迭代器</span><br><span class="line">public:</span><br><span class="line">    LRUCache(int capacity) &#123;</span><br><span class="line">        cap=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        auto mapitera = cache.find(key);</span><br><span class="line">        if(mapitera==cache.end())&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;// found</span><br><span class="line">            list&lt;pair&lt;int,int&gt;&gt;::iterator listItera = mapitera-&gt;second;</span><br><span class="line">            int value = (*listItera).second;</span><br><span class="line"></span><br><span class="line">            l.erase(listItera);</span><br><span class="line">            l.push_front(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.begin();</span><br><span class="line"></span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        auto itera = cache.find(key);</span><br><span class="line">        if(itera!=cache.end())&#123;// exist</span><br><span class="line">            list&lt;pair&lt;int,int&gt;&gt;::iterator listItera = itera-&gt;second;</span><br><span class="line"></span><br><span class="line">            l.erase(listItera);</span><br><span class="line">            l.push_front(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.begin();</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;// not exist</span><br><span class="line">            if(cache.size()&gt;=cap)&#123;</span><br><span class="line">                pair&lt;int,int&gt; oldpair = l.back();</span><br><span class="line">                l.pop_back();</span><br><span class="line">                cache.erase(oldpair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            l.push_front(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="line"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="line"> * int param_1 = obj-&gt;get(key);</span><br><span class="line"> * obj-&gt;put(key,value);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure> #### （8） 死锁的恢复 1. 重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。 2. 终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。 (1) 一次性全部终止；(2) 逐步终止(优先级，代价函数) 3. 剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。 (1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。 (2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。 4. 进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大： (1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。 (2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的 #### （8）什么是饥饿 饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。 #### （9） 如果要你实现一个mutex互斥锁你要怎么实现？ https://blog.csdn.net/kid551/article/details/84338619</p><p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag=1表明该锁已经锁住，flag=0表明锁没有锁住。 实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0； <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;flag,<span class="number">1</span>)==<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//flag=1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 因为while有可能被重入，所以可以用TestandSet()方法。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr;</span><br><span class="line">    *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### （10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？ 线程之间通信： * 使用全局变量 * 使用信号机制 * 使用事件</p><p>进程之间同步： https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</p><ul><li><p>信号量</p></li><li><p>管程 #### （13） 什么时候用多进程，什么时候用多线程 https://blog.csdn.net/yu876876/article/details/82810178</p></li><li><p>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></p></li><li><p>计算量：需要大量计算的优先使用<strong>多线程</strong> 因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</p></li><li><p>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</p></li><li><p>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</p></li></ul><p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。 #### （14） 文件读写使用的系统调用 #### （15） 孤儿进程和僵尸进程分别是什么，怎么形成的？ https://www.cnblogs.com/Anker/p/3271773.html</p><ul><li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li><li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。 #### （16） 说一下PCB/说一下进程地址空间/ https://blog.csdn.net/qq_38499859/article/details/80057427</li></ul><p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p><p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p><p><img src="https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p><p>进程地址空间内有： * 代码段text：存放程序的二进制代码 * 初始化的数据Data：已经初始化的变量和数据 * 未初始化的数据BSS：还没有初始化的数据 * 栈 * 堆 #### （17） 内核空间和用户空间是怎样区分的 在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</p><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。 #### （18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论） https://blog.csdn.net/s_lisheng/article/details/74278765</p><ul><li>临界区</li><li>信号量</li><li>事件</li><li>互斥量 #### （19） 同一个进程内的线程会共享什么资源？</li><li>该进程的地址空间</li><li>全局变量</li><li>堆空间</li></ul><p>线程的栈空间是自己独有的 #### （20） 异常和中断的区别 #### （21） 一般情况下在Linux/windows平台下栈空间的大小 在Linux下栈空间通常是8M，Windows下是1M #### （22）虚拟内存的了解 https://www.cnblogs.com/Przz/p/6876988.html</p><p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。 当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。 #### （23）服务器高并发的解决方案 1. 应用数据与静态资源分离 将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p><ol start="2" type="1"><li><p>客户端缓存 因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p></li><li><p>集群和分布式 （集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）</p></li></ol><p>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）</p><p>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p><ol start="4" type="1"><li>反向代理 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。 #### （24）协程了解吗（高频） 协程和微线程是一个东西。</li></ol><p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。 这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。 #### （25）那协程的底层是怎么实现的，怎么使用协程？ 协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。 #### （23）进程的状态以及转换图 * 三态模型 三态模型包括三种状态： 1. 执行：进程分到CPU时间片，可以执行 2. 就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行 3. 阻塞：有IO事件或者等待其他资源 <img src="fig/三态模型.png" /> * 五态模型 1. 新建态：进程刚刚创建。 2. 就绪态： 3. 运行态： 4. 等待态：出现等待事件 5. 终止态：进程结束 <img src="fig/五态模型.png" /></p><ul><li>七态模型<ol type="1"><li>新建态</li><li>就绪挂起态</li><li>就绪态</li><li>运行态</li><li>等待态</li><li>挂起等待态</li><li>终止态 <img src="fig/七态模型.png" /></li></ol></li></ul><h4 id="在执行malloc申请内存的时候操作系统是怎么做的内存分配的原理说一下malloc函数底层是怎么实现的进程是怎么分配内存的">（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？</h4><p>https://blog.csdn.net/yusiguyuan/article/details/39496057</p><p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap * brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小 * mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</p><p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p><p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。 #### （25）什么是字节序？怎么判断是大端还是小端？有什么用？ https://www.cnblogs.com/broglie/p/5645200.html</p><p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。 判断大小端的方法：使用一个union数据结构 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">  <span class="keyword">short</span> s;</span><br><span class="line">  <span class="keyword">char</span> c[<span class="number">2</span>]; <span class="comment">// sizeof(short)=2;</span></span><br><span class="line">&#125;un;</span><br><span class="line">un.s=<span class="number">0x0102</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">1</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;大端&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">2</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;小端&quot;</span>;</span><br></pre></td></tr></table></figure> 在网络编程中不同字节序的机器发送和接收的顺序不同。</p><h1 id="场景题算法题">6. 场景题/算法题</h1><h4 id="leetcode-hot100至少刷两遍剑指offer至少刷两遍-重中之重">（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h4><p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要 #### （1） 介绍熟悉的设计模式（单例，简单工厂模式） #### （2） 写单例模式，线程安全版本 <figure class="highlight c++"><figcaption><span>version</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">      <span class="comment">// initialize</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance==<span class="literal">nullptr</span>) instance=<span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> #### （3） 写三个线程交替打印ABC <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">0</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 1: a&quot;</span>&lt;&lt;endl; <span class="number">1</span>=<span class="string">&quot;&quot;</span> count++;=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="string">&quot;my=&quot;</span><span class="string">&quot; cv.notify_all();=&quot;</span><span class="string">&quot; finish&quot;</span>&lt;&lt;endl;=<span class="string">&quot;&quot;</span> flag=<span class="string">&quot;1;&quot;</span> <span class="built_in">printb</span>()&#123;=<span class="string">&quot;&quot;</span> thread=<span class="string">&quot;&quot;</span> unique_lock&lt;mutex=<span class="string">&quot;&quot;</span> <span class="keyword">void</span>=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span>&gt; <span class="built_in">lk</span>(mymutex);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">1</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 2: b&quot;</span>&lt;&lt;endl; <span class="number">2</span>=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="string">&quot;my=&quot;</span><span class="string">&quot; cv.notify_all();=&quot;</span><span class="string">&quot; finish&quot;</span>&lt;&lt;endl;=<span class="string">&quot;&quot;</span> flag=<span class="string">&quot;2;&quot;</span> <span class="built_in">printc</span>()&#123;=<span class="string">&quot;&quot;</span> thread=<span class="string">&quot;&quot;</span> unique_lock&lt;mutex=<span class="string">&quot;&quot;</span> <span class="keyword">void</span>=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span>&gt; <span class="built_in">lk</span>(mymutex);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">2</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 3: c&quot;</span>&lt;&lt;endl; ![](fig=<span class="string">&quot;&quot;</span> <span class="string">&quot;&lt;&lt;endl;=&quot;</span><span class="string">&quot; ####=&quot;</span><span class="string">&quot; *=&quot;</span><span class="string">&quot; 3=&quot;</span><span class="string">&quot; ```=&quot;</span><span class="string">&quot; ```c++=&quot;</span><span class="string">&quot; a=&quot;</span>a^b;<span class="string">&quot; a,int&amp;=&quot;</span><span class="string">&quot; b=&quot;</span>a^b;<span class="string">&quot; b)&#123;=&quot;</span><span class="string">&quot; cout&lt;&lt;&quot;</span>=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="string">&quot;my=&quot;</span><span class="string">&quot; cv.notify_all();=&quot;</span><span class="string">&quot; finish&quot;</span>&lt;&lt;endl;=<span class="string">&quot;&quot;</span> flag=<span class="string">&quot;0;&quot;</span> <span class="keyword">int</span>=<span class="string">&quot;&quot;</span> main=<span class="string">&quot;&quot;</span> <span class="built_in">main</span>()&#123;=<span class="string">&quot;&quot;</span> <span class="built_in">swap</span>(<span class="keyword">int</span>&amp;=<span class="string">&quot;&quot;</span> <span class="built_in">swap</span>(vector&lt;<span class="keyword">int</span>=<span class="string">&quot;&quot;</span> <span class="built_in">th1</span>(printb);=<span class="string">&quot;&quot;</span> th1.<span class="built_in">join</span>();=<span class="string">&quot;&quot;</span> <span class="built_in">th2</span>(printa);=<span class="string">&quot;&quot;</span> th2.<span class="built_in">join</span>();=<span class="string">&quot;&quot;</span> <span class="built_in">th3</span>(printc);=<span class="string">&quot;&quot;</span> th3.<span class="built_in">join</span>();=<span class="string">&quot;&quot;</span> thread=<span class="string">&quot;&quot;</span> <span class="keyword">void</span>=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span> 不使用临时变量实现swap函数=<span class="string">&quot;&quot;</span> 二维码登录流程.png)=<span class="string">&quot;&quot;</span> 二维码登录的实现过程=<span class="string">&quot;&quot;</span> 使用异或=<span class="string">&quot;&quot;</span> 加减等方式，下面给出使用异或的实现方法=<span class="string">&quot;&quot;</span> 场景题=<span class="string">&quot;&quot;</span> 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢=<span class="string">&quot;&quot;</span> 实现快排=<span class="string">&quot;&quot;</span> （<span class="number">4</span>）=<span class="string">&quot;&quot;</span> （<span class="number">5</span>）=<span class="string">&quot;&quot;</span> （<span class="number">6</span>）=<span class="string">&quot;&quot;</span> （<span class="number">7</span>）=<span class="string">&quot;&quot;</span>&gt;&amp; vec,<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    vec[a]=vec[a]^vec[b];</span><br><span class="line">    vec[b]=vec[a]^vec[b];</span><br><span class="line">    vec[a]=vec[a]^vec[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">partition</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot=vec[start+(end-start)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123; <span class="keyword">and</span>=<span class="string">&quot;&quot;</span> start++;=<span class="string">&quot;&quot;</span> vec[end]=<span class="string">&quot;&quot;</span> vec[start]&lt;pivot)=<span class="string">&quot;&quot;</span> <span class="keyword">while</span>(start&lt;end=<span class="string">&quot;&quot;</span>&gt;pivot) end--;</span><br><span class="line">        <span class="keyword">if</span>(start&lt;end) <span class="built_in">quicksort</span>(vector&lt;<span class="keyword">int</span>=<span class="string">&quot;&quot;</span> <span class="keyword">return</span>=<span class="string">&quot;&quot;</span> start;=<span class="string">&quot;&quot;</span> <span class="built_in">swap</span>(vec,start,end);=<span class="string">&quot;&quot;</span> <span class="keyword">void</span>=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span>&gt;&amp; vec,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot=<span class="built_in">partition</span>(vec,start,end);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec,start,pivot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec,pivot+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### （8） 实现一个堆排序 堆排序的基本过程： * 将n个元素的序列构建一个大顶堆或小顶堆 * 将堆顶的元素放到序列末尾 * 将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</p><p>整体时间复杂度为nlogn <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    arr[a]=arr[a]^arr[b];</span><br><span class="line">    arr[b]=arr[a]^arr[b];</span><br><span class="line">    arr[a]=arr[a]^arr[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr,<span class="keyword">int</span> len,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxid=index;</span><br><span class="line">    <span class="comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">2</span>*index+<span class="number">1</span>,right=<span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找当前以index为根的子树中最大/最小的元素的下标</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;len <span class="built_in">adjust</span>(arr,len,maxid);=<span class="string">&quot;&quot;</span> <span class="keyword">and</span>=<span class="string">&quot;&quot;</span> arr[left]&lt;arr[maxid])=<span class="string">&quot;&quot;</span> arr[right]&lt;arr[maxid])=<span class="string">&quot;&quot;</span> <span class="built_in">heapsort</span>(vector&lt;<span class="keyword">int</span>=<span class="string">&quot;&quot;</span> <span class="keyword">if</span>(maxid!=<span class="string">&quot;index)&#123;&quot;</span> <span class="keyword">if</span>(right&lt;len=<span class="string">&quot;&quot;</span> maxid=<span class="string">&quot;right;&quot;</span> <span class="built_in">swap</span>(arr,maxid,index);=<span class="string">&quot;&quot;</span> <span class="keyword">void</span>=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span> 进行交换，记得要递归进行adjust,传入的index是maxid=<span class="string">&quot;&quot;</span>&gt;&amp;arr,<span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="comment">// 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(len<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">adjust</span>(arr,len,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr,<span class="number">0</span>,i);</span><br><span class="line">        <span class="built_in">adjust</span>(arr,i,<span class="number">0</span>);<span class="comment">// 注意每次adjust是从根往下调整，所以这里index是0！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;before: &quot;</span>&lt;&lt;endl; <span class="string">&quot;;=&quot;</span><span class="string">&quot; &quot;</span>&lt;&lt;endl;=<span class="string">&quot;&quot;</span> ####=<span class="string">&quot;&quot;</span> <span class="number">0</span>;=<span class="string">&quot;&quot;</span> <span class="number">8656425</span>=<span class="string">&quot;&quot;</span> ```=<span class="string">&quot;&quot;</span> ```c++=<span class="string">&quot;&quot;</span> article=<span class="string">&quot;&quot;</span> blog.csdn.net=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="string">&quot;after:=&quot;</span><span class="string">&quot; cout&lt;&lt;endl;=&quot;</span><span class="string">&quot; cout&lt;&lt;item&lt;&lt;&quot;</span>=<span class="string">&quot;&quot;</span> details=<span class="string">&quot;&quot;</span> <span class="keyword">for</span>(<span class="keyword">int</span>=<span class="string">&quot;&quot;</span> <span class="built_in">heapsort</span>(arr,arr.<span class="built_in">size</span>());=<span class="string">&quot;&quot;</span> https:=<span class="string">&quot;&quot;</span> <span class="built_in">insertsort</span>(vector&lt;<span class="keyword">int</span>=<span class="string">&quot;&quot;</span> item:arr)=<span class="string">&quot;&quot;</span> item:arr)cout&lt;&lt;item&lt;&lt;<span class="string">&quot;=&quot;</span><span class="string">&quot; left_la=&quot;</span><span class="string">&quot; return=&quot;</span><span class="string">&quot; void=&quot;</span><span class="string">&quot; &#125;=&quot;</span><span class="string">&quot; 实现一个插入排序=&quot;</span><span class="string">&quot; （8）=&quot;</span><span class="string">&quot;&gt;&amp; nums)&#123;</span></span><br><span class="line"><span class="string">  int len=nums.size();</span></span><br><span class="line"><span class="string">  for(int i=1;i&lt;len;i++)&#123; int=&quot;</span><span class="string">&quot; j=&quot;</span>i<span class="number">-1</span>;<span class="string">&quot; key=&quot;</span>nums[i];<span class="string">&quot; while(j=&quot;</span><span class="string">&quot;&gt;=0 and nums[j]&gt;key)&#123;</span></span><br><span class="line"><span class="string">      nums[j+1]=nums[j];</span></span><br><span class="line"><span class="string">      j--;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    nums[j+1]=key;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="快排存在的问题如何优化">（9） 快排存在的问题，如何优化</h4><ul><li>3 种快排基准选择方法：</li></ul><p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p><ul><li>4种优化方式：</li></ul><p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p><p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p><p>优化3：优化递归操作</p><p>优化4：使用并行或多线程处理子序列 #### （10） 反转一个链表（招银网络二面） <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* root)</span></span>&#123;</span><br><span class="line">  ListNode* pre=<span class="literal">nullptr</span>,cur=root,nxt;</span><br><span class="line">  <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    nxt=cur-&gt;next;</span><br><span class="line">    cur-&gt;next=pre;</span><br><span class="line">    pre=cur;cur=nxt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### （11） Top K问题（可以采取的方法有哪些，各自优点？）（重点） <em>Top K 问题的常见形式：</em> &gt;给定10000个整数，找第K大（第K小）的数</p><p>给定10000个整数，找出最大（最小）的前K个数</p><p>给定100000个单词，求前K词频的单词</p><p><em>解决Top K问题若干种方法</em> * 使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。 * Quick Select算法。使用类似快排的思路，根据pivot划分数组。 * 使用排序方法，排序后再寻找top K元素。 * 使用选择排序的思想，对前K个元素部分排序。 * 将1000.....个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</p><ol type="1"><li>使用最大最小堆的思路 （以top K 最大元素为例）</li></ol><p>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</p><blockquote><p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p></blockquote><p>C++中的最大最小堆要用标准库的priority_queue来实现。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="keyword">int</span> v, <span class="keyword">int</span> i): <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> struct Node &amp;n1, <span class="keyword">const</span> struct Node &amp;n2) ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> struct Node &amp;n1, <span class="keyword">const</span> struct Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li>使用Quick Select的思路（以寻找第K大的元素为例）</li></ol><p>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的： 首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。 此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作； 如果左边的数组元素个数等于K-1，则第K大的数就是pivot； 如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</p><p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//此为Java实现</span><br><span class="line">public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">  return quickSelect(nums, k, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// quick select to find the kth-largest element</span><br><span class="line">public int quickSelect(int[] arr, int k, int left, int right) &#123;</span><br><span class="line">  if (left == right) return arr[right];</span><br><span class="line">  int index = partition(arr, left, right);</span><br><span class="line">  if (index - left + 1 &gt; k)</span><br><span class="line">    return quickSelect(arr, k, left, index - 1);</span><br><span class="line">  else if (index - left + 1 == k)</span><br><span class="line">    return arr[index];</span><br><span class="line">  else</span><br><span class="line">    return quickSelect(arr, k - (index - left + 1), index + 1, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3" type="1"><li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）</li></ol><p>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K) #### （12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面） 我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</p><p>https://blog.csdn.net/ailunlee/article/details/84548950</p><h4 id="自己构建一棵二叉树使用带有null标记的前序遍历序列">（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</h4><p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span>&#123;</span></span><br><span class="line">    string val;</span><br><span class="line">    treeNode* left,*right;</span><br><span class="line">    <span class="built_in">treeNode</span>(string val):<span class="built_in">val</span>(val)&#123;</span><br><span class="line">        left=<span class="literal">nullptr</span>;</span><br><span class="line">        right=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">treeNode* <span class="title">vec2tree</span><span class="params">(vector&lt;string&gt;&amp; vec,<span class="keyword">int</span>&amp; start)</span></span>&#123;</span><br><span class="line">    treeNode* root;</span><br><span class="line">    <span class="keyword">if</span>(vec[start]==<span class="string">&quot;null&quot;</span>)&#123;</span><br><span class="line">        start+=<span class="number">1</span>;</span><br><span class="line">        root=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> <span class="built_in">treeNode</span>(vec[start]);</span><br><span class="line">        start+=<span class="number">1</span>;</span><br><span class="line">        root-&gt;left=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">        root-&gt;right=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree2vec</span><span class="params">(treeNode *root,vector&lt;string&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;left,vec);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;right,vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec=&#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>,&amp;start=index;</span><br><span class="line">    treeNode* root=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">    <span class="comment">//displaytree(root);</span></span><br><span class="line">    vector&lt;string&gt; mvec;</span><br><span class="line">    <span class="built_in">tree2vec</span>(root,mvec);</span><br><span class="line">    <span class="keyword">for</span>(string item:mvec) cout&lt;&lt;item&lt;&lt;<span class="string">&quot; ![](fig=&quot;</span><span class="string">&quot; &quot;</span>;=<span class="string">&quot;&quot;</span> ####=<span class="string">&quot;&quot;</span> *=<span class="string">&quot;&quot;</span> **移位计算公式：**=<span class="string">&quot;&quot;</span> <span class="number">0</span>;=<span class="string">&quot;&quot;</span> <span class="number">1.</span>=<span class="string">&quot;&quot;</span> <span class="number">1000</span>=<span class="string">&quot;&quot;</span> <span class="number">110202102</span>=<span class="string">&quot;&quot;</span> <span class="number">2</span>=<span class="string">&quot;&quot;</span> <span class="number">2.</span>=<span class="string">&quot;&quot;</span> <span class="number">3.</span>=<span class="string">&quot;&quot;</span> <span class="number">32</span>]。=<span class="string">&quot;&quot;</span> <span class="number">32</span>就是将n的二进制右移log32（也就是<span class="number">5</span>）位=<span class="string">&quot;&quot;</span> <span class="number">4.</span>=<span class="string">&quot;&quot;</span> <span class="number">5.</span>=<span class="string">&quot;&quot;</span> <span class="number">6104371.</span>html=<span class="string">&quot;&quot;</span> <span class="number">7786014</span>=<span class="string">&quot;&quot;</span> &lt;=<span class="string">&quot;m）&quot;</span> =<span class="number">4</span>*<span class="number">8</span>比特=<span class="string">&quot;32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int&quot;</span> ```=<span class="string">&quot;&quot;</span> ```sql=<span class="string">&quot;&quot;</span> a[<span class="number">1</span>+max=<span class="string">&quot;&quot;</span> article=<span class="string">&quot;&quot;</span> b+树是一种特殊的b树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。=<span class="string">&quot;&quot;</span> bitmap1.png)=<span class="string">&quot;&quot;</span> bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。=<span class="string">&quot;&quot;</span> blog.csdn.net=<span class="string">&quot;&quot;</span> b树主要应用于文件系统中，在数据库中（mongodb）也有应用，与b+树相比好处应该是有时不需要访问到叶节点就可以获取数据。=<span class="string">&quot;&quot;</span> b树也叫做b-树，或者平衡多路树，它是每个节点最多有m个子树的**平衡树**。一个m阶的b树具有如下几个特征：=<span class="string">&quot;&quot;</span> chengxiao=<span class="string">&quot;&quot;</span> cout&lt;&lt;endl;=<span class="string">&quot;&quot;</span> details=<span class="string">&quot;&quot;</span> from=<span class="string">&quot;&quot;</span> hguisu=<span class="string">&quot;&quot;</span> https:=<span class="string">&quot;&quot;</span> limit=<span class="string">&quot;&quot;</span> m=<span class="string">&quot;&quot;</span> n=<span class="string">&quot;&quot;</span> n个骰子出现和为m的概率=<span class="string">&quot;&quot;</span> p=<span class="string">&quot;&quot;</span> <span class="keyword">return</span>=<span class="string">&quot;&quot;</span> select=<span class="string">&quot;&quot;</span> t1=<span class="string">&quot;&quot;</span> www.cnblogs.com=<span class="string">&quot;&quot;</span> zhuanlan.zhihu.com=<span class="string">&quot;&quot;</span> 一致性哈希=<span class="string">&quot;&quot;</span> 介绍一下b+树和它的应用场景有哪些=<span class="string">&quot;&quot;</span> 介绍一下b树和它的应用场景有哪些=<span class="string">&quot;&quot;</span> 介绍一下红黑树和它的应用场景有哪些=<span class="string">&quot;&quot;</span> 依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为<span class="number">1</span>的就还原该数字。=<span class="string">&quot;&quot;</span> 叶节点的空节点是黑色的。=<span class="string">&quot;&quot;</span> 如果一个节点是红色的，那么它的两个子节点是黑色的。=<span class="string">&quot;&quot;</span> 如果使用<span class="keyword">int</span>型数组的形式来保存的话，一个<span class="keyword">int</span>=<span class="string">&quot;4字节&quot;</span> 它的具体过程是：先根据数组中元素最大的数n计算需要分配多大的空间。=<span class="string">&quot;&quot;</span> 它的性质是这样的：=<span class="string">&quot;&quot;</span> 对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。=<span class="string">&quot;&quot;</span> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至<span class="number">1</span>时，整个文件恰被分成一组，算法便终止。=<span class="string">&quot;&quot;</span> 应用场景主要是stl中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logn=<span class="string">&quot;&quot;</span> 应用场景主要是数据库的索引=<span class="string">&quot;&quot;</span> 怎么写sql取表的前<span class="number">1000</span>行数据（招银网络二面）=<span class="string">&quot;&quot;</span> 所有的叶子结点都位于同一层。=<span class="string">&quot;&quot;</span> 手撕=<span class="string">&quot;&quot;</span> 查询时间复杂度也是logn=<span class="string">&quot;&quot;</span> 查询时间复杂度是logn=<span class="string">&quot;&quot;</span> 根结点至少有两个子女。=<span class="string">&quot;&quot;</span> 根节点是黑色的。=<span class="string">&quot;&quot;</span> 模拟stl中vector的实现即可，去看一下vector的源码。=<span class="string">&quot;&quot;</span> 每个中间节点都包含至多m个子树=<span class="string">&quot;&quot;</span> 每个节点不是红色就是黑色。=<span class="string">&quot;&quot;</span> 每个节点中的元素从小到大排列，节点当中k<span class="number">-1</span>个元素正好是k个子树包含的元素的值域分划。=<span class="string">&quot;&quot;</span> 每个节点包含的元素个数是其子树个数<span class="number">-1</span>（其中=<span class="string">&quot;&quot;</span> 海量数据的bitmap使用原理=<span class="string">&quot;&quot;</span> 海量数据问题（可参考左神的书）=<span class="string">&quot;&quot;</span> 然后需要推导一个整数a内如何映射<span class="number">32</span>个数据，方法是将待存储的数据模<span class="number">32</span>，然后将a中相应位置的比特置为<span class="number">1</span>。=<span class="string">&quot;&quot;</span> 红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。=<span class="string">&quot;&quot;</span> 红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是<span class="built_in">o</span>(<span class="built_in">log</span>(n))=<span class="string">&quot;&quot;</span> （<span class="number">14</span>）=<span class="string">&quot;&quot;</span> （<span class="number">15</span>）=<span class="string">&quot;&quot;</span> （<span class="number">16</span>）=<span class="string">&quot;&quot;</span> （<span class="number">17</span>）=<span class="string">&quot;&quot;</span> （<span class="number">18</span>）=<span class="string">&quot;&quot;</span> （<span class="number">19</span>）=<span class="string">&quot;&quot;</span> （<span class="number">20</span>）=<span class="string">&quot;&quot;</span> （<span class="number">21</span>）希尔排序说一下=<span class="string">&quot;&quot;</span> （<span class="number">22</span>）dijkstra算法说一下=<span class="string">&quot;&quot;</span> （<span class="number">23</span>）实现一个动态数组要怎么实现，说思路（腾讯teg一面）=<span class="string">&quot;&quot;</span> （<span class="number">24</span>）最小生成树算法说一下=<span class="string">&quot;&quot;</span> （<span class="number">25</span>）=<span class="string">&quot;&quot;</span> ，=<span class="string">&quot;&quot;</span> ：=<span class="string">&quot;&quot;</span>&gt;&gt;<span class="number">5</span>  </span><br><span class="line"></span><br><span class="line">N%<span class="number">32</span>就是求N的后<span class="number">5</span>位：N&amp; <span class="number">0x1F</span>  (<span class="number">0x1F</span> = <span class="number">00011111</span>)  </span><br><span class="line"></span><br><span class="line">模<span class="number">32</span>然后相应位置置为<span class="number">1</span>： a[i] |= <span class="number">1</span>&lt;&lt; N &amp; <span class="number">0x1F</span>  </span><br><span class="line"></span><br><span class="line">所以总的公式为： a[ N&gt;&gt;<span class="number">5</span> ] |= <span class="number">1</span>&lt;&lt; N &amp; <span class="number">0x1F</span>  </span><br><span class="line"></span><br><span class="line">**BitMap算法评价**</span><br><span class="line">* 优点：</span><br><span class="line">    <span class="number">1.</span> 运算效率高，不进行比较和移位；</span><br><span class="line">    <span class="number">2.</span> 占用内存少，比如最大的数MAX=<span class="number">10000000</span>；只需占用内存为MAX/<span class="number">8</span>=<span class="number">1250000B</span>yte=<span class="number">1.25</span>M。</span><br><span class="line">* 缺点：</span><br><span class="line">    <span class="number">1.</span> 所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用<span class="number">2</span>-bitmap）。</span><br><span class="line">    <span class="number">2.</span> 所需要的空间随着最大元素的增大而增大，当数据类似（<span class="number">1</span>，<span class="number">1000</span>，<span class="number">10</span>万）只有<span class="number">3</span>个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</span><br><span class="line"></span><br><span class="line">#### （<span class="number">26</span>） 布隆过滤器原理与优点</span><br><span class="line">布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</span><br><span class="line"></span><br><span class="line">**它的具体工作过程是这样子的：**</span><br><span class="line">假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为<span class="number">1</span>。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为<span class="number">1</span>，如果某一个相应的位不为<span class="number">1</span>，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</span><br><span class="line"></span><br><span class="line">**为什么说有可能存在呢？**</span><br><span class="line">因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到<span class="number">1</span>也可能是由于某个另外的数据映射得到的。</span><br><span class="line"></span><br><span class="line">**支持删除操作吗**</span><br><span class="line">目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为<span class="number">1</span>则计数加一，删除则减一。</span><br><span class="line"></span><br><span class="line">布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为<span class="number">1</span>，如果太少会容易误报。</span><br><span class="line"></span><br><span class="line">**布隆过滤器的大小以及哈希函数的个数怎么选择？**</span><br><span class="line">k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率</span><br><span class="line">![](fig/布隆过滤器.png)</span><br><span class="line">#### （<span class="number">27</span>） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</span><br><span class="line">#### （<span class="number">28</span>）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</span><br><span class="line">```C++</span><br><span class="line"><span class="comment">//评测题目: </span></span><br><span class="line">class FIFOQueue</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">vec</span>(initCap,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">condition_variable cv;</span><br><span class="line">mutex m;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;<span class="comment">// isFull</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(flag==<span class="literal">true</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        end=(end+<span class="number">1</span>)%initCap;</span><br><span class="line">        vec[end]=v;</span><br><span class="line">        cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">  <span class="keyword">if</span>(start!=end)&#123;</span><br><span class="line">    <span class="keyword">int</span> val = vec[start];</span><br><span class="line">    start=(start+<span class="number">1</span>)%initCap;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">    cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    flag=<span class="literal">false</span>;</span><br><span class="line">    cv.<span class="built_in">notifyall</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 以上代码是面试时写的，并没有运行，也许有错误，请客观参考 # 7. 智力题 #### （1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题） * （给定了楼层数和鸡蛋数的情况）二分法+线性查找 从100/2=50楼扔起，如果破了就用另一个从0扔起直到破。如果没破就从50/2=25楼扔起，重复。 * 动态规划 #### （2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠 用二进制的思路解决问题。2的十次方是1024，使用十只小鼠喝一次即可。方法是先将每瓶水编号，同时10个小鼠分别表示二进制中的一个位。将每瓶水混合到水瓶编号中二进制为1的小鼠对应的水中。喝完后统计，将死亡小鼠对应的位置为1，没死的置为0，根据死亡小鼠的编号确定有毒的是哪瓶水，如0000001010表示10号水有毒。 #### （3） #### （4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿 寻找每个回合固定的拿取模式。最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。关键是第一次我必须先手拿（100%6=4）本（这不算在第一回合里面）。 #### （5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。 碰到就当没发生，继续走，相当于碰到的两个蚂蚁交换了一下身体。其实就是每个蚂蚁从当前位置一直走直到停止的总距离或者时间。 #### （6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶 拿走3瓶，换回1瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4=996，996/2=498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1=1499瓶。 #### （7）在24小时里面时针分针秒针可以重合几次 24小时中时针走2圈，而分针走24圈，时针和分针重合24-2=22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次 #### （8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？ 至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个； 第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个； #### （9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？ 砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组 #### （10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？ 思路：由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。 记住下面这个式子： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandNN= N( RandN()-1 ) + RandN() ;// 生成1到N^2之间的随机数</span><br><span class="line">可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度，RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙</span><br></pre></td></tr></table></figure> 比如<code>Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3<em>7）之间的数字，所以可以这么写 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int rand7()&#123;</span><br><span class="line">  int x=INT_MAX;</span><br><span class="line">  while(x&gt;21)&#123;</span><br><span class="line">    x=5*(rand5()-1)+rand5();</span><br><span class="line">  &#125;</span><br><span class="line">  return x%7+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？ </em> 第一次，分成5个赛道ABCDE，每个赛道5匹马，每个赛道比赛一场，每个赛道的第12345名记为 A1,A2,A3,A4,A5 B1,B2,B3,B4,B5等等，这一步要赛5场。 * 第二次，我们将每个赛道的前三名，共15匹。分成三组，然后每组进行比赛。这一步要赛3场。 * 第三次，我们取每组的前三名。共9匹，第一名赛道的马编号为1a,1b,1c，第二名赛道的马编号为2a,2b,2c，第三名赛道的马编号为3a,3b,3c。这时进行分析，1a表示第一名里面的第一名，绝对是所有马中的第一，所以不用再比了。2c表示第二名的三匹里头的最后一匹，3b和3c表示第三名里面的倒数两匹，不可能是所有马里面的前三名，所以也直接排除，剩下1b,1c,2a,2b,,3a，共5匹，再赛跑一次取第一第二名，加上刚筛选出来的1a就是所有马里面的最快3匹了。这一步要赛1场。 * 所以一共是5+3+1=9场。 #### 烧 香/绳子/其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？ （说了求15分钟，没说开始的15分钟还是结束的15分钟，这里是可以求最后的15分钟）点燃一根A，同时点燃另一根B的两端，当另一根B烧完的时候就是半小时，这是再将A的另一端也点燃，从这时到A燃烧完就正好15分钟。</p><h4 id="掰巧克力问题-nm块巧克力每次掰一块的一行或一列掰成11的巧克力需要多少次1000个人参加辩论赛1v1输了就退出需要安排多少场比赛">掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</h4><p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N*M块，所以要掰N*M-1次，-1是因为最开始的一块是不用算进去的。</p><p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1=999场。 # 8. 大数据 #### 1. 介绍一下Hadoop Hadoop是一套大数据解决方案，提供了一套分布式的系统基础架构，包括HDFS，MapReduce和YARN。 * HDFS提供分布式的数据存储 * MapReduce负责进行数据运算 * YARN负责任务调度</p><p>HDFS是主从架构的，包括namenode，secondarynamenode和datanode。datanode负责存储数据，namenode负责管理HDFS的目录树和文件元信息。</p><p>MapReduce包括jobtracker,tasktracker和client。Jobtracker负责进行资源调度和作业监控。tasktracker会周期性的通过心跳向jobtracker汇报资源使用情况。 #### 2. 说一下MapReduce的运行机制 MapReduce包括输入分片、map阶段、combine阶段、shuffle阶段和reduce阶段。分布式计算框架包括client，jobtracker和tasktracker和调度器。 * 输入分片阶段，mapreduce会根据输入文件计算分片，每个分片对应一个map任务 * map阶段会根据mapper方法的业务逻辑进行计算，映射成键值对 * combine阶段是在节点本机进行一个reduce，减少传输结果对带宽的占用 * shuffle阶段是对map阶段的结果进行分区，排序，溢出然后写入磁盘。将map端输出的无规则的数据整理成为有一定规则的数据，方便reduce端进行处理，有点像洗牌的逆过程。 https://blog.csdn.net/ASN_forever/article/details/81233547 * reduce阶段是根据reducer方法的业务逻辑进行计算，最终结果会存在hdfs上。</p><h4 id="介绍一下kafka">3. 介绍一下kafka</h4><p>https://blog.csdn.net/qq_29186199/article/details/80827085</p><p>https://blog.csdn.net/student__software/article/details/81486431</p><p>kafka是一个分布式消息队列，包括producer、broker和consumer。kafka会对每个消息根据topic进行归类，每个topic又会分成多个partition，消息会根据先进先出的方式存储。消费者通过offset进行消费。</p><p>kafka的特点是吞吐量高，可以进行持久化，高可用。 #### 4. 为什么kafka吞吐量高？/介绍一下零拷贝 kafka吞吐量高是因为一个利用了磁盘顺序读写的特性，速度比随机读写要快很多，另一个是使用了零拷贝，数据直接在内核进行输入和输出，减少了用户空间和内核空间的切换。</p><p>零拷贝：传统文件读取并发送至网络的步骤是：先将文件从磁盘拷贝到内核空间，然后内核空间拷贝到用户空间的缓冲区，再从用户空间拷贝到内核空间的socket缓冲区，最后拷贝到网卡并发送。而零拷贝技术是先将文件从磁盘空间拷贝到内核缓冲区，然后直接拷贝至网卡进行发送，减少了重复拷贝操作。 #### 5. 介绍一下spark https://blog.csdn.net/u011204847/article/details/51010205</p><p>spark是一个通用内存并行计算框架。它可以在内存中对数据进行计算，效率很高，spark的数据被抽象成RDD（弹性分布式数据集）并且拥有DAG执行引擎，兼容性和通用性很好。可以和Hadoop协同工作。 #### 6. 介绍一下spark-streaming https://blog.csdn.net/yu0_zhang0/article/details/80569946</p><p>spark-streaming是spark的核心组件之一。主要提供高效的流计算能力。spark-streaming的原理是将输入数据流以时间片进行拆分，然后经过spark引擎以类似批处理的方式处理每个时间片数据。</p><p>spark-streaming将输入根据时间片划分成一段一段的Dstream（也就是离散数据流），然后将每一段数据转换成RDD进行操作。</p><h4 id="spark的transformation和action有什么区别">7. spark的transformation和action有什么区别</h4><p>spark的算子分成transformation和action两类 * transformation是变换算子，这类算子不会触发提交，是延迟执行的。也就是说执行到transformation算子的时候数据并没有马上进行计算，只是记住了对RDD的逻辑操作 * action算子是执行算子，会出发spark提交作业，并将数据输出到spark #### 8. spark常用的算子说几个 spark的算子分为两类：transformation和action</p><p>常用的transformation算子： <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union 求并集</span></span><br><span class="line"><span class="keyword">val</span> rdd8 = rdd6.union(rdd7)</span><br><span class="line"></span><br><span class="line"><span class="comment">// intersection 求交集 </span></span><br><span class="line"><span class="keyword">val</span> rdd9 = rdd6.intersection(rdd7)</span><br><span class="line"></span><br><span class="line"><span class="comment">// join 将rdd进行聚合连接，类似数据库的join </span></span><br><span class="line"><span class="keyword">val</span> rdd3 = rdd1.join(rdd2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map flatMap mapPartition 传入一个函数对数据集中的每一个数据进行操作 </span></span><br><span class="line"><span class="keyword">val</span> arr1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> arr2 = rdd1.map(_+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// countByKey reduceByKey partitionByKey 统计每个key有多少个键值对 </span></span><br></pre></td></tr></table></figure> 常用的action算子 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce 按照一定的方法将元素进行合并 </span></span><br><span class="line"><span class="keyword">val</span> rdd2 = rdd1.reduce(_+_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// collect 将RDD转换为数组</span></span><br><span class="line">rdd1.collect</span><br><span class="line"></span><br><span class="line"><span class="comment">// top 返回最大的k个元素</span></span><br><span class="line">rdd1.top(<span class="number">2</span>)</span><br></pre></td></tr></table></figure> #### 9. 如何保证kafka的消息不丢失 https://blog.csdn.net/liudashuang2017/article/details/88576274</p><p>我们可以从三个方面保证kafka不丢失消息 * 首先从producer生产者方面，为send()方法注册一个回调函数，可以得知消息发送有没有成功；将重试次数retrie设置为3；设置acks参数为all，当消息被写入所有同步副本之后才算发送成功。 * 在consumer消费者方面，关闭自动提交； * 在broker集群方面，设置复制系数replica.factor为大于等于3 #### 10. kafka如何选举leader 首先启动的broker在zookeeper中创建一个临时节点并让自己称为leader，其他的节点会创建watch对象进行监听并成为follower，当broker宕机的时候，其他follower会尝试创建这个临时节点，但是只有一个能够创建成功，创建成功的broker就会成为leader。</p><h4 id="说下spark中的宽依赖和窄依赖">11. 说下spark中的宽依赖和窄依赖</h4><p>https://blog.csdn.net/a1043498776/article/details/54889922</p><ul><li>宽依赖：指子RDD的分区依赖于父RDD的所有分区，举例：groupbykey,join</li><li>窄依赖：指父RDD的每个分区被最多一个子RDD的分区所依赖,举例：map，filter <img src="https://img-blog.csdn.net/20170206221148299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEwNDM0OTg3NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /> #### 12. 说下spark中stage是依照什么划分的 https://zhuanlan.zhihu.com/p/57124273</li></ul><p>spark中的stage其实是一组并行的任务，spark会将多个RDD根据依赖关系划分成有向无环图DAG，DAG会被划分成多个stage，划分的依据是RDD之间的宽窄依赖。遇到宽依赖就划分stage。因为宽依赖与窄依赖的区别之一就是宽依赖会发生shuffle操作，所以也可以说stage的划分依据是是否发生shuffle操作。</p><h4 id="spark的内存管理是怎样的">13. spark的内存管理是怎样的</h4><p>https://www.jianshu.com/p/4f1e551553ae</p><p>https://www.cnblogs.com/wzj4858/p/8204282.html</p><p>spark的内存包括静态内存管理和统一内存管理两种机制。静态内存管理中存储和执行两块内存区域是分开的，统一内存管理中两块内存之间可以相互借用</p><ul><li>静态内存管理：静态内存管理机制下堆内内存包括安全内存，存储内存，shuffle内存和unroll内存</li></ul><p><img src="fig/spark内存一.png" /> * 统一内存管理：统一内存管理机制下内存分为spark内存，用户内存和保留内存三部分。用户内存存放用户代码逻辑和自定义数据结构等，保留内存存放的是spark的内部对象和逻辑。 <img src="https://upload-images.jianshu.io/upload_images/195230-f119edabb5683f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" /></p><h4 id="spark的容错机制是什么样的">14. spark的容错机制是什么样的</h4><p>https://blog.csdn.net/dengxing1234/article/details/73613484</p><p>spark的容错机制是通过血统（lineage）和checkpoint来实现的 。</p><ul><li>RDD的lineage可以看作是一个重做日志（redo log）记录的是它粗粒度上的transformation操作。当rdd的分区数据丢失时，它可以根据lineage重新计算来恢复数据。 在窄依赖上可以直接计算父RDD的节点数据进行恢复，在宽依赖上则要等到父RDD所有数据计算完后并将结果shuffle到子RDD上才能完成恢复。</li><li>如果DAG中的lineage过长，或者在宽依赖上进行checkpoint的收益更大，就会使用checkpoint进行容错，将RDD写入磁盘进行持久化存储，如果节点数据丢失，就从磁盘读取数据进行恢复。</li></ul><h1 id="hr面">9. HR面</h1><h4 id="自我介绍">1. 自我介绍</h4><p>（HR面试的自我介绍可以侧重软实力部分，项目技术方面介绍可以适当少一些） #### 2. 项目中遇到的最大难点 * 在项目中曾经遇到了新的框架不知道该如何上手的问题，以及面对新的概念，新的技术不知道从何学起。解决的办法是在官网寻找说明文档和demo，按照说明文档上的内容一步步了解，以及咨询身边有用过这个框架的同学，或者在CSDN上寻找相关博客。</p><ul><li>项目的时间比较紧迫，没有那么多的时间可以用。解决方法是把还没有完成的项目分一个轻重缓急，在有限的时间里，先做重要而且紧急的，然后完成紧急的，再做重要的。利用轻重缓急做一个取舍。 #### 3. 项目中的收获 一个是了解了相关框架的使用方法（比如Dataframe的使用，xgboost的使用等等），这些框架或者技术可以在以后的开发中使用到。和对自己开发能力的锻炼。</li></ul><p>一个是锻炼了与他人的交流能力，因为在团队项目里经常会跟别人汇报自己的想法和进度，同时也会跟其他成员沟通模块之间的交互，所以在这个过程中对自己的表达能力和理解能力都是一个很大的提升。 #### 4. 可以实习的时间，实习时长 一定要往长了说！半年起步，最好七八个月，因为实习生是可以随时跑路的。而且实习时间越长HR越青睐。 #### 5. 哪里人 #### 6. 说一下自己的性格 我是比较内向谨慎的人，平时做的多说的少。比较善于总结，在与人交流的时候更倾向于倾听别人的意见后才发言。并且别人都说我办事认真靠谱。 #### 7. 你的优缺点是什么 我的缺点是容易在一些细节的地方花费太多的时间，有时候过分追求细节。并且我的实习经验比较缺乏，对于实际项目的业务流程和工作流程不是很了解。（所以我打算通过实习来熟悉实际的软件开发的流程和技术。）</p><p>我的优点是责任心比较强，做事比较负责，在校期间我负责的大创项目进展很顺利，我经常组织组员们进行讨论和推进项目的开发，最后这个项目得到了92的评分，在同级别里面是比较高的。 #### 8. 有什么兴趣爱好，画的怎么样/球打的如何/游戏打的怎么样 平时的爱好是画画打游戏，在CSDN写写博客，还有就是看书，我很喜欢学到新知识掌握新技能的感觉。 #### 9. 看过最好的一本书是什么 技术类：编程之美 机器学习西瓜书 STL源码剖析 剑指offer C++primer plus</p><p>非技术类：明朝那些事儿 香水（聚斯金德） 解忧杂货店 人类简史 沉默的大多数 与时间做朋友（李笑来） 千年历史千年诗 #### 10. 学习技术中有什么难点 #### 11. 怎么看待加班 我觉得 任何一家单位都有可能要加班。如果自己的工作没有按时完成，那自觉加班是理所当然的，当然，自己要不断提高工作效率，避免这种原因导致的加班。如果遇到紧急任务或者突发状况时，为了顺利配合团队完成任务，我会尽自己所能加班共同完成。 #### 12. 觉得深圳怎么样（或者其他地点） #### 13. 遇见过最大的挫折是什么，怎么解决的</p><h4 id="职业规划">14. 职业规划</h4><p>在工作的第一个阶段，先尽快适应工作的环境，包括开发环境开发工具和工作流程等，把自己负责的部分快速的完成，不能出差错。第二个阶段要熟悉整个项目的业务流程，所有模块的结构和依赖关系，知道每个模块为什么要这么设计，以及它们的实现细节。第三个阶段要培养独立设计一个项目的能力，可以独立或者在别人的协作下设计项目的模块分工和架构。</p><p>在工作和项目中多写博客或者笔记，积累技术影响力，将经验总结成文档。同时与同事搞好关系，尝试培养领导能力和组织能力。</p><h4 id="目前的offer情况">15. 目前的offer情况</h4><p>可以如实说 #### 16. 你最大的优势和劣势是什么 * 优势：做事情有主动性，不拖沓，有责任心。举个例子：在做论文课题的时候，几乎都是我自己找老师汇报进度和找老师讨论问题，很少有被老师催的时候。每一次跟老师讨论之后都会将讨论的内容和老师提出的意见进行详细记录。在中软杯的比赛中，主动承担答辩ppt的制作，并且每次排练之后都迅速对ppt的修改意见进行落实修改，前前后后改了十几版。 * 劣势：有时候做事情比较急躁，容易导致粗心。 #### 17. 介绍在项目里面充当的角色 #### 18. 介绍一下本科获得的全国赛奖项的情况 #### 19. 最有成就感的事情/最骄傲的一件事情 * 本科的时候跟优秀的队友们一起参加中国软件杯比赛努力了四个月，最后获得了该赛题的第一名和全国一等奖的好成绩 * 保研夏令营拿到了四个学校的offer #### 20. 在实验室中担任什么角色，参加的XXX能聊聊吗 #### 22. 用两个词来形容自己 踏实 认真</int>&lt;/item&lt;&lt;"&gt;</string></string></string></string></queue></vector></iostream></node>&lt;/len;i++){&gt;&lt;/endl;&gt;</int></len></int></int></vector></iostream>&lt;/end)&gt;&lt;/end){&gt;</int>&lt;/endl;&gt;&lt;/endl;&gt;&lt;/endl;&gt;</mutex></condition_variable></mutex></thread></iostream>&lt;/int,int&gt;&lt;/pair&lt;int,int&gt;&lt;/pair&lt;int,int&gt;&lt;/int,list&lt;pair&lt;int,int&gt;&lt;/pair&lt;int,int&gt;&lt;/pair&lt;int,int&gt;&lt;/int,list&lt;pair&lt;int,int&gt;&lt;/a.data&lt;&lt;endl;}&gt;</iostream></iostream></typename>&lt;/stdio.h&gt;&lt;/sizeof(a)&lt;&lt;endl;&gt;&lt;/sizeof(a)&lt;&lt;endl;&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Where to go and What to do</title>
      <link href="/2021/11/23/Where%20to%20go%20and%20What%20to%20do/"/>
      <url>/2021/11/23/Where%20to%20go%20and%20What%20to%20do/</url>
      
        <content type="html"><![CDATA[<p>最近几周一直在下雨，天气也转凉的很快，而我则过得很低落，心情郁闷，即便做好了计划还是啥也不想干，工作生活混乱且没有任何心劲，唯一比较开心的就是晚上和欣儿聊会天~但是她有时候也不是特别懂我的感受</p><p>造成上述现象的原因很多也很凌乱，我试着列一下吧： 1. 被傻逼小老板打了小报告，整天给她搬砖反倒被她捅了一刀，心里很不爽，本来就不想科研，这下更不想弄了。容我再说一句，zxy yydsb 2. 投出去的论文感觉大概率会被拒掉，而且有的补充材料没有提交，心里一直没底，被拒一定会影响自己的后续工作学习安排，还tmd被狗日的zxy抢了一作 3. 整个互联网的大环境在变差，竞争更加激烈，十分担心自己忍受不了这种高压残酷的工作环境，而且算法岗更加惨烈，也没什么出彩的简历，也不知道将来到底要干啥工作 4. 浙大的哥们也和我每天吐槽都是负能量爆棚的事情，日常看不到积极的因素 5. 西交的这帮傻逼们（从学校到学院再到老师同学）为什么都这么奇葩呢？我觉得自己现在也跟傻逼一样... 6. 要自学的东西太多了，算法题也做不出来，项目也进展不动，论文也看不进去，被湮没了 7. 想要做手术但是不知道有没有时间和陪我的人，还要花钱，这手术tmd还相当尴尬... 8. 想抓紧时间找个npy去make love，释放下欲望，一直tmd没有进展，也不知道要不要等赵欣考完研再去表白 9. 回家了几次，发现tmd农民真的太可怜了，干着最贱的活拿着最少的钱，zf不知道咋搞的。而且一出生条件就比别人差，以后买房娶妻啥的都很社会很残酷，当然我并没有埋怨父母，我父母都很伟大 10. 自己也不会social，平时能深入交流的朋友也很少，整的都快孤僻了 11. 天气边变冷了，最近也很少运动了，可能也有影响吧 12. 性格也比较弱势，还是说佛系，总之在涉及利益的事情上不够上进，不够自私，因此也经常吃亏吧，这样估计工作了就是背锅侠（只知道闷头干活，却忘了漂亮地展示自己和斗争取得属于自己的利益）...但是也不知道是好是坏 13. 表达沟通能力也比较欠缺（面对面时也说不清楚事情），容易紧张，面试肯定吃亏，屁大点事都会睡不着觉 14. 脸上不知道咋回事长了一堆痘，很长时间也下不去，烦啊 15. 还有二战的一年还不知道找工作影响咋样，怎么解释呢</p><p>尽量不要想着回宿舍学习，尤其是在实验室晚上比较累的时候，可以听会歌放松一下，然后继续在实验室学习</p><p>不想过得太累，那就索性不要有什么压力，该做什么就做什么，随缘随喜好</p><p>做梦装逼： 尘埃落定，要去Google Singapore啦！ 感谢晨光和Google Sydney修唯学长的内推，感谢胡神、聪爷、经纬哥和晨光不厌其烦的mock，当然还有佳薇姐精心的coordinate~ 坦白说，在西交的这几年过得不怎么开心，个中滋味，只有自己清楚，也希望换个环境会有所改善吧~ 坡县见啦~</p><p>如果长时间艳羡别人的生活，我指的不是真心祝福交流，而是向往，想去往那里，这是一个危险的信号。这意味着你对自己的生活状态很不满意，意味着焦虑不安，意味着对自己的目标产生了怀疑，这时候就要停下来认真思考：yes or no 如果no那么就要重新确定目标，否则就完全没必要走入羡慕他人的状态，因为你坚信自己做的事情是内心真正想要的，对自己的目前生活状态就会保持自信，还有什么比追求内心更加美妙的事情吗？ 那么我呢？我并不怀疑自己的目标，因此应当对自己目前的状况感到自信，我正在攀登！</p><p>努力学习，冲！</p><p>还是有进步的，以前老想着完成任务，将自己的简历变丰富。现在更注重培养自身对于课程内容的思考，更关注自己的创造性工作或者自己亲手的实现，更关注自己的理解见解。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Wilcoxon signed-rank test</title>
      <link href="/2021/11/23/Wilcoxon%20signed-rank%20test/"/>
      <url>/2021/11/23/Wilcoxon%20signed-rank%20test/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>Wilcoxon符号秩检验是一种非参数检验方法（总体没有高斯分布），t检验貌似要数据服从高斯分布。</p><p>具体是这么操作的： 假如有两组数据<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>需要检验对比：<span class="math inline">\((X_i,Y_i)\)</span>首先被转为差值<span class="math inline">\(X_i-Y_i\)</span>，记为<span class="math inline">\(Z_i\)</span>，假设<span class="math inline">\(Z_i\neq 0\)</span>且绝对值均不等： 1. 计算<span class="math inline">\(|Z_i|\)</span> 2. 将<span class="math inline">\(|Z_i|\)</span>排序得排序后的索引<span class="math inline">\(R_i\)</span> 3. 检验统计量<span class="math inline">\(T=\sum sgn(Z_i)R_i\)</span> 4. 通过对比<span class="math inline">\(T\)</span>和原假设下的分布求出p值</p><p>如果存在<span class="math inline">\(Z_i=0\)</span>，有几种处理方法： 1. <code>zero_method="wilcox"</code>：忽略所有等于0的数据 2. <code>zero_method="pratt"</code>：排序时考虑为0的项，排完后扔掉这些0项的秩 3. <code>zero_method="zsplit"</code>：</p><h2 id="refs">Refs</h2><p><a href="https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test">Wilcoxon signed-rank test</a> <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wilcoxon.html">scipy.stats.wilcoxon</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CS144 Lab</title>
      <link href="/2021/11/12/CS144%20Lab/"/>
      <url>/2021/11/12/CS144%20Lab/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cs144.github.io/">Introduction to Computer Networking</a>是Stanford的网络课，据说lab质量很高，就把它作为转System后的第一个小系统吧！</p><h2 id="准备工作">准备工作</h2><p>Stanford大气！能让我们这些野鸡学校的同学接触到最顶级的教育资源，甚至开放了lab，也希望大伙不要把题解po到github上！</p><p>因此我做的是Fall 2021的版本，所有的starter code都在<a href="https://github.com/CS144/sponge">这里</a>。</p><p>至于如何在自己的github上备份代码，参考<a href="https://stackoverflow.com/questions/10065526/github-how-to-make-a-fork-of-public-repository-private">这里</a>。</p><p>虚拟机平台用的是VirtualBox，144官方提供了基于Ubuntu的系统镜像，CPU和RAM随便设。</p><p>大致按照<a href="https://stanford.edu/class/cs144/vm_howto/">官方文档</a>配置环境，windows环境可以用powershell，无需<a href="https://putty.org/">Putty</a>。 开启虚拟机，通过ssh client建立TCP连接到远程主机的某端口：<code>ssh user@remote -p port</code>，<code>user</code>是在远程主机的用户名，<code>remote</code>是远程机器的地址（IP/域名），<code>port</code>是ssh server监听的端口，默认22（即登录请求会送进远程主机的22端口），上面通过-p参数改变了该端口。</p><p>不过遇到了点问题： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211103183846716-1107297673.png" alt="image" /> 奇怪！远程虚拟机明明安装了ssh服务!</p><p>从主机去ping虚拟机超时，但是虚拟机可以ping通主机，参考<a href="https://www.cnblogs.com/mengjie88/p/11803879.html">这个设置</a>成功ping通，后来发现国内的这些blog都是在胡说八道，真正的原因和解决方案在<a href="https://unix.stackexchange.com/questions/145997/trying-to-ssh-to-local-vm-ubuntu-with-putty">这里</a>，本质上是虚拟机的端口转发没设置好，设置好后VB会把连接localhost:2222的TCP请求转发到虚拟机的22号端口。</p><p>关于IDE，开始用的VIM，后来想用vscode，Host上安装vscode以及remote-ssh插件，关于配置网上一大堆教程，自行学习吧，powershell以后就负责编译运行了。</p><h2 id="lab-0">Lab 0</h2><h3 id="networking-by-hand">Networking by hand</h3><p>这些小游戏都是为了翻译翻译：什么是可靠的双向字节流，网络通过这种抽象完成许多重要的交互，如上网冲浪、发邮件等。</p><p>第一个事是要手动模拟浏览器的请求过程（注意手速，不然还没输完就408 Timeout了）： 1. <code>telnet cs144.keithw.org http</code>：<code>telnet</code>作为一种client程序，负责和服务器的某个服务建立连接。用telnet客户端程序在本机和服务器之间开一个可靠的字节流，并请求服务器的http服务（80端口），连接成功证明端口可用 2. 建立连接后就要通过HTTP协议请求内容：需要告诉服务器所请求URL的path和host：<code>GET /hello HTTP/1.1</code> <code>Host: cs144.keithw.org</code>，不过为啥需要host呢？难道服务器不知道自己的ip吗，好像是因为服务器可以同时运行多个网站/服务 3. <code>Connection: close</code>：表示希望服务器一旦完成响应，就关闭连接 4. 输入回车（空行）：表示HTTP请求头结束，接下来是请求数据（当然GET没有，POST有）</p><p>其实这就是一个HTTP请求报文，效果： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211104155702139-1679706369.png" alt="image" /> 作业就是瞎玩： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211104215913218-403717095.png" alt="image" /></p><p>第二个事是学着发邮件，请求服务器的SMTP服务（主要用来发邮件），我试试和自己的邮箱互动下： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211106090516675-391035638.png" alt="image" /> 这里要注意：首先要开启IMAP/SMTP服务，还需要获取第三方客户端登录的授权码，登录时邮箱名称和授权码都需要Base64格式。</p><p>文档里说From地址是可以伪造的，有点神奇，垃圾邮件可能挺喜欢干这事！但是我实际操作时是伪造不了的： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211106091008967-598610443.png" alt="image" /> 因为已经登录了本人账户，所以发件人必须一致，Stanford那个没有登录，也许是商业邮件系统一般都比较完善？</p><p>第三个事是作为服务器去监听，主要使用所谓的瑞士军刀netcat： <code>netcat -v -l -p 9090</code>：-v表示显示执行命令过程，-l表示开启监听，-p表示在指定端口监听 <code>telnet localhost 9090</code>： 然后服务器（netcat）和客户端（telnet）就可以通信啦！</p><h3 id="network-program-using-an-os-stream-socket">Network program using an OS stream socket</h3><p>这部分让同志们利用操作系统内核提供的stream socket从Internet上抓网页，和上文中手动抓差不多，不过这次是把手动过程写成代码。</p><p>由于Internet只能提供尽最大努力交付的数据报服务，因此这些数据报可能会：丢失、乱序、内容更改、重复，所以通常OS会把Internet的这种抽象转为可靠的双向字节流，以便应用层软件使用。OS一般使用socket来完成这种转变并向程序员提供接口，socket和文件描述符类似，一旦建立连接就能进行可靠的通信。后续会自己实现一个TCP去揣摩这种转变。</p><p>这个简单的web client程序有几个要注意的地方： 1. 由于<code>connection: close</code>，因此服务器只会处理一次http请求 2. 服务器响应后就会关闭从server到client的socket连接，但是client的<code>socket.read()</code>可以持续读：If the connection is broken on a stream socket, but data is available, then the read() function reads the data and gives no error. If the connection is broken on a stream socket, but no data is available, then the read() function returns 0 bytes as EOF. 3. EOF一般是一个定义为-1的宏，因此没有对应的ASCII字符，因此也无法显示出来（可以强制转int），C语言将其定义在某个头文件的宏里（可以直接用EOF判断），C++一般使用函数判断。EOF的作用就是client可以判断是否读完了server发来的响应，终端输入windows环境是ctrl+Z，linux是ctrl+D 4. 为什么一个<code>read()</code>不够呢？因为<code>read()</code>是有limit的，超过上限就得多次读，<code>std:string FileDescriptor::read(const size_t limit=std::numeric_limits&lt;size_t&gt;::max())</code> 5. 及时关掉socket的写功能是一个<a href="https://stackoverflow.com/questions/4160347/close-vs-shutdown-socket">好习惯</a></p><figure><img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211207143452338-2049325007.png" alt="" /><figcaption>image</figcaption></figure><h3 id="an-in-memory-reliable-byte-stream">An in-memory reliable byte stream</h3><p>在单机上实现一个可靠的字节流（内存里当然是可靠的），writer可以结束字节流输入，reader读到EOF后就无法继续读。 基本可以理解为一个容量为<code>capacity</code>的buffer，<code>capacity</code>用来进行流量控制，文档说了只会进行单线程操作，因此不用担心并发的读/写。 需要注意：流本身可以无限长，<code>capacity</code>存储的是已经写入但还未读取的字节，哪怕<code>capacity = 1</code>，只要writer每次写入一个字节，reader读走，这个流就可以无限长。</p><p>开始想用<code>queue</code>，但是<code>queue</code>无法支持<code>peek_output</code>操作，那就用<code>deque</code>了。 <code>size_t write(const std::string &amp;data)</code>：如果长度大于<code>capacity</code>该如何处理？这种情况多余的写入只能被丢弃，就和网络上超出线路容量的写入被丢弃一样。 <code>size_t bytes_read() const</code>返回的是所有pop的字节数目，包括<code>read(const size_t len)</code>和<code>pop_output(const size_t len)</code>。 <code>bool input_ended() const</code>返回流输入是否结束；<code>bool eof() const</code>是reader判断是否读取到了流输出的结束位置，因此必须满足writer已经有过写入且buffer为空。</p><p>记得先<code>make format</code>，再<code>make</code>编译，最后<code>make check_lab0</code>自动化测试。</p><h2 id="lab-1">Lab 1</h2><p>接下来的4个lab要自行实现一个TCP，模块如下： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211207210801604-1226780700.png" alt="image" /></p><p>由于sender会将发送的字节流分割为若干segments，每段不超过1460B，封装为数据报交给网络传送，但这些segments可能会乱序、丢失、重复、交叉重叠、长度不一，但是不会出现inconsistent的段，因此Lab 1要实现一个流重组器，将收到的字节流中的segments拼接还原为其原本正确的顺序。</p><p><code>StreamReassembler</code>会用一个可靠字节流<code>ByteStream</code>作为输出：as soon as the reassembler knows the next byte of the stream, it will write it into the <code>ByteStream</code>. 接着应用层就可以从<code>ByteStream</code>读取有序的字节流。<code>StreamReassembler</code>和<code>ByteStream</code>的容量大小是一样的，不过<code>ByteStream</code>真正的size（绿色部分）是动态变化的。</p><p><code>push_substring(const string &amp;data, const uint64_t index, const bool eof)</code>一旦超出<code>StreamReassembler</code>的容量，就只能丢弃该碎片（或者丢弃部分）； <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211118103108010-1947303917.png" alt="image" /> 根据上图：可以想象为我们拥有一条index从0开始的无限长的字节流，每个段都有自己在流中的位置，随着应用层读取流中的数据，<code>StreamReassembler</code>就像一个滑动的窗口，落在该窗口内的段都需要被按序组装。</p><p>显然，需要用某种数据结构把不能直接写入<code>ByteStream</code>中的segments存起来：<strong>data+index</strong>即可唯一确定，因此单个segment可以用类、结构体或<code>std::pair</code>存储，为了方便起见，在segment结构体中增加成员变量<code>len</code>来指示其有效长度。 由于可能需要根据index快速查找合并位置，因此最好按序存储，并且自动去重，所有不能写入的segments可以用<code>std::set</code>来存，底层基于红黑树实现。</p><p>处理逻辑： 1. 新来段是否超出/部分超出了<code>StreamReassembler</code>的窗宽，如超过则进行剪切； 2. 新来段是否和<code>ByteStream</code>之前（蓝色+绿色部分）有重叠，如有则切除重叠部分； 3. 合并新段和暂存段：确定新段插入位置，不断将其前后的暂存段往新段上合并，直到找不到可以继续合并的暂存段； 4. 判断能否写入<code>ByteStream</code>； 5. <strong>处理后</strong>新段的eof为true：<del>若暂存区为空，结束向<code>ByteStream</code>的写入</del>结束写入的时机可能会导致潜在bug，后面有血泪教训；若暂存区非空，<del>报错</del>，可能是last segment先到达但还不能写入，因此存入暂存区。</p><p>根据上述逻辑准备用3个函数完成： 1. <code>void _cut_overlap(segment &amp;seg);</code>完成12 2. <code>void _merge_segs(segment &amp;seg);</code>完成3 3. <code>void _write_to_stream();</code>完成4 4. 直接在<code>push_substring()</code>处理5</p><p>这个实验一般就会开始出bug，我直接跪在了corner case，来了一个eof为<code>true</code>的<code>""</code>，空串是要被忽略的，但是这个空串带了我们需要的eof信息，由于在<code>_cut_overlap</code>直接返回： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (seg.index &gt;= _first_unacceptable || seg.index + seg.len &lt;= _first_unassembled) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure> 所以没有正确设置<code>_eof</code>： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211211135443937-770319647.png" alt="image" /> 测试样例<code>t_strm_reassem_single</code>报错，所有的测试源码都在<code>./tests</code>文件夹下，对应的可执行程序在<code>./build/tests</code>。 <code>sudo apt-get install gdb</code>安装GDB，找到对应的测试源码文件<code>fsm_stream_reassembler_single.cc</code>打断点开始调试，跳出<code>launch.json</code>稍作修改就可以愉快地debug（面向测试编程😂）了： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;sponge debug&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/tests/$&#123;fileBasenameNoExtension&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: g++-8 build active file&quot;,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后来第7个样例一直过不了，而且Byte Stream实际读取的字节数和真实值差距很大： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211212162034900-680357364.png" alt="image" /></p><p>怀疑是提前<code>end_input()</code>了，主要是下面这种case： first unassembled=7且first unacceptable很大，先来一个<code>index=9, eof=true</code>的""，再来一个<code>index=7, eof=false</code>的"ab"，如果这样判断： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_eof &amp;&amp; _unassembled_bytes == <span class="number">0</span>) &#123;</span><br><span class="line">    _output.<span class="built_in">end_input</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 很容易在第一个段就<code>end_input()</code>导致提前结束写入。 因此核心问题在于什么时候调用<code>end_input()</code>，我用了<code>_eof_index</code>来指示结束的位置而非用布尔变量<code>_eof</code>，一旦<code>_first_unassembled &gt;= _eof_index</code>就结束输入。 ## Lab 2 Lab 2要实现<code>TCPReceiver</code>，将从Internet接收的segments送入<code>StreamReassembler</code>转为可靠的<code>ByteStream</code>，以供应用层从socket读取。 除此之外，<code>TCPReceiver</code>还要负责和sender反馈：1. first unassembled字节的index，也叫做确认号<strong>acknowledgment</strong>，这样sender才知道下次该发送啥；2. first unassembled和first unacceptable之间的窗宽window size，用来告诉sender允许发送的字节范围。两者结合形成滑动窗口用来进行<strong>flow control</strong>。</p><p>第一件必须要处理的事就是序列号sequence number的转换：在<code>StreamReassembler</code>中我们用的是64位的stream index，因此不太可能溢出，但是TCP header空间宝贵，所以第一个字节的index采用32位的seqno，这样就带来几个问题： 1. stream index可以近似于无限大，但是seqno只能从<span class="math inline">\(0\sim2^{32}-1\)</span>不断循环； 2. 为了安全起见，seqno并不是从0开始，而是取一个随机数Initial Sequence Number(ISN)来表示stream的开始SYN(beginning of stream)； 3. TCP header中的SYN和FIN(end of stream)标志位都要被分配seqno，但是SYN和FIN并不是真正的数据，只是表示流的开始和结束。</p><figure><img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211216213718402-1668481893.png" alt="" /><figcaption>image</figcaption></figure><table><thead><tr class="header"><th>isn</th><th>isn+1</th><th>isn+2</th><th>...</th><th>2^32-2</th><th>2^32-1</th><th>0</th><th>1</th><th>...</th><th>isn-2</th><th>isn-1</th></tr></thead><tbody><tr class="odd"><td>0</td><td>1</td><td>2</td><td>...</td><td></td><td></td><td></td><td></td><td></td><td>2^32-2</td><td>2^32-1</td></tr><tr class="even"><td>2^32</td><td>2^32+1</td><td>2^32+2</td><td>...</td><td></td><td></td><td></td><td></td><td></td><td>2^33-2</td><td>2^33-1</td></tr><tr class="odd"><td>NaN</td><td>0</td><td>1</td><td>...</td><td>first unassemble</td><td>...</td><td></td><td>first unacceptable</td><td></td><td>2^32-3</td><td>2^32-2</td></tr><tr class="even"><td>2^32-1</td><td>2^32</td><td>2^32+1</td><td>...</td><td></td><td></td><td></td><td></td><td></td><td>2^33-3</td><td>2^33-2</td></tr></tbody></table><p>第一行是32位的seqno，可以想象成在圆环上走路（正反走均可），二三行是64位的absolute seqno，四五行是64位的stream index。</p><p>absolute seqno转seqno：<span class="math inline">\(isn+n\%2^{32}\)</span>，<span class="math inline">\(n\)</span>直接强制类型转换即可截取低32位。 seqno转absolute seqno：有点麻烦，可能对应多个结果，因此选择距离<code>checkpoint</code>最近的那个结果，<code>checkpoint</code>取前一次所收段的absolute seqno。原因在于两个前后到达的段absolute seqno的差值几乎不可能超过<span class="math inline">\(2^{32}\)</span>。有个corner case是当<code>checkpoint</code>比较小时计算得到的absolute seqno可能小于0，需要加上<span class="math inline">\(2^{32}\)</span>即<a href="https://stackoverflow.com/questions/4201301/warning-left-shift-count-width-of-type"><code>1UL&lt;&lt;32</code></a>。</p><p>做好索引的转换后，因为麻烦的部分已经在Lab 1完成了，剩下的就是根据<code>TCPSegment</code>写一些业务逻辑。 <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211217214005787-1024116698.png" alt="image" /> 注意下SYN和FIN对ackno的处理就行： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211217214722866-2056520012.png" alt="image" /> ## Lab 3 这次的活是TCP Sender，负责将应用层的ByteStream分割为段发送，根据接收方的反馈情况进行超时重传。</p><p>每次收到接收方的ACK就可以知道其window size, 发送方在每次收到ACK时更新窗宽，并且在下一次收到ACK前，根据发送情况记录窗口的剩余容量，决定是否继续发送。 只要<code>_stream</code>还有需要发送的内容并且receiver还有空闲空间，<code>fill_window</code>就要一直组装成段并发送直到填满该窗口，receiver真正的free space应该是其声明的窗宽减去已发送但未被确认的所有段的长度总和，这个free space才是可以不断继续组装新段并发送时可以利用的，在<code>fill_window</code>组装新段之前要check该空间是否大于0。</p><p>另外，发送的第一个段是SYN段，没有数据，只有SYN和initial sequence number，SYN段发完后就返回等待receiver的connection granted，即第一次握手，此时窗宽看作1： &gt; What should my TCPSender assume as the receiver's window size before I've gotten an ACK from the receiver? One byte.</p><p>并且在TCP Header中SYN和FIN不能同时为1，否则应该报错RST，FIN段是可以携带数据的。</p><p>如果收到ack表明窗口大小为0，在<code>fill_window</code>当作1处理，但是超时的段不应double RTO，因为这是receiver的原因而非线路流量限制导致的，但是SYN段超时需要double RTO并增加重传counter，以便判断是否终止本次连接请求。</p><p>FIN段的处理需要仔细一些： 如果<code>_stream.read</code>以后<code>_stream.eof()</code>意味着ByteStream已经没有需要发送的东西了，这时就要考虑设置FIN的问题了，但是FIN是要占序列号的，也就意味着要在接收方的window里占空间，如果free space为50最后一段的payload size为30，那可以设置FIN；如果free space为50最后一段的payload size为51，那么最后一个字节就需要进行下一次发送，并且在下一次考虑FIN的设置问题；如果free space为50最后一段的payload size也为50，那么这段数据可以发送，但是这次没法设置FIN了，也就只能等到接收方腾出空间后才能继续。因此只有free space严格大于最后一段的payload size才可以设置FIN。</p><p><code>fill_window</code>有一种情况，free space还有但是<code>_stream.buffer_empty()</code>已经空了，但是只是数据发完了，FIN标志还没发，就需要再发一个段，因此这样写是不行的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!_stream.<span class="built_in">buffer_empty</span>() &amp;&amp; _receiver_free_space) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211224201911692-472858794.png" alt="image" /></p><p>可以直接多循环一次然后用segment的<code>length_in_sequence</code>判断流是否真的空了以及是否要继续发送： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (_receiver_free_space) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> payload_size =</span><br><span class="line">        <span class="built_in">min</span>(&#123;_stream.<span class="built_in">buffer_size</span>(), <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(_receiver_free_space),</span><br><span class="line">             TCPConfig::MAX_PAYLOAD_SIZE&#125;);</span><br><span class="line">    TCPSegment seg;</span><br><span class="line">    <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(_receiver_free_space) &gt; payload_size) &#123;</span><br><span class="line">        seg.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">        _fin = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(_stream.<span class="built_in">read</span>(payload_size));</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    _send_segment(seg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 但是这样可能导致一直发送只包含FIN的段，因此要在while循环限定<code>_fin</code>来确保只发一次FIN段。</p><p>关于重传，闲来无事，把重传计时器单独写一个类，因为这个类相对比较简单，所以就和sender放在同一个头文件吧，不过据说有些公司的coding guideline有规定： &gt; Each class shall have it's own header and implementation file.</p><p>采用累计确认：如果发送方收到ackno代表之前的所有段都正常接收，因此用<code>std::queue</code>存没有收到ack的段（包括只被ack了一部分的段），超时后从队头开始传。 <code>_segments_outstanding</code>发送时在<code>std::queue</code>里是按照seqno有序的，只有每次收到ack才从<code>std::queue</code>里扔掉一些已经被完全确认收到的段，否则认为<code>std::queue</code>里的所有段接收方均未收到。</p><p>收到ack并清理完<code>_segments_outstanding</code>后，如果此时还有未被确认的段，重启计时器并将RTO和重传counter恢复初始值。 注意收到的ack可能是非法的，比如ack了一个还没有发送的段或者ack了已经收到的段的序列号 还有一个corner case在<code>send_extra.cc</code>的95行，如果收到了与上次相同的ack，计时器是不应该重启的，重传时只有收到的ackno严格大于上一次的ackno才重启。</p><p>计时器的启动可以参考课本： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211222163312884-1740072168.png" alt="image" /></p><h2 id="lab-4">Lab 4</h2><p>第一次在项目中体会到测试的重要性，也有点理解TDD的好处了，好的测试不仅能够发现问题，还能根据测试样例debug，再次跪谢Stanford~</p><figure><img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211225200758037-1347511939.png" alt="" /><figcaption>image</figcaption></figure><p>TCPConnection既充当接收者，也充当发送者，可以理解为实现以后就可以在你自己的主机上使用，接收别人的消息，发送自己的消息。</p><p>tick这里如果超过最大重传次数，不仅需要关闭连接，还要给peer发送带有RST的段：如果_sender的segments_out()不空，直接将队头的段设为RST，否则调用send_empty_segment()设置RST</p><p>比较抽象的是TCP的关闭这部分：</p><p>初步写完代码后，就对着测试样例疯狂调bug吧！！</p><p>遇到的第一个corner case是空ACK段（比如第3次握手），由于Lab3的sender只关注ackno和win，通过要发送的seg的length_in_sequence判断是否继续发送，第二次握手收到一个peyload=0的段，以后正常交流是不会这样的，因此第三次握手应该回一个段（可带可不带数据），但是Lab3的fill window遇到这种情况会直接返回，不会发送，我们在这里发送一个空ACK段作为第三次握手。</p><p>发送空的ACK段有以下情况： 1. 第3次握手可能发空的，也可能携带数据 2. 第2次挥手 3. 第4次挥手 4. keep alive</p><p>即只要收到了length_in_sequence&gt;0的段都需要发ack，如果sender要发数据那可以顺便携带ack，否则就要发空ACK</p><p>有时候打断点会瞎跳，据说是编译优化的问题， <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104111823209-669239914.png" alt="image" /> <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104113021977-665516588.png" alt="image" /></p><p>还有syn的处理需要考虑作为接收方和发送方两种情况分别处理</p><p><code>txrx.sh</code>的测试不好过</p><p>调单个测试用例ctest -R test_name <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104161235764-1555046156.png" alt="image" /></p><p>建议按照状态机来写，否则会被细节折磨死。 <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104180142069-201294829.png" alt="image" /></p><p>神呀！104-160一直过不了，无奈只能通过替换网上的模块找bug <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104213010425-1104108783.png" alt="image" /> 但是lab0-4全部替换仍然是那个bug，不知道哪里有问题。。。严重怀疑由于服务器在美国的原因</p><figure><img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104220146252-1499569230.png" alt="" /><figcaption>image</figcaption></figure><p>折腾vmware，自己配环境，G++注意设好后https://blog.csdn.net/kenkao/article/details/89550641?utm_medium=distribute.pc_relevant.none-task-blog-2<sub>default</sub>baidujs_title~default-4.no_search_link&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7</p><p>还要修改https://www.cnblogs.com/minglee/p/9016306.html <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220105233420579-412125300.png" alt="image" /> 接着就可以正常make和测试了。 换到VMware没有任何改动一次性通过了所有测试： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220105234831224-1290189010.png" alt="image" /></p><p>有点离谱...第一次遇到系统级别的Bug，卡了三天，全部模块替换为别人的还是挂... ## Lab 5 实现IP/Ethernet网络接口，也叫网络适配器/网卡，</p><p>只要ARP表没找到，说明需要学习目标MAC地址，因此发送的IP数据报均需要缓存。</p><p>不论是ARP请求还是回复，都需要学习ARP表，如果是请求，还要发送ARP响应。 VMware可以过，VB还是挂 <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108112730514-116878135.png" alt="image" /></p><h2 id="lab-6">Lab 6</h2><p>这个实验要基于Lab 5的<code>NetworkInterface</code>实现一个IP路由器，负责将接收到的数据报根据路由表转发：从哪个网络接口转发以及下一跳的IP地址。 我们只负责根据生成的路由表转发，至于如何生成路由表（RIP/OSPF/BGP）无需关心。 <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220111214607248-1624579305.png" alt="image" /></p><p>第一个函数<code>void add_route(const uint32_t route_prefix, const uint8_t prefix_length, const optional&lt;address&gt; next_hop, const size_t interface_num);</code>负责保存每条路由信息以备后续使用。 <code>route_prefix</code>和<code>prefix_length</code>共同确定一个网段，比如<code>18.47.0.0/16</code>的<code>route_prefix=18*2^24+47*2^16,prefix_length=16</code>，如果一个数据报的目的IP是<code>18.47.x.y</code>那么该条路由即匹配。</p><p>如果路由器直接目的网段，路由信息的<code>next_hop</code>为空，直接通过<code>NetworkInterface</code>发送到目的IP；如果路由器通过其它路由器连接到目的网段，路由信息的<code>next_hop</code>为下一个路由器的IP。</p><p>第二个函数<code>void route_one_datagram(InternetDatagram &amp;dgram);</code>通过最长前缀匹配找到最佳路由，如果没有匹配的路由则丢弃数据报，如果该数据包的<span class="math inline">\(TTL\leq 1\)</span>也丢弃，否则通过最佳路由对应的<code>NetworkInterface</code>转发。</p><p>这里的abstraction在于路由器只需要关心IP数据报而无需关心链路层实现细节，只是通过<code>NetworkInterface</code>与链路层交互。</p><h2 id="lab-7">Lab 7</h2><p>到此为止，实现了Internet的传输层TCP协议、网络层和链路层之间的接口转换以及路由转发。 这个实验让我们用实现的这些组件和另一个人交互： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220111154943808-1022957497.png" alt="image" /></p><p>由于学校局域网内的IP都是私网地址（10.0.0.0/8，172.16.0.0/12，192.168.0.0/16），为了交互，需要通过<a href="https://www.zhihu.com/question/31332694">NAT技术</a>映射到公网IP，所以使用了<code>cs144.keithw.org/104.196.238.229</code>作为中继服务器。 <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220111155822569-889084045.png" alt="image" /></p><p>按照文档交互： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108170606232-1565549109.png" alt="image" /> <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108170639108-1941733275.png" alt="image" /></p><p>任意一方按<code>ctrl+D</code>单方向关闭连接后，就不能继续发送数据，但仍可以继续接收直到peer也关闭连接。双方都关闭后，任意一方完成了lingering之后连接才真正关闭。</p><p>除了聊天，还可以收发文件。</p><p>通关截图： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108170828819-1433823727.png" alt="image" /></p><h2 id="refs">Refs</h2><a href="https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html">【计算机网络】Stanford CS144 Lab Assignments 学习笔记</a> <a href="http://yuzijun.life/2021-02/CS144">斯坦福计网实验 / CS144 Lab Assignments</a> <a href="https://kiprey.github.io/2021/11/cs144-lab0/">CS144计算机网络</a></address><p></size_t></size_t></size_t></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重新思考机器学习及职业方向选择</title>
      <link href="/2021/11/01/%E9%87%8D%E6%96%B0%E6%80%9D%E8%80%83%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%8A%E8%81%8C%E4%B8%9A%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/"/>
      <url>/2021/11/01/%E9%87%8D%E6%96%B0%E6%80%9D%E8%80%83%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%8A%E8%81%8C%E4%B8%9A%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p>最近参加了一个<a href="https://datafountain.cn/competitions/537/">AI比赛</a>，引起了我对机器学习以及自己未来职业方向的重新思索，我发现自己现在做决定更加在乎自身的兴趣而非舆论等其他因素，也算是一种进步了吧！</p><p>比赛的过程我很难享受编程带来的乐趣，只有在看到AUC指标提升零点几个百分点时才会有一丝丝成就感，而在数据清洗、特征构建、魔改模型以及无脑调参这种占据算法工程师大量时间的环节感受到的只有繁琐和无聊，这不禁让我反思自己半年前的选择：如果将来步入互联网，到底是选择算法岗还是开发岗呢？</p><p>从世俗的角度来看，算法岗毫无疑问有着更高的薪资甚至更光明的前途，我也坚信机器学习会持续改变人类生活并且在未来应用到方方面面，但是需要多久时间可能谁也说不准。</p><p>从现阶段来看，AI的发展尤其是落地遇到了很多困难，突然想起了《智能计算》韩德强老师上课时指出的数据驱动的方法终究很难解释问题的本质，我当时嗤之以鼻，现在有些许赞同了。</p><p>从自身喜好来讲，对于不确定的东西我向来不太喜欢，然而机器学习领域充斥着大量的不确定性，大多数模型缺乏可解释性，我在操纵灰盒甚至黑盒的过程中祈求获得指标的提升，在出现bug时不好排查。除此之外，现实世界的数据大多数是杂乱繁琐的，需要花费80%以上的时间去清洗数据、构建特征，这也不是我喜欢做的事情。相对而言，我更加欣赏自己能做出来一个确定的、完整的系统呈现在眼前，它可以解决现实生活中的某个问题，并且可以重复使用（可复现），所以我决定学习重心重新回到开发岗位，当然如果时间充裕可以去算法岗实习看看再做最终的决定。</p><p>还有就是胡神的很多思考对我触动很深。</p><p>我想好啦，做system！当然我肯定会把当前分内的事情做好、该学的学懂！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>屠龙少年 遍体鳞伤</title>
      <link href="/2021/10/24/%E5%B1%A0%E9%BE%99%E5%B0%91%E5%B9%B4%20%E9%81%8D%E4%BD%93%E9%B3%9E%E4%BC%A4/"/>
      <url>/2021/10/24/%E5%B1%A0%E9%BE%99%E5%B0%91%E5%B9%B4%20%E9%81%8D%E4%BD%93%E9%B3%9E%E4%BC%A4/</url>
      
        <content type="html"><![CDATA[<p>与恶龙斗，其乐无穷！少年怀揣利剑，不顾生死与恶龙搏斗，听起来热血沸腾，可是大多时候总是遍体鳞伤，甚至性命不保！</p><p>有感于最近奖学金评定以及与实验室老师之间的一些“趣事”，我想仔细思考下面几个问题： 1. 个人对于体制的反抗究竟是否值得 2. 以后采取什么样的行为完成从学生到社畜的转变</p><p>我相信大家从小到大，周围一定会有这种人：面对与自己利益相关的事情十分敏感，对于自身的获益锱铢必较，一丝一毫也不能退让。在学生时代，体现最为明显的就是评奖评优的加分机制：参加了某类活动的一群人总是会形成一个微妙的利益共同体，这个圈子看似脆弱隐形，但为了该类活动的加分却能爆发出惊人的一致性，与规则制定者们、其他活动利益共同体等圈子展开激烈的撕逼，毕竟每个圈子都有自己的代表利益：规则制定者向上负责，学院为了拍学部的马屁将歌唱比赛等的加分设置的和科研同样高，美其名曰培养学生的团队精神；歌唱比赛圈子自然全力支持，走方阵圈子此时不满意了：我们也是集体活动，我们也要加分！班干部圈子也不满意了：为啥它们加那么多，我们也要加这么多！</p><p>就这样，错综复杂的扯皮会持续到评定结束，所有圈子在撕逼中达到了利益的相对平衡，弱势圈子甚至不发声圈子自然是吃亏大户，闹得越欢的圈子自然会多分一杯羹，正应了那句老话：会哭的孩子有奶吃。</p><p>我作为不发声圈子的一员，默默吃瓜之余，也会为自己的利益损失感到疑惑，老实人就活该吃亏吗？</p><p>回顾自己的求学生涯，我一直有着比较严重的逆反心理，对于各种评定规则嗤之以鼻。高中以前事情并不复杂，只看学习成绩，赢者通吃，我又在那种评价体系下表现得不错，因此并无太多怨念。本科以及烟酒生期间，不论是出于佛系还是不屑抑或是对于规则制度的反叛，我对这些事情也撕逼甚少，结果就是少生很多气，但是利益损失也相当大，甚至以后会充当背锅侠。</p><p>在这种弱肉强食的环境下，总有那么一群人，可以在这些特殊的规则下左右逢源，最终达到自身的利益最大化，我相信在社会上这些只会变得更加严重。</p><p>现在我先来尝试回答第一个问题：与这些制度规则以及利益共同体的斗争是否值得，即心理层面的问题。我做出如下考虑： - 核心思想在于：分清楚社交边界，对于界内的朋友事情当然可以像从前一样无欲无求、佛系处理；对于界外的人群事情再也不能像以前那样无原则忍让，在保护好自身的前提下：要坚定地捍卫自己的利益，我们不能总是让老实人吃亏。因此斗争是必要的，但是要分清斗争的敌友中间派（此时觉得毛选一定要读）。 - 那么关键问题在于：如何分清敌友中间派？这个需要敏锐的观察和深入的沟通，甚至有时候还要被捅刀才能识人。举个例子：我研一时候觉得自己可以和实验室小老板做朋友，但是人心隔肚皮，被捅刀子之后才彻底认清她的丑恶嘴脸，也打消了我的幻想：工人和资本家永远不可能做朋友，但是我依然坚信不是所有的老师都是这个鬼样子： <img src="https://img2020.cnblogs.com/blog/1260581/202110/1260581-20211024124309130-337350262.png" alt="image" /> - 对于友：要互帮互助，积极联络，共度难关 - 对于中间派：要谨言慎行，有利益需求时互相利用，切记不要透露真心 - 对于敌：要坚决放弃幼稚的幻想、采用智慧的策略坚决斗争，坚定维护自身以及朋友的利益，坚决拒绝不合理的要求！</p><p>明确心理层面的处理后，再来看看行为层面的处理： - 核心要义在于：用魔法打败魔法！将自身和朋友利益放在首位！ - 关键问题在于：如何拥有更加高超的魔法？首先根据自身的目标不断壮大实力，须知枪杆子里出政权；此外，除了闷头干活，还要会表难点表功。两点结合起来也就是所谓的软硬实力。 - 硬实力：别无他法，选择以后刻苦再刻苦 - 软实力：平时要学会和友、中间派、敌的说话策略，该交心交心、该阳奉阴违就阳奉阴违、该果断拒绝就拒绝</p><p>总之，屠龙少年即使遍体鳞伤也不会终成恶龙！只是会采取更加巧妙的方式继续自己的斗争！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>笔试合辑</title>
      <link href="/2021/10/16/%E7%AC%94%E8%AF%95%E5%90%88%E8%BE%91/"/>
      <url>/2021/10/16/%E7%AC%94%E8%AF%95%E5%90%88%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li><a href="https://blog.nowcoder.net/n/705b29af83034150830e3c0e9a28e51f">送文件问题</a> 题意说人话就是：给定线段<span class="math inline">\(A_1A_2\)</span>和<span class="math inline">\(B_1B_2\)</span>，希望从<span class="math inline">\(A_1A_2\)</span>和<span class="math inline">\(B_1B_2\)</span>上分别找一个点A和B，使得<span class="math inline">\(B_1B+BA&lt;=A_1A\)</span>。 首先三角形<span class="math inline">\(B_1BA\)</span>三条边满足<span class="math inline">\(B_1A&lt;b_1b+ab\)</span>，因此快递员必然走直线<span class="math inline">\(ab_1\)</span>，即需要<span class="math inline">\(ab_1&lt;=aa_1\)</span>，即<span class="math inline">\(ab_1+aa_2&lt;=aa_1+aa_2=a_1a_2\)</span>，又在三角形<span class="math inline">\(b_1aa_2\)</span>中，<span class="math inline">\(ab_1+aa_2&gt;B_1A_2\)</span>，因此快递员必然选择走直线<span class="math inline">\(B_1A_2\)</span>，也就是说如果<span class="math inline">\(B_1A_2\)</span>的距离小于等于<span class="math inline">\(A_1A_2\)</span>的距离就能满足。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    x1, y1, x2, y2, x3, y3, x4, y4 = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    alice = (x3 - x4) ** <span class="number">2</span> + (y3 - y4) ** <span class="number">2</span></span><br><span class="line">    bob = (x1 - x4) ** <span class="number">2</span> + (y1 - y4) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> bob &lt;= alice:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No&quot;</span>)</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><a href="https://blog.nowcoder.net/n/62d4211f496e4939a153536e8e89a3ef">及格问题</a> 我理解的题意（误）是：共有<span class="math inline">\((n+3)*20\)</span>道题，只要做对<span class="math inline">\((n+3)*12\)</span>题以上就可以及格，然后如下代码连样例都过不了： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> comb</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">72</span>, <span class="number">121</span>):</span><br><span class="line">    ans += comb(<span class="number">120</span>, i, exact=<span class="literal">True</span>) % <span class="number">202220222022</span></span><br><span class="line">    ans %= <span class="number">202220222022</span></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure></li></ol><p>DP的话：如果将dp(i,j)定义为前i门课至少做对j题的组合数，最终的答案就是dp(n+3,12(n+3))，但这样后面的状态转移可能会比较复杂。</p><p>所以我们将dp(i,j)定义为前i门课刚好做对j题的组合数，答案就是dp(n+3,12(n+3))+dp(n+3,12(n+3)+1)+...+dp(n+3,13(n+3))+...+dp(n+3,20(n+3)) 卧槽，好像弄错题意了... dp(1,i)=1，也就是说每一门课里做对哪些题没有区别，1门课做对1题不是20种方案，而是1种，所以排列组合也就不对了。唉，最怕读错题啊！！ 状态转移方程dp(i,j)=dp(i-1,0)+dp(i-1,1)+...+dp(i-1,j)，就是说前i门课刚好做对j题的方案数取决于前i-1门课，如果前i-1门课做对0题，那么第i门就必须要做对j题；如果前i-1门课做对1题，那么第i门就必须要做对j-1题... 这里要注意：因为一门课最多只能做对20题，所以前i-1课做对的题数要满足k &gt;= j - 20 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">mod = <span class="number">202220222022</span></span><br><span class="line"></span><br><span class="line">n += <span class="number">3</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> + <span class="number">20</span> * n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">    dp[<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i * <span class="number">20</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># k表示前i-1课做对的题数, 第i课做对的题数&lt;=20, 即前i-1课做对的题数k &gt;= j - 20</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> k &gt;= j - <span class="number">20</span>:</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][k]</span><br><span class="line">                dp[i][j] %= mod</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误示范</span></span><br><span class="line"><span class="comment"># for i in range(12, 21):</span></span><br><span class="line">    <span class="comment"># ans += dp[n][i * n] % mod</span></span><br><span class="line">    <span class="comment"># ans %= mod</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span> * n, <span class="number">20</span> * n + <span class="number">1</span>):</span><br><span class="line">    ans += dp[n][i] % mod</span><br><span class="line">    ans %= mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure> 3. <a href="https://blog.csdn.net/Derrick12/article/details/119712588">牛牛施肥</a> 这种题要注意循环不变性，就是说每一趟是否要包含第一行和最后一行，采用左闭右开，这样每一趟需要的肥料都是固定的，比较好实现而不至于淹没在细节里 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FarmerNN</span>(<span class="params">self, n, m</span>):</span></span><br><span class="line">        k, b = m // (n - <span class="number">1</span>), m % (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            ans = [k] * n</span><br><span class="line">            ans[<span class="number">0</span>], ans[-<span class="number">1</span>] = k // <span class="number">2</span>, k // <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b):</span><br><span class="line">                ans[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = [k] * n</span><br><span class="line">            ans[<span class="number">0</span>], ans[-<span class="number">1</span>] = k // <span class="number">2</span> + <span class="number">1</span>, k // <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, n - <span class="number">1</span> - b, -<span class="number">1</span>):</span><br><span class="line">                ans[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure> &lt;/b_1b+ab<span class="math inline">\(，因此快递员必然走直线\)</span>ab_1<span class="math inline">\(，即需要\)</span>ab_1&lt;=aa_1<span class="math inline">\(，即\)</span>ab_1+aa_2&lt;=aa_1+aa_2=a_1a_2<span class="math inline">\(，又在三角形\)</span>b_1aa_2<span class="math inline">\(中，\)</span>ab_1+aa_2&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日常碎碎念</title>
      <link href="/2021/09/24/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2021/09/24/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>以后还是减少在宿舍的时间吧，这个地方适合躺尸，不适合学习</li><li>就是太怂；不要被周围的土鳖影响定位，防止飘了，清醒的认识；keep in distance；非必要不用眼；工作是为了生活</li><li>真的少和他们鬼混了；没人结账，都是死皮脸；跟他们玩基本得不到任何提升，在他们面前显得牛逼没有任何卵用</li><li>以后少和他们出去玩吧，除了吃饭还是吃饭，很多时候还要我掏钱。而且某人已经得罪我了。以后就根据自己的需求最多和他们打打球好了或者去食堂好了，可以自己一个人去道科或者和其他朋友。 简言之，除了自身必要需求，少与他们鬼混。 重心要转到工作了，少玩点吧。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是江湖</title>
      <link href="/2021/09/11/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B1%9F%E6%B9%96/"/>
      <url>/2021/09/11/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B1%9F%E6%B9%96/</url>
      
        <content type="html"><![CDATA[<p>周一老板通知我周四去MSRA分享下自己的工作，我又惊又喜：喜的是自己有生之年竟然会有机会去dream company给talk，惊的是自己的工作实在很简单拉跨。接下来几天我全力做PPT，确认每一个技术细节，担心被问得下不来台，这也是我到目前为止见过的最大场面，所以压力极大，甚至吃不下饭、睡不着觉。</p><p>期间小老板还一直催着改论文，经常一个电话过来搞得我有点烦。可能真的是累了，烦了，也可能是被老师说创新性和工作量都不大，或者是要去微软分享过于紧张，总之现在过的有些痛苦，我基本彻底不想搞科研了，甚至不想毕业干码农了。可是真的不知道在金钱和妥协之间如何选择，到底是： 1. 能忍受互联网的工作环境，然后攒点钱去做其他事 2. 实在忍受不了，过的也比较痛苦，毕业直接去当老师 这个问题可能只有去不同地方实习才会有答案/与工作的同学交流，看看什么情况。 和赵欣倾诉下吧~</p><p>到北京后才知道被鸽了，得知这次只能参观一圈，改为下周四线上会议，我如释重负。虽然没有完美成行，但是和老板以及MSRA密切交流还是有了一些收获：</p><ol type="1"><li>通过和老板以及MSRA的一些交流，学术水平或者学习水平重要，但是更重要的是圈子，人脉，关系。江湖不是打打杀杀，而是人情世故。</li><li>学会错位发展。如果一件事情很火，那么可能就要小心点，你未必卷的过，就像ML组基本进不了，但是生信组却坑多，容易进，同时也显示了信息的重要。</li><li>自己的水平以及做的东西至少要达到一个差不多的标准，这样在老板的人脉发挥作用时才不至于错失良机。</li><li>许多事不要用类比的眼光去看，政策永远在动态调整，背后可能牵扯了很多故事，这是浮在表面的我们看不到的。</li><li>不出来见见世面，永远不会被打醒。创新港永远是一个鸟不拉屎的地方，长期在那里只会禁锢思想，自甘堕落。不要小瞧环境对人潜移默化的影响。</li><li>中美关系的影响我第一次如此真切的感受到，微软要听美国爸爸的话，人脸识别做不了，外企的特色文化也很敏感。</li></ol><p>还有就是自己无论见识，能力都差的很远，今天的聊天我几乎是透明的。感觉真的越来越土了，我真的太差了，想想自己的水平，万一真的被派到MSRA实习，又怎么能胜任呢？</p><p>还有就是以后再给自己太大压力了吧，有多大锅下多少米，有多大能力就干多少事吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>How to Make Plans</title>
      <link href="/2021/08/30/How%20to%20Make%20Plans/"/>
      <url>/2021/08/30/How%20to%20Make%20Plans/</url>
      
        <content type="html"><![CDATA[<p>如何平衡好科研、自学、生活？这是一个非常重要的问题，关乎未来发展和生活质量，并且随着年龄增长这个问题会变得更加严重，因为我们将要面临的世界会更加纷繁复杂。</p><p>要处理好这个问题并不容易，甚至有些玄学、有些艺术。我个人觉得解决这个问题的关键在于计划：制定合理的、可行的、有侧重性的、不那么死板、也不那么松散随意的计划，这其中包括长期计划、中期计划和短期计划，并且还要学会巧妙利用时间。</p><p>我自己尝试过各种各样的计划，包括但不限于按照时间段严格限定任务、按照任务进展松散型、TODO List等，基本都是坚持不到2礼拜就废弃了，而且也没有贯彻长期和中期计划。 <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211223092219887-1893756805.png" alt="image" /></p><p>如果纯粹按照follow your heart去排序，那么毫无疑问是生活&gt;自学&gt;科研，但是问题在于需要保证科研的最低限度（实习及毕业），所以计划应该怎么定呢？</p><ol type="1"><li>长期计划（2021.7~2025.7）：毕业工作两年。</li><li>中期计划（2021.7~2023.7）：</li><li>短期计划（每月每周）：</li></ol><p>核心问题在于：计划的目的并不在于100%完成，这听起来可能有些荒谬，计划的真正目的在于使你有一个为之努力的东西，全身心地投入到这个过程中，自然而然最后的结果也不会太差劲。所以TODO List中的事项没有全部划掉并不可怕，完成70%~80%足矣。剩下未完成的部分视重要程度作为下一阶段的首当其冲的事项。</p><p>达成目标本身并不会提高幸福水平的baseline，只是让自己future-oriented</p><h2 id="from-2021.11.23-to-2022.12.31">From 2021.11.23 To 2022.12.31</h2><p><strong>这段时间非常非常关键，会决定第一份工作的去向！！！绝对不能每天每个小时浑浑噩噩</strong></p><p>本计划包括阶段性目标和短期计划两部分，从后端开发（系统编程/云计算）的岗位需求出发设计目标：</p><p>阶段性目标主要是在什么时间节点完成什么事情，短期计划会具体到每天甚至每个小时的安排。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Inspiring Quotes</title>
      <link href="/2021/07/28/Inspiring%20Quotes/"/>
      <url>/2021/07/28/Inspiring%20Quotes/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>还差得远呢！ -ddd 深夜看到ddd对2020年华为软件比赛的精准<a href="https://github.com/justarandomstring/2020-Huawei-Code-Craft">分析</a>，深感自己平日实在太过轻松。</li><li>天赋游戏，遥不可及。 一位计算机同学的个性签名，深感自己早已不可能成为最顶尖的那批人，借此来宽慰遇到麻烦时的窘境。</li><li>所有的优越感都是因为没有见识。</li><li>深夜里碰杯，都是梦破碎的声音。</li><li>I'm tired of all those boring comparisons.</li><li>Missing your Vanilla Sky.</li><li>消失在人海。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>767 Reorganize String</title>
      <link href="/2021/07/26/767%20Reorganize%20String/"/>
      <url>/2021/07/26/767%20Reorganize%20String/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/reorganize-string/" title="题目链接">题目链接</a> ## 题意 给定字符串，重排其中的字符使得任意两个相邻位置的字母不同。 样例：s="aab"，输出"aba" ## 分析 最开始的想法是贪心+双指针，指针i从前向后遍历，指针j从i+1开始，如果s[i]==s[j]，j不断向后遍历找到第一个与s[i]不同的字母s[k]，将s[k]与s[j]交换。WA在了"baaba"，期待"ababa"，输出""，所以这种贪心策略显然是错的。</p><p>接着就想到需要考虑字符的出现频率，先按频率高低排序再去按照上述贪心，WA在了"aabbcc"，期待"abacbc"，输出""，很显然这种贪心策略本身就是错的。</p><p>接着就想到先安排出现次数最多的，如果当前要安排的与前一个字符相同，就选择出现次数第二多的，这样交替下去，可以写出如下代码： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reorganizeString(self, s: str) -&gt; str:</span><br><span class="line">        if len(s) == 1:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        from collections import Counter</span><br><span class="line">        dic = Counter(s)</span><br><span class="line"></span><br><span class="line">        ans = &quot;&quot;</span><br><span class="line">        prev = &quot;&quot;</span><br><span class="line">        for i in range(0, len(s)):</span><br><span class="line">            cnts = list(dic.items())</span><br><span class="line">            cnts = sorted(cnts, key=lambda x:x[1], reverse=True)</span><br><span class="line">            if prev == cnts[0][0]:</span><br><span class="line">                if len(cnts) &lt;= 1 or cnts[1][1] == 0:</span><br><span class="line">                    return &quot;&quot;</span><br><span class="line">                ans += cnts[1][0]</span><br><span class="line">                dic[cnts[1][0]] -= 1</span><br><span class="line">                prev = cnts[1][0]</span><br><span class="line">            else:</span><br><span class="line">                ans += cnts[0][0]</span><br><span class="line">                dic[cnts[0][0]] -= 1</span><br><span class="line">                prev = cnts[0][0]</span><br><span class="line">        return ans</span><br><span class="line"></span><br></pre></td></tr></table></figure> 时间复杂度<span class="math inline">\(O(n^2lgn)\)</span>，空间<span class="math inline">\(O(n)\)</span>。</p><p>因为涉及到出现次数最多的问题，可以考虑max heap。每次迭代时，从堆里弹出堆顶元素（意味着下次迭代该元素不会考虑）加入res，如果上一次迭代加入res的元素还有剩余，就将其重新加入heap，意味着下次迭代需要考虑该元素。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reorganizeString(self, s: str) -&gt; str:</span><br><span class="line">        ans, cnt = [], Counter(s)  # decent order</span><br><span class="line">        max_heap = [(-value, key) for key, value in cnt.items()]</span><br><span class="line">        heapq.heapify(max_heap)</span><br><span class="line">        prev_ch, prev_cnt = &#x27;&#x27;, 0</span><br><span class="line">        while max_heap:</span><br><span class="line">            cnt, ch = heapq.heappop(max_heap)</span><br><span class="line">            ans.append(ch)</span><br><span class="line">            if prev_cnt &lt; 0:</span><br><span class="line">                heapq.heappush(max_heap, (prev_cnt, prev_ch))</span><br><span class="line">            cnt += 1</span><br><span class="line">            prev_ch, prev_cnt = ch, cnt</span><br><span class="line">        if len(s) != len(ans):</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        return &#x27;&#x27;.join(ans)</span><br></pre></td></tr></table></figure> 时间复杂度<span class="math inline">\(O(n)\)</span>，空间<span class="math inline">\(O(n)\)</span>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CS231n Assignment</title>
      <link href="/2021/07/21/CS231n%20Assignment%20#1/"/>
      <url>/2021/07/21/CS231n%20Assignment%20#1/</url>
      
        <content type="html"><![CDATA[<p>先吹一波Google Colab，所有操作都可在云上进行，还能白嫖🐕家的GPU；再吹一下Stanford的骨架代码，真的是干净整洁优美，堪称典范。 <a href="https://github.com/EIMadrigal/CS231n">My Code</a> ## kNN 最幼稚的机器学习算法。</p><ol type="1"><li>计算测试集和训练集的距离 训练集<code>X_train</code>的shape为<span class="math inline">\((N, D)\)</span>，<code>y_train</code>的shape为<span class="math inline">\((N,)\)</span>，<code>y[i]</code>取值范围<span class="math inline">\([0,C-1]\)</span> 测试集<code>X_test</code>的shape为<span class="math inline">\((M, D)\)</span>，最终的distance matrix的shape为<span class="math inline">\((M,N)\)</span> 声明：不能使用类似于<code>np.linalg.norm()</code>这种东西作弊。 首先来看看2重循环：第一重遍历测试集，第二重遍历训练集，当然如果你愿意，还可以用第三重遍历dimension去累加距离； 再来看看只遍历测试集的单层循环：对于每个测试样例<code>X[i]</code>，减去<code>X_train</code>，通过广播机制得到一个<span class="math inline">\((N, D)\)</span>的差矩阵，做element-wise的平方，按列相加得到<span class="math inline">\((N,)\)</span>，表示测试样例<code>X[i]</code>与每个训练样例的距离，作为距离矩阵的第<span class="math inline">\(i\)</span>行； 最后来看看full-vectorized的版本，数学推导见<a href="https://zhuanlan.zhihu.com/p/146076139">NumPy之计算两个矩阵的成对平方欧氏距离</a>，吃饱没事干的同学可以自己推推，我数学太差就溜了。</li><li>根据距离矩阵预测测试集的标签 对于每个测试样例<code>X[i]</code>，选k个距离最小的训练样例，将其label（从<code>y_train</code>获得）存入<code>cloest_y</code>中，投票决定最终的预测标签。 先用<code>idx=np.argsort(dists[i])[:k]</code>取出前k个训练样例的index，再用<code>y_train[idx]</code>得到对应的k个label，最后用<code>np.argmax(np.bincount(cloest_y))</code>得到最终的预测label。</li></ol><p>kNN效果当然比较拉垮了，在CIFAR-10的子集上分类正确率大概在27%左右。比较令我震惊的是三个计算距离函数耗费的时间，2重循环57s，单层循环41s，fully-vectorized只有0.57s，竟然<strong>降低了100倍</strong>，写出高效的代码对于程序性能有着至关重要的影响，反思下自己写出的junk code，不由得留下了伤心的泪水...</p><p>最后就是用cross-validation确定超参k的取值，就略过了哈。 ## Linear Multiclass SVM 首先要为多分类SVM写一个损失函数，老规矩还是先写一个naive版本<code>svm_loss_naive(W, X, y, reg)</code>： 权重矩阵W：<span class="math inline">\((D, C)\)</span> minibatch输入X：<span class="math inline">\((N, D)\)</span> 标签y：<span class="math inline">\((N,)\)</span>，<code>y[i]=c</code>表示<code>X[i]</code>的标签是c，<span class="math inline">\(0 \leq c&lt;c\)</span> <span class="math display">\[l=&quot;\frac{1}{N}&quot; \]</span>l_i="_{j" +="" -="" )="" ),s_j="f(x_i," ="" ="" _i="" <em>k<em>l="" </em>{j="" f(x_i;="" loss为：="" loss和正则项两部分，对于第<span class="math inline">\(i\)</span>个训练样本，data="" loss是这么定义的：="" machine="" multiclass="" s_j="" s</em>{y_i}="" support="" vector="" w)_j="" w)_j<span class="math display">\[=&quot;&quot; w)_{y_i}=&quot;&quot; w_{k,l}^2\]</span>="" y_i}="" 什么意思呢？<span class="math inline">\(s\)</span>是第<span class="math inline">\(i\)</span>个训练样本的得分向量<span class="math inline">\((c,)\)</span>，<span class="math inline">\(s_{y_i}\)</span>表示正确标签的得分，<span class="math inline">\(s_j\)</span>表示其他类的得分。不妨看看什么时候损失为0呢？稍作变形即有：当<span class="math inline">\(s_{y_i}-s_j=&quot;&quot; 看着有点复杂哦！主要有data=&quot;&quot; 返回浮点数`loss`和解析梯度`dw`=&quot;&quot;&gt;\Delta\)</span>时，第<span class="math inline">\(j\)</span>类损失为0，说人话就是只有当正确类的得分减去其他类的得分大于某个间隔<span class="math inline">\(\Delta\)</span>时才不会累积损失，否则就累加损失（必然为正数），这就是大名鼎鼎的<strong>Hinge Loss</strong>。</p><p>如果<span class="math inline">\(f\)</span>用的是linear score function，进一步有： <span class="math display">\[L_i = \sum_{j\neq y_i} \max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)\]</span> 其中，<span class="math inline">\(w_j\)</span>表示W的第<span class="math inline">\(j\)</span>列。 至此，naive版本的<code>loss</code>实现就不必废话了。接着来求<code>dW</code>，老规矩，还是先研究单个样本。</p><p>如果你的数学还行，下面的梯度推导可以略过： <span class="math display">\[L_i = max(0,w_1^T x_i - w_{y_i}^T x_i + \Delta)+max(0,w_2^T x_i - w_{y_i}^T x_i + \Delta)+...+max(0,w_C^T x_i - w_{y_i}^T x_i + \Delta)\]</span> 共有<span class="math inline">\(C-1\)</span>项，因为<span class="math inline">\(j=y_i\)</span>那项不算。另，只有在<span class="math inline">\(w_j^T x_i - w_{y_i}^T x_i + \Delta&gt;0\)</span>时第<span class="math inline">\(j\)</span>项的梯度不为0。</p><ol type="1"><li>对<span class="math inline">\(w_{y_i}\)</span>的梯度 每项都有，并且都是0或<span class="math inline">\(-x_i\)</span>，因此只要看几项大于0，梯度就是几倍的<span class="math inline">\(-x_i\)</span>，正式点就是： <span class="math display">\[\nabla_{w_{y_i}} L_i = - \left( \sum_{j\neq y_i} \mathbb{1}(w_j^Tx_i - w_{y_i}^Tx_i + \Delta &gt; 0) \right) x_i\]</span></li><li>对<span class="math inline">\(w_j\)</span>的梯度 只有第<span class="math inline">\(j\)</span>项有，0或<span class="math inline">\(x_i\)</span>，正式点就是： <span class="math display">\[\nabla_{w_j} L_i = \mathbb{1}(w_j^Tx_i - w_{y_i}^Tx_i + \Delta &gt; 0) x_i\]</span></li></ol><p>naive版本的<code>dW[:,j]</code>和<code>dW[:,y[i]]</code>就2重循环按部就班更新即可，别忘了除以<span class="math inline">\(N\)</span>和正则项梯度。</p><p>接着来实现<code>svm_loss_vectorized(W, X, y, reg)</code>：</p><ol type="1"><li>loss 首先求得整个训练集的得分矩阵<code>scores</code>，shape为<span class="math inline">\((N,C)\)</span>，每一行表示一个样例的得分。正确类得分向量<code>correct_class_score</code>可用<code>scores[np.arange(num_train), y]</code>得到，shape为<span class="math inline">\((N,)\)</span>，注意这里不能用<code>scores[:, y]</code>，简单试验下：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line">y = np.array([<span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(X[np.arange(<span class="number">2</span>), y])  <span class="comment"># [3,4]</span></span><br><span class="line"><span class="built_in">print</span>(X[:, y])  <span class="comment"># [[3,2],[5,4]]</span></span><br></pre></td></tr></table></figure><p>下来到了最关键的<code>margins</code>矩阵，该矩阵和<code>scores</code>矩阵shape相同<span class="math inline">\((N,C)\)</span>，第<span class="math inline">\(i\)</span>行表示第<span class="math inline">\(i\)</span>个训练样本的margin即<span class="math inline">\(max(0,s_j - s_{y_i} + \Delta)\)</span>，在每一行第<span class="math inline">\(y_i\)</span>个位置上应当设置为0，其余位置按照公式即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margins = np.maximum(<span class="number">0</span>, scores - correct_class_score[:, np.newaxis] + <span class="number">1</span>)</span><br><span class="line">margins[np.arange(num_train), y] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>需要注意：<code>correct_class_score</code>是一个<span class="math inline">\((N,)\)</span>的向量，如果直接<code>scores-correct_class_score</code>就会报错，广播机制从最后一个维度开始比对，只有相等或者其中某个为1才行，因此用<code>np.newaxis</code>将<code>correct_class_score</code>的shape变为<span class="math inline">\((N,1)\)</span>；还有就是<code>np.max()</code>和<code>np.maximum()</code>的区别，<code>np.max()</code>和<code>np.amax(a, axis=None, ...)</code>等价，返回数组的最大值，<code>np.maximum(x1, x2, out=None, ...)</code>返回element-wise的较大值。</p><ol start="2" type="1"><li>梯度 这里也稍微有点tricky，根据naive版本对梯度的讨论：对<span class="math inline">\(w_j\)</span>的梯度需要知道margin的正负，对<span class="math inline">\(w_{y_i}\)</span>的梯度需要知道<strong>有几项大于0</strong>。怎么借助<code>margins</code>矩阵统计每一行大于0的项数呢？无聊的程序员先将矩阵中大于0的项都设为1，然后按列相加即可：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">margins[margins &gt; <span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">num_to_loss = np.<span class="built_in">sum</span>(margins, axis=<span class="number">1</span>)  <span class="comment"># (N,)</span></span><br><span class="line">margins[np.arange(num_train, y)] = -num_to_loss</span><br></pre></td></tr></table></figure><p>对单个样本<span class="math inline">\(i\)</span>来说，其对<code>dW</code>的贡献要么是在第<span class="math inline">\(j\)</span>列（即第<span class="math inline">\(j\)</span>个类）加上<span class="math inline">\(x_i\)</span>，要么在第<span class="math inline">\(y_i\)</span>列加上<span class="math inline">\(-kx_i\)</span>，<span class="math inline">\(k\)</span>为<code>margins[i]</code>中大于0的元素个数，即<code>num_to_loss[i]</code>，整个训练集对<code>dW</code>的更新即是在累加单个样本对<code>dW</code>每一列（每个类）的影响。对第<span class="math inline">\(j\)</span>列，其更新即为每个训练样本对该类贡献的线性组合，组合系数取决于该样本的标签以及是否满足指示函数，即为<code>margins</code>的第<span class="math inline">\(j\)</span>列，取值范围<span class="math inline">\(\{0,1,-k\}\)</span>，0表示该样本对第<span class="math inline">\(j\)</span>个类的梯度没有贡献（该样本标签不是<span class="math inline">\(j\)</span>且不满足指示函数），1表示贡献了<span class="math inline">\(x_i\)</span>（该样本标签不是<span class="math inline">\(j\)</span>且满足指示函数），<span class="math inline">\(-k\)</span>表示贡献了<span class="math inline">\(-kx_i\)</span>（该样本的标签就是<span class="math inline">\(j\)</span>），因此：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dW = np.dot(X.T, margins) / num_train + <span class="number">2</span> * reg * W</span><br></pre></td></tr></table></figure><p>可以从矩阵维度相容的角度验证。 ## Softmax 先用循环实现一个<code>softmax_loss_naive(W, X, y, reg)</code>，输入的shape和SVM相同。 softmax分类器不再将<span class="math inline">\(f(x_i;W)\)</span>看做每个类的得分，而是希望输出normalized class probabilities，最终选一个概率最大的类作为预测，<strong>softmax函数</strong>就能将<span class="math inline">\(f(x_i;W)\)</span>映射到<span class="math inline">\([0,1]\)</span>且满足概率的性质： <span class="math display">\[P(y_i \mid x_i; W) = \frac{e^{f_{y_i}}}{\sum_j e^{f_j} }\]</span> 从预测函数可以看到：softmax是把<span class="math inline">\(f(x_i;W)\)</span>看作unnormalized log probabilities，因此对<span class="math inline">\(f(x_i;W)\)</span>先指数再归一化得到每个类的概率。</p><p>再来看softmax的损失函数： <span class="math display">\[L_i = -\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right) \hspace{0.1in} \text{or equivalently} \hspace{0.1in} L_i = -f_{y_i} + \log\sum_j e^{f_j}\]</span> 从直觉上说：属于正确类<span class="math inline">\(y_i\)</span>的概率（括号里的分式）越高，损失应该越小，这就是大名鼎鼎的<strong>cross-entropy loss</strong>，衡量了真实分布<span class="math inline">\(p\)</span>和预测分布<span class="math inline">\(q\)</span>之间的差距： <span class="math display">\[H(p,q) = - \sum_x p(x) \log q(x)= H(p) + D_{KL}(p||q)\]</span> 具体到softmax： <span class="math display">\[q=\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} },p = [0, \ldots 1, \ldots, 0]\]</span> 其中，<span class="math inline">\(p\)</span>在第<span class="math inline">\(y_i\)</span>个位置上为1。 由于<span class="math inline">\(H(p)=0\)</span>，因此其实是在最小化<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>的KL散度，即希望预测结果<span class="math inline">\(q\)</span>尽量向<span class="math inline">\(p\)</span>靠近。</p><p>从概率的角度出发看损失函数，我们是在最小化正确类<span class="math inline">\(y_i\)</span>的负对数似然，本质上就是在做一个极大似然估计。</p><p>看完理论，还要考虑一些现实问题。比如数值稳定性，由于指数的原因可能会导致overflow或者underflow，因此做一个简单的等价变换： <span class="math display">\[\frac{e^{f_{y_i}}}{\sum_j e^{f_j}}= \frac{Ce^{f_{y_i}}}{C\sum_j e^{f_j}}= \frac{e^{f_{y_i} + \log C}}{\sum_j e^{f_j + \log C}}\]</span> 一般选<span class="math inline">\(\log C = -\max_j f_j\)</span>，这个变换不会改变预测函数或者损失函数，只是将得分做了平移。</p><p>至此，naive版本的loss就基本有了，接着看看梯度咋求。先稍稍展开康康： <span class="math display">\[L_i=-f_{y_i} + \log\sum_j e^{f_j}=-w_{y_i}^Tx_i+log\sum_je^{w_j^Tx_i}\]</span> 其中，<span class="math inline">\(w_j\)</span>表示W的第<span class="math inline">\(j\)</span>列。 然后使用我们的小学数学知识去求偏导： <span class="math display">\[\nabla_{w_{y_i}} L_i =(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j}}-1)x_i \\\nabla_{w_j} L_i = \frac{e^{f_{j}}}{ \sum_j e^{f_j}}x_i\]</span> 记<code>p = np.exp(scores) / np.sum(np.exp(scores))</code>，shape为<span class="math inline">\((C,)\)</span>，表示样本<span class="math inline">\(i\)</span>属于每个类的概率。 所以<code>dW</code>的第<code>y[i]</code>列更新即为<code>(p[y[i]] - 1) * X[i]</code>，其他列更新为<code>p[j] * X[i]</code>。</p><p>接着看下vectorized版本，<code>scores</code>的shape变为了<span class="math inline">\((N,C)\)</span>，首先处理数值稳定性问题，每一行都减去该行的最大值（注意<code>keepdim=True</code>）；接着求出概率矩阵<code>p</code>，shape与<code>scores</code>相同，那么loss为： <code>loss = np.sum(-np.log(p[np.arange(X.shape[0]), y])) / X.shape[0]</code> 与SVM类似，<code>dW</code>的每一列（每个类）是由每个训练样本影响的线性组合决定的，组合系数取决于该训练样例的标签，比如对于<code>dW</code>的第<span class="math inline">\(j\)</span>个类来说，如果某个样例的标签恰好是<span class="math inline">\(j\)</span>，那么其对梯度的贡献就是<code>p[j]-1</code>，否则系数就是<code>p[j]</code>。因此只要将概率矩阵<code>p</code>中所有正确标签的值减1即得到系数矩阵，进而得到<code>dW</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p[np.arange(X.shape[<span class="number">0</span>]), y] = p[np.arange(X.shape[<span class="number">0</span>]), y] - <span class="number">1</span></span><br><span class="line">dW = np.dot(X.T, p)</span><br></pre></td></tr></table></figure><p>同样可以用维度相容去check。 ## Neural Network 这是一个两层的全连接神经网络，架构如下： 输入<span class="math inline">\((N,D)\)</span>-&gt;全连接层1-&gt;ReLU-&gt;全连接层2（输出每个类的得分）-&gt;softmax 参数们的shape为：<span class="math inline">\(X(N,D),W1(D,H),b1(H,),W2(H,C),b2(C,)\)</span></p><p>第一步Forward Pass，根据输入X和权值W计算<span class="math inline">\(scores(N,C)\)</span>，然后计算softmax loss； 第二步Backward Pass，需要计算loss对于参数们的梯度，根据网络结构： <span class="math display">\[h=XW1+b1\\o=ReLU(h)\\s=oW2+b2\\L=\sum_i(-s_{y_i}+log\sum_j e^{s_j})\]</span> 根据链式法则+维度相容： <span class="math display">\[\nabla_{w_2} L =o^T \nabla_{s} L\\\nabla_{b_2} L =(\nabla_{s} L)^T(\nabla_{b_2} s)=(C,N)(N,1)=(C,N)(all\ 1\ col)\\\nabla_{w_1} L =X^T \nabla_{s} L\nabla_{h} s\\\nabla_{b_1} L =\nabla_{h} s (\nabla_{s} L)^T\nabla_{b_1} h=(H,C)(C,N)(N,1)=(H,C)(C,N)(all\ 1\ col)\]</span> 可以看出：关键在于求出<span class="math inline">\(\nabla_{s} L\)</span>，在对softmax的讨论中可知，对于第<span class="math inline">\(y_i\)</span>列导数为<code>p[y[i]]-1</code>，对其他列为<code>p[j]</code>，因此该偏导为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d2 = p</span><br><span class="line">d2[np.arange(X.shape[<span class="number">0</span>]), y] -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>另外对于<span class="math inline">\(W_1,b_1\)</span>，还需要<span class="math inline">\(\nabla_{h} s\)</span>：这玩意在<span class="math inline">\(h&gt;0\)</span>就是<span class="math inline">\(W_2^T\)</span>，否则就是0。因此<span class="math inline">\(\nabla_{s} L\nabla_{h} s\)</span>可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1 = d2.dot(W2.T) * (h &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="image-features">Image Features</h2><p>之前的样例都是直接用raw pixel，加上都是线性模型，效果拉跨太正常了。这里用的人工feature包括HOG(Histogram of Oriented Gradients)和color histogram，HOG捕捉texture（纹理变化？）信息，color histogram捕捉颜色信息，两者互相辅助。&lt;/c$&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1171 Remove Zero Sum Consecutive Nodes from Linked List</title>
      <link href="/2021/07/17/1171%20Remove%20Zero%20Sum%20Consecutive%20Nodes%20from%20Linked%20List/"/>
      <url>/2021/07/17/1171%20Remove%20Zero%20Sum%20Consecutive%20Nodes%20from%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">题目链接</a> ## 题意 给定一个单链表，删除和为0的连续结点序列，直到最终链表中没有和为0的连续结点序列。 样例：head = [1,2,3,-3,-2]，输出[1] ## 分析 由于链表头结点可能会被删除，因此首先创建dummy结点。一个比较直观的想法就是记录前缀和，依次遍历链表，遇到出现过的前缀和也就意味着出现了和为0的序列，就删除两次相同前缀和中间的序列。因此需要一个hashtable记录前缀和出现的位置，手动走一个简单样例吧： dummy设为<code>(0,head)</code>，hashtable初始包含<code>&#123;0:dummy&#125;</code>，避免[1,-1]这种情况。</p><ol type="1"><li><code>cur=p(1),sum=1,hash=&#123;0:dummy,1:p(1)&#125;</code></li><li><code>cur=p(2),sum=3,hash=&#123;0:dummy,1:p(1),3:p(2)&#125;</code></li><li><code>cur=p(3),sum=6,hash=&#123;0:dummy,1:p(1),3:p(2),6:p(3)&#125;</code></li><li><code>cur=p(-3),sum=3</code>：此时hash返回p(2)，因此就让p(2).next指向cur.next，相当于删除了[3,-3]，<code>hash=&#123;0:dummy,1:p(1),3:p(2),6:p(3)&#125;</code></li><li><code>cur=p(-2),sum=1</code>：此时hash返回p(1)，因此让p(1).next指向cur.next，相当于删除了[2,-2]，<code>hash=&#123;0:dummy,1:p(1),3:p(2),6:p(3)&#125;</code></li></ol><p>大概可以写出这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        cur = head</span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        hashtable = &#123;<span class="number">0</span>:dummy&#125;</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            prefix_sum += cur.val</span><br><span class="line">            p = hashtable.get(prefix_sum)</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                p.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashtable[prefix_sum] = cur</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>交上去WA了，问题出在哪呢？ 走一遍出错的样例：输入[1,3,2,-3,-2,5,5,-5,1]，期待[1,5,1]，输出[1,5,5,-5,1]</p><ol type="1"><li><code>cur=p(1),sum=1,hash=&#123;0:dummy,1:p(1)&#125;</code></li><li><code>cur=p(3),sum=4,hash=&#123;0:dummy,1:p(1),4:p(3)&#125;</code></li><li><code>cur=p(2),sum=6,hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2)&#125;</code></li><li><code>cur=p(-3),sum=3,hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2),3:p(-3)&#125;</code></li><li><code>cur=p(-2),sum=1</code>：此时hash返回p(1)，让p(1).next指向p(-2).next，链表变为了[1,5,5,-5,1]，<code>hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2),3:p(-3)&#125;</code></li><li><code>cur=p(5),sum=6</code>：此时hash返回p(2)，但此时p(2)已经删除，因此让p(2).next指向p(5).next肯定是错的。</li></ol><p>至此应该可以看出问题了：在删除改变链表指针的同时，hashtable并没有做相应的同步删掉对应的元素，所以每当出现重复前缀和时只要删掉hashtable中两次前缀和之间的项即可，可以借助<code>OrderedDict()</code>实现，按照插入顺序即链表顺序有序：</p><ol type="1"><li><code>cur=p(-3),sum=3,hash=&#123;0:dummy,1:p(1),4:p(3),6:p(2),3:p(-3)&#125;</code></li><li><code>cur=p(-2),sum=1</code>：此时hash(1)返回p(1)，删除后为<code>hash=&#123;0:dummy,1:p(1)</code></li><li><code>cur=p(5),sum=6</code>：此时hash返回<code>None</code>，符合预期，继续迭代即可。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        cur = head</span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        hashtable = OrderedDict(&#123;<span class="number">0</span>:dummy&#125;)</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            prefix_sum += cur.val</span><br><span class="line">            prev = hashtable.get(prefix_sum, cur)</span><br><span class="line">            <span class="keyword">while</span> prefix_sum <span class="keyword">in</span> hashtable:</span><br><span class="line">                hashtable.popitem()</span><br><span class="line">            hashtable[prefix_sum] = prev</span><br><span class="line">            prev.<span class="built_in">next</span> = cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>Two-pass： 上述做法的hashtable记录的是第一次出现前缀和的位置。现在换一种思路：首先遍历一次链表，hashtable记录<strong>最后一次</strong>出现前缀和的位置，第二次遍历链表设置相应的指针到最后一次前缀和的位置，这样即使第一次前缀和位置被删除，指针也会相应地跳过：</p><ol type="1"><li>第一次遍历后：<code>hash=&#123;0:dummy,1:p(-2),4:p(3),6:p(-5),3:p(-3),11:p(5),7:p(1)&#125;</code></li><li>第二次遍历：<code>dummy.next=hash[0].next,p(1).next=hash[1].next=p(5),p(5).next=hash[6].next=p(1),p(1).next=hash[7].next=null</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeZeroSumSublists</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        hashtable = &#123;<span class="number">0</span>:dummy&#125;</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            prefix_sum += head.val</span><br><span class="line">            hashtable[prefix_sum] = head</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        prefix_sum = <span class="number">0</span></span><br><span class="line">        head = dummy</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            prefix_sum += head.val</span><br><span class="line">            head.<span class="built_in">next</span> = hashtable[prefix_sum].<span class="built_in">next</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>时间复杂度<span class="math inline">\(O(n)\)</span>，空间复杂度<span class="math inline">\(O(n)\)</span>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Research Proposal</title>
      <link href="/2021/07/15/Research%20Proposal/"/>
      <url>/2021/07/15/Research%20Proposal/</url>
      
        <content type="html"><![CDATA[<h2 id="时间节点">时间节点</h2><ol type="1"><li>开题答辩：11月20第一批，1.1第二批</li><li>实习：1.1第一批，3.1第二批</li><li>自身安排：第一批开题并且第一批出去。 从9.25~12.31全力科研，完成创新点2，并且写成毕业论文的格式；零碎时间自学提升。 2022.1.1~2022.7.1全部用来实习。</li></ol><h2 id="创新点1">创新点1</h2><ol type="1"><li>加入了采样方法的自动选择</li><li>代理模型对于高维稀疏数据的处理XGBoost</li><li>Playout阶段的改进</li></ol><ul class="task-list"><li><input type="checkbox" disabled="" />代理模型采用二分类器，类似于FB的paper</li><li><input type="checkbox" disabled="" />pipeline：默认config组成的pipeline的影响（结合meta-learning）；components在Tree中的层次搜索顺序：初始数据集均匀随机采3个，嵌入先验分布，如<code>score_each_cl</code>通过先验进行修正</li></ul><h2 id="创新点2">创新点2</h2><ol type="1"><li>搜索过程产生的config按某种策略（动态推荐）做ensemble</li><li>评价指标换用其它综合指标，避免recall/precision等简单指标（接近极限了）。换指标的话就可以用KEEL和Imblearn的大部分数据集，不用去找其他的或者用少数类数目筛选</li></ol><ul class="task-list"><li><input type="checkbox" disabled="" />建立不平衡数据集的meta database作为warm-start，加速搜索过程</li><li><input type="checkbox" disabled="" />使用bandit等策略来对时间分配策略调整</li><li><input type="checkbox" disabled="" />考虑从黑盒优化转为灰盒优化（Multi-fidelity优化），如训练集子集、观察学习曲线等</li><li><input type="checkbox" disabled="" />朱老师说的按照元特征去指导MCTS的搜索方向，提前剪枝等</li><li><input type="checkbox" disabled="" />多分类不平衡数据</li></ul><h2 id="探索">探索</h2><ul class="task-list"><li><input type="checkbox" disabled="" />AdaBoost/AdaBoost-MH/GBDT/XGBoost/LightGBM（工业界用的多）等集成学习用来对分错的数据集进行提升</li><li><input type="checkbox" disabled="" />概率图模型（每个数据集对应的可能的算法是由概率形式表现的）：<span class="math inline">\(P(A_i|D)=\cfrac{P(D|A_i)P(A_i)}{P(D)}\)</span></li><li><input type="checkbox" disabled="" />BO/CBO/SOO (综述paper)</li><li><input type="checkbox" disabled="" />除了基于精确度和时间的对比，但是很多时候搜索阶段表现最好的，在评估阶段并不是最好的，甚至可能表现很差。 因此一种用的比较多的就是Kendall Tau metric，它会评估两个阶段模型性能的相关性，相关性越高则表示算法越有效</li><li><input type="checkbox" disabled="" /><strong>多样本</strong>：图神经网络==深度学习链接预测</li></ul><p>可能由于样本量太少，特征太多，导致数据稀疏，用低维特征去做分类，元特征选择/降维</p><p>致命缺点：算法性能的差别可能是由于数据集质量决定的，而不是元特征的质量？？所以元特征还应有一个衡量数据集质量的特征？？</p><h2 id="advice">Advice</h2><ul><li>现有方法软肋，针对性idea稳妥。论文要多问<strong>为什么</strong>，为什么用这个模型，为什么在这种数据上表现好...</li><li>读AutoML</li></ul><ol type="1"><li>我要解决的问题是什么？</li><li>这个问题的难点在哪？</li><li>别人是怎么干的？为什么这么干？效果怎么样？这么干有什么缺陷？</li><li>我打算怎么干？为什么这样干是对的？</li><li>实验验证 ## Next</li><li>小数据集、GNN(Graphsage/pinsage/gat，GCN/Deepwalk不能用)、新特征表示、KNN 每次来一个新的测试数据集，就加入图中，动态增长变化的模型</li><li>大数据集、GraphSage/DNN变为多标签分类{A1 A2...}</li><li>DRL</li></ol><h2 id="tricks">Tricks</h2><ul><li>更改UCI问题数据集</li><li>看看最终的元模型在哪些数据集表现不佳，适当替换数据集</li></ul><h2 id="now">Now</h2><ol type="1"><li>对于不平衡数据集，需要采样进行预处理，推荐合适的采样的算法及其超参数（采样比例等）</li><li>GNN对原始数据集提特征，要求数据集特征数目相同，可能要降维等</li></ol><h2 id="图神经网络">图神经网络</h2><p>图神经网络商品推荐非常准确：用户和产品间的交互 <img src="https://img-blog.csdnimg.cn/20210117170914563.png" alt="在这里插入图片描述" /></p><ul><li>图卷积网络GCN</li><li>图注意力网络GAN</li><li>图自编码器</li><li>图生成网络</li><li>图时空网络</li></ul><p>图结构信息：经典的DNN、RNN、CNN处理效果不好</p><p>社交网络（用户、关系） 电子购物（用户、商品） 化学分子（原子、化学键）</p><p>多标签的GNN？异构图的GNN？</p><p>数据：MultiKNN那篇文章生成数据集的方法</p><p>欧几里得数据：图像、文本、视频</p><p>ML假设样本独立，图数据不满足 <img src="https://img-blog.csdnimg.cn/20210118155146919.png" alt="在这里插入图片描述" /> 网络嵌入：保留网络拓扑架构和结点内容信息，将网络顶点表示到低维向量空间，使得后续的分类、聚类、推荐使用简单的算法即可完成：</p><ul><li>矩阵分解</li><li>随机游走</li><li>深度学习：同时属于GNN</li></ul><figure><img src="https://img-blog.csdnimg.cn/20210118185948765.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><p>抽特征后，新的数据集可能和历史数据集有联系，即和图中的某些结点有带权边，可以用GCN从邻域聚合特征信息。</p><ul><li>GCN：</li><li>图注意力网络：重要的结点会有更大的权值，在聚合特征信息时向不同近邻分配注意力权重、根据注意力权重集成多个模型，以及使用注意力权重引导随机游走</li></ul><p>传统深度学习加层会带来效果的提升，但是研究表明：图网络随着层数增加，性能急剧下降； 不能扩展到大型图；</p><h2 id="graph-embedding">Graph embedding</h2><p>发现高维图的低维向量表示 <img src="https://img-blog.csdnimg.cn/20210119101906372.png" alt="在这里插入图片描述" /></p><p>异构图GNN，算法结点的特征空间可以考虑算法本身的性质等？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于职业发展的考虑</title>
      <link href="/2021/07/14/%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E7%9A%84%E8%80%83%E8%99%91/"/>
      <url>/2021/07/14/%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E7%9A%84%E8%80%83%E8%99%91/</url>
      
        <content type="html"><![CDATA[<p>事情缘由是这样的：自从二战以后，我个人对未来职业上的事就淡然处之了，更加关注生活方面的幸福感，这其实也没有太大的过错，而且我自己感觉这些时间总体上还是越来越happier了。</p><p>前段时间有好朋友拿到Google Seattle的offer，又有朋友要去UCSD追寻学术梦想了，再想想许多朋友都在国外混得风生水起，觉得自己也不能太咸鱼吧，我自己清楚这并不是与别人比较，而是在基本物质得不到满足的情况下，未来的现实生活并没有想象中的那么ideal，尤其是我这种条件。</p><p>所以我希望更加细化自己的职业规划，并且结合当前的现实情况制定下一步的具体措施。</p><ol type="1"><li>重视思想认识 一方面，要足够重视找工作对未来生活的影响，可以适当牺牲一些当前生活的幸福指数；另一方面，要深刻认识到时间并不充裕，满打满算也就一年，尤其自己还是没什么天赋的非科班选手。 High expectation并不会带来太大的失望，learn to fail or fail to learn。 在不把自己限制死的前提下，目前大的方向就是去互联网（包括银行、国企、fin-tech）或者去高中教师。</li><li>分析现实情况 2.1 实验室：首先就是认清目前的境遇：在这个学校的当前这个实验室靠发顶会论文找到好工作的可能几乎没有，因此只能通过自学和实习来增加找到好工作的几率；老师的目标和自身目标在某些方面是一致的（如毕业），但是在很多方面是有很大冲突的（老师希望发好文章保住饭碗或者干项目，我希望用更多时间去准备工作），所以不能一味听从老师的忽悠，不要把注意力过于放在老师身上，要有自己清醒的判断：你最终找到什么样的工作老师压根不会关心，他们只会抢你的一作。另外，不必太过担心毕业的事情，按照自身的水平和XJTU的尿性，正常毕业应该问题不太大。 2.2 博士：不要被周围的博士蒙蔽，我自己暂时绝没有读博的打算，因此在科研问题上没必要较真，平时的讨论也要注意自己的定位。而且从目前来看：周围环境下的博士做的也基本是垃圾。当然并不排除工作几年后出国读博/国内优秀导师读博的可能性，虽然目前来看这种可能性并不大。 2.3 工作（努力）方向：高中教师包括数学和计算机的可能性，计算机的教资要尽快拿到，到时候找工作可以直接去面试，这一点可以作为备选方案，届时进行offer比较； 互联网的方向就是算法和开发：首先自身暂时倾向于算法岗，找实习/工作时如果过于困难就转开发。开发这边目前已经积累了一些项目，但仍有很多薄弱点（如java）；算法目前没有项目，要迅速找一些<strong>较大</strong>的项目/比赛完成，同时还要打磨自己开发上的积累，<strong>如此看来时间更加紧迫</strong>。 目标就是能拿到微软或者国内大厂sp这一档的offer。</li><li>具体措施 3.1 hard work：不论是各位前辈还是哈佛的课都在强调这点，这同时也意味着要减少不必要的娱乐时间（看b站、大量外出吃饭唱歌等），当然这并不意味着不锻炼或者低效学习，而是要增加高效学习的时间。 3.2 科研与自学的平衡：科研只要达到外出实习和毕业的最低要求就行，不要太较真，抱着差不多就行了的态度，不要想着做出顶会级的成果，<strong>但是首先要集中精力水出一篇垃圾以获得外出实习的机会</strong>；自学一定要足够敬畏和认真，扎扎实实推进。 3.3 自学：这方面的具体措施已经写在博客里，不再赘述。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Optimization Methods in Deep Learning</title>
      <link href="/2021/07/10/Optimization%20Methods%20in%20Deep%20Learning/"/>
      <url>/2021/07/10/Optimization%20Methods%20in%20Deep%20Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="background">Background</h2><p>深度神经网络的训练过程主要通过求解一个特定的优化问题来实现，然而由于该问题是一个复杂的高维非线性优化问题，并且不同的网络结构差异很大，不能将传统的优化方法直接使用。即使数据集和网络结构完全相同，不同的优化算法也可能导致完全不同的收敛效果。实际应用的一些简单方法虽然行之有效，但现有理论无法充分解释其有效性，超参数的不断增加也给优化增加了不少难度。如何确保算法收敛、如何尽快收敛以及能否收敛到全局最优一直是困扰学术界和工业界的问题。如果能够用优化理论去解释神经网络的训练行为，对于深度学习的推广应用将会起到巨大的推动作用。</p><p>对于有监督学习，给定包含n个样本的训练集<span class="math inline">\(\{(\mathbf{x}_1, y_1), \ldots, (\mathbf{x}_n, y_n)\}\)</span>，<span class="math inline">\(\mathbf{x}\)</span>表示样本的特征向量，<span class="math inline">\(y\)</span>表示该样本对应的标签。我们的任务是利用样本信息来预测相应的标签，使预测值尽可能接近真实标签。如果用深度学习来完成这个任务，就需要通过调整神经网络的参数（权重W和偏差b）来近似数据背后的函数映射关系，这个关系往往是高度非线性的，网络越深表达能力也就越强，逼近效果的精度也就更高，因此网络结构很可能是极其复杂的。</p><p>为了衡量预测值和真实值之间的接近程度，通常需要采用某种距离度量方式<span class="math inline">\(l\)</span>，<span class="math inline">\(l\)</span>一般设计为<strong>可微</strong>的，接着用一些优化算法去最小化该目标函数。因此优化问题变为寻找最佳的参数使得<span class="math inline">\(l\)</span>最小，在不考虑正则项的情况下有： <span class="math display">\[\mathop{\mathrm{min}}_f \frac{1}{n} \sum_{i=1}^n l(f(\mathbf{x}_i), y_i)\]</span> <span class="math inline">\(f\)</span>就是我们从输入到输出的映射函数，<span class="math inline">\(l\)</span>通常也叫损失函数，衡量预测值<span class="math inline">\(f(x_i)\)</span>和真实标签<span class="math inline">\(y_i\)</span>的差距，比如回归问题中经常使用的平方损失函数<span class="math inline">\(l=||f(x_i)-y_i||^2\)</span>。</p><p>需要注意的是：深度学习中的优化问题与传统意义上的优化问题有所差别。传统的优化问题需要尽可能找到目标函数的最值，而深度学习的最终目的是为了<strong>预测未知</strong>的数据，而不是将训练数据上的损失降到最低。我们定义的损失函数<span class="math inline">\(J(\Theta)\)</span>衡量的是当前模型参数<span class="math inline">\(\Theta\)</span>在<strong>训练集</strong>上的优劣，然而，最小化训练误差并不意味着模型的泛化误差也会最小，为了降低泛化误差我们还需要关注过拟合问题，因此损失函数往往要加上<strong>正则项</strong>。统计学上称为经验风险最小化，即由于无法获得全部数据，所以只能用经验风险作为实际风险的近似。非常有意思的是：尽管大多数神经网络都是严重过参数化的，但是反而有着比较不错的泛化能力，这与传统的机器学习观点是矛盾的，泛化理论也需要更加深入的研究。</p><p>深度学习中的<span class="math inline">\(f\)</span>通常是多层的复合函数，由于太复杂而无法求出解析解，所以要用数值优化算法去求解。实际中主流的深度学习优化算法都利用梯度下降来求解，梯度下降是深度学习优化算法的基础，尽管目前已经很少直接使用，但它却是其他高级优化算法的基石： 假设网络的参数为<span class="math inline">\(x=(x_1,x_2,...,x_d)^T\)</span>，优化的目标函数为<span class="math inline">\(f\)</span>，那么<span class="math inline">\(f\)</span>的梯度为： <span class="math display">\[\nabla f(\mathbf{x}) = \bigg[\frac{\partial f(\mathbf{x})}{\partial x_1}, \frac{\partial f(\mathbf{x})}{\partial x_2}, \ldots, \frac{\partial f(\mathbf{x})}{\partial x_d}\bigg]^\top\]</span> 每个元素对应着目标函数在该方向上的变化率，因此只要沿着梯度的反方向就可以使目标函数减小得最快：<span class="math inline">\(\mathbf{x} \leftarrow \mathbf{x} - \eta \nabla f(\mathbf{x})\)</span>，<span class="math inline">\(\eta\)</span>是一个被称为学习率的超参数，用来控制每一步的大小。<span class="math inline">\(\eta\)</span>过小，收敛过程极度缓慢；<span class="math inline">\(\eta\)</span>过大，可能造成损失函数在最小点附近波动甚至发散。学习率的调整是神经网络训练过程中一个重要的调整参数，常常使人头痛不已，因此也出现了很多学习率自适应调整的算法，将在下面深入分析这些算法的优劣。</p><p>有了优化模型及最基础的求解方法后，我们需要对其性质和优缺点进行分析，以便于后续的改进。深度学习的优化问题大多是非凸的，因此存在很多挑战：</p><ol type="1"><li>局部最优：对于凸优化问题，局部最优即是全局最优。然而对于非凸问题，当损失函数到达局部最优点时，<span class="math inline">\(J(\Theta)\)</span>的梯度为0，<span class="math inline">\(\Theta\)</span>无法继续更新，损失函数无法继续下降；</li><li>鞍点：该点既不是局部最小也不是全局最小，但是该点的梯度消失，无法继续更新；</li><li>梯度消失/爆炸：由于初始值和激活函数选择不当 (如sigmoid)，当梯度反向回传时，可能在某一层求导后梯度值很小/很大，导致训练速度极其缓慢。因此初始值的选择通常采用很小的随机数，避免收敛到比较差的区域，激活函数通常也会选择ReLU，避免梯度消失问题。</li></ol><p>局部最小和鞍点示意图如下： <img src="https://img-blog.csdnimg.cn/20210710191530881.png" alt="在这里插入图片描述" /> 尤其在高维空间中，鞍点的问题变得更加严重：假设<span class="math inline">\(\Theta\)</span>是一个k维向量，<span class="math inline">\(J(\Theta)\)</span>的海森矩阵就有k个特征值，其梯度为0的点有可能是局部最小（特征值均为正）、局部最大（特征值均为负）或者是鞍点（特征值有正有负）。高维空间中特征值有正有负的概率很大，因此鞍点出现的可能性远大于局部最优点出现的可能性，并且鞍点周围的平坦区域可能很大，需要增加噪声扰动来逃离鞍点。</p><p>由于上述问题的存在，通常很难找到<span class="math inline">\(J(\Theta)\)</span>的全局最优解，但实际上为了减少过拟合的风险我们并不需要训练集上的全局最优，经典的梯度下降就可以带来足够的局部最优。</p><p>分析完优化模型本身的问题，再来看看最基础的GD的问题：目标函数通常是训练集中所有样本的损失的平均值，故目标函数的梯度为： <span class="math display">\[\nabla f(\mathbf{x}) = \frac{1}{n} \sum_{i = 1}^n \nabla f_i(\mathbf{x})\]</span> 如果用Full-batch GD，那么每次迭代每个参数的梯度计算的时间复杂度为<span class="math inline">\(O(n)\)</span>，对于大规模数据，这样的更新速度显然无法令人忍受。</p><p>学习率的选择是一项重要的调参工作，因此学习率的自适应变化就成为了研究热点之一，一些二阶方法应运而生，我们首先来看看牛顿法该如何解决这个问题。</p><p>对于损失函数<span class="math inline">\(f\)</span>，利用泰勒展开式有： <span class="math display">\[f(\mathbf{x} + \boldsymbol{\epsilon}) = f(\mathbf{x}) + \boldsymbol{\epsilon}^\top \nabla f(\mathbf{x}) + \frac{1}{2} \boldsymbol{\epsilon}^\top \nabla^2 f(\mathbf{x}) \boldsymbol{\epsilon} + \mathcal{O}(\|\boldsymbol{\epsilon}\|^3)\]</span> 式中的<span class="math inline">\(\nabla^2 f(\mathbf{x})\)</span>即<span class="math inline">\(d*d\)</span>海森矩阵，存储了函数的二阶偏导数。为了求得<span class="math inline">\(f\)</span>的最小值，令上式对<span class="math inline">\(\epsilon\)</span>求导得0，有：<span class="math inline">\(\boldsymbol{\epsilon}=-\nabla f(\mathbf{x})H^{-1}\)</span>，即每次的参数更新为<span class="math inline">\(\mathbf{x} \leftarrow \mathbf{x} - \nabla f(\mathbf{x})H^{-1}\)</span>。二阶近似利用了损失函数的曲率信息，即如果曲率比较小，那么这步更新就会比较大，反之则更新较小。这里没有了学习率，而是通过“梯度的梯度”自动调整步幅，看起来比一阶的梯度下降要好一些。</p><p>然而深度学习的参数空间往往十分巨大，因此存储和计算海森矩阵的逆是不现实的，这也是牛顿法无法在DNN中使用的重要原因。为了缓解这个问题，学术界提出了一些拟牛顿法如L-BFGS等试图去降低存储消耗，但是计算代价仍然很高。</p><p>从以上的分析可以看到：无论是Full-batch GD还是牛顿法，都存在计算消耗大等问题，不适用于深度学习任务的大规模数据集训练，因此已经很少被直接用在深度学习模型中。为了处理这些问题，学术界提出了很多替代的优化算法，因此接下来我将调研分析当前常用的深度学习优化算法 (SGD/Adam...)的优缺点，并结合实例及前沿研究进行相关讨论。 ## Popular Algorithms 优化算法在神经网络的训练中有着举足轻重的作用，选择合适的优化算法可以使得损失函数收敛地更快，同时收敛到更好的区域。目前比较流行的算法有下面几种： ### 1 SGD 尝试用mini-batch的梯度平均值作为整体梯度的无偏估计，参数的更新非常简单，沿着梯度的反方向即是loss下降最快的方向： <span class="math display">\[x_{t+1}=x_t-\alpha\nabla f(x_t)\]</span> 如果是Batch GD并且学习率足够小时可以保证损失函数单调不增。实际使用时一般会采用学习率递减策略保证模型收敛。</p><p>实现也非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -= lr * grads</span><br></pre></td></tr></table></figure><p>SGD存在几个问题：</p><p>首先，如果loss对于不同参数的敏感程度不同，那么收敛过程会在敏感参数方向上抖动： <img src="https://img-blog.csdnimg.cn/20210710192205509.png" /> 对于非常大的参数空间，可能会收敛到不同的区域。 其次，如果loss函数有局部最优或者鞍点，这些点上梯度为0，无法收敛到全局最优； 最后，如果采用mini-batch，那么计算出的梯度值是有噪声的，意味着收敛过程可能会是非常曲折的，也即需要更多时间。 ### 2 SGD+Momentum 为了解决SGD的问题，有学者提出了带有动量的SGD，其思想也很简单：更新参数时不仅考虑当前的梯度方向，还要考虑历史累积梯度方向，如果两者方向一致，那么这一步更新幅度就会增大；如果不一致，就会减弱沿当前梯度的下降幅度。 <span class="math display">\[v_{t+1}=\rho v_t+\nabla f(x_t) \\x_{t+1}=x_t-\alpha v_{t+1}\]</span> <span class="math inline">\(\rho\)</span>可以看作是对历史梯度的衰减，一般取0.9。</p><p>带有动量的SGD实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = rho * v + grads</span><br><span class="line">x -= lr * v</span><br></pre></td></tr></table></figure> 这样就解决了SGD的三个问题： 首先，由于历史梯度的存在，朝敏感方向步进的数量就会减少，会更加平滑的向最优点前进，减小了震荡，加速收敛； 其次，对于局部最优点，虽然当前梯度为0，但是依靠历史梯度可以越过该点继续下降； 最后，梯度噪声引起的震荡可以通过历史梯度互相抵消。 ### 3 Nesterov Momentum Nesterov Momentum由SGD+Momentum衍生而来，SGD+Momentum是将当前点的梯度和速度结合起来，而Nesterov Momentum则是将当前点的速度和下一个近似点的梯度结合起来，意味着我们不是在当前位置去看未来，而是多看了一步，在稍远一些的下一步看未来，可以提前调整步进大小： <img src="https://img-blog.csdnimg.cn/20210710192712932.png" alt="在这里插入图片描述" /> 所以Nesterov Momentum的更新规则为： <span class="math display">\[v_{t+1}=\rho v_t-\alpha\nabla f(x_t+\rho v_t) \\x_{t+1}=x_t+v_{t+1}\]</span> 通常我们希望针对<span class="math inline">\(x_t\)</span>计算梯度，通过简单的变量替换，得到新的更新规则： <span class="math display">\[v_{t+1}=\rho v_t-\alpha\nabla f(x_t) \\x_{t+1}=x_t+v_{t+1}+\rho(v_{t+1}-v_t)\]</span> Nesterov的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v_prev = v</span><br><span class="line">v = rho * v - lr * grads</span><br><span class="line">x += (1 + rho) * v - rho * v_prev</span><br></pre></td></tr></table></figure> ### 4 AdaGrad 前面的几种方法都是设置了一个全局的学习率，AdaGrad则通过引入二阶动量使得学习率可以针对<strong>每个参数</strong>自适应地取值：对于更新频繁的参数，已经有了很多认知，不希望因为单个样本影响太大，所以学习率可以小一些；对于更新稀疏的参数，希望从偶尔出现的能更新该参数的样本中多获得一些信息，所以学习率可以设置地大一些。为了了解参数更新的频繁程度，引入二阶动量——每个维度上历史梯度值的平方和： <span class="math display">\[grad\_squared +=\nabla^2 f(x_t) \\x_{t+1}=x_t-\cfrac{\alpha\nabla f(x_t)}{\sqrt{grad\_squared+10^{-7}}}\]</span> 此时的学习率实质上是<span class="math inline">\(\cfrac{\alpha}{\sqrt{grad\_squared}}\)</span>，为了避免除0，一般分母加上一个很小的平滑项。如果某个参数更新频繁，那么grad_squared就会增大，学习率也就越小。</p><p>AdaGrad的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grad_sq += grads**2</span><br><span class="line">x -= lr * grads / (numpy.sqrt(grad_sq) + eps)</span><br></pre></td></tr></table></figure> AdaGrad的问题在于随着grad_squared单调递增，学习率最终会单调衰减到0，意味着很可能会提早终止训练过程。 ### 5 RMSProp/AdaDelta 为了缓解AdaGrad的学习率变化过于激进的问题，二阶动量的计算不累积全部的历史梯度，只关注过去某段时间内的梯度变化，用指数移动平均值来表示过去某时间段的二阶动量的均值： <span class="math display">\[grad\_squared=decay\_rate*grad\_squared+(1-decay\_rate)\nabla^2 f(x_t) \\x_{t+1}=x_t-\cfrac{\alpha\nabla f(x_t)}{\sqrt{grad\_squared+10^{-7}}}\]</span> decay_rate是一个超参数，一般取值0.9。</p><p>RMSProp的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grad_sq = decay * grad_sq + (1 - decay) * grads**2</span><br><span class="line">x -= lr * grads / (numpy.sqrt(grad_sq) + eps)</span><br></pre></td></tr></table></figure> 因此，RMSProp仍然是通过梯度的大小来调整每个参数的学习率，不过现在学习率不会单调递减。</p><h3 id="adam">6 Adam</h3><p>Adam的出现是集成了一阶动量思想和AdaGrad等的二阶动量思想，即Adaptive Momentum： <span class="math display">\[m_{t+1}=\beta_1m_t+(1-\beta_1)\nabla f(x_t)\\V_{t+1}=\beta_2V_t+(1-\beta_2)\nabla^2 f(x_t)\\x_{t+1}=x_t-\cfrac{\alpha m_{t+1}}{\sqrt{V_{t+1}+10^{-7}}}\]</span> 由于m和V初始化为0，所以开始的几次迭代会偏向取值0，为了弥补这一缺点，又引入了偏差纠正项，完整的Adam算法如下： <span class="math display">\[m=\beta_1m+(1-\beta_1)\nabla f(x_t)\\m_t=\cfrac{m}{1-\beta_1^t}\\V=\beta_2V+(1-\beta_2)\nabla^2 f(x_t)\\V_t=\cfrac{V}{1-\beta_2^t}\\x_{t}=x_{t-1}-\cfrac{\alpha m_{t}}{\sqrt{V_{t}+10^{-7}}}\]</span> Adam的实现： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = beta_1 * m + (1 - beta_1) * grads</span><br><span class="line">m_t = m / (1 - beta_1**t)</span><br><span class="line">v = beta_2 * v + (1 - beta_2) * grads**2</span><br><span class="line">v_t = v / (1 - beta_2**t)</span><br><span class="line">x -= lr * m_t / (numpy.sqrt(v_t) + eps)</span><br></pre></td></tr></table></figure> 如果Adam再加上Nesterov的向后看一步的思想，就是Nadam算法。 ## Experiment 为了对上述算法有更加直观的认识，同时在部分程度上比较不同算法的性能，构造一维函数<span class="math inline">\(f(x)\)</span>作为损失函数，其表达式如下： <span class="math display">\[f(x)=0.01x^2+sin(x)+\frac{1}{3}cos(3x)+\frac{1}{5}sin(5x)+\frac{1}{7}cos(7x)\]</span> 这个损失函数含有大量的局部最小点以及悬崖，如图所示： <img src="https://img-blog.csdnimg.cn/2021071019313296.png" alt="在这里插入图片描述" /> 为了公平起见，比较时将x的初始值设为-29，每种算法的迭代次数均设置为300次，学习率均设置为0.1，迭代过程如下图所示： <img src="https://img-blog.csdnimg.cn/20210710193206336.png" alt="在这里插入图片描述" /> 最终的收敛结果如下表所示： | 算法 | 最终x | 最终损失 | | -------- | ------ | -------- | | SGD | -27.98 | 7.19 | | Momentum | -24.00 | 6.21 | | Nesterov | -24.00 | 6.21 | | AdaGrad | -27.98 | 7.19 | | RMSProp | -28.95 | 9.10 | | Adam | -26.46 | 5.59 |</p><p>从上图和上表可以看到：Adam算法在前期收敛很快，并且最终效果最好，是综合性能最佳的算法；带动量的SGD能够越过一些局部极小值，在没有精细调参的情况下一度达到了和Adam类似的效果；AdaGrad开始时的梯度很大，但是由于学习率过早地减小，最终效果并不出众；这些结果进一步佐证了之前对各种算法的分析。</p><p>如果将学习率设置为0.01，对比如下： <img src="https://img-blog.csdnimg.cn/20210710193256448.png" alt="在这里插入图片描述" /> 可以看到：精调后的Momentum、Nesterov和Adam的效果几乎不相上下，这只是初步调整了学习率参数，如果通过验证集更加精细地调整超参数的值，那么SGD+Momentum完全可以达到甚至超越Adam的表现，当然这也需要人为付出更多的努力，Adam这个烦恼则小得多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Sun Apr 11 18:31:58 2021</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Jingtao Ren</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = tf.constant(<span class="number">3.0</span>)</span><br><span class="line">b = tf.constant(<span class="number">5.0</span>)</span><br><span class="line">c = tf.constant(<span class="number">7.0</span>)</span><br><span class="line">d = tf.constant(<span class="number">0.1</span>)</span><br><span class="line">x = tf.Variable(initial_value=-<span class="number">29.0</span>, name=<span class="string">&quot;x&quot;</span>, dtype=tf.float32)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_f</span>():</span></span><br><span class="line">    x = np.linspace(-<span class="number">30</span>, <span class="number">30</span>, <span class="number">1000</span>)</span><br><span class="line">    <span class="comment"># y = -20.0 * np.exp(b * np.abs(x)) - np.exp(np.cos(c * x)) + 20.0 + np.exp(1)</span></span><br><span class="line">    y = (<span class="number">0.1</span> * x) ** <span class="number">2</span> + np.sin(x) + np.cos(a * x) / a + np.sin(b * x) / b + np.cos(c * x) / c</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Loss Function&#x27;</span>)</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_train</span>(<span class="params">y</span>):</span></span><br><span class="line">    x = np.arange(<span class="number">300</span>)</span><br><span class="line">    labels = [<span class="string">&#x27;SGD&#x27;</span>, <span class="string">&#x27;Momentum&#x27;</span>, <span class="string">&#x27;Nesterov&#x27;</span>, <span class="string">&#x27;AdaGrad&#x27;</span>, <span class="string">&#x27;RMSProp&#x27;</span>, <span class="string">&#x27;Adam&#x27;</span>]</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Iteration&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Loss&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Algorithm Comparison&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):    </span><br><span class="line">        plt.plot(x, y[i], label=labels[i])</span><br><span class="line">        plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span>():</span></span><br><span class="line">    <span class="comment"># y = a * tf.exp(b * tf.abs(x)) - tf.exp(tf.cos(c * x)) - a + tf.exp(tf.constant(1.0))</span></span><br><span class="line">    y = tf.<span class="built_in">pow</span>(d * x, <span class="number">2</span>) + tf.sin(x) + tf.cos(a * x) / a + tf.sin(b * x) / b + tf.cos(c * x) / c</span><br><span class="line">    <span class="keyword">return</span> (y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimize</span>(<span class="params">optimizer, iters = <span class="number">300</span></span>):</span></span><br><span class="line">    y = []</span><br><span class="line">    <span class="comment"># optimizer = tf.keras.optimizers.SGD(learning_rate=0.1)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tf.<span class="built_in">range</span>(iters):</span><br><span class="line">        optimizer.minimize(loss, [x])</span><br><span class="line">        y.append(loss())</span><br><span class="line">    tf.<span class="built_in">print</span>(<span class="string">&quot;Final x = &quot;</span>, x)</span><br><span class="line">    tf.<span class="built_in">print</span>(<span class="string">&quot;Final Loss = &quot;</span>, loss())</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># plot_f()</span></span><br><span class="line">    ops = [tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>), tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>, momentum=<span class="number">0.9</span>),</span><br><span class="line">           tf.keras.optimizers.SGD(learning_rate=<span class="number">0.1</span>, momentum=<span class="number">0.9</span>, nesterov=<span class="literal">True</span>), tf.keras.optimizers.Adagrad(learning_rate=<span class="number">0.1</span>),</span><br><span class="line">           tf.keras.optimizers.Adadelta(learning_rate=<span class="number">0.1</span>, rho=<span class="number">0.9</span>), tf.keras.optimizers.Adam(learning_rate=<span class="number">0.1</span>)]</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        x.assign(-<span class="number">29.0</span>)</span><br><span class="line">        y.append(minimize(ops[i]))</span><br><span class="line">    plot_train(y)</span><br></pre></td></tr></table></figure><p>当然，这个实验非常简单，损失函数形式是一维的，实际中的网络模型参数的数量可能达到百万级别，超高维情况下算法的效率、鲁棒性以及模型最终的泛化能力才是我们真正关心的。</p><p>最后贴2张神图总结下： <img src="https://img-blog.csdnimg.cn/20210306203509952.gif#pic_center" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/2021030620351970.gif#pic_center" alt="在这里插入图片描述" /> ## Research Adam虽然是集大成者，而且也被推荐为起始的默认优化算法，但是一些Paper揭示了Adam的一些问题。 ### 1 过拟合 Berkeley在NIPS 2017的一篇文章指出：如果一个问题有多个全局极优，即使从相同的初始值出发，不同的优化算法也会得到完全不同的结果。文章构造了一个简单的线性可分的二分类问题，证明了SGD在这种情况下测试误差为0，而AdaGrad等自适应方法会把所有的测试样例分为正类，泛化能力极差，也就是根本不能工作。</p><p>随后作者又用VGG+BN+Dropout的网络结构在CIFAR-10数据集上进行了实验： <img src="https://img-blog.csdnimg.cn/20210710193712619.png" alt="在这里插入图片描述" /> 可以看到：前期训练中Adam有优势，但SGD的泛化能力确实比Adam要好。</p><p>最后，为了彻底黑化Adam，文章又用了文本数据集和一些NLP模型做了实验： <img src="https://img-blog.csdnimg.cn/20210710193823396.png" alt="在这里插入图片描述" /> 即便有时候自适应方法的训练loss会更低，但SGD的泛化能力都无一例外地胜过了自适应的方法。自适应方法在训练初期速度很快，但是后期表现平平。</p><p>泛化能力差的原因在于：自适应方法倾向于关注稀疏的特征，因为这些特征对于训练样例的鉴别是很有效的，尤其在训练样例数少而特征较多的数据集中，但是这些特征其实并非关键特征，这样自适应学习率算法出现过拟合的风险就会增大，导致泛化能力不佳，最终的收敛效果不如传统的SGD。 ### 2 二阶动量波动 Google的一篇文章从数学上证明了在某些特定情况下Adam可能不收敛，因为二阶动量取的是某个时间窗口的变化，所以<span class="math inline">\(V_t\)</span>的变化可能会剧烈震荡，尤其在高维情况下，梯度的方差可能随时间波动很大，导致学习率震荡，模型无法收敛。这也是为什么一般<span class="math inline">\(\beta_2\)</span>要取0.999这么大的值，避免二阶动量有太大波动。</p><p>一般认为Adam默认的<span class="math inline">\(\beta_1\)</span>和<span class="math inline">\(\beta_2\)</span>不需要调整，采用默认的0.9和0.999即可。但是这两个超参如果不按这样设置，Adam可能永远不会收敛到最优值。文章从数学上证明了对任意的<span class="math inline">\(\beta_1,\beta_2\in[0,1),\beta_1&lt;\sqrt{\beta_2}\)</span>，都存在一个随机的凸优化问题使得Adam不能收敛到最优解。</p><p>为了避免二阶动量的剧烈震荡，文章对其进行了控制，提出了一个新算法AMSGrad确保模型收敛，<span class="math inline">\(V_t=max(V_{t-1},\beta_2V_{t-1}+(1-\beta_2)\nabla^2 f(x_t))\)</span>。</p><p>作者随后通过人造数据和真实数据进行了实验：</p><p>人造数据上的结果： <img src="https://img-blog.csdnimg.cn/20210710193934596.png" alt="在这里插入图片描述" /> 很显然在Adam没有找到最优解的这些数据上，改进后的算法都表现良好。</p><p>在MNIST上的效果： <img src="https://img-blog.csdnimg.cn/20210710193956571.png" alt="在这里插入图片描述" /> 这篇文章最终获得了2018年ICLR最佳论文，但是引起了很大争议。主要原因在于其构造的令Adam失效的数据在实际情况中出现的概率极低，即使出现也会在数据预处理时被筛掉，因此并没有特别广泛的实际用处。另外，文章过于强调训练集上的损失函数值，甚至有人通过复现表明文章提出的AMSGrad算法在测试数据上表现很差，与原文中的某些结论相互矛盾。 ### 3 学习率下降 arXiv上的一篇文章通过在CIFAR-10上的实验证明Adam在一些情况下虽然速度快，但收敛效果没有SGD好： <img src="https://img-blog.csdnimg.cn/20210710194231292.png" alt="在这里插入图片描述" /> 文章通过实验发现主要原因在于后期Adam的学习率过低，影响了最终效果。文章尝试通过控制学习率下界，提高了最终收敛效果。</p><p>既然Adam后期有问题，那么一个自然的改进就是前期训练使用Adam，用来快速减小loss；后期训练转换为SGD，用稍慢的速度寻找更佳的解甚至是最优解。但是这样也会引入新的问题：在什么时刻切换？切换为SGD后的学习率又该如何设置？</p><p>文章提出了SWATS(Switches from Adam to SGD)策略来解决上面2个问题，在CIFAR-10和CIFAR-100数据集上实验效果看着还不错： <img src="https://img-blog.csdnimg.cn/20210710194309531.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20210710194329636.png" alt="在这里插入图片描述" />这些文章都采用了一些比较极端的数据去探索Adam的不适情况，然而实际中遇到这些极端情况的概率并不大，因此Adam并不失为首选尝试。通过上面的讨论可以看到：SGD和Adam各有优劣，精调后的SGD一般最终会收敛到更好的效果；Adam在训练前期收敛速度快，在稀疏数据上表现更好，对超参不敏感，不需要十分精细的调参。</p><p>如果对优化算法不熟悉，可以先尝试SGD+Nesterov Momentum或者Adam；如果对某个优化算法很精通，那么调参就会相对容易些。如果资源足够，也可以尝试L-BFGS等二阶优化方法。另外，选择之前要充分了解数据的性质，对于比较稀疏的数据可以优先尝试学习率自适应调整的算法。 ## Reference [1] CS231n: Convolutional Neural Networks for Visual Recognition. lecture 8, Stanford University. [2] The Marginal Value of Adaptive Gradient Methods in Machine Learning. NIPS'17 [3] On the Convergence of Adam and Beyond. ICLR'18 [4] Improving Generalization Performance by Switching from Adam to SGD. arXiv [5] Optimization methods for large-scale machine learning. SIAM Review, 2018. [6] Optimization for deep learning: theory and algorithms. arXiv, 2019. [7] Understanding Black-box Predictions via Influence Functions. ICML'17. [8] Understanding Deep Learning Requires Rethinking Generalization. ICLR'17.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradient Boosting</title>
      <link href="/2021/06/17/Gradient%20Boosting/"/>
      <url>/2021/06/17/Gradient%20Boosting/</url>
      
        <content type="html"><![CDATA[<h2 id="gradient-boosting-regression">Gradient Boosting Regression</h2><h2 id="gradient-boosting-classification">Gradient Boosting Classification</h2><h2 id="xgboost">XGBoost</h2><h2 id="决策树集成">决策树集成</h2><p>集成学习可以组合多个基学习器，产生更加优异的性能。将决策树（如CART）作为基学习器，结合每个基学习器的预测结果作为最终输出，就像<a href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html">下图</a>这样： <img src="https://img-blog.csdnimg.cn/2021061621501811.png" alt="在这里插入图片描述" /> 正式一些的表示： <span class="math display">\[\hat{y}_i = \sum_{k=1}^K f_k(x_i), f_k \in \mathcal{F}\]</span> 其中，<span class="math inline">\(K\)</span>是决策树个数，<span class="math inline">\(f_k(x_i)\)</span>表示第<span class="math inline">\(k\)</span>个决策树的预测值。</p><p>为了定量描述模型参数与训练数据的匹配程度，我们还要定义待优化的目标函数： <span class="math display">\[\text{obj}(\theta) = \sum_i^n l(y_i, \hat{y}_i) + \sum_{k=1}^K \Omega(f_k)\]</span> ## Boosting Decision Tree 集成多棵树的方式可以是Bagging，也可以是Boosting。Boosting的motivation是用一棵新树不断拟合当前的集成模型与真实值的残差，拟合后将该树也加入模型中，即所谓的Additive Training： <span class="math display">\[\hat{y}_i^{(0)} = 0\\\hat{y}_i^{(1)} = f_1(x_i) = \hat{y}_i^{(0)} + f_1(x_i)\\\hat{y}_i^{(2)} = f_1(x_i) + f_2(x_i)= \hat{y}_i^{(1)} + f_2(x_i)\\\dots\\\hat{y}_i^{(t)} = \sum_{k=1}^t f_k(x_i)= \hat{y}_i^{(t-1)} + f_t(x_i)\]</span> 好了，接下来的问题就是每次迭代时的那棵新树<span class="math inline">\(f_t\)</span>要怎么训练呢？一个直观的想法就是选择那棵令目标函数最小的树： <span class="math display">\[\text{obj}^{(t)} = \sum_{i=1}^n l(y_i, \hat{y}_i^{(t)}) + \sum_{i=1}^t\Omega(f_i) \\          = \sum_{i=1}^n l(y_i, \hat{y}_i^{(t-1)} + f_t(x_i)) + \Omega(f_t) + \mathrm{constant}\]</span> 我们先选择MSE作为损失函数，看看会发生什么： <span class="math display">\[{obj}^{(t)} = \sum_{i=1}^n (y_i - (\hat{y}_i^{(t-1)} + f_t(x_i)))^2 + \sum_{i=1}^t\Omega(f_i) \\          = \sum_{i=1}^n [2(\hat{y}_i^{(t-1)} - y_i)f_t(x_i) + f_t(x_i)^2] + \Omega(f_t) + \mathrm{constant}\]</span> 虽然MSE的形式比较友好，但是如果选择其它损失函数就很难有上式那般人性了，吃得太饱的同学可以试试logistic loss： <span class="math display">\[L(\theta) = \sum_i[ y_i\ln (1+e^{-\hat{y}_i}) + (1-y_i)\ln (1+e^{\hat{y}_i})]\]</span> 为了增强可扩展性、便于计算，一般采用损失函数的二阶泰勒展开去做一个近似： <span class="math display">\[\text{obj}^{(t)} = \sum_{i=1}^n [l(y_i, \hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i)] + \Omega(f_t) + \mathrm{constant}\]</span> 其中，<span class="math inline">\(g_i = \partial_{\hat{y}_i^{(t-1)}} l(y_i, \hat{y}_i^{(t-1)}),h_i = \partial_{\hat{y}_i^{(t-1)}}^2 l(y_i, \hat{y}_i^{(t-1)})\)</span>。 扔掉所有常数项，就得到了第<span class="math inline">\(t\)</span>步的目标函数： <span class="math display">\[\sum_{i=1}^n [g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i)] + \Omega(f_t)\]</span></p><p>弄完了training loss，接着还得研究下正则项<span class="math inline">\(\Omega(f_t)\)</span>，首先得给<span class="math inline">\(f(x)\)</span>来一个正式点的定义： <span class="math display">\[f_t(x) = w_{q(x)}, w \in R^T, q:R^d\rightarrow \{1,2,\cdots,T\} .\]</span> 其中，<span class="math inline">\(w\)</span>是叶子结点的得分向量，<span class="math inline">\(q\)</span>是将样本点映射到对应叶子的函数，<span class="math inline">\(T\)</span>是叶子数目。 如果有点抽象，就看看上图中的左子图吧：<span class="math inline">\(w=[2,-1],f(男孩)=w_{q(男孩)}=w_0=2\)</span>。</p><p>模型复杂度的具体定义随你了，XGBoost是这么定义的： <span class="math display">\[\Omega(f) = \gamma T + \frac{1}{2}\lambda \sum_{j=1}^T w_j^2\]</span> 就用上式重新写出我们第<span class="math inline">\(t\)</span>步的目标函数： <span class="math display">\[\text{obj}^{(t)} \approx \sum_{i=1}^n [g_i w_{q(x_i)} + \frac{1}{2} h_i w_{q(x_i)}^2] + \gamma T + \frac{1}{2}\lambda \sum_{j=1}^T w_j^2\\= \sum^T_{j=1} [(\sum_{i\in I_j} g_i) w_j + \frac{1}{2} (\sum_{i\in I_j} h_i + \lambda) w_j^2 ] + \gamma T\]</span> 其中，<span class="math inline">\(I_j = \{i|q(x_i)=j\}\)</span>表示第<span class="math inline">\(j\)</span>个叶子中样本点的索引集合，由于任意一个叶子中样本点得分相同，因此上式写成了对<span class="math inline">\(T\)</span>个叶子的求和。</p><p>令<span class="math inline">\(G_j = \sum_{i\in I_j} g_i\)</span>及<span class="math inline">\(H_j = \sum_{i\in I_j} h_i\)</span>，就有了一个相对简洁的表示： <span class="math display">\[\text{obj}^{(t)} = \sum^T_{j=1} [G_jw_j + \frac{1}{2} (H_j+\lambda) w_j^2] +\gamma T\]</span> 因为叶子之间相互独立，所以令目标函数最优的得分向量<span class="math inline">\(w\)</span>为： <span class="math display">\[w_j^\ast = -\frac{G_j}{H_j+\lambda}\\\text{obj}^\ast = -\frac{1}{2} \sum_{j=1}^T \frac{G_j^2}{H_j+\lambda} + \gamma T\]</span> 目标函数<span class="math inline">\(obj^*\)</span>的值衡量着本次迭代树结构<span class="math inline">\(q(x)\)</span>对训练数据的拟合程度。</p><p>云里雾里一大堆，我都烦了，来看个例子： <img src="https://img-blog.csdnimg.cn/2021061716123725.png" alt="在这里插入图片描述" /> 假设在第<span class="math inline">\(t\)</span>次迭代选了这么一棵树，按照if-then规则将训练样本分到相应的叶子，将梯度信息相加得到每个叶子对应的<span class="math inline">\(G,H\)</span>，接着用<span class="math inline">\(obj^*\)</span>计算这棵树最小的损失，不行就换一种树结构，以求减小<span class="math inline">\(obj^*\)</span>。</p><p>忙活了大半天，终于知道了怎么度量一棵树的好坏。那么只要枚举所有可能的树结构，选那个令<span class="math inline">\(obj^*\)</span>最小的就好了。傻子都知道这是不行滴，所以只能贪心地一层一层地剥开你的心...哦不对，一层一层地优化：将结点分类为左孩子和右孩子的得分增益为： <span class="math display">\[Gain = \frac{1}{2} \left[\frac{G_L^2}{H_L+\lambda}+\frac{G_R^2}{H_R+\lambda}-\frac{(G_L+G_R)^2}{H_L+H_R+\lambda}\right] - \gamma\]</span> 其中，第一/二项分别表示左/右孩子的分数，第三项表示原始节点的分数，最后一项表示增加叶子的惩罚。可以看到：如果分裂后的得分增益小于<span class="math inline">\(\gamma\)</span>，就不要继续分了，凑合过吧...</p><p>为了在每层获取到最佳的分裂点，通常先将训练数据排个序： <img src="https://img-blog.csdnimg.cn/20210617164041605.png" alt="在这里插入图片描述" /> 暴力枚举一遍分裂点找最优就可以啦！</p><ul><li><span class="math inline">\(f_0(x)=0\)</span></li><li>对于第m棵树的训练：<ul><li>首先计算每条训练数据的残差：<span class="math inline">\(r_{mi}=y_i-f_{m-1}(x_i),i=1,2...,N\)</span></li><li>接着通过拟合上面得到的残差数据，训练出回归树<span class="math inline">\(T_m(x)\)</span></li><li>此时第m棵树的输出即为<span class="math inline">\(f_m(x)=f_{m-1}(x)+T_m(x)\)</span></li></ul></li><li>进行M次训练后得到最终的模型</li></ul><p>可以看到：Boosting Decision Tree每次迭代都将上一轮预测结果的残差作为当前的训练集，对于平方损失容易求得损失函数最小值的点，但是对于稍复杂的损失函数，残差的获得就只能通过负梯度<span class="math inline">\(\frac{\partial L(y_i,f(x_i))}{f(x_i)}\)</span>去逼近，这就是GBDT的核心思想。 GBDT的训练与Boosting Decision Tree很相似：</p><ul><li>初始化弱学习器<span class="math inline">\(f_0(x)=\underset{c}{arg\ min}\sum_{i=1}^{N}L(y_i,c)\)</span>，如果损失函数是MSE，那么<span class="math inline">\(f_0(x)=\frac{1}{N}\sum_{i=1}^{N}y_i\)</span></li><li>对于第m棵树的训练：<ul><li>计算负梯度：<span class="math inline">\(r_{mi}=-\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)},f(x)=f_{m-1}(x)\)</span></li><li>得到新的训练集<span class="math inline">\((x_i,r_{mi})\)</span>，训练产生一棵新的回归树，对应的叶子结点域为<span class="math inline">\(R_{mj},j=1,...,J\)</span>，<span class="math inline">\(J\)</span>为叶子结点个数</li><li>对第j个叶子结点，计算最佳拟合值：<span class="math inline">\(c_{mj}=\underset{c}{arg\ min}\sum_{x_i\in R_{mj}}L(y_i,f_{m-1}(x_i)+c)\)</span></li><li>更新强学习器：<span class="math inline">\(f_m(x)=f_{m-1}(x)+\sum_{i=1}^{J}c_{mj}I(x\in R_{mj})\)</span></li></ul></li><li>最终的学习器为：<span class="math inline">\(\hat f(x)=f_M(x)=f_0(x)+\sum_{m=1}^{M}\sum_{j=1}^{J}c_{mj}I(x\in R_{mj})\)</span></li></ul><h2 id="implementation">Implementation</h2><h2 id="properties">Properties</h2><ol type="1"><li>extrapolate问题 众所周知随机森林回归是不具备推理能力的，那么XGBoost可以吗？ 答案是可以，因为梯度提升模型并不直接根据训练集的结果做预测，而是通过一系列树的加和得到，加和结果取决于每棵树的权重，权重则是由损失函数的一二阶梯度优化得来，并不依赖于训练集的上下限。</li><li>缺失值问题 GBDT/GBRT自身不支持缺失值的自动填充，例如使用sklearn中的GradientBoostingRegressor在训练数据包含缺失值时将无法训练，人工填充可能会引入偏差，但是XGBoost却可以自动地处理缺失值（但并不是填充）。 根据陈天奇大佬的说法： &gt; Internally, XGBoost will automatically learn what is the best direction to go when a value is missing. Equivalently, this can be viewed as automatically "learn" what is the best imputation value for missing values based on reduction on training loss.</li></ol><p>那么究竟是如何自动学习最佳的分裂方向呢？ 假设在结点A有50条训练样本，并且该结点只有一个可能的分割点：比如只有一个二元特征x，那么分割点就只有该特征取值为0或1，这样训练数据可以被分为3组： 1. x取值为B的20条样例 2. x取值为C的20条样例 3. x缺失的10条样例，叫做M组</p><p>那么M组的样例会被分别赋到B和C，接着计算<span class="math inline">\(\{(B,M),C\}\)</span>和<span class="math inline">\(\{B,(C,M)\}\)</span>的得分及损失函数衰减，两者中选择损失函数衰减大的。 如果使用MSE作为损失函数，并且B的标签均值为5，C的标签均值为10，M的标签均值为0。 如果使用<span class="math inline">\(\{(B,M),C\}\)</span>：<span class="math inline">\(\frac{|M|}{|B| + |M|}\text{mean}(M) + \frac{|B|}{|M|+|B|}\text{mean}(B) = \frac{10}{30}0 + \frac{20}{30}5 = 3.\overline{3}\)</span> 如果使用<span class="math inline">\(\{B,(C,M)\}\)</span>：<span class="math inline">\(\frac{|M|}{|C| + |M|}\text{mean}(M) + \frac{|C|}{|M|+|C|}\text{mean}(C) = \frac{10}{30}0 + \frac{20}{30}10 = 6.\overline{3}\)</span> 最后计算两者的MSE与划分前MSE的差，选择使得MSE下降更快的作为分裂方向（也就是得分gain更大的方向）。</p><p>在寻找最优特征分裂点（如年龄＜20还是年龄＜30）时，只访问该特征不含缺失值的训练样例，即如果年龄缺失，就不参与20和30的决策，这样计算复杂度也就降低了，尤其是对于稀疏数据。</p><p>预测时的缺失值有２种情况： 1.　训练阶段已经见识过该缺失值了：按照训练时选定的方向往下走就行 2.　训练阶段该特征没有缺失：默认走向右子树。</p><p>Ref里还有一个更加全面的例子，训练集有6个小孩，只有一个特征年龄（其中有2个样例年龄缺失），标签是身高，初始预测值为0.5，接下来每棵树都要拟合残差。 | Age | Height | Res | | ------------ | ------------ | ------------ | | 7 | 130 | －129.5 | | 9 | 148 | －147.5 | | 6 | 115 | －114.5 | | 15 | 164 | －163.5 | | ？ | 125 | －124.5 | | ？ | 140 | －139.5 |</p><p>接着要根据年龄特征寻找最优的分裂点，将年龄排序并选择中点（<strong>注意：这里就不考虑缺失值样例了</strong>），因此候选分裂点有6.5，8，12，对于每个候选点，分别计算将缺失样例划到左子树和右子树的Quality/Similarity Score：</p><p><span class="math display">\[Quality\ Score=\frac{(\sum residuals)^2}{\#residuals + \lambda}\]</span></p><p>比如，对于分裂点6.5： 如果划到左子树：<span class="math inline">\(Gain＝划分后的Quality\ Score－划分前的Quality\ Score＝\frac{(-114.5-124.5-139.5)^2}{3} + \frac{(-129.5-147.5-163.5)^2}{3} - \frac{(-129.5-147.5-114.5-163.5-124.5-139.5)^2}{6}=640.7\)</span> 如果划到右子树：<span class="math inline">\(Gain＝划分后的Quality\ Score－划分前的Quality\ Score＝580.8\)</span></p><p>接着对于8：1083；630.8 对于12：874.8；216 从中选择gain最大的（也就是使得损失函数最小的），分裂点选8，缺失值划到左子树。 ## Bug <a href="https://www.lycecho.com/archives/2364">PYTHON XGBOOST 报错 KEYERROR: ‘BASE_SCORE’</a></p><h2 id="references">References</h2><p><a href="https://www.youtube.com/watch?v=3CC4N4z3GJc"><strong>Gradient Boost</strong></a> <a href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html">Introduction to Boosted Trees</a> <a href="https://datascience.stackexchange.com/questions/15305/how-does-xgboost-learn-what-are-the-inputs-for-missing-values">Missing values in XGBoost</a> <a href="https://stats.stackexchange.com/questions/304962/is-is-possible-for-a-gradient-boosting-regression-to-predict-values-outside-of-t">Is is possible for a gradient boosting regression to predict values outside of the range seen in its training data?</a> <a href="https://datascience.stackexchange.com/questions/77234/can-boosted-trees-predict-below-the-minimum-value-of-the-training-label">Can Boosted Trees predict below the minimum value of the training label?</a> <a href="https://github.com/dmlc/xgboost/issues/1581#issuecomment-249853718">Why does XGBoost regression predict completely unseen values?</a> <a href="https://medium.com/hypatai/how-xgboost-handles-sparsities-arising-from-of-missing-data-with-an-example-90ce8e4ba9ca">How XGBoost Handles Sparsities Arising From of Missing Data? (With an Example)</a> <a href="https://www.youtube.com/watch?v=OtD8wVaFm6E"><strong>XGBoost Regression</strong></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Learn to Learn</title>
      <link href="/2021/06/03/Learn%20to%20Learn/"/>
      <url>/2021/06/03/Learn%20to%20Learn/</url>
      
        <content type="html"><![CDATA[<p>上了十几年学，依然不会学习。不知是因为中学一些糟糕习惯的延续，还是当代知识难度的加深，我总是感受到日常学习的辛苦：身体累、脑子累、心也累。</p><p>刻苦的确是一种很好的品质，但这种品质有些时候未免有些夸大其词了。傻傻地机械地重复在中学时代那种应试环境或许可以带来一些成绩的提升，但是显然已经不适应现在的我。我尝试将每天安排得满满当当，恨不得每一分每一秒都在学习，然而效果却并不如人意。</p><p>除了智力等一些先天因素外，我个人觉得有以下几点问题：</p><ol type="1"><li>没有找到合适的学习方法，缺乏深度思考和知识体系。我总是试图单点单点地掌握未知的知识点，试图掌握每一处细节，甚至使用死记硬背的方式处理核心问题。笔记和博客也多是摘抄型，独立理解实现太少。</li><li>效率低下。尽管学习时长可能足够，但是且不说大多时间都在摸鱼，即使纯粹学习时间也经常犯困，无法专注完成手头的某项任务，总是过于频繁地切换。效率*时长=最终效果自然不会很好。</li><li>单打独斗。周围少有一起交流进步的伙伴，遇到问题只能单向地从互联网获取信息，没法通过讨论等形式取得快速进步。</li></ol><p>最近看了Marty Lobdell的一个演讲Study Less, Study Smart(<a href="https://www.youtube.com/watch?v=IlU-zDU6aQ0">YouTube</a>/<a href="https://www.bilibili.com/video/BV1Pz4y1f7oi">B站</a>)，有些启发，但是如何学习这种事是绝没有普适准则的，只能结合自身实际摸索总结。Marty还写了一本同名的书，内容比演讲稍微细化一些。</p><p>Marty认为比较重要的有：</p><ol type="1"><li>番茄工作法。每学习25~30min应该休息5min，可以听一首音乐、出去上个厕所、吃点喝点、回消息等等，这样再次回来后注意力和效率又会回升到一个较高的水平，而非效率指数级下降的持续长时间学习。完成一天的工作后，对自己进行更丰厚一些的奖励，比如看个电影、吃顿大餐等等，以形成正反馈。</li><li>寻找一个专门的学习地点，书桌是用来学习的，床是用来睡觉的。Intend to learn rather than incidental learn.</li><li>费曼学习法。看完材料后，深加工以后尝试用自己的话复述给别人听，能准确复述或者能把别人讲懂才行。</li><li>对于学习材料要SQ4R(Survey, Question, Read, Record, Recite, Review)，要主动理解思考自己的笔记，产生更加深刻的认识，而非机械地摘抄背诵。</li><li>高质量睡眠、高质量运动。</li></ol><p>结合自身缺点和学科特点，我认为可以有以下改进措施：</p><ol type="1"><li>每学习一个新东西，理解算法流程、数学推导、实现细节等确实重要，但更重要的是领会方法的思想动机，掌握优缺点和应用场景，将其纳入知识体系中，也就是所谓的“解决现实问题的能力”。</li><li>合理安排学习计划，劳逸结合。不要安排得过于紧密，也不要过于松散。制定的目标不能模棱两可，要有可评估性，即某段时间里要扎扎实实做完TODO LIST上的某件事。</li><li>组队学习，提出自己的问题，解答别人的问题。</li><li>累了就休息，不要在低效率状态下学习工作。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>人生永远艰难</title>
      <link href="/2021/05/23/%E4%BA%BA%E7%94%9F%E6%B0%B8%E8%BF%9C%E8%89%B0%E9%9A%BE/"/>
      <url>/2021/05/23/%E4%BA%BA%E7%94%9F%E6%B0%B8%E8%BF%9C%E8%89%B0%E9%9A%BE/</url>
      
        <content type="html"><![CDATA[<p>很抱歉在这样一个美好的日子用了这样一个忧伤的标题，有感于最近所闻所思，实在难以入眠，索性爬起来，聊作记录。</p><p>昨天新垣结衣宣布结婚，一大堆宅男苦嚎自己痛失老婆，我并非宅男，也不是新垣的粉丝，不过我的心情并不比那些粉丝们好到哪里去。</p><p>研一即将结束，回顾过去几个月的生活学习，很难谈得上满意。庆幸的是，其中的问题大概率并不是因为我。</p><p>不知道是现实的压力还是社会的风气，周围的人大部分好像都陷入了一种病态的狂热之中，每天聊天的话题永远都是发文章、奖学金、出去实习、如何毕业以及毕业后去哪上班。不光是实验室的人这样，好像所有人都这样，哪怕是曾经散发着耀眼的理想主义光芒的朋友也有被侵蚀到。以我所在的计算机实验室为例：你永远感受不到ta们对于计算机科学的发自内心的热爱，当然更加谈不上ta们有什么理想，有的只是无聊的功利心和对结果的病态渴求，因此你永远看不到ta们enjoy的过程，相反，这种追求会令人痛苦。</p><p>我压根不想理这帮人，仔细想想：我在这个地方基本没有朋友，当然我也不想结交这些所谓的朋友。</p><p>关于实验室和学校的环境，更是无数同学包括我在内的梦魇。学校和学院一方面声称要力破五唯，另一方面却更加变本加厉地用文章数目决定毕业规则，真是又当婊子又立牌坊。实验室的环境则更加不可思议，大老板王某是官宦之家，并且年纪轻轻就被聘请为正教授，当然他的学术水平还是很高的，发了一些顶尖的期刊，可是他对实验室的管理堪称灾难，并且我严重怀疑他精神受过一定程度刺激，或者先天性格古怪，这绝不是开玩笑。</p><p>典型的“笑面虎”，他对硕士生基本没有任何有效的指导，指派的课题也许压根没有经过慎重考虑，甚至在研二学长即将完成课题的情况下，组会上狠批其工作没有创新点，不足以满足要求，导致该学长只能临时更换课题。我进组这几个月以来，组里的博士生一个因为开题答辩不过退学，一个博三学姐彻底脱离了电信学部，转去了社会科学，一个研二学长开题不过转至其他组。目前选他课题的同门都痛不欲生，发微信不回，开组会除了一直问为什么、或者一直重复那些正确的废话以外传达不出任何有效的指导信息，总是哼哼哈哈应付了事。</p><p>组里目前有6个老师，除了王，还有张某，临近退休，很明显也是在混日子等死，并且对相关课题没有任何见解，名下的学生都只能选择其他老师的课题，这种奇葩除了对考勤工作格外关心、组会时怼怼学生，基本没有任何用处，不知道这种人才当年怎么评上教授的，这也从侧面反映了西交的裙带有多么严重，这些破事暂且不表。还有2个很年轻的助理教授，她们自己科研压力也很大，自然没时间指导我们。剩下的一个赖，一个朱，人品都十分堪忧，对学生也是极尽压榨。朱基本没有任何学术能力，可以说对机器学习一窍不通，也完全不会follow最新的科研进展，只会找学生要结果和抢学生的一作。最搞笑的就是：文章已经投出去了，她自己连文章里的算法都没懂，真不知道之前哪里来的勇气给我改论文...朱还总是喜欢让学生干些杂七杂八的事并且认为理所应当（建个qq群也要让学生来），并且会不时打小报告，背后捅你一刀哦（我自己就挨过几刀）~好像天底下只有她自己的事最重要，别人都应该为她服务。最可笑的是：这人总是把自己伪装成指路名师，但实际上她只关心自己的利益和前途（通过抢一作实现），学生的死活和去向她压根不会在乎，更别说给你推荐工作什么的。</p><p>组里目前还没有毕业的博士生，并且30个人做的方向可以说应有尽有，完全不搭嘎。王主要研究生信，张没有任何研究方向，赖研究统计，朱做自动机器学习，如此分散的方向导致极其缺乏学长学姐的帮带，所有的坑都要自己重新踩一遍。因此组里的成果并不稳定，加上王自己心思已经完全不在科研上，他甚至在组会上很自豪地说自己现在主要在终南山上研究茶艺，并且说自己代表作已经够了，大有功成名就的感觉。的确，这种情况下，学生基本可以忽略不计。</p><p>人生真是魔幻啊！你能主动控制的东西少之又少，当时找导师就想着避坑，谁曾想还是如此。我觉得现在唯一支撑着我的，就是我对CS的仅存的一丝丝喜爱，你知道，在这种教育环境下保留着这种喜爱是多么奢侈的一件事吗？再次感谢一些前辈的指点，感谢众多国外高校的公开课。我告诉自己每天都要有充电时间，晚上学一些自己感兴趣的东西。</p><p>理想主义者总是看起来有些幼稚，甚至有些悲凉。我性格里有反抗基因，讨厌规则的约束，也会用实际行动反对，但我清楚自己不是一个彻底的决绝的人，没法彻底逃离，但是底线是不要把自己搞得太卑微。</p><p>每个人都有自己的生活方式，不必艳羡别人，未来的npy至少要有些理想主义气质，否则我真的不知道该如何相处。偶尔会想，是我把自己搞得太复杂了吗，是我每天想太多东西吗？我觉得像别人那样简简单单生活也不错啊，每天聊聊考试，作业，科研，去哪吃饭。可是我真的不是这样子合群，我太独立，太散漫，太逆反，我希望别人和我一样，可是这怎么可能呢？周围没有一个人和我一样，我有些孤独。cyq带我快乐吧，一起幸福吧。</p><p>我的要求并不算很高：</p><ol type="1"><li>一个志同道合的朋友，一起学习聊天啥的</li><li>顺利毕业</li><li>找个差不多的工作就行了，每天过得幸福快乐就好了</li></ol><p><strong>事已至此，我觉得被负面情绪笼罩没有什么，但是抱怨无法解决任何问题，而且会让人变得焦躁，我应该更多地专注于自己能做些什么，而不是像愤青一样整日咒骂</strong>。我觉得以后比较重要的几点是：</p><ol type="1"><li>遇到问题，分析原因，冷静地尝试解决问题，尽量少地被外界环境影响；</li><li>静下心来，汲取知识。试着成为一个创新者，而不是成为一个抄袭者，积累找工作的资本；</li><li>要好好学习了呢，贼认真的那种。Code everyday by yourself！</li><li>永远不要压抑自己的感情，无论是热爱，喜悦，还是悲伤，迷惘；</li><li>晚上不要梦想些有的没的，最好还是反思下自己一天的生活，做点感恩的事；</li><li>学琴，学开车！</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dealing with Imbalanced Datasets</title>
      <link href="/2021/05/07/Dealing%20with%20Imbalanced%20Datasets/"/>
      <url>/2021/05/07/Dealing%20with%20Imbalanced%20Datasets/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>The Imbalanced Datasets are very common in our life such as illegal users or illness check. The machine learning model always performs bad on these datasets if there are no specific dealings, especially the prediction accuracy of minority class. For example, if the data is highly imbalanced such as 9995(negative):5(positive), then if your model just let every instance to be negative and you can get an acc of 99.95% but the result is meaningless. Another example is that misclassifying the minority is very severe. Assume that you misclassify the patient as normal. Oh my god!</p><p>So researchers proposed two kinds of methods for this problem:</p><ul><li>Cost Sensitive Learning When <strong>training</strong> your model, it will give different classes different weights in the <strong>loss function</strong> thus let the model focus more on the minority class. In sklearn, there are <code>class_weight</code> and <code>sample_weight</code> for you. For <code>class_weight</code>, you can specify the weights for different classes such as <code>&#123;0:0.1,1:0.9&#125;</code> or you can set it to <code>balanced</code> then weights will be computed by <span class="math inline">\(\frac{\#samples}{\#classes\ *\ np.bincount(y)}\)</span>. For <code>fit(sample_weight=)</code>, you give <strong>every instance</strong> different weights. When computing the loss for the instance, it will be <code>class_weight</code> * <code>sample_weight</code> * <code>loss</code>.</li><li>Sampling Sampling means that we will change the original dataset rather than giving them different weights.</li></ul><h2 id="sampling-methods">Sampling Methods</h2><p>Over-sampling means to increment the minority class.</p><ul><li>Random Over Sampling To sample from minority class with replacement to let the number of each class is 1:1. Overfitting on minority class.</li><li>Synthetic Minority Oversampling Technique (SMOTE) <span class="math display">\[x_{new}=x_i+\lambda(x_{zi}-x_i)\]</span> First you find the <code>k_neighbors</code> of <span class="math inline">\(x_i\)</span> in the minority class, then just select one <span class="math inline">\(x_{zi}\)</span> randomly and produce the new one. There are some variants such as borderline SMOTE, SVM SMOTE and KMeans SMOTE.</li><li>Adaptive Synthetic (ADASYN) The difference between SMOTE and ADASYN is that SMOTE will generate new samples for random minority data until 1:1. But ADASYN will automatically decide the number of new points generated for each <span class="math inline">\(x_i\)</span>. There will be more points generated if there are more majority data around <span class="math inline">\(x_i\)</span>.</li></ul><p>Under-sampling means to decrease the majority class.</p><ul><li>RUS Data waste.</li><li></li></ul><h2 id="example">Example</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>彻底作别</title>
      <link href="/2021/05/02/%E5%BD%BB%E5%BA%95%E4%BD%9C%E5%88%AB/"/>
      <url>/2021/05/02/%E5%BD%BB%E5%BA%95%E4%BD%9C%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>还有2天我就23岁半了，趁着五一假期的闲暇，又翻了翻过去的相册，一时间百感交集，差点泪流满面：既怀念那段朦胧的时光，又对比着现在的窘境，伴着耳机里杰伦的歌，我觉得是时候做一个彻底的告别了，尽管这本该就是早早封存的记忆。</p><p>之前虽然说过已经开始了崭新的人生，但现在还是有些想念曾经的一些人、一些事，以至于晚上只能靠着这些记忆和憧憬去入睡，但醒来以后才深切感受到这些倚靠的无力和虚无。很多时候我觉得自己有些矛盾，甚至有抑郁和精神分裂的倾向：一方面我瞧不上现在的环境以及这个环境下的人，另一方面却还要戴着面具在这里生活。我觉得还是因为太过注重于过去的美妙，还是太沉迷于过去的优越，少年得志总归有些不利。</p><p>听着杰伦的歌，翻着过往的点滴，好像大哭一场，告别过去的岁月。有太多太多没敢去做的事，回想起来觉得当年好傻好青涩，如果勇敢一点，如果成熟一点，结果会不会不一样？如今真的长大了，忘记了太多，我变得封闭起来。 现在成熟了，懂事了，却再也没有当年的感觉了！我永远都是感性大于理性， 曾经的我，喜欢足球，喜欢装酷，喜欢所有运动，喜欢写一些虚无缥缈，华丽的词句，喜欢和别人比文采 就让这些过往永远尘封在过去吧，就像加密的相册和说说一样，平时不再触碰，待将来与人分享。我想每个人都有自己的故事，期望能听到分享，而不是庸俗。</p><p>过得很累的原因主要还是在于一直戴着面具生活，跟周围的人无法吐露心声，急切需要找到一个能说心里话的红颜知己，可是那个人究竟在哪呢？是清华的她吗？我不知道，真的不知道！！！</p><p>我还是一直在逃避，究竟在逃避什么，是因为自卑，还是因为自负？或者是社交恐惧？我说不太清楚，无论遇见男女朋友，我的第一反应就是躲避，而不是主动迎上去打招呼。我是多么希望有一天我爱的人也会恰好爱我。</p><p>首先，摆正自己的心态，不要觉得西交的女生都是土，还有就是自己的要求不要太高，自己也就普通人水平。 其次，对待周围的女生，不要装作没看见或者冷脸以待，笑脸相迎，多多聊天。 最后，眼光也不要局限于西交这块，初高中同学只要聊得来，都可以试试。</p><p>不知道此生还有没有人能够打开我心扉。</p><p>以后面对朋友，要多用当下和未来的视角，而非过多沉迷于美妙的梦境。</p><p>Fancy Dream, Poor Memory</p><p>最最重要的，还是要有面对的勇气，豁达面对过往烟云、认真面对当下人事，不念过往、不惧将来。剩下的就只能交给命运了</p><p>属于时间的就让它归于时间吧。希望以后的睡眠更多依赖于当下的小确幸而非无端的想象。祝你我安好，祝来日方长，祝有缘再见！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kick Start 2013</title>
      <link href="/2021/04/22/Kick%20Start%202013/"/>
      <url>/2021/04/22/Kick%20Start%202013/</url>
      
        <content type="html"><![CDATA[<h2 id="practice-round">Practice Round</h2><ol type="1"><li>题目大意：给定一堆人名，从上向下扫描，一旦当前值比前一个的字典序小，就将当前值移动到正确的位置，不论移动多远，代价都是1，求代价总和。</li></ol><p>和插入排序类似，如果当前值<span class="math inline">\(j\)</span>比<span class="math inline">\(j-1\)</span>小，将<span class="math inline">\(j\)</span>移到前面合适的位置，此时前<span class="math inline">\(j\)</span>个数是局部有序的。这道题只要求出代价和即可，不需要输出排序后的结果，不需要真正去移动，只要记录前<span class="math inline">\(j\)</span>个的最大值，如果<span class="math inline">\(j+1\)</span>比最大值小，那么必然触发一次移动。举例： 2 1 5 3 0 j=1, max=2, cost++ 1 2 5 3 0 j=3, max=5, cost++ 1 2 3 5 0 j=0, max=5, cost++ 0 1 2 3 5 有2个地方要注意：<code>cin</code>读入<code>string</code>时，会把空格/回车作为分隔符，遇到即停止，所以要用<code>getline()</code>，默认以回车结束；<code>cin</code>读完<code>int</code>后，换行符<code>\n</code>仍然在输入流里，所以下一次的<code>getline</code>会先读<code>\n</code>，故用<code>cin.get()</code>先取走<code>\n</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, N;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">        cin.<span class="built_in">get</span>();</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">names</span><span class="params">(N)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin, names[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string curMax;</span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                curMax = names[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (names[j].<span class="built_in">compare</span>(curMax) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ++money;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                curMax = names[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; money &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>题目大意：</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Monte-Carlo Tree Search</title>
      <link href="/2021/04/13/Monte-Carlo%20Tree%20Search/"/>
      <url>/2021/04/13/Monte-Carlo%20Tree%20Search/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>We all know that Monte Carlo Simulation is used to estimate some unknown variables through random simulation. It is because that the process is too complicated so we cannot know the true rule behind it. Only god knows. But thankful to the randomness we can do lots of experiments to approach the truth.</p><p>MCTS has the same idea but it is based on a tree. Every path from root to leaf forms a solution and the whole tree defines the search space. It is a heuristic search strategy based on some loss functions. But it will follow not only the loss but also try to explore the unvisited nodes. So it's also trying to make a balance between exploration &amp; exploitation.</p><p>One iteration has 4 processes: Selection, Expansion, Simulation and Backpropagation. Let's start to build the tree. Initially the tree only has a root node. Every node holds 3 info: action list for the next decision; visit times to measure the exploration; quality values to measure the exploitation.</p><ol type="1"><li>Selection Using some criterion to select a child node which is eager to expand. There are 3 possibilities for the current state: If all the actions have been expanded thus the node has finished a complete search, then we will find a child with max UCB value and go down the tree recursively; Else if there are still some actions which have not been expanded (e.g. the node has 20 possible actions but there are 19 child node in the tree), then it will select one action randomly from the unexpanded actions and do Step 2 Expansion; Else game over and do Step 4 Backpropagation.</li><li>Expansion We have found the most eager node N to expand and the action A after Selection. So we need to add a new node S to the tree as N's child node by doing A.</li><li>Simulation/Playout Start from S to let the game run randomly until game over. Then we get a performance to be S's initial quality value.</li><li>Backpropagation The nodes along the path from root to N will update their quality values after S's simulation.</li></ol><p>After some fixed number of iterations or time limit, we will get a large tree and select the best leaf node as the result. Below is a figure: <img src="https://img-blog.csdnimg.cn/20210404201349819.png" alt="在这里插入图片描述" /> ## Upper Confidence Bound (UCB) When we need to select a child node to go down the tree, we usually use UCB criterion: <span class="math display">\[\underset{child}{\operatorname{arg\ max}}(\hat\mu_{child}+C\sqrt\frac{log\ n(s)}{n(child)})\]</span> <span class="math inline">\(\hat\mu_{child}\)</span> is the average reward gathered over all tree-walks with prefix child, <span class="math inline">\(n(s)\)</span> the number of the parent's visits and <span class="math inline">\(C\)</span> is constant controlling exploration &amp; exploitation. UCB tends to select a node with high quality value (for exploitation) and relatively low visit times (for exploration). ## An example 1. Initial tree Actually we only have root node <span class="math inline">\(S_0\)</span>. Assume there are only two actions <span class="math inline">\(A_1\)</span> and <span class="math inline">\(A_2\)</span>. <span class="math inline">\((Q,N)\)</span> means the quality value and #visits of this node. <img src="https://img-blog.csdnimg.cn/20210519201721793.png" alt="在这里插入图片描述" /> 2. First Iteration Since <span class="math inline">\(S_0\)</span> is a leaf node now, we should expand. Since the 2 actions are both unexpanded so we randomly select one (assume we select <span class="math inline">\(A_1\)</span>). Then we add <span class="math inline">\(S_1\)</span> to the tree and playout from <span class="math inline">\(S_1\)</span>. <img src="https://img-blog.csdnimg.cn/20210519202838706.png" alt="在这里插入图片描述" /> Assume we got a performance of 20. Next we need to backpropagate the value to <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_0\)</span> and update Q and #visits. <img src="https://img-blog.csdnimg.cn/20210519203559429.png" alt="在这里插入图片描述" /> We finished the first iteration. 3. Second iteration Start from <span class="math inline">\(S_0\)</span>, since <span class="math inline">\(A_2\)</span> has not been expanded so we have to choose it. Then add <span class="math inline">\(S_2\)</span> to the tree and playout from here. <img src="https://img-blog.csdnimg.cn/2021051921175522.png" alt="在这里插入图片描述" /> Then backpropagate to <span class="math inline">\(S_2\)</span> and <span class="math inline">\(S_0\)</span>: <img src="https://img-blog.csdnimg.cn/20210519212028325.png" alt="在这里插入图片描述" /> 4. Third iteration From <span class="math inline">\(S_0\)</span> there are no unexpanded actions so we need to select one child using UCB (assume C=2). <span class="math inline">\(UCB(S_1)=21.67,UCB(S_2)=11.67\)</span>. Thus we select the leaf node <span class="math inline">\(S_1\)</span>. Assume <span class="math inline">\(S_1\)</span> has 2 unexpanded actions. Choose one randomly (assume <span class="math inline">\(S_3\)</span>) and playout from here and backpropagate, assume we get performance of 0: <img src="https://img-blog.csdnimg.cn/20210519212745377.png" alt="在这里插入图片描述" /> 5. Fourth iteration From root we should decide which one to select. Again using UCB: <span class="math inline">\(UCB(S_1)=11.48,UCB(S_2)=12.10\)</span>. So we choose <span class="math inline">\(S_2\)</span>. Assume there are two unexpanded actions so we randomly choose <span class="math inline">\(S_5\)</span> and playout and get a performance of 14. After backpropagate: <img src="https://img-blog.csdnimg.cn/20210519213431456.png" alt="在这里插入图片描述" /></p><p>Assume the max iteration number is 4 so we get the final tree above. Finally we can select the best solution from <span class="math inline">\(S_0\)</span> to leaf node according to UCB value.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bayesian Optimization</title>
      <link href="/2021/04/06/Bayesian%20Optimization/"/>
      <url>/2021/04/06/Bayesian%20Optimization/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>Hyper-parameters tuning has become an important work during training neural networks. As the number of Hyper-parameter is becoming larger, researchers proposed Grid Search &amp; Random Search to wish to get better combinations of Hyper-parameters. However, Grid Search has a high time cost. Although some experiments showed that Random Search got a better result than Grid Search but the result is still not fulfilling.</p><p>Besides, there are some gradient-based methods to solve the problem. But the objective function is usually not differentiable or even not continuous. Thus these methods have a very finite usage.</p><p>BO is a gradient-free optimization method to get global solutions of a black-box function. The function usually has a high cost to compute such as training a deep neural network after tuning the Hyper-parameters. For this reason, we usually find a <strong>surrogate</strong> function to approximate the original function <span class="math inline">\(f\)</span>. In the field of AutoML, we often use Gaussian Process, Random Forest or deep network as the surrogate model. The simplest form of BO is as follows: <img src="https://img-blog.csdnimg.cn/20210401193953429.png" alt="在这里插入图片描述" /> <span class="math inline">\(f\)</span> represents the black-box function that we want to optimize (black-box means that the function transforms a configuration <span class="math inline">\(x\)</span> to an output but we don't know the exact function relationship). <span class="math inline">\(\chi\)</span> represents the search space of the combination of hyper-parameters. <span class="math inline">\(S\)</span> represents <strong>Acquisition Function</strong> which is used to select the promising <span class="math inline">\(x\)</span>. <span class="math inline">\(M\)</span> represents the surrogate model which takes a configuration <span class="math inline">\(x\)</span> and outputs the performance (much like <span class="math inline">\(f\)</span> does).</p><p>First we need to get some samples from <span class="math inline">\((f,\chi)\)</span>, thus we get <span class="math inline">\(D=(x_i,f(x_i)), i=1...n\)</span>.</p><p>Next we iterate <span class="math inline">\(T\)</span> times (often fixed) to select configuration <span class="math inline">\(x\)</span>. Use the dataset <span class="math inline">\(D\)</span> to train the surrogate model <span class="math inline">\(M\)</span> (much easier than train <span class="math inline">\(f\)</span>). <span class="math inline">\(M\)</span> has several choices such as Random Forest, Tree Parzen Estimators. Here we use GP so we get the probabilistic model <span class="math inline">\(p(y|x,D)\)</span>.</p><p>Then we need to find the most promising configuration <span class="math inline">\(x\)</span>. The most important thing for Acquisition Function is to make a balance between <strong>exploration &amp; exploitation</strong>. It means that when selecting the next <span class="math inline">\(x\)</span> we not only want to select those untried points (exploration) but also want to select those tried points which has a great <span class="math inline">\(f(x)\)</span> (exploitation).</p><p>Finally use the promising <span class="math inline">\(x_i\)</span> to get corresponding performance <span class="math inline">\(y_i\)</span> and join the pair into <span class="math inline">\(D\)</span>. ## Gaussian Process If we assume <span class="math inline">\(x_i\)</span> is independent with each other, the Multivariant Gaussian Distribution's probability density is as follows: <span class="math display">\[p(x_1,...,x_n)=\frac{1}{(2\pi)^{\frac{n}{2}}\sigma_1...\sigma_n}exp(-\frac{1}{2}[\frac{(x_1-\mu_1)^2}{\sigma_1^2}+...+\frac{(x_n-\mu_n)^2}{\sigma_n^2}])\]</span> We can rewrite the formula to the vectorized version: <span class="math display">\[p(x)=(2\pi)^{-\frac{n}{2}}|K|^{-\frac{1}{2}}exp[-\frac{1}{2}(x-\mu)^TK^{-1}(x-\mu)]\]</span> in which <span class="math display">\[K=\left[\begin{matrix}  \sigma_1^2     &amp; 0      &amp; \cdots &amp; 0      \\ 0      &amp; \sigma_2^2      &amp; \cdots &amp; 0      \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0     &amp; 0      &amp; \cdots &amp; \sigma_n^2     \\\end{matrix}\right], x-\mu=[x_1-\mu_1,...,x_n-\mu_n]^T\]</span> Thus <span class="math inline">\(x\sim N(\mu,K)\)</span>, <span class="math inline">\(\mu\)</span> is the mean vector and <span class="math inline">\(K\)</span> is the covariance matrix (a diagonal matrix since the independence).</p><p>But what should we do when <span class="math inline">\(x\)</span> has infinite dimensions? Such as in a continuous temporal T or spatial S. Actually GP means Gaussian Distribution and Stochastic Process (about time T). GP is defined by an infinite number of Random Variables on a continuous domain. In other words, it is an infinite dimension Gaussian Distribution. Formally, let's sample n moments from T: <span class="math inline">\(t_1,...,t_n\in T\)</span>, thus we get a n-dimensional vector <span class="math inline">\((\xi_1,...,\xi_n)\)</span>, if this vector is a n-dimensional Gaussian Distribution then <span class="math inline">\({\xi_t}\)</span> is a GP.</p><p>Let's take an easy example to illustrate: suppose during peoples' life time, at every moment <span class="math inline">\(t\)</span> the energy of the population forms a Gaussian Distribution but different moments have different <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span>: <img src="https://img-blog.csdnimg.cn/20210404141525979.png" alt="在这里插入图片描述" /> If we take 5 moments during a population's life time, then <span class="math inline">\(\xi_1-\xi_5\)</span> all forms Gaussian Distribution but they have different <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span>. If we sample an arbitrary moment <span class="math inline">\(t\)</span> then <span class="math inline">\(\xi(t)\sim N(\mu_t,\sigma_t^2)\)</span>. If we sample at some points and connect them together we get two samples of the GP, as the figure shows.</p><p>Now that we know what happens at <span class="math inline">\(t\)</span>, let's consider the whole <span class="math inline">\(T\)</span>. We know that for a finite Gaussian Distribution, it can be determined by a n-dimensional vector <span class="math inline">\(\mu_n\)</span> (reflects every Random Variable's expectation) and a <span class="math inline">\(n\times n\)</span> matrix <span class="math inline">\(\Sigma\)</span> (reflects every RV's variances and covariance between different dimensions). It is almost the same for GP except that we cannot use a vector to describe every <span class="math inline">\(t\)</span>'s mean since it is infinite. So we need a function <span class="math inline">\(m(t)\)</span> to describe the continuous <span class="math inline">\(T\)</span>. For <span class="math inline">\(\Sigma\)</span> we should use a kernel function <span class="math inline">\(k(s,t)\)</span> to describe the covariance between time <span class="math inline">\(t\)</span> and <span class="math inline">\(s\)</span>. Once <span class="math inline">\(m(t)\)</span> and <span class="math inline">\(k(s,t)\)</span> is defined the GP is determined <span class="math inline">\(\xi_t\sim GP(m(t),k(s,t))\)</span>.</p><p>The most popular kernel function is RBF which is defined as follows: <span class="math display">\[k(s,t)=\sigma^2exp(-\frac{||s-t||^2}{2l^2})\]</span> <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(l\)</span> are two hyper-parameters. If <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> are close in <span class="math inline">\(T\)</span> then the output covariance will be larger and it means the correlation between the two points is bigger.</p><p>Once we have some knowledge about GP we can start to know Gaussian Process Regression, which is a kind of Probabilistic Model. It means that we can use Prior and Observations to calculate Posterior. First we define a GP by <span class="math inline">\(m(t)\)</span> and <span class="math inline">\(k(s,t)\)</span>, which is a Prior. Then we observe some data to revise the GP's <span class="math inline">\(m(t)\)</span> and <span class="math inline">\(k(s,t)\)</span> to get Posterior. But how?</p><p>Here we need to use some Gaussian Distribution's nice properties: Once Gaussian always Gaussian. It means that marginal distribution, summation and conditional distribution of a GD are still GD. Assume a n-dimensional RV <span class="math inline">\(x\sim N(\mu,\Sigma)\)</span> and we divide it into two parts <span class="math inline">\(x_A\)</span> and <span class="math inline">\(x_B\)</span> then we get: <span class="math display">\[x=\begin{bmatrix} x_A\\ x_B \end{bmatrix},\mu=\begin{bmatrix} \mu_A\\ \mu_B \end{bmatrix},\Sigma=\begin{bmatrix} \Sigma_{AA}, \Sigma_{AB} \\ \Sigma_{BA}, \Sigma_{BB} \end{bmatrix}\]</span> Then we can get: <span class="math display">\[x_A|x_B\sim \mathcal{N}(\mu_A+\Sigma_{AB}\Sigma_{BB}^{-1}(x_B-\mu_B),\Sigma_{AA}-\Sigma_{AB}\Sigma_{BB}^{-1}\Sigma_{BA})\]</span> Thus we could update the GD's Posterior parameters. It is much the same in GP. If we get some samples <span class="math inline">\((X,Y)\)</span> then the rest is <span class="math inline">\((X^*,f(X^*))\)</span>. The joint distribution forms an infinite GD: <span class="math display">\[\begin{bmatrix} Y\\ f(X^*) \end{bmatrix}\sim N(\begin{bmatrix} \mu(X)\\ \mu(X^*) \end{bmatrix},\begin{bmatrix} k(X,X), k(X,X^*) \\ k(X^*,X), k(X^*,X^*) \end{bmatrix})\]</span> So we want to know the rest of the points based on the observed points: <span class="math inline">\(f(X^*)|Y\sim N(\mu^*,k^*)\)</span>. <span class="math display">\[\mu^*=\mu(X^*)+k(X^*,X)k(X,X)^{-1}(Y-\mu(X))\\k^*=k(X^*,X^*)-k(X^*,X)k(X,X)^{-1}k(X,X^*)\]</span> Here is an example: <img src="https://img-blog.csdnimg.cn/20210404155244142.png" alt="在这里插入图片描述" /> Finally let's return back to our BO's <span class="math inline">\(M\)</span>. We first assume our prior: <span class="math inline">\(\mu(X)=0,k(X,X^*)=RBF\)</span>. Plus the observed and evaluated <span class="math inline">\(D=\{x_i,y_i\}\)</span> we can get <span class="math inline">\(\hat \mu\)</span> and <span class="math inline">\(\hat{\sigma}^{2}\)</span>, then the posterior prediction is <span class="math inline">\(p(y|x,D)\)</span>, which is still a Gaussian Distribution. The calculation process is as follows: <span class="math display">\[y=(y_1,...,y_i)^T \\\hat \mu=k^T(x)(k+\sigma_{n}^{2}I)^{-1}y \\\hat{\sigma}^{2}=k(x^*x)-k(x)^T(k+\sigma_{n}^{2}I)^{-1}k(x)\]</span> Once we get the posterior prediction <span class="math inline">\(p(y|x,D)\)</span>, we can feed them to the Acquisition Function to get next <span class="math inline">\(x_t\)</span>. ## Acquisition Function There are some popular Acquisition Functions:</p><ol type="1"><li>Upper Confidence Bound (UCB) <span class="math inline">\(x_{t+1}=\underset{x\in X}{\operatorname{arg\ max}}[\mu_{t}(x)+\beta_t^{1/2}\sigma_t(x)]\)</span> The weighted sum of posterior mean and posterior standard deviation. The two items correspond exploitation and exploration, respectively.</li><li>Expected Improvement (EI) <span class="math inline">\(x_{t+1}=\underset{x\in X}{\operatorname{arg\ max}}\ E_{f(x)\sim N(\mu_{t}(x),\sigma_t^2(x))}[max(0,f(x)-f_t^+)]\)</span>, <span class="math inline">\(f_t^+\)</span> is the max observation value during the first <span class="math inline">\(t\)</span> iterations.</li></ol><p>Except the above functions, there are Probability of Improvement, Entropy Search and so on. ## Reference <a href="https://jgoertler.com/visual-exploration-gaussian-processes/">A Visual Exploration of Gaussian Processes</a> <a href="https://www.zhihu.com/question/46631426">如何通俗易懂地介绍Gaussian Process</a> <a href="https://zhuanlan.zhihu.com/p/76269142">贝叶斯优化/Bayesian Optimization</a> <a href="https://github.com/fmfn/BayesianOptimization/blob/master/examples/exploitation_vs_exploration.ipynb">Exploitation vs Exploration</a> <a href="https://github.com/fmfn/BayesianOptimization">BayesianOptimization</a> <a href="https://www.cs.cornell.edu/courses/cs4780/2018fa/lectures/lecturenote15.html">Lecture 15: Gaussian Processes</a> <a href="https://distill.pub/2020/bayesian-optimization/">Exploring Bayesian Optimization</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Inductive Representation Learning on Large Graphs</title>
      <link href="/2021/03/29/Inductive%20Representation%20Learning%20on%20Large%20Graphs/"/>
      <url>/2021/03/29/Inductive%20Representation%20Learning%20on%20Large%20Graphs/</url>
      
        <content type="html"><![CDATA[<p>Stanford的帅哥Jure发在NIPS 2017的一篇文章。</p><p>GCN是Transductive Learning，训练时的图要包含所有结点，是固定的，不能快速泛化到未知结点（图），本文提出了一种Inductive Learning的GraphSAGE。</p><p>GCN学习的是每个单独节点的低维embedding，由于输入的图是固定的，所以可以很好捕获全局信息。但如果要获得新节点的embedding，加入图以后需要调整其它结点，至少也是局部重新训练，计算开销太大，应用受限。</p><p>GraphSAGE学习的不是每个结点的固定的表示，因为图结构不断变化，所以学习一种节点表示的函数，这样就可以快速得到未知结点的表示。</p><p>简单来说：学习每个结点的特征如何由邻居的特征聚合而来，学到聚合函数后，只要已知新节点的特征和邻边关系，就能得到表示，并且这个表示会由于图结构的变化而变化，是动态的。</p><p>前向传播是为了生成结点的向量表示， <img src="https://img-blog.csdnimg.cn/20210207163418476.png" alt="在这里插入图片描述" /> 如果聚合K次，就需要K个聚合函数，初始时每个结点的表示是原本的特征向量，对第k层，对结点v，先得到v的第k层结点的聚合表示，加上v在上一层的特征，最后得到v的最终表示。</p><p>以作者的图为例， <img src="https://img-blog.csdnimg.cn/20210220111424640.png" alt="在这里插入图片描述" /> 我觉得知乎上这张更清楚： <img src="https://img-blog.csdnimg.cn/20210220111932548.png" alt="在这里插入图片描述" /> 每一层的表示都是由上一层生成，与当前层其他节点无关。</p><p>由于需要学习参数，所以要设计损失函数。无监督学习的损失函数应该是让临近节点有相似的表示，有监督学习用cross-entropy即可。</p><p>聚合函数作者给了3种选择：</p><ol type="1"><li>Mean 取邻居的平均值</li><li>LSTM</li><li>Pooling</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Loss Function</title>
      <link href="/2021/03/13/Loss%20Function/"/>
      <url>/2021/03/13/Loss%20Function/</url>
      
        <content type="html"><![CDATA[<p>For binary classification (+1, -1), if we classify correctly then <span class="math inline">\(y\cdot f = y\cdot \theta^Tx\gt0\)</span>; otherwise <span class="math inline">\(y\cdot f = y\cdot\theta^Tx\lt0\)</span>. Thus we have following loss functions:</p><ul><li>0/1 loss <span class="math inline">\(\min_\theta\sum_i L_{0/1}(\theta^Tx)\)</span>. We define <span class="math inline">\(L_{0/1}(\theta^Tx) =1\)</span> if <span class="math inline">\(y\cdot f \lt 0\)</span>, and <span class="math inline">\(=0\)</span> o.w. Non convex and very hard to optimize.</li><li>Hinge loss Upper Bound of 0/1 loss. Approximate 0/1 loss by <span class="math inline">\(\min_\theta\sum_i H(\theta^Tx)\)</span>. We define <span class="math inline">\(H(\theta^Tx) = max(0, 1 - y\cdot f)\)</span>. Apparently <span class="math inline">\(H\)</span> is small if we classify correctly.</li><li>Logistic loss <span class="math inline">\(\min_\theta \sum_i log(1+\exp(-y\cdot \theta^Tx))\)</span>.</li></ul><p>Fortunately, hinge loss, logistic loss and square loss are all convex functions. Convexity ensures global minimum and it's computationally appealing. <img src="https://img-blog.csdnimg.cn/20210226181824674.png" alt="在这里插入图片描述" /> Figure 7.5 from Chris Bishop's PRML book. The Hinge Loss E(z) = max(0,1-z) is plotted in blue, the Log Loss in red, the Square Loss in green and the 0/1 error in black.</p><p>From the figure we can observe that the hard instance (near the boundary) will influence the loss function a lot so we need to make the model robust and can deal with the hard ones.</p><p>For binary classification we can unify the two cases (classify correctly or not) by <span class="math inline">\(y\cdot f\)</span>, but for multi-class classification (0, 1, 2, ..., k) we cannot unify all the cases. So we use cross-entropy as the loss.</p><p>There exists a vivid example for transform the target function: If a noisy picture is given, and want to output the clean one. Here the clean one is hard to control so we can let the noise be the target function and wo should minimize the amplitude of the noise. Thus the problem becomes controllable.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BusTub</title>
      <link href="/2021/03/05/BusTub/"/>
      <url>/2021/03/05/BusTub/</url>
      
        <content type="html"><![CDATA[<h2 id="project-0---c-primer"><a href="https://15445.courses.cs.cmu.edu/fall2020/project0/">PROJECT #0 - C++ PRIMER</a></h2><p>这个Warm-Up主要是要熟悉C++ 17的一些Features，只需要实现<code>p0_starter.h</code>即可； 提交gradescope，要上传zip文件，但是路径总是不对，文档里也说得不明不白，一定要加上路径名：<code>zip solution.zip src/include/primer/p0_starter.h</code>； <code>unique_ptr</code>拥有对象的独占权，可以用<code>move</code>将对象的所有权转移到另一个<code>unique_ptr</code>。</p><p>第一次提交时有内存安全隐患： <img src="https://img-blog.csdnimg.cn/20201227221401866.png" alt="在这里插入图片描述" /> 网上说可能是valgrind版本过低，用高版本测试后发现没问题： <img src="https://img-blog.csdnimg.cn/20201227221456847.png" alt="在这里插入图片描述" /> 其实代码是有bug的，经过测试，发现问题在于实现矩阵乘法时定义了临时变量<code>double tmp = 0.0</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> tmp = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mat1-&gt;<span class="built_in">GetColumns</span>(); ++k) &#123;</span><br><span class="line">  tmp += mat1-&gt;<span class="built_in">GetElem</span>(i, k) * mat2-&gt;<span class="built_in">GetElem</span>(k, j);</span><br><span class="line">&#125;</span><br><span class="line">ans-&gt;<span class="built_in">SetElem</span>(i, j, tmp);</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; mat1-&gt;<span class="built_in">GetColumns</span>(); ++k) &#123;</span><br><span class="line">  ans-&gt;<span class="built_in">SetElem</span>(i, j, ans-&gt;<span class="built_in">GetElem</span>(i, j) + mat1-&gt;<span class="built_in">GetElem</span>(i, k) * mat2-&gt;<span class="built_in">GetElem</span>(k, j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我个人理解是这样：因为原本代码中是模板参数<code>T</code>，如果定义<code>double</code>作为临时变量，测试时用<code>int</code>测试，最终<code>SetElem</code>时要存入<code>double</code>，但是预先分配的内存只有<code>int</code>大小，所以内存溢出报错。 <img src="https://img-blog.csdnimg.cn/20210127214548109.png" alt="在这里插入图片描述" /> ## <a href="https://15445.courses.cs.cmu.edu/fall2020/project1/">PROJECT #1 - BUFFER POOL MANAGER</a> 整体要为<a href="https://github.com/cmu-db/bustub">Bustub</a>做一个面向磁盘的存储管理系统： <img src="https://img-blog.csdnimg.cn/20210225225705723.png" alt="在这里插入图片描述" /> 第一次作业是要实现一个内存缓冲池：负责将物理页面在磁盘和主存之间移动，这样DBMS就可以支持比内存更大的数据库。缓冲池的操作对其它系统部件是透明的，比如系统通过唯一的页面标识符<code>page_id_t</code>向缓冲池要求访问页面，而不管页面是在内存中还是在磁盘上。</p><p>缓冲池的实现必须是线程安全的，多个线程同时访问时需要用latches保护（OS中叫locks）。 关于DBMS中的🔒： - locks：高层次的逻辑原语，在事务的整个执行过程中保护数据库的内容（元组/表/数据库），可以rollback - latches：低层次的保护原语，DBMS用来保护内部数据结构的安全访问（hash table, regions of memory），只在某个具体操作时使用，不可以rollback</p><p>具体来说：有2部分：LRU替换策略+缓冲池管理 - LRU LRU的实现有多种方式： 1、数组+时间戳：每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。 2、双向链表：每次新插入数据的时候将新数据插到链表的头部；每次缓存命中（即数据被访问），则将数据移到链表头部；那么当链表满的时候，就将链表尾部的数据丢弃。 上面两种复杂度均是O(n) 3、双向链表+Hash Map：当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。本质上是list看作时间戳，hash table记录元素值到链表位置的映射关系，get和put均是O(1)。 - 缓冲池管理 缓冲池的组织形式是frame数目固定的数组，访问时将page从磁盘拷贝到frame。 与OS内存管理相似，也需要有page table记录哪些page在buffer pool中，page id -&gt; frame id；page directory记录了磁盘上的位置，page id -&gt; page locations in disk。 还需要有dirty位以及pin/ref counter记录当前正在访问的线程数目，只有flush或者置换脏页时才写回磁盘。 <img src="https://img-blog.csdnimg.cn/2021022523062865.png" alt="在这里插入图片描述" /> 缓冲池和<code>Replacer</code>的大小是相同的，如果page的ref counter变为0时就可以加入到<code>Replacer</code>中作为替补牺牲页面。</p><p>从缓冲池中根据ID fetch的时候有3种情况： 1. 如果page在缓冲池，直接返回； 2. 如果不在，但缓冲池有空闲frame，从磁盘读取page放入该frame； 3. 如果不在且缓冲池没有空闲frame，从buffer中牺牲一页，从磁盘读取page放入对应的frame。</p><p>第一次提交忘了处理并发问题，只得了65分： <img src="https://img-blog.csdnimg.cn/20210209211524362.png" alt="在这里插入图片描述" /> 加了一些🔒后，还有2个test挂了： <img src="https://img-blog.csdnimg.cn/20210209215248107.png" alt="在这里插入图片描述" /> <code>isdirty</code>一直过不去，后来在群里看到：只有page当前的脏位是false且传入<code>is_dirty==true</code>时才需要修改当前的脏位。这里我是这么理解的：如果页面应该标记为dirty那么传入的参数就是true： - 当前为true &amp;&amp; <code>is_dirty==true</code>：页面修改过，也做了正确标记，不用管； - 当前为false &amp;&amp; <code>is_dirty==true</code>：页面其实修改过，但没有标记，改正； - 当前为false &amp;&amp; <code>is_dirty==false</code>：页面没修改，标记正确，不用管； - 当前为true &amp;&amp; <code>is_dirty==false</code>：页面没修改，标记为修改过，这种也不用管，大不了置换时写回磁盘耗费些时间。 <img src="https://img-blog.csdnimg.cn/20210210204925713.png" alt="在这里插入图片描述" /> 数据库真的太难了，尤其是涉及到并发控制的部分，我真的没有足够时间去debug这些，以后有空再继续做吧。。 ## <a href="https://15445.courses.cs.cmu.edu/fall2020/project2/">PROJECT #2 - B+ TREE</a> ## <a href="https://15445.courses.cs.cmu.edu/fall2020/project3/">PROJECT #3 - QUERY EXECUTION</a> ## <a href="https://15445.courses.cs.cmu.edu/fall2020/project4/">PROJECT #4 - CONCURRENCY CONTROL</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flow Control &amp; Congestion Control</title>
      <link href="/2021/02/25/Flow%20Control%20&amp;%20Congestion%20Control/"/>
      <url>/2021/02/25/Flow%20Control%20&amp;%20Congestion%20Control/</url>
      
        <content type="html"><![CDATA[<p>In order to make sure that every packet reaches its destination, we use Retransmit. There are 3 approaches: Stop-and-Wait, Go Back N and Selective Repeat.</p><ul><li>Stop-and-Wait Sender transmits packet one by one, label each with a sequence number and sets timer after transmitting. If receive ACK, send next. If timer goes off, resend the previous packet. When receive packet, send ACK. If packet is corrupted, ignore it and sender will resend.</li><li>SR Send packets from the window and set timeout for each packet. On receiving ACK for left side of the window, slide forward and send packets that have now entered the window. On timeout, resend only the timed out packet. Receiver keeps a buffer of size of the window. On receiving packets, send ACK. If packet comes in out of order, just store it in the buffer and send ACK anyway. ## How big should we size the sender's window Don't overload the receiver. Sender cannot send as fast as possible since it will overflow the receiver's buffer. <img src="https://img-blog.csdnimg.cn/20200417151819468.png" alt="在这里插入图片描述" /> The solution is Advertised Window (W): tell the sender how much space the receiver's buffer has through ACK. So the window size of the sender: the size &lt;= W. Thus we won't overload the receiver. This is Flow Control.</li></ul><p>But if we set the size to W, we cannot solve the problem thoroughly: <img src="https://img-blog.csdnimg.cn/2021022516554078.png" alt="在这里插入图片描述" /> Sender's window contains a set of packets that have been transmitted but not yet acked. But some packets will get dropped at router and sender will never receive ACKs for these packets. The result is these packets will remain buffered in the window. It means that we cannot set the size to W, we only want to send at 50Mbps. It will take a RTT(200ms) to receive an ACK back for the first packet. We will send 50*200=1.25MB data and that's exactly the definition of the sender's window.</p><p>The window size of the sender should &lt;= bandwidth-delay product (BDP). Thus we won't overload the network. This is Congestion Control. BDP is the "volume" of the link, the amount of data that can be "in flight" at any time. ## How should we determine the BDP Things are much harder to calculate the BDP:</p><ul><li>We don't know the bandwidth or RTT</li><li>My share of bandwidth is dependent on the other user on the network, so the window size will change as other users start or stop sending</li><li>The router will stall the excess packets in the bottleneck queue instead of dropping, so you can overshoot the size a little bit</li></ul><p>There are many algorithms to solve the problem given the prior constraints. The old one is Reno, although no one uses it anymore, sigh!!</p><p>Use Multiplicative Increase at startup to find the right sending rate quickly, this process is called "slow start"; Then uses Additive Increase/Multiplicative Decrease (AIMD) to adjust the sending rate over time. <img src="https://img-blog.csdnimg.cn/20210225174103869.png" alt="在这里插入图片描述" /> ## Reference <a href="https://computer-networks.github.io/sp19/lectures.html">CMU 15-441 TCP Part 2</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Entropy Model</title>
      <link href="/2021/02/07/Maximum%20Entropy%20Model/"/>
      <url>/2021/02/07/Maximum%20Entropy%20Model/</url>
      
        <content type="html"><![CDATA[<p>熵是对随机变量<strong>不确定性</strong>的度量，是对所有可能发生的事件产生的信息量的期望，没有外部能量输入的情况下，封闭系统趋向熵增。</p><p>信息熵指离散随机事件的出现概率：<span class="math inline">\(X={x_1,x_2,...,x_n}\)</span>，<span class="math inline">\(P(X=x_i)=p_i\)</span> <span class="math display">\[H(X)=-\sum_{i=1}^{n}p(x_i)log\ p(x_i)\]</span></p><p>Joint Entropy <span class="math display">\[H(X,Y)=-\sum_{i=1}^{n}\sum_{j=1}^{m}p(i,j)log\ p(i,j)\]</span></p><p><span class="math display">\[H(X|y_j)=-\sum_{i=1}^{n}p(x_i|y_j)log\ p(x_i|y_j)\]</span></p><p>按照<span class="math inline">\(Y\)</span>的各种情况进行加权平均，得条件熵<span class="math inline">\(H(X|Y)\)</span> <span class="math display">\[H(X|Y)=-\sum_{i=1}^{n}\sum_{j=1}^{m}p(y_j)p(x_i|y_j)log\ p(x_i|y_j)=-\sum_{i=1}^{n}\sum_{j=1}^{m}p(x_i,y_j)log\ p(x_i|y_j)\]</span> 易证<span class="math inline">\(H(X|Y)=H(X,Y)-H(Y)\)</span></p><p>交叉熵，<span class="math inline">\(P(X)\)</span>和<span class="math inline">\(Q(X)\)</span>是<span class="math inline">\(X\)</span>的两个概率分布 <span class="math display">\[D_{KL}(P\ ||\ Q)=\sum_xP(x)log\frac{P(x)}{Q(x)}\]</span></p><p>互信息 <span class="math display">\[I(X,Y)=\sum_x\sum_yp(x,y)log\frac{p(x,y)}{p(x)p(y)}\]</span> 互信息就是联合分布<span class="math inline">\(P(X,Y)\)</span>和独立分布乘积<span class="math inline">\(P(X)P(Y)\)</span>的交叉熵。 易证<span class="math inline">\(I(X,Y)=H(X)+H(Y)-H(X,Y)\)</span></p><p>直观上看：在已知部分知识的前提下，对于未知分布最合理的推断就是符合已知且最不确定的推断，整个系统趋向于无序，熵最大。 在一定<strong>约束条件</strong>下，使得<span class="math inline">\(H(X|Y)\)</span>最大。 <span class="math display">\[p^*={\underset {p\in P}{\operatorname {arg\,max} }}\,-\sum_{i=1}^{n}\sum_{j=1}^{m}\bar p(y_j)p(x_i|y_j)log\ p(x_i|y_j)\]</span> 约束条件： <span class="math display">\[\sum_xp(x|y)=1 \\...\]</span> 又可以通过拉格朗日乘数法变为对偶问题求解。</p><p>由于无法求得解析解，只能用迭代法求数值解： <span class="math display">\[p^*(x|y)=\cfrac{1}{Z_\lambda(y)}e^{\sum_i\lambda_if_i(x,y)} \\Z_\lambda(y)=\sum_xe^{\sum_i\lambda_if_i(x,y)}\]</span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python FAQ</title>
      <link href="/2021/01/30/Python%20FAQ/"/>
      <url>/2021/01/30/Python%20FAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="lambda表达式">lambda表达式</h2><p>对于一句话的函数，均可以用lambda表达式，一种语法糖。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x: x ** <span class="number">2</span></span><br><span class="line">g = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadratic</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: a*x*x + b*x + c</span><br><span class="line"></span><br><span class="line">f = quadratic(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">quadratic(<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>)(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><h2 id="decorator">decorator</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># messy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    t1 = time.time()</span><br><span class="line">c = a + b</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(t2 - t1)</span><br><span class="line"><span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><p>如果使用装饰器： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_time</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args</span>):</span></span><br><span class="line">        t1 = time.time()</span><br><span class="line">        res = func(*args)  <span class="comment"># do something</span></span><br><span class="line">        t2 = time.time()</span><br><span class="line">        <span class="built_in">print</span>(t2 - t1)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@display_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">ans = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure></p><h2 id="basics">Basics</h2><ol type="1"><li>两个列表转字典：<code>dict(zip(list1, list2))</code></li><li><a href="https://blog.csdn.net/weixin_37579123/article/details/89515577">Python中__new__()和__init__()的区别</a>：Python中的constructor是<code>__new__</code>，initializer是<code>__init__</code>。<code>__new__</code>首先被调用创建新实例并返回该实例，始终作为类的静态方法，类级别方法，默认调用父类的<code>__new__</code>构造该类的实例，也可以重写<code>__new__</code>，构造出来的对象取决于<code>__new__</code>，<code>__new__</code>返回什么就是什么；<code>__init__</code>没有返回值负责初始化创建的实例，实例级别方法，其<code>self</code>参数就是<code>__new__</code>返回的实例。</li><li><a href="https://hj24.life/posts/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E6%B5%85%E6%9E%90/">Python中的进程/线程/协程</a>： 协程是比线程更小的执行单元，也叫微线程，用户态，在单线程上执行多个任务，一个任务等待时执行另一个任务，使用的内存动态变化，切换调度由用户控制，避免线程的系统级别切换的开销，内存利用率更高。 Python的协程是1：N</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;monkey&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: cat&quot;, &quot;#2: dog&quot;, &quot;#3: monkey&quot;, each on its own line</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;person&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;cat&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;spider&#x27;</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">for</span> animal, legs <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;A %s has %d legs&#x27;</span> % (animal, legs))</span><br><span class="line"><span class="comment"># Prints &quot;A person has 2 legs&quot;, &quot;A cat has 4 legs&quot;, &quot;A spider has 8 legs&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animals = &#123;<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;fish&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> idx, animal <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;#%d: %s&#x27;</span> % (idx + <span class="number">1</span>, animal))</span><br><span class="line"><span class="comment"># Prints &quot;#1: fish&quot;, &quot;#2: dog&quot;, &quot;#3: cat&quot;</span></span><br></pre></td></tr></table></figure><p>one of the most important differences is that tuples can be used as keys in dictionaries and as elements of sets, while lists cannot.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name  <span class="comment"># Create an instance variable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Instance method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span>(<span class="params">self, loud=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> loud:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;HELLO, %s!&#x27;</span> % self.name.upper())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Hello, %s&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">g = Greeter(<span class="string">&#x27;Fred&#x27;</span>)  <span class="comment"># Construct an instance of the Greeter class</span></span><br><span class="line">g.greet()            <span class="comment"># Call an instance method; prints &quot;Hello, Fred&quot;</span></span><br><span class="line">g.greet(loud=<span class="literal">True</span>)   <span class="comment"># Call an instance method; prints &quot;HELLO, FRED!&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])   <span class="comment"># Create a rank 1 array</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))            <span class="comment"># Prints &quot;&lt;class &#x27;numpy.ndarray&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)            <span class="comment"># Prints &quot;(3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])   <span class="comment"># Prints &quot;1 2 3&quot;</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                  <span class="comment"># Change an element of the array</span></span><br><span class="line"><span class="built_in">print</span>(a)                  <span class="comment"># Prints &quot;[5, 2, 3]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])    <span class="comment"># Create a rank 2 array</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)                     <span class="comment"># Prints &quot;(2, 3)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])   <span class="comment"># Prints &quot;1 2 4&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>))   <span class="comment"># Create an array of all zeros</span></span><br><span class="line"><span class="built_in">print</span>(a)              <span class="comment"># Prints &quot;[[ 0.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  0.]]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))    <span class="comment"># Create an array of all ones</span></span><br><span class="line"><span class="built_in">print</span>(b)              <span class="comment"># Prints &quot;[[ 1.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">7</span>)  <span class="comment"># Create a constant array</span></span><br><span class="line"><span class="built_in">print</span>(c)               <span class="comment"># Prints &quot;[[ 7.  7.]</span></span><br><span class="line">                       <span class="comment">#          [ 7.  7.]]&quot;</span></span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)         <span class="comment"># Create a 2x2 identity matrix</span></span><br><span class="line"><span class="built_in">print</span>(d)              <span class="comment"># Prints &quot;[[ 1.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>))  <span class="comment"># Create an array filled with random values</span></span><br><span class="line"><span class="built_in">print</span>(e)                     <span class="comment"># Might print &quot;[[ 0.91940167  0.08143941]</span></span><br><span class="line">                             <span class="comment">#               [ 0.68744134  0.87236687]]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use slicing to pull out the subarray consisting of the first 2 rows</span></span><br><span class="line"><span class="comment"># and columns 1 and 2; b is the following array of shape (2, 2):</span></span><br><span class="line"><span class="comment"># [[2 3]</span></span><br><span class="line"><span class="comment">#  [6 7]]</span></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># A slice of an array is a view into the same data, so modifying it</span></span><br><span class="line"><span class="comment"># will modify the original array.</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;2&quot;</span></span><br><span class="line">b[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">77</span>     <span class="comment"># b[0, 0] is the same piece of data as a[0, 1]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;77&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two ways of accessing the data in the middle row of the array.</span></span><br><span class="line"><span class="comment"># Mixing integer indexing with slices yields an array of lower rank,</span></span><br><span class="line"><span class="comment"># while using only slices yields an array of the same rank as the</span></span><br><span class="line"><span class="comment"># original array:</span></span><br><span class="line">row_r1 = a[<span class="number">1</span>, :]    <span class="comment"># Rank 1 view of the second row of a</span></span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>, :]  <span class="comment"># Rank 2 view of the second row of a</span></span><br><span class="line"><span class="built_in">print</span>(row_r1, row_r1.shape)  <span class="comment"># Prints &quot;[5 6 7 8] (4,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(row_r2, row_r2.shape)  <span class="comment"># Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can make the same distinction when accessing columns of an array:</span></span><br><span class="line">col_r1 = a[:, <span class="number">1</span>]</span><br><span class="line">col_r2 = a[:, <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(col_r1, col_r1.shape)  <span class="comment"># Prints &quot;[ 2  6 10] (3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(col_r2, col_r2.shape)  <span class="comment"># Prints &quot;[[ 2]</span></span><br><span class="line">                             <span class="comment">#          [ 6]</span></span><br><span class="line">                             <span class="comment">#          [10]] (3, 1)&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># An example of integer array indexing.</span></span><br><span class="line"><span class="comment"># The returned array will have shape (3,) and</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The above example of integer array indexing is equivalent to this:</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When using integer array indexing, you can reuse the same</span></span><br><span class="line"><span class="comment"># element from the source array:</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Equivalent to the previous integer array indexing example</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">1</span>], a[<span class="number">0</span>, <span class="number">1</span>]]))  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new array from which we will select elements</span></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[ 1,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5,  6],</span></span><br><span class="line">          <span class="comment">#                [ 7,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 11, 12]])&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array of indices</span></span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select one element from each row of a using the indices in b</span></span><br><span class="line"><span class="built_in">print</span>(a[np.arange(<span class="number">4</span>), b])  <span class="comment"># Prints &quot;[ 1  6  7 11]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mutate one element from each row of a using the indices in b</span></span><br><span class="line">a[np.arange(<span class="number">4</span>), b] += <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[11,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5, 16],</span></span><br><span class="line">          <span class="comment">#                [17,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 21, 12]])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>)   <span class="comment"># Find the elements of a that are bigger than 2;</span></span><br><span class="line">                     <span class="comment"># this returns a numpy array of Booleans of the same</span></span><br><span class="line">                     <span class="comment"># shape as a, where each slot of bool_idx tells</span></span><br><span class="line">                     <span class="comment"># whether that element of a is &gt; 2.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bool_idx)      <span class="comment"># Prints &quot;[[False False]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We use boolean array indexing to construct a rank 1 array</span></span><br><span class="line"><span class="comment"># consisting of the elements of a corresponding to the True values</span></span><br><span class="line"><span class="comment"># of bool_idx</span></span><br><span class="line"><span class="built_in">print</span>(a[bool_idx])  <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can do all of the above in a single concise statement:</span></span><br><span class="line"><span class="built_in">print</span>(a[a &gt; <span class="number">2</span>])     <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)         <span class="comment"># Prints &quot;int64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)             <span class="comment"># Prints &quot;float64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)   <span class="comment"># Force a particular datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)                         <span class="comment"># Prints &quot;int64&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise sum; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 6.0  8.0]</span></span><br><span class="line"><span class="comment">#  [10.0 12.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise difference; both produce the array</span></span><br><span class="line"><span class="comment"># [[-4.0 -4.0]</span></span><br><span class="line"><span class="comment">#  [-4.0 -4.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x - y)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise product; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 5.0 12.0]</span></span><br><span class="line"><span class="comment">#  [21.0 32.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x * y)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise division; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 0.2         0.33333333]</span></span><br><span class="line"><span class="comment">#  [ 0.42857143  0.5       ]]</span></span><br><span class="line"><span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="built_in">print</span>(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise square root; produces the array</span></span><br><span class="line"><span class="comment"># [[ 1.          1.41421356]</span></span><br><span class="line"><span class="comment">#  [ 1.73205081  2.        ]]</span></span><br><span class="line"><span class="built_in">print</span>(np.sqrt(x))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inner product of vectors; both produce 219</span></span><br><span class="line"><span class="built_in">print</span>(v.dot(w))</span><br><span class="line"><span class="built_in">print</span>(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / vector product; both produce the rank 1 array [29 67]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(v))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / matrix product; both produce the rank 2 array</span></span><br><span class="line"><span class="comment"># [[19 22]</span></span><br><span class="line"><span class="comment">#  [43 50]]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(y))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, y))</span><br></pre></td></tr></table></figure><h2 id="问题">问题</h2><p>遇到一个问题： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nums = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            nums.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        </span><br><span class="line">        inorder(proot)</span><br></pre></td></tr></table></figure> 这段代码不会报错，但是如果： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cnt, ans = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == k:</span><br><span class="line">                ans = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.right)</span><br></pre></td></tr></table></figure> 就会报错<code>UnboundLocalError: local variable 'cnt' referenced before assignment</code> 不太理解为啥list没事，后来<a href="https://stackoverflow.com/questions/2609518/unboundlocalerror-with-nested-function-scopes">SO</a>上的回答我大概明白了： python通过赋值操作来判断是否是局部变量，但是nums的append不是赋值，因此只要不在嵌套函数里赋值都不会报错。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A new classification algorithm recommendation method based on link prediction</title>
      <link href="/2021/01/28/A%20new%20classification%20algorithm%20recommendation%20method%20based%20on%20link%20prediction/"/>
      <url>/2021/01/28/A%20new%20classification%20algorithm%20recommendation%20method%20based%20on%20link%20prediction/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要还是在元模型上创新，采用基于链接预测的方式为新数据集推荐分类算法。基本框架如下： <img src="https://img-blog.csdnimg.cn/20210127113628615.png" alt="在这里插入图片描述" /> 用元学习做AutoML主要关注：元特征、元目标的表现形式、元模型。 ## 元特征 第一步包括提特征和识别可用算法。 目前流行的元特征有5种：</p><ul><li>statistical and information-theory based</li><li>model structure based</li><li>landmarking</li><li>problem-complexity</li><li>structural information</li></ul><p>由于每个数据集可能有不定数目的可用算法，文章采用了multiple comparison procedure：如果我们用acc作为衡量标准（除此以外本文还用了ARR作为标准，将时间因素也考虑进去），这个程序能用统计检验的方法发现一系列与最佳算法相差不显著的候选算法。文中具体使用的统计检验方法是Friedman Test+Holm procedure test，即如果Friedman Test认为所有算法性能相差不显著，那么所有的算法都是meta target；否则以表现最佳的算法为参考，用Holm procedure test去识别和最佳算法没有显著差异的算法们作为meta target。 这样就得到了元数据<span class="math inline">\(M=\{m_1,...,m_n\},m_i=&lt;x_i,y_i&gt;\)</span>，其中<span class="math inline">\(x_i=(f_{i1},...,f_{ip})\)</span>是该数据集的p个元特征，<span class="math inline">\(y_i=(a_1,...,a_q)\)</span>是q个合适的算法。 ## 元目标形式 有4种： - 单标签 - 多标签 - 连续值：预测算法的表现，回归问题 - 排序：预测算法之间的相对顺序 ## 元模型 - 分类 - 回归 - ranking</p><p>本文将问题看作多标签分类，并采用DAR图+链接预测作为分类模型。 建的是一个异构图，有数据集（元特征作为结点属性）和算法（算法名作为属性）两种结点，有d-d和d-a两种无向边，d-d边的构建通过数据集间的相似性（<strong>欧氏距离</strong>最近的k个邻居，需要将元特征标准化min-max scaling），d-a边就用每个数据集的候选算法构建。 建图的伪代码： <img src="https://img-blog.csdnimg.cn/2021012815482635.png" alt="在这里插入图片描述" /> 建好图后就可以推荐了，伪代码如下： <img src="https://img-blog.csdnimg.cn/20210128161524948.png" alt="在这里插入图片描述" /> 文章里LPMethod有3种：Katz,LRW,SRW。 综上，预测时需要的参数有：训练集<span class="math inline">\(D=\{d_1,...,d_n\}\)</span>，候选算法集<span class="math inline">\(A=\{a_1,..,a_m\}\)</span>，推荐的算法数目，每个数据集结点的邻边数目<span class="math inline">\(k\)</span>。 ## 评估 评估指标包括5个：Hamming损失、F值、acc、HitRatio、RA（推荐准确率）。 考虑DAR图的边的权重，类似概率图模型 &lt;/x_i,y_i&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Climbing Summary</title>
      <link href="/2021/01/22/Climbing%20Summary/"/>
      <url>/2021/01/22/Climbing%20Summary/</url>
      
        <content type="html"><![CDATA[<p>看完<em>Everest</em>之后，我也做着有朝一日登顶珠峰的白日梦。懒癌晚期也没爬过几座山，希望有机会挑战下雪山（嘿！又一个雄心勃勃的flag）。</p><ul><li>骊山 没什么好说的，海拔1300+，高中翻个墙就是山路，基本没有难度。</li><li>太白山 很冷，海拔3700+，6月上到峰顶还是很冷，只有下面是旅游开发区，上面一大部分路段都没有开发，只是用石头简单铺了，手机没有信号，基本没有歇脚的地，风吹得你怀疑人生。</li><li>华山 海拔2100+，夏天上去完全不用外套，注意防晒，爬起来也没啥难度，基本开发地都不错，只是很多地方非常险峻，比如鹞子翻身、大索道，听说还有完全透明的那种。 <img src="https://img-blog.csdnimg.cn/20200829222658646.png" alt="在这里插入图片描述" /> 路线很多，随你怎么走了。 我们是前一天晚上到华山北站，休息一晚，然后游客中心-&gt;北峰索道-&gt;北峰-&gt;中峰-&gt;东峰-&gt;南峰-&gt;西峰-&gt;西峰索道-&gt;游客中心，本来想走玉泉院徒步上去，但是人家关闭了，而且一天时间也不够，晚上在华山北休息了一晚，第三天早上回西安。 我觉得最刺激的有几处： 很多地方都有那种近乎于垂直的台阶，甚至有超过90度的，反正我上到一半就撤了。。 鹞子翻身：没敢玩 长空栈道：没敢去 西峰索道：下行20min，真刺激，山谷间吹个小风，索道就左右飘~</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MLE &amp; MAP</title>
      <link href="/2021/01/16/MLE%20&amp;%20MAP/"/>
      <url>/2021/01/16/MLE%20&amp;%20MAP/</url>
      
        <content type="html"><![CDATA[<p>自从贝叶斯理论诞生以后，频率学派和贝叶斯学派的争论一直没有停歇，平时的学习太注重公式计算，故在此谈谈自己对贝叶斯理论的一些认识。</p><p>频率学派认为概率是基于大量实验所得的定值（大数定理），比如抛掷一枚材质均匀的硬币10000次，出现正面的次数有4995次，反面的次数有5005次，大致认为出现正反面的概率都是50%。然而现实生活中很多事情是无法做大量实验的，比如某人得心脏病的概率是5%，显然我们无法通过多次实验来计算出这个概率值。回到硬币的例子，如果只允许你抛5次，5次的结果都是正面，那么出现正面的概率是100%了吗？显然这是存在弊端的。</p><p>再来看一个非常经典的医学上的例子：有一种很稀有的病，得病的人检测结果呈阳性的概率是0.9，没得病的人检测结果呈阴性的概率也是0.9，人们患这种病的概率是0.01。如果某人的检测结果呈阳性，那么他患这种病的概率是多少？</p><p>直观上看：患病的人检测呈阳性的概率是0.9，这个人被检测为阳性，那么有很大概率这个人是患病的。不妨试着算算：</p><p>假设用A表示检测结果为阳性，B表示患病，那么可以很轻松的计算出： <span class="math display">\[P(B|A)=\cfrac{P(A|B)P(B)}{P(A)}=\cfrac{P(A|B)P(B)}{P(A|B)P(B)+P(A|\bar B)P(\bar B)}=\cfrac{0.9*0.01}{0.9*0.01+0.1*0.99}=0.083 \\P(\bar B|A)=1-P(B|A)=0.917\]</span> 可以看到：即使检测结果呈阳性，患病的概率仍然只有8.3%，和我们的直观认识并不相同。</p><p>上面的计算其实就用了贝叶斯公式：后验概率<span class="math inline">\(P(B|A)\)</span>等于条件概率<span class="math inline">\(P(A|B)\)</span>（似然函数）乘以先验概率<span class="math inline">\(P(B)\)</span>，再除以一个常数因子。我们在已知先验概率的前提下，通过新的观测值<span class="math inline">\(P(A|B)\)</span>（检测结果是否阳性）来预测患病的概率。</p><p>关于常数因子<span class="math inline">\(P(A)\)</span>可以这样理解：分子<span class="math inline">\(P(A,B)\)</span>表示检测结果呈阳性并且患病的概率，那么还有一部分人<span class="math inline">\(P(A,\bar B)\)</span>检测结果呈阳性但是没有患病，<span class="math inline">\(P(A,B)+P(A,\bar B)=P(A)\)</span>，我们要求的<span class="math inline">\(P(B|A)\)</span>即检测呈阳性的人中患病的人所占的比例<span class="math inline">\(\cfrac{P(A,B)}{P(A)}\)</span>。</p><p>更加一般的贝叶斯公式：</p><p>如果参数<span class="math inline">\(\theta\)</span>的分布是离散的： <span class="math display">\[\pi(\theta_i|x)=\cfrac{\pi(\theta_i)f(x|\theta_i)}{\sum_{i}\pi(\theta_i)f(x|\theta_i)}\]</span> 如果参数<span class="math inline">\(\theta\)</span>的分布是连续的： <span class="math display">\[\pi(\theta|x)=\cfrac{\pi(\theta)f(x|\theta)}{\int_{\Theta}\pi(\theta)f(x|\theta)d\theta}\]</span> 后验概率密度表示在已知x的前提下关于参数<span class="math inline">\(\theta\)</span>的一个概率密度函数，即<span class="math inline">\(\theta\)</span>是一个分布，而不是一个固定的值，这是贝叶斯学派与传统学派最大的不同。</p><p>似然函数<span class="math inline">\(f(x|\theta)\)</span>可以这么理解：每个事件的背后都有一个分布，这个分布里是含有参数的，并且传统学派认为这个参数<span class="math inline">\(\theta\)</span>是固定的，我们做了大量的实验，用很多样本x就是为了求出这个参数的值，观测到的样本x是以参数<span class="math inline">\(\theta\)</span>为前提的一个分布。为了估计<span class="math inline">\(\theta\)</span>，我们用到了<strong>矩估计</strong>和<strong>极大似然估计</strong>，本质上都是一样的，我们在参数<span class="math inline">\(\theta\)</span>的前提下，从总体X中采样n个样本，用样本的性质来大致替代总体的参数<span class="math inline">\(\theta\)</span>。具体到极大似然：通过找到使似然函数<span class="math inline">\(\prod_{i=1}^{n}f(x_i|\theta)\)</span>最大的参数当作<span class="math inline">\(\theta\)</span>，其实就是选择一个<span class="math inline">\(\theta\)</span>使得样本出现的概率最大，本质上仍然是在拟合样本数据。</p><p>从上面的分析可以看出：我们的未知参数<span class="math inline">\(\theta\)</span>是从样本中计算得到的，必然和总体中原本的参数值存在误差，并且只能求得一个固定的参数值。贝叶斯理论认为：参数<span class="math inline">\(\theta\)</span>不应该是一个单独的值，更加合理的解释应该是参数<span class="math inline">\(\theta\)</span>有很多取值，并且每个取值都有相应的概率，即参数是服从某种分布的。概率最大的那个参数值即<strong>最大后验估计</strong>，参数取值的中位数即<strong>后验中位数估计</strong>，参数取值的均值即<strong>后验期望估计</strong>。为什么仍然叫估计呢？因为我们的后验分布是从似然计算得到的，我们无法采样所有的总体中的样本，所以也就无法计算出参数<span class="math inline">\(\theta\)</span>的精确分布。</p><p>最后来看看先验分布<span class="math inline">\(\pi(\theta)\)</span>，即在获得实验观测值之前对未知参数分布的一个主观认识，这也是贝叶斯学派一直被攻击的一点，客观的统计学中竟然引入了主观的因素！比如对于材质均匀的硬币，在抛掷之前，我们脑海中就会认为出现正反面的概率各是0.5。</p><p>但是很多时候先验分布是很难获得的，如果硬币材质不均匀，我们的先验又应当是什么分布呢？此时就引入了课程上讲的<strong>无信息先验</strong>，当我们对事件没有了解的时候，认为参数所有取值的概率都是相等的，在硬币实验中，我们认为<span class="math inline">\(\theta\)</span>是服从(0,1)的均匀分布。接着我们来做实验，看看后验分布会怎么变化（图源：Cameron Davidson-Pilon, Probabilistic Programming and Bayesian Methods for Hackers, 2016）：</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/11e883581dd48f9c8442b8273371766d.png" alt="" /><figcaption>img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/3110af9ecffd601bb7acd89d86ad9784.png" alt="" /><figcaption>img</figcaption></figure><p>从图中可以看出：起初是均匀分布，连续抛掷了2次正面，此时认为该硬币正面向上的概率为1的可能性是最大的，但注意：正面向上的概率取0.6,0.4的可能也不是没有，不过这种可能性更小罢了。如果我们用极大似然去估计，就会得到该硬币正面向上的概率是1，正面向上的概率取0.6,0.4的可能为0，这显然与现实不符！接着抛了一次反面，正面向上的概率分布又进行了修正，不断通过观测值修正我们的后验，最终得到一个稳定的后验分布。</p><p>均匀分布<span class="math inline">\(U(a,b)\)</span>作为先验看起来很好用，但是他本质上还是有倾向性的，即认为在区间(a,b)内是有取值的，在区间外是没有取值的可能的，更加合理的无信息先验可以选取一个大方差的高斯分布。</p><p>选择高斯分布作为先验带来的一个问题是计算上的复杂性骤然提高，所以引入了<strong>共轭先验分布</strong>：即后验分布<span class="math inline">\(\pi(\theta|x)\)</span>与先验分布<span class="math inline">\(\pi(\theta)\)</span>是同一种类型的分布，就称先验分布<span class="math inline">\(\pi(\theta)\)</span>是<span class="math inline">\(f(x|\theta)\)</span>的共轭先验分布。这样我们在计算后验分布时，就无需计算复杂的积分，只要调整先验分布的参数即可确定后验分布。可以证明：<span class="math inline">\(\beta\)</span>分布是二项分布<span class="math inline">\(B(n,p)\)</span>中参数<span class="math inline">\(p\)</span>的共轭先验分布。即如果总体<span class="math inline">\(X|\theta\sim B(N,\theta)\)</span>，从中采样n个样本，样本分布即似然函数<span class="math inline">\(f(x|\theta)\)</span>服从<span class="math inline">\(\beta\)</span>分布，假设先验<span class="math inline">\(\theta\sim\beta(a,b)\)</span>，那么后验分布<span class="math inline">\(\theta|x\sim\beta(a+\sum x_i,b+nN-\sum x_i)\)</span>。</p><p>证明： 总体<span class="math inline">\(X|\theta\sim B(N,\theta)\)</span>，先验<span class="math inline">\(\theta\sim\beta(a,b)\)</span>，<span class="math inline">\(X=(X_1,...,X_n)^T\)</span>是来自总体的n个样本，则样本分布为： <span class="math display">\[p(x|\theta)=L(\theta)=\prod_{i=1}^{n}\tbinom{N}{x_i}\theta^{x_i}(1-\theta)^{N-x_i}\propto\theta^{\sum_{i=1}^{n}x_i}(1-\theta)^{nN-\sum_{i=1}^{n}x_i}\]</span> 可以看到：似然函数<span class="math inline">\(L(\theta)\)</span>具有<span class="math inline">\(\beta\)</span>分布的核，先验的核为<span class="math inline">\(\theta^{a-1}(1-\theta)^{b-1}\)</span>，所以后验为： <span class="math display">\[\pi(\theta|x)\propto\theta^{a-1+\sum_{i=1}^{n}x_i}(1-\theta)^{b-1+nN-\sum_{i=1}^{n}x_i},0&lt;\theta&lt;1\]</span> 显然后验分布的核与<span class="math inline">\(\beta\)</span>分布的核是同种类型，即<span class="math inline">\(\theta|x\sim\beta(a+\sum x_i,b+nN-\sum x_i)\)</span>，所以<span class="math inline">\(\beta\)</span>分布是二项分布<span class="math inline">\(B(n,p)\)</span>中参数<span class="math inline">\(p\)</span>的共轭先验分布。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>概率统计基础</title>
      <link href="/2021/01/11/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/01/11/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>联合概率<span class="math inline">\(P(A,B)\)</span>即两个事件同时发生的概率 条件概率（后验概率）<span class="math inline">\(P(A|B)P(B)=P(B|A)P(A)\)</span> 全概率公式 <span class="math display">\[P(A)=\sum_nP(A,B_n)=\sum_nP(A|B_n)P(B_n)\]</span> 贝叶斯定理： <span class="math display">\[P(A|B)=\frac{P(B|A)P(A)}{P(B)}\]</span> <span class="math inline">\(A\)</span>的后验概率等于标准相似度乘以先验概率</p><p>离散型随机变量概率分布（分布律）： |<span class="math inline">\(X\)</span>| <span class="math inline">\(x_1\)</span>|...|<span class="math inline">\(x_i\)</span>|... |--|--|--|--|--| | <span class="math inline">\(P\)</span>| <span class="math inline">\(p_1\)</span>|...|<span class="math inline">\(p_i\)</span>|... 满足<span class="math inline">\(p_i\geq0, \sum_{i=1}^{\infty}p_i=1\)</span></p><p>0-1分布：<span class="math inline">\(X\sim B(1,p)\)</span> |<span class="math inline">\(X\)</span>| 0|1| |--|--|-- |<span class="math inline">\(P\)</span>|<span class="math inline">\(1-p\)</span>|<span class="math inline">\(p\)</span>| <span class="math display">\[P(X=k)=p^k(1-p)^{1-k},k=0,1\]</span></p><p>二项分布：<span class="math inline">\(X\sim B(n,p)\)</span> <span class="math inline">\(n\)</span>重伯努利试验 <span class="math display">\[P(X=k)=C_n^kp^k(1-p)^{n-k},k=0,1,...,n\]</span></p><p>Poisson分布：<span class="math inline">\(X\sim P(\lambda)\)</span> <span class="math display">\[P(X=k)=\frac{\lambda^ke^{-\lambda}}{k!},k=0,1,...,n,\lambda&gt;0\]</span> <span class="math inline">\(E(X)=\lambda,D(X)=\lambda\)</span> 可以证明：Poisson分布是二项分布在<span class="math inline">\(\lambda=np,n\to\infty\)</span>的极限分布。</p><p>连续型随机变量概率分布函数：<span class="math inline">\(F(x)=\int_{-\infty}^{x}f(t)dt\)</span>，<span class="math inline">\(f(x)\)</span>称为概率密度函数。 均匀分布：<span class="math inline">\(X\sim U(a,b)\)</span> <span class="math display">\[f(x)=\begin{cases}\cfrac{1}{b-a}, &amp;x\in(a,b)\\0, &amp;其它\end{cases}\]</span> 指数分布：<span class="math inline">\(X\sim E(\lambda)\)</span> <span class="math display">\[f(x)=\begin{cases}\lambda e^{-\lambda x}, &amp;x&gt;0\\0, &amp;x\leq0\end{cases}\]</span> 正态分布（高斯分布）：<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span> <span class="math display">\[f(x)=\cfrac{1}{\sigma \sqrt{2\pi}}e^{-\cfrac{(x-\mu)^2}{2\sigma^2}}\]</span> <span class="math inline">\(\mu\)</span>是位置参数，决定对称轴位置；<span class="math inline">\(\sigma\)</span>是尺度参数，决定分布的幅度。 标准正态分布<span class="math inline">\(X\sim N(0,1)\)</span></p><p>数学期望： 离散型：<span class="math inline">\(E(X)=\sum_ip_ix_i\)</span> 连续型：<span class="math inline">\(E(X)=\int_{-\infty}^{+\infty}xf(x)dx\)</span></p><p>方差：随机变量的离散程度，距离期望的距离 <span class="math inline">\(D(X)=E[(X-E(X))^2]=E(X^2)-E(X)^2\)</span> <span class="math display">\[D(X)=\cfrac{1}{N}\sum_{i=1}^{N}(x_i-\mu)^2=\cfrac{1}{N}(\sum_{i=1}^{N}x_i^2-N\mu^2)\]</span> 离散型：<span class="math display">\[D(X)=\sum_{i=1}^{\infty}[x_i-E(X)]^2p_i\]</span> 连续型：<span class="math display">\[D(X)=\int_{-\infty}^{+\infty}[x-E(X)]^2f(x)dx\]</span></p><p>标准差（均方差）是方差的算术平方根</p><p>样本标准差： <span class="math display">\[s=\sqrt{\cfrac{1}{n-1}\sum_{i=1}^{n}(x_i-\bar x)^2}\]</span> 对于二维随机变量，协方差用来描述<span class="math inline">\(X\)</span>与<span class="math inline">\(Y\)</span>之间的相互关系： <span class="math display">\[Cov(X,Y)=E\{[X-E(x)][Y-E(Y)]\}\]</span></p><p>相关系数： <span class="math display">\[\rho_{XY}=\cfrac{Cov(X,Y)}{\sqrt{D(X)D(Y)}}\]</span></p><p>de Movire-Laplace中心极限定理： <span class="math inline">\(n_A\)</span>为<span class="math inline">\(n\)</span>重伯努利试验中<span class="math inline">\(A\)</span>发生的次数，<span class="math inline">\(P(A)=p\)</span>，对任意实数<span class="math inline">\(x\)</span>，有： <span class="math display">\[\lim\limits_{n\to+\infty}P(\cfrac{n_A-np}{\sqrt{np(1-p)}}\leq x)=\int_{-\infty}^{x}\cfrac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}dt=\Phi(x)\]</span> <span class="math inline">\(n\)</span>充分大时，<span class="math inline">\(n_A\sim N(np,np(1-p))\)</span>，故： <span class="math display">\[P(a&lt;n_a\leq \]</span>="" <span class="math inline">\(n\)</span>充分大时，<span class="math inline">\(\sum_{i=&quot;1}^{n}X_i\sim&quot; \cfrac{\sqrt{n}(\bar=&quot;&quot; \lim\limits_{n\to+\infty}p(|\cfrac{n_x}{n}-p|&lt;\epsilon)=&quot;1&quot; b)\approx\phi(\cfrac{b-n\mu}{\sqrt{n}\sigma})-\phi(\cfrac{a-n\mu}{\sqrt{n}\sigma})=&quot;&quot; b)\approx\phi(\cfrac{b-np}{\sqrt{np(1-p)}})-\phi(\cfrac{a-np}{\sqrt{np(1-p)}})=&quot;&quot; n(0,1)=&quot;&quot; n(0,1)\)</span>，即：="" n(0,1)<span class="math inline">\(，故：=&quot;&quot; n(n\mu,n\sigma^2)\)</span>，<span class="math inline">\(y_n\sim=&quot;&quot; p(a&lt;\sum_{i=&quot;1}^{n}X_i\leq&quot; x-\mu)}{\sigma}\sim=&quot;&quot; y_n=&quot;\cfrac{\sum_{i=1}^{n}X_i-n\mu}{\sqrt{n}\sigma}&quot; 中心极限定理表明：任意的一个概率分布中生成的随机变量，其序列和统一地归约到正态分布：\)</span>y_n="" 伯努利大数定律：事件<span class="math inline">\(x\)</span>在每次试验中发生概率是<span class="math inline">\(p\)</span>，<span class="math inline">\(n\)</span>次独立重复试验中，<span class="math inline">\(x\)</span>发生的次数为<span class="math inline">\(n_x\)</span>，则：="" 即事件的发生频率依概率收敛于事件的概率。="" 独立同分布中心极限定理：="" 辛钦大数定律：<span class="math inline">\(x_i\)</span>为独立同分布的随机变量序列，且期望<span class="math inline">\(\mu\)</span>存在，则对<span class="math inline">\(\forall\epsilon=&quot;&quot; 随机变量\)</span>x_1,x_2,...,x_n,...<span class="math inline">\(独立同分布，\)</span>e(x_i)=",D(X_i)=^2<span class="math inline">\(，前\)</span>n<span class="math inline">\(个变量和的标准化变量为：&quot;&gt;0\)</span>，有： <span class="math display">\[\lim\limits_{n\to+\infty}P(|\cfrac{1}{n}\sum_{i=1}^{n}X_i-\mu|\geq\epsilon)=0\]</span></p><p>正太分布熵的大小，取决于方差的大小。&lt;/n_a&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>逼乎摘选</title>
      <link href="/2020/12/31/%E9%80%BC%E4%B9%8E%E6%91%98%E9%80%89/"/>
      <url>/2020/12/31/%E9%80%BC%E4%B9%8E%E6%91%98%E9%80%89/</url>
      
        <content type="html"><![CDATA[<p><font size="2"><em>早已决定退乎，将一些曾经的收藏稍加整理摘录于此，均已注明出处，侵删</em></font> ## <a href="https://www.zhihu.com/question/374401049/answer/1055275763">多任务下如何保持高效率</a> 第一件事情，是想一想什么事情是自己应该做的，什么是要推给别人的，什么是要找人讨论再做，什么需要等一阵子的。这个是战略问题，比任何战术上的技巧都管用。多任务完成得再快，做自己不应该做或者不需要做的事情，只会累死累活还没什么用。</p><p>随时想着如果不玩这局棋了，把棋盘掀翻重来会是什么结果？也许会有更好的解法。</p><p>在这之后，再讨论战术。以下是一些应付多任务的具体方案： 1. 每做一个任务要百分百集中（比如说现在在写这个答案的时候，就不要写一半刷手机了）。 2. 每个任务最好持续一段时间（我的经验是最少15分钟），切去一个需要一定脑力的任务，做5分钟再切回来基本上没有成功的例子。10分钟的任务除非在做之前有非常清楚的规划，不然要不什么事都没做成（比如说还在手忙地找浏览器里的相关标签页），要不因为专注而超时。 3. 每个任务有非常明确的完成指标。比如说某个任务是代码能跑起来，文章的introduction看完，或是审完一篇论文并且写出评审建议。不完成不要停手。如果实在得要暂停（比如说得去开会），记得把完成指标再分得更细一些。 4. 难的和简单的任务可以错开做。做完难的需要休息可以做些简单但不得不做的，做完简单的可以再切回难的（这样有挑战性）。如果发现自己并不需要休息就迫不及待地去做下一个任务了，说明任务安排得好。 5. 不要安排得太满，不要要求每天都一定要全部完成。总会有完不成的事项。我觉得我每天订的TODO list总有一两个没完成，然后就会发现，有些其实并不重要，有些其实挺重要但下意识逃避了，下次就要把它们拿出来第一个做完。 6. 经常锻炼，充足睡眠，合理膳食，才能保持充沛精力。偶尔熬夜也许确实活多，但天天熬夜，就说明战略上有大问题了，身体不是这么玩的。 ## <a href="https://www.zhihu.com/question/27032313/answer/315544084">应届生是选择一个公司，还是选择一个行业</a> 人生的幸福，我的感觉来自自律，独立思考能力，控制住自己的欲望，保持对新事物的敏感度和参与度。</p><p>比选择行业更重要的是一个人独立思考能力，自己纠错，自己拯救自己的能力。</p><p>我混到今天一直在自己做决策，从大学填写志愿，到跳槽，找工作，做生意，都从来不问别人，都是自己研究琢磨。我也有问人的时候，但是我从来不问人生该怎么选择，我只问具体的技术性问题。</p><p>保持对物欲的控制，管理好自己，培养良好的习惯，我们可以摆脱很多不必要的麻烦。 ## <a href="https://www.zhihu.com/question/24917544/answer/154775610">你生命中最艰难、痛苦的一段时间是如何度过的</a> 对于我来说，从来没有觉得有什么最艰难和痛苦的日子。人生本来就是一场旅行，能够和爱的人在一起度过，又何必在意旅途的风景是什么风格。也许，这场旅途对于我来说，只是可能比父母和孩子早下车几站而已。</p><p>当你用心拼尽全力过好每一天，会发现早死晚死都是一种平淡无奇的结果，艰难困苦只是自己给自己懦弱和懒惰的开脱词。祝尚有余生的各位安好。 ## <a href="https://www.zhihu.com/question/29956916/answer/311913864">活着不开心怎么办</a> 如何减少不开心？一是别瞎去比较，人确实都有损失厌恶，但你如果不主动去做一些无谓的比较，就能让自己舒服很多；另一个是别瞎揣摩别人，别因为不理解别人，而给自己制造不必要的不快。</p><p>说完这两点还没完，因为它俩都属于“别做什么”，还要再聊一点“要做什么”。</p><p>要自在如风，要在不违反法律、不伤风败俗的前提下去尽情享受生活，享受自由。</p><p>我以前觉得那些走在马路上唱着歌还唱得不好听的人特别蠢，可是人家一点都不蠢，他唱歌的样子就能证明他很快乐。</p><p>那些跳广场舞的大妈，人家是真的开心，在跳舞的过程中，她们是心情愉悦的，不然谁会每天都准点跑去跳啊。</p><p>咱们也得好好对待自己，别老那么在意别人的目光，人家路人其实压根就不在意你。 ## <a href="https://www.zhihu.com/question/278108330/answer/400776080">如何看待论调「所谓稳定不过是在浪费生命」</a> 纸醉金迷可能会有一时之爽，但午夜梦回，浮现在眼前的是孩提时代的无忧无虑，还是高档场所的推杯换盏，真不一定。</p><p>内心的平安才是真正的平安。</p><p>人活着，要常常问自己，到底想要什么。不要总跟别人比较，不要过于苛求自己。和自己相识，和自己和解。</p><p>盗用头文字D的一句台词，这世界上只有一种成功，就是能够用自己喜欢的方式度过一生，这才是成功最返璞归真的定义。 ## <a href="https://www.zhihu.com/question/33220674/answer/58248246">我们是怎样一步步地走向平庸的</a> 认为我这么一个大好人才，却被投闲置散，落至今时今日这样的田地。</p><p>也试过自怨自艾，认为自己不知不觉间变成了一个废人。</p><p>直到这个时候，我才知道，我之所以觉得亲朋好友们的夸赞大惊小怪，其实是因为在我心底，我一直以为自己本来就应该是个天之骄子。</p><p>一路以来走得太过顺畅，我以为自己并不高傲自大，其实这种高傲自大已经深入骨髓，我根本没有机会察觉。</p><p>及至看到周围那些，曾经和我一个水平，甚至不如我的人，踏踏实实地走每一步，一步一步地抛离我，我才慢慢意识到，我并不是什么天之骄子，我只是一个平平凡凡的人。</p><p>接受自己是一个庸人这个过程非常痛苦。我每天都在剧烈的内心煎熬中。</p><p>一时劝说自己，生来便是庸人，坦然接受便是。一时又斗志激昂，只要努力，我便能回到原来天之骄子的位置上。</p><p>食不能安，夜不能寐。精神的压力直接导致身体的衰弱，一度卧病在床。</p><p>每个人都理所当然地演绎着自己的每一日。</p><p>相比之下，我国内的朋友，最近一个个结婚生子，安居乐业。我的妹妹，看起来学历能力一切不如我，却兢兢业业安安稳稳地工作着，闲时与朋友吃吃烧烤喝喝啤酒，上瑜伽班，学画画，日子过得不亦乐乎。</p><p>你说这样是平庸吗？然而她却觉得幸福无比。我拿着两个名校的学位又一次进入了名企，努力了那么久，曾经我以为我也算一直在进步，最后也不过是朝九晚五地工作。</p><p>而此时此刻，我只想回到家人的身边，过那带着油烟味的乏味无奇的日子。</p><p>我想，大千世界，谁人不平庸谁人平庸，一切不过是心魔。努力上进也好，安稳度日也好，若是不幸福不快乐，又有何用。 ## <a href="https://www.zhihu.com/question/20004337/answer/18961389">大学毕业之后，同学之间慢慢拉开了差距，还有必要参加老同学聚会吗</a> 唯有真正的好朋友，你过得好，他们反倒会问候你，这样累不累，不累就好；你过得不好，他们也会真心体贴你：「没关系，加油，做你自己想做的事，兄弟帮不到你，但你不开心的时候，可以找兄弟出来喝喝酒、吃吃饭、唱唱歌，哥儿几个陪你。」</p><p>当朋友之间不用显示优越感时，就能好好聊天了。 ## <a href="https://www.zhihu.com/question/20657503/answer/28028792">如何让自己变得开心起来</a> 不要和他人比较。我在精神病院工作，我可以直截了当的告诉你：太多看上去成功和开心的人被自己内心的骚动活活折磨疯了。所以，只要专注自己就好。</p><p>参与社交。即使你是一个内向的人，也要强迫自己去进入社交环节，这会给你和人结识、建立联系的机会。这些联系会使你和你的人性连接在一起。</p><p>做有关健康的决策。运动和好的饮食会改变你的世界观，这是很神奇的。你脑中看起来很真实很迫切的消极想法会消失的。</p><p>做不一样的事情。不要再浪费时间试图找到“完美的爱好”了。学习一点新的，无论是纤维艺术还是品尝咖啡。找到一件你可以投入精力的东西，自己能够胜任，然后等待结果。</p><p>和转折点保持联系。当我们长大的时候我们就慢慢失去了那些转折点。试着在任何一个你觉得亲切的群体里更好的安置自己，无论那个群体是你的家庭，你的邻居，你的文明，或是你的种族。</p><p>少往前看，少往后看。试着更多关注现在的自己。开始建立回忆而不是活在回忆里。开始创造你的未来而不是期待更好的未来。如果你不这样做，你的生活就会成为一片雾，横跨你的整个人生。（在某个阶段做事时候，不要总想着下一阶段，专注于现在。）</p><p>创造。在旅行中书写，或者画点什么。写一首歌，即使你从未演奏它。当你走的时候，开始改变你遗留下来的纪念品。</p><p>放手。原谅那些伤害你的人。我很遗憾你受到了伤害。但是如果你不将那些伤痛留在过去，它就会像狼一样跟着你——当你做任何事情的时候，它永远扮演着一个危险的影子。</p><p>更多的为他人担心。很多时候是我们的自恋毁了我们。这听上去很反直觉，但是每天花些时间想想你生活中人们的需求。帮助他们实现一些需求会使你更加开心，这个你现在可能不会理解。</p><p>停止奔跑。其实没有一个地方是“在远处”的。你想旅行多远就多远，但是当你到达那里的时候，你将始终发现你在等待着自己。拔出你的剑。是时候回头和你心中的巨龙搏斗了。 ## <a href="https://www.zhihu.com/question/24047876/answer/37943380">关于高考，你印象最深的是什么</a> 高考前的人生轻薄如纸，越往后走，生活才越显出复杂与沉重的本来面目。</p><p>我希望各位能在高考中取得好成绩，但我更希望，当你们背负着越来越沉重的人生往前走时，依然不会失去感受幸福的能力。</p><p>从知道得病至今我一直坦然和平静，我总是想，人不能只允许自己遇到好事，不允许自己遇到坏事。当不顺或困境找到我时，我会反问自己：为什么不可以是我？于是就能平静地去面对。 ## <a href="https://www.zhihu.com/question/23606484/answer/25156325">这样的努力真的有意义吗</a> 强者懂得，不管喜欢与否，现有的事情要做得漂亮。才有资格在人生方向确定时，发现自己已经有充分的积累，实现他们的梦想。</p><p>不管你是什么level的，永远有无数的人跟你同一个level，而你只要不断努力，就能超过这些本来跟你同level的人。 ## <a href="https://www.zhihu.com/question/19627497/answer/15875565">你是如何变得不浮躁的</a> 浮躁是因为急于求成而产生的一种不安的心理。心中总是想着做更多的事情，更快的获得成功，更快的抵达自己的目标，使我们忘记了，我们是为什么去做一件事情。</p><p>做一件事的最重要的是求的心灵的安宁。当我们充满激情的想做完成一件作品时，我们的心不是安宁的。一直到作品呈现出，它应该有的形式，我们心灵才获得了安宁，才获得了喜悦。</p><p>然而当你想着赶快做完一件事的时候，就说明你不再关心此事，而是想着下一件事，你匆匆忙忙的应付了眼前的事，然后又赶紧开始下一件事，你的心没有得到过安宁。前面事情又做的不够好，你会更不安，更浮躁。戒浮躁就要做好当下的事，投入你的热忱，直到做好它，那时你的心才得到安宁。</p><p>高僧把扫地也当成他生活的一部分，他沉浸于扫地这个过程，直到把地扫干净，他获得了心灵的安宁，这种安宁对他来说比任何东西都重要。他过得是一种沉浸式的生活。而心浮气躁的人总是过着肤浅的生活。</p><p>放慢自己做事情的速度，投入自己的热忱。不要着急地去做一件事情，先端正自己的态度，寻找做此事的热忱。</p><p>冥想，静坐，都是不错的训练方法。 ## <a href="https://www.zhihu.com/question/34970791/answer/63071829">能否用一百字写清楚你最想要的生活</a> 冬。 大雪。 小火炉。 热巧克力。 温暖的沙发。 脚边打滚的猫。 阳台上赏雪的狗。 笼子里好动的仓鼠。 靠在我肩上瞌睡的你。 水瓶里开得正盛的鲜花。 爸妈刚打来一个电话。 你们有空回来喝茶。 我给你盖上被子。 没想吵醒你啦。 你揉了揉眼。 一起睡吧。 那好吧。 讨厌！ 哈。 ## <a href="https://www.zhihu.com/question/28639137/answer/374782107">如何做一个让人眼前一亮的 presentation</a> 当然，不同场合需要不同的风格，但是整体流程一定要像讲故事一样，大致有3步： 1. 一个看似平静的现状 不超过10%时间，用一个小故事开场引出问题，接着要改造，团队应运而生，我是xx团队的xxx，团队致力于xxx，最主要的feature是xxx 2. 遇到困难，甚至已经不行了 对比，幽默、数据展示、逻辑说明（乔布斯） 经典采访音频、震撼的图片 大图片+小文字 大数字+小文字 3. 凭借聪明才智翻转，最终战胜困难 勾画出一个美好的愿景</p><p>下来就是看一些经典的发布会，加强练习。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Performance Measurement</title>
      <link href="/2020/12/20/Performance%20Measurement/"/>
      <url>/2020/12/20/Performance%20Measurement/</url>
      
        <content type="html"><![CDATA[<p>程序性能的衡量一般有2种方式：Benchmarking和Profiling。 ## Benchmarking Benchmarking通过绝对运行时间来比较程序的整体性能，例如给定一组同样的输入，比较不同版本的程序在同样硬件环境下的运行时间，或者比较相同版本程序在不同硬件环境下的运行时间。 ## Profiling Profiling通常用来识别程序的耗时瓶颈（通常是一些函数），优化这些瓶颈后再去做Benchmarking评估整体性能。 Unix系统提供了GPROF工具，CSAPP上有一个示例：</p><ul><li>编译：<code>gcc -Og -pg prog.c -o prog</code> <code>-Og</code>表示关闭了很多编译器的优化开关，并且优化了调试信息；<code>-pg</code>表示产生供GPROF剖析用的可执行文件。</li><li>执行：<code>./prog file.txt</code> 会比正常执行要慢一些（慢一倍左右），生成待分析的文件<code>gmon.out</code>。</li><li>分析：<code>gprof prog</code> 结果通常有2部分。 第一部分是不同函数的耗时情况： <img src="https://img-blog.csdnimg.cn/20201012215440170.png#pic_center" alt="在这里插入图片描述" /> 第4列显示了该函数被调用了多少次（不含递归调用），库函数一般不显示在列表中，但是可以通过wrapper function去显示它的执行情况。 第二部分是函数的调用情况，以递归函数<code>find_ele_rec</code>为例： <img src="https://img-blog.csdnimg.cn/20201012220111993.png" alt="在这里插入图片描述" /> 前2行显示了调用该函数的情况：自己递归调用了158555725次，被<code>insert_string</code>调用了965027次，<code>insert_string</code>自己递归调用了965027次；后几行显示了<code>find_ele_rec</code>调用其他函数的情况。</li></ul><p>由于GPROF采用的是interval counting，所以计时可能不太精确，尤其对于运行时间小于1s的程序误差更大。 如何使用Profiling去优化程序，CSAPP上给了一个非常精彩的例子，这里不再赘述。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Quarterly Review</title>
      <link href="/2020/12/10/Quarterly%20Review/"/>
      <url>/2020/12/10/Quarterly%20Review/</url>
      
        <content type="html"><![CDATA[<h1 id="section">2020.9.9~2020.12.9</h1><p>转眼开学已经3个月了，在此做一个简短的总结，明确优缺，针对性改进。 整体来看：可以给自己打75分，各项计划也都在推进，但是有的事情很不顺利，唉习惯了~</p><ul><li>课业 相对来讲优先级很低，我翘掉了应该翘的所有课，节省了宝贵的时间。 弄清了培养方案的细节；英语课通过了免修考试；彻底结束了口语课、人工智能、自然辩证法；</li><li>CS学习 完成了15213的malloc lab；CS 61B的bear map；</li><li>科研 确定了科研选题和研究计划，并着手开始阅读文献；</li><li>其它 教师资格笔试（1门未通过）；六级口语考试；每周运动；适当外出放松；顺利成为积极分子；王道兼职进行的非常顺利，暂时做到了经济独立；</li></ul><p><strong>选定以后，扎实去做</strong> <strong>应付了事，不如不做</strong> - 教资笔试没有全部通过，这是3个月里最糟糕的事情，要拖到21年3月再考一次笔试，面试就只能顺延到21年5月。反思：当时复习时确实轻视了综合素质这门课，总归是付出代价了。。 - 百度人工智能班选拔失败，申请时过于应付，其实不太想去。反思：<strong>以后一旦决定某事，就尽全力准备，不要犹犹豫豫，应付了事，不想做的事就坚决拒绝，不要费力不讨好。</strong> - 系统看书/paper太少，跟老师学长交流比较少。反思：<strong>还是有些浮躁，没有扎扎实实地对待每一件计划内的事，总想着短平快，这是要栽跟头的。</strong> - 平时遇到的一些老师同学，尽量打个招呼，留个联系方式，不要装作没看见，逃避不是好办法； - 对于自己以往的经历，不要撒谎，谎言可能需要更多谎言去弥补。 # 2020.12.9~2021.3.9 ### 生活 对于幸福的追求将会是孜孜不倦、持之以恒的，探索生活的意义永远都是第一要务。</p><p>最近关注了一个UP主<a href="https://b23.tv/n62zL9">天真的和感伤的小说家</a>，使得我又有了一些思考：如果没有自我身份和自我实现的认同，那么会很害怕死亡。无论是现实层面抑或是理想层面，所做之事即使不是引以为傲，至少也要发自内心地赞同。少年时总觉得理想为天，刻不容缓，哪怕粉身碎骨；稍稍长大，觉得首先确保自己的生存，再去向理想看齐并不可耻。解决个人的生存是用另外一种方式促进社会的进步，间接地为理想助力。</p><p>一直觉得自己像是戴了一层面具生活，过得十分拧巴，跟以前的朋友随着时间、距离、阅历的不同而逐渐疏远，更不用说所谓的新认识的“朋友”。摘下面具最好的方法就是“真诚”，当然这里的意思并不是傻乎乎地全盘托出，而是适当地袒露自己的真实想法。卸下伪装对于我有两点：</p><ol type="1"><li>完全没必要用认识很多NB朋友和所谓的社会性话术、酒桌技能来突出自己的人脉或是为人处世的成熟；</li><li>真实地交流自己的经历。</li></ol><p>读研后其实就很少把自己看作纯粹的学生了，希望自己成为半个社会人，为人处世也要遵循规范。意味着属于自己的可支配时间变得越来越少，要协调处理家庭、同事、朋友各种圈子，能敞开心扉倒苦水的人越来越少，要更加珍惜朋友。力所能及的事情，哪怕是陌生人，能帮就帮帮吧，我想会有一些乐趣的。</p><p>最后，学CS实在没什么可炫耀的，家里条件好的谁来这个用命换钱的行业。 ### 学业 一如既往地翘课，但是作业和考试还算是认真对待。 六级很逗比，听力答题卡才涂了一半就被收走了，现在有点纠结今年6月要不要再来一次？</p><p>稍微麻烦一些的事在于：<strong>我还是不够扎实，我太着急了，着急着想要一个结果，着急着完成任务，没有真正属于自己的理解</strong>，更不用谈自己独立做出来！！计算机系的同学应该把提高能力远远地放在第一位，而不是浮华表面的成绩、比赛，最切身的周围环境无时无刻不在消耗着我对于这个学科的热爱，处在一个快节奏的社会，任何事物都追求短平快，内卷加剧浮躁，浮躁也促进内卷，焦虑值继而攀升。</p><p>我还是低估了环境对人的同化作用，读研前我觉得一定要跟大家不一样，但对于意志力不坚定的我，实验室学长的归宿可能是我最好的盼望了。那么这些问题应当如何解决？</p><p>应该时常反问自己：愿意成为一个整天赶作业，均分90+，但是脑袋空空半懂不懂的水货，还是愿意成为真的学了一些东西，可以讲出自己的理解的人？这次扎实学了，下次捡起来就可以省力很多，这大概就是磨刀不误砍柴工？不要在环境的内卷中迷失本质的能力！！对计算机科学（任何科学知识）保持谦卑和敬畏的态度，汲取养分，返璞归真。</p><p>在“来西交基本等于完蛋，来生信实验室彻底完蛋”的氛围下，少受一些周围同学的影响，平静接受自己难以改变的，经常反思自己：<strong>我是水货吗？？</strong></p><p><strong>真的不要再浮躁和偷懒了，最后的时光了</strong>。做事情要保证基本的连贯，不要频繁切换。learning by doing目前来看效果不错。</p><p>合作时弄清什么是自己该做的，什么是该推给别人的，不要当圣母，该喷就喷，否则会把自己搞得很累，还吃力不讨好，将来工作是要吃亏的。</p><p>最后，经常和学长学姐沟通！！！ ### 工作 接下来要准备下<strong>实习的申请</strong>：刷题、熟悉简历，不论最后能不能去，先拿到入场券总是不差的。</p><p>最重要的是<strong>自信</strong>，很多事情都可以努力争取，不去争取怎么知道可不可以呢？遇到稍微有点冲突的事情，不要因为畏惧而觉得几件事一定冲突，只能选一件，其实很多时候，合理安排都可以兼得，<strong>勇敢尝试，不要畏手畏脚</strong>。机会多如牛毛，多去试试，失败了还有其他的呢。</p><p>合格的职场人<span class="math inline">\(\Rightarrow\)</span>合格的工程师<span class="math inline">\(\Rightarrow\)</span>合格的算法工程师： <img src="https://img-blog.csdnimg.cn/20210224140520159.png" alt="在这里插入图片描述" /> 关于程序员大龄危机，抠个<a href="https://www.zhihu.com/question/392425409/answer/1207099799">回答</a>：</p><blockquote><p>租鸡青一，不买房不结婚不约会不大额消费，做程序员工资高，争取35之前存够100万，然后能撑多久撑多久，一旦40岁裁员下岗，就去四线城市找个安静的地方安度接下来的日子，自己买个便宜的商铺开开小卖部或五金店，反正自己吃住都在那里。有空能线上接单就接单，做做教程装装逼能赚点外快有一点是一点，不炒股不炒币投资理财只买银行保本型。把自己消费控制在每年3万以内，每天跑步加强锻炼，不抽烟不喝酒多吃肉蛋奶少吃高糖高油高盐，相信我，这样你会比你的同龄人活得更久，这样一来差不多可以苟到退休，退休后运气好就有退休金了！运气不好退休金玩完了，就提前买辆车跑滴滴。 你说生病了怎么办？这个世界上只有一种病：穷病！小病自己熬，大病自付超过三万主动放弃，和医生明确时间，然后去完成自己最后的愿望，别多想，这就是人生，命运从不讲道理。你要想，你已经比那些加班到突然猝死，什么遗愿都没去完成，带着劳累痛苦而走的同龄人要幸运太多了。 年轻人别想太多，你们有选择的权利！</p></blockquote><p>最后，目前打算毕业去一线互联网，之后跳槽独角兽或者回西安。 ### 乱七八糟 抠个网抑云热评：</p><blockquote><p>世上最幸福的便是： wifi满格 您的快递正在配送 打开电视就看到自己的偶像 天气刚好 旧衣服里的零钱 手机只剩1%时刚好踏进家门 买到炸鸡店里最后一只鸡腿 考的都会 蒙的全对 你喜欢的人刚好也喜欢你 幸福就是这么简单</p></blockquote><p>坚持锻炼身体，坚持午休，保持高效的作息，注意用眼卫生。</p><p>最后的最后，<strong>计划一直都在，高效认真执行否？</strong> # 2021.3.9~2021.6.9 以前的学习太关注整理优质资料，只是把别人的复述下而已，这不是真正学习的方法，一定要有自己的<a href="https://lyqlola.github.io/MyBlog/hs%E8%AF%B4/">motivation</a>，这样之后用自己的理解写出来。</p><p>还是有点浮躁和自以为是，整天喷这个骂那个，其实潜意识里认为自己已经什么都会，但事实上并没有静心钻研，事情也没有认真对待。不要让焦虑控制自己，扪心自问：老师讲的你都会了吗？能自己独立推导吗？能自己独立实现吗？</p><p>另外，每天晚上走的有点早，总是潜意识认为自己回来有事，实际上还是看b站。</p><p>首先，不要乱喷，自己心里知道就好，也不要以国外的课为荣，不管哪种方式和资源，掌握知识才是最重要的。</p><p>其次，仔细认真对待磕研任务，公开课学习，以及刷题过程中的数学计算机知识，相信以后会有用的。要能踏实地坐在工位上，专注学习，翘课当然没问题，最主要还是为了更重要的事情。</p><p>做好当下的事和未来的计划，合理安排时间，不要以喷为荣，当做自己的本事，真正的本事应该是知识的触类旁通。</p><p>碰到难点或者麻烦点，不要着急，该花的时间还得花，不要急于求成，忽略理解和实现的过程。这一点要向一览和英鹏看齐。</p><p>加油吧少年，未来还很长，不要给自己太大压力。</p><p>找时间系统输入知识，而不是疯狂输出，零碎补充，这就没油了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Malloc Lab</title>
      <link href="/2020/11/28/Malloc%20Lab/"/>
      <url>/2020/11/28/Malloc%20Lab/</url>
      
        <content type="html"><![CDATA[<h2 id="basic-info">Basic Info</h2><p>这是CMU 15-213的Malloc Lab，本来没打算做，被同学安利了一波~ 需要用C实现A Dynamic Storage Allocator，类似于<code>libc</code>中的<code>malloc/free/realloc</code>，整体来看难度较大。</p><p>开始没什么思路，看了下CSAPP动态内存分配那一节。 内存的划分是这样子的： <img src="https://img-blog.csdnimg.cn/2020101116464245.png" alt="在这里插入图片描述" /> 运行时分配的虚拟内存主要是Heap，Allocator将堆视作不同size的块，Allocator有2种：</p><ul><li>Explicit Allocators：需要应用程序手动释放申请的内存块，<code>malloc/free</code></li><li>Implicit Allocators：就是garbage collectors</li></ul><p><code>malloc</code>返回的对齐地址取决于编译环境，32位是8的倍数，64位是16的倍数；<code>malloc</code>不会初始化申请的内存，<code>calloc</code>会初始化内存为0。 堆的增长是通过增加内核的<code>brk</code>指针来增加/减小堆： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span>;  <span class="comment">// success: old brk pointer; error: -1</span></span><br></pre></td></tr></table></figure> 如果<code>free</code>的是一个非法指针，那么结果未定义。</p><p>主要实现在<code>mm.c</code>中，有4个主要函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><code>mm_init</code>负责初始化，比如分配初始的堆空间，成功返回0，失败返回-1； <code>mm_malloc</code>负责分配指定大小的空间，但是这个空间必须在已经初始化的堆里，不能与其他空间冲突；返回的指针按照8B对齐，与<code>libc</code>中实现的<code>malloc</code>类似，最后会有一个PK； <code>mm_realloc</code>负责：</p><ul><li><code>ptr</code>为<code>NULL</code>，等价于<code>void *mm_malloc(size)</code></li><li>size=0，等价于<code>mm_free(ptr)</code></li><li>如果<code>ptr</code>不为<code>NULL</code>，把<code>ptr</code>所指的内存块增加/减小到<code>size</code>个字节，返回新地址（可能与原来的块相同，也可能不同，取决于实现方式、原块里内碎片的数量以及请求<code>size</code>的大小），保持原块的内容不变（如果申请变大，剩下的空间是未初始化的；如果申请变小，那么只保留<code>size</code>大小的原块内容）</li></ul><p><code>memlib.c</code>为我们的分配器模拟了内存系统，可以调用里面的一些函数： <code>void *mem_sbrk(int incr)</code>: 将堆扩展<code>incr</code>B，参数是正整数，返回新分配的内存首地址； <code>void *mem_heap_lo(void)</code>: 返回堆的首地址； <code>void *mem_heap_hi(void)</code>: 返回堆的最后一个字节的地址； <code>size_t mem_heapsize(void)</code>: 返回当前堆的大小； <code>size_t mem_pagesize(void)</code>: 返回系统页面大小。 ## Implementation 首先明确设计约束条件：</p><ul><li>可以处理任意的请求释放序列</li><li>请求需要被立即响应</li><li>内存对齐要求</li><li>不能修改已经分配的内存块</li></ul><p>再明确设计目标：</p><ul><li>最大化吞吐量</li><li>最大化内存利用率</li></ul><p>吞吐量最大化：单位时间处理的请求，分配复杂度<span class="math inline">\(O(n)\)</span>，n是空闲块的数目，释放复杂度<span class="math inline">\(O(1)\)</span>； 内存利用率最大化：用peak utilization衡量，假设有<span class="math inline">\(n\)</span>个请求：<span class="math inline">\(R_0, R_1, ... R_k, ..., R_{n-1}\)</span>，在<span class="math inline">\(R_k\)</span>完成后，将aggregate payload(申请的字节总数)记作<span class="math inline">\(P_k\)</span>，当前的堆的大小记作<span class="math inline">\(H_k\)</span>(单调不减)，单调不减的条件可以通过使<span class="math inline">\(H_k\)</span>为high-water mark来松弛，这样堆就可以上下都增长。那么peak utilization为： <span class="math display">\[U_k=\frac{max_{i\leq k}P_i}{H_k}\]</span> 我们的目标是最大化<span class="math inline">\(U_{n-1}\)</span>。</p><p>这两目标是需要trade-off的，吞吐量越大，意味着需要减小操作的时间，往往就不能花费时间去处理碎片；内存利用率越大，意味着要精心处理分配和回收的块，自然需要更多的时间。</p><p>具体来说，有以下几点： <img src="https://img-blog.csdnimg.cn/20201023215211206.png" alt="在这里插入图片描述" /> 这些关键细节的设计非常重要，再BB一次：程序架构、数据结构和接口设计是一门艺术！</p><ul><li><code>free</code>只给一个指针，怎么知道要释放多少空间：记录每一块的大小；</li><li>空闲块的组织管理：隐式链表、显式链表（双向链表）（存储指针域开销太大）、Segregated Free Lists、将空闲块始终按大小排序；</li><li>Placement: 有多个满足要求的空闲块，如何选择以放置新的申请：First Fit, Next Fit, Best Fit</li><li>Splitting: 在一个空闲块放置申请后如何处理剩余的空闲空间。可以直接将整个空闲块分配出去，也可以将剩余的空闲空间重新利用；</li><li>无法找到合适的满足请求的块：做空闲块合并后再次检查是否可以满足；用<code>sbrk</code>向内核申请更多的内存，插入空闲链表；</li><li><strong>空闲块合并</strong>：需要考虑何时合并：立即合并（可能引发抖动）、延迟合并（申请失败时合并整个堆里所有的空闲块）；合并后面的块很容易，但是要高效合并前面的空闲块，需要用双向的Boundary Tag(可以优化以减少空间开销)；</li></ul><p>不仅需要记录每块的大小，还需要区分已分配块和空闲块，所以block的格式可以设计如下： <img src="https://img-blog.csdnimg.cn/20201011195117307.png" alt="在这里插入图片描述" /> 如果要求double-word(8B)对齐，那么Block size总是8的倍数，所以低3位都是0，可以利用其存储分配状态。</p><p>这样整个堆就可以组织为连续的分配和空闲块，由于已经存储了每块的大小，所以隐式空闲链表就应运而生： <img src="https://img-blog.csdnimg.cn/20201014165121101.png" alt="在这里插入图片描述" /> 隐式链表可以在<span class="math inline">\(O(1)\)</span>的时间里合并之后的空闲块，但是要合并之前的空闲块，需要<span class="math inline">\(O(n)\)</span>的时间扫描整个堆，这显然无法接受。Knuth大佬提出了boundary tags，这样实际上相当于隐式双向链表： <img src="https://img-blog.csdnimg.cn/20201011214226551.png" alt="在这里插入图片描述" /> 这样就可以通过Footer在<span class="math inline">\(O(1)\)</span>检查之前的块的状态及其开始位置，缺点在于如果小的内存块比较多的话，内存开销太大。 双向tag带来的内存开销可以优化：只有前面的块是空闲，才需要它footer里的大小，所以可以在每个块用后3位里的某一位来存储前面块的状态，那么已分配块就不需要footer了，可以把footer的空间用来当作payload，但是空闲块仍然需要2个tag。</p><p>那么现在整个堆变成了这样： <img src="https://img-blog.csdnimg.cn/20201016204303577.png" alt="在这里插入图片描述" /> 这里的<code>heap_listp</code>指向Prologue block的中间是做了一些小优化，方便直接定位到下一块的数据位置。</p><p>这里的实现非常tricky和subtle，一开始只申请了4words，unused(1)+Prologue(2)+Epilogue(1)，后续的<code>extend_heap</code>申请一个空闲块后，将原来的Epilogue作为空闲块的header，空闲块的最后一个word变为新的Epilogue。</p><p>由于对齐要求（Headers在非对齐位置，Payloads对齐），分配器应该有一个minimum block size，即使只请求了1B，也要分配minimum block size，这里是16B。</p><p>写代码时先实现并测试<code>malloc</code>和<code>free</code>，如果能正确并且高效执行，再去实现<code>realloc</code>。 ## Evaluation 性能主要考虑2方面因素：</p><ul><li>空间利用率<span class="math inline">\(U\)</span>：peak ratio即评测程序申请的总内存（<code>mm_malloc/mm_realloc</code>但是还没有<code>mm_free</code>）与分配器使用的堆容量的比值，需要用好的策略减小碎片，使得该值接近1；</li><li>吞吐量<span class="math inline">\(T\)</span>：每秒完成的操作数量</li></ul><p>评测程序会综合考虑2个方面，计算一个performance index <span class="math display">\[P=wU+(1-w)min(1,\frac{T}{T_{libc}})\]</span> <span class="math inline">\(T_{libc}\)</span>是<code>libc</code>中的<code>malloc</code>的吞吐量，大概在600Kops/s左右，<span class="math inline">\(w=0.6\)</span>。 这个<span class="math inline">\(P\)</span>既考虑了内存资源，又考虑了CPU资源，两个矛盾的指标需要适当权衡。</p><p>第一个版本<code>mm1.c</code>基本就是抄书，Implicit Free Lists+First Fit+Bi Boundary Tag，抄书也就将将及格。。 <img src="https://img-blog.csdnimg.cn/20201115143013580.png" alt="在这里插入图片描述" /> 将First-Fit改成Next-Fit，还不错： <img src="https://img-blog.csdnimg.cn/20201115202312126.png" alt="在这里插入图片描述" /> 可以看到：Next-Fit在速度上有很大提升，主要是因为它是从上次终止的块开始搜索，避免了前面很多块的无效搜索。</p><p>最后对于Implicit Lists的性能做个总结： 分配：<span class="math inline">\(O(n)\)</span> 释放：<span class="math inline">\(O(1)\)</span> Memory Overhead：取决于First Fit等策略</p><p>感觉这个性能已经不错了，但是一些无聊的计算机科学家还是不满意分配时的效率。接着我们看下更加🐂🍺的方法Segregated Free Lists： <img src="https://img-blog.csdnimg.cn/20201024204031234.png" alt="在这里插入图片描述" /> 每个size级别的块都有自己的free list，分配大小为n的块时：</p><ul><li>搜索合适的free list使得size&gt;n</li><li>找到：split并将remainder放入应该去的list</li><li>未找到：向操作系统申请更大的内存，分出去n，将剩下的放入相应的list</li></ul><p>释放时合并空闲块并且放入相应的free list即可。</p><p>这实际上近似模拟了Best Fit，而且不用搜索整个free list，Best Fit一般有着最优的内存利用率，但是运行时间<span class="math inline">\(O(n)\)</span>，又是吞吐量和内存利用率的trade-off，终于明白了为什么官方的<code>malloc</code>要用这个方式了：吞吐量更大<span class="math inline">\(O(lgn)\)</span>、更优的内存利用率Best Fit。</p><p>Segregated Free Lists中的空闲块包含Header+prev+next+padding+Footer，已分配块没有前后指针。 写代码要注意：整个堆中的块位置是不变的，只是状态（分配、释放）在改变，整个堆中的空闲块是用seg list的方式串起来的。</p><p>Debug可以自己写一下<code>mm_check</code>，还是很有用的。 <code>realloc</code>快de疯了，整整一个晚上。。。其实就4种情况：</p><ol type="1"><li>如果当前已分配块后面是结尾块，直接申请新的堆空间，与原块组合返回；</li><li>如果当前已分配块后面是一个空闲块，且两者之和&gt;=size，组合返回；</li><li>如果当前已分配块后是一个空闲块，但两者之和&lt;size，但是空闲块后是结束块，申请新的堆空间，三者组合返回；</li><li>malloc新块，将原块复制，释放原块。</li></ol><p>第一次写完，只有85，内存利用率太差了： <img src="https://img-blog.csdnimg.cn/20201117220719669.png" alt="在这里插入图片描述" /> <code>place</code>的时候，如果申请块比较大，我们将其分配到后半部分，将前半部分切割为空闲： <img src="https://img-blog.csdnimg.cn/2020111909030584.png" alt="在这里插入图片描述" /> 之前class的划分是1，2-3，4-7，8-15... 但是最小块是16B，所以16B以下的用不到，所以改为16-31，32-63，64-127，128-255...</p><p>这样优化后直接96： <img src="https://img-blog.csdnimg.cn/20201119092357832.png" alt="在这里插入图片描述" /> 后面还可以继续优化榨干性能，比如去掉已分配块的Footer，<code>realloc</code>组合块以后对remainder进行split... 以后有时间再说......</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Stacking</title>
      <link href="/2020/11/17/Stacking/"/>
      <url>/2020/11/17/Stacking/</url>
      
        <content type="html"><![CDATA[<p>Ensemble Learning的基本思想就是将多个基学习器组合在一起，产生泛化能力更强的模型。 组合策略有许多种，包括Voting、平均法和Stacking等，Stacking就是选择某种学习器作为组合基学习器的方式。 <img src="https://img-blog.csdnimg.cn/20200926193430376.png" alt="在这里插入图片描述" /> 既然要结合多个基学习器的优点，那么基学习器的选择最好是“准而不同”，元学习器一般选择比较简单的模型（如逻辑回归），防止过拟合。 比较简单的想法就是将全部训练集用于训练基学习器，将基学习器的预测结果作为元学习器的训练集，从而得到整个模型。 这样做的问题在于：基学习器最终在训练集上的表现非常好，再用基学习器在该训练集上的预测结果作为次级训练集，同样元学习器在该训练集上表现也会非常好，但是模型的泛化能力不一定很好，有过拟合的风险。 因此，采用K折交叉验证的方式，用训练基学习器未使用的样本来产生次级训练集。 <img src="https://img-blog.csdnimg.cn/20201109191045436.jpg" alt="在这里插入图片描述" /> 具体来讲： 在训练阶段（假设训练集<span class="math inline">\(400*10\)</span>），对于每个基学习器（假设有3个基学习器），进行5次训练与验证，得到<span class="math inline">\(400*1\)</span>的验证结果，那么最终次级训练集是<span class="math inline">\(400*3\)</span>（类标签还是原始类标签），用这些数据训练次级学习器，完成后再用全部的训练集训练所有的基学习器（可选，提高基学习器性能）； 在测试阶段，如果训练阶段选了最后一步，那么每个基学习器直接得到一个结果，就会得到3个测试结果，送入次级学习器，得到最终的预测结果；如果训练时没有选最后一步，那么每个基学习器都有5个小模型，将测试样本用5个小模型分别测试，将5个结果平均得到某个基学习器的预测结果，也会得到3个测试结果。 <img src="https://img-blog.csdnimg.cn/20201109192340496.png" alt="在这里插入图片描述" /> Weka里的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Buildclassifier selects a classifier from the set of classifiers</span></span><br><span class="line"><span class="comment">   * by minimising error on the training data.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> data the training data to be used for generating the</span></span><br><span class="line"><span class="comment">   * boosted classifier.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the classifier could not be built successfully</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 建立整个模型</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildClassifier</span><span class="params">(Instances data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_MetaClassifier == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No meta classifier has been set&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断分类器是否有能力处理该数据集</span></span><br><span class="line">    getCapabilities().testWithFail(data);</span><br><span class="line">    <span class="comment">// 删除类标签缺失数据</span></span><br><span class="line">    Instances newData = <span class="keyword">new</span> Instances(data);</span><br><span class="line">    m_BaseFormat = <span class="keyword">new</span> Instances(data, <span class="number">0</span>);</span><br><span class="line">    newData.deleteWithMissingClass();</span><br><span class="line">    </span><br><span class="line">    Random random = <span class="keyword">new</span> Random(m_Seed);</span><br><span class="line">    newData.randomize(random); <span class="comment">// 打乱整个数据集</span></span><br><span class="line">    <span class="comment">// 如果是分类问题，分层抽样</span></span><br><span class="line">    <span class="comment">// 原始数据按照类标签集中在一起，按m_NumFolds为步长重新抽取数据，保持训练集/验证集数据分布一致性, 避免因数据划分引入额外的偏差</span></span><br><span class="line">    <span class="keyword">if</span> (newData.classAttribute().isNominal()) &#123;</span><br><span class="line">      newData.stratify(m_NumFolds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理原始数据得到新的数据，建立meta classifier</span></span><br><span class="line">    generateMetaLevel(newData, random);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// restart the executor pool because at the end of processing</span></span><br><span class="line">    <span class="comment">// a set of classifiers it gets shutdown to prevent the program</span></span><br><span class="line">    <span class="comment">// executing as a server</span></span><br><span class="line">    <span class="comment">// 创建线程池，为下面的基学习器训练做准备</span></span><br><span class="line">    <span class="keyword">super</span>.buildClassifier(newData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提高基础模型的准确度，使其在测试数据表现更好，用所有的训练集进行基学习器的训练</span></span><br><span class="line">    <span class="comment">// 这里为了节省时间，测试时，可以直接在多个基学习器预测后取平均</span></span><br><span class="line">    <span class="comment">// Rebuild all the base classifiers on the full training data</span></span><br><span class="line">    buildClassifiers(newData);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Generates the meta data</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newData the data to work on</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> random the random number generator to use for cross-validation</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">generateMetaLevel</span><span class="params">(Instances newData, Random random)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 先用newData得到metaData的格式m_MetaFormat</span></span><br><span class="line">    <span class="comment">// 确定元分类器需要的属性</span></span><br><span class="line">    Instances metaData = metaFormat(newData);</span><br><span class="line">    m_MetaFormat = <span class="keyword">new</span> Instances(metaData, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_NumFolds; j++) &#123;</span><br><span class="line">      <span class="comment">// 得到训练集</span></span><br><span class="line">      Instances train = newData.trainCV(m_NumFolds, j, random);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// start the executor pool (if necessary)</span></span><br><span class="line">      <span class="comment">// has to be done after each set of classifiers as the</span></span><br><span class="line">      <span class="comment">// executor pool gets shut down in order to prevent the</span></span><br><span class="line">      <span class="comment">// program executing as a server (and not returning to</span></span><br><span class="line">      <span class="comment">// the command prompt when run from the command line</span></span><br><span class="line">      <span class="comment">// 线程池，多线程并行构建基学习器</span></span><br><span class="line">      <span class="keyword">super</span>.buildClassifier(train);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建基学习器</span></span><br><span class="line">      buildClassifiers(train);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Classify test instances and add to meta data</span></span><br><span class="line">      <span class="comment">// 将未使用过的原始训练数据通过基学习器预测后加入metadata作为新的训练集</span></span><br><span class="line">      Instances test = newData.testCV(m_NumFolds, j);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.numInstances(); i++) &#123;</span><br><span class="line">    metaData.add(metaInstance(test.instance(i)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用元数据建立元分类器</span></span><br><span class="line">    m_MetaClassifier.buildClassifier(metaData);    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>因为基学习器之间的训练是独立的，所以每次交叉验证划分好数据后，都是利用线程池并行训练。 如果是在分层抽样的基础上划分训练集和验证集，<code>trainCV()</code>抽取数据后，需要将新的训练集Shuffle，保证独立同分布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes the format for the level-1 data.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> instances the level-0 format</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the format for the meta data</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the format generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 生成元数据格式</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Instances <span class="title">metaFormat</span><span class="params">(Instances instances)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果m_BaseFormat属性连续，就加入m_Classifiers.length个属性</span></span><br><span class="line">    <span class="comment">// 如果是离散的，每次要加入level 0类别属性取值个数个属性</span></span><br><span class="line">    ArrayList&lt;attribute&gt; attributes = <span class="keyword">new</span> ArrayList&lt;attribute&gt;();</span><br><span class="line">    Instances metaFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历基学习器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m_Classifiers.length; k++) &#123;</span><br><span class="line">      Classifier classifier = (Classifier) getClassifier(k);</span><br><span class="line">      String name = classifier.getClass().getName() + <span class="string">&quot;-&quot;</span> + (k+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (m_BaseFormat.classAttribute().isNumeric()) &#123;</span><br><span class="line">    attributes.add(<span class="keyword">new</span> Attribute(name));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果离散，后续会通过每个取值的概率来判断，比如杂色、圆花，这2种特性不能用一个属性表示，所以每个取值都要独立成单独的属性</span></span><br><span class="line">          <span class="comment">// 来保存概率值</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_BaseFormat.classAttribute().numValues(); j++) &#123;</span><br><span class="line">        attributes.add(</span><br><span class="line">          <span class="keyword">new</span> Attribute(</span><br><span class="line">      name + <span class="string">&quot;:&quot;</span> + m_BaseFormat.classAttribute().value(j)));</span><br><span class="line">    &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加上原始类标签</span></span><br><span class="line">    attributes.add((Attribute) m_BaseFormat.classAttribute().copy());</span><br><span class="line">    <span class="comment">// 形成元数据格式</span></span><br><span class="line">    metaFormat = <span class="keyword">new</span> Instances(<span class="string">&quot;Meta format&quot;</span>, attributes, <span class="number">0</span>);</span><br><span class="line">    metaFormat.setClassIndex(metaFormat.numAttributes() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> metaFormat;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>生成元数据格式时，如果是分类问题，类标签的每个属性都被作为一个新的属性： <img src="https://img-blog.csdnimg.cn/20201109195503863.png" alt="在这里插入图片描述" /> 这里我个人这样理解：有的基分类器可以输出属于某个类的概率（如逻辑回归），将概率作为元属性而不是直接将基学习器的分类结果作为元属性，这样做能够减小基学习器的分类误差带给元学习器的影响，模型整体更加精确： <img src="https://img-blog.csdnimg.cn/20201109195918632.png#pic_center" alt="在这里插入图片描述" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes a level-1 instance from the given instance.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> instance the instance to be transformed</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the level-1 instance</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the instance generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 产生元数据</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Instance <span class="title">metaInstance</span><span class="params">(Instance instance)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// values保存分类结果，连续属性直接保存，离散属性则先求得分布，将每种取值的分布加入values，设置为m_MetaFormat格式返回</span></span><br><span class="line">    <span class="keyword">double</span>[] values = <span class="keyword">new</span> <span class="keyword">double</span>[m_MetaFormat.numAttributes()];</span><br><span class="line">    Instance metaInstance;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m_Classifiers.length; k++) &#123;</span><br><span class="line">      Classifier classifier = getClassifier(k);</span><br><span class="line">      <span class="keyword">if</span> (m_BaseFormat.classAttribute().isNumeric()) &#123;</span><br><span class="line">    values[i++] = classifier.classifyInstance(instance);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 基学习器对该实例的分类的概率分布, sum(dist)=1</span></span><br><span class="line">    <span class="keyword">double</span>[] dist = classifier.distributionForInstance(instance);</span><br><span class="line">    <span class="comment">// 将该基学习器对该实例的预测概率输出到对应的元属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dist.length; j++) &#123;</span><br><span class="line">      values[i++] = dist[j];</span><br><span class="line">    &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标签值对应最后一个元属性</span></span><br><span class="line">    values[i] = instance.classValue();</span><br><span class="line">    metaInstance = <span class="keyword">new</span> DenseInstance(<span class="number">1</span>, values);</span><br><span class="line">    metaInstance.setDataset(m_MetaFormat);</span><br><span class="line">    <span class="keyword">return</span> metaInstance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在实际数据集上的结果其实不一定比其他模型效果好，可能是我参数调的不好吧（雾）~ </attribute></attribute></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bear Maps</title>
      <link href="/2020/11/07/Bear%20Maps/"/>
      <url>/2020/11/07/Bear%20Maps/</url>
      
        <content type="html"><![CDATA[<h2 id="intro">Intro</h2><p>这是CS 61B的Project 3，也是最后一个Proj。刚好上完这门课出去旅个游，放松下心情开始15213。 完成基本的要求花了5天时间，当然现在的版本还十分简陋，这个工程我是想做得比较大，后面还得抽时间消化理解、完善优化。</p><p>SP18用了<a href="https://maven.apache.org/">Apache Maven</a>做项目建构工具，<a href="https://blog.csdn.net/qq_41431457/article/details/102999439">折腾</a>了一天也没有配好，<del>不知道这么垃圾的工具有啥用</del> ，最后实在没辙就把该项目所有需要的jar包导进来，后来发现SP19就抛弃了maven。 <img src="https://img-blog.csdnimg.cn/20200623161825813.png" alt="在这里插入图片描述" /> 项目需要的地图集以及地图上的点/路信息都是Google采集好的，可在<a href="https://github.com/Berkeley-CS61B">这里</a>下载，当然这个地图只是一小部分，后面想要扩展可以去下载需要的<a href="https://www.openstreetmap.org/">数据集</a>，包括tile images和map feature data。</p><p>整体需求是实现一个网页端地图，用户通过浏览器输入URL，Java程序接收，然后生成相应的地图结果并返回，在浏览器中显示。服务器框架用的是<a href="http://sparkjava.com/documentation.html#getting-started">Spark</a>，前端以及前后端交互的部分已经写好了（TA真的太强了），其实我有时候觉得这些dirty的工作比较考验码力，这些代码写得漂亮说明System的能力是挺强的。</p><p>后端至少需要实现3个类：</p><ul><li><code>Rasterer</code> 输入upper left latitude and longitude, lower right latitude and longitude, a window width, and a window height. 输出2D array of filenames corresponding to the files to be rendered.</li><li><code>GraphDB</code> 输入Open Street Map数据集，将其转为图存储起来：每个结点是a single intersection，每条边是一条路。</li><li><code>Router</code> 输入GraphDB, a starting latitude and longitude, and a destination latitude and longitude. 输出从起点到终点的一系列结点，以及路径导航信息。 ## Map Rastering 首先要将用户查询的真实世界的经纬度信息转为实际地图，<code>Rasterer.java</code>会接收用户请求的矩形参数<code>Map&lt;String, Double&gt; params</code>，生成对应的图像名称<code>String[][]</code>： 主要工作在<code>getMapRaster()</code>方法中完成，用户输入的查询请求共有6个参数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;lrlon=-<span class="number">122.2104604264636</span>, ullon=-<span class="number">122.30410170759153</span>, w=<span class="number">1085.0</span>, h=<span class="number">566.0</span>, ullat=<span class="number">37.870213571328854</span>, lrlat=<span class="number">37.8318576119893</span>&#125;</span><br></pre></td></tr></table></figure><p>表示用户希望显示经度范围<code>lrlon</code>~<code>ullon</code>，纬度范围<code>ullat</code>~<code>lrlat</code>的区域，并且分辨率大概是<code>w*h</code>。</p><p>街景图采用<strong>冗余存储</strong>，所有图片都是<code>256*256</code>：<code>d0_x0_y0.png</code>是整个区域的街景，但是分辨率最低，<code>d1_x0_y0.png/d1_x0_y1.png/d1_x1_y0.png/d1_x1_y1.png</code>分别代表西北/东北/西南/东南四个角的街景，但是分辨率加倍。</p><p>更加规范的说：在第D个缩放级别，共有<span class="math inline">\(4^D\)</span>张图片，<code>dD_x0_y0.png</code>到<code>dD_xk_yk.png</code>，<span class="math inline">\(k=2^D-1\)</span>，随<code>x</code>增大向东移动，随<code>y</code>增大向南移动，我们需要返回<code>String[][]</code>代表用户请求区域的图片文件名矩阵，当然还有一些其他参数（查询是否成功等）：由于Java只能返回一个值，所以结果组装成<code>Map&lt;String, Object&gt;</code>返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[d2_x0_y1.png, d2_x1_y1.png, d2_x2_y1.png, d2_x3_y1.png],</span><br><span class="line">[d2_x0_y2.png, d2_x1_y2.png, d2_x2_y2.png, d2_x3_y2.png],</span><br><span class="line">[d2_x0_y3.png, d2_x1_y3.png, d2_x2_y3.png, d2_x3_y3.png]]</span><br></pre></td></tr></table></figure><p>上述返回结果的分辨率为<code>1024*768</code>，几乎满足用户分辨率要求<code>1085*556</code>。</p><p>这样对于同一个区域，可以有很多选择：可以用更多张高分辨率图片的组合，也可以用较少几张低分辨率的图片组合，只要满足用户要求，比如对于上述例子，<code>d2_x0_y1.png</code>可以采用<code>d3_x0_y2.png/d3_x1_y2.png/d3_x0_y3.png/d3_x1_y3.png</code>代替，这样返回的图片是<code>6*8</code>共48张，分辨率可达<code>2048*1536</code>。</p><p>但这样做很可能overflow，远远超过用户要求，浪费时间和资源，因为分辨率高就意味着展示的空间小，并且前端是不会做缩放的，如果用很多高分辨率图片，浏览器会有太多太多照片加载显示，因为大家都是<code>256*256</code>的。</p><p>所以定义单位像素的经度距离：<span class="math inline">\(\text{LonDPP} = \frac{\text{lower right longitude} - \text{upper left longitude}}{\text{width of the image (or box) in pixels}}\)</span>，我们要展示的是小于用户要求的LonDPP的最大值，比方说用户要求每个像素2度，如果我们大于2，那么分辨率低到不能满足要求，只有小于2才能满足要求。又不能太小，分辨率太高展示范围变小。当然如果用户要求的LonDPP很低，只能用现有的最低的LonDPP图片，即<code>d7</code>系列。 可以将LonDPP理解为模糊程度，LonDPP越大，显示的图片越模糊，比如<code>d0</code>系列就有最大的LonDPP。 纬度也要做类似处理。</p><p>举例来看：<code>d2</code>系列共有16张图片，用户请求Query Box应该返回9张图片： <img src="https://img-blog.csdnimg.cn/20200624205748557.png" alt="在这里插入图片描述" /> 具体实现只有1个方法<code>public Map&lt;String, Object&gt; getMapRaster(Map&lt;String, Double&gt; params)</code>，分2步：</p><ul><li>需要的图片的<code>depth</code> 全图即<code>d0</code>的经纬度范围是：<code>-122.29980, 37.89220/-122.21191, 37.82280</code> 因为地球不是规则的，但是在确定Depth时，经度方向的LonDPP满足要求即可，不需考虑纬度方向的影响。</li><li>确定四个角的下标</li><li>corner case 判断输入是否合法时，边界判断一定要加EPS，不然一点小误差会崩掉程序。 输入不合法（用户拖动至全图外等），将<code>query_success</code>置为<code>false</code>返回即可。</li></ul><p>Bug：读取图片文件时，总是<code>javax.imageio.IOException: Can't read input file!</code>。一般都是路径问题。 ## Routing &amp; Location Data 明确了前端需要显示哪些图片后，接下来就是要建一个图，因为最后要路径规划嘛。 路由和位置数据是通过<code>berkeley-2018.osm.xml</code>文件给的，是整个<a href="https://download.bbbike.org/osm/">地球数据</a>的一部分，文件格式是<a href="https://wiki.openstreetmap.org/wiki/OSM_XML">OSM XML</a>。</p><p>解析XML数据用的是SAX Parser，遍历每个element，在每个元素的开始和结束位置，调用<code>startElement</code>和<code>endElement</code>回调函数。</p><p>先来熟悉下OSM XML文档： <img src="https://img-blog.csdnimg.cn/20200625122049178.png" alt="在这里插入图片描述" /> <code>node</code>元素是组成地图的主干，有id/lat/lon等属性。如果结点是一个位置，那么<code>tag</code>标签就会有<code>name</code>，如果是其他的，比如路上的一个点，那么就没有<code>tag</code>。 <img src="https://img-blog.csdnimg.cn/20200625122412890.png" alt="在这里插入图片描述" /> <code>way</code>元素表示一条路，路上可能有很多<code>node</code>，用<code>id</code>表示。<code>tag</code>会包含额外信息，如果<code>name</code>是highway，那么<code>v</code>就是道路类型。假设所有道路都是双向的。</p><p>在类<code>GraphDB</code>中存储图，要求允许插入和删除结点，最后要用<code>clean()</code>清理掉没有连接的结点。 <code>GraphBuildingHandler</code>会解析XML文件并调用<code>GraphDB</code>的一些接口函数构建整个图。</p><p>如果选择邻接矩阵存储，由于这是一个动态的图，可能要增加或者删除结点，所以一开始顶点个数是不确定的，也就不能用<code>int[][]</code>表示。所以选择邻接表，因为有<code>clean()</code>操作，需要判断结点是否与其他结点相邻，邻接表速度更快。</p><p><code>GraphBuildingHandler</code>每次只处理XML的一行，也就是一个标签，<code>GraphBuildingHandler</code>这个类可以被其它方法多次调用去处理完所有的XML，我发现这种拆分很有用，系统会变得简单，只需要考虑当前状态就很好写。清楚需求后，需要设计类的接口，数据结构和算法，这才是最难的部分。</p><p>由于parser的解析是从上到下的，所以处理<code>way</code>时最好不要直接把边和边上的结点直接加进图里，因为后面的<code>highway</code>的值可能不在合法范围内，这种边是不算的。所以在碰到边上的点，先存到一个数组里，最后<code>endElement()</code>时候如果路合法，再加进图里。处理<code>node</code>也同理，在<code>endElement()</code>时加入图。记得每次做完一个<code>node</code>或<code>way</code>要<code>clear()</code>上一个的状态信息。</p><p>每个<code>node</code>有一些属性（id/lat/lon），每条边也有一些属性（fromID/toID/name），所以首先要有<code>Node</code>类和<code>Edge</code>类。 邻接表的顶点表<code>Map&lt;Long, Node&gt; vertex</code>，边表<code>Map&lt;Long, Set&lt;Edge&gt;&gt; adj</code>。</p><p>Bug：对<code>ArrayList</code>等在迭代时同时进行修改就会引发异常<code>ConcurrentModificationException</code>。</p><p><code>long closest(double lon, double lat)</code>方法会被用来找最短路，需要返回最近的<strong>有邻居</strong>的<code>node</code>，一个点可能没有邻居，因为他是饭店啥的，不能用来找最短路。另外，这个方法复杂度要求<span class="math inline">\(O(lgn)\)</span>，先实现一个<span class="math inline">\(O(n)\)</span>的做法，后续有时间再去优化吧。 ## Route Search 建好地图后，就要做路由工作：给定起点和终点的经纬度，选一条距离最短的路径，需要在类<code>Router</code>中实现<code>shortestPath</code>方法。 应该从距起点最近的<code>node</code>开始导航到距终点最近的<code>node</code>结束，当然这些<code>node</code>必须是connected的。</p><p>两个<code>node</code>间的距离采用<a href="https://en.wikipedia.org/wiki/Great-circle_distance">great-circle distance</a>，即当作球模型来计算弧长距离。整体距离就是计算1/2之间、2/3之间...的距离之和，还要考虑经度和纬度有不同的尺度，并且随着纬度变化，每度代表的实际距离也是不同的，还好计算距离的函数已经由🐂🍺的TA写好了。</p><p>最好用A*而不是Dijkstra，启发函数h(n)用结点n到终点的great-circle distance就行，要注意目标不可达的情况。</p><p>开始只能在<code>berkeley-2018-small-osm.xml</code>上跑起来，我以为是笔记本配置太烂，跑大的数据集跑不动，只能用小的来测试，后来发现<code>GraphDB</code>里一行写错了。。。debug真痛苦啊！！</p><p>找到最优路线后，这里有一个optional feature，就是显示方向导航信息Turn-by-turn Navigation，需要在类<code>Router</code>中实现<code>routeDirections</code>方法。导航方向的表示是在<code>Router</code>类中写了一个新类<code>NavigationDirection</code>，具体的导航信息格式如下： DIRECTION on WAY for DISTANCE miles 其中，DIRECTION有8种选择： - “Start” - “Continue straight” - “Slight left/right” - “Turn left/right” - “Sharp left/right”</p><p>所以我们需要确定正确的DIRECTION/WAY/DISTANCE，方向取决于当前结点和上一个节点间的<a href="https://en.wikipedia.org/wiki/Bearing_(navigation)">relative bearing</a>：</p><ul><li>Between -15 and 15 degrees the direction should be “Continue straight”.</li><li>Beyond -15 and 15 degrees but between -30 and 30 degrees the direction should be “Slight left/right”.</li><li>Beyond -30 and 30 degrees but between -100 and 100 degrees the direction should be “Turn left/right”.</li><li>Beyond -100 and 100 degrees the direction should be “Sharp left/right”.</li></ul><p>难点在于：一条<code>way</code>上可能包含了若干<code>node</code>，如何在遍历<code>node</code>的过程中判断<code>way</code>是否发生了改变，只有<code>way</code>变化后才能产生一条新的导航信息。如果恰好来到了一条没有<code>name</code>的路，就将WAY设为“unknown road”。</p><p>举例来说： 假设出发的<code>node</code>在“Shattuck Avenue”这条路上，那么DIRECTION应该设为“Start”，遍历接下来的<code>node</code>时，需要累加在这条路上走过的距离，最终到达一个不在“Shattuck Avenue”的<code>node</code>时，设置WAY为“Shattuck Avenue”，DISTANCE为之前的累加值。接着，下一条导航信息的DIRECTION应该根据相对方位计算，WAY是当前<code>node</code>所在的路，DISTANCE重新累加。</p><p>最终的效果：蓝色线表示最优路线： <img src="https://img-blog.csdnimg.cn/20201126192103548.png" alt="在这里插入图片描述" /> 单元测试还是非常重要的，只有确保每一个函数都是正确的，最终组合的功能才可能正确。 ## Autocomplete and Search 作为一个很有用的Feature，自动补全还是很酷的：搜索地名时只输入一部分，就返回以它开头的所有地名。需要在<code>MapServer</code>类中实现<code>List&lt;String&gt; getLocationsByPrefix(String prefix)</code>方法。</p><p>输入的参数<code>prefix</code>是clean后的字符串：除了大小写字母以及空格外，其它字符全部被移除，全部由小写字母组成。 需要返回所有locations（有<code>name</code>的<code>node</code>）的全名，前提是clean后的全名与<code>prefix</code>匹配。 复杂度要求<span class="math inline">\(O(k)\)</span>，k是共享同一前缀的所有地名。</p><p>比如这样： <img src="https://img-blog.csdnimg.cn/20200902160016738.png" alt="在这里插入图片描述" /> 除了自动补全，还需要完成Search功能：clean后的用户输入与clean后的<code>locationName</code>完全匹配，同名的<code>location</code>都需要加入<code>List</code>。 复杂度要求<span class="math inline">\(O(k)\)</span>，k是匹配的地名个数。 需要在<code>MapServer</code>类中实现<code>List&lt;Map&lt;String, Object&gt;&gt; getLocations(String locationName)</code>方法，返回同名的所有地方的信息，如果正确实现，那么就会有一个mark标记在那个地方： <img src="https://img-blog.csdnimg.cn/20200906101859262.png" alt="在这里插入图片描述" /> 具体实现一般用Trie，这里的难点在于输入是clean后的字符串，需要输出clean前的全名，所以我们的Trie结点除了有<code>children</code>和<code>isWord</code>外，还需要保存一些额外的信息（clean前的<code>name</code>/<code>id</code>/<code>lat</code>/<code>lon</code>），当然这些信息只有叶子结点才需要保存，用<code>List&lt;Map&lt;String, Object&gt;&gt; extraInfo</code>来存储。这样重名的地点虽然占用了相同的叶子，但是所有地点的信息都存在了该叶子的<code>extraInfo</code>当中，可以直接展示出来。</p><p>Debug好痛苦啊！！有一次怎么样在浏览器都渲染不出来，折腾了一天，最后发现是因为html文件里一个js文件要FQ才可以访问，醉了。 ## Extensions - Front-end Integration 现在是每调用一次，就在后台raster the entire image，然后传到前端显示。实际中前端可以缓存用过的tiles以及路线，下次调用无需后台计算。 - Vectored Tiles 现在的数据是一张张图片，实际上这些图片是可以从roads, lines, filled areas, buildings等基础矢量几何图形提取，可以用OpenGL/WebGL将其全部绘制为三角形，这样非常同一的工作就可以用GPU去做，速度比CPU要快很多，这些矢量图形可以在<a href="https://wiki.openstreetmap.org/wiki/Vector_tiles">这里</a>下载。 - <a href="https://sp19.datastructur.es/materials/proj/proj2c/heroku">Deploy on Heroku</a> 目前为止，我们的地图还只能在本地运行，下来就将它部署到服务器~ 具体的部署过程可以参考上述链接，完成后APP就会部署到<a href="http://bearmaps-fun.herokuapp.com/map.html">这里</a>。 后续的代码更改需要rebuild jar包，然后redeploy。 ## TODO 做工程真是长期的活，遇到bug每天能写50行就不错了。</p><p>所有<a href="https://github.com/EIMadrigal/CS61B/tree/master/proj3">代码</a>均已通过AG的测试： Part I： <img src="https://img-blog.csdnimg.cn/20200917210047412.png" alt="在这里插入图片描述" /> PART II &amp; III： <img src="https://img-blog.csdnimg.cn/20200917210119434.png" alt="在这里插入图片描述" /> 附加Feature： <img src="https://img-blog.csdnimg.cn/20201127214331958.png" alt="在这里插入图片描述" /> 单元测试除了<code>TestDirections</code>外全部通过。 <img src="https://img-blog.csdnimg.cn/20201129193519713.png" alt="在这里插入图片描述" /> 这个Bug真的有些诡异，不过： <img src="https://img-blog.csdnimg.cn/20201201103328818.png" alt="在这里插入图片描述" /> 尽量少用<code>protected</code>修饰成员变量，写一个函数接口去访问。 ## Reference <a href="https://sp18.datastructur.es/materials/proj/proj3/proj3">Project 3: Bear Maps, version 3.0</a> <a href="https://sp19.datastructur.es/materials/proj/proj2c/proj2c">Project 2C: Bear Maps, version 4.0</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Support Vector Machine</title>
      <link href="/2020/11/02/Support%20Vector%20Machine/"/>
      <url>/2020/11/02/Support%20Vector%20Machine/</url>
      
        <content type="html"><![CDATA[<p>SVM是入门机器学习绕不开的一个话题，但愿这篇文章我能把它讲清楚。 ## 线性可分 SVM的核心思想是：对于<span class="math inline">\(p\)</span>维输入数据集，找一个有着maximum margin的<span class="math inline">\(p-1\)</span>维的超平面去做decision boundary，这与直觉是相符的： <img src="https://img-blog.csdnimg.cn/20200903193214259.png" alt="在这里插入图片描述" /> 回忆下小学数学讲过的几何知识：空间中一个超平面由法向量<span class="math inline">\(\vec w\)</span>和截距<span class="math inline">\(b\)</span>唯一确定： <span class="math display">\[a(x-x_1)+b(y-y_1)+c(z-z_1)+...=0, \\w^Tx+b=0\]</span> 那么如何求解最优超平面的<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>呢？</p><p>假设<span class="math inline">\(\vec w\)</span>指向的一侧为正类（设为负类也没关系，后面会统一表示的），还<strong>假设</strong>在正类的支持向量上有<span class="math inline">\(w^Tx+b=1\)</span>，在负类的支持向量上有<span class="math inline">\(w^Tx+b=-1\)</span>，这里之所以将间隔假设为1主要是为了方便表示和求解，并不影响最终求得的最优超平面和决策函数，证明如下：</p><p>假设正类支持向量距最优超平面距离为<span class="math inline">\(c(c&gt;0)\)</span>，即<span class="math inline">\(w^Tx+b=c\)</span>，此时对应的最优超平面为<span class="math inline">\(w^Tx+b=0\)</span>；又<span class="math inline">\(\frac{w^T}{c}x+\frac{b}{c}=1\)</span>，即<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>同时缩小<span class="math inline">\(c\)</span>倍，那么这时超平面方程同除以<span class="math inline">\(c\)</span>并不改变其形式。</p><p>因此对于正负样本有： <span class="math display">\[w\cdot x_++b\geq 1 \\w\cdot x_-+b\leq -1\]</span> 为了统一表示上面2种情况，引入<span class="math inline">\(y_i=\begin{cases} 1,&amp;\text{+sample}\\ -1,&amp;\text{-sample} \end{cases}\)</span>，所有样本统一表示为： <span class="math display">\[y_i(w\cdot x_i+b)-1\geq 0\]</span> 如果能确定<span class="math inline">\(b\)</span>和<span class="math inline">\(w\)</span>，那么分类超平面和决策函数也就随即确定。</p><p>根据小学数学，间隔即为2个平行超平面的距离： <span class="math display">\[width=\frac{(b+1)-(b-1)}{||w||}=\frac{2}{||w||}\tag{1}\]</span></p><p>综上，<strong>原优化问题</strong>为： <span class="math display">\[\begin{array}{ll}\min _{w, b} &amp; \frac{1}{2}\|w\|^{2} \\\text { s.t. } &amp; y_{i}\left(w \cdot x_{i}+b\right)-1 \geqslant 0, \quad i=1,2, \cdots, N\end{array}\tag{2}\]</span> 这里之所以构造为<span class="math inline">\(\frac{1}{2}\|w\|^{2}\)</span>而不是<span class="math inline">\(||w||\)</span>是为了后面构造的Lagrangian求导的便利。</p><p>明眼人都看得出来：优化目标是一个Convex Quadratic Optimization Problem，并且只有线性约束条件，意味着不会卡在局部极大，一定可以找到全局最优解。此时上述问题已经完全可以用一些QP软件求解了。之所以还要继续讨论下去得到其对偶形式，一是为了在高维空间应用kernel，二是对偶形式的求解有着更加高效的算法。</p><p>回忆下学过的高等数学：有约束优化问题可以通过拉格朗日乘子法求解。首先构造Lagrangian： <span class="math display">\[L(w,b,\alpha)=\frac{||w||^2}{2}-\sum_{i=1}^{N}\alpha_i[y_i(w\cdot x_i+b)-1],\alpha_i\geq0\tag{3}\]</span> 如果<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>满足<span class="math inline">\((2)\)</span>中的约束，那么<span class="math inline">\(\max_{\alpha}L(w,b,\alpha)=\frac{||w||^2}{2}\)</span>； 如果<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>不满足<span class="math inline">\((2)\)</span>中的约束，那么<span class="math inline">\(\max_{\alpha}L(w,b,\alpha)=+\infin\)</span>。 因此下式的优化问题与<span class="math inline">\((2)\)</span>完全等价： <span class="math display">\[\min_{w, b}\max_{\alpha} L(w, b, \alpha)\tag{4}\]</span> 根据拉格朗日对偶性（不懂就暂时当作成立吧嘻嘻），<span class="math inline">\((4)\)</span>的对偶问题为： <span class="math display">\[\max_{\alpha} \min_{w, b} L(w, b, \alpha)\tag{5}\]</span> 为了求解对偶问题<span class="math inline">\((4)\)</span>，先求<span class="math inline">\(L\)</span>对<span class="math inline">\(w,b\)</span>的极小，再求对<span class="math inline">\(\alpha\)</span>的极大：</p><ol type="1"><li>固定<span class="math inline">\(\alpha\)</span>，求<span class="math inline">\(\min_{w, b} L(w, b, \alpha)\)</span> 分别求<span class="math inline">\(L\)</span>对<span class="math inline">\(\vec{w}\)</span>和<span class="math inline">\(b\)</span>的偏导并令其为0： <span class="math display">\[\frac{\partial L}{\partial\vec{w}}=\vec{w}-\Sigma\alpha_iy_ix_i=0, \vec{w}=\Sigma\alpha_iy_ix_i \\\frac{\partial L}{\partial b}=\Sigma\alpha_iy_i=0, \Sigma\alpha_iy_i=0\tag{6}\]</span> 决策向量<span class="math inline">\(\vec{w}\)</span>是样本的线性和，将<span class="math inline">\(\vec{w}\)</span>代入<span class="math inline">\((3)\)</span>： <span class="math display">\[\min_{w, b}L=\Sigma\alpha_i-\frac{1}{2}\Sigma_i\Sigma_j\alpha_i\alpha_jy_iy_jx_i\cdot x_j\tag{7}\]</span></li><li>求<span class="math inline">\(\min_{w, b} L(w, b, \alpha)\)</span>对<span class="math inline">\(\alpha\)</span>的极大 即求<span class="math inline">\((7)\)</span>对<span class="math inline">\(\alpha\)</span>的极大，等价于取负号求对<span class="math inline">\(\alpha\)</span>的极小，于是终于得到了<strong>原优化问题</strong><span class="math inline">\((2)\)</span>的<strong>对偶优化问题</strong>： <span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; \alpha_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\tag{8}\]</span></li></ol><p>利用SMO等算法可以比普通的二次规划算法更高效求得最优的<span class="math inline">\(\alpha^*\)</span>，进而根据<span class="math inline">\((6)\)</span>求得： <span class="math display">\[w^{*}=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i}\tag{9}\]</span> 再利用KKT条件（不懂就装懂吧嘻嘻）求得： <span class="math display">\[b^{*}=y_{j}-(w^*)^Tx_j=y_{j}-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}\left(x_{i} \cdot x_{j}\right)\tag{10}\]</span> 其中，<span class="math inline">\(y_{j}\)</span>为任意一个支持向量。</p><p>最终的分类超平面为： <span class="math display">\[w^{*}\cdot x+b^{*}=0,\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}(x_{i}\cdot x)+b^{*}=0\tag{11}\]</span> 分类决策函数为： <span class="math display">\[f(x)=sign(w^{*}\cdot x+b^{*})=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}(x_{i}\cdot x)+b^{*}\tag{12}\]</span> 最后要bb的是关于支持向量，根据KKT条件里的互补条件<span class="math inline">\(\alpha_{i}^{*}[y_{i}(x_{i}\cdot w^*+b^{*})-1]=0\)</span>：非支持向量必然有<span class="math inline">\(\alpha_{i}^{*}=0\)</span>，只有支持向量才可能出现<span class="math inline">\(\alpha_{i}^{*}&gt;0\)</span>。</p><p>如果回头看<span class="math inline">\((9)(10)(11)(12)\)</span>，所有的非支持向量对SVM没有任何影响，最优超平面以及决策函数都只由少量的支持向量决定，这大概就是支持向量机名称的由来吧~ ## 近似线性可分 上面讨论了完全线性可分的情况，然而在现实情况中，训练数据会有一些outliers，除去这些点后数据是线性可分的。为了处理这种情况，允许SVM分错一些样本。对每个样本点引入松弛因子<span class="math inline">\(\xi_{i} \geqslant 0\)</span>，即样本点的函数间隔只需要大于<span class="math inline">\(1-\xi_{i}\)</span>，放松了限制条件，<strong>原优化问题</strong>变为： <span class="math display">\[\begin{array}{ll}\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i} \\\text { s.t. } &amp; y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1-\xi_{i}, \quad i=1,2, \cdots, N \\&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\tag{13}\]</span> 如果样本点严格满足约束，对于损失函数没有贡献；如果不严格满足即<span class="math inline">\(\xi_{i}&gt;0\)</span>，损失函数就会有相应的惩罚。惩罚参数<span class="math inline">\(C\)</span>控制了一种权衡：既要间隔最大（即<span class="math inline">\(min\ ||w||\)</span>），又要分对尽可能多的样本点。</p><p>类似地，<span class="math inline">\((13)\)</span>可以通过拉格朗日乘子法转换为对偶问题后再去求解，建议吃饱的同学自己尝试一下。<span class="math inline">\((13)\)</span>的<strong>对偶优化问题</strong>是： <span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; 0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N\end{array}\tag{14}\]</span> 此时此刻恰如彼时彼刻，使用普通的二次规划算法或者更高效的SMO求解<span class="math inline">\((14)\)</span>得到最优的<span class="math inline">\(\alpha_{i}^{*}\)</span>，进而得到软间隔SVM的解： <span class="math display">\[w^{*}=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i} \\b^{*}=y_{j}-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}\left(x_{i} \cdot x_{j}\right)\tag{15}\]</span> 其中，<span class="math inline">\(y_{j}\)</span>要满足<span class="math inline">\(0&lt;\alpha_j&lt;C\)</span>。 ## 非线性可分 上面讨论了线性分类问题，对于非线性可分问题，SVM的思想是做一个变换<span class="math inline">\(\phi(\vec{x})\)</span>，将样本映射到另外一个空间，也许就线性可分了。 由于目标函数和决策函数<strong>只依赖于样本对之间的点积</strong>，所以无需显式定义变换<span class="math inline">\(\phi(\vec{x})\)</span>，只要定义一个函数<span class="math inline">\(K(\vec{x_i},\vec{x_j})=\phi(\vec{x_i})\cdot\phi(\vec{x_j})\)</span>提供新空间的样本点的点积即可，<span class="math inline">\(K\)</span>叫做<strong>Kernel Function</strong>。 此时原优化问题为： <span class="math display">\[\begin{array}{ll}\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i} \\\text { s.t. } &amp; y_{i}\left(w^T \phi(x_{i})+b\right) \geqslant 1-\xi_{i}, \quad i=1,2, \cdots, N \\&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\]</span> 对偶问题为： <span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(K(x_{i},x_{j})\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; 0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N\end{array}\]</span> 一种常用的kernel是线性的：<span class="math inline">\((\vec{u}\cdot\vec{v}+1)^n\)</span>，当前空间的<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>通过简单的点积映射到了另一个空间； 另一种kernel是高斯核：<span class="math inline">\(e^{-\frac{||x_i-x_j||^2}{\sigma}}=e^{-\gamma{||x_i-x_j||}^2}\)</span>。 高斯核对应高斯径向基函数分类器，这里有2个参数<span class="math inline">\(C\)</span>和<span class="math inline">\(\gamma\)</span>需要调节：惩罚系数<span class="math inline">\(C\)</span>表示分类器对于误差的宽容度，<span class="math inline">\(C\)</span>越大表示越不能容忍误差，容易过拟合，按照经验可以在<span class="math inline">\([10^{-4},10^4]\)</span>间调节；<span class="math inline">\(\gamma\)</span>控制径向作用范围，<span class="math inline">\(\gamma\)</span>越大，径向作用范围越小，有可能将每个样本点单独形成一个分类，容易过拟合，<span class="math inline">\(\gamma\)</span>过小，径向范围过大，容易将2个样本映射为同一个点，无法区分，一般<span class="math inline">\(\gamma=\frac{1}{样本特征数}\)</span>。另外，这2个参数可以通过交叉验证和grid-search来调整。 ## 扩展 SVM处理多分类问题的方式主要有2种：</p><ul><li>one-against-one 在每2个类之间都构造一个binary SVM，共有<span class="math inline">\(C_m^2\)</span>个SVM，对新数据采用Voting的方式进行分类。</li><li>one-against-the-rest 对每个类，将其作为正类，其余<span class="math inline">\(m-1\)</span>个类作为负类，共<span class="math inline">\(m\)</span>个SVM，对新数据采用winner-takes-all策略。</li></ul><p>如果样本不均衡，目标函数中的惩罚项主要由多数类构成，超平面偏向少数类，甚至将所有样本都分在同一侧。 此时目标变为了在不严重损失多数类精度的情况下，在少数类上获得尽可能高的分类正确率。一般来讲有2种做法：</p><ul><li>数据合成 对少数类样本进行分析并根据其特点人工插值合成新样本添加到数据集中，构成均衡数据集。比较常用的方法是SMOTE(Synthetic Minority Oversampling Technique)。</li><li>加权SVM 将少数类分错的代价很大，所以在惩罚项中对两个类设置不同的惩罚系数，少数类的系数设置更大，甚至可以对每个样本都设置不同的惩罚系数，此时原优化问题变为： <span class="math display">\[\begin{array}{ll}\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C^+ \sum_{y_i=1} \xi_{i}+C^-\sum_{y_i=-1} \xi_{i} \\\text { s.t. } &amp; y_{i}\left(w^T \phi(x_{i})+b\right) \geqslant 1-\xi_{i}, \quad i=1,2, \cdots, N \\&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N\end{array}\]</span> 对偶问题： <span class="math display">\[\begin{array}{ll}\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(K(x_{i},x_{j})\right)-\sum_{i=1}^{N} \alpha_{i} \\\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\&amp; 0 \leqslant \alpha_{i} \leqslant C^+, y_i=+1 \\&amp; 0 \leqslant \alpha_{i} \leqslant C^-, y_i=-1\end{array}\]</span></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO Multiplexing</title>
      <link href="/2020/10/23/IO%20Multiplexing/"/>
      <url>/2020/10/23/IO%20Multiplexing/</url>
      
        <content type="html"><![CDATA[<p>当多个独立的I/O事件同时发生时，I/O多路复用是一种解决方式。 为了提高服务器的吞吐量，<strong>单个线程</strong>通过记录跟踪每个I/O流的状态同时管理多个I/O流，非常类似时分复用技术。 <img src="https://img-blog.csdnimg.cn/20200825092905568.gif#pic_center" alt="在这里插入图片描述" /> I/O多路复用的具体实现方式有3种：<code>select()</code>、<code>poll()</code>和<code>epoll()</code>。 ## select <code>select()</code>系统调用：<code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code> <code>select()</code>会一直阻塞直到至少一个文件描述符就绪，可以读写，或者出现异常。 中间3个参数会被修改，表示哪个FD准备好了，最后一个表示等待时间，NULL表示无限等待。 返回就绪的FD数目，有错-1。只知道有就绪，不知道哪个FD就绪了。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd[];  <span class="comment">// 需要监听的socket集合</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> n = select();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fd.size(); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (FD_ISSET()) &#123;  <span class="comment">// 判断哪个socket接收到数据</span></span><br><span class="line"><span class="comment">// 处理数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>select()</code>是阻塞方法，只有某个socket接收到数据才会继续执行，唤醒进程。 直接的方式缺点就比较多：</p><ul><li>时间开销大，所以规定最多监听1024个socket；</li><li>每次调用都要把fd集合从用户态拷贝到内核态。</li><li>线程不安全：</li></ul><blockquote><p>If a file descriptor being monitored by select() is closed in another thread, the result is unspecified. ## poll 去掉了1024的限制，线程不安全。 ## epoll 线程安全，知道哪个FD就绪，只有Linux支持。 相比于<code>select()</code>，<code>epoll()</code>不会无差别轮询，只处理接收到数据的socket，这样复杂度就降低为<span class="math inline">\(O(k)\)</span>。 ## Reference <a href="https://www.zhihu.com/question/32163005/answer/55772739">I/O多路复用是什么意思</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>魏晋风度浅探</title>
      <link href="/2020/10/18/%E9%AD%8F%E6%99%8B%E9%A3%8E%E5%BA%A6%E6%B5%85%E6%8E%A2/"/>
      <url>/2020/10/18/%E9%AD%8F%E6%99%8B%E9%A3%8E%E5%BA%A6%E6%B5%85%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>从小学作文开始，就喜欢写一些辞藻华丽的诗歌文章。 竹林七贤我当时只听说过山涛、阮籍和嵇康，引用之意是觉这几位遗世独立、傲然风骨，没有世俗羁绊，整日琴棋书画、饮酒作乐、不问世事，潇洒写意的生活，正是吾向往之。《广陵散》和《与山巨源绝交书》更是勾起了我对于嵇康无限的崇拜。 我极喜欢嵇康和纳兰性德，即使一些毫无关联的题目，也要用他们的事例强行去阐述论点。但由于只喜欢钻研近现代的战争史（可以原谅，男孩一般都喜欢枪支、火炮等近现代武器），一直对古代史不感兴趣，觉得几千年前的文化故事不过是落后、腐朽的代名词而已，所以其实对一些人物只是略知一二，最近花了些时间重新捋了一下魏晋那段历史，故分享于此。 ## 历史背景 我一直觉得想要真正了解一段文化、一个人物，就首先要了解他们所处的历史时代。 曹操在东汉末年的群雄逐鹿中“挟天子以令诸侯”，在三国末期势力最强。曹操去世后，其子曹丕于公元220年建立曹魏政权。公元265年，司马炎建立西晋，史称晋武帝。竹林七贤就是生活在这样一段历史时期： 山涛：205~283 阮籍：210~263 嵇康：224~263 刘伶：221~300 向秀：227~272 阮咸：不详 王戎：234~305 曹丕去世后，曹叡即位，公元239年隆冬时节，曹叡驾崩之际，将皇位传给仅仅8岁的曹芳，并将其同时托孤给司马懿和曹爽，于是在接下来漫长的几十年中，曹氏集团和司马氏集团开始了你死我活的政治斗争，史称“曹马之争”。 ## 竹林七贤 在那个极其黑暗动荡的乱世之中，文学和艺术却得到了出乎意料的大发展，人们对自由解放的追求达到了极致，鲁迅先生称之为魏晋风度。当时盛行清谈和隐逸，古人的心灵更加丰富和缠绵，规则的约束压抑了个性与自我，却在频频交流中迎来了文化的繁荣。不要用成王败寇的观点去评价历史人物，参差百态，实乃幸福本源。</p><p>而对魏晋风度影响最大的自然就是竹林七贤，虽然百年之后后人将其称之为七贤，但这个文人沙龙的规模其实大于7人，之所以定为七贤，据刘强老师的说法是为了攀附《论语》：</p><blockquote><p>贤者辟世，其次辟地，其次辟色，其次辟言。作者七人矣。</p></blockquote><p>另外，关于竹林七贤是否因为经常在竹林活动而得名也存疑。陈寅恪先生认为有可能是借佛经之中的“竹林精舍”的故事来表达出世的理想。据考证，他们的活动地点在都城洛阳以及山阳（今云台山）附近，后来当地可能为了借竹林七贤的名声促进旅游业的发展，所以人工栽种了一些竹林。</p><p>当时流行修身齐家治国平天下，但是这些才华横溢的文人开始却不愿做官，这是为什么呢？</p><p>“曹马之争”愈演愈烈，再加上这些名士的名气和影响力，他们被逼站队才能得以生存。那么问题来了，是站在司马家族一边，还是支持曹氏集团呢？曹爽此时被封为大将军，司马懿则是太尉，选择稍有不慎，很可能会被秋后算账。</p><p>作为老大哥，山涛最先受到“曹马之争”的冲击。</p><p>山涛早年丧父，出身庶族，隐居不仕，刘老师说可能是因为时机不成熟，2个政治集团的形势不明朗。山涛本人是有政治抱负的，但为了自保只能暂时推脱出仕邀请。</p><p>公元244年，他觉得形势明朗，自己的机会来了，终于在40岁时开始了官宦生涯，并且选择站到曹爽队伍里。</p><p>为了彻底击败曹氏集团，司马懿称病不朝，以退为进。极富政治头脑的山涛嗅出了不同的味道，突然醒悟，夜半弃官。</p><p>山涛弃官以后，司马懿在称病迷惑曹爽的同时，积累军事力量、联络曹魏老臣取得道义支持、散播舆论蛊惑人心，家族势力日渐强大。而就在此时，山涛结交了阮籍、嵇康等名士，整日醉饮玩乐。</p><p>公元249年，司马懿发动政变，一举粉碎了政敌曹爽集团，史称“高平陵之变”，以谋反罪处死了曹氏整个家族，数千人惨死，竹林七贤也受到了惊吓。接着为了缓解白色恐怖的气氛，司马家族开始招贤纳士、笼络人心，竹林七贤自然也在招贤之列：</p><p>山涛由于和司马氏的姻亲关系，第二次做官便凭借亲戚的身份主动投靠司马师，从此以后官运亨通，步入了仕途的快车道。</p><p>相比之下，在音乐、诗赋方面才华横溢的阮籍就显得异常凄惨。</p><p>阮籍的背景十分复杂，他的父亲阮瑀是建安七子之一，和曹魏关系密切；同时他又是司马氏的亲戚。 被招纳时，由于害怕司马懿的屠刀，于是阮籍答应为官，做了一个闲职。但他尸位素餐，整日划水摸鱼，几乎没有作为。并且他和司马氏倡导的封建礼教格格不入（司马氏当时号召“以孝治天下”，公元258年左右，阮籍丧母，他公然违背礼法，在葬礼期间喝酒吃肉），生活得极其痛苦但又不想过早结束生命，所以只能寄托于司马懿的死亡。</p><p>司马懿死后，其子司马师又把阮籍召去做官。司马昭上台后，为了拉拢阮籍，想要将阮籍的女儿嫁给司马昭的儿子司马炎，阮籍只能用烂醉如泥来应付。天天这样也不是办法，他就主动求官，调往外地，金蝉脱壳之计，但很不幸，十天后又被司马昭看穿并召回幕府。从此慎言慎行、明哲保身、郁郁寡欢。</p><p>嵇康死后，阮籍抑郁而终，晚年被迫为司马昭写了一篇歌功颂德的《劝进文》，成为了人生的污点。</p><p>向秀跟嵇康关系最好，嵇康的死给他带去了巨大的阴影，后来为了自保也踏上了仕途。</p><p>王戎后来做了大官，却变得非常吝啬，跟年轻时候判若两人，但是他依然很重情谊。 阮咸后来被山涛举荐，但没有被任用。</p><p>刘伶据说是7人里最丑的，但是他的精神自我十分强大，整日烂醉如泥，在酒中放飞自我，晚景凄凉。代表作《酒德颂》，刘强老师说他是真正的行为艺术家hh。 ## 嵇康 嵇康出身普通，自幼颠沛流离。和曹操同乡，其妻子是曹操的曾孙女长乐亭主，嵇康最后被司马昭所杀可能与这个因素也有关系。诗歌、文章、书法、乐理造诣很高，据传还是个大帅哥，史书记载：</p><blockquote><p>嵇康为人，肃肃如松下风，酒醉时倾倒，若玉山之将崩。</p></blockquote><p>他提出越名教任自然，反对礼教，追求自然和本我，厌恶政治斗争，据传嵇康在打铁时，司马氏的走狗钟会前来探访，所谓道不同不相与谋，故意把钟会晾在一边不说，走前还冷嘲热讽了一通。</p><p>当时司马师废掉了曹芳，引起淮南兵变，嵇康也想起兵响应，被山涛劝阻。</p><p>公元255年，司马师在平定叛乱时，由于得病死掉了。随后司马昭上台，希望招纳嵇康，嵇康借口避地河东。</p><p>嵇康以宽厚待人，虽然他的哥哥嵇喜还有几个朋友做了司马氏的官，但仍然没有影响他们的友谊。对待朋友友好，但是对待敌人却像严冬一样冷峻无情，也导致了后来悲剧的发生。</p><p>后来他又多次拒绝司马昭的邀请，但很不幸，嵇康最终还是卷进了政治斗争： 皇帝曹髦一直被司马昭操控，被迫封其为相国，眼看分分钟就要被取代的节奏。后来也由此诞生一个成语：司马昭之心——路人皆知。公元260年，曹髦很快就被司马昭干掉了，又找了一个傀儡。</p><p>公元261年，山涛升迁，找到嵇康希望他代替自己之前的官职。两人虽然“契若金兰”，但嵇康依然愤怒地写下《与山巨源绝交书》，极尽讽刺羞辱山涛，他觉得山涛拉拢他是为了缓解自己的尴尬，一起下水就不觉得那么罪过了。嵇康在书里自明心志：自己生性疏懒，阐述了自己做官的七不堪、二不可： 没法睡懒觉；喜欢休闲弹琴，出去玩不自由；需要正襟危坐；不喜欢写公务信；不喜欢吊丧；不喜欢和俗人共事；性情不耐烦，不喜欢做繁琐的事情。 菲薄古代的圣贤，被发现就挂了；性格刚烈、嫉恶如仇，沉不住气，不适合做官。</p><p>历史上关于两人是否真的绝交有争论：尤其是后来还发生了托孤事件。</p><p>屋漏偏逢连夜雨，接下来又发生了吕安事件，直接将嵇康送入了火坑之中：</p><p>吕巽是吕安的哥哥，对吕安的妻子有非分之想并且给他带了绿帽子，吕安告诉了嵇康，嵇康严词谴责了吕巽，但为了声誉，劝吕安隐忍不发，事情就这样被捂了下来。</p><p>吕巽和钟会关系很好，为了报复吕安，他向钟会进献谗言，钟会很可能为了牵出嵇康，以报一箭之仇，不久后就抓了吕安。嵇康听到消息后十分愤怒，写了一封《与吕长悌绝交书》，之后只身前往洛阳，去为吕安辩护。</p><p>吕安在流放途中，给嵇康写了一封言辞激烈的信。大意是说天下大乱，自己承受冤屈，他要改天换地。这封信很快落到了钟会手上，钟会终于等到了机会。</p><p>吕安事件由此升级为谋反罪，嵇康被当作同犯抓了。司马昭本来就忌惮嵇康，对他的不合作态度怀恨在心，但对于是否要杀嵇康也犹豫不决，此时钟会又站了出来上纲上线，说嵇康上不臣天子，下不事王侯，私下又罗织了几个理由：他说嵇康是人中龙凤，并且当年有起兵谋反之意。</p><p>欲加之罪，何患无辞？于是吕安和嵇康被关入死囚牢房，等待秋后问斩。</p><p>命犯小人，嵇康入狱后，有几千太学生为他抱打不平。他也在狱中反思自己，写下了《幽愤诗》，觉得自己虽然心地善良，但却没有识别坏人的能力。</p><p>临死前将其儿子嵇绍托付给山涛，有人说这是为了缓解山涛的愧疚之意，山涛接受了嵇康的托孤，把嵇绍培养的很好：</p><blockquote><p>巨源在，汝不孤矣！</p></blockquote><p>就在行刑前，太学生又请愿释放嵇康当太学老师。司马昭看到嵇康如此的影响力，杀心更重： 公元263年，嵇康与吕安一起在都城洛阳被处死。</p><p>据记载，行刑那天人山人海，嵇康顾看日影、神色坦然。</p><p>嵇康找哥哥嵇喜要了一把琴，嵇喜果然随身携带，而且嵇康的弹奏要求竟然被同意： 在刑场上，他平静呼吸，调整琴弦，弹完了最后的哀歌《广陵散》后说到：当年有一个朋友袁孝尼求学此散，自己由于吝惜，没有教给他：</p><blockquote><p>广陵散于今绝矣！ ## Reference 同济大学的刘强老师是魏晋史的专家，百家讲坛和上海图书馆系列讲座中都收录了他的精彩分享： <a href="http://tv.cctv.com/lm/bjjt/index.shtml#&amp;Type=0&amp;Y=2010&amp;M=10">百家讲坛之竹林七贤</a> <a href="https://www.bilibili.com/video/BV1Zt411d7Fr">竹林七贤与魏晋风度</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bomb Lab</title>
      <link href="/2020/10/04/Bomb%20Lab/"/>
      <url>/2020/10/04/Bomb%20Lab/</url>
      
        <content type="html"><![CDATA[<p>给了<code>bomb.c</code>和<code>bomb</code>二进制可执行目标程序，<code>bomb.c</code>不能直接编译和运行，只是有一些提示，但是程序大致结构是：有6个关卡，每个都需要输入（stdin/文件）一个字符串，运行后判断是否输入了正确的字符串。我们需要反汇编<code>bomb</code>，找到这6个正确的字符串。 我是在Amazon的云服务器上完成的，64位Red Hat。</p><p>第一步把汇编代码扔到一个文件中，方便调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.asm</span><br></pre></td></tr></table></figure><h2 id="phase-1">phase 1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  400ee4:be 00 24 40 00       mov    $0x402400,%esi</span><br><span class="line">  400ee9:e8 4a 04 00 00       callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:85 c0                test   %eax,%eax</span><br><span class="line">  400ef0:74 05                je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:e8 43 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  400efb:c3                   retq</span><br></pre></td></tr></table></figure><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 我们的input作为第一个参数存入rdi，第二个参数0x402400存入rsi，传入函数处理， 调用了<code>401338</code>处的函数<code>strings_not_equal</code>：</p><p>在400ee4设个断点，看看402400里是啥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb</span><br><span class="line">file bomb</span><br><span class="line">b *0x400ee4</span><br><span class="line">run</span><br><span class="line">x/s Addr// 显示内存值为字符串</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200703101513705.png" alt="在这里插入图片描述" /> 为了确认这就是我们要的答案，再去看看调用的函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0000000000401338 &lt;strings_not_equal&gt;:</span><br><span class="line">  401338:41 54                push   %r12</span><br><span class="line">  40133a:55                   push   %rbp</span><br><span class="line">  40133b:53                   push   %rbx</span><br><span class="line">  40133c:48 89 fb             mov    %rdi,%rbx # 第一个参数(地址)存入rbx</span><br><span class="line">  40133f:48 89 f5             mov    %rsi,%rbp # 第二个参数(地址)存入rbp</span><br><span class="line">  401342:e8 d4 ff ff ff       callq  40131b &lt;string_length&gt; # 用rdi的值调用string_length</span><br><span class="line">  401347:41 89 c4             mov    %eax,%r12d # 返回值存入r12d</span><br><span class="line">  40134a:48 89 ef             mov    %rbp,%rdi # 第二个参数作为入参调用string_length</span><br><span class="line">  40134d:e8 c9 ff ff ff       callq  40131b &lt;string_length&gt;</span><br><span class="line">  401352:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line">  401357:41 39 c4             cmp    %eax,%r12d # 比较两个字符串的长度</span><br><span class="line">  40135a:75 3f                jne    40139b &lt;strings_not_equal+0x63&gt; # 不相等跳转</span><br><span class="line">  40135c:0f b6 03             movzbl (%rbx),%eax # 将rbx地址中的值(input的第一个字母)存入eax</span><br><span class="line">  40135f:84 c0                test   %al,%al</span><br><span class="line">  401361:74 25                je     401388 &lt;strings_not_equal+0x50&gt;</span><br><span class="line">  401363:3a 45 00             cmp    0x0(%rbp),%al # 比较rbp地址中的值(待比较的第一个字母)</span><br><span class="line">  401366:74 0a                je     401372 &lt;strings_not_equal+0x3a&gt; # 相等跳转</span><br><span class="line">  401368:eb 25                jmp    40138f &lt;strings_not_equal+0x57&gt; # 不相等跳转</span><br><span class="line">  40136a:3a 45 00             cmp    0x0(%rbp),%al</span><br><span class="line">  40136d:0f 1f 00             nopl   (%rax)</span><br><span class="line">  401370:75 24                jne    401396 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line">  401372:48 83 c3 01          add    $0x1,%rbx # 指针+1</span><br><span class="line">  401376:48 83 c5 01          add    $0x1,%rbp # 指针+1</span><br><span class="line">  40137a:0f b6 03             movzbl (%rbx),%eax</span><br><span class="line">  40137d:84 c0                test   %al,%al</span><br><span class="line">  40137f:75 e9                jne    40136a &lt;strings_not_equal+0x32&gt; # 跳回循环</span><br><span class="line">  401381:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line">  401386:eb 13                jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401388:ba 00 00 00 00       mov    $0x0,%edx</span><br><span class="line">  40138d:eb 0c                jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40138f:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line">  401394:eb 05                jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401396:ba 01 00 00 00       mov    $0x1,%edx</span><br><span class="line">  40139b:89 d0                mov    %edx,%eax</span><br><span class="line">  40139d:5b                   pop    %rbx</span><br><span class="line">  40139e:5d                   pop    %rbp</span><br><span class="line">  40139f:41 5c                pop    %r12</span><br><span class="line">  4013a1:c3                   retq</span><br></pre></td></tr></table></figure> 所以这个函数就是比较两个字符串是否相同，先比较长度，再比较每个字符。故我们的第一个key就是Border relations with Canada have never been better. ## phase 2 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:55                   push   %rbp</span><br><span class="line">  400efd:53                   push   %rbx</span><br><span class="line">  400efe:48 83 ec 28          sub    $0x28,%rsp # 栈指针-40</span><br><span class="line">  400f02:48 89 e6             mov    %rsp,%rsi # 栈指针作为第二个参数</span><br><span class="line">  400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:83 3c 24 01          cmpl   $0x1,(%rsp) # 检查是否相等</span><br><span class="line">  400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt; # 相等跳转</span><br><span class="line">  400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:eb 19                jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:8b 43 fc             mov    -0x4(%rbx),%eax # (rbx-4)赋给eax</span><br><span class="line">  400f1a:01 c0                add    %eax,%eax</span><br><span class="line">  400f1c:39 03                cmp    %eax,(%rbx) # 比较当前数与下一个数</span><br><span class="line">  400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt; # 相等跳转</span><br><span class="line">  400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:48 83 c3 04          add    $0x4,%rbx</span><br><span class="line">  400f29:48 39 eb             cmp    %rbp,%rbx # 是否比完了6个数</span><br><span class="line">  400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:48 8d 5c 24 04       lea    0x4(%rsp),%rbx # 栈指针+4赋给rbx</span><br><span class="line">  400f35:48 8d 6c 24 18       lea    0x18(%rsp),%rbp # 栈指针+24赋给rbp</span><br><span class="line">  400f3a:eb db                jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  400f40:5b                   pop    %rbx</span><br><span class="line">  400f41:5d                   pop    %rbp</span><br><span class="line">  400f42:c3                   retq</span><br></pre></td></tr></table></figure> 第一次是1，第二次是2，4，8，16，32 ## phase 3 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:48 83 ec 18          sub    $0x18,%rsp # 栈指针-24</span><br><span class="line">  400f47:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx # 栈指针+12赋给rcx</span><br><span class="line">  400f4c:48 8d 54 24 08       lea    0x8(%rsp),%rdx # 栈指针+8赋给rdx</span><br><span class="line">  400f51:be cf 25 40 00       mov    $0x4025cf,%esi</span><br><span class="line">  400f56:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400f5b:e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt; # 返回值存入eax</span><br><span class="line">  400f60:83 f8 01             cmp    $0x1,%eax</span><br><span class="line">  400f63:7f 05                jg     400f6a &lt;phase_3+0x27&gt; # 大于跳转</span><br><span class="line">  400f65:e8 d0 04 00 00       callq  40143a &lt;explode_bomb&gt; # 否则爆炸</span><br><span class="line">  400f6a:83 7c 24 08 07       cmpl   $0x7,0x8(%rsp) #(rsp+8)即输入的第一个整数与7比较</span><br><span class="line">  400f6f:77 3c                ja     400fad &lt;phase_3+0x6a&gt; # 大于爆炸</span><br><span class="line">  400f71:8b 44 24 08          mov    0x8(%rsp),%eax # 输入的第一个整数赋给eax</span><br><span class="line">  400f75:ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8) # 跳转8*rax+0x402470</span><br><span class="line">  400f7c:b8 cf 00 00 00       mov    $0xcf,%eax</span><br><span class="line">  400f81:eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:b8 c3 02 00 00       mov    $0x2c3,%eax</span><br><span class="line">  400f88:eb 34                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:b8 00 01 00 00       mov    $0x100,%eax</span><br><span class="line">  400f8f:eb 2d                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:b8 85 01 00 00       mov    $0x185,%eax</span><br><span class="line">  400f96:eb 26                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:b8 ce 00 00 00       mov    $0xce,%eax</span><br><span class="line">  400f9d:eb 1f                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:b8 aa 02 00 00       mov    $0x2aa,%eax</span><br><span class="line">  400fa4:eb 18                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:b8 47 01 00 00       mov    $0x147,%eax</span><br><span class="line">  400fab:eb 11                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:e8 88 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400fb7:eb 05                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:b8 37 01 00 00       mov    $0x137,%eax</span><br><span class="line">  400fbe:3b 44 24 0c          cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:74 05                je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:e8 71 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  400fcd:c3                   retq</span><br></pre></td></tr></table></figure> 400f51将地址0x4025cf赋给esi，作为第二个参数，看下这个地址有啥：为了方便，我们把前面问题的答案仍在一个文件ans.txt中， <img src="https://img-blog.csdnimg.cn/20200703164446264.png" alt="在这里插入图片描述" /> 输入是2个整数，第一个不能大于7，基于第一个整数（0-7）跳转...... </explode_bomb>&lt;/phase_3+0x86&gt;&lt;/phase_3+0x7b&gt;</explode_bomb>&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x6a&gt;</explode_bomb>&lt;/phase_3+0x27&gt;</phase_3>&lt;/phase_2+0x1b&gt;&lt;/phase_2+0x40&gt;&lt;/phase_2+0x1b&gt;</explode_bomb>&lt;/phase_2+0x29&gt;&lt;/phase_2+0x34&gt;</explode_bomb>&lt;/phase_2+0x34&gt;</read_six_numbers></phase_2>&lt;/strings_not_equal+0x63&gt;&lt;/strings_not_equal+0x63&gt;&lt;/strings_not_equal+0x63&gt;&lt;/strings_not_equal+0x32&gt;&lt;/strings_not_equal+0x5e&gt;&lt;/strings_not_equal+0x57&gt;&lt;/strings_not_equal+0x3a&gt;&lt;/strings_not_equal+0x50&gt;&lt;/strings_not_equal+0x63&gt;</string_length></string_length></strings_not_equal></explode_bomb>&lt;/phase_1+0x17&gt;</strings_not_equal></phase_1></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>谈谈我的理想</title>
      <link href="/2020/09/26/%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%90%86%E6%83%B3/"/>
      <url>/2020/09/26/%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%90%86%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>今年6月份我写过一篇文章，总结了过去几年发生的一些事情：我提到如果要获得<strong>世俗意义上的成功</strong>应该怎么去做，我自己的选择当然也有这方面的考虑，毕竟一直穷着过来的，对于CS这样的就业形势不可能不动心，当然选择CS也不全是功利，我自己还是挺喜欢做这些事情的。</p><p>这一篇我想接着写写内心更深处的一些想法。起因是前段时间加入了一个豆瓣小组：<em>985废物引进计划</em>，看到了家家那本难念的经，当然更欣慰地看到很多前辈已经迈出了戳破怪圈的第一步，开始去做自己暂时没有勇气去做的事情，我备受鼓舞。</p><p><a href="https://www.zhihu.com/question/396643886">这个问题</a>的最高赞回答跟我的一些经历颇为相似，评论里也有同学意识到自己的不足： <img src="https://img-blog.csdnimg.cn/20200816165343450.png" alt="在这里插入图片描述" /> 我多多少少有着跟她类似的问题：我自己从小到大理科天赋都不高，原来觉得数学还好点，但是见识了更多世面、学的更加复杂以后，我的数学也是差劲，自然也没什么兴趣。大家都知道，数学是计算机的基础，我对计算机也没有天赋，理解算法很慢，一个点常常需要反复练习。但是喜欢和天分并不矛盾，我并不担心自己在IT业找不到好工作，因为CS其实只需要大量的中等生，其他行业也是如此。我想表达的是：既然没有天分，<strong>虽然喜欢但是没有到那么喜欢，或者具体来说，如果让我在不考虑世俗因素下去选择未来的工作，毫不意外我有更加prefer的选项，那就是去高中教书。</strong></p><p>这个想法其实由来不久，最初是在大一的暑假，支教完回来。我觉得那段时间我有着久违的开心，非常喜欢和学生在一起，不论是出于一些炫耀的目的，包括向一起去的女同学炫耀，或者是向孩子们炫耀，亦或是因为自己过于固执的要实现所谓的理想，还是因为自己从农村出来的一路上的感悟，也包括自己高中那些美好但遗憾的回忆，这些叠加在一起，让我觉得自己的理想就是去高中当老师，去贫困地区的高中当老师。</p><p>后来经历了很多事情，李永乐老师对我影响颇深。前不久我的学生参加了高考，得知他有机会去高校学习，我比自己当年考上大学还要兴奋。</p><p>很感慨：人的欲望总是无穷无尽，想明白了自己还比较喜欢做啥，现在这个方向发展的也还不错，就想着更加精神的，更加完美的方向，这样也好，有超乎金钱、权力的理想总归是好事，可能也是从尊重需求迈向自我需求的跨越。所以我决定来扒一扒，当然这只是包括我在内少部分人的思想境况，我当然不希望大多人都这样，毕竟国家的发展需要方方面面的人才。</p><p>以前看过一篇《肖申克的救赎》的<a href="https://www.zhihu.com/answer/44595996">影评</a>，作者说自己最大的感悟在于Andy的经历所彰显出来的4步：</p><ol type="1"><li>有理想和希望，永远不弃；</li><li>有足够的勇气；</li><li>有坚持行动的毅力；</li><li>有行动的智慧。</li></ol><p>我大致走过了第一步，却没有足够的勇气去真的放弃机会收益，去真的和所谓的成功学搏斗，其实就是和自己的内心搏斗。至少，在我研究生刚毕业时候不敢，有朋友说可以等到35岁财务自由后再去做这件事，我之前也是这么考虑的，如果30岁前没有走到管理层（30以前没有进外企或者国内管理岗，跳槽稳定行业），就进入体制内。但我担心的是：届时我是否也有勇气放弃已经得到的一切，去从头再来。</p><p>我本来就是一个占有欲比较强的人，希望能做到很多事的兼得，这很不好，我已经在改正了。</p><p>目前的打算就是：努力掌握CS公司的选择权，不论是国内高薪还是轻松外企，同时了解高中的教师工作，拿到资格证。下一步就是挣钱，挣很多很多钱，尽可能让自己退出时有底气，接下来就是去实现下理想，在体制内做些事情。</p><p>有段时间也考虑过直接去一个轻松的外企，或者直接进入体制内工作，但我觉得这些选择有点过于自我，我的成就感不会太高，还是帮别人提升价值更好一些。</p><p>明确理想是一个渐进的过程，那个时候我揭开了它的第一层面纱，但还是朦朦胧胧，因为我不知道自己应该怎么去做才能实现？所以也在豆瓣抱怨，这也是我常常给自己贴上伪理想主义者标签的原因，因为不敢勇敢追求的理想实在登不上大雅之堂，但是又有一些经历和交流、思考后，我揭开了它的第二层面纱，我不知道第三层面纱何时才能揭开？</p><p>寻找理想的过程有反复、有曲折， 18年7月：</p><blockquote><p>自己又害怕去找工作，又懒得去考研。整天在知乎上看大神的回答，互相吹捧，月入多少，仿佛自己也是那类人，也在他们的圈子里。 恐怕唯一真正体验到的，就是对死亡的恐惧。我也害怕自己一辈子碌碌无为。</p></blockquote><p>19年4月时：</p><blockquote><p>为尘世所牵绊，渐渐忘记了自己的理想和希望， 没有了理想，也没有了勇气</p><p>我希望能找到这个问题的答案，知乎 看书 交谈等等，不想每天都过得匆匆忙忙，却也浑浑噩噩</p><p>有一个相爱的人，一份不错的工作，朋友都健康快乐。</p></blockquote><p>以前被所谓的成功学欺骗了太久，相信所谓的马云、王健林之流的鬼话，觉得自己一定要挣很多很多钱才可以，简言之：以前追求的是个人利益最大化，当然这没什么不好，也会在一定程度上促进整个人类的进步，但我想，这样的贡献是极其微小的，甚至不值一提，帮人增值也许贡献更大，或者说更适合我。</p><p>后来又觉得活得轻松快乐才是最重要的，于是就想毕业后进入体制/外企，或者挣点钱再去体制内，整天过着人一样的生活，再后来我的思想更加开放，想着能不能在轻松自由的同时做出一点微薄的贡献，帮助他人成长，尤其是帮助贫苦人民成长。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT Operating System Engineering#0 Booting a PC</title>
      <link href="/2020/09/16/MIT%20Operating%20System%20Engineering#0%20Booting%20a%20PC/"/>
      <url>/2020/09/16/MIT%20Operating%20System%20Engineering#0%20Booting%20a%20PC/</url>
      
        <content type="html"><![CDATA[<p><em>最近在学MIT的OS课程，lab绝对业界良心。 XJTU的操作系统课就是写一个系统调用，改下进程软中断通信的代码，代码量不足500。。。 MIT上课用xv6来教学，lab是做一个完整的小型操作系统JOS。</em></p><hr /><h2 id="配置环境">配置环境</h2><p>虽然没什么技术含量，但是这真的是令人头疼的事。附：<a href="https://blog.csdn.net/eye_water/article/details/80638463">图文教程</a> 需要一台x86机器，一般的Linux发行版应该都可以，可以使用<code>unabenlme -a</code>查看，如果显示<code>xxx GNU/Linux</code>就行，MIT的学生可以使用配置好的远程Server。 本来打算白嫖下Harvard的服务器，但是没有<code>root</code>权限，只能可怜巴巴地在Win环境用虚拟机。 平台：Vmware Player15，<a href="http://old-releases.ubuntu.com/releases/14.04.5/">Ubuntu-14.04.5-desktop-i386.iso</a></p><ul><li>检验编译链 <code>objdump -i</code>：第二行显示elf32-i386； <code>gcc -m32 -print-libgcc-file-name</code>：打印出/usr/lib/gcc/i686-linux-gnu/4.8/libgcc.a</li><li>安装git：<code>sudo apt-get install git</code></li><li>下载qemu 建议不要作死，安装MIT Patch过的版本：<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code></li><li>安装依赖库 官方说要装5个库，但其实libtool-bin好像找不到，不过不影响后续： <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install libsdl1.<span class="number">2</span><span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libglib2.<span class="number">0</span><span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libz<span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libpixman<span class="literal">-1</span><span class="literal">-dev</span></span><br></pre></td></tr></table></figure></li><li>配置qemu 切到qemu目录，<code>./configure --disable-kvm --disable-werror --target-list="i386-softmmu x86_64-softmmu"</code> <code>[--prefix=PFX]</code>可选参数是选择安装路径，这里就默认在<code>/usr/local</code></li><li>安装qemu：<code>sudo make &amp;&amp; sudo make install</code></li><li>下载实验代码 根目录下新建6.828目录，切到该目录，<code>git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</code>，切到<code>lab</code>目录，<code>make</code>就可以了。 ## PC Bootstrap 物理地址空间： <img src="https://img-blog.csdnimg.cn/20200523082913317.png" alt="在这里插入图片描述" /> 以前的PC内存只有1MB，Low Memory是PC唯一能用的RAM。VGA Display是VGA缓冲区和固件，BIOS以前都在ROM中，不过现今都在闪存中，做完系统初始化（PCI总线等重要设备），寻找bootable设备(硬盘)，读取boot loader加载OS，将控制权转OS。后来内存远远超过1MB，可用的也就有Extended Memory，不过为了后向兼容，还是保留了Low Memory，这样可用的RAM就被分为了两部分。如果64位系统，那么内存更大，这样为了兼容，32-bit memory mapped devices还是要保留，就又被割裂了。 ## The Boot Loader 硬盘的第一个分区存放启动程序，包括一个汇编文件<code>boot/boot.S</code>和一个C文件<code>boot/main.c</code>，启动程序将CPU从实模式转为32位保护模式，通过特殊的I/O指令读取内核。 ## The Kernel</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web Proxy</title>
      <link href="/2020/09/04/Web%20Proxy/"/>
      <url>/2020/09/04/Web%20Proxy/</url>
      
        <content type="html"><![CDATA[<h2 id="intro">Intro</h2><p>Web Proxy是浏览器和服务器的中间人：浏览器访问网页时，将请求发给代理，由代理将该请求发给服务器；服务器返回结果时，先发送给代理，由代理发给浏览器。之所以这么做，是因为可以在Proxy这做一些事情： - 防火墙：<del>有些不能直接访问的网站可以通过代理去访问</del> ； - 匿名器：代理可以隐藏浏览器的信息，使其对服务器匿名； - 缓存：暂存服务器返回结果，加快访问速度。</p><p>本项目要实现一个简单的Web Proxy，支持以下Features： - 中间人功能 - 并发 - 缓存 ## Background Knowledge - HTTP/1.0 GET 当用户在浏览器输入URL<code>http://www.cnblogs.com/EIMadrigal</code>并按下回车后，浏览器会向代理发送HTTP请求，请求行可能如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.cnblogs.com:8080/EIMadrigal HTTP/1.1</span><br></pre></td></tr></table></figure> 代理要将这个请求解析为主机名<code>www.cnblogs.com</code>、端口<code>8080</code>和路径<code>/EIMadrigal</code>，之后代理可以尝试连接<code>www.cnblogs.com</code>并且向服务器发送新的HTTP请求，请求行如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /EIMadrigal HTTP/1.0</span><br></pre></td></tr></table></figure> - Request Header <img src="https://img-blog.csdnimg.cn/20200726153711559.png" alt="在这里插入图片描述" /> 请求头可能有多行，每行的基本组成就是头部字段名和值，需要注意的是：HTTP请求的每一行都以<code>\r\n</code>结束，并且整个请求是以空行<code>\r\n</code>结束。 项目要求：<strong>对于浏览器自带的request header，代理应该原封不动地转发</strong>。但必须将以下4项补齐，即如果自带的请求头包含以下4项之一，就按照自带请求头转发；否则按照下面的默认值转发。对于自带的其它请求头，直接转发即可：</p><p>Host：服务器主机名，如果浏览器自带，直接转发；否则使用请求行里解析出的hostname。 User-Agent：用户的操作系统/浏览器等信息。 Connection：第一次请求/响应完成后，当前连接是否keep alive。 Proxy-Connection：同上。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host: www.cnblogs.com</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (X11; Linux x86_64; rv:<span class="number">10.0</span><span class="number">.3</span>) Gecko/<span class="number">20120305</span> Firefox/<span class="number">10.0</span><span class="number">.3</span></span><br><span class="line">Connection: close</span><br><span class="line">Proxy-Connection: close</span><br></pre></td></tr></table></figure> - 端口 请求端口：URL中的可选字段，如果用户输入时指定，代理应该连接指定端口，否则使用默认端口80。 监听端口：代理应该在该端口监听用户的连接请求，由命令行参数给出。可以是1024~65536之间的未被其他进程占用的任意值。 ## Implementation - Sequential Web Proxy 代理首先要接收浏览器HTTP请求，将浏览器的标准请求解析，转换为自己的请求发送。 这里的实现不难，只要模仿Tiny Server在一个死循环中监听来自浏览器的请求，接收之后在<code>void doit(int fd)</code>里完成解析请求行、请求头、将处理后的请求发送给server、接收server的响应并写回浏览器。 一些比较方便的函数： <code>int accept(int listenfd, struct sockaddr *addr, int *addrlen)</code>：在<code>listenfd</code>等待连接请求，将client的socket信息和长度存入<code>addr</code>和<code>addrlen</code>； <code>int Open_clientfd(char *hostname, char *port)</code>：Open connection to server at &lt;hostname, port&gt;, return a socket descriptor ready for reading and writing. 读写时可以使用提供的RIO包。</p><p>这里需要注意的是请求的解析：思路是在proxy这里整合所有的请求行和请求头信息，对于所有浏览器发来的请求头的内容，原封不动保存到<code>reqHeader</code>里；对于默认的4个请求头，缺少几个，就按照规定内容增加进去。 还要注意：因为规定<code>Connection</code>和<code>Proxy-Connection</code>都有Connection这个单词，所以用<code>strstr</code>查找的时候：如果浏览器自带的请求头没有<code>Connection</code>但是有<code>Proxy-Connection</code>，这时程序就可能误判为有<code>Connection</code>，所以最好用函数<code>strncmp</code>或者<code>memcmp</code>。</p><p>要写一个非常robust的URI解析器还是挺繁琐的，由于C没有正则表达式（也许可以用其他语言写好编译成库，然后C程序调用？），需要考虑的情况很多。 首先明确URI的格式：一般由4部分组成：protocol://hostname:[port]/path/[parameters][?query][#fragment] 协议目前只支持HTTP和HTTPS，其它一律不合法。 因为一旦和服务器建立连接后，protocol和hostname就没用了，只需要path以及后面的query和fragment，为了方便起见，将/也放入path字段，因为其表示根目录，但是对于query和fragment，没有放?和#，因为找到请求内容的位置后，一些具体的搜索/片段直接用关键字即可，与?和#没关系，只有/特殊一些。 - Multiple Concurrent Requests 对于Iterative Server，同时只能处理一个连接请求：<img src="https://img-blog.csdnimg.cn/20200821122702755.png" alt="在这里插入图片描述" /> 当第二个客户试图去连接：调用<code>connect</code>会正常返回，但Server不会<code>Accept</code>该请求，会用TCP Listen Backlog技术将该请求入队；调用<code>rio_writen</code>也会正常返回，Server会把写入的数据存入缓存；调用<code>rio_readlineb</code>会阻塞，因为Server没有发送任何的response。</p><p>解决方法就是并发处理，我们的代理要能同时处理多个请求，具体的方法很多：多进程、I/O多路复用、预线程化（类似生产者-消费者问题，先创建n个线程，相当于n个缓冲区），最直接的方式就是专门有一个线程负责监听，每收到一个连接请求，就开一个新线程去进行读写。这里要采用<strong>可分离</strong>的线程模型：当其终止时，内存资源会被系统自动回收。</p><p>这部分本来很简单，但是写完后测试发现挂了： <img src="https://img-blog.csdnimg.cn/20200811181713826.png" alt="在这里插入图片描述" /> 这很可能是NOP Server出了问题，这个Server是用Python写的，我去启动了一下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nop-server.py <span class="number">15000</span></span><br></pre></td></tr></table></figure> 发现： <img src="https://img-blog.csdnimg.cn/20200811182155577.png" alt="在这里插入图片描述" /> 这个问题是Python的版本不匹配，把<code>nop-server.py</code>第一行的<code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python3</code>即可，指定用python3的解释器执行脚本。</p><p>并发这块也妥了： <img src="https://img-blog.csdnimg.cn/20200811182851976.png" alt="在这里插入图片描述" /> 这里的测试逻辑是这样的：Client1通过proxy连接到nop-server，这个服务器永远不会发送response，也就是这条连接一直保持；Client2通过proxy连接到Tiny，看看能不能从Tiny取个文件回来，如果能，说明并发是ok的，如果不能，说明不支持并发。之所以要用nop-server，是因为这东西可以一直连接，比较方便。如果Client1也是通过proxy连Tiny，那么可能很快就执行完了，这时Client2再去连接，很可能就不是并发的访问了，失去了测试的意义。</p><p>做第三部分之前，先实际测试下proxy的健壮性。用FireFox浏览器试试，先升级到最新版本，然后设置浏览器的代理方式： <img src="https://img-blog.csdnimg.cn/20200811194820393.png" alt="在这里插入图片描述" /> 在8080端口运行proxy，然后找个HTTP网站<code>http://csrankings.org/</code>试一下，现在网站基本都是HTTPS，看来后续的Features要支持HTTPS了（先挖个坑）。</p><p>运行proxy之前，画风是这样的： <img src="https://img-blog.csdnimg.cn/20200811200533477.png" alt="在这里插入图片描述" /> 运行proxy之后： <img src="https://img-blog.csdnimg.cn/20200821133459152.png" alt="在这里插入图片描述" /> 通过代理访问该网页时，页面只能加载一部分，收到59420B数据后，会<code>segmentation fault</code> ，最后发现 主要原因是<code>init_cache()</code>时空间分配写错了，但是修改后又出现了如下错误： <img src="https://img-blog.csdnimg.cn/20200824160910224.png" alt="在这里插入图片描述" /> 是<code>memcpy</code>时候数组越界，处理buffer时候要千万小心。</p><p>这里要改下<code>csapp.c</code>中的错误处理，里面都是直接<code>exit(0)</code>，但是作为一个服务器，不能随便终止，所以我们注释掉所有Error-handling functions里的<code>exit()</code>，如果在读数据或者什么时候遇到错误，<code>return</code>即可：<code>exit()</code>是系统调用级别的，结束整个进程；<code>return</code>是函数级别的，返回给调用者，当然在<code>main()</code>里<code>return</code>也就是<code>exit(0)</code>。 - Caching Web Objects 缓存可以说是整个项目的难点，需要考虑的问题比较多。为了模块化，将这一部分单独写作<code>cache.c/cache.h</code>，并修改<code>Makefile</code>。 主要问题有2个： 1、多线程同步：对于cache的访问应当是线程安全的，多个线程可以同时读，但只有一个线程可以写，这就是典型的读者-写者问题（又用到操作系统的知识了）； 2、替换策略：cache块的数量是有限的，没有空间时就需要换出换入。一般来讲都是采用LRU方式，一个单线程的严格的LRU Cache可以参考<a href="https://leetcode.com/problems/lru-cache/">leetcode146题</a>。</p><p>我们首先来解决问题一： 读者写者问题可以分为读优先、写优先2种： 读优先：来了一个读进程，除非有一个写进程正在访问，否则读者直接去读，可能导致写进程饥饿； 写优先：有进程读时，如果来了写进程，那么禁止后续读进程请求，现有进程读完后，写进程立即去写，可能导致读进程饥饿。 写优先实现起来稍微麻烦一些，所以这里采用读优先。这里就不自己实现读者写者了，使用读写锁<code>pthread_rwlock_t</code>，确保不会死锁。</p><p>接着来解决问题二： 要实现多线程并发LRU Cache，由于C实现双向链表和Hashtable有点繁琐，所以项目要求<strong>近似LRU</strong>即可：我们可以为每一个cache块附加一个时间戳，每当该块被访问时，就更新时间戳。需要替换时，换出时间戳最小的块即可。这样带来的问题就是：读的时候也需要更新时间戳，但更新时间需要加写锁，如果其他线程占用写锁，那么读进程就无法更新时间戳，也就不是严格的LRU了。</p><p>Cache的实现既可以像malloc lab一样采用分级的思想，也可以直接均分所有空间，整体流程如下： - 初始化 - 查Cache - 如果miss，寻找可用位置 - 找到可用块，缓存满足大小条件的Object - 更新时间戳</p><p>最大的缓存对象是100KB，一共的空间1MB，平均可以缓存10个Object，这样会浪费24KB空间。所以采用分级的方法： 100KB * 5块 = 500KB 50KB * 6块 = 300KB 20KB * 5块 = 100KB 10KB * 10块 = 100KB 1KB * 24块 = 24KB 接着来构思下存储结构，<strong>设计数据结构</strong>和<strong>类（函数）接口</strong>是我认为做一个工程最难的部分，当然还有最后的效率优化问题： 一个cache line最基本的构成需要存储URI和OBJ，因为下次用户请求时代理需要知道请求的是哪个网站的什么内容（通过URI确定），进而如果查找到，将内容OBJ直接返回给用户。同时还需要一个时间戳以及用于同步的读写锁： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *uri;</span><br><span class="line">    <span class="keyword">char</span> *obj;</span><br><span class="line">    <span class="keyword">int</span> objSize;</span><br><span class="line">    <span class="keyword">int64_t</span> time;</span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> rwlock; </span><br><span class="line">&#125; cache_line;</span><br></pre></td></tr></table></figure> 一共有5种类型的cache，每种类型有一个number，还有一个指向该种cache第一块的指针p，p指向该种的第一小块，p+1指向该种的第二小块，以此类推： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> numOfLine;</span><br><span class="line">    cache_line *cachep;</span><br><span class="line">&#125; cache_type;</span><br></pre></td></tr></table></figure> 数据结构设计完后，需要设计函数接口，cache的操作有初始化、查找、写入（替换）和释放： 初始化需要为cache block分配空间，将每一块的时间戳置0，表示该块没有存储内容； 查找时需要遍历所有的type，再在该type中遍历所有的block，如果时间戳不为0，比对浏览器需要访问的URI与当前块的URI是否相等，相等则表示cache hit，直接写回给相应的fd；更新时间戳时，粒度越细越好，这里用<code>gettimeofday</code>精确到微秒级别；读取时如果能申请到写锁，就更新时间，否则就不更新； 写入时需要先计算object大小，寻找空闲的cache block，没有需要替换，满足要求后存入cache，并且将结果返给浏览器。这里要注意寻找空闲块时要<strong>从小往大</strong>，否则很可能一个很小的object占用了一块很大的block，造成严重浪费，类似于操作系统内存管理动态分配中的最佳适应算法。 那么这种分级的方式的缺点是：每种类型的cache块<strong>大小固定</strong>，很可能50KB的块只存了10KB内容，造成浪费，类似于固定分区分配。 关于替换，我们采取<strong>局部置换</strong>策略：即需要换入的object大小如果是30KB，我们只用50KB这种类型去存储，如果50KB的块用完了，就需要换出一块50KB，即使此时100KB的块有空闲，也仍然完成置换过程。</p><p>写完cache后，需要修改<code>Makefile</code>，在<code>proxy.c</code>中增加cache的部分。运行完以后，可以用<code>make clean</code>清除目录下多余的垃圾文件，比如<code>.o</code>文件等。 ## Test 测试的方式一共有3种：</p><ul><li>自动化测试 利用课程提供的脚本<code>driver.sh</code>自动进行，执行之前，需要安装一些工具： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install net-tools</span><br></pre></td></tr></table></figure> 做完所有内容后，先用<code>driver.sh</code>进行测试，发现cache部分没分。。。得，开始debug吧！我觉得GDB好难用啊，所以都是通过<code>printf</code>de的。</li></ul><p>用curl先通过proxy发个请求，然后看看proxy有没有缓存服务器返回的内容。 最后发现在<code>write_cache</code>时需要用到URI，但是之前解析时候把URI改了，一定注意URI最好不要改，设置为<code>const</code>比较保险。</p><p>完了以后，cache满分了，basic又错了一个，fetch可执行对象文件tiny时： <img src="https://img-blog.csdnimg.cn/20200819212506210.png" alt="在这里插入图片描述" /> 一开始怀疑是tiny太大了，某个数组爆掉了。看了下tiny有36000+B，缓存空间足够，但是可能写入时候有些bug。tiny是二进制文件，可能比较特殊？很奇怪的是：明明<code>objSize</code>是36000+，但是<code>strlen(obj)</code>只有100，怀疑文件中可能有<code>\0</code>，提前终止了<code>strlen</code>的计数。</p><p>解决方案是<code>write_cache</code>参数不仅要有<code>uri</code>和<code>obj</code>，还要有<code>obj</code>的长度<code>len</code>，否则直接用<code>strlen</code>获取长度可能就挂了。后来修改以后就满分了，一定要注意，如果用<code>char*</code>传参，一定要附带参数<code>len</code>，因为不一定读取的是字符串，还有可能是二进制文件，<code>\0</code>也就是<code>0</code>很容易出现，用<code>strlen</code>大概率会爆掉。</p><p>最终测试结果如下： <img src="https://img-blog.csdnimg.cn/20200819221810760.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20200819221846500.png" alt="在这里插入图片描述" /> - 利用<code>curl</code>工具 <code>curl</code>可以用来生成HTTP请求：假设Sever在端口15213监听，代理在端口15214监听，那么可以通过下面命令经由代理发送请求： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --proxy http:<span class="comment">//localhost:15214 http://localhost:15213/home.html</span></span><br></pre></td></tr></table></figure> 我们用该工具测试下Sequential Web Proxy： 首先启动Tiny Web Server和Proxy： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./tiny 15213</span><br><span class="line">./proxy 15214</span><br></pre></td></tr></table></figure> 然后执行<code>curl</code>命令： <img src="https://img-blog.csdnimg.cn/20200730162654329.png" alt="在这里插入图片描述" /> 说明基本功能是OK的！！ - 实际浏览器测试 满分之后，万里长征走了一半吧，因为要在实际浏览器测试，不断增强程序的<strong>鲁棒性</strong>。 测试之前，先禁用浏览器自带的cache，清空之前的缓存。 测下内存泄漏：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --leak-check=full --show-leak-kinds=all ./proxy 8080</span><br></pre></td></tr></table></figure><h2 id="codereference">Code&amp;Reference</h2><p><a href="https://github.com/EIMadrigal/15-213/tree/master/Web%20Proxy">code here</a> <a href="http://csapp.cs.cmu.edu/3e/labs.html">reference here</a> ## TODO 接下来的工作可拓展的还有很多，包括但不限于： - 增加对HTTPS的支持（看起来并不简单） - Cache这里还有很多可优化的地方（分配策略、置换策略...） - 目前只支持GET方式，还可以拓展到POST方式</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>给我未来的孩子</title>
      <link href="/2020/08/31/%E7%BB%99%E6%88%91%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%AD%A9%E5%AD%90/"/>
      <url>/2020/08/31/%E7%BB%99%E6%88%91%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%AD%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>读诗之前，先澄清一点：这首诗原作者是作家张梅女士，收录于20世纪90年代出版的个人散文集《木屐声声》。至于流传甚广的余光中先生的《写给未来的你》，完全是某些出版物杜撰的，17年余先生去世时，大家读着这篇别人的文章以为纪念，不知道算不算一种悲哀。</p><p>如果读过余光中的作品，他的文风绝对不会像这首诗这么直白，当然也不会如此鸡汤。</p><p>说回这首诗，有一次搜索<理想主义者>时偶然读到，虽然有些道理比较宏大，但是整体来看都是作者阅历的总结，如果结合自身经验去读相信一定收获颇丰，当然作为育儿经也是不错的~</p><hr /><p>孩子，我希望你自始至终都是一个理想主义者。</p><p>你可以是农民，可以是工程师，可以是演员，可以是流浪汉，但你必须是个理想主义者。</p><p>童年，我们讲英雄故事给你听，并不是一定要你成为英雄，而是希望你具有纯正的品格。</p><p>少年，我们让你接触诗歌、绘画、音乐，是为了让你的心灵填满高尚的情趣。 这些高尚的情趣会支撑你的一生，使你在最严酷的冬天也不会忘记玫瑰的芳香。</p><p>理想会使人出众。</p><p>孩子，不要为自己的外形担忧。</p><p>理想纯洁你的气质，而最美貌的女人也会因为庸俗而令人生厌。</p><p>通向理想的途径往往不尽如人意，而你亦会为此受尽磨难。</p><p>但是，孩子，你尽管去争取，理想主义者的结局悲壮而绝不可怜。</p><p>在貌似坎坷的人生里，你会结识许多智者和君子，你会见到许多旁人无法遇到的风景和奇迹。</p><p>选择平庸虽然稳妥，但绝无色彩。</p><p>不要为蝇头小利放弃自己的理想，不要为某种潮流而改换自己的信念。</p><p>物质世界的外表太过复杂，你要懂得如何去拒绝虚荣的诱惑。</p><p>理想不是实惠的东西，它往往不能带给你尘世的享受。</p><p>因此你必须习惯无人欣赏，学会精神享受，学会与他人不同。</p><p>其次，孩子，我希望你是个踏实的人。</p><p>人生太过短促，而虚的东西又太多，你很容易眼花缭乱，最终一事无成。</p><p>如果你是个美貌的女孩，年轻的时候会有许多男性宠你，你得到的东西太过容易，这会使你流于浅薄和虚浮；如果你是个极聪明的男孩，又会以为自己能够成就许多大事而流于轻佻。</p><p>记住，每个人的能力有限，我们活在世上能做好一件事足矣。</p><p>写好一本书，做好一个主妇。</p><p>不要轻视平凡的人，不要投机取巧，不要攻击自己做不到的事。</p><p>你长大后会知道，做好一件事太难，但绝不要放弃。</p><p>你要懂得和珍惜感情。</p><p>不管男人女人，不管墙内墙外，相交一场实在不易。</p><p>交友的过程会有误会和摩擦，但想一想，诺大世界，有缘结伴而行的能有几人？</p><p>你要明白朋友终会离去，生活中能有人伴在身边，听你倾谈，倾谈给你听，就应该感激。</p><p>要爱自己和爱他人，要懂自己和懂他人。</p><p>你的心要如溪水般柔软，你的眼波要像春天般明媚。</p><p>你要会流泪，会孤身一人坐在黑暗中听伤感的音乐。</p><p>你要懂得欣赏悲剧，悲剧能丰富你的心灵。</p><p>希望你不要媚俗。</p><p>你是个独立的人，无人能抹杀你的独立性，除非你向世俗妥协。</p><p>要学会欣赏真，要在重重面具下看到真。</p><p>世上圆滑标准的人很多，但出类拔萃的人极少。而往往出类拔萃又隐藏在卑琐狂荡之下。</p><p>在形式上我们无法与既定的世俗争斗，而在内心我们都是自己的国王。</p><p>如果你的脸上出现谄媚的笑容，我将会羞愧地掩面而去。</p><p>世俗的许多东西虽耀眼却无价值，不要把自己置于大众的天平上，不然你会因此无所适从，人云亦云。</p><p>在具体的做人上，我希望你不要打断别人的谈话，不要娇气十足。</p><p>你每天至少要拿出两小时来读书，要回信写信给你的朋友。</p><p>不要老是想着别人应该为你做些什么，而要想着怎么去帮助他人。</p><p>借他人的东西要还，不要随便接受别人的恩惠。</p><p>要记住，别人的东西，再好也是别人的；自己的东西，再差也是自己的。</p><p>孩子，还有一件事，虽然做起来很难，但相当重要，这就是要有勇气正视自己的缺点。</p><p>你会一年年地长大，会渐渐遇到比你强、比你优秀的人，会发现自己身上有许多你所厌恶的缺点。 这会使你沮丧和自卑。</p><p>但你一定要正视它，不要躲避，要一点点地加以改正。</p><p>战胜自己比征服他人还要艰巨和有意义。</p><p>不管世界潮流如何变化，但人的优秀品质却是永恒的：正直、勇敢、独立。</p><p>我希望你是一个优秀的人。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bit Manipulation</title>
      <link href="/2020/08/26/Bit%20Manipulation/"/>
      <url>/2020/08/26/Bit%20Manipulation/</url>
      
        <content type="html"><![CDATA[<p>位操作可以使得我们细粒度地控制数据，但是很多技巧显得非常tricky，需要做一些总结。 ## Basics 常见的操作有：与、或、非、异或和移位。</p><ul><li><code>n &amp; (n - 1)</code>：将n的二进制表示中最低位的<code>1</code>改为<code>0</code></li><li><code>a ^ b = b ^ a</code>，<code>(a ^ b) ^ c = a ^ (b ^ c)</code>，<code>a ^ 0 = a</code>，<code>a ^ a = 0</code></li><li><code>n &amp; (-n)</code>：lowbit操作，将最低位的1及后面的0代表的数字转为十进制</li><li><code>&amp;</code>只会递减/不变</li><li><code>a = a | (1 &lt;&lt; i)</code> 将a的第i位设为1</li></ul><h2 id="examples">Examples</h2><ol type="1"><li>计算二进制中<code>1</code>的个数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line">n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">++cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>判断整数是否为2的幂</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v; <span class="comment">// we want to see if v is a power of 2</span></span><br><span class="line"><span class="keyword">bool</span> f;         <span class="comment">// the result goes here </span></span><br><span class="line"></span><br><span class="line">f = (v &amp; (v - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">f = v &amp;&amp; !(v &amp; (v - <span class="number">1</span>));  <span class="comment">// v=0特判</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>整数相加</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// a^b: a+b without carry</span></span><br><span class="line">        <span class="comment">// a&amp;b: the carry</span></span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum(a ^ b, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>将n中第i~j位置0</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) &#123;</span><br><span class="line">mask |= (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br><span class="line">mask = ~mask;</span><br><span class="line">n = n &amp; mask;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><a href="https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary:-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently">A summary: how to use bit manipulation to solve problems easily and efficiently</a> <a href="http://graphics.stanford.edu/~seander/bithacks.html">Bit Twiddling Hacks</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Library Functions Implementation</title>
      <link href="/2020/08/16/Library%20Functions%20Implementation/"/>
      <url>/2020/08/16/Library%20Functions%20Implementation/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">void</span>* des, <span class="keyword">unsigned</span> <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!src || !des)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (des &gt; src &amp;&amp; (<span class="keyword">const</span> <span class="keyword">char</span>*)src + cnt &lt; (<span class="keyword">char</span>*)des) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* srcB = (<span class="keyword">const</span> <span class="keyword">char</span>*)src + cnt - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span>* desB = (<span class="keyword">char</span>*)des + cnt - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">*desB = *srcB;</span><br><span class="line">--desB;</span><br><span class="line">--srcB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* srcF = (<span class="keyword">const</span> <span class="keyword">char</span>*)src + cnt - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span>* desF = (<span class="keyword">char</span>*)des + cnt - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">*desF = *srcF;</span><br><span class="line">++desF;</span><br><span class="line">++srcF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将original中的子串substr替换为replace</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strReplace</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* original, <span class="keyword">const</span> <span class="keyword">char</span>* substr, <span class="keyword">const</span> <span class="keyword">char</span>* replace)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!original || !substr || !replace) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(original);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* newStr = <span class="built_in">malloc</span>((len + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">memcpy</span>(newStr, original, (len + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* p = <span class="built_in">strstr</span>(newStr, substr);</span><br><span class="line"><span class="built_in">memcpy</span>(p, replace, <span class="built_in">strlen</span>(replace));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector">vector</h2><p>比较高频的问题：为什么<code>push_back()</code>的平均时间复杂度是<span class="math inline">\(O(1)\)</span>？ 假设倍增因子是<span class="math inline">\(m\)</span>，vector当前有<span class="math inline">\(n\)</span>个元素，那么扩容过程大致为：<span class="math inline">\(0,1,m,m^2,...,m^{log_mn}\)</span>，每次扩容的复杂度等于当时的元素个数，无需扩容时插入的时间复杂度为<span class="math inline">\(O(1)\)</span>，所以总的复杂度为： <span class="math display">\[1+m+m^2+...+m^{log_mn}=\frac{mn-1}{m-1}\]</span> 如果<span class="math inline">\(m=2\)</span>，那么均摊到<span class="math inline">\(n\)</span>个元素，插入每个元素的操作复杂度就是<span class="math inline">\(O(1)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> t=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">class myvector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">push_back</span>(T&amp; x) &#123;</span><br><span class="line"><span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line"><span class="built_in">broad</span>(<span class="number">2</span> * capacity + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">obj[size++] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">broad</span><span class="params">(<span class="keyword">int</span> newCap)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (newCap &lt; size)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">T* tmp = obj;</span><br><span class="line">obj = <span class="keyword">new</span> T[newCap];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">obj[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> capacity;</span><br><span class="line">T* obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!str) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;Invalid input!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*str == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (*str == <span class="string">&#x27;+&#x27;</span> || *str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (*str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">sign = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*str &lt; <span class="string">&#x27;0&#x27;</span> || *str &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;Invalid input!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">value = value * <span class="number">10</span> + *str - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sign * value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(mn)，可以用KMP优化为O(m+n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; haystack.<span class="built_in">size</span>() &amp;&amp; j &lt; needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - j + <span class="number">1</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - needle.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></typename></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Tiny Shell</title>
      <link href="/2020/08/02/Tiny%20Shell/"/>
      <url>/2020/08/02/Tiny%20Shell/</url>
      
        <content type="html"><![CDATA[<h2 id="intro">Intro</h2><p>本项目要实现一个简易版Shell，支持以下Features： - 命令提示符<code>tsh&gt;</code> - 若用户输入的命令第一个单词是内置命令，在当前进程tsh(Tiny Shell)执行命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span>   列出运行/挂起的后台job</span><br><span class="line"><span class="built_in">bg</span> &lt;job&gt;   通过发送SIGCONT信号重启进程，将后台挂起的job设为在后台运行，&lt;job&gt;可以是PID或%JID</span><br><span class="line"><span class="built_in">fg</span> &lt;job&gt;   通过发送SIGCONT信号重启进程，将后台运行/挂起的job设为在前台运行，&lt;job&gt;可以是PID或%JID</span><br><span class="line"><span class="built_in">kill</span> &lt;job&gt;   结束&lt;job&gt;</span><br><span class="line">quit   退出tsh</span><br></pre></td></tr></table></figure> - 若用户输入的命令第一个单词是可执行文件路径，后续单词是命令行参数，tsh会fork一个子进程，在子进程运行 - 支持job control（前后台切换），改变进程状态（running/stopped/terminated） - 支持管道<code>|</code>和I/O重定向<code>&lt;</code> <code>&gt;</code>(TODO) ## Background Knowledge - Shell shell是一个交互式的命令行解释器，可以执行用户输入的指令，显示计算结果。 用户输入既可以是内置命令，也可以是可执行文件路径。用户既可以在前台运行，也可以在后台运行。后台job可以在命令最后加一个<code>&amp;</code>，否则视为前台。比如<code>/bin/ls -l -d &amp;</code>表示在后台执行<code>ls</code>程序。前台job只能有1个，后台job则可以有多个。 - Signals 信号机制的作用就是允许进程/内核打断其他进程运行，是进行进程间通信的一种方式。 Linux的常用信号有： <img src="https://img-blog.csdnimg.cn/20200719145450179.png" alt="在这里插入图片描述" /> ## Implementation - useful functions <code>int fork(void)</code>：父进程创建一个子进程，在子进程中返回0，父进程中返回子进程的PID。 <code>int kill(pid_t pid, int sig)</code>：进程向其它进程（包括自己）发送信号，成功返回0，错误返回-1。可以通过改变参数<code>pid</code>调整发送目标：<code>pid&gt;0</code>，给该进程发信号；<code>pid==0</code>，给包括自己在内的当前进程组发信号；<code>pid&lt;0</code>，给pgid=|pid|的进程组的每个进程发信号。 <code>int execve(char *filename, char *argv[], char *envp[])</code>：在当前进程的上下文环境中装载并运行新的程序，成功不返回，失败返回-1。<code>filename</code>可以是可执行目标文件或脚本文件，会覆盖原进程的data/code/stack，会保留原进程的PID/open files/signal context。 <code>pid_t waitpid(pid_t pid, int *status, int options)</code>：指定进程终止父进程会进行回收，否则等待。内核会将子进程的退出状态传给父进程，之后清除子进程。<code>options=WNOHANG | WUNTRACED</code>时，如果wait set中没有终止/暂停的子进程，立即返回0；否则返回任意一个子进程的PID。 <code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)</code>：<code>how=SIG_BLOCK</code>将<code>set</code>中的信号加入阻塞向量；<code>how=SIG_UNBLOCK</code>将<code>set</code>中的信号从阻塞向量中移除；<code>how=SIG_SETMASK</code>将阻塞向量设置为<code>set</code>。如果<code>oldset!=NULL</code>之前的阻塞向量就存储在<code>oldset</code>中。 <code>handler_t *signal(int signum, handler_t *handler)</code>：改变信号的默认行为。 - step by step -- 整体结构：除了测试文件和Makefile外，全部实现都在<code>tsh.c</code>中，<code>main</code>函数有一个死循环，不停调用<code>eval()</code>实现命令的解析、执行。 -- <code>eval(char* cmdline)</code> 接收到用户输入后，第一件事就是解析。解析是通过<code>int parseline(const char* cmdline, char** argv)</code>完成，将<code>cmdline</code>解析到<code>argv</code>中，如果用户要求后台运行就返回1，否则返回0。 解析后，我们需要通过<code>int builtin_cmd(char** argv)</code>判断是否为内置命令。如果是内置命令，就在<code>builtin_cmd</code>里立刻执行；否则需要创建子进程执行，这里需要区分前后台进程：如果是前台，需要等待terminate才能返回并接受新的输入；如果是后台，则可以立即接收新输入。 - key point 1 父进程在<code>fork</code>子进程之前，要用<code>sigprocmask</code>阻塞<code>SIGCHLD</code>信号。否则由于父子进程执行顺序不确定，可能导致： 子进程首先执行完毕，内核向父进程发送<code>SIGCHLD</code>信号； 从内核态切换到用户态时，检测到<code>SIGCHLD</code>信号并且执行<code>sigchld_handler</code>，删除该job； 父进程执行<code>addjob</code>操作，显然删除和添加顺序反了。 如果我们正确阻塞了<code>SIGCHLD</code>信号，还是按照上面的顺序： 子进程首先执行完毕，内核向父进程发送<code>SIGCHLD</code>信号； 从内核态切换到用户态时，由于父进程阻塞了<code>SIGCHLD</code>信号，所以不会执行<code>sigchld_handler</code>； 父进程添加该job，解除<code>SIGCHLD</code>信号的阻塞，下一次context switch时删除job。 - key point 2 用户从键盘输入ctrl-c时，内核给shell发<code>SIGINT</code>信号（默认终止shell进程），在<code>main</code>里面安装handler，在<code>sigint_handler</code>中处理：终止所有的前台进程及其子进程； 用户从键盘输入ctrl-z时，内核给shell发<code>SIGTSTP</code>信号（默认暂停当前进程直到收到<code>SIGCONT</code>），在<code>main</code>里面安装handler，在<code>sigtstp_handler</code>中处理：暂停所有的前台进程及其子进程。 - key point 3 默认情况下，<code>fork</code>出来的子进程和他爹属于同一个进程组。当我们在机器上运行Tiny Shell时，程序运行在前台进程组中，这时如果Tiny Shell创建一些子进程，这些子进程也会同属于这个前台进程组，用户输入ctrl-c会终止所有前台进程，包括Tiny Shell，这显然不是我们想要的。 解决方案是：<code>fork</code>之后，子进程调用<code>setpgid(0,0)</code>将其放到一个新的进程组里，这个组的group id和PID相同。这样就可以确保前台进程组里只有Tiny Shell一个进程，用户输入ctrl-c时，就可以在<code>sigint_handler</code>中调用<code>kill()</code>终止特定的前台job。 - key point 4 当子进程终止或者暂停，内核会给父进程发送<code>SIGCHLD</code>信号，我们在<code>sigchld_handler</code>中根据子进程的状态做相应的处理： <code>WIFEXITED(status)</code>：子进程通过<code>exit</code>或<code>return</code>正常终止； <code>WIFSIGNALED(status)</code>：子进程通过信号终止； <code>WIFSTOPPED(status)</code>：子进程暂停； <code>WTERMSIG(status)</code>：当<code>WIFSIGNALED()</code>为真，返回造成子进程终止的信号ID； <code>WSTOPSIG(status)</code>：当<code>WIFSTOPPED()</code>为真，返回造成子进程暂停的信号ID。 - key point 5 对于前台进程，需要一直等待其执行完毕，然后回收，可以在<code>waitfg()</code>中调用<code>sigsuspend</code>完成；但对于后台进程，由于不用等待其完成，所以为了避免其成为zombie，需要在其执行完毕或者暂停时通知父进程，这个机制就是signal，具体的就是我们的<code>sigchld_handler</code>做的事情。 ## Test 一方面通过提供的脚本测试，共有16个脚本测试文件，测试通过<code>make test01</code>~<code>make test16</code>进行； 另一方面通过实际执行去测试各项功能。 ## Code&amp;Reference <a href="https://github.com/EIMadrigal/15-213/tree/master/Tiny%20Shell">code here</a> <a href="http://csapp.cs.cmu.edu/3e/labs.html">reference here</a> ## TODO 管道、重定向、https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L1</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Seam Carving</title>
      <link href="/2020/07/24/Seam%20Carving/"/>
      <url>/2020/07/24/Seam%20Carving/</url>
      
        <content type="html"><![CDATA[<p>这是CS 61B的HW5，具体实现<a href="https://github.com/EIMadrigal/CS61B/tree/master/hw5">在这里</a>。 ## Intro 这个项目是要实现一种基于内容的图像缩放算法Seam Carving。Seam分为垂直（自上而下每行取一个像素点）和水平（自左向右每列取一个像素点）。 下图是一张505*287的图像： <img src="https://img-blog.csdnimg.cn/20200707090755919.png" alt="在这里插入图片描述" /> 移除150条垂直seam，得到一张比原图窄30%的新图： <img src="https://img-blog.csdnimg.cn/2020070709085251.png" alt="在这里插入图片描述" /> 与传统的内容不可知的方法（裁剪、缩放）相比，seam curving可以保留原图的大多数重要特征。 图像处理中的坐标表示与常见的笛卡尔坐标系不同： <img src="https://img-blog.csdnimg.cn/20200707094310172.png" alt="在这里插入图片描述" /> 每个像素的颜色采用RGB空间，与<code>java.awt.Color</code>一致。算法的过程分为3步：</p><ul><li>Energy calculation 因为是内容感知算法，所以需要一个指标衡量每个像素的<strong>重要程度</strong>，这个指标我们叫做该像素点的能量：能量越高越重要，就不太会被当做seam的一部分剔除。 我们选择双梯度能量函数来计算能量。对于上面的冲浪图，计算后的灰度图如下： <img src="https://img-blog.csdnimg.cn/20200707095021383.png" alt="在这里插入图片描述" /> 可以看到：高能量像素对应颜色发生巨变的地方，比如冲浪者和大海的边界、天际线等，并且颜色更白。处理过程中就是要避免移除这些关键信息。</li><li>Seam identification 计算出每个像素点的能量值后，就要找出一条能量值总和最小的seam，垂直seam从顶行的某像素点开始到最后一行某点结束。但是如果(x,y)位于seam，下一行只能选(x-1,y+1), (x,y+1), (x+1,y+1)之一，可能是为了保证图像的连贯。</li><li>Seam Removal 移除找到的seam。 ## Implement 三个步骤的实现都在<code>SeamCarver</code>中，我们逐个来看：</li><li>单像素能量计算 采用对偶梯度能量函数<span class="math inline">\(\Delta_x^2(x, y) + \Delta_y^2(x, y)\)</span>，x梯度的平方<span class="math inline">\(\Delta_x^2(x, y) = R_x(x, y)^2 + G_x(x, y)^2 + B_x(x, y)^2\)</span>，<span class="math inline">\(R_x(x, y), G_x(x, y), B_x(x, y)\)</span>是左右两个像素点(x+1, y)和(x-1, y)的红、绿、蓝之差的绝对值；类似地，对于y的梯度，就是要求上下两个像素点的差。对于边界的处理，采取循环方式，即如果某侧不存在，就取反方向的点。 举例来看： <img src="https://img-blog.csdnimg.cn/20200707155708977.png" alt="在这里插入图片描述" /> 要计算(1, 0)位置即(255, 101, 153)的能量： <span class="math display">\[R_x(1, 0) = 255 − 255 = 0, G_x(1, 0) = 101 − 101 = 0, B_x(1, 0) = 255 − 51 = 204\]</span> 故<span class="math inline">\(\Delta_x^2(1, 0) = 204^2 = 41616\)</span>；对于y方向，由于没有(x, y-1)，就用(x, height-1)代替： <span class="math display">\[R_y(1, 0) = 255 − 255 = 0, G_y(1, 0) = 255 − 153 = 102, B_y(1, 0) = 153 − 153 = 0\]</span> 故<span class="math inline">\(\Delta_y^2(1, 0) = 102^2 = 10404\)</span>，所以(1, 0)位置的能量就是<span class="math inline">\(41616 + 10404 = 52020\)</span>。 接口也很简单<code>public  double energy(int x, int y)</code>。</li><li>Find Vertical Seam 这个接口设计为<code>public int[] findVerticalSeam()</code>，返回的数组有H个值，第i个值对应要移除的第i行的列号。 要找这样一条最短路径，我们考虑用动态规划求解： 首先定义子问题<span class="math inline">\(M(i,j)\)</span>表示以<span class="math inline">\((i,j)\)</span>结尾的最短路径的成本，用<span class="math inline">\(e(i,j)\)</span>表示位置<span class="math inline">\((i,j)\)</span>的能量； 接着寻找状态转移方程：由于路径的左右位置绝对值不大于1，所以<span class="math inline">\(M(i,j)=e(i,j)+min\{M(i-1,j-1),M(i,j-1),M(i+1,j-1)\}\)</span>； 最后确定base case：每行的值都由上一行确定，所以base case就是<span class="math inline">\(M(i,0)=e(i,0)\)</span>。 最终结果就是在最后一行找到<span class="math inline">\(M\)</span>最小的像素点，逐行向上寻找三个相邻格子中<span class="math inline">\(M\)</span>较小的那个。</li><li>Find Horizontal Seam 对于水平方向的seam，当然也可以用动态规划求解。但是为了避免代码冗余，我们考虑利用<code>findVerticalSeam()</code>：先将图像转置，然后调用<code>findVerticalSeam()</code>，最后再将其转置即可。 具体的：考虑如下3*2图像： <img src="https://img-blog.csdnimg.cn/20200708090038977.png" alt="在这里插入图片描述" /> 将其转置： <img src="https://img-blog.csdnimg.cn/2020070809031641.png" alt="在这里插入图片描述" /> 利用<code>findVerticalSeam()</code>得到(0,1,0)即为水平的seam，最后将图像再次转置即可。 ## 待改进</li><li>能量计算 每次移除一条seam，都要调用<code>findVerticalSeam()</code>，<code>findVerticalSeam()</code>中会计算所有格子的能量，这样如果我们移除20条seam，就要计算20次所有格子的能量，显然这是可以避免的。 最直观的方法就是空间换时间，创建能量矩阵<code>double[][]</code>存储每个格子的能量。</li><li>水平seam 转置矩阵耗时<span class="math inline">\(O(WH)\)</span>，更快一些的做法是利用一个flag记录当前是在寻找垂直还是水平seam，在计算能量时判断分类。 ## Reference <a href="https://sp18.datastructur.es/materials/hw/hw5/hw5">HW 5: Seam Carving</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>漫谈三毛</title>
      <link href="/2020/07/17/%E6%BC%AB%E8%B0%88%E4%B8%89%E6%AF%9B/"/>
      <url>/2020/07/17/%E6%BC%AB%E8%B0%88%E4%B8%89%E6%AF%9B/</url>
      
        <content type="html"><![CDATA[<p>三毛的书我读的不多，大概只有《撒哈拉的故事》、《梦里花落知多少》和《谈心》。 初识三毛，是在《谈心》中她给一个读者的回信：</p><blockquote><p>三毛女士：   我今年廿九岁，未婚，是一家报关行最低层的办事员，常常在我下班以后，回到租来的斗室里，面对物质和精神都相当贫乏的人生，觉得活着的价值，十分...对不起，我黯淡的心情，无法用文字来表达。我很自卑，请你告诉我，生命最终的目的何在？   以我如此卑微的人（我的容貌太平凡了），工作能力也有限，说不出有什么特别的兴趣，也从来没有异性对我感兴趣。   我真羡慕你，恨不得能够活得像你，可惜我不能，请你多写书给我看，丰富我的生命，不然，真不知活着还有什么快乐？   敬祝 春安！ 一个不快乐的女孩上</p></blockquote><p>谈及生命的意义，这或许是大多数人都会思考的问题，然而它却不像数学题那样有什么所谓的标准答案，这是一道拥有无数种解法的题目。丝毫不需要掩饰，直至今日我仍然没有完全明晰。 是的，人终有一死，一切都会湮灭。生活中的很多事情从人生这一宏观角度来看根本不值一提，广而泛之，其实所有的事情都不值一提。那么生命的意义到底在哪里？不妨先了解下三毛的想法：</p><blockquote><p>不快乐的女孩：   从你短短的自我介绍中，看来十分惊心，二十九岁正当年轻，居然一连串的用了——最低层、贫乏、黯淡、自卑、平凡、卑微、能力有限这许多不正确的定义来形容自己。   以我个人的经验来说，我也反复思索过许多次，生命的意义和最终目的到底是什么，目前我的答案却只有一个，很简单的一个，那便是“<strong>寻求真正的自由</strong>”，然后<strong>享受生命</strong>。   不快乐的女孩，你的心灵并不自由，对不对？当然，我也没有做到绝对的超越，可是如你信中所写的那些字句，我已不再用在自己身上了，虽然我们比较起来是差不多的。   如果我是你，第一步要做的事是加重对自我的期许与看重，将信中那一串又一串自卑的字句从生命中一把扫除，再也不轻看自己。   你有一个正当的职业，租得起一间房间，容貌不差，懂得在上下班之余更进一步探索生命的意义，这都是很优美的事情，为何觉得自己卑微呢？你觉得卑微是因为没有用自己的主观眼光观看自己，而用了社会一般的功利主义的眼光，这是十分遗憾的。   一个不欣赏自己的人，是难以快乐的。   当然，由你的来信中，很容易想见你部分的心情，你表达的能力并不弱，由你的文字中，明明白白可以看见一个都市单身女子对于生命的无可奈何与悲哀，这种无可奈何，并不浮浅，是值得看重的。   很实际的来说，不谈空幻的方法，如果我住在你所谓的“斗室”里，如果是我，第一件会做的事情，就是布置我的房间。我会将房间粉刷成明朗的白色，给自己在窗上做上一幅美丽的窗帘，我在床头放一个普通的小收音机，在墙角做一个书架，给灯泡换一个温暖而温馨的灯罩，然后，我要去花市，仔细的挑几盆看了悦目的盆景，放在我的窗口。如果仍有余钱，我会去买几张名画的复制品——海报似的那种，将它挂在墙上……这么弄一下，以我的估价，是不会超过四千台币的，当然除了那架收音机之外，一切自己动手做，就省去了工匠费用，而且生活会有趣得多。   房间布置得美丽，是享受生命改变心情的第一步，在我来说，它不再是斗室了。然后，当我发薪水的时候——如果我是你，我要给自己用极少的钱，去买一件美丽又实用的衣服。如果我觉得心情不够开朗，我很可能去一家美发店，花一百台币修剪一下终年不变的发型，换一个样子，给自己耳目一新的快乐。我会在又发薪水的下一个月，为自己挑几样淡色的化妆品，或者再买一双新鞋。当然，薪水仍然是每个月会领的，下班后也有四五小时的空闲，那时候，我可能去青年会报名学学语文、插花或者其他感兴趣的课程，不要有压力的每周夜间上两次课，是改换环境又充实自己的另一个方式。   你看，如果我是你，我慢慢的在变了。   我去上上课，也许可能交到一些朋友，我的小房间既然那么美丽，那么也许偶尔可以请朋友来坐坐，谈谈各自的生活和梦想。   慢慢的，我不再那么自卑了，我勇于接触善良而有品德的人群（这种人在社会上仍有许多许多），我会发觉，原来大家都很平凡——可是优美，正如自己一样。我更会发觉，原来一个美丽的生活，并不需要太多的金钱便可以达到。我也不再计较异性对我感不感兴趣，因为我自己的生活一点一点的丰富起来，自得其乐都来不及，还想那么多吗？   如果我是你，我会不再等三毛出新书，我自己写札记，写给自己欣赏，我慢慢的会发觉，我自己写的东西也有风格和趣味，我真是一个可爱的女人。   不快乐的女孩子，请你要行动呀！不要依赖他人给你快乐。你先去将房间布置起来，勉强自己去做，会发觉事情没有你想象的那么难，而且，兴趣是可以寻求的，东试试西试试，只要心中认定喜欢的，便去培养它，成为下班之后的消遣。   可是，我仍觉得，<strong>在这个世界上，最深的快乐，是帮助他人，而不只是在自我的世界里享受</strong>——当然，享受自我的生命也是很重要的。你先将自己假想为他人，帮助自己建立起信心，下决心改变一下目前的生活方式，把自己弄得活泼起来，不要任凭生命再做赔本的流逝和伤感，起码你得试一下，尽力的去试一下，好不好？   享受生命的方法很多很多，问题是你一定要有行动，空想是不行的。下次给我写信的时候，署名快乐的女孩，将那个“不”字删掉了好吗？　 你的朋友三毛上</p></blockquote><p>这篇回信给我最深印象的，就是<strong>在这个世界上，最深的快乐，是帮助他人，而不只是在自我的世界里享受</strong>。实话实说，我并没有那么高尚的境界，甚至以前很少想到这一层。不过非常幸运的是：关于寻求自由与享受生命，我与三毛达成了一致。有了思想的指导，方法自然不会成为障碍，信中提到的做法会带来改变。 好久前看过李健的一个访谈，他说在任何时代，自我价值的实现都是很重要的，过好自己的生活，成为生活的艺术家是最难的事情，但他一直在尝试。经常性地关注村上等人的生活状态，极度追求个人自由与价值的实现，但是忽视了the big picture。当然村上自从《地下》以后，改变了很多。 这些对我个人价值观的塑造都有很大的影响（大概就是读书的好处吧），所以我一度认为生命没有意义，你做的一切，或者说人类做的一切，都没有意义。那么为什么还要去做事呢？是因为总得有事情去填充我们的时间。做好当下的事或者虚度时光，结果是迥然不同的，将来回忆起来很多事没有体验，岂不肠子都悔青了？ 真理总是很早就学过，却很晚才明白：</p><blockquote><p>人最宝贵的是生命，生命对于每个人只有一次，这仅有的一次应当怎样度过？ 每当回忆往事的时候，不因虚度年华而悔恨，不因碌碌无为而羞耻。</p></blockquote><p>前面说过，这是一道有着无数种解法的题目。每个个体想做的事很多，不过共同之处在于：do it，千万不要因为畏惧而放弃、拖延，当下只有一次，永不会再来。在认真体验、洒脱生活、享受酸甜苦辣的同时，记得帮助别人。 戏剧之处在于：如果读者只看过《撒哈拉的故事》，没人会接受三毛最终的选择。物质生活那样贫瘠的非洲，再加上常年患病的身体，都没有击垮她。相反，她将平凡的日子过得如诗一般，幸福早已溢出了文字，哪怕结婚用香菜代替鲜花她也津津乐道。就是这样一个善良自由、追求自我实现的人，荷西的死却成为她生命中无可挽回的拐点，也许浪漫的人很难有好的生活。再去看《梦里花落知多少》，你可能无法相信这出自同一个作家之手。 痛失挚爱，无异于晴天霹雳，但我想大多数人都会渐渐走出这份悲伤，只是时间长短不同罢了。感性的人很难自拔，会沉醉过去，也会幻想梦境：</p><blockquote><p>记得当时年纪小 你爱谈天 我爱笑 有一回并肩坐在桃树下 风在林梢鸟儿在叫 我们不知怎样睡着了 梦里花落知多少</p></blockquote><p>那种语调，并不是刻意地悲痛，好似一切都变淡了，当然也包括生死，三毛不断提醒自己要有责任心，还要照顾父母，如此目的很难维持得下去。 我们慨叹命运弄人，每一丝幸福，都可能是若干年后的一场悲剧，因为开始就会有结束。而且快乐往往是短暂的，就像它的字面意思一样，平淡和普通才是人生的主旋律。</p><hr /><ul class="task-list"><li><input type="checkbox" disabled="" />不知怎么搞的，可能读书越来越少、手机越玩越多的缘故，也可能书单过于单一，总是看些小说滥竽充数，写一些人文类blog总是力不从心：不论是行文思路，还是写作手法，直到最后的自我表达都十分混乱，而且遣词造句多有贫瘠累赘之感，甚至还不如小时候来得自然和丰富。别无他法，只有大量阅读思考才可能改观，希望每天都能静下来读会书吧，先看看中国现代文学@-@</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Garbage Collection</title>
      <link href="/2020/07/10/Garbage%20Collection/"/>
      <url>/2020/07/10/Garbage%20Collection/</url>
      
        <content type="html"><![CDATA[<p>垃圾回收：为了防止内存泄漏，对<strong>堆</strong>中死亡的对象进行清除，并回收相应空间的机制。 某些有GC机制的语言(Java, Python...)，平时不会特别在意内存的分配和释放。但是对于C/C++等语言来说，稍有不慎就会造成Memory Leak/Double Frees/Use-after-frees等问题。 ## Garbage 垃圾顾名思义就是以后不再使用的对象。但是要确定一个对象是垃圾通常很难，所以我们认为不可达（没有被引用）对象就是垃圾，但是需要明确的是：许多可达对象也不再会使用，也是垃圾，但是这种垃圾我们无法回收，所以即使拥有GC机制的语言也很容易造成内存泄漏。</p><h2 id="reference-counting">Reference Counting</h2><p>C++的<code>shared_ptr</code>主要采用引用计数法，实现简单： 每个对象都与一个引用计数器<code>cnt</code>相关联，每当有一个引用指向该对象，<code>++cnt</code>；一个引用失效时，<code>--cnt</code>。当<code>cnt==0</code>时：Remove all outgoing references from that object，并且清理该对象。</p><p>由于每个<code>cnt</code>记录的是引用数，而不是可达的引用数，只关注自己的对象而没有全局的信息，<strong>循环引用</strong>的情况就无法被回收： <img src="https://img-blog.csdnimg.cn/20200705104719124.png" alt="在这里插入图片描述" /></p><h2 id="mark-sweep">Mark-Sweep</h2><p>Lua/Ruby等主要采用Mark-Sweep算法： 有一些位置是明确知道可达的：全局变量、栈中的变量以及寄存器中的变量等，这些区域作为root set，从root set出发可达的对象视为存活对象，不可达对象视为待回收对象。 - mark阶段目标是找到可达对象。 -- 将root set中的对象放入worklist； -- 当worklist不空： 从worklist中移除一个对象； 如果该对象没有标记，标记它并且把从它出发的所有可达对象加入worklist。 - sweep阶段目标是回收死亡对象。 -- 对于<strong>所有已经分配的对象</strong>： 如果未标记，释放； 如果已经标记，为了下一次的GC，unmark。</p><p>有时候确实很难想象如此简洁的设计竟然是Lua 5.0之前采用的机制，不过工程上一条重要的原则就是：<strong>先完成、再完善</strong>。这个比较简单的GC实现过程可以参考<a href="http://it.deepinmind.com/gc/2014/03/26/babys-first-garbage-collector.html">自己动手写GC</a>。 这种Naive的方式虽然简洁，但是却有很大的缺点：即mark和sweep阶段必须一口气执行完毕，不能分步骤进行，结果就是在进行GC时其他线程都必须挂起，也就是通常说的Stop The World。 原因在于：假如在mark完成后，新创建了若干对象，这些对象显然没有被标记，在本次的sweep阶段就会被清除，造成无法挽回的后果。</p><p>为了改进上述算法的时间和空间性能，Baker's algorithm应运而生： 每个分配的内存块只能属于四种状态之一：Marked(可达)/Enqueued(in the worklist)/Unknown(未处理)/Deallocated(已释放)，维护4个双向链表保存4个状态的对象。</p><ul><li>将root set中的所有对象移入enqueued链表；</li><li>当enqueued链表不空： -- 将enqueued链表的对象移入marked链表； -- 对于unknown链表中的被引用对象，移入enqueued链表。</li><li>合并unknown链表和Deallocated链表并释放，耗时<span class="math inline">\(O(1)\)</span>；</li><li>将marked链表中的所有对象移入unknown链表，耗时<span class="math inline">\(O(1)\)</span>。</li></ul><p>这样时间复杂度优化为runs in time proportional to the number of reachable objects.</p><h2 id="generational-gc">Generational GC</h2><p>分代收集的核心思想是将内存划分为若干代，每次新的对象总是被分在新生代，新生代没有空间时，做一次迅速的GC，之后将新生代中剩余的对象移入next generation，实在没有空间可用时，对整个内存进行一次GC。 Java的GC就是基于这种算法，新生代分为Eden和Survivor： <img src="https://img-blog.csdnimg.cn/20200705145530733.png" alt="在这里插入图片描述" /> 开始的分配都在eden中，满了之后做一次GC，将留下的对象移入survivor浅色区，具体过程可以参考文献中的200页。</p><h2 id="具体应用">具体应用</h2><ol type="1"><li>Python的GC主要结合了引用计数和分代回收2种策略，当对象的引用计数为0时立即回收该对象，如果出现循环引用，则等待分代回收算法清理该对象。</li></ol><h2 id="reference">Reference</h2><p><a href="http://web.stanford.edu/class/archive/cs/cs143/cs143.1128/lectures/18/Slides18.pdf">Garbage Collection</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>The Annotated STL Sources</title>
      <link href="/2020/07/03/The%20Annotated%20STL%20Sources/"/>
      <url>/2020/07/03/The%20Annotated%20STL%20Sources/</url>
      
        <content type="html"><![CDATA[<h2 id="intro">Intro</h2><p>《STL源码剖析》用来了解原理性的设计没什么问题，但是这本书实在太老，所有源码基于GNU2.9；现在语言的发展飞快，而且很多地方都是考虑兼容性等因素，设计非常复杂，也并不高效，我没有时间去搞明白所有实现，更没有时间实现标准库，所以只学了一小半就停了。 ## 六大组件 容器、算法、分配器、迭代器、适配器、仿函数。 <img src="https://img-blog.csdnimg.cn/20200423140448163.png" alt="在这里插入图片描述" /> ## Allocator 分配器用来为容器分配内存，分配器是class，有成员函数<code>allocate</code> <code>deallocate</code>，调用<code>operator new()</code>会调用<code>malloc</code>，<code>operator delete()</code>调用<code>free</code>。 不同编译器的分配器实现稍有区别，不建议直接使用allocators，<code>int* p = allocator&lt;int&gt;().allocate(512)</code> 会创建临时对象，归还还要指定大小：<code>allocator&lt;int&gt;().deallocate(p, 512)</code>。 但<code>malloc</code>归还时不需要指定大小，因为<code>malloc</code>时候会有<strong>cookie</strong>保存分配的内存块大小，如果每次申请内存都包含cookie的话，开销太大，并且频繁申请内存十分耗时。 GNU2.9觉得allocators太傻逼，自己用的是alloc的分配器，有16个单链表，每个链表负责某个特定大小的内存块分配，比如8B（该链表串了很多8B的小内存块），16B，...，容器需要内存会被调整到8的倍数，去相应的链表找，如果链表没有小块内存，就会调用<code>malloc</code>向OS申请一块大的，切成很多小的，串起来去分配，这样<code>malloc</code>次数会变小很多，而且cookie会少很多，时间和空间开销都会变小，碎片也少了。 GNU4.9没有使用alloc，使用<code>std::allocator</code>，allocator继承了new_allocator，有成员函数<code>allocate</code> <code>deallocate</code>，调用<code>operator new()</code>会调用<code>malloc</code>，<code>operator delete()</code>调用<code>free</code>，一夜回到解放前。。。 4.9有很多扩展的分配器，2.9里的alloc变为了_pool_alloc，要改变默认的分配器，可以写<code>vector&lt;string, __gnu_cxx::_pool_alloc&lt;string&gt;&gt; vec</code>。 ## list 双向环状链表，end指向一个dummy node。 因为非连续，所以<code>++iterator</code>要重新设计，使得指向下一个元素，而不是错误的地址。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">void_pointer prev; <span class="comment">// 4.9 struct __list_node* prev</span></span><br><span class="line">void_pointer next; <span class="comment">// 4.9 struct __list_node* next</span></span><br><span class="line">T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line"><span class="comment">// 5种associated types</span></span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line"><span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> Ptr pointer; <span class="comment">// 4.9 typedef T* pointer</span></span><br><span class="line"><span class="keyword">typedef</span> Ref reference; <span class="comment">// 4.9 typedef T&amp; reference</span></span><br><span class="line"><span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">link_type node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操作符重载 */</span></span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="comment">// 前置++</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">node = (link_type)((*node).next); <span class="comment">// 指向下一个结点</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后置++</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">self tmp = *<span class="keyword">this</span>; <span class="comment">// 记录原值，拷贝构造</span></span><br><span class="line">++* <span class="keyword">this</span>; <span class="comment">// 操作</span></span><br><span class="line"><span class="keyword">return</span> tmp; <span class="comment">// 返回原值</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line"><span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt; iterator;</span><br><span class="line"><span class="comment">// typedef __List_iterator&lt;_Tp&gt; iterator; 4.9模板参数只有一个</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">link_type node;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ## vector 1.5/2倍增长。 迭代器只是一个指针，而不是class iterator，通过萃取机（Iterator Traits）中对类型的偏特化处理，可以回答算法提出的问题（iterator_category,value_type,difference_type,pointer,reference） <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line"><span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line"><span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>)); <span class="comment">// 建立一个元素，并以最后一个元素作为初值</span></span><br><span class="line">++finish;</span><br><span class="line">T x_copy = x;</span><br><span class="line"><span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">*position = x_copy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">iterator new_start = data_alloctor::<span class="built_in">allocate</span>(len);</span><br><span class="line">iterator new_finish = new_start;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 将原vector内容拷贝到新vector</span></span><br><span class="line">new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line"><span class="built_in">construct</span>(new_finish, x); <span class="comment">// 新元素设为x</span></span><br><span class="line">++new_finish;</span><br><span class="line"><span class="comment">// 拷贝插入点后的元素，可能被insert调用</span></span><br><span class="line">new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line"><span class="comment">// commit or rollback</span></span><br><span class="line"><span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>()); <span class="comment">// 析构释放原vector</span></span><br><span class="line"><span class="built_in">deallocate</span>();</span><br><span class="line"><span class="comment">// 调整迭代器指向新的vector</span></span><br><span class="line">start = new_start;</span><br><span class="line">finish = new_finish;</span><br><span class="line">end_of_storage = new_start + len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type* iterator; <span class="comment">// T*, just a pointer, not a class iterator</span></span><br><span class="line"><span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">iterator start;</span><br><span class="line">iterator finish;</span><br><span class="line">iterator end_of_storage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="built_in">begin</span>() + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line"><span class="built_in">construct</span>(finish, x);</span><br><span class="line">++finish;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ## deque <img src="https://img-blog.csdnimg.cn/20200424213635414.png" alt="在这里插入图片描述" /> The data is stored by chunks of fixed size vector, which are pointered by a <code>map</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line"><span class="keyword">typedef</span> Ref reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">T* cur;</span><br><span class="line">T* first;</span><br><span class="line">T* last;</span><br><span class="line">map_pointer node;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">difference_type index = pos - start;</span><br><span class="line">value_type x_copy = x;</span><br><span class="line"><span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">push_front</span>(<span class="built_in">front</span>());</span><br><span class="line">...</span><br><span class="line"><span class="built_in">copy</span>(front2, pos1, front1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">push_back</span>(<span class="built_in">back</span>());</span><br><span class="line">...</span><br><span class="line"><span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">&#125;</span><br><span class="line">*pos = x_copy;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line"><span class="comment">// BufSiz == 0表示使用默认值</span></span><br><span class="line"><span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt;</span><br><span class="line">class deque &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="comment">// BufSiz指每个buffer大小</span></span><br><span class="line"><span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">typedef</span> pointer* map_pointer; <span class="comment">// T**</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">iterator start;</span><br><span class="line">iterator finish;</span><br><span class="line">map_pointer map;</span><br><span class="line">size_type map_size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line"><span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">iterator tmp = finish;</span><br><span class="line">--tmp;</span><br><span class="line"><span class="keyword">return</span> *tmp;</span><br><span class="line">&#125;</span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line"><span class="built_in">push_front</span>(x);</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;</span><br><span class="line"><span class="built_in">push_back</span>(x);</span><br><span class="line">iterator tmp = finish;</span><br><span class="line">--tmp;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cycling Summary</title>
      <link href="/2020/07/01/Cycling%20Summary/"/>
      <url>/2020/07/01/Cycling%20Summary/</url>
      
        <content type="html"><![CDATA[<p>大学时候骑过几次，我算不上严格意义上的爱好者，所以每次也都只有几十公里。在车窗边看过无数次的景色，总觉得没有骑车看得仔细和真实。对过去的几次短程聊作记录，也希望未来有机会来一次长途骑行（先挖坑。。），领略下未曾相识的远方。</p><ul><li>2016年1月13日/XJTU兴庆~咸阳市渭滨公园/往返共计64km 大一上期末刚考完，和几个朋友一起。 最感动的就是冬天的早上，没有带手套，快冻哭了，太冷了，最后真的骑不动了。 <img src="https://img-blog.csdnimg.cn/20200701231747283.png" alt="在这里插入图片描述" /> emmm...没错，我就是拖后腿的那个。。。 中午吃饭真的超级香，毕竟饿了一早上，分分钟解决战斗。 湖边的环境还是蛮好的，干净整洁，休息了一个多小时，下午一两点飞速撤退，结果还是晚上八点多才回校。</li><li>2016年6月4日/XJTU兴庆~西安工业大学未央校区/往返共计31km 去找同学，那天感觉还好，不是特别累，可能距离比较短。 主要是去时艳阳高照，回来时风比较大，还伴有小雨。 <img src="https://img-blog.csdnimg.cn/20200701232424575.png" alt="在这里插入图片描述" /></li><li>2016年10月6日/XJTU兴庆~蓝田县史家寨乡/共计60km 国庆节回去看看我的学生们。 <img src="https://img-blog.csdnimg.cn/20200701232726598.png" alt="在这里插入图片描述" /> 去的时候比较顺利，可惜回来比较尴尬了。 回去时雨下得特别大，而且上坡路很多，比较耗费体力。 我记得有一个路口骑错了，又折了回来。 还有找到一个小的棚户避雨，当时心里其实有点小害怕，感觉路有点陌生（和去的时候不是一条），导航屏幕上全是水，心想着千万要回去啊，别把哥扔这个地方了，就冒着雨拼命骑，上坡真的巨累，衣服湿透了，但是回去却并没有感冒~~~</li><li>2018年4月4日/XJTU兴庆~家/共计40.2km 这次是最坑的。 下午1点40走的时候，微风轻抚着面庞，春天怡人的气息遍布空气。不过车子有点问题，修了之后感觉还是不太给力。 结果一上路，全是沙尘，而且我又是一路逆风，风超级大，就是下坡也要使劲去踩，否则车子不动啊！！！ <img src="https://img-blog.csdnimg.cn/20200701233048537.png" alt="在这里插入图片描述" /> 那天吃了一嘴的土，衣服也都是灰尘，蓬头垢面。中途还走到了一个死胡同，又做了无用功。路上偶遇三次洒水车，两次不幸被“洗澡”。 <img src="https://img-blog.csdnimg.cn/20200701233137365.png" alt="在这里插入图片描述" /> 最后小腿有点抽筋，碰到上坡还是下车推着走比较轻快。 <del>推啊推啊我的骄傲放纵，吹啊吹啊我的骄傲放纵……</del> 不过感觉突破了个人的那段极限之后，反而没有知觉了，就是一直骑啊骑。到达后大腿的酸痛感才会很刺激啊！ <img src="https://img-blog.csdnimg.cn/20200701233240785.png" alt="在这里插入图片描述" /></li><li>2019年4月27日/XJTU兴庆~创新港/共计65km 大早上起床后就一直在下雨，于是乎吃完一波久违的早饭后，回宿舍睡觉。 <img src="https://img-blog.csdnimg.cn/20200701233512406.png" alt="在这里插入图片描述" /> 直到12点，雨变小了才出发。路上全身都被淋透了，坑比队友的车总是掉链子，耽误了不少时间。 后来雨就停啦~ 唱了一路歌，玩了一路成语接龙，骑过很泥的地，扛着车越过小山包。 建筑很不错，骑行很酸爽： <img src="https://img-blog.csdnimg.cn/20200701233823919.png" alt="在这里插入图片描述" /></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Percolation</title>
      <link href="/2020/06/15/Percolation/"/>
      <url>/2020/06/15/Percolation/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>这是CS 61B的HW2，具体实现<a href="https://github.com/EIMadrigal/CS61B/tree/master/hw2">在这里</a>。这个项目是要模拟一个渗滤系统，最终目标是要通过蒙特卡洛方法计算出渗滤系统的阈值，主要会考察对并查集的使用而非实现。 渗滤有很多应用，比较重要的就是复合导电材料：刚开始是绝缘体，将金属作为导电材料逐渐掺入，填充到某临界值后，金属会形成一条导电网格组成的路径，完成从绝缘体到半导体、导体的转变，该临界值就是所谓的<strong>渗滤阈值</strong>。 模型是一个<span class="math inline">\(N*N\)</span>的网格图，每个格子有打开和关闭两种状态。如果一个格子是打开的，并且可以通过相邻的某些打开的格子连接到第一行的打开格子，那么该格子的状态就是full。如果最后一行有格子是full，那么系统就会发生渗滤。对于前面的例子，如果金属材料能形成一条从上到下的导电路径，那么就发生渗滤： <img src="https://img-blog.csdnimg.cn/2020061309400433.png" /> 我们感兴趣的是：如果<span class="math inline">\(N\)</span>足够大，每个格子独立，并且打开的概率是<span class="math inline">\(p\)</span>，那么会存在一个阈值<span class="math inline">\(p^*\)</span>，当<span class="math inline">\(p&lt;p^*\)</span>时，系统几乎不可能发生渗滤；当<span class="math inline">\(p&gt;p^*\)</span>时，系统几乎一定发生渗滤： <img src="https://img-blog.csdnimg.cn/20200613094728545.png" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/20200613094740884.png" alt="在这里插入图片描述" /> 我们的任务就是估算这个<span class="math inline">\(p^*\)</span>。 ## 渗滤系统建模 模型并不复杂，写一个类<code>Percolation.java</code>专门模拟该系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Percolation</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Percolation</span><span class="params">(<span class="keyword">int</span> N)</span>  <span class="comment">// create N-by-N grid, with all sites initially blocked</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span>  <span class="comment">// open the site (row, col) if it is not open already</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span>  <span class="comment">// is the site (row, col) open?</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span>  <span class="comment">// is the site (row, col) full?</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfOpenSites</span><span class="params">()</span>  <span class="comment">// number of open sites</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">percolates</span><span class="params">()</span>  <span class="comment">// does the system percolate?</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>难点在于要满足规定的时间复杂度：除了构造函数是<span class="math inline">\(O(N^2)\)</span>，其余方法都必须是<span class="math inline">\(O(1)\)</span>。 如果采用常规方法判断是否渗滤，那么至少也要遍历最后一行看看有没有full的格子，这样时间<span class="math inline">\(O(N)\)</span>无法满足要求。 问题就在于第一行和最后一行的格子数太多，减慢了我们的判断效率。那么如果我们在最上面和最下面设置两个虚拟节点，事情就会变得OK： <img src="https://img-blog.csdnimg.cn/20200613110636913.png" alt="在这里插入图片描述" /> virtualTop负责连接第一行所有打开的结点，virtualBottom负责连接最后一行所有打开的结点，这样我们就把<span class="math inline">\(N\)</span>个点浓缩成了一个点：</p><ul><li>判断某点是否full时，只需要判断该点是否和virtualTop连接；</li><li>判断是否渗滤时，只要判断virtualTop和virtualBottom是否连接。</li></ul><p>这种解决方案看似很完美，但是有一个问题Backwash： <img src="https://img-blog.csdnimg.cn/20200613111558820.png" alt="在这里插入图片描述" /> 如果已经有一条从上到下的路，那么水流可以通过virtualBottom回流到最后一行已经打开的格子，而这些格子本不应该full。 这个问题的解决有点tricky，开始我是想通过周围格子的状态来判断是否full，即只有周围四个格子之一是full，当前格子才是full。但是如果要在<code>isFull()</code>里递归调用去判断周围格子，那么一定会爆栈；所以要判断周围格子只能通过是否和virtualTop连接，但是只要这个打开的格子在最后一行，就一定要和virtualBottom连接，如此一来只要有其他通路，那么该格子必然还是backwash，进而就会导致其它和该格子相连的也backwash。 举例来说：假如右边3个蓝色格子从上至下编号123，先打开3号，3号周围四个格子都没有和virtualTop连接，因此我们认为3号没有full，这没问题；但是接着打开2号，2号下面的格子（3号在最后一行且打开，必然和virtualBottom连接，即也和virtualTop连接）是和virtualTop连接的，因此我们判断2号是full，这显然错误。</p><p>没法用逻辑优化的时候，就应该转向用空间去优化。我们可以在开一个并查集，这个集合最多只包含virtualTop和地图中的所有格子，而将virtualBottom排除在外。判断full时，只要当前格子在新并查集中与virtualTop连接，那么必然full。</p><h2 id="monte-carlo-simulation">Monte Carlo Simulation</h2><p>为了估算阈值，需要做<span class="math inline">\(T\)</span>次独立重复实验：</p><ul><li>所有格子都设置为关闭；</li><li>随机选取一个关闭的格子，打开它，重复直至系统渗滤。 那么这次试验的<span class="math inline">\(p^*\)</span>就是打开格子数/总数。</li></ul><p>取<span class="math inline">\(T\)</span>次实验的平均值，可以得到更加精确的阈值；标准差<span class="math inline">\(\sigma\)</span>展示了结果的波动程度： <span class="math display">\[\mu = \frac{x_1 + x_2 + … + x_T}{T},\sigma^2 = \frac{(x_1 - \mu)^2 + (x_2 - \mu)^2 + … + (x_T - \mu)^2}{T-1}\]</span> 当<span class="math inline">\(T\)</span>足够大，<span class="math inline">\([\mu - \frac{1.96\sigma}{\sqrt{T}}, \mu + \frac{1.96\sigma}{\sqrt{T}}]\)</span>提供了95%的置信度。</p><p>这部分的实现很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PercolationStats</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PercolationStats</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> T, PercolationFactory pf)</span>  <span class="comment">// perform T independent experiments on an N-by-N grid</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">mean</span><span class="params">()</span>  <span class="comment">// sample mean of percolation threshold</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">stddev</span><span class="params">()</span>  <span class="comment">// sample standard deviation of percolation threshold</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceLow</span><span class="params">()</span>  <span class="comment">// low endpoint of 95% confidence interval</span></span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">confidenceHigh</span><span class="params">()</span>  <span class="comment">// high endpoint of 95% confidence interval</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>痛撞南墙才回头——高考五年记</title>
      <link href="/2020/06/07/%E7%97%9B%E6%92%9E%E5%8D%97%E5%A2%99%E6%89%8D%E5%9B%9E%E5%A4%B4%E2%80%94%E2%80%94%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E8%AE%B0/"/>
      <url>/2020/06/07/%E7%97%9B%E6%92%9E%E5%8D%97%E5%A2%99%E6%89%8D%E5%9B%9E%E5%A4%B4%E2%80%94%E2%80%94%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">0 前言</h2><p>距离2015年高考已经过去了整整5年，这段日子埋藏着太多不堪。尽管现如今我已经开始了全新的生活，但仍想把自己曾经的问题和思考展示出来，一来当作对过去的告别，二来也希望这些教训能给境遇类似的人一些启发。</p><p>这篇文章字字血泪、句句属实，我不想熬制鸡汤或者贩卖焦虑。文中的一些想法都是通过亲身经历、思考、与前辈同学交流得到的，可能不太成熟，欢迎大家批评指正。</p><hr />认真去划决定命运的小船，却不知道未来会漂向哪里。<p align="right">——题记</p><h2 id="高中故事">1 高中故事</h2><p>文章题目虽然是高考五年记，但其实主题与高考并没有多大关系，而且上大学以后，我很少主动提起高考这档子事，只是为了故事完整，就从高中时代讲起。</p><p>高中三年是在一所县城高中，高考压力很小，学习也是波澜不惊。我并没有像传说中那么拼命学习，努力程度连初中都不如。相反，我的高中自在安逸，回想起来让人有些后怕。作为典型的“小县城学霸”，由于比较轻松就能考到前几名，所以我将大把大把的课余时间拿去运动，以至于已经主次不分。</p><p>做题总是很无聊，而我不知道是因为骄傲，还是因为懒散，遇到难题总是放弃思考、看看答案了事，看不懂就去睡觉，每天做些简单题（毫无必要）保持自信。事实上，我隐约知道外面有更大的世界，但却不知道那个世界是什么样子。那时我几乎没有可以追赶的目标（不像初中），这也许是高考失败的一个原因吧。自负、虚荣以及平日的偷懒终于在高三时酿成了苦果，那几次大型模考理综难度激增，跟平时训练完全不是一个套路。理综彻底被完爆的我后来再也没得过第一，化学甚至长期徘徊在及格边缘。看到这，你也许以为我会发奋努力上演逆袭神话，但现实永远是残酷的。实际上我并没有多少改变：该踢球踢球，该偷懒偷懒，甚至在四五月份时我都打算放弃物理，想着随便混几分算了。高考的目标也变得无所谓起来，反正那一直都是挂在墙上终将被戳破的泡沫罢了。到最后我干脆抱着爱考哪考哪的弃疗心态，只希望尽快毕业。</p><p>我之前对于“小县城学霸”这个词一直嗤之以鼻，即使高中物理老师曾经不止一次强调过我们只是一个县城中学。不过当时我觉得学霸就是学霸（现在显然我自己并不是），厉害的人到哪都那么厉害，哪有什么小县城不小县城。不过后来当这类人的思维方式深深影响我的时候，才发现原来老一辈人的说法未必都是错的，“不听老人言，吃亏在眼前”这句古语也并非空穴来风。</p><p>2015年的高考和往年一样平淡无奇，出分后我异常平静（要是没上600该多好，那我就坚持复读了）。我想学物流管理或者工商管理，前者是因为我喜欢看到井井有条的交通运输网，最终将东西错落有致地归位，后者则纯粹是因为高大上。不过很不幸，这些想法并没有得到亲戚父母的支持，他们说那些专业虚无缥缈，毕业后不好找工作。</p><p>信息的闭塞使得我（包括那些已经工作的亲朋）并不了解各个专业的细节以及未来可能的职业轨迹，我甚至搞不清电子信息与计算机之间的关系。<strong>18岁前的我们只知道读书，习以为常的主流价值观就是“努力学习，考高分，上好大学”，在这样主流价值观的裹挟下，很多人相信 “一分耕耘，一分收获”，彷佛只要足够拼命学习，一切都会迎刃而解。然而这种简单的线性的思维方式完全是对真实生活的一种片面归纳，强行被灌输的这些价值观念是否契合当代社会真实的发展轨迹，甚至是否正确，都有待商榷。也许当某一天我们突然发现自己的世界观无法解释见识到的种种现象时，才会在深夜里辗转反侧痛哭流涕的同时，试图去打破曾经的桎梏，而人生信条的崩塌和重塑无疑会是极具撕裂感的、漫长的过程。</strong></p><p>此时的我们对社会的认知极度匮乏，高中也完全没有相关的职业指导教育，盲目地填报志愿，这是当时很多人的通病，我也不例外。在西工大三航学院、厦大经济学和西安交大的来回纠结中，最后一天将交大的专业大致按照历年录取分的高低依次填进志愿表，这在现在看来是多么不可思议的一件事，而我，最后就是这么干的。就这样，稀里糊涂地来到了交大电子信息类。 ## 2 懵懂时光 到大学后，集体住宿搞得我很不适应，晚上总是很晚才睡着，早上起个大早去跑操，结果就是几乎所有早上的课我都一睡而过。那些课程我也着实提不起兴趣，考试总是随缘突击，结果就是期末挂了一门工程制图，那种空间想象能力我差到不可救药。我个人对新环境的适应一直都很慢，所以进入一个崭新的阶段，开始时总是做得十分差劲。</p><p>不过好在我并非一个一成不变的人，于是开始尝试去改变。由于迟迟找不到方向所在，试错的过程持续了将近两年半的时间。选修了一门职业规划的课程，想借此明确未来的打算，弥补这本该是很早前就完成的人生必修课，不过这门课与大学物理一样无趣；参加了数模比赛，虽然得了奖，但除了提升软件安装和论文写作技能以外，并没有什么新奇之处；参加了社团的支教，这是我当时唯一觉得价值非凡的事情，这段经历也对我后来的想法产生了重大影响，可是这并没有从本质上解决我的问题：<strong>我未来到底想干嘛</strong>？辅修了金融学，也不过帮助我提早排除了一个未来可能从事的行业而已；去奶茶店进行所谓的“创业”，半年后店铺出租，我“失业”了；甚至于无聊到搞了一个公众号，想看看自己有没有自媒体运营方面的喜好，最后也是无功而返。</p><p>说来倒也有些矛盾，除了少数大神一直都有明确的方向或者可以兼顾方方面面以外，我们大多普通人，大学里如果一直不停尝试各种方向去试图寻找兴趣，那必然会分散精力，成绩不够好带来的代价就是后期通过更多时间和精力去弥补。可是如果很少尝试，一条道走到黑，那后果也是可想而知。两种决定都会付出代价，只是时间早晚而已。</p><p>我想既然这些都无济于事，就先提高绩点吧。于是从大二下学期直到毕业，我都在认真学习。即使信号与系统、模电数电那些专业课依然没有学懂，但我发现考试与学没学懂关系并没有那么密切，我居然拿到了在大学的第一个100分。欣喜之余，我隐约觉得这里面有什么问题，但是也懒得思考。</p><p><strong>生活就是这么奇妙，收获的成果有时并不与你的付出成正比</strong>。很快我就发现即使我再努力学习，平均分最高也不过89，全系排名好的时候30多，差的时候50多，那时我才初步意识到<strong>人与人的差距有时候不是通过努力就可以弥补的</strong>。</p><p>成绩上不去，我就想试着去开发一下自己的科研禀赋。于是大三寒假我报了ML方向的一个组，不过我压根没有见过报名的那个教授本人，而是被直接分在了一个副教授手下，并进而被分给了他的一个博士。见不到leader本人我完全不觉得惊讶，毕竟IEEE Fellow怎么可能去带一个本科生？但令我不能理解的是我明明报的是ML，但平时的工作却完全是网络通信方向，又是讨厌的信号和从未搞懂的相位。看了一个寒假的论文，帮助他们测试实验数据，在组会上讲论文，尽管我还不知道自己想做什么，但却知道自己厌恶什么。随着时间推移，我愈发觉得自己正在南辕北辙，加之实验室不在一个校区，后来也就主动退出了，科研初探随即宣告失败。</p><p>到此为止，能想到的方式我都一一尝试，可是收效甚微。那段时间我时常在球场散步，一圈又一圈，脑子里就想着两个问题：<strong>我到底喜欢做什么？我未来到底要干嘛？</strong></p><p>人生总有想不明白的问题，苦苦思索不得其解，只能先搁置起来。事情在大三下学期出现了转机，我们系开放了两门CS的课：OS和微机原理，加上ACM大佬们的影响，我开始发现计算机课程的乐趣，那是我第一次认认真真、彻彻底底搞懂了一门课，甚至于我竟然乐意废寝忘食去完成课程的Project。正反馈也来得恰到好处，两门课我都拿到了90+的成绩，那时我隐约有了转CS的想法。顺便要纠正一下，很多人误以为通信转CS很容易，事实上除了三四门相同的专业课以外，通信与CS本科期间学习的东西就像是两条平行线，通信转CS和转金融没什么差别。可能是听到太多科班CS大佬的故事，我始终觉得自己与科班出身的差距无异于一条鸿沟，以至于敬畏到忘记自己该学些什么，尽管后来发现事实并非如此，<strong>人有时候总是自己吓唬自己</strong>。</p><p>说到这就难免谈到劝退的话题，生/化/环/材被黑的体无完肤，大家都要去金融/CS，有时候我也会想：作为所谓的名校学生，我们享受了比较优质的教育资源，然而却少有人愿意投身基础科学研究，这才是科技兴盛的基石，过去不久的华为中兴就是典型的正反例。也难怪有人戏谑“中国只有互联网，没有计算机科学”，我们的互联网公司都在模仿美帝，腾讯学习ICQ，百度学习Google，阿里学习eBay，可是我们却没有看到美帝不仅有这些应用层的公司，还有Intel，Apple，Qualcomm等一大批芯片硬件厂商作为基石，而我们的BAT又有谁做基石呢？一股脑转去高薪行业，这会不会有些太过自私了呢？曾经的理想主义色彩淡薄了许多，我是否也变成了所谓的“精致的利己主义者”，而忽略了对社会的那份责任？但转念又一想，如果一个社会逼得许多人转去金融/CS，那是不是这个社会本身出现了问题呢？遇到一些不顺心的事，千万不要想不开，很多时候不是你的问题，而是整个社会的运行机制出现了偏差。</p><p>由此也可以看出：<strong>世俗意义上的成功更重要的决定因素是历史的进程，选择远远比努力重要得多，而信息和自我定位则会很大程度上左右你的选择。某些情况下努力可能只占1分，而成长环境、家境状况、历史进程、个人选择、贵人相助甚至运气则可能占9分，甚至99分。</strong> ## 3 曲折岁月 时间飞逝，一转眼三年已如白驹过隙。大一的成绩太差，总成绩大概只落在了全系40多名，掐指一算就知道在保研边缘，如果出国的大佬比较多，我也许会有机会。所以我不敢怠慢，两手准备，保研自然最好，若是失败也不能耽误考研。</p><p>大概是8月份回校的，那阵就看数学，没什么状态，大概心里还是侥幸着能够保送，也不知道专业课该看计算机还是通信的。9月大家人心惶惶，有出国考T考G的，有各种保外保内的，还有穿着西装到处参加面试的，大家也都比较焦虑，放弃考研的也大有人在。浑浑噩噩就到了9月中旬，保研名额给到了第42名，而我是第45名。颇具戏剧性的是，之前坊间传言会有20多个专硕名额，搞得人心惶惶，我还幻想着保专硕算了，后来也不了了之。</p><p>这下本以为彻底死心，考虑到自己当时备考效率极低，根本看不进去书，加上周围的同学纷纷拿到了offer，我下定决心找工作。于是就完善简历，练练编程的题目，投了华为、中兴、网易等几个公司的研发岗，差不多耗了一个礼拜，也收到了陆陆续续的笔面试通知。没想到生活总是会有<del>意外的惊喜</del> ，系里通知有一个国防科大的普通生定向保送名额，在我前面的2个人都放弃了，再加上军校的缘故，我竟然没怎么思考就选择了放弃，这该是第一波坑操作。</p><p>后来不知怎么滴，也许是和老师朋友聊了很多，也许觉得自己还是太菜，莫名其妙又想读研了，稀里糊涂就推掉了所有的面试，一是不够自信，二来不想分心。又把书重新拿了起来，滚去复习。奇怪的是：这次竟然可以静下心来，仔仔细细做题了。这该死的第二波坑操作，事实证明：<strong>秋招远比春招重要并且容易得多</strong>，这一点我会在后面解释。</p><p>时间来到了9月底，这下终于可以安心复习了。出于对通信专业课的阴影，我还是选了CS，还有是因为大三时几门计算机的课学的还不错，倒也饶有兴趣。</p><p>那，选哪个学校好呢？我心想，既然要考研了，本科比不过他们，研究生的学校可不能输给他们。殊不知这就是典型的“高中生心态”，<strong>没有根据自己的定位和当前的规划去做出恰当的选择，而是冲着高大上的标签去做决定，这样的决定显然是冲动并且幼稚的</strong>。清北太难了，比XJTU好的就ZJU、SJTU、FDU、NJU，最想去的是SJTU，查了之后才知道2018年SJTU CS就招了两个学硕、10几个专硕，我想难度太大了，遂杀掉（题外，2019SJTU CS难度蛮低的）。之后查了这几所之后，发现NJU分数又低、招人又多，就开始复习NJU的专业课。</p><p>专业课一共有5门，很难，每天看的头昏眼花。屋漏偏逢连夜雨，10月招生简章出来后，NJU的名额还是和往年一样多，结果过了差不多一个礼拜，官网突然把名额杀了一半，剩20几个了。我想，这也变难了，再加上群里大家信誓旦旦的样子，和朋友商量后，我在来回纠结和迷之自信中又换了学校（题外，我的分去年上NJU没啥问题）。就剩ZJU和FDU了，FDU虽然好考，但专硕却不提供住宿，还恰是从这一年开始，ZJU就这样成了唯一的选择。结果表明，复习时间真的太过紧张，尤其是专业课。408的难度相信都有所耳闻，时而做对，时而连着错很多，心情也像过山车似的起起伏伏，无数次都有撕掉卷子的冲动。我只能死马当作活马医，其实直到最后，我甚至连习题集都没有做完，很多知识点也是一知半解。这该死的第三波骚操作。</p><p>当时和几个出国狗一起自习，看过他们托福考出来的欣喜，也见过GRE 310的落寞，当然还有那一起吃饭时互吐的苦水。我说考完的日子就舒服了，说我已经列好了长长的TODO List。他们说，其实你有没有想过，这本身就是人生啊！</p><p>12月的日子很难熬，临近考试，觉得自己不是在查漏补缺，而是在女娲补天。心情总是飘忽不定，仿若过山车一般，题目全对了会喜上眉梢，英语阅读5错4时又觉人生无望，揉过的专业课卷子冷静下来还是只能乖乖去看。</p><p>说来我算是一个乐观主义者，或许是<strong>人总是愿意相信对自己有利的事情</strong>。寒假可能有一丝落榜的焦虑，但大部分时间我还是在准备机试，每天都在做算法题（题外，这大概是唯一正确的事了，春招用上了）。 ## 4 折戟沉沙 出成绩后就得知没有过线，我顿觉失望与惶恐。稍一比较，才发现别人的生活多姿多彩，自己反而是一直学习却连考试都考不好的傻逼。当天的我十分慌张，立刻去查找调剂信息。得知中科大软院收校外调剂，心情才稍稍舒缓了些。虽然学费贵点，但去中科大读个硕士还是不错的。</p><p>看着94分的专业课，我一时语塞。有些不甘心的我一遍又一遍回忆着这大半年发生的事情: 本科通信、三跨浙大、备考也算不上充分，落榜也实属正常。我一直尝试重新认识自己，可现在愈发地不认识，像是一个完完全全的陌生人。刚开学后的那两天我处于弃疗状态，觉得什么都无所谓了，爱咋咋滴吧，调去差点的也行，随便找份工作也行。</p><p>冷静了几天，又觉得这些挫折并非坏事，现在受挫总比将来走向社会好。况且成年人应当为自己的错误付出代价，不论是选择出了问题，还是不够努力。挫折对于我而言绝对谈不上财富，只是希望让我这个转变缓慢的人长点教训。我不是一个一蹶不振的人，也不是度量狭小，只是受了打击，犯了错，总得学点什么，不是吗？积极的心态很重要，凡事总要向前看，过去的就过去吧。工作要好好找，调剂也要努力争取，解决好当下，求一份心安。</p><p>鸡蛋不能放在同一个篮子里，我又迅速确定了其它几个调剂的学校，排除了调剂本校和浙大相关专业的可能。后来也在老师和同学的推荐下了解了一些研究所，但大多是军工性质，我并不想去。很无聊的名校情节以及差强人意的总分使我把比本科差的学校都直接排除，最后就确定了3个：科软、山东大学、中科院成都所。</p><p>我想着这3个再差也能去一个吧，但是<strong>现实远比想象的更加要命</strong>。直到3月10几号才知道科软从今年开始不收校外生；接着是山大，学硕调剂有3个名额，专硕有11个，我想着报个人多的，却不知再次选择出错：专硕的分数高的吓人，没有拿到复试资格，而学硕反而分数低的多。拖了最长时间的就是中科院，预调剂很早就填了，我甚至都填完了政审表，傻傻地把这个当成最后的救命稻草，直到3月底没看到名单，我还是相信会来的，这大概因为我实在想要这个硕士吧。到了4月10日，我对比了去年的招生人数和今年一志愿人数，发现可能不会再有调剂了（之前发邮件问了但没有回信）。</p><p>期间也不敢落下春招，当时想得太简单：不能既没学上，又没工作。一口气投了十几份简历，所幸除了冲突和放弃的之外，都拿到了笔面试通知。因为我是半路CS，再加上春招已经没有大公司的职位，所以也投了一些非技术岗。</p><p>说个题外话，找工作一定要在秋招，因为春招只是秋招的补录，名额少、难度大。拿我作为反例，春招想要投递大公司（BAT），都已经没了HC，错过这一次你就再也不是应届生了，自然也就没了校招的待遇。我后来才了解到：阿里巴巴光是实习生转正和提前批就已经占掉了绝大部分HC，甚至于秋招都已经没什么机会了。</p><p>那段时间我几乎没怎么休息，也没心思去休息，只希望3月底可以确定去处，未来的不确定对人真是煎熬。认真去准备的有五家：TP、OPPO、浦发总行、华为和字节跳动。前三家都给了offer，华为没有了消息，字节跳动则是笔试挂掉了。后来突然发现自己跪在了哪里，华为这种公司，或者说几乎所有公司，都需要你来好好干活。但我的致命错误就在于太老实，而没有学会伪装。我甚至在主管面说自己还是想继续深造，如此愚蠢的错误我接连犯了很多次，这是学会的第一课。</p><p>我其实很讨厌面试时看重忠心的公司，现代企业本来就该是我付出劳动力、你付给我报酬，我当然会把份内的事做好，你也不要占用我其他时间。情怀不能当饭吃，这种忽悠我觉得非常小儿科，甚至不是现代企业所需要的管理方式。</p><p>找工作的心态一直在“卧槽，我还挺牛B的”/“唉，我真傻B”之间来回切换：某司HR主动打电话问我要不要去；那么简单的题目竟然不会做；某司竟然直接免掉了高管面；我怎么问了那么傻X的问题……唯一的共同点在于N轮面试真的会把人榨干。</p><p>后来拒了TP，其实OPPO也没签，一直在等菊厂的结果，直到打听到别人已经拿到了offer，才确认自己凉了。这时OPPO已经快要截止，唯一庆幸的就是自己联系了一起去面试的同学，这才没有傻等下去。虽然我知道不能以偏概全，但OPPO的HR在招聘过程中展现出来的专业素养比某为不知道高到哪里去了，“店大欺客”的道理是明摆着的。</p><p>一步一步把一手好牌打成了今天这个样子，我终于体会到其实<strong>人生的道路是由很多因素共同决定的，并且很多机会都是转瞬即逝</strong>。另外，自己也就是中人之资、半吊子水平而已。</p><p>尽管如此，起初拿到offer后，看着协议上的薪资，我有些兴奋：虽然package不大，但就我了解的情况，也算是比较好的待遇了。我庆幸自己搭上了CS的末班车，还被邀请给下一届分享找工作的经验，甚至开始早早谋划起在另一个城市的生活...... ## 5 痛定思痛 草草签约以后，我总觉得哪里不对劲，却说不上来。<strong>我发现自己比之前进步一点的是遇到不明白的问题，会去思考、去交流、去尝试得到一个答案，尽管这个答案不甚完美，甚至在上帝视角下都不一定正确，但这也比敷衍了事强上一万倍。</strong></p><p>考研失败就像压垮骆驼的最后一根稻草，让我开始跳出虚荣的怪圈，真正重新认识、评估自己。是不是一切从开始就错了呢？为什么在给予别人建议时头头是道，到了自己就非得撞得头破血流呢？万千世界，大家虽然所处位置不同，但每个人都在寻找自己的局部最优，而且结果好像都不错。唯独我，好像学习率太大，损失函数竟有些发散，距离最优点也越来越远。<strong>那种疼痛感，就像从崖边跌落，远比在平地上摔倒更令人刻骨铭心。</strong></p><p>我像过电影般一遍遍回忆这几年的事情，也时常和各种背景的人聊天（徐老师的<a href="https://www.cnblogs.com/EIMadrigal/p/11973810.html">文章</a>给了我很大启发，我也和徐老师交流过，人很nice）。我逐渐开始发现自己的问题：周围都是IT的同学，大多都想着高薪买房，目前看来的确不错，但或许正是在这种<strong>单线程思维</strong>的浸染以及<strong>同质化的比较</strong>下，我也在不知不觉中迷失了自我，这种象牙塔带来的禁锢总有一天要被打破。更加本质的原因在于我自己<strong>本身没有一个清晰的定位并且没有明确的职业规划，哪怕只是五年、十年的规划</strong>。兜兜转转又回到了那个熟悉而又陌生的问题：我未来到底想做什么？媒体软文总是告诉我们要不忘初心、坚持梦想，却从来不告诉我们怎样寻找初心？怎样选择梦想？</p><p>与在国内互联网公司实习的同学交流后，我看到了高薪背后的挣扎：长时间的加班使得很多人到一定年龄后只能主动退出。以前我从来没有想明白：为什么某为每年从各大高校招聘那么多人，企业利润总是有限的，招那么多人怎么能消化呢？某为又不像国企，政府有命令必须帮助国家解决就业，国家养活完全可以理解。后来当我某一天突然看到了某为的离职率，才明白其实不过是数量巨大的新人换旧人而已。很多年轻人几乎没有自己的生活，疲惫而又无奈。这才是普通大众的真实情况，我们不该只看到某某大佬创业成功去纳斯达克敲钟，某某大佬又融到了C轮，这种“<strong>幸存者偏差</strong>”掩盖了“<strong>一将功成万骨枯</strong>”的现实，也让我重新审视自己：你愿意一直从事这样的职业吗？显然，答案是否定的，因为我始终觉得工作不该成为生活的主旋律，还有很多更有意义的事情等着我去完成。</p><p>顺便插一句：如果你不确定自己要干嘛，<strong>趁早去实习</strong>，接触真实的工作环境远比在象牙塔里意淫要实在得多，提早打破学校里单一价值评价体系带来的桎梏。此外，实习的好处也自不必多说，牛逼公司的实习永远都是简历上最耀眼的闪光点，甚至于在互联网，实习经历大于其它GPA、获奖、社团所带来的价值之和。</p><p>被碾压的感觉与证明自己的情绪混在一起，使得我对自己没有明确的定位。而选择上的失误更多的不是来自于信息的匮乏，而是选择的依据出现了问题：<strong>没有基于未来的职业规划来做出决定，反倒是冲着高大上的标签或者亲朋好友的期待，这样的选择能有多少理智的成分呢</strong>？扪心自问，之前那一连串的操作都是基于一个错误而又功利的方向进行，真正想要的和你实际做的完全是两码事，两者间的夹角至少也有80度，甚至可能是钝角，量出这个角度我花了整整一年，而有的人则花了五年、十年甚至一辈子，这样无头苍蝇乱撞般的努力毫无意义，甚至可能起到反作用。</p><p>是的，之前的选择出了很大的问题，现在的锅确实也得背着。可是这并不是彻底击倒我的理由，换句话说，我应该去纠正之前的错误，而不是一蹶不振。之前说过：选择比努力重要，但<strong>通过交流、经历、思考不断纠正方向的能力则比选择还要重要</strong>，这样才会带来螺旋式的上升而不是断崖式下降。</p><p>明白了错误的主要原因和以后的职业规划后，再一次重新做出的选择看起来那么自然和水到渠成。再强调一遍：<strong>你对自己的定位评估会影响你的选择，而选择却远比努力更重要。你的定位应该取决于你对自己未来的规划，而不是那些高大上的标签或者亲戚朋友的看法，这会让你失去对自己的准确判断，德不配位，必然撞墙。</strong></p><p>不撞南墙不回头，这一年撞得头破血流，跟自己的无知、幼稚、局限斗争了一年。同样，也成长了一年，甚至比以往任何时候都成长地更快。有时候回过头去想，如果这一路很顺利的话，现在又会是怎样一番景象？如果当初选择了保送，如果选择了秋招工作，如果没有选择ZJU计算机，如果调剂到地球科学系，如果去工作了，如果……可惜没如果，所以从过去汲取教训后，最好向前看。盗用一句台词：</p><blockquote><p>You have got to put the past behind you before you can move on. ## 6 自食其果 放弃这个比较有诱惑力的工作而去赌一个未知的将来，要说没有压力肯定没人相信，但我当时的决定却相当清晰，即使违约的事情还没有谈妥，即使二战期间的食宿还没有着落。因为我在用未来的职业规划当作决策目标，不再过多考虑暂时的收益，因此决定不再是冲动的。我一直以为自己是悲惨的，大四的最后才确定初步的生涯规划，但实际上我又是幸运的，因为还有一大批人甚至中年以前都没有明白。</p></blockquote><p>真的要感谢我有一对开明的父母，当我不停地自我怀疑和否定之前的观点与行为，他们总会给予无限的鼓励与支持。</p><p>度过了煽情的毕业季，处理完违约的事情，考完驾照后，我便开始逐渐矫正自己的生活，为过去的错误买单。又是8月回校，心境却大有不同，坚定目标后，事情也不是一帆风顺。记得李健有一句歌词：等待和耕耘，谁更辛苦？我的答案是等待，那段时间我偶有焦虑，填补焦虑最好的方式就是找些事情做，可是闲下来之后，<strong>等待的日子却最是难熬</strong>。</p><p>每段崭新的日子一开始总是来不及悲伤。尽管我十分讨厌把相同的事情做两次以上，但或许是因为新鲜感，刚去的几周学习状态感觉还不错。逐渐理顺了生活之后，最难熬的一段日子在9月底10月初到来。接下来的几周我严重失眠：经常是晚上8/9点睡觉，躺床上思考很多事情，凌晨2/3点才入睡，然后就一直睡到大中午才起床，接着去吃饭学习，生物钟彻底陷入混乱。虽然我不止一次告诉自己：几个月很快就会过去，也明白路该怎么走，但是<strong>心病难医</strong>，还是会经常抱怨Why always me/Why always the wrong answer。我希望时光过得快一些，每天复习都数着日子。虽然看起来还算正常，但我有些担心会不会在哪一瞬间突然崩溃。我尝试了很多种方法试图让自己平静，回归正常的作息。</p><p>由于学校很傻逼的支付系统，扫码吃饭可供选择的窗口少得可怜，不过比物质上的单一更加要命的是心理上的波动。那段日子我真真切切感受到了人生的艰难：每天和活人说话不超过10句，我擅长独处，但还是一度怀疑自己能否忍受这样的孤独？能否坚持下去？接下来的日子又该如何度过？</p><p>幸好我有自己的日常爱好和排遣方式。除了正常的复习时间，我尝试用音乐、文学和足球去填补漫长的空闲：去看各种人物的访谈，从李健到村上春树；去听各种风格的音乐，从钢琴曲到摇滚乐，后来我惊讶地发现自己一年里竟然听了8000多首歌；去了解各种军事话题，从二战到伊拉克战争；去看各式各样的人生轨迹，从职业选择到人生理想。那段时间最开心的事情就是写博客、听音乐和刷评论，那就像是我自己的避风港。每隔一段时间我就会迷上一个大师：从Richard Clayderman到Beethoven, 从石进到周杰伦，从Joe Hisaishi到Maksim，从李健到Akina，甚至无聊到去扒一些<a href="https://www.cnblogs.com/EIMadrigal/p/11421473.html">抄袭的作品</a>、在足球APP上和人撕逼。</p><p align="center"></p><center class="half"><img src="https://img-blog.csdnimg.cn/2021050914403540.jpg" height="25%" width="25%"/>图片更新于2021.5.9</center><p>为了调整生物钟，我决定用早起对抗失眠，学了很多<a href="https://zhuanlan.zhihu.com/p/34952593">快速入睡</a>的技巧。深夜自我怀疑的时候，就去回想毕设导师对我能力的认可，她告诉我不能因为一次失误就这样自暴自弃，甚至在毕设答辩时，其他老师问我将来什么打算，我回答工作，老师仍然在表达惋惜。为了避免枯燥，我试图在每天晚上为第二天制定计划，并在完成小小的目标后奖励自己一顿美食（每隔一段时间都会去某个固定的小店吃饭）。后来不知是因为生活的惯性还是出于对第二人生的追求，我的效率渐渐提高，并养成了程序化的一天：早餐、学习、午饭、午休、学习、晚饭、学习、跑步、洗澡、沙雕视频（美食/老剧）、维护博客、睡觉。不可否认的是，尽管有时候仍然觉得自己像个可笑的小丑，但情况一直在好转。这种井井有条的生活给予了我长期的专注，使我得以脱离苦海。 <img src="https://img-blog.csdnimg.cn/20200528111916687.png" alt="在这里插入图片" /> 于是从10月下旬直到考前，我都变得异常平静。<strong>在那段低谷的日子里，收到了许多老师、前辈、同学以及食堂大叔的照顾和鼓励，也包括那些远在网络彼岸的未曾谋面的陌生人，在此一并感谢~</strong></p><p>我原本坚定地以为，高考考成那个鬼样子是因为没有认真去学，去复读一年肯定会有巨大的提高。不过经历了那几个月，现在我觉得结果真的未可知：心态、压力等等因素共同作用下导致的结果可能会谬之千里。</p><p>在这一年里，我听到过太多的诉苦：工作后的同学又想回来读研，而且固执地认为研究生的待遇好、升职快；还遇到了许多正在读研的学长学姐后悔自己没有早早去工作挣钱，积累社会经验。两种想法没有对错，还是那句老掉牙的话：因人而异。不置可否的是，<strong>人都是有损失厌恶的，比较必然带来不快，乃至伤害</strong>。以前我总是转不过这个弯来，或者更确切地说，潜意识里不想让自己转过这个弯。如果放眼整个社会，你会发现，<strong>人生从来就不是什么公平的游戏</strong>，别人比你少读几年书、多挣一些钱根本就是没什么大不了的事。有一大堆人压根不需要读书、打工挣钱，就可以家财万贯，你奋斗一辈子可能都无法到达别人的起点，难道我们就放弃生活了吗？大家都是普通人，甚至夸张一些，都是社会最底层的人，没有谁比谁高贵或卑微，为什么要比来比去互相伤害呢？</p><p>将读研作为缓冲的人无非两种情况：不知道自己要做啥；知道了要做什么但时间已经不足以得到理想的结果，别无选择。对我个人而言，如果去工作，可能以后选择的权利会少一些。三年的缓冲一是为了弥补之前犯下的错误，二是为了让自己将来有一些小小的选择权，不用一直996。基于职业规划的前提下，我想该怎么做也已经非常明确了。当然这只是我自己的情况，其他人，比如本科时已经积攒够了资本，那大可以直接工作；对于立志进入学术界的同学，那继续出国深造才是最好的选择，所以才说因人而异。</p><p>初试后我压根没有对答案，只是小小放松了一下，庆祝这段岁月的结束，也是迎接下一段更加艰难的旅程。终于松了口气，不为别的，只为有时间做自己的事情了，<strong>自由的感觉真好</strong>。</p><p>回家后，一边等待成绩，一边准备实习。找实习的过程并没有比这半年的生活轻松多少，本来打算3月份复试后立即找实习，拿到录取资格就可以算是在校生。结果人算不如天算，没想到疫情居然持续了这么久，2/3月的时候遥遥无期，也不知道什么时候复试，如果复试拖到4/5月，结束后就只剩6/7/8这3个月，很多公司都是至少实习3个月，这样找实习的时间几乎没有。所以从2月份开始，通过各位前辈和同学的内推，大大小小投了国内外几十家互联网企业：网易、字节、华为、深信服、微软、依图、百度、腾讯、小米、Amazon、IBM、Intel、广联达......起初我觉得非常奇怪，除了2家公司打电话了解情况后，其他的都杳无音讯，唯一的机会来自于网易，不过我的面试实在糟糕。后来特意查了一下，发现非在读生签实习协议违反劳动合同法。知道这事以后，我也就基本放弃，不再强求，如意算盘再一次落空。 ## 7 重新起跑 2月中旬看到初试成绩后，我觉得应该没什么问题，复试准备得很放松，把更多时间用来思考问题、夯实基础以及整理散落的片段。</p><p>复试虽然延期了2个月，但一切顺利。感谢我交的老师，面试时仍然在鼓励我，问的最多的就是去年的经历，告诉我不要以为没去ZJU就亏了，告诉我XJTU也不差，结束时说欢迎我来交大的确有些感动。在打趣的过程中，我能感觉到老师们那种不服气的精神，但同时我也明白品质和实力几无关系，就像托尔斯泰说的：<strong>只有伟大的作品，没有伟大的作家</strong>。我十分清醒，自己的水平目前确实很low，只有按照计划踏踏实实去做。</p><p>初试成绩公布后，我就联系了一堆老师，除了直接拒绝的，剩下某老师告诉我复试后才能确定名额，拟录取名单公布后，该老师问我是否读博，在得到否定的回答后，告诉我2天后跟他确认。但实际上，学硕名额非常紧张，有几个老师主动联系，我也意识到再等下去无济于事，赶快联系想跟的其他老师，很不幸的是：学硕名额几乎全都告罄。剩下一些不太想做的方向，出于无奈，只能群发了5个老师碰一碰运气。只要能实习、人品不至于太难以言表，是否push我都没什么问题，因为我只是要个学位证而已，即使这样也还是从下午3点找到晚上10点。</p><p>一年多的时间，我个人也变得更加平静，所以早早联系的老师一直吊着我，最后放我鸽子，我也无所谓。甚至看到自己出现在拟录取名单的第一行时，我也少有欣喜，脑子里想的只是烟酒生期间去哪实习，经济独立要怎么做，能不能早点拿到毕业证。</p><p>实习无望，只有做些其它事来消耗日子：拿到王道的助教资格，可能是这几个月为数不多的好消息。</p><p>人在回顾前一阶段的自己时，大多会觉得幼稚，正如现在翻看几年前的朋友圈，尴尬癌就会复发，所谓的成长究竟是好事还是坏事呢？<strong>随机漫步的人生又有谁说的清楚</strong>？甚至一年前我都从来没想过会是今天这个局面，顺便推荐一本有点虚无主义色彩的书《随机漫步的傻瓜》，看完后你可能会发现运气和概率竟然在人生中扮演了如此重要的角色。</p><p><strong>喜欢什么，就放手去做吧。人生的许多问题，只有自己亲身经历过，才能够给出回答</strong>。如雷军在<a href="https://v.qq.com/x/page/m0857uh1apx.html">采访</a>中所说：</p><blockquote><p>雷布斯：人生不要太多的勉强，不要强迫自己做什么。我觉得做自己喜欢的事情，可能是最佳的选择。因为你喜欢这个方向，喜欢做这件事情，我觉得爱好比什么强迫都管用。 主持人：如果不知道自己喜欢什么呢？ 雷布斯：那就看直觉。 主持人：也没有直觉？ 雷布斯：那就撞上什么干什么，这些冥冥之中姻缘注定的，反正撞到什么是什么。人生就是这样的一场经历嘛。你撞到这个事情，你不知道自己喜不喜欢，你先干了再说，你不喜欢还可以改。不要怕选择，你不喜欢可以改。 主持人：可能大家总是怕选错吧，走弯路吧？ 雷布斯：这个选错是必然的事，每个人都会做很多很多的选择，我觉得选择一定会出错。关键是提高选对的成功率，而不是说怕选错。每个人一辈子，可能做了一千个选择、一万个选择，怎么让你重要的选择不出错，或者少出错，这是关键，那些小的选择，无所谓对与错。</p></blockquote><p>人啊，总是逃不过真香定律：本科时黑的最起劲的一个地方，迟到了一年，几个月后又将重新去往。不过这次与五年前不同的是：我知道了<strong>Who am I</strong>，也弄清了<strong>Where am I going</strong>，以及大致明白了<strong>How to get there</strong>。 ## 8 小结 折腾了这么多，成长的阵痛依然历历在目。有些时候道理就在那里，可是不痛撞南墙就是明白不了。撞得头破血流才体会到了下面这些道理（不保证正确，只是我现在的看法，每个人都会有局限，仅供参考）： 1. <strong>选择比努力更重要，你的当前状态就是由之前的每一步决定和行为导致的。获取足够的信息是做出正确决定的前提，多和不同背景的人交流（多约饭）是获取信息的一种方式；</strong> 2. <strong>做决定时多考虑未来的职业规划，少考虑沉没成本，更不要冲着高大上的标签或者亲朋好友的期待；</strong> 3. <strong>独立思考和自我纠错会是极其重要并且稀缺的品性，这种能力的提高都需要亲身实践（跳几次坑就明白了）；</strong> 4. <strong>世俗意义下的成功评价标准与你在哪所学校读书、成绩有多好、科研多牛逼并不是强相关，所以非名校的同学完全没有必要自暴自弃，主动获取信息并做出明智的决定，最后比名校学生优秀的大有人在，我已经亲身见识过很多这类人了；</strong> 5. <strong>对于名校同学，千万不要沉迷于学校牌子、竞赛获奖这些光环带来的麻醉中，个人差异远比学校和专业的差异大得多，趁早找到自己的生涯规划：多去申请实习或者通过其他方式进而提前排除错误选项，越早付出的代价越小；</strong> 6. <strong>不要用战术上的勤奋掩盖战略上的失败，做事前先想明白Why，再去考虑How；</strong> 7. <strong>一尘不染的事情是没有的，完美只存在于梦境中，认清过去的错误，面对当下的现实，未来重新做人；</strong> 8. <strong>综上，想要避免痛苦，就要尽早认清自己曾经、现在、将来一直都是loser的事实，每天做个乐呵呵的傻逼，也挺好。</strong></p><p>伏案涕零，不知所言！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#7 Applications</title>
      <link href="/2020/06/02/MIT%20Linear%20Algebra#7%20Applications/"/>
      <url>/2020/06/02/MIT%20Linear%20Algebra#7%20Applications/</url>
      
        <content type="html"><![CDATA[<h2 id="图和网络">图和网络</h2><p>图是一些工程问题的抽象，比如电路网络： <img src="https://img-blog.csdnimg.cn/20200525210820863.png" alt="在这里插入图片描述" /> 我们可以用<span class="math inline">\(A_{54}\)</span>表示图中的信息，每行代表一条边，每列代表一个结点，1表示电流流入，-1表示流出： <span class="math display">\[A=\begin{bmatrix}   -1 &amp; 1 &amp; 0 &amp; 0 \\   0 &amp; -1 &amp; 1 &amp; 0 \\   -1 &amp; 0 &amp; 1 &amp; 0 \\   -1 &amp; 0 &amp; 0 &amp; 1 \\   0 &amp; 0 &amp; -1 &amp; 1 \\  \end{bmatrix}\]</span> <span class="math inline">\(edge3=edge1+edge2\)</span>，前三行线性相关，在图中表现为形成环路。 我们比较关注<span class="math inline">\(A\)</span>的零空间，也即如何组合各列以得到零列<span class="math inline">\(Ax=0\)</span>，即： <span class="math display">\[Ax=\begin{bmatrix}   x_2-x_1\\   x_3-x_2\\   x_3-x_1\\   x_4-x_1\\   x_4-x_3\\  \end{bmatrix}=\begin{bmatrix}   0\\ 0\\  0\\  0\\   0\\  \end{bmatrix}\]</span> 根据前面的学习，<span class="math inline">\(dim(N(A))=n-r(A)=4-3=1\)</span>，并且可以求出零空间：<span class="math inline">\(x=c\begin{bmatrix}  1\\  1\\  1\\  1\\  \end{bmatrix}\)</span>，如果<span class="math inline">\(x_i\)</span>表示<strong>结点<span class="math inline">\(i\)</span>的电势</strong>，那么从结果可以看出来四个点等电势，一旦确定某个点的电势(接地为0)，即可确定其余各点。</p><p>再研究一下<span class="math inline">\(A\)</span>的左零空间，即<span class="math inline">\(A^Ty=0\)</span>，<span class="math inline">\(dim(N(A^T))=m-r(A)=5-3=2\)</span>，不妨看看转置后的鬼样子： <span class="math display">\[\begin{bmatrix}   -1 &amp; 0 &amp; -1 &amp; -1 &amp; 0 \\  1 &amp; -1 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 1 &amp; 1 &amp; 0 &amp; -1 \\  0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\  \end{bmatrix}\begin{bmatrix}   y_1\\   y_2\\  y_3\\ y_4\\ y_5\\  \end{bmatrix}=\begin{bmatrix}   0 \\ 0 \\ 0 \\  0 \\  \end{bmatrix}\]</span> 变为简化行阶梯<span class="math inline">\(R\)</span>就会发现：pivot col是第一列、第二列和第四列，对应到图中的三条边，可以看到是没有环路的，实际上是一棵<strong>最小生成树</strong>。如果用<span class="math inline">\(y_i\)</span>表示<strong>边<span class="math inline">\(i\)</span>的电流值</strong>，不妨写出这个方程组： <span class="math display">\[\begin{cases}-y_1-y_3-y_4=0&amp; \text{结点1流出之和为0}\\y_1-y_2=0&amp; \text{结点2流入流出相等}\\y_2+y_3-y_5=0&amp; \text{...}\\y_4+y_5=0&amp; \text{...}\end{cases}\]</span> 类似地，可以求出这个左零空间的一组基： <span class="math display">\[\begin{bmatrix}   1\\ 1\\  -1\\  0\\   0\\  \end{bmatrix}、\begin{bmatrix}   0\\ 0\\  1\\  -1\\   1\\  \end{bmatrix}\]</span> 这组基对应到图中也是很明确的：第一个向量对应回路1(边1/2/3)的电流，第二个向量对应回路2(边3/4/5)的电流，当然也可以选择大的回路作为基的一个组成。 由此也可以看出：<span class="math inline">\(dim(N(A^T))=m-r=\#loops=\#edges-(\#nodes-1)\)</span>，这也就是著名的欧拉公式：<span class="math inline">\(\#nodes-\#edges+\#loops=1\)</span>。</p><p>回顾整个过程：</p><ul><li>通过电势求得电势差：<span class="math inline">\(Ax=e\)</span>；</li><li>通过欧姆定律<span class="math inline">\(y=Ce\)</span>可以求得结点间的电流值<span class="math inline">\(y_i\)</span>；</li><li>通过<span class="math inline">\(A^Ty=0\)</span>验证了Kirchhoff's current law。 如果有外接电流源，那么整个过程可以描述为<span class="math inline">\(A^TCAx=f\)</span>。 ## 马尔可夫矩阵 马尔可夫模型最初是研究人口迁徙的模型，马尔可夫矩阵有2个特点：</li><li><span class="math inline">\(a_{ij}&gt;0\)</span></li><li>每一列和为1</li></ul><p>我们要研究随着时间变化，人口最终的分布情况，即稳态。 根据一阶差分<span class="math inline">\(u_k=A^ku_0=c_1\lambda_1^kx_1+c_2\lambda_2^kx_2+...\)</span>，<strong>马尔可夫矩阵有一个特征值为1</strong>，其余的绝对值都小于1，那么最终的稳态就是<span class="math inline">\(c_1x_1\)</span>。 举例来看： <span class="math display">\[\begin{bmatrix}   u_{cal}\\   u_{mass}\\  \end{bmatrix}_{t=k+1}=\begin{bmatrix}   0.9 &amp; 0.2\\  0.1 &amp; 0.8\\  \end{bmatrix}\begin{bmatrix}   u_{cal}\\   u_{mass}\\  \end{bmatrix}_{t=k},u_0=\begin{bmatrix}   0\\   1000\\  \end{bmatrix}\]</span> 矩阵表示加州的人有0.9留在加州，0.1迁徙到麻省。求得<span class="math inline">\(A\)</span>的特征值和特征向量，再用<span class="math inline">\(u_0\)</span>求得系数<span class="math inline">\(c\)</span>，就可以得到<span class="math inline">\(u_k\)</span>。 ## 傅里叶级数 我们知道，向量空间内任意向量都可以表示为一组标准正交基的线性组合： <span class="math display">\[v=x_1q_1+x_2q_2+...+x_nq_n=Qx,x=Q^{-1}v=Q^Tv\]</span> 那么对于任意的函数<span class="math inline">\(f(x)\)</span>，也可以表示为一组正交基的线性组合： <span class="math display">\[f(x)=a_0*1+a_1cosx+b_1sinx+a_2cos(2x)+b_2sin(2x)+...\]</span> 这组基<span class="math inline">\(1,cosx,sinx,cos(2x),sin(2x),...\)</span>是正交的，即： <span class="math display">\[f^Tg=\int_0^{2\pi} f(x)g(x) dx=0\]</span> 要求得级数得系数，比如<span class="math inline">\(a_1\)</span>，只要等式两边同乘<span class="math inline">\(cosx\)</span>并积分即可： <span class="math display">\[\int_0^{2\pi} f(x)cosx dx=\int_0^{2\pi} a_1cos^2(x) dx\]</span> ## 复矩阵 复向量<span class="math inline">\(Z=\begin{bmatrix}  z_1\\  ...\\  z_n\\  \end{bmatrix}\)</span>的模<span class="math inline">\(||Z||^2=\bar Z^TZ=||z_1||^2+...+||z_n||^2\)</span>，内积也变为共轭转置<span class="math inline">\(\bar y^Tx\)</span>。 复数意义下的对称是<span class="math inline">\(\bar A^T=A\)</span>，也叫Hermitian矩阵； 复数意义下的正交是<span class="math inline">\(\bar q_i^Tq_j=\begin{cases} 0,i\neq j\\ 1,i=j\\ \end{cases}\)</span>，这样组成的正交阵<span class="math inline">\(\bar Q^TQ=I\)</span>，<span class="math inline">\(Q\)</span>也叫unitary矩阵。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#6 Linear Transformations</title>
      <link href="/2020/06/01/MIT%20Linear%20Algebra#6%20Linear%20Transformations/"/>
      <url>/2020/06/01/MIT%20Linear%20Algebra#6%20Linear%20Transformations/</url>
      
        <content type="html"><![CDATA[<h2 id="线性变换">线性变换</h2><p>顾名思义，所谓线性变换即某种变换满足线性性质： <span class="math display">\[\begin{cases}T(v+w)=T(v)+T(w)&amp; \text{}\\T(cv)=cT(v)&amp; \text{}\\\end{cases}\]</span> 投影变换、旋转变换满足线性，这种映射可以通过左乘矩阵完成。 如果要知道对整个空间的线性变换，只需要知道对基的变换结果即可，因为任意向量都可表示为基的线性组合：<span class="math inline">\(v=c_1v_1+c_2v_2+...+c_nv_n\)</span>，<span class="math inline">\((c_1,c_2,...,c_n)\)</span>是该向量在这组基下的<strong>坐标</strong>，那么<span class="math inline">\(T(v)=c_1T(v_1)+...+c_nT(v_n)\)</span>。</p><p>线性变换可以用矩阵表示，不同基下对应的矩阵是不同的，如果要求该矩阵： 假设输入基是<span class="math inline">\(v_1,...v_n\)</span>，输出空间的基是<span class="math inline">\(w_1,...w_m\)</span>，<strong><span class="math inline">\(A\)</span>的第一列就是<span class="math inline">\(T(v_1)\)</span>在<span class="math inline">\(w\)</span>下的坐标</strong>，因为输入<span class="math inline">\(v_1\)</span>，其在<span class="math inline">\(v\)</span>下的坐标就是<span class="math inline">\(\begin{bmatrix}  1\\  0\\  ...\\  0  \end{bmatrix}\)</span>，<span class="math inline">\(A\)</span>乘以该坐标就是取<span class="math inline">\(A\)</span>的第一列，同理可得其他列。 容易验证<span class="math inline">\(T=\frac{d}{dx}\)</span>也是线性变换，输入基如果选择<span class="math inline">\(1,x,x^2\)</span>，输入是<span class="math inline">\(c_1+c_2x+c_3x^2\)</span>，那么输出是<span class="math inline">\(c_2+2c_3x\)</span>，输出基是<span class="math inline">\(1,x\)</span>，那么用矩阵表示就是： <span class="math display">\[A\begin{bmatrix}   c_1\\   c_2\\   c_3\\  \end{bmatrix}=\begin{bmatrix}   c_2\\   2c_3\\  \end{bmatrix}\]</span> 当然可以用上面的方法求矩阵，这里比较简单<span class="math inline">\(A=\begin{bmatrix}  0 &amp; 1 &amp; 0\\  0 &amp; 0 &amp; 2\\  \end{bmatrix}\)</span>。 ## 基变换 选择合适的基，可以对图像进行压缩： 对于原始信号<span class="math inline">\(x\)</span>，可以通过基变换得到另一组基下的坐标<span class="math inline">\(c\)</span>，这一步是无损的，这些系数里可能含有大量的0，通过去掉这些项可以压缩大小，这一步是有损的，即<span class="math inline">\(\hat x=\Sigma \hat c_iv_i\)</span>。 目前比较好的有Fourier基和小波基，都是将原始图片分割为若干小块处理。 8<em>8Fourier基： <span class="math display">\[\begin{bmatrix}   1 &amp; 1 &amp;... &amp; 1 \\   1 &amp; w&amp;... &amp; w^{n-1} \\   ... &amp; ... &amp; ...\\    1 &amp; w^{n-1}&amp;... &amp; w^{(n-1)^2} \\  \end{bmatrix}\]</span> 8</em>8小波基： <span class="math display">\[W=\begin{bmatrix}   1 &amp; 1 &amp;1 &amp; 0 &amp; 1&amp;0&amp;0&amp;0\\   1 &amp; 1 &amp;1 &amp; 0  &amp; -1&amp;0&amp;0&amp;0\\   1 &amp; 1 &amp;-1 &amp; 0 &amp;0&amp;1&amp;0&amp;0\\  1 &amp; 1 &amp;-1 &amp; 0 &amp;0&amp;-1&amp;0&amp;0\\  1 &amp; -1 &amp;0&amp; 1 &amp;0&amp;0&amp;1&amp;0\\  1 &amp; -1 &amp;0 &amp; 1 &amp;0&amp;0&amp;-1&amp;0\\  1 &amp; -1 &amp;0 &amp; 1 &amp;0&amp;0&amp;0&amp;1\\  1 &amp; -1 &amp;0 &amp; 1 &amp;0&amp;0&amp;0&amp;-1\\  \end{bmatrix}\]</span> 标准基下的像素值在基变换后： <span class="math display">\[p=\begin{bmatrix}   p_1\\   ...\\   p_8\\  \end{bmatrix}=W\begin{bmatrix}   c_1\\   ...\\   c_8\\  \end{bmatrix}=Wc\]</span> 所以在新的基下的坐标是<span class="math inline">\(c=W^{-1}p\)</span>。 就性能而言：我们需要<span class="math inline">\(W^{-1}\)</span>可以快速求得，这一点<span class="math inline">\(W^{-1}=W^T\)</span>；另外还要求只需要少量基向量就可以逼近原始信号。 ## 左右逆/伪逆 对于满秩的情况<span class="math inline">\(r=m=n\)</span>，左逆和右逆都存在，即<span class="math inline">\(AA^{-1}=I=A^{-1}A\)</span>； 对于列满秩<span class="math inline">\(r=n&lt;m\)</span>，比如<span class="math inline">\(\begin{bmatrix}  1 &amp; 2\\  1 &amp; 3\\  2 &amp; 4\\  \end{bmatrix}\)</span>，<span class="math inline">\(A_{left}^{-1}=(A^TA)^{-1}A^T\)</span>； 对于行满秩<span class="math inline">\(r=m&lt;n\)</span>，<span class="math inline">\(A_{right}^{-1}=A^T(AA^T)^{-1}\)</span>； 对于不满秩的情况<span class="math inline">\(r&lt;m,r&lt;n\)</span>，这样<strong>不论<span class="math inline">\(A^TA\)</span>还是<span class="math inline">\(AA^T\)</span>都是奇异的</strong>，所以不可能有左逆或者右逆。这种情况在统计学上多次出现，就提出了伪逆的概念，记作<span class="math inline">\(A^+\)</span>。 找伪逆可以通过SVD，<span class="math inline">\(A=U\Sigma V^T\)</span>，这里我们的特征值是不完整的，即<span class="math inline">\(\Sigma_{mn}=\begin{bmatrix}  \sigma_1 &amp; ... &amp; 0&amp;0 \\  ... &amp; ... &amp; ...&amp;0\\  0 &amp; ... &amp; \sigma_r &amp;0\\  ...\\  0 &amp; ... &amp; 0&amp;0 \\  \end{bmatrix}\)</span>，那么<span class="math inline">\(\Sigma_{nm}^+=\begin{bmatrix}  1/\sigma_1 &amp; ... &amp; 0&amp;0 \\  ... &amp; ... &amp; ...&amp;0\\  0 &amp; ... &amp; 1/\sigma_r &amp;0\\  ...\\  0 &amp; ... &amp; 0&amp;0 \\  \end{bmatrix}\)</span>，这样<span class="math inline">\(A^+=V\Sigma^+U^T\)</span>。 ## 作业</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#5 Eigenvalues and Eigenvectors</title>
      <link href="/2020/05/31/MIT%20Linear%20Algebra#5%20Eigenvalues%20and%20Eigenvectors/"/>
      <url>/2020/05/31/MIT%20Linear%20Algebra#5%20Eigenvalues%20and%20Eigenvectors/</url>
      
        <content type="html"><![CDATA[<h2 id="特征值特征向量">特征值/特征向量</h2><p>矩阵作用于列向量<span class="math inline">\(x\)</span>得到列向量<span class="math inline">\(Ax\)</span>，矩阵的作用相当于函数，对于大部分列向量<span class="math inline">\(Ax\)</span>，其方向是不同于<span class="math inline">\(x\)</span>的，我们感兴趣的是其中<strong>平行于</strong><span class="math inline">\(x\)</span>的：<span class="math inline">\(Ax=\lambda x,x\neq0\)</span>。即：向量<span class="math inline">\(x\)</span>在矩阵<span class="math inline">\(A\)</span>的作用下，方向不变，只进行比例系数为<span class="math inline">\(\lambda\)</span>的伸缩。 特征向量所在直线上的向量都是特征向量，并且包含了所有特征向量，组成了特征空间。如果我们不断左乘矩阵<span class="math inline">\(A\)</span>，得到的列向量会越来越贴合最大特征值对应的特征空间（只对实数而言）。 对于二阶投影矩阵<span class="math inline">\(P\)</span>而言：如果<span class="math inline">\(x\)</span>已经在列空间的平面上，那么<span class="math inline">\(Px=x,\lambda=1\)</span>；如果<span class="math inline">\(x\)</span>垂直于列空间的平面，则<span class="math inline">\(Px=0,\lambda=0\)</span>，除此之外， 没有任何<span class="math inline">\(x\)</span>可以在投影后与原<span class="math inline">\(x\)</span>平行。 若<span class="math inline">\(A\)</span>是奇异阵，那么<span class="math inline">\(Ax=0\)</span>必有非零解，所以<span class="math inline">\(\lambda=0\)</span>必是一个特征值。 特征值还有两条简单的性质： <span class="math display">\[\Sigma_{i=1}^{n}\lambda_i=trace(A),\lambda_1...\lambda_n=det(A)\]</span> 有了理解后，求解<span class="math inline">\(\lambda,x\)</span>也很自然： <span class="math display">\[(A-\lambda I)x=0有非零解，A-\lambda I必奇异\]</span> <span class="math display">\[特征方程det(A-\lambda I)=0\]</span> 解出<span class="math inline">\(\lambda\)</span>，进而求出<span class="math inline">\((A-\lambda I)x=0\)</span>的零空间即可。 举个交换阵的例子：<span class="math inline">\(A=\begin{bmatrix}  0 &amp; 1 \\  1 &amp; 0\\  \end{bmatrix}\)</span>，从物理意义上，交换<span class="math inline">\(x_1=\begin{bmatrix}  1\\  1\\  \end{bmatrix}\)</span>的两行仍然与原向量平行，此时<span class="math inline">\(\lambda=1\)</span>；类似地，交换<span class="math inline">\(x_2=\begin{bmatrix}  1\\  -1\\  \end{bmatrix}\)</span>的两行仍然与原向量平行，只是变成了相反向量，此时<span class="math inline">\(\lambda=-1\)</span>。 如果再看<span class="math inline">\(A+3I=\begin{bmatrix}  3 &amp; 1 \\  1 &amp; 3\\  \end{bmatrix}\)</span>，特征值变为了<span class="math inline">\(\lambda+3=2,4\)</span>，特征向量没有改变。 接着可以看看特征值不为实数的例子：对于<strong>反对称</strong>矩阵<span class="math inline">\(\begin{bmatrix}  0 &amp; -1 \\  1 &amp; 0\\  \end{bmatrix}\)</span>，<span class="math inline">\(\lambda=i,-i\)</span>，从几何上看：该矩阵的作用是将向量旋转90度，旋转之后的向量不可能与之前的平行，所以也就没有实数特征值。 ## 对角化 这一节的前提是<span class="math inline">\(A\)</span><strong>有<span class="math inline">\(n\)</span>个线性无关的特征向量</strong>，这样后面由<strong>特征向量组成的矩阵</strong><span class="math inline">\(S\)</span>才可逆。 对于满足前提的矩阵： <span class="math display">\[AS=A\begin{bmatrix}x_1&amp;...&amp; x_n \\\end{bmatrix}=\begin{bmatrix}\lambda_1x_1&amp;...&amp; \lambda_nx_n \\\end{bmatrix}=\begin{bmatrix}x_1&amp;...&amp; x_n \\\end{bmatrix}\begin{bmatrix}   \lambda_1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \lambda_n \\  \end{bmatrix}=S\Lambda\]</span> 这样<span class="math inline">\(S^{-1}AS=\Lambda\)</span>。 如果<span class="math inline">\(A\)</span>的所有特征值互异，必可对角化；如果有重复特征值，那么<strong>不一定</strong>有<span class="math inline">\(n\)</span>个线性无关的特征向量，也不一定可以对角化。</p><p><span class="math inline">\(A\)</span>可以被分解为<span class="math inline">\(A=S\Lambda S^{-1}\)</span>。由此不难得到<span class="math inline">\(A\)</span>的幂：<span class="math inline">\(A^K=S\Lambda^K S^{-1}\)</span>，特征值加倍，但特征向量不变。 当<span class="math inline">\(K\rightarrow+\infin\)</span>，如果所有<span class="math inline">\(|\lambda_i|&lt;1\)</span>，那么<span class="math inline">\(A^K\rightarrow0\)</span>。 <span class="math inline">\(A\)</span>的幂有一个应用：一阶差分方程<span class="math inline">\(u_{k+1}=Au_k\)</span>，通过递推不难发现<span class="math inline">\(u_k=A^ku_0\)</span>，如果直接用<span class="math inline">\(A^K=S\Lambda^K S^{-1}\)</span>求解，求逆开销是不可忽视的，所以我们换一种方式： 我们知道，线性无关的特征向量可以作为基表示其它向量： <span class="math display">\[u_0=c_1x_1+...+c_nx_n=Sc,Au_0=S\Lambda S^{-1}u_0=S\Lambda S^{-1}Sc=S\Lambda c\]</span> <span class="math display">\[A^ku_o=c_1\lambda_1^{k}x_1+...+c_n\lambda_n^{k}x_n=S\Lambda^{k}c\]</span> 很清楚地看到：<span class="math inline">\(u_k\)</span>的增长速度由<span class="math inline">\(\Lambda\)</span>决定，并且越大的特征值起的作用越大。 因此求解差分方程需要三步：</p><ol type="1"><li>求解矩阵<span class="math inline">\(A\)</span>的特征值和特征向量；</li><li>将<span class="math inline">\(u_0\)</span>在特征向量上展开，求出向量<span class="math inline">\(c\)</span>；</li><li>按照<span class="math inline">\(u_k=S\Lambda^{k}c\)</span>计算即可。</li></ol><p>这里非常经典的例子就是<a href="https://www.cnblogs.com/EIMadrigal/p/11478906.html">斐波那契数列</a>。 ## 微分方程 我们知道：对于常系数线性微分方程<span class="math inline">\(\frac{dy}{dt}=\lambda y\)</span>，其解为<span class="math inline">\(y(t)=Ce^{\lambda t}\)</span>。现在要研究的是未知函数是向量的情况：<span class="math inline">\(\frac{du}{dt}=Au\)</span>，不难验证<span class="math inline">\(u(t)=e^{\lambda t}x\)</span>是特解，并且微分方程组满足线性性质。 举例来看： <span class="math display">\[\begin{cases}\frac{du_1}{dt}=-u_1+2u_2&amp; \text{}\\\frac{du_2}{dt}=u_1-2u_2&amp; \text{}\\\end{cases},u(0)=\begin{bmatrix}   1\\   0\\  \end{bmatrix}\]</span> <span class="math inline">\(A=\begin{bmatrix}  -1 &amp; 2 \\  1 &amp; -2\\  \end{bmatrix}\)</span>，求解出<span class="math inline">\(\lambda=0,-3\)</span>，从特征值可以看出：<span class="math inline">\(\lambda=-3\)</span>的项会随着<span class="math inline">\(t\)</span>的增加而消失，<span class="math inline">\(\lambda=0\)</span>的项最终会是稳态。 特征向量<span class="math inline">\(x_1=\begin{bmatrix}  2\\  1\\  \end{bmatrix},x_2=\begin{bmatrix}  1\\  -1\\  \end{bmatrix}\)</span>，这样可以写出通解： <span class="math display">\[u(t)=c_1e^{\lambda_1 t}x_1+c_2e^{\lambda_2 t}x_2=\frac{1}{3}\begin{bmatrix}   2\\   1\\  \end{bmatrix}+\frac{1}{3}e^{-3t}\begin{bmatrix}   1\\   -1\\  \end{bmatrix}\]</span> 当<span class="math inline">\(t\rightarrow+\infin\)</span>，<span class="math inline">\(\frac{1}{3}\begin{bmatrix}  2\\  1\\  \end{bmatrix}\)</span>这一项将是稳态。 因此从特征值的角度，<span class="math inline">\(||e^{(-3+6i)t}||=e^{-3t}\)</span>，<span class="math inline">\(||e^{6it}||=1\)</span>，在单位圆上运动，所以最终的状态取决于特征值的实部：</p><ul><li><span class="math inline">\(Re(\lambda)&lt;0,e^{\lambda t}\rightarrow0,u(t)\rightarrow0\)</span></li><li>某个特征值为0，其余实部小于0，最终收敛于常量</li><li><span class="math inline">\(Re(\lambda)&gt;0\)</span>，无法收敛</li></ul><p>回头去看上述的微分方程，<span class="math inline">\(u_1\)</span>和<span class="math inline">\(u_2\)</span>耦合在一起，下面我们尝试用特征向量<strong>解耦</strong>： 令<span class="math inline">\(u=Sv\)</span>，则微分方程变为<span class="math inline">\(S\frac{dv}{dt}=ASv,\frac{dv}{dt}=S^{-1}ASv=\Lambda v\)</span>，那么： <span class="math display">\[\begin{cases}\frac{dv_1}{dt}=\lambda_1v_1&amp; \text{}\\\frac{dv_2}{dt}=\lambda_2v_2&amp; \text{}\\...\end{cases}\]</span> 换种思路，如果直接求解<span class="math inline">\(\frac{dv}{dt}=\Lambda v\)</span>，那么类似于标量的答案<span class="math inline">\(v(t)=v(0)e^{\Lambda t},u(t)=Sv(t)=Se^{\Lambda t}S^{-1}u(0)=e^{At}u(0)\)</span>，这里就得到了一个新的概念：<strong>矩阵指数</strong><span class="math inline">\(e^{At}\)</span>。 如果你还记得高数里的泰勒展开： <span class="math display">\[\frac{1}{1-x}=\sum\limits_{n=0}^{\infin}x^n,e^x=\sum\limits_{n=0}^{\infin}\frac{x^n}{n!}\]</span> 那么矩阵指数同样可以展开： <span class="math display">\[(I-At)^{-1}=I+At+(At)^2+...,e^{At}=I+At+\frac{1}{2}(At)^2+...+\frac{(At)^n}{n!}+...\]</span> <span class="math inline">\(e^{At}\)</span>一定是收敛的，因为阶乘的增长速度远远大于其它运算，接着将它写成矩阵形式： <span class="math display">\[e^{At}=I+S\Lambda S^{-1}t+\frac{1}{2}S\Lambda^2S^{-1}t^2+...=Se^{\Lambda t}S^{-1}\]</span> <span class="math inline">\(e^{\Lambda t}\)</span>也是一个矩阵指数，可以写作<span class="math inline">\(\begin{bmatrix}  e^{\lambda_1t} &amp; ... &amp; 0 \\  ... &amp; ... &amp; ...\\  0 &amp; ... &amp; e^{\lambda_nt} \\  \end{bmatrix}\)</span>，这里也可以有相似的收敛性：</p><ul><li>对于矩阵指数<span class="math inline">\(e^{\Lambda t}\)</span>，若<span class="math inline">\(Re(\lambda)&lt;0\)</span>，则收敛；</li><li>对于矩阵幂<span class="math inline">\(A^K=S\Lambda^K S^{-1}\)</span>，若<span class="math inline">\(||\lambda||&lt;1\)</span>，则收敛。</li></ul><p>微分方程也可以像上一节一样，将二阶<span class="math inline">\(y&#39;&#39;+by&#39;+ky=0\)</span>转为一阶，构造： <span class="math display">\[\begin{cases}y&#39;&#39;+by&#39;+ky=0&amp; \text{}\\y&#39;=y&#39;&amp; \text{}\\\end{cases}\]</span> 令<span class="math inline">\(u=\begin{bmatrix}  y&#39;\\  y\\  \end{bmatrix}\)</span>，则<span class="math inline">\(u&#39;=\begin{bmatrix}  y&#39;&#39;\\  y&#39;\\  \end{bmatrix}=\begin{bmatrix}  -b &amp; -k \\  1 &amp; 0\\  \end{bmatrix}\begin{bmatrix}  y&#39;\\  y\\  \end{bmatrix}=Au\)</span>。 ## 实对称阵/正定阵 <strong>实对称矩阵的特征值必为实数，特征向量正交</strong>。证明略。对于复矩阵，只有<span class="math inline">\(A=\bar A^T(共轭转置)\)</span>，性质才成立。 上一节我们知道：如果<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个线性无关的特征向量，那么可以被分解成<span class="math inline">\(A=S\Lambda S^{-1}\)</span>。对于正交阵而言<span class="math inline">\(Q^T=Q^{-1}\)</span>，故<span class="math inline">\(A=Q\Lambda Q^{-1}=Q\Lambda Q^{T}\)</span>，如果进一步计算： <span class="math display">\[A=\begin{bmatrix}q_1&amp;...&amp; q_n \\\end{bmatrix}\begin{bmatrix}   \lambda_1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \lambda_n \\  \end{bmatrix}\begin{bmatrix}   q_1^T\\   ...\\   q_n^T\\  \end{bmatrix}=\lambda_1q_1q_1^T+...+\lambda_nq_nq_n^T\]</span> <span class="math inline">\(q_iq_i^T\)</span>是投影矩阵，实对称矩阵可以由投影矩阵线性组合而来，这些投影矩阵我个人感觉非常像矩阵的基，也就是说实对称阵可以完全由其特征值和特征向量确定。</p><p>接着我们来看正定阵，<strong>正定阵的前提是对称阵</strong>，有3个充要条件：</p><ul><li><span class="math inline">\(\lambda_i&gt;0\)</span></li><li><span class="math inline">\(pivot_i&gt;0\)</span></li><li>所有子行列式为正</li></ul><p>实际上，<span class="math inline">\(\#正主元=\#正特征值\)</span>，并且<span class="math inline">\(\Pi pivot=\Pi\lambda_i=det(A)\)</span>。 利用正定阵可以研究二次型的最小值： <span class="math display">\[f(x,y)=x^TAx=ax^2+2bxy+cy^2\]</span> 如果<span class="math inline">\(A\)</span>正定，那么<span class="math inline">\(除(0,0)外,f(x,y)&gt;0\)</span>。 取<span class="math inline">\(A=\begin{bmatrix}  2 &amp; 6 \\  6 &amp; 20\\  \end{bmatrix}\)</span>，那么<span class="math inline">\(f(x,y)=2x^2+12xy+20y^2\)</span>，配方<span class="math inline">\(f(x,y)=2(x+3y)^2+2y^2&gt;0\)</span>，注意各项的系数：两个平方项前的系数是<span class="math inline">\(A\)</span>的两个<strong>主元</strong>，括号中的3是矩阵消元时所用的<strong>乘数</strong>。如果把<span class="math inline">\(A\)</span>做LU分解会看得更清楚：<span class="math inline">\(A=LU=\begin{bmatrix}  1 &amp; 0 \\  3 &amp; 1\\  \end{bmatrix}\begin{bmatrix}  2 &amp; 6 \\  0 &amp; 2\\  \end{bmatrix}\)</span>。 从几何上看，<span class="math inline">\(f(x,y)\)</span>就像是一个<strong>碗</strong>的形状，在<span class="math inline">\((0,0)\)</span>处取极小值0，<span class="math inline">\(f(x,y)=1\)</span>则是椭圆截面。 对于三阶的情况：<span class="math inline">\(A=\begin{bmatrix}  2 &amp; -1 &amp; 0 \\  -1 &amp; 2 &amp; -1 \\  0 &amp; -1 &amp; 2 \\  \end{bmatrix}\)</span>，可以求得<span class="math inline">\(\lambda=2-\sqrt2,2,2+\sqrt2\)</span>，那么此时 <span class="math display">\[f=x^TAx&gt;0\]</span> 这在几何上已经上升到四维，必然有3个轴，并且轴的方向由相应的特征向量决定，轴的长度由特征值决定，<span class="math inline">\(f=1\)</span>是一个椭球。</p><p>最后，如果<span class="math inline">\(A_{mn}\)</span>的各列线性无关，那么<span class="math inline">\(A^TA\)</span>必然正定，证明可以从<span class="math inline">\(x^TAx&gt;0\)</span>入手。 ## 相似阵 前面我们见过<span class="math inline">\(S^{-1}AS=\Lambda\)</span>，那么<span class="math inline">\(A\sim\Lambda\)</span>。比较正式的说法是：存在可逆阵M，使得<span class="math inline">\(B=M^{-1}AM\)</span>，则称<span class="math inline">\(A\sim B\)</span>。相似阵可以看作一个家族，这个家族的共同点就是<strong>特征值相同</strong>。 之前我们知道：如果<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个不同的特征值，那么必可相似对角化。如果有重复的特征值，未必可以对角化： 现在考虑<span class="math inline">\(\lambda_1=\lambda_2=4\)</span>的情况，满足条件的矩阵有很多，比如<span class="math inline">\(A=\begin{bmatrix}  4 &amp; 0 \\  0 &amp; 4\\  \end{bmatrix}\)</span>，但如果我们去找<span class="math inline">\(A\)</span>的相似阵，我们尝试用<span class="math inline">\(M^{-1}AM=A\)</span>，无论任何<span class="math inline">\(M\)</span>，最终的结果都是<span class="math inline">\(A\)</span>自己，不会增加任何新的矩阵，矩阵<span class="math inline">\(A\)</span>单独组成了一个家族。 如果去看其余满足条件的矩阵，比如<span class="math inline">\(B=\begin{bmatrix}  4 &amp; 1 \\  0 &amp; 4\\  \end{bmatrix},C=\begin{bmatrix}  4 &amp; 0 \\  17 &amp; 4\\  \end{bmatrix}...\)</span>，这些只有1个特征向量的矩阵虽然不能对角化，但是我们可以找一个<strong>最接近对角阵</strong>的，也就是<span class="math inline">\(B\)</span>，称为Jordan Form。 对于<span class="math inline">\(\begin{bmatrix}  0 &amp; 1 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 1 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  \end{bmatrix}和\begin{bmatrix}  0 &amp; 1 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  \end{bmatrix}\)</span>，尽管特征值全为0，但并不相似。只有2个线性无关的特征向量，所以就有2个Jordan Block，每个Jordan Block长这样： <span class="math display">\[J_i=\begin{bmatrix}   \lambda_i &amp; 1 &amp;...&amp; 0 \\  0 &amp; \lambda_i  &amp; 1 &amp; ...\\  ...&amp;...&amp;...&amp;...\\  0 &amp; 0 &amp; \lambda_i  &amp; 1 \\   0 &amp; 0 &amp; 0 &amp; \lambda_i  \\  \end{bmatrix}\]</span> 每个块只能有1个特征向量，这样做的意义在于任意的矩阵<span class="math inline">\(A\)</span>，即使不能相似对角化，但是都有<span class="math inline">\(A\sim J=\begin{bmatrix}  J_1 &amp; ... &amp; 0 \\  ... &amp; ... &amp; ...\\  0 &amp; ... &amp; J_d \\  \end{bmatrix}\)</span>。 ## SVD分解 假设我们在行空间有一组标准正交基<span class="math inline">\(v_1,v_2,...,v_r\)</span>，左乘矩阵<span class="math inline">\(A\)</span>进入列空间，将结果表示为列空间中的一组标准正交基<span class="math inline">\(u_1,u_2,...,u_r\)</span>： <span class="math display">\[AV=A\begin{bmatrix}v_1&amp;...&amp; v_r \\\end{bmatrix}=\begin{bmatrix}u_1&amp;...&amp; u_r \\\end{bmatrix}\begin{bmatrix}   \sigma_1 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \sigma_r \\  \end{bmatrix}=U\Sigma\]</span> 故<span class="math inline">\(A\)</span>可以分解为<span class="math inline">\(A=U\Sigma V^T\)</span>。 如果<span class="math inline">\(A=\begin{bmatrix}  4 &amp; 4 \\  -3 &amp; 3\\  \end{bmatrix}\)</span>，试着分解下，关键问题就是如何求得等式右边的3个矩阵。 先来搞定<span class="math inline">\(V\)</span>，最好能去掉<span class="math inline">\(U\)</span>，我们的技巧是用<span class="math inline">\(A^TA\)</span>： <span class="math display">\[A^TA=V\Sigma^TU^TU\Sigma V^T=V\begin{bmatrix}   \sigma_1^2 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \sigma_r^2 \\  \end{bmatrix}V^T\]</span> 由于<span class="math inline">\(A^TA\)</span>实对称，所以我们得到了<span class="math inline">\(Q\Lambda Q^{T}\)</span>的形式，接下来只要搞定<span class="math inline">\(A^TA\)</span>的特征值和特征向量即可得到<span class="math inline">\(V\)</span>和<span class="math inline">\(\Sigma\)</span>； 同样地，为了求<span class="math inline">\(U\)</span>，最好先搞掉<span class="math inline">\(V\)</span>： <span class="math display">\[AA^T=U\Sigma V^TV\Sigma^TU^T=U\begin{bmatrix}   \sigma_1^2 &amp; ... &amp; 0 \\   ... &amp; ... &amp; ...\\    0 &amp; ... &amp; \sigma_r^2 \\  \end{bmatrix}U^T\]</span> 只要求得<span class="math inline">\(AA^T\)</span>的特征值和特征向量即可得<span class="math inline">\(U\)</span>。 ## 作业 Suppose we have the rank-r svd of a rank 1 matrix <span class="math inline">\(A = U\Sigma V^T\)</span>. Describe the nullspace of <span class="math inline">\(A\)</span> in terms of possibly <span class="math inline">\(U\)</span>, <span class="math inline">\(Σ\)</span>, and <span class="math inline">\(V\)</span>. Answer: The nullspace of <span class="math inline">\(A\)</span> is the same as the nullspace of <span class="math inline">\(V^T\)</span>. Since <span class="math inline">\(A\)</span> is rank 1, <span class="math inline">\(V\)</span> is a vector. So the nullspace of <span class="math inline">\(V^T\)</span> is a hyperplane given by <span class="math inline">\(V^Tx=0\)</span>, i.e., the space of all the vectors that are perpendicular to <span class="math inline">\(V\)</span>.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#4 Determinants</title>
      <link href="/2020/05/29/MIT%20Linear%20Algebra#4%20Determinants/"/>
      <url>/2020/05/29/MIT%20Linear%20Algebra#4%20Determinants/</url>
      
        <content type="html"><![CDATA[<p>行列式本质上是要通过一个数字反应矩阵的某些信息，目前看来不是很重要，快速过一遍。 ## 性质 引入是通过3个基本性质：</p><ol type="1"><li><span class="math inline">\(det(I)=1\)</span></li><li>交换两行，行列式的值变号：置换矩阵<span class="math inline">\(det(P)=\begin{cases} 1&amp; \text{交换偶数次}\\ -1&amp; \text{交换奇数次}\\ \end{cases}\)</span></li><li><span class="math inline">\(\left|\begin{array}{cccc} ta &amp; tb\\ c &amp; d\\ \end{array}\right|=t\left|\begin{array}{cccc} a &amp; b\\ c &amp; d\\ \end{array}\right|,\left|\begin{array}{cccc} a+a&#39; &amp; b+b&#39;\\ c &amp; d\\ \end{array}\right|=\left|\begin{array}{cccc} a &amp; b\\ c &amp; d\\ \end{array}\right|+\left|\begin{array}{cccc} a&#39; &amp; b&#39;\\ c &amp; d\\ \end{array}\right|\)</span></li></ol><p>由3个基本性质可以推出若干：</p><ol type="1"><li>若两行相等，则<span class="math inline">\(det(A)=0\)</span> 交换相等的2行，矩阵不变，行列式的值不变，根据性质2：<span class="math inline">\(det(A)=-det(A)\)</span>，得证。</li><li>初等行变换不改变行列式的值 <span class="math display">\[\left|\begin{array}{cccc}a &amp; b\\ c-la &amp; d-lb\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; b\\ c &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}a &amp; b\\ -la &amp; -lb\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; b\\ c &amp; d\\\end{array}\right|\]</span></li><li>有一行全为0，行列式为0</li><li><strong>上三角矩阵的行列式等于主对角线元素之积</strong>：<span class="math inline">\(det(U)=d_1d_2...d_n\)</span> 对于任意矩阵，通过初等行变换可以得到<span class="math inline">\(U\)</span>，接着向上消元并提出对角线的因子，可以得到<span class="math inline">\(I\)</span>。 这也是Matlab求行列式的方法。</li><li><span class="math inline">\(det(A)=0\Leftrightarrow A是奇异矩阵(消元后有全0行)\)</span> <span class="math inline">\(det(A)\neq0\Leftrightarrow A可逆\Rightarrow U\Rightarrow d_1d_2...d_n\neq0\)</span></li><li><span class="math inline">\(det(AB)=det(A)*det(B) \Rightarrow det(A^{-1})=\frac{1}{det(A)}\)</span></li><li><span class="math inline">\(det(A^T)=det(A)\)</span>，可以通过LU分解去证，这也意味着对行成立的性质对列也成立。 ## 计算方法 上一节中介绍了消元化上三角求行列式的方法，本节介绍2种不常用的方法，所有计算都可以通过上一节的3个基本性质获得： 对于二阶，拆解后有2个非零项： <span class="math display">\[\left|\begin{array}{cccc}a &amp; b\\ c &amp; d\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; 0\\ c &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}0 &amp; b\\ c &amp; d\\\end{array}\right|=\left|\begin{array}{cccc}a &amp; 0\\ c &amp; 0\\\end{array}\right|+\left|\begin{array}{cccc}a &amp; 0\\ 0 &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}0 &amp; b\\ 0 &amp; d\\\end{array}\right|+\left|\begin{array}{cccc}0 &amp; b\\ c &amp; 0\\\end{array}\right|=ad-bc\]</span> 对于三阶，拆解后有6个非零项： <span class="math display">\[\left|\begin{array}{cccc} a_{11} &amp; a_{12} &amp; a_{13}\\ a_{21} &amp; a_{22} &amp; a_{23}\\ a_{31} &amp; a_{32} &amp; a_{33}\\ \end{array}\right|=\left|\begin{array}{cccc} a_{11} &amp;  &amp; \\  &amp; a_{22} &amp; \\  &amp;  &amp; a_{33}\\ \end{array}\right|+\left|\begin{array}{cccc} a_{11} &amp;  &amp; \\  &amp;  &amp; a_{23}\\  &amp;  a_{32}&amp; \\ \end{array}\right|+\left|\begin{array}{cccc}  &amp;a_{12}  &amp; \\  a_{21}&amp;  &amp; \\  &amp;  &amp;a_{33}\\ \end{array}\right|+\left|\begin{array}{cccc}  &amp;a_{12}  &amp; \\  &amp;  &amp;a_{23} \\  a_{31}&amp;  &amp;\\ \end{array}\right|+\left|\begin{array}{cccc}  &amp;  &amp;a_{13} \\  a_{21}&amp;  &amp; \\  &amp;a_{32}  &amp;\\ \end{array}\right|+\left|\begin{array}{cccc}  &amp;  &amp;a_{13} \\  &amp;a_{22}  &amp; \\  a_{31}&amp;  &amp;\\ \end{array}\right|\]</span> 接着可以通过交换行得到对角阵并求得结果。 如果我们观察每一项：从第一行到最后一行，<strong>列下标</strong>是<span class="math inline">\((1,2,3)\)</span>的某个全排列，因此可以知道展开以后非零项一共有<span class="math inline">\(n!\)</span>项(第一行有<span class="math inline">\(n\)</span>种选择，第二行有<span class="math inline">\(n-1\)</span>种选择...)，于是可以得到第二种计算行列式的方法： <span class="math display">\[det(A)=\Sigma_{n!项}\pm a_{1x}a_{1y}...a_{1w},(x,y,...w)是(1,n)的某个全排列\]</span> 正负号取决于交换了几次得到<span class="math inline">\((1,2,3...)\)</span>这种朴素的排列。 举例来看： <span class="math display">\[\left|\begin{array}{cccc} 0 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0\\ 1 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 1\\ \end{array}\right|\]</span> 可以先取<span class="math inline">\((1,3)\)</span>位置，接着只能取<span class="math inline">\((2,2)\)</span>，接着<span class="math inline">\((3,1)\)</span>，最后<span class="math inline">\((4,4)\)</span>，所以列的排列是<span class="math inline">\((3,2,1,4)\)</span>，交换一次可得<span class="math inline">\((1,2,3,4)\)</span>，故有一非零项-1； 还可以先取<span class="math inline">\((1,4)\)</span>，接着<span class="math inline">\((2,3)\)</span>，<span class="math inline">\((3,2)\)</span>，最后<span class="math inline">\((4,1)\)</span>，列的排列是<span class="math inline">\((4,3,2,1)\)</span>，交换2次可得<span class="math inline">\((1,2,3,4)\)</span>，故有一非零项1，除此以外，没有别的选择，所以行列式的值是0。</li></ol><p>如果我们对上述拆解三阶行列式的结果提取公因子： <span class="math display">\[det(A)=a_{11}(a_{22}a_{33}-a_{23}a_{32})+a_{12}(-a_{21}a_{33}+a_{23}a_{31})+a_{13}(a_{21}a_{32}-a_{22}a_{31})\]</span> 我们穷举了第一行的3种可能的选择<span class="math inline">\(a_{11},a_{12},a_{13}\)</span>，对于每种选择，当前行与当前列都不能再用，括号中的式子叫做<strong>代数余子式</strong><span class="math inline">\(C_{ij}\)</span>：去掉<span class="math inline">\(a_{ij}\)</span>所在行列的<span class="math inline">\(n-1\)</span>阶行列式，并且正负号取决于<span class="math inline">\(i+j\)</span>的奇(-)偶(+)。 这样我们得到了求行列式的第三种方法： <span class="math display">\[det(A)=a_{11}C_{11}+a_{12}C_{12}+...+a_{1n}C_{1n}\]</span> 举例来看，对于三对角行列式： <span class="math display">\[\left|\begin{array}{cccc} 1 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 1 &amp; 1 &amp; 0\\ 0 &amp; 1 &amp; 1 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 1\\ \end{array}\right|\]</span> 容易知：<span class="math inline">\(det(A_1)=1,det(A_2)=\left|\begin{array}{cccc} 1 &amp; 1\\ 1 &amp; 1\\ \end{array}\right|=0,det(A_3)=\left|\begin{array}{cccc} 1 &amp; 1 &amp; 0\\ 1 &amp; 1 &amp; 1\\ 0 &amp; 1 &amp; 1\\ \end{array}\right|=-1\)</span>。 对于四阶，我们<strong>按第一列展开</strong>：<span class="math inline">\(det(A_4)=1*det(A_3)-1*det(A_2)=-1\)</span>，此式可以推广：<span class="math inline">\(det(A_n)=det(A_{n-1})-det(A_{n-2})\)</span>，可以发现上述三对角行列式是以6为周期的。 ## 应用</p><ul><li>求逆矩阵 记得当年矩阵求逆教了一种伴随矩阵的方法：<span class="math inline">\(A^{-1}=\frac{1}{det(A)}C^T\)</span>，不知为何物？ 只要证明<span class="math inline">\(AC^T=det(A)I\)</span>即可： <span class="math display">\[\left[\begin{array}{cccc} a_{11} &amp; ... &amp; a_{1n}\\ ... &amp;  &amp; ...\\ a_{n1} &amp; ... &amp; a_{nn}\\ \end{array}\right]\left[\begin{array}{cccc} C_{11} &amp; ... &amp; C_{n1}\\ ... &amp;  &amp; ...\\ C_{1n} &amp; ... &amp; C_{nn}\\ \end{array}\right]=\left[\begin{array}{cccc} det(A) &amp; ... &amp;0\\ ... &amp;  &amp; ...\\ 0 &amp; ... &amp; det(A)\\ \end{array}\right]\]</span> 对于主对角线上的元素：<span class="math inline">\(a_{11}C_{11}+...+a_{1n}C_{1n}=det(A)\)</span>； 对于其它元素：<span class="math inline">\(a_{11}C_{n1}+...+a_{1n}C_{nn}=\left|\begin{array}{cccc} a_{11} &amp; ... &amp; a_{1n}\\ ... &amp; &amp; ...\\ a_{11} &amp; ... &amp; a_{1n}\\ \end{array}\right|=0\)</span>。</li><li>求解<span class="math inline">\(Ax=b\)</span> 求解：<span class="math inline">\(x=A^{-1}b=\frac{1}{det(A)}C^Tb\)</span>，那么考虑<span class="math inline">\(x_1=\frac{1}{det(A)}(b_1c_{11}+..+b_nc_{n1})\)</span>，<span class="math inline">\(b_1c_{11}+..+b_nc_{n1}\)</span>其实是将矩阵<span class="math inline">\(A\)</span>的第一列换为<span class="math inline">\(b\)</span>，按照第一列展开求行列式的值即可，同理可以求得其它<span class="math inline">\(x_i\)</span>，这种差到没人用的方法竟然被国内教材奉为圭臬。</li><li>求体积 <span class="math inline">\(det(A)\)</span>的绝对值可以定义为一个平行六面体的体积，正负表示左手系还是右手系。 将三阶矩阵<span class="math inline">\(A\)</span>的每行(列)当作平行六面体的一条边，如果<span class="math inline">\(A=I\)</span>，我们得到一个标准的单位立方体；如果<span class="math inline">\(A=Q\)</span>，我们得到一个旋转过的单位立方体，体积仍然为1，可以通过<span class="math inline">\(Q^TQ=I\)</span>验证。 如果是二维情况，那么<span class="math inline">\(det(A)\)</span>的绝对值就是平行四边形的面积： <span class="math display">\[S=\left|\begin{array}{cccc}a &amp; b\\ c &amp; d\\\end{array}\right|=ad-bc\]</span> 那么三角形的面积就是<span class="math inline">\(\frac{1}{2}S\)</span>，推广到向量的起始位置不在<span class="math inline">\((0,0)\)</span>的情况： <span class="math display">\[S_{三角形}=\frac{1}{2}\left|\begin{array}{cccc}x_1 &amp; y_1 &amp; 1\\ x_2 &amp; y_2 &amp; 1\\ x_3 &amp; y_3 &amp; 1\\ \end{array}\right|\]</span> 可以通过平移到原点去证明。 ## 作业 A Hadamard matrix H is a matrix with entries ±1 and orthogonal columns. What is the determinant of H as a function of n? (Hadamard matrices are conjectured to exist for every n that is a multiple of 4, but nobody knows if there is such a matrix even for n=668). 由于<span class="math inline">\(H\)</span>各列正交，故<span class="math inline">\(H^TH=cI\)</span>；又<span class="math inline">\(H\)</span>的元素只有±1，故<span class="math inline">\(c=n\)</span>。所以<span class="math inline">\(det(H)^2=n^n,det(H) = \pm\sqrt{n^n}\)</span>，即<span class="math inline">\(n\)</span>阶Hadamard矩阵的行列式既可以为正，也可以为负。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#3 Orthogonality</title>
      <link href="/2020/05/27/MIT%20Linear%20Algebra#3%20Orthogonality/"/>
      <url>/2020/05/27/MIT%20Linear%20Algebra#3%20Orthogonality/</url>
      
        <content type="html"><![CDATA[<h2 id="正交向量">正交向量</h2><p>初中时候我们学过勾股定理，现在用<strong>向量</strong>的形式表示： <span class="math display">\[|x|^2+|y|^2=|x+y|^2\]</span> 模长的平方也可以表示为<span class="math inline">\(x^Tx\)</span>，做一些计算，就有两个向量正交的判断条件<span class="math inline">\(x^Ty=0\)</span>。</p><p>向量正交有些简单，让我们上升到子空间正交。一个比较直观的<strong>错误</strong>的例子就是地板和墙壁的关系，两者并<strong>不正交</strong>，因为子空间正交要求子空间<span class="math inline">\(S\)</span>中的每个向量都和子空间<span class="math inline">\(T\)</span>中每个向量正交。根据定义，任意两个子空间若相交于某非0向量，那么两者必然不正交。 将正交的概念应用于前面学过的四个基本子空间： 对于零空间<span class="math inline">\(Ax=0\)</span>，我们有<span class="math inline">\(\begin{bmatrix}  row1\\  ...\\  rowm  \end{bmatrix}x=\begin{bmatrix}  0\\  ...\\  0  \end{bmatrix}\)</span>，<span class="math inline">\(x\)</span>和每一行都是正交的，那么<span class="math inline">\(x\)</span>和各行的线性组合也正交，由此可见<strong>零空间和行空间是正交的</strong>。 我们还知道：在<span class="math inline">\(R^n\)</span>中，需要<span class="math inline">\(n\)</span>个基向量张成整个空间，<span class="math inline">\(dim(C(A^T))=r,dim(N(A))=n-r\)</span>，这两个正交的子空间将<span class="math inline">\(R^n\)</span>一分为二，有个专门的术语<strong>正交补</strong>就描述了这种关系，意即零空间包含了所有垂直于行空间的向量。 类似地，可以证明<span class="math inline">\(C(A)\)</span>和<span class="math inline">\(N(A^T)\)</span>也是正交补的关系，将<span class="math inline">\(R^m\)</span>一分为二。 最后，我们为下一节留一个引子：考虑<span class="math inline">\(Ax=b\)</span>，当方程个数<span class="math inline">\(m\)</span>大于未知数个数<span class="math inline">\(n\)</span>，方程组很可能无解，那么怎么找到一个最为近似的解呢？听起来可能有些难理解，举个例子来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 1\\   1 &amp; 2\\   1 &amp; 5\\  \end{bmatrix}\begin{bmatrix}   x_1\\   x_2\\  \end{bmatrix}=\begin{bmatrix}   b_1\\   b_2\\     b_3\\  \end{bmatrix}  \]</span> <span class="math inline">\(A\)</span>的列空间是<span class="math inline">\(R^3\)</span>中的一个平面，但是向量<span class="math inline">\(b\)</span>极有可能不在列空间中，此时方程组无解。但是我们想找到<span class="math inline">\(b\)</span>在列空间的<strong>投影</strong>，进而求出最为近似的解。 做法是在<span class="math inline">\(Ax=b\)</span>两边同乘<span class="math inline">\(A^T\)</span>，求解<span class="math inline">\(A^TA\hat x=A^Tb\)</span>，<span class="math inline">\(\hat x\)</span>即是要求的近似解。这里牵涉到一个非常重要的矩阵<span class="math inline">\(A^TA\)</span>，它是对称阵，并且<span class="math inline">\(N(A^TA)=N(A),r(A^TA)=r(A)\)</span>，如果<span class="math inline">\(A\)</span>的各列线性无关，那么<span class="math inline">\(A^TA\)</span>就是可逆的。这样做的原因后面会逐渐揭晓。 ## 子空间投影 这一节非常重要。上一节的最后我们说到：在<span class="math inline">\(Ax=b\)</span>无解的情况下，我们要将<span class="math inline">\(b\)</span>微调成最靠近<span class="math inline">\(C(A)\)</span>的某个向量<span class="math inline">\(p\)</span>，从而求解<span class="math inline">\(A\hat x=p\)</span>，<span class="math inline">\(p\)</span>就是<span class="math inline">\(b\)</span>在列空间的<strong>投影</strong>。</p><p>我们首先看看<span class="math inline">\(R^2\)</span>的情况： <img src="https://img-blog.csdnimg.cn/20200526204930131.png" alt="平面上有向量a,b，" /> 从图中可以看到：<span class="math inline">\(e=b-p=b-xa\)</span>，再由正交关系：<span class="math inline">\(a^Te=a^T(b-xa)=0\)</span>，可以计算出乘数<span class="math inline">\(x=\frac{a^Tb}{a^Ta}\)</span>，进而可以将投影<span class="math inline">\(p\)</span>表示为<span class="math inline">\(p=xa=\frac{aa^T}{a^Ta}b=Pb\)</span>，这里的<span class="math inline">\(P=\frac{aa^T}{a^Ta}\)</span>即投影矩阵。 <span class="math inline">\(r(P)=1\)</span>，<span class="math inline">\(P\)</span>的列空间即为过<span class="math inline">\(a\)</span>的直线。此外，投影矩阵还有两条性质：<span class="math inline">\(P^T=P,P^2=P\)</span>，从几何上解释即投影2次和投影1次效果完全一样。</p><p>接着看看<span class="math inline">\(R^3\)</span>的情况： 两个<strong>线性无关</strong>的列向量<span class="math inline">\(a_1,a_2\)</span>生成的列空间是一个平面，令<span class="math inline">\(A=\begin{bmatrix}  a_1 &amp; a_2\\  \end{bmatrix}\)</span>。类似地，<span class="math inline">\(p\)</span>是向量<span class="math inline">\(b\)</span>在平面上的投影，<span class="math inline">\(e=b-p\)</span>垂直于平面。<strong>因为<span class="math inline">\(p\)</span>在<span class="math inline">\(A\)</span>的列空间中</strong>，所以可以表示为<span class="math inline">\(p=A\hat x=\hat x_1a_1+\hat x_2a_2\)</span>，我们就是要找到<span class="math inline">\(\hat x\)</span>。</p><p>根据<span class="math inline">\(e\)</span>和平面的垂直关系，可以得到： <span class="math display">\[\begin{cases}a_1^T(b-A\hat x)=0&amp; \text{}\\a_2^T(b-A\hat x)=0&amp; \text{}\end{cases}\]</span> 写出矩阵形式： <span class="math display">\[\begin{bmatrix}   a_1^T\\   a_2^T\\  \end{bmatrix}\begin{bmatrix}  b-A\hat x \\  \end{bmatrix}=\begin{bmatrix}   0\\   0\\  \end{bmatrix}  \]</span> 即<span class="math inline">\(A^T(b-A\hat x)=0\)</span>，<strong>这里<span class="math inline">\(b-A\hat x=e\)</span>在<span class="math inline">\(N(A^T)\)</span>中</strong>，故<span class="math inline">\(e\)</span>垂直于<span class="math inline">\(C(A)\)</span>。 接着化简，我们<strong>得到了上一节中同乘<span class="math inline">\(A^T\)</span>的原因</strong>：<span class="math inline">\(A^TA\hat x=A^Tb\)</span>，继续：<span class="math inline">\(\hat x=(A^TA)^{-1}A^Tb\)</span>。这里注意不能继续化简，因为<span class="math inline">\(A\)</span>不是方阵，<span class="math inline">\(A^{-1}\)</span>不存在。 得到组合系数<span class="math inline">\(\hat x\)</span>后，就可以写出投影<span class="math inline">\(p=A\hat x=A(A^TA)^{-1}A^Tb\)</span>，同样地，投影矩阵<span class="math inline">\(P=A(A^TA)^{-1}A^T\)</span>，可以验证，<span class="math inline">\(P^T=P,P^2=P\)</span>仍然成立。</p><p>最后我们考虑极端一些的情况：</p><ul><li>若<span class="math inline">\(b\)</span>在<span class="math inline">\(A\)</span>的列空间中，投影后仍然是<span class="math inline">\(b\)</span>自己：<span class="math inline">\(b=Ax-&gt;Pb=PAx=Ax=b\)</span>；</li><li>若<span class="math inline">\(b\)</span>垂直于<span class="math inline">\(A\)</span>的列空间，投影后是<span class="math inline">\(0\)</span>：<span class="math inline">\(b\)</span>在<span class="math inline">\(N(A^T)\)</span>中，<span class="math inline">\(A^Tb=0-&gt;Pb=0\)</span>。</li></ul><p>换句话说，<span class="math inline">\(b\)</span>被分解为<span class="math inline">\(p\)</span>和<span class="math inline">\(e\)</span>，<span class="math inline">\(p\)</span>在<span class="math inline">\(C(A)\)</span>中，<span class="math inline">\(e\)</span>在<span class="math inline">\(N(A^T)\)</span>中，并且<span class="math inline">\(b=p+e=Pb+(I-P)b\)</span>。 ## 最小二乘法 这是投影的一个应用，主要用来拟合直线，举例来看： <img src="https://img-blog.csdnimg.cn/20200526221325518.png" alt="在这里插入图片描述" /> 有三个点，需要找到一条最佳拟合直线，方程组形式： <span class="math display">\[\begin{cases}C+D=1&amp; \text{}\\C+2D=2&amp; \text{}\\C+3D=2&amp; \text{}\\\end{cases}\]</span> 矩阵形式： <span class="math display">\[Ax=\begin{bmatrix}   1 &amp; 1\\   1 &amp; 2\\   1 &amp; 3\\  \end{bmatrix}\begin{bmatrix}   C\\  D\\  \end{bmatrix}=\begin{bmatrix}   1\\   2\\     2\\  \end{bmatrix}=b  \]</span> 显然是无解的，要找到最优拟合系数<span class="math inline">\(CD\)</span>，就要用到投影： 清除outlier(离群值)后，定义每个点的误差：<span class="math inline">\(|e|^2=|Ax-b|^2\)</span>，那么优化目标变为最小化：<span class="math inline">\(e_1^2+e_2^2+e_3^2=(C+D-1)^2+(C+2D-2)^2+(C+3D-2)^2\)</span>，如何找到<span class="math inline">\(\hat x=\begin{bmatrix}  C\\  D\\  \end{bmatrix}\)</span>? 求偏导当然是一种方法，从线性代数的角度，回顾下上节中<span class="math inline">\(A^TA\hat x=A^Tb\)</span>，我们已经证明，<strong>这样解得的<span class="math inline">\(\hat x\)</span>可以微调<span class="math inline">\(b\)</span>使其最靠近<span class="math inline">\(C(A)\)</span></strong>，也就是我们要的最优估计。 所以我们有： <span class="math display">\[A^TA\hat x=\begin{bmatrix}   3 &amp; 6\\   6 &amp; 14\\  \end{bmatrix}\begin{bmatrix}   C\\  D\\  \end{bmatrix}=\begin{bmatrix}   5\\   11\\  \end{bmatrix}=A^Tb  \]</span> 这样就得到了所谓的Normal Equation： <span class="math display">\[\begin{cases}3C+6D=5&amp; \text{}\\6C+14D=11&amp; \text{}\\\end{cases}\]</span> 解得<span class="math inline">\(C=\frac{2}{3},D=\frac{1}{2}\)</span>，我们的最佳拟合直线即为<span class="math inline">\(b=\frac{2}{3}+\frac{1}{2}t\)</span>。</p><p>最后要注意的一点：<span class="math inline">\(\hat x\)</span>可解的前提是<span class="math inline">\(A^TA\)</span>可逆，只要<span class="math inline">\(A\)</span>的各列线性无关，这点即可满足。 不妨做一些证明： 要证明<span class="math inline">\(A^TA\)</span>可逆即证明<span class="math inline">\(A^TAx=0\)</span>只有零解； <span class="math inline">\(x^TA^TAx=0,(Ax)^TAx=0,Ax=0\)</span>，<span class="math inline">\(A\)</span>的各列线性无关意即<span class="math inline">\(Ax=0\)</span>只有零解，得证。 ## 正交化 我们都知道，对于<strong>标准正交向量</strong>，有： <span class="math display">\[q_i^Tq_j=\begin{cases}0&amp; \text{$i\neq j$}\\1&amp; \text{$i=j$}\\\end{cases}\]</span> 正交矩阵写作<span class="math inline">\(Q=\begin{bmatrix}  q_1 &amp; q_2 ... &amp; q_n\\  \end{bmatrix}\)</span>，很容易验证： <span class="math display">\[Q^TQ=\begin{bmatrix}   q_1^T\\   ...\\     q_n^T\\  \end{bmatrix}\begin{bmatrix}   q_1 &amp; ... &amp; q_n\\  \end{bmatrix}=I\]</span> 如果<span class="math inline">\(Q\)</span>是方阵，那么<span class="math inline">\(Q^T=Q^{-1}\)</span>。正交矩阵的例子有很多：以前学习过的置换矩阵、<span class="math inline">\(\begin{bmatrix}  cos\theta &amp; -sin\theta\\  sin\theta &amp; cos\theta\\  \end{bmatrix}\)</span>，还有一种叫做Adhemar的系列矩阵也是正交阵：<span class="math inline">\(\frac{1}{\sqrt{2}}\begin{bmatrix}  1 &amp; 1\\  1 &amp; -1\\  \end{bmatrix}\)</span>、<span class="math inline">\(\frac{1}{2}\begin{bmatrix}  1 &amp; 1 &amp; 1 &amp; 1\\  1 &amp; -1 &amp; 1 &amp; -1\\  1 &amp; 1 &amp; -1 &amp; -1\\  1 &amp; -1 &amp; -1 &amp; 1\\  \end{bmatrix}\)</span>... 有了这些了解后，就可以解答为什么需要正交矩阵： 还记得上一节中的投影矩阵<span class="math inline">\(P\)</span>吗？将矩阵<span class="math inline">\(A\)</span>变为正交阵<span class="math inline">\(Q\)</span>后，这时再把<span class="math inline">\(b\)</span>投影到<span class="math inline">\(C(Q)\)</span>中，投影矩阵就变为了<span class="math inline">\(P=Q(Q^TQ)^{-1}Q^T=QQ^T\)</span>，如果<span class="math inline">\(Q\)</span>是方阵，那么<span class="math inline">\(P=QQ^T=I\)</span>，这也非常好解释：<span class="math inline">\(Q\)</span>是方阵必然可逆，<span class="math inline">\(C(Q)\)</span>就是整个空间，<span class="math inline">\(P=I\)</span>相当于没有进行投影。 还有我们在求最优估计时用到的<span class="math inline">\(A^TA\hat x=A^Tb\)</span>变为了<span class="math inline">\(Q^TQ\hat x=Q^Tb\)</span>，即<span class="math inline">\(\hat x=Q^Tb\)</span>，求解<span class="math inline">\(\hat x_i\)</span>就简化为了<span class="math inline">\(\hat x_i=q_i^Tb\)</span>。</p><p>所以接下来的问题就是如何将各列线性无关的<span class="math inline">\(A\)</span>变为正交阵<span class="math inline">\(Q\)</span>，这项工作就是Gram-Schmidt正交化，先从两个向量的情况开始： <img src="https://img-blog.csdnimg.cn/20200527120631653.png" alt="在这里插入图片描述" /> 工作分2步进行：</p><ul><li>由线性无关的2个向量<span class="math inline">\(a,b\)</span>得到2个正交的向量<span class="math inline">\(A,B\)</span>： 这一步主要是改变方向，<span class="math inline">\(A=a\)</span>即可，<span class="math inline">\(B=e=b-p=b-\frac{A^Tb}{A^TA}A\)</span>。</li><li>将<span class="math inline">\(A,B\)</span>变为标准正交向量<span class="math inline">\(q_1,q_2\)</span>： 这一步主要是改变长度，<span class="math inline">\(q_1=\frac{A}{|A|},q_2=\frac{B}{|B|}\)</span>。</li></ul><p>如果是3个线性无关的向量，必然生成整个三维空间，<span class="math inline">\(A,B\)</span>不会变，<span class="math inline">\(C\)</span>其实是垂直于<span class="math inline">\(AB\)</span>子空间的那个<span class="math inline">\(e\)</span>，即减去在<span class="math inline">\(A,B\)</span>两个方向的投影(可以用三支笔模拟)，故<span class="math inline">\(C=c-\frac{A^Tc}{A^TA}A-\frac{B^Tc}{B^TB}B\)</span>。 观察上述工作，可以发现：我们所有的工作都是在<strong>同一个列空间</strong>中进行，只是开始的线性无关的基计算量太大，我们想要一组更加简化计算的互相垂直且长度为1的基。 正因为是在一个空间中进行，所以必然存在<span class="math inline">\(q\)</span>的线性组合可以得到<span class="math inline">\(a\)</span>，即<span class="math inline">\(A=QR\)</span>，并且<span class="math inline">\(a_1\)</span>只与<span class="math inline">\(q_1\)</span>有关、<span class="math inline">\(a_2\)</span>只与<span class="math inline">\(q_1,q_2\)</span>有关、<span class="math inline">\(a_3\)</span>只与<span class="math inline">\(q_1,q_2,q_3\)</span>有关，故<span class="math inline">\(R\)</span>必为<strong>上三角矩阵</strong>，也即： <span class="math display">\[\begin{bmatrix}   a_1 &amp; a_2 &amp; a_3\\  \end{bmatrix}=\begin{bmatrix}   q_1 &amp; q_2 &amp; q_3\\  \end{bmatrix}\begin{bmatrix}   q_1^Ta_1 &amp; q_1^Ta_2 &amp; q_1^Ta_3\\   0 &amp; q_2^Ta_2 &amp; q_2^Ta_3\\   0 &amp; 0 &amp; q_3^Ta_3\\  \end{bmatrix}\]</span> 这里<span class="math inline">\(R=Q^TA\)</span>。 ## 作业 Suppose a square <span class="math inline">\(A\)</span> has an LU factorization <span class="math inline">\(A=LU\)</span> where <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are invertible. If <span class="math inline">\(A=QR\)</span>, what is <span class="math inline">\(r_{11}\)</span> in terms of possibly elements of <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>? 在QR分解中，<span class="math inline">\(r_{11}=q_1^Ta_1=\frac{a_1}{||a_1||}a_1=||a_1||\)</span>，即<span class="math inline">\(A\)</span>第一列的模；第一列即<span class="math inline">\(L\)</span>各列的线性组合，系数是<span class="math inline">\(U\)</span>的第一列(只有<span class="math inline">\(U_{11}\)</span>一个元素)，所以<span class="math inline">\(r_{11}=U_{11} \sqrt{\sum_i L_{i1}^2}\)</span>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#2 Vector Spaces and Subspaces</title>
      <link href="/2020/05/25/MIT%20Linear%20Algebra#2%20Vector%20Spaces%20and%20Subspaces/"/>
      <url>/2020/05/25/MIT%20Linear%20Algebra#2%20Vector%20Spaces%20and%20Subspaces/</url>
      
        <content type="html"><![CDATA[<h2 id="向量空间">向量空间</h2><p>向量空间对于该空间内任意向量的线性组合(数乘/加法)都是封闭的，并且必然包含零向量(数乘0)。 <span class="math inline">\(R^2\)</span>本身就是一个向量空间，它的子空间有下面几种：</p><ul><li>过原点直线；</li><li>零向量。</li></ul><p><span class="math inline">\(R^3\)</span>本身也是一个向量空间，它的子空间：</p><ul><li>过(0,0,0)的平面；</li><li>过(0,0,0)的直线；</li><li>零向量。</li></ul><p>从矩阵构造的角度来看，假设<span class="math inline">\(A=\begin{bmatrix}  1 &amp; 3\\  2 &amp; 3\\  4 &amp; 1  \end{bmatrix}\)</span>，<span class="math inline">\(A\)</span>的每一列属于<span class="math inline">\(R^3\)</span>，<span class="math inline">\(A\)</span>的col1和col2的所有线性组合构成了一个向量空间，称作<strong>列空间</strong>，记作<span class="math inline">\(C(A)\)</span>。 从列空间的角度重新来看<span class="math inline">\(Ax=b\)</span>： <span class="math display">\[A=\begin{bmatrix}   1 &amp; 1 &amp; 2\\   2 &amp; 1 &amp; 3\\   3 &amp; 1 &amp; 4\\   4 &amp; 1 &amp; 5  \end{bmatrix}\]</span> <span class="math inline">\(A\)</span>的所有列向量的线性组合构成了<span class="math inline">\(R^4\)</span>的一个子空间，<span class="math inline">\(Ax\)</span>恰是<span class="math inline">\(A\)</span>的所有列向量的线性组合，即列空间<span class="math inline">\(C(A)\)</span>，故只有<span class="math inline">\(b\)</span>在<span class="math inline">\(C(A)\)</span>中时方程组才有解。 3列无论怎样线性组合，都无法充满整个4维空间，同时注意到<span class="math inline">\(col1+col2=col3\)</span>，即使去掉第三列，仍然可以生成原来的列空间，<span class="math inline">\(col3\)</span>与<span class="math inline">\(col1\)</span>和<span class="math inline">\(col2\)</span>是<strong>线性相关</strong>的，所以实际上矩阵<span class="math inline">\(A\)</span>的列空间只是<span class="math inline">\(R^4\)</span>中的2维子空间。</p><p>再来看看<span class="math inline">\(Ax=0\)</span>，所有解<span class="math inline">\(x\)</span>构成了<span class="math inline">\(A\)</span>的<strong>零空间</strong>，记作<span class="math inline">\(N(A)\)</span>。 <span class="math display">\[Ax=\begin{bmatrix}   1 &amp; 1 &amp; 2\\   2 &amp; 1 &amp; 3\\   3 &amp; 1 &amp; 4\\   4 &amp; 1 &amp; 5  \end{bmatrix}\begin{bmatrix}  x_1\\  x_2\\  x_3  \end{bmatrix}=\begin{bmatrix}  0\\  0\\  0\\  0  \end{bmatrix}\]</span> 虽然<span class="math inline">\(A\)</span>的每一列都属于<span class="math inline">\(R^4\)</span>，但是零空间研究的是<span class="math inline">\(x\)</span>，<span class="math inline">\(x\)</span>属于<span class="math inline">\(R^3\)</span>。 傻子都看得出来<span class="math inline">\((0,0,0)\)</span>是一组解，此前我们知道<span class="math inline">\(col1+col2=col3\)</span>，所以<span class="math inline">\(c(1,1,-1)\)</span>也是一组解，所有解其实就是<span class="math inline">\(R^3\)</span>中的一个子空间，一条直线而已，也就是<span class="math inline">\(A\)</span>的零空间<span class="math inline">\(N(A)\)</span>。 如果<span class="math inline">\(Ax=b\)</span>中<span class="math inline">\(b\neq0\)</span>，那么<span class="math inline">\(x\)</span>是不能构成子空间的，因为其中没有零向量。</p><p>由此我们可以得到构造子空间的两种方法：</p><ul><li>矩阵各列的所有线性组合；</li><li>方程组满足特定条件，让<span class="math inline">\(x\)</span>生成子空间。</li></ul><h2 id="求解零空间">求解零空间</h2><p>在上一节中我们知道，求解<span class="math inline">\(A\)</span>的零空间其实就是求解<span class="math inline">\(Ax=0\)</span>，还是要用到高斯消元。 <span class="math display">\[A=\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2\\   2 &amp; 4 &amp; 6 &amp; 8\\   3 &amp; 6 &amp; 8 &amp; 10  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2\\   0 &amp; 0 &amp; 2 &amp; 4\\   0 &amp; 0 &amp; 0 &amp; 0  \end{bmatrix}=U\]</span> 很显然，主元(每一行中第一个非零元素)是<span class="math inline">\(U(0,0)=1\)</span>和<span class="math inline">\(U(2,3)=2\)</span>，pivot col是第一列和第三列，第二列和第四列是free col，也可知<span class="math inline">\(rank(A)=\#pivots=2\)</span>，<span class="math inline">\(\#自由变量=n-rank(A)\)</span>，于是写出化简后的方程组： <span class="math display">\[\begin{cases}x_1+2x_2+2x_3+2x_4=0&amp; \text{}\\2x_3+4x_4=0&amp; \text{}\end{cases}\]</span> 对自由变量<span class="math inline">\(x_2\)</span>和<span class="math inline">\(x_4\)</span>，一般取<span class="math inline">\((0,1)\)</span>和<span class="math inline">\((1,0)\)</span>，所以特解(<strong>零空间的一组基</strong>)为： <span class="math display">\[\begin{bmatrix}  -2\\  1\\  0\\  0  \end{bmatrix}、\begin{bmatrix}  2\\  0\\  -2\\  1  \end{bmatrix}\]</span> 两个特解的线性组合即是整个零空间，也即是<span class="math inline">\(Ax=0\)</span>的全部解： <span class="math display">\[x=c\begin{bmatrix}  -2\\  1\\  0\\  0  \end{bmatrix}+d\begin{bmatrix}  2\\  0\\  -2\\  1  \end{bmatrix}\]</span> 其实矩阵<span class="math inline">\(U\)</span>还可以变得更加简单，可以化为简化行阶梯<span class="math inline">\(R=\begin{bmatrix}  1 &amp; 2 &amp; 0 &amp; -2\\  0 &amp; 0 &amp; 1 &amp; 2\\  0 &amp; 0 &amp; 0 &amp; 0  \end{bmatrix}\)</span>，即主元全部为1。 仔细观察矩阵<span class="math inline">\(R\)</span>，如果将pivot col全部移到左边，将free col移到右边，我们可以得到<span class="math inline">\(R\)</span>的一般形式：<span class="math inline">\(R=\begin{bmatrix}  I &amp; F\\  0 &amp; 0\\  \end{bmatrix}\)</span>，由此得出<span class="math inline">\(x\)</span>的一般形式：<span class="math inline">\(x=\begin{bmatrix}  -F\\  I\\  \end{bmatrix}\)</span>。 ## 求解Ax=b 上一节中我们求解了<span class="math inline">\(Ax=0\)</span>，接着看看更加复杂的情况： <span class="math display">\[[A\ b]=\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\   2 &amp; 4 &amp; 6 &amp; 8 &amp; b_2\\   3 &amp; 6 &amp; 8 &amp; 10 &amp; b_3  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1\\   0 &amp; 0 &amp; 2 &amp; 4 &amp; b_2-2b_1\\   0 &amp; 0 &amp; 0 &amp; 0 &amp; b_3-b_2-b_1  \end{bmatrix}\]</span> 我们知道，当<span class="math inline">\(b\)</span>属于<span class="math inline">\(C(A)\)</span>时方程组有解，不妨设<span class="math inline">\(b=(1,5,6)\)</span>，那么化简的矩阵为<span class="math inline">\(\begin{bmatrix}  1 &amp; 2 &amp; 2 &amp; 2 &amp; 1\\  0 &amp; 0 &amp; 2 &amp; 4 &amp; 3\\  0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \end{bmatrix}\)</span>，求解过程有3步：</p><ul><li>特解：一般令自由变量取0，即<span class="math inline">\(x_2=x_4=0\)</span>，求主变量： <span class="math display">\[\begin{cases}x_1+2x_3=1&amp; \text{}\\2x_3=3&amp; \text{}\end{cases}\]</span> 所以特解<span class="math inline">\(x_p=\begin{bmatrix}  -2\\  0\\  1.5\\  0  \end{bmatrix}\)</span></li><li>求零空间，即<span class="math inline">\(Ax=0\)</span>的解<span class="math inline">\(x_{null}\)</span>；</li><li>所有解<span class="math inline">\(x=x_p+x_{null}\)</span>。 因为<span class="math inline">\(Ax_p=b, Ax_{null}=0\)</span>，故<span class="math inline">\(A(x_p+x_{null})=b\)</span>。</li></ul><p>对于矩阵<span class="math inline">\(A_{mn}\)</span>，我们知道<span class="math inline">\(r(A)=\#pivots\)</span>，所以<span class="math inline">\(r\leq m\)</span>，<span class="math inline">\(r\leq n\)</span>。 先看看<strong>列满秩</strong>的情况：每列都有主元，<span class="math inline">\(r=n&lt;m\)</span>，没有自由变量，零空间只有零向量： 举例来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 3\\   2 &amp; 1\\   6 &amp; 1\\   5 &amp; 1  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0\\   0 &amp; 1\\   0 &amp; 0\\   0 &amp; 0  \end{bmatrix}=\begin{bmatrix}   I\\   0\\  \end{bmatrix}\]</span> 如果特解恰好存在，有1个解，否则无解。 接着看看<strong>行满秩</strong>的情况：每行都有主元，<span class="math inline">\(r=m&lt;n\)</span>，<strong>自由变量有<span class="math inline">\(n-r=n-m\)</span>个</strong>，零空间有<span class="math inline">\(n-m\)</span>个基，<span class="math inline">\(Ax=b\)</span>有无穷多解： 举例来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 2 &amp; 6 &amp; 5\\   3 &amp; 1 &amp; 1 &amp; 1  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0 &amp; a &amp; b\\   0 &amp; 1 &amp; c &amp; d  \end{bmatrix}=\begin{bmatrix}   I &amp; F\\  \end{bmatrix}\]</span> 还有<strong>满秩</strong>的情况：<span class="math inline">\(r=m=n\)</span>，没有自由变量，零空间只有零向量，必有唯一的特解： 举例来看： <span class="math display">\[\begin{bmatrix}   1 &amp; 2\\   3 &amp; 1\\  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0\\   0 &amp; 1\\  \end{bmatrix}=I\]</span> 最后一种情况就是<strong>不满秩</strong>：<span class="math inline">\(r&lt;m\)</span>，<span class="math inline">\(r&lt;n\)</span>，<span class="math inline">\(R=\begin{bmatrix}  I &amp; F\\  0 &amp; 0\\  \end{bmatrix}\)</span>，如果特解存在，就有无穷多解；否则无解。 ## 线性相关/基/维数 我们知道，对于矩阵<span class="math inline">\(A_{mn}(m&lt;n)\)</span>，因为有<span class="math inline">\(n-r\geq n-m\)</span>个自由变量，将这些自由变量赋一些非零值，即可解得主元，所以<span class="math inline">\(Ax=0\)</span>必有非零解。 对于一组向量<span class="math inline">\(x_1, x_2..., x_n\)</span>，除了系数全0以外，没有其他的线性组合可以得到零向量，那么这组向量<strong>线性无关</strong>，即<span class="math inline">\(c_1x_1+c_2x_2+...+c_nx_n\neq0(c_i不全为0)\)</span>。 举例来看：二维空间中的三个向量必然线性相关： <span class="math display">\[A=\begin{bmatrix}   2 &amp; 1 &amp; 3\\   1 &amp; 2 &amp; -1\\  \end{bmatrix}\]</span> 因为<span class="math inline">\(n-r&gt;0\)</span>，故必然有自由变量，所以<span class="math inline">\(Ax=0\)</span>必有非零解，即线性相关。 <strong>基</strong>也是一组向量<span class="math inline">\(v_1, v_2..., v_d\)</span>，不过要满足2个条件：</p><ul><li>线性无关；</li><li>可以生成整个空间。</li></ul><p><strong>空间维度</strong>即可以生成该空间的<strong>基向量的个数</strong>，前面我们知道：<span class="math inline">\(r(A)=\#pivot\ cols\)</span>，所以<span class="math inline">\(dim(C(A))=r(A)\)</span>，因为只需要pivot col就能生成整个列空间，并且列空间属于<span class="math inline">\(R^m\)</span>，因为每个基向量都有<span class="math inline">\(m\)</span>个元素。 对于零空间来说，特解的个数就是自由变量的个数，也就是基向量的个数，即<span class="math inline">\(dim(N(A))=\#自由变量=n-r(A)\)</span>，并且零空间属于<span class="math inline">\(R^n\)</span>，因为每个解向量都有<span class="math inline">\(n\)</span>个元素。 ## 四个基本子空间 前面我们学习了列空间和零空间，很自然地，就会有行空间和<span class="math inline">\(A^T\)</span>的零空间： 行空间，顾名思义，即是矩阵行向量的所有线性组合生成的向量空间，其实就是<span class="math inline">\(C(A^T)\)</span>，<span class="math inline">\(dim(C(A^T))=r(A)\)</span>，属于<span class="math inline">\(R^n\)</span>； <span class="math inline">\(A^T\)</span>的零空间，即<span class="math inline">\(A^Tx=0\)</span>的所有解向量生成的向量空间，即<span class="math inline">\(N(A^T)\)</span>，<span class="math inline">\(dim(N(A^T))=m-r(A)\)</span>，属于<span class="math inline">\(R^m\)</span>。 回忆消元的过程，我们不停地进行初等行变换，这个过程中，行空间没有改变，列空间改变，最终的行空间就是<span class="math inline">\(R\)</span>矩阵的前<span class="math inline">\(r(A)\)</span>行生成的向量空间。 对于<span class="math inline">\(N(A^T)\)</span>，即<span class="math inline">\(A^Ty=0\)</span>，转置即有<span class="math inline">\(y^TA=0\)</span>，所以<span class="math inline">\(N(A^T)\)</span>又叫<strong>左零空间</strong>。 学习消元时我们知道，左乘一系列的初等阵可以将<span class="math inline">\(A\)</span>化为<span class="math inline">\(R\)</span>： <span class="math display">\[E\begin{bmatrix}   A_{mn} &amp; I_{mm}\\  \end{bmatrix}-&gt;\begin{bmatrix}   R_{mn} &amp; E_{mm}\\  \end{bmatrix}\]</span> 矩阵<span class="math inline">\(E\)</span>记录了我们的变换过程，举例来看： <span class="math display">\[EA=\begin{bmatrix}   -1 &amp; 2 &amp; 0\\   1 &amp; -1 &amp; 0\\   -1 &amp; 0 &amp; 1  \end{bmatrix}\begin{bmatrix}   1 &amp; 2 &amp; 3 &amp; 1\\   1 &amp; 1 &amp; 2 &amp; 1\\   1 &amp; 2 &amp; 3 &amp; 1  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0 &amp; 1 &amp; 1\\   0 &amp; 1 &amp; 1 &amp; 1\\   0 &amp;  0&amp; 0 &amp; 0  \end{bmatrix}=R\]</span> <span class="math inline">\(dim(N(A^T))=m-r(A)=3-2=1\)</span>，左零空间中唯一一个基向量即<span class="math inline">\(E\)</span>的最后一行，因为<span class="math inline">\(\begin{bmatrix}  -1 &amp; 0 &amp; 1  \end{bmatrix}A=0\)</span>。 ## 矩阵空间 前面我们研究了若干向量生成的空间，上升一个高度，若干矩阵也可以构成一种特殊的向量空间，即矩阵空间。 所有的三阶矩阵构成矩阵空间<span class="math inline">\(M\)</span>，也就是<span class="math inline">\(R^{3*3}\)</span>。 <span class="math inline">\(M\)</span>的子空间有上三角矩阵<span class="math inline">\(U\)</span>和对称矩阵<span class="math inline">\(S\)</span>(可以用封闭性验证)。明确了空间后，就要研究该空间的维数和基向量。 <span class="math inline">\(dim(M)=9\)</span>，因为需要9个矩阵构成一组基，而且我们可以写出一组基： <span class="math display">\[\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 0 &amp; 1\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0  \end{bmatrix}  ...\begin{bmatrix}   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}\]</span> <span class="math inline">\(dim(S)=6\)</span>，因为需要对角线的3个元素和对角线下面(上面)3个元素； <span class="math inline">\(dim(U)=6\)</span>，因为需要对角线的3个元素和对角线上面3个元素。 再来看看<span class="math inline">\(S\bigcap U\)</span>，既是上三角矩阵又是对称矩阵，其实就是对角阵，<span class="math inline">\(dim(S\bigcap U)=3\)</span>； 那么<span class="math inline">\(S\bigcup U\)</span>呢？属于上三角或者对称，很显然这无法构成子空间； 那么<span class="math inline">\(S+U\)</span>呢？对应元素求和，实际上这就是<span class="math inline">\(M\)</span>。 由此我们得到一个性质： <span class="math display">\[dim(S)+dim(U)=dim(S\bigcap U)+dim(S+U)\]</span> 对于向量空间和基，不应局限于线性代数中，例如熟悉的微分方程： <span class="math display">\[\frac{d^2y}{dx^2}+y=0\]</span> 它的所有解<span class="math inline">\(y=c_1cosx+c_2sinx\)</span>也构成零空间，那么<span class="math inline">\(cosx\)</span>和<span class="math inline">\(sinx\)</span>就是一组基，并且解空间的维数是2。</p><p>最后看一种很有趣的矩阵，秩为1的矩阵： 对于这种矩阵，有<span class="math inline">\(dim(C(A))=dim(C(A^T))=r=1\)</span>，不妨举个例子： <span class="math display">\[A=\begin{bmatrix}   1 &amp; 4 &amp; 5\\   2 &amp; 8 &amp; 10  \end{bmatrix}=\begin{bmatrix}   1\\   2\\  \end{bmatrix}\begin{bmatrix}   1 &amp; 4 &amp; 5\\  \end{bmatrix}=uv^T\]</span> 用一个例子作为结尾： 在<span class="math inline">\(R^4\)</span>中，<span class="math inline">\(v=\begin{bmatrix}  v_1\\  v_2\\  v_3\\  v_4  \end{bmatrix}\)</span>，<span class="math inline">\(s\)</span>是满足<span class="math inline">\(v_1+v_2+v_3+v_4=0\)</span>的所有<span class="math inline">\(v\)</span>，那么<span class="math inline">\(s\)</span>显然是子空间，并且可以写成矩阵形式<span class="math inline">\(Av=\begin{bmatrix}  1 &amp; 1 &amp; 1 &amp; 1\\  \end{bmatrix}v=0\)</span>，接着看看<span class="math inline">\(A\)</span>的四个基本子空间：</p><ul><li>零空间：<span class="math inline">\(dim(N(A))=n-r=4-1=3\)</span>，给每个自由变量赋值后，得到一组特解(基)： <span class="math display">\[\begin{bmatrix}-1\\1\\0\\0  \end{bmatrix}、\begin{bmatrix}-1\\0\\1\\0  \end{bmatrix}、\begin{bmatrix}-1\\0\\0\\1  \end{bmatrix}\]</span></li><li>列空间：<span class="math inline">\(dim(C(A))=r=1\)</span>，基可以取任意一列；</li><li>行空间：<span class="math inline">\(dim(C(A^T))=r=1\)</span>，基向量即第一行；</li><li>左零空间：<span class="math inline">\(dim(N(A^T))=m-r=0\)</span>，基向量只有零向量。 ## 作业 Under what possible conditions is the matrix <span class="math inline">\(A=uv^T+wz^T\)</span> not of rank 2? 对于<span class="math inline">\(uv^T=\begin{bmatrix} a\\ b\\ c\\  \end{bmatrix}\begin{bmatrix} v_1&amp;v_2&amp;v_3\\  \end{bmatrix}\)</span>，结果就是<span class="math inline">\(u\)</span>的线性组合<span class="math inline">\(\begin{bmatrix} v_1u&amp;v_2u&amp;v_3u\\  \end{bmatrix}\)</span>，所以<span class="math inline">\(C(uv^T)\subset C(u)=xu,x\in R\)</span>；同样地，<span class="math inline">\(C(wz^T)\subset C(w)=yw,y\in R\)</span>，如果<span class="math inline">\(u\)</span>和<span class="math inline">\(w\)</span>共线，那么<span class="math inline">\(C(A)=xu\)</span>，即<span class="math inline">\(r(A)\leq1\)</span>； 从行向量组合的角度：<span class="math inline">\(uv^T=\begin{bmatrix} av^T\\ bv^T\\ cv^T\\  \end{bmatrix}\)</span>，故<span class="math inline">\(uv^T\)</span>的行空间<span class="math inline">\(\subset v^T\)</span>的行空间<span class="math inline">\(=xv^T\)</span>，<span class="math inline">\(wz^T\)</span>的行空间<span class="math inline">\(\subset z^T\)</span>的行空间<span class="math inline">\(=yz^T\)</span>，所以如果<span class="math inline">\(v\)</span>和<span class="math inline">\(z\)</span>共线，那么行空间就可以合并，即<span class="math inline">\(r(A)\leq1\)</span>。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#1 Solving Linear Equations</title>
      <link href="/2020/05/23/MIT%20Linear%20Algebra#1%20Solving%20Linear%20Equations/"/>
      <url>/2020/05/23/MIT%20Linear%20Algebra#1%20Solving%20Linear%20Equations/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵消元">矩阵消元</h2><p>求解三元一次方程组<span class="math inline">\(Ax=b\)</span>的方法就是<strong>消元</strong>： <span class="math display">\[\begin{cases}x+2y+z=2&amp; \text{E1}\\3x+8y+z=12&amp; \text{E2}\\4y+z=2&amp; \text{E3}\end{cases}\]</span> 用<span class="math inline">\(E2-3*E1\)</span>，再用<span class="math inline">\(E3-2*E2\)</span>，增广矩阵的变化： <span class="math display">\[\begin{bmatrix}   A &amp; b\\  \end{bmatrix}=\begin{bmatrix}   1 &amp; 2 &amp; 1 &amp; 2\\   3 &amp; 8 &amp; 1 &amp; 12\\   0 &amp; 4 &amp; 1 &amp; 2  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 1 &amp; 2\\   0 &amp; 2 &amp; -2 &amp; 6\\   0 &amp; 4 &amp; 1 &amp; 2  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 2 &amp; 1 &amp; 2\\   0 &amp; 2 &amp; -2 &amp; 6\\   0 &amp; 0 &amp; 5 &amp; -10  \end{bmatrix}=\begin{bmatrix}   U &amp; c \\  \end{bmatrix}\]</span> 注意到变换过程中<span class="math inline">\(A\)</span>的pivots(主对角线元素)均不为0。 接着可以得到消元后的方程组： <span class="math display">\[\begin{cases}x+2y+z=2&amp; \text{}\\2y-2z=6&amp; \text{}\\5z=-10&amp; \text{}\end{cases}\]</span> 从最后一个方程解起，并不断<strong>回代</strong>，就可以求得<span class="math inline">\((x,y,z)\)</span>的值。</p><p>如果回顾刚才的变换过程，并且用矩阵形式去表示： 第一步：将<span class="math inline">\((2,1)\)</span>位置的值变0，即<span class="math inline">\(E2-3*E1\)</span>： <span class="math display">\[E_{21}A=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   -3 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}\begin{bmatrix}   1 &amp; 2 &amp; 1\\   3 &amp; 8 &amp; 1\\   0 &amp; 4 &amp; 1  \end{bmatrix}=\begin{bmatrix}   1 &amp; 2 &amp; 1\\   0 &amp; 2 &amp; -2\\   0 &amp; 4 &amp; 1  \end{bmatrix}  \]</span> 其实这个过程就是对单位阵做相同的行变换得到<span class="math inline">\(E_{21}\)</span>，<span class="math inline">\(E_{21}\)</span>的第一行乘以<span class="math inline">\(A\)</span>本质上就是<span class="math inline">\(A\)</span>的各行的线性组合：<span class="math inline">\(1*row1+0*row2+0*row3=[1\ 2\ 1]\)</span>；同样的，<span class="math inline">\(E_{21}\)</span>的第二行乘以<span class="math inline">\(A\)</span>本质上还是<span class="math inline">\(A\)</span>的各行的线性组合：<span class="math inline">\(-3*row1+1*row2+0*row3=[0\ 2\ -2]\)</span>... 第二步：将<span class="math inline">\((3,2)\)</span>位置的值变0，即<span class="math inline">\(E3-2*E2\)</span>： <span class="math display">\[E_{32}(E_{21}A)=\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0\\   0 &amp; -2 &amp; 1   \end{bmatrix}\begin{bmatrix}   1 &amp; 2 &amp; 1\\   0 &amp; 2 &amp; -2\\   0 &amp; 4 &amp; 1  \end{bmatrix}=\begin{bmatrix}   1 &amp; 2 &amp; 1\\   0 &amp; 2 &amp; -2\\   0 &amp; 0 &amp; 5  \end{bmatrix}  \]</span> 这个过程就是对单位阵做相同的行变换得到<span class="math inline">\(E_{32}\)</span>，<span class="math inline">\(E_{32}\)</span>的第三行乘以<span class="math inline">\((E_{21}A)\)</span>本质上就是<span class="math inline">\((E_{21}A)\)</span>的各行的线性组合：<span class="math inline">\(0*row1+(-2*row2)+1*row3=[0\ 0\ 5]\)</span>； 所以整个变换过程用矩阵形式表示： <span class="math display">\[E_{32}(E_{21}A)=U-&gt;(E_{32}E_{21})A=U(矩阵乘法结合律成立，交换律不成立)\]</span> 非常重要的结论就是<strong>左行右列</strong>： <span class="math display">\[\begin{bmatrix}   1 &amp; 2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}  row1\\  row2\\  row3  \end{bmatrix}=1*row1+2*row2+7*row3(矩阵左乘向量即行向量的线性组合)  \]</span> <span class="math display">\[\begin{bmatrix}   col1 &amp; col2 &amp; col3\\  \end{bmatrix}\begin{bmatrix}  3\\  4\\  5  \end{bmatrix}=3*col1+4*col2+5*col3(矩阵右乘向量即列向量的线性组合)  \]</span> <strong>线性组合</strong>的思想也是矩阵乘法的核心，再举一例： <span class="math display">\[\begin{bmatrix}   0 &amp; 1\\   1 &amp; 0\\  \end{bmatrix}\begin{bmatrix}   a &amp; b\\   c &amp; d\\  \end{bmatrix}=\begin{bmatrix}   c &amp; d\\   a &amp; b\\  \end{bmatrix}  \]</span> 结果的第一行即：<span class="math inline">\(0*[a\ b]+1*[c\ d]\)</span>，第二行即：<span class="math inline">\(1*[a\ b]+0*[c\ d]\)</span>，交换行。 类似的，交换列(<strong>列向量的线性组合</strong>)： <span class="math display">\[\begin{bmatrix}   a &amp; b\\   c &amp; d\\  \end{bmatrix}\begin{bmatrix}   0 &amp; 1\\   1 &amp; 0\\  \end{bmatrix}=\begin{bmatrix}   b &amp; a\\   d &amp; c\\  \end{bmatrix}  \]</span> ## 乘法和逆矩阵 回顾上一节的内容，对于<span class="math inline">\(AB=C\)</span>： <span class="math inline">\(C\)</span>的第<span class="math inline">\(i\)</span>列是<span class="math inline">\(A\)</span>的列向量的线性组合，组合系数即是<span class="math inline">\(B\)</span>对应的列<span class="math inline">\(col_i\)</span>，即：<span class="math inline">\(A*col_i\)</span>； <span class="math inline">\(C\)</span>的第<span class="math inline">\(i\)</span>行是<span class="math inline">\(B\)</span>的行向量的线性组合，组合系数即是<span class="math inline">\(A\)</span>对应的行<span class="math inline">\(row_i\)</span>，即：<span class="math inline">\(row_i*B\)</span>。 从这点出发，对于任意的矩阵乘法，都可以有： <span class="math display">\[AB=\Sigma(col_A*row_B)\]</span> 举例来看： <span class="math display">\[\begin{bmatrix}   2 &amp; 7\\   3 &amp; 8\\   4 &amp; 9  \end{bmatrix}\begin{bmatrix}   1 &amp; 6\\   0 &amp; 0\\  \end{bmatrix}=\begin{bmatrix}   2\\   3\\   4  \end{bmatrix}\begin{bmatrix}   1 &amp; 6  \end{bmatrix}+\begin{bmatrix}   7\\   8\\   9  \end{bmatrix}\begin{bmatrix}   0 &amp; 0  \end{bmatrix}  \]</span> 再来看看<span class="math inline">\(A=\begin{bmatrix}  1 &amp; 3\\  2 &amp; 6\\  \end{bmatrix}\)</span>，能否找到一个<strong>非零向量</strong><span class="math inline">\(x\)</span>，使得<span class="math inline">\(Ax=0\)</span>呢？ 答案是肯定的，因为<span class="math inline">\(A\)</span>是不可逆的。 解决不可逆这种特殊情况之前，先搞定足够好(可逆)的矩阵： <span class="math display">\[AA^{-1}=\begin{bmatrix}   1 &amp; 3\\   2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}   a &amp; c\\   b &amp; d\\  \end{bmatrix}=\begin{bmatrix}   1 &amp; 0\\   0 &amp; 1\\  \end{bmatrix}=I  \]</span> 要求出<span class="math inline">\(A^{-1}\)</span>，从列向量线性组合的角度： <span class="math display">\[\begin{bmatrix}   1 &amp; 3\\   2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}   a\\   b\\  \end{bmatrix}=\begin{bmatrix}   1\\   0\\  \end{bmatrix}，\begin{bmatrix}   1 &amp; 3\\   2 &amp; 7\\  \end{bmatrix}\begin{bmatrix}   c\\   d\\  \end{bmatrix}=\begin{bmatrix}   0\\   1\\  \end{bmatrix}  \]</span> 此时又回到了消元法解方程组，不过这里我们可以偷个懒，用Gauss-Jordan一次解出2个方程组： <span class="math display">\[\begin{bmatrix}   A &amp; I\\  \end{bmatrix}=\begin{bmatrix}   1 &amp; 3 &amp; 1 &amp; 0\\   2 &amp; 7 &amp; 0 &amp; 1\\  \end{bmatrix}-&gt;\begin{bmatrix}   1 &amp; 0 &amp; 7 &amp; -3\\   0 &amp; 1 &amp; -2 &amp; 1\\  \end{bmatrix}=\begin{bmatrix}   I &amp; A^{-1}\\  \end{bmatrix}  \]</span> 再次回顾上一节的内容：消元过程中所作的变换都可以通过<strong>左乘初等阵</strong>实现，将变换过程中所有初等阵的乘积记作<span class="math inline">\(E\)</span>，我们得到了一个激动人心的求解逆矩阵的方法： <span class="math display">\[E\begin{bmatrix}   A &amp; I\\  \end{bmatrix}=\begin{bmatrix}   I &amp; A^{-1}\\  \end{bmatrix}  \]</span> 因为经过变换，<span class="math inline">\(EA=I\)</span>，所以<span class="math inline">\(E=A^{-1}\)</span>，比国内的伴随矩阵不知道好到哪里去了。 ## A的LU分解 在了解为什么进行LU分解之前，我们先来看看高斯消元的时间复杂度： 回想整个过程，如果矩阵<span class="math inline">\(A\)</span>有<span class="math inline">\(n\)</span>个元素，不难发现耗费的时间<span class="math inline">\(n^2+(n-1)^2+...+1^2\approx \frac{n^3}{3}\)</span>，即<span class="math inline">\(O(n^3)\)</span>；对于右侧的列向量<span class="math inline">\(b(有m个元素)\)</span>，耗费<span class="math inline">\(O(m^2)\)</span>。 在很多时候，求解<span class="math inline">\(Ax=b\)</span>时矩阵<span class="math inline">\(A\)</span>是不变的，只有<span class="math inline">\(b\)</span>在变化，如果每次都用消元法去解，每次的复杂度都会是<span class="math inline">\(O(n^3)\)</span>，那么如果采用LU分解<span class="math inline">\(A=LU\)</span>，只要预先准备好<strong>下三角矩阵</strong><span class="math inline">\(L\)</span>和<strong>上三角矩阵</strong><span class="math inline">\(U\)</span>，这一步复杂度<span class="math inline">\(O(n^3)\)</span>，以后求解时：<span class="math inline">\(Ax=LUx=b\)</span>，只要求解：</p><ul><li><span class="math inline">\(Ly=b\)</span>，得到<span class="math inline">\(y\)</span>，<span class="math inline">\(O(n^2)\)</span>；</li><li><span class="math inline">\(Ux=y\)</span>，得到<span class="math inline">\(x\)</span>，<span class="math inline">\(O(n^2)\)</span>。 以后每次求解只需要<span class="math inline">\(O(n^2)\)</span>，大大提高了效率。</li></ul><p>明白了原因后，我们看看具体的过程： 我们知道，消元过程中矩阵<span class="math inline">\(A\)</span>可以通过左乘矩阵<span class="math inline">\(E\)</span>变为上三角矩阵<span class="math inline">\(U\)</span>，即<span class="math inline">\(EA=U\)</span>，那么<span class="math inline">\(A=E^{-1}U=LU\)</span>。 举例来看： 如果<span class="math inline">\(E_{32}E_{21}A=U\)</span>，那么<span class="math inline">\(A=E_{21}^{-1}E_{32}^{-1}U=LU\)</span>，假设<span class="math inline">\(E_{32}=\begin{bmatrix}  1 &amp; 0 &amp; 0\\  0 &amp; 1 &amp; 0\\  0 &amp; -5 &amp; 1  \end{bmatrix}\)</span>，<span class="math inline">\(E_{21}=\begin{bmatrix}  1 &amp; 0 &amp; 0\\  -2 &amp; 1 &amp; 0\\  0 &amp; 0 &amp; 1  \end{bmatrix}\)</span>，那么求<span class="math inline">\(L\)</span>即是求<span class="math inline">\(E_{21}^{-1}和E_{32}^{-1}\)</span>，当然可以通过上一节中的拼单位阵来求解，但是对于初等阵，可以不用这么麻烦，以<span class="math inline">\(E_{21}^{-1}\)</span>为例： 这个变换是<span class="math inline">\(row2-2*row1\)</span>，那么<strong>逆矩阵就是要undo这个操作</strong>，即<span class="math inline">\(row2+2*row1\)</span>，所以<span class="math inline">\(E_{21}^{-1}=\begin{bmatrix}  1 &amp; 0 &amp; 0\\  2 &amp; 1 &amp; 0\\  0 &amp; 0 &amp; 1  \end{bmatrix}\)</span>，同理可得<span class="math inline">\(E_{32}^{-1}=\begin{bmatrix}  1 &amp; 0 &amp; 0\\  0 &amp; 1 &amp; 0\\  0 &amp; 5 &amp; 1  \end{bmatrix}\)</span>，按照<strong>列线性组合</strong>的思想，<span class="math inline">\(L=E_{21}^{-1}E_{32}^{-1}=\begin{bmatrix}  1 &amp; 0 &amp; 0\\  2 &amp; 1 &amp; 0\\  0 &amp; 5 &amp; 1  \end{bmatrix}\)</span>。 ## 置换 前面的消元过程中，当主元为0时，可能需要<strong>交换行</strong>来使消元继续下去，交换行的操作可以通过左乘置换矩阵实现，即<span class="math inline">\(PA=LU\)</span>，前提是<span class="math inline">\(A\)</span>可逆，否则再怎么交换，都会有零行。 3阶矩阵的置换可以有<span class="math inline">\(3!=6\)</span>种： <span class="math display">\[\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}、\begin{bmatrix}   0 &amp; 1 &amp; 0\\   1 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 1  \end{bmatrix}、\begin{bmatrix}   0 &amp; 0 &amp; 1\\   0 &amp; 1 &amp; 0\\   1 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   1 &amp; 0 &amp; 0\\   0 &amp; 0 &amp; 1\\   0 &amp; 1 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 1 &amp; 0\\   0 &amp; 0 &amp; 1\\   1 &amp; 0 &amp; 0  \end{bmatrix}、\begin{bmatrix}   0 &amp; 0 &amp; 1\\   1 &amp; 0 &amp; 0\\   0 &amp; 1 &amp; 0  \end{bmatrix}\]</span> 置换矩阵一个重要性质是：<span class="math inline">\(P^T=P^{-1}\)</span>。 ## 作业 Suppose <span class="math inline">\(A = \begin{pmatrix} a &amp; b \\ c &amp; d \end{pmatrix}\)</span> is factored into a 2x2 rotation <span class="math inline">\(Q=\begin{pmatrix} \cos \theta &amp; -\sin \theta \\ \sin \theta &amp;\cos \theta \end{pmatrix}\)</span> times a 2x2 lower triangular matrix <span class="math inline">\(L=\begin{pmatrix} x &amp; 0\\ y &amp; z \end{pmatrix}\)</span>. Write <span class="math inline">\(x,y,z\)</span> and <span class="math inline">\(θ\)</span> in terms of <span class="math inline">\(a,b,c\)</span> and <span class="math inline">\(d\)</span>. 这道题不难，但容易漏解： 容易得到：<span class="math inline">\(\begin{pmatrix} x\cos{\theta}-y\sin{\theta} &amp; -z\sin{\theta} \\ x\sin{\theta}+y\cos{\theta} &amp; z\cos{\theta} \end{pmatrix} = \begin{pmatrix} a &amp; b\\ c &amp; d \end{pmatrix}\)</span>，故<span class="math inline">\(b^2+d^2 = z^2\)</span>。对于旋转矩阵，<span class="math inline">\(0\leq\theta\leq2\pi\)</span>。</p><ul><li><span class="math inline">\(z = \sqrt{b^2+d^2}\)</span>：<span class="math inline">\(\cos{\theta} = \frac{d}{\sqrt{b^2+d^2}},\sin{\theta} = -\frac{b}{\sqrt{b^2+d^2}}\)</span> 因为<span class="math inline">\(L=Q^{-1}A\)</span>： <span class="math display">\[\begin{pmatrix} \cos{\theta} &amp; \sin{\theta} \\ -\sin{\theta} &amp; \cos{\theta}\end{pmatrix}\begin{pmatrix} a &amp; b\\c &amp; d\end{pmatrix} = \begin{pmatrix}a\cos{\theta}+c\sin{\theta} &amp; b\cos{\theta}+d\sin{\theta} \\ -a\sin{\theta}+c\cos{\theta} &amp; -b\sin{\theta}+d\cos{\theta} \end{pmatrix} = \begin{pmatrix} x &amp; 0 \\ y &amp; z\end{pmatrix}\]</span> 所以有： <span class="math display">\[x = \frac{ad - bc}{\sqrt{b^2+d^2}}, y = \frac{ab+cd}{\sqrt{b^2+d^2}}, \theta = \begin{cases}\arccos\frac{d}{\sqrt{b^2+d^2}},b\le0\\\\\arccos{\frac{d}{\sqrt{b^2+d^2}}}+\pi, b&gt;0\end{cases}\]</span> <span class="math inline">\(\arccos\theta\)</span>的值域是<span class="math inline">\([0,\pi]\)</span>。</li><li><span class="math inline">\(z = -\sqrt{b^2+d^2}\)</span>：<span class="math inline">\(\cos{\theta} = -\frac{d}{\sqrt{b^2+d^2}},\sin{\theta} = \frac{b}{\sqrt{b^2+d^2}}\)</span> <span class="math display">\[x = \frac{- ad + bc}{\sqrt{b^2+d^2}}, y = -\frac{ab+cd}{\sqrt{b^2+d^2}}, \theta = \begin{cases}2\pi-\arccos\frac{d}{\sqrt{b^2+d^2}},b\le0\\\pi-\arccos{\frac{d}{\sqrt{b^2+d^2}}}, b&gt;0\end{cases}\]</span></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIT Linear Algebra#0 Introduction to Vectors</title>
      <link href="/2020/05/22/MIT%20Linear%20Algebra#0%20Introduction%20to%20Vectors/"/>
      <url>/2020/05/22/MIT%20Linear%20Algebra#0%20Introduction%20to%20Vectors/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><em>前言</em></h4><p><em>线性代数应该是大部分工科和商科同学的必修课，然而很不幸的是：国内的线代教学简直一团糟。如同国内大学的其他课一样，一上来就是一堆不知所云的概念、定义和性质，然后是没有什么道理的计算技巧训练，期末考完试一切结束。如果你有时间看看MIT的18.06，相信绝对会刷新你对这个学科的认知，Gilbert Strang完美遵循了现实生活中遇到了什么问题、为什么会有这些问题、该如何解决、更好的方法这一教学链条。循循善诱、环环相扣，你会觉得上课、学习数学是一种享受。</em> #### <em>方式</em> <em>这门课我强烈建议去看Gil老爷子的视频，2020年的Lecture真心觉得不太良心，看完视频可以做做20版的作业加深理解。 我会在Blog中专门记录这门课的笔记和理解，并且覆盖一些有趣的作业题。废话不多说，开始吧~</em></p><hr /><h2 id="笔记">笔记</h2><p>课程的引入是通过初中的二元一次方程组： <span class="math display">\[\begin{cases}2x-y=0&amp; \text{}\\-x+2y=3&amp; \text{}\end{cases}\]</span> 从几何上来看：就是二维平面上两条直线相交于<span class="math inline">\((1,2)\)</span>。 从Row Picture来看：可以很直观地写作： <span class="math display">\[\begin{bmatrix}   2 &amp; -1 \\   -1 &amp; 2  \end{bmatrix}\begin{bmatrix}   x \\   y  \end{bmatrix}=\begin{bmatrix}   0 \\   3  \end{bmatrix}\]</span> 这种思考方式也是国内灌输的，第一行乘以第一列得到0，第二行乘以第一列得到3，但其实更重要的是从<strong>向量(列)的线性组合</strong>角度去考虑： <span class="math display">\[x\begin{bmatrix}   2 \\   -1  \end{bmatrix}+y\begin{bmatrix}   -1 \\   2  \end{bmatrix}=\begin{bmatrix}   0 \\   3  \end{bmatrix}\]</span> 这样从几何上解释就是：有两个向量<span class="math inline">\(\begin{bmatrix}  2 \\  -1  \end{bmatrix}\)</span>、<span class="math inline">\(\begin{bmatrix}  -1 \\  2  \end{bmatrix}\)</span>，要找到某个组合<span class="math inline">\((x,y)\)</span>可以得到向量<span class="math inline">\(\begin{bmatrix}  0 \\  3  \end{bmatrix}\)</span>。 类似地，三元一次方程组也可以从列向量线性组合的角度考虑，几何上扩展到三维空间。 由此推广到更加一般的情形：<span class="math inline">\(Ax=b\)</span>，自然而然地，我们想知道：是否对于任意的<span class="math inline">\(b\)</span>，此方程都有解？或者换句话：对于三元一次方程组，<strong>列向量的线性组合是否能充满整个三维空间？</strong> 如果三个向量共面，那么最多只能生成一个平面，也就是不能保证可以生成任意的<span class="math inline">\(b\)</span>(有解)。后面会知道，有解的条件就是<span class="math inline">\(A\)</span><strong>可逆</strong>。 这节课最重要的一点就是要用<strong>Column Picture去思考<span class="math inline">\(Ax=b\)</span></strong>，为了加深理解，再举例： <span class="math display">\[\begin{bmatrix}   2 &amp; 5 \\   1 &amp; 3  \end{bmatrix}\begin{bmatrix}   1 \\   2  \end{bmatrix}=1*\begin{bmatrix}   2 \\   1  \end{bmatrix}+2*\begin{bmatrix}   5 \\   3  \end{bmatrix}=\begin{bmatrix}   12 \\   7  \end{bmatrix}\]</span> ## 作业</p><ol type="1"><li>Draw two non-colinear vectors v and w, and the region that consists of all combinations cv+dw where 0 ≤ c ≤ 1 and 0 ≤ d ≤ 1. Now consider the linear transformation of the unit square (all points (c,d) with 0 ≤ c ≤ 1 and 0 ≤ d ≤ 1) by the 2x2 matrix with first column v and second column w. Are these two regions the same? 答：两个区域相同。 对<span class="math inline">\((c,d)\)</span>做线性变换，也即 <span class="math display">\[\begin{bmatrix}   v&amp;w \\  \end{bmatrix}\begin{bmatrix}   c \\   d  \end{bmatrix}=cv+dw(矩阵乘以列向量，即矩阵各列的线性组合)\]</span></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>变态的高等教育</title>
      <link href="/2020/05/21/%E5%8F%98%E6%80%81%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%99%E8%82%B2/"/>
      <url>/2020/05/21/%E5%8F%98%E6%80%81%E7%9A%84%E9%AB%98%E7%AD%89%E6%95%99%E8%82%B2/</url>
      
        <content type="html"><![CDATA[<p>作为一个局内人，经历了四年的本科教育，后来接触了美帝学校的课程，对比之下越发觉得差距天大。丝毫不夸张地说，随便找一门美帝TOP50学校的公开课，质量都可以吊打国内99%的学校课程。 ## 重蹈覆辙 一届又一届的学生进入高校，被统一的流程加工几年之后扔进市场，工厂会召回次品，但没人会为学生负责，这样的故事仍然在不断上演，以我所在的EE为例：</p><ul><li>四年中要上若干门思政课，并且浪费很多时间去写作业、开会讨论、做pre。XJTU的这些课期末考试都是闭卷，君不见考前的图书馆走廊，到处都是拿着《毛概》笔记认真背书的同学，我曾经也是其中的一员，看似司空见惯的事情现在想来真的非常荒诞。</li><li>每学期动辄10几门课、30几个学分。大三的第一学期堆积了5门硬核专业课，外加电设和FPGA实验，以及不知道为什么存在的金工实习，更遑论还有选修课。这样的培养方案使得学生根本没有时间和精力仔细钻研，能应付完平时作业、大作业和期末考已经不易。</li><li>更为严重的是：专业课上时常可以见到PPT Reader般的老师，往往这类老师对签到这种事情非常在乎，好像在维护自己的权威，除了这些，看不出他/她对课程有什么见解。PPT往往都是10几年前的版本，排版、错别字惨不忍睹，就这样一代代流传下来，还是在EE/CS这样更新极快的学科中。至今记忆犹新的微机原理的某个女老师，上课总是在炫耀自己去THU学习人家的计组课程，要做一台计算机云云...这位老师上课时竟然将汇编程序的后缀写作.acm。。。</li><li>关于实验课，更是无力吐槽，你的成绩基本取决于实验报告的长度，所以内卷之风日益兴起，甚至一个小小的物理实验，有同学写出了20多页的报告。。。试想如果老师仔细评阅每份报告，自然不会按照长度打分，但是老师还要忙着做很多重要的事情呢？</li></ul><p>这样的结果就是本科学的东西考完试就还回去了，下次要用还得重新学，浪费几倍的时间重新学习，这也是我最讨厌的地方。</p><h2 id="追根溯源">追根溯源</h2><p>曾经我觉得：本科教育的失败只是某个学校做的不好，也可能只是西部高校做得不够好，可是随着很多很多不可思议的事情发生，我开始怀疑即使是顶尖大学也会烂到一塌糊涂。如果你有兴趣搜索这些内容，你会看到哪怕THU、SJTU这些国内名校也是如此，只是恶劣的程度有所不同而已。所以我一直觉得交大在我黄金般的4年里没起到什么作用，甚至起的是负面作用，我没有斯德哥尔摩情节，不会感谢学校提供了如此巨大的阻力，是为了锻炼学生。</p><ul><li>本科教育并不会影响职称评定，没有相应的考核要求，不如灌paper、拉项目来的实在。教学评估也是可笑，只会评估课堂出勤率高不高、实验报告写得长不长，压根不会有领导在乎课堂质量。</li><li>钱，还是钱：我上过Harvard的计算机导论课，整个课程有70+ TA，还有Amazon的计算资源免费支持，这样精心设计的课程怎么可能不是翘楚？</li></ul><h2 id="惩前毖后">惩前毖后</h2><p>怪不得在《上海交通大学学生生存手册》中，有学长疾呼： &gt; 国内绝大部分大学的本科教育，不是濒临崩溃，而是早已崩溃。</p><p>我自己意识到这一点实在太晚，穷屌丝也读不起master::&gt;_&lt;:: 我很感谢国家的政策，让我掏很少的钱就能接触到大学教育。但是希望赶路者能意识到：国内的高等教育就是shit，如果按照学校的计划走下来，进社会迟早被安排地明明白白，越努力，越傻逼。</p><p>Sad but true，研究生的教育只会更加差劲，我不想再被继续残害下去，说说自己的打算(在达到毕业要求的前提下)：</p><ul><li>我不否认有大神可以从课堂上学会关键知识，但是对于我们普通人来说，只能把有限的时间用来做出最好的选择。适合自己的方式才是最好的。</li><li>能不去的课就不去了，尽量选水课(不签到/考试水/给分高)。用尽可能多的<strong>自由支配时间</strong>学习更加优质的教学资源。</li><li>和老师交流要看情况，主要还是科研方向问题。</li></ul><h2 id="他山之石">他山之石</h2><p>我只列举一些我看到过的观点，并不代表个人看法。</p><ul><li><a href="http://www.houxiaodi.com/assets/misc/manual.pdf">《上海交通大学学生生存手册》</a></li><li><a href="https://blog.csdn.net/wangkechuang/article/details/8125062">清华梦的粉碎——写给清华大学的退学申请</a></li><li><a href="https://www.zhihu.com/question/60444527/answer/267271327">西安交通大学和其它几所2+7相比有什么优势和不足？</a></li></ul><blockquote><p>本来不想来打扰准备昏睡至死的人。</p><p>如果只是XJTUer来知乎自问自答寻求廉价的满足感，我从来不会浪费自己的时间来反驳他们。毕竟他们抱着发霉的C9头衔和上世纪的择校观念自娱自乐开心就好。</p><p>但是看到题主只是一名高中生，并且已经成功意识到了XJTU既存的缺陷（我当年为什么没有获得这些信息？！），应该是一位相当重视自己未来并且希望它最优的人。实在不希望那些高票回答毁人不倦。</p><p>不错，你确实应该对排名有一个清醒的认识：不要再拿XJTU和清北华五以及华科北航等学校比，它不配。生源/就业质量/出国率这些硬参数XJTU全方面垫底。这时候会有XJTUer跳出来说三大奖排名才是货真价实的比较，那么根据<a href="https://www.sohu.com/a/154387981_111981">近五年各大高校国家“三大奖”</a>中国农大排名11名，中科大排名19落后于苏州大学江南大学等高校，请问这个排名货真价实在哪里？每种排名都有一些对应的“利好高校”，三大奖之于XJTU，类似武书连排名之于WHU。就算前者更客观，也只不过是一方面。更何况WHU都不拿武书连说事儿了，XJTU还在西部一隅拿三大奖自慰呢！</p><p>XJTU的腐朽、低效、没落，就算是孜孜不倦来洗地的各位，想必也是深有体会吧。彩虹楼甲醛、彭康楼甲醛、女生宿舍和主楼女厕偷窥偷拍事件、xx书院房顶掉落，还有很多我暂时没回忆起来的，以上这些，XJTU官方有过任何一个让人满意的答复吗？可笑的是，很多XJTUer作为受害者身边的人甚至受害者自身，还在试图说服自己去对XJTU“培养一种满足和自豪感”。就我个人来说，很多小事都折射着XJTU的低效和颓败。</p><p>1）上学期办英文成绩单，学校教务处的人告知要先在哪里开原始成绩单，然后找谁和谁签字，等费劲周折终于完成，回来盖章的时候，又说按规定今天不行，下周一下午来吧。结果又浪费了好几天（后来才知道，给教务处那个负责盖章的求求情就能立刻完成，呵呵）。</p><p>2）大三的暑期实习答辩，基本水出天际，只要你的实习盖章签字没问题。同期去XJTU钦定的陕西鼓风机动力集团和渭河电厂打扑克玩手机的同学，答辩就算千篇一律漏洞百出，照样稳过。当时本人没有去学校“偏好”的公司实习，答辩被刁难了近一个月。据我所知还有机械那边的学长大三暑假在DJI实习，结果回来学院死活不认可，被迫大四暑假补上XJTU认证的不知道在干嘛的实习。那些响应XJTU号召去签约的野鸡公司划水的乖乖同学们，能不能通过DJI面试都是问题。以及有大神翘课去MSRA科研，期末考的也很好，但是XJTU不给登成绩的事就不细说了。</p><p>3）老师们绝大部分都是重科研轻本科教学，时不时会遇到PPT朗读员般的极品老师。不过这个貌似是中国高校通病，XJTU具有也是理所当然？？XJTUer，你们是这么认为的吗？另外，科研也不是你想象的那样，50%以上是论文灌水+项目拉钱，极少数是高质量研究。</p><p>4）本学期老师给的一门CS相关课程的PPT，拿到一看，最后修改时间2007年，十年过去了，连页脚的日期，正文的错别字都没有变，就这样年复一年的给陕西省一流大学的学生们使用着，而且还是CS这种更新极快的课程方向，让人忍俊不禁...</p><p>5）XJTU大部分老师都是本校本硕博一条龙的教育。一个开放的、优秀的、吸引人才的大学，这种情况不会这么严重。不信可以去美国的大学任何一个系的faculty list看一看，以及去中国东部的排名靠前的学校官网看看。另外，XJTU很多老师根本就不更新自己的主页，publications停留在几年前，甚至一些英文论文标题都有错词，总之不知道他们每天都在做些什么。</p><p>关于“XJTU这些年已经止颓了，正在稳步上升，你看创新港建的多好”这类说法，我只想说我们都是普通人，只能力争用有限的时间做出最优的选择。你不能把自己四年最宝贵的时间赌在一个未知数上。建了一堆大楼就改善了对本科生个体的关怀，也不现实。走出家乡去发达地区拥抱更多的机会和更广阔的视野，就算上了一个看起来不如XJTU的学校（也只是看起来不如而已），比起在知乎上埋头洗地的XJTUer来，你已经优秀太多了。</p><p>如果非要客观地介绍一下XJTU屈指可数的优势：</p><p>1.机械能动材料等传统工科科研实力强势（与本科生关系并不大，本科发顶会paper的是极少数）。如果确实热爱这方面的科研并且愿意忍受相对较低的工资，同类高校请选择XJTU。CS EE相关工科，选择北航北邮华科这些学校，不要选择XJTU。</p><p>2.目前还算在市中心，生活和交通便利。</p><p>最后的最后，你的选择权由你的高考成绩/自招成绩决定。 - <a href="https://www.zhihu.com/answer/437601713">如何评价西安交大计算机系？</a></p></blockquote><blockquote><p>看到很多人的批评，还是想多说两句，表达我的想法：</p><p>我从来都很感激西安交大，学校的补贴让我不用花钱出国交流，好心的老师给我写推荐信，学校的名声让我的简历能进入全国的大公司，2W元四年的学费让我收获了自认为超过100万的好处。</p><p>但是这都是我对学校本身的感激和爱戴，是学校或者是国家的好政策培养了我。而不是那些搞小山头的老师，僵化的管理人员，不尊重学生的制度。这些人现在越来越多，我认为并不配代表西安交大。我对这些毒瘤的批评也并不能代表对交大的否定。</p><p>交大计算机的培养计划确实存在着很大的问题，说交大计算机本科毕业不会写代码，我觉得完全没毛病，95%的学生四年下来写过的代码不会超过1000行，一半是for循环。剩下一半是在纸上写的。</p><p>其次我不同意也不想反驳如下的论点：“你来了交大就别BB，BB不如去复读”，“母校只允许自己黑，不能让别人说半句不是“，这基本等同于“你对政府不满就出国，不然老老实实受着”。</p><p>很多人都只是挑了西交计算机的缺点，这是十分有偏见的，本着为校争光的原则，在此列举一些西交计算机的优点：</p><p>1。西交计算机系的编程作业很少，给了学生们充分的自学时间。众所周知，计算机是一门自学的专业，很多三本的大神都是自学成才。而学校领导和老师们充分认识到了这一点，作业能出原题就出原题，能用笔写绝不用电脑，能让助教改绝不机考。比如一个下午就能写完一学期的C++作业，看了一学期mooc的数据结构，上机不到10个学时的操作系统。这对学生的自学能力提出了很高的要求，极大地提升了同学们的自学能力。</p><p>2。重视经典和原创。上课的教材能用本校就用本校的，能自己编就自己编，充分地体现了很多老师本人的风格和只可意会的专业水平。甚至体育都有自己本校的教材，印象中有太极拳等等，为了防止学生练武走火入魔，学校可谓用心良苦。PPT也都极其经典，有10年前的，5年前的，表现了尊重经典，坚持传统的精神。</p><p>3。必修很多看似与计算机无关的课，比如工程制图和生物实验等等。虽然国内很多知名高校，比如清华计算机是不修的，但是世界一流大学MIT，Caltech都是有生物必修课。这充分表现了西交与国际接轨，争做世界一流大学的决心。要知道生物作为21世纪的专业，可谓前途无量。虽然西交除了生化实验班之外的生物系学生大多转行了，但未来需要的是计算机和生物的交叉人才，正需要计算机系的学生去开拓和发展。</p><p>4。计算机系经常受到自动化某所的强烈关怀和支持。前任校长郑南宁深刻地意识到，集中力量才能办大事。于是常年把电信学院的经费奋力拨到自动化系，通过自动化系的发展反过来带动计算机系，正契合了天朝早年“先富带动后富”的理念。可以预料，通过院系之间的互帮互助，计算机系必将获得长足的发展和进步。</p><p>5。上课严格考勤。除了某些特殊关照班级之外基本不能出去实习／科研，这充分体现了学校领导关心同学的心。要知道西交计算机教学水平一流，出去实习能学到什么？对于拿到了某些实习offer的同学，学校就会百般刁难，参见<a href="https://www.zhihu.com/question/281289820">如何看待西安交通大学不断地被黑?</a>某回答，这充分锻炼了同学们艰苦奋斗，逆境求生的品质，而这种精神在同学毕业之后几十年的人生都是非常重要的，凸显了领导眼光的长远。</p><p>6。在编程作业很少的同时，实验和考试则是非常硬核的。楼上有人提到计算机课程电类太多，其实有点狭隘，不才在清华计算机系学习过一年，模电下半学期的电路分析和数电的“数字点亮人生”实验也都十分繁重，而信号与系统是计算机一小半研究方向的必须基础之一，不学就开玩笑了，所以说并没有黑到点子上。而西交的考试要求则更高，动辄成吨的概念题，对记忆力的要求极高，这不仅体现了学校希望将计算机这门学科文科化的创新精神，更是锻炼了同学们的背诵能力。试想别的学校同学还在对着C++官方文档写代码的时候，西交的同学们已经背完了文档，这必将极大地提升同学们写代码的速度和水平。</p><p>7。新任教师基本是本校博士，充分体现了学校的团结。参考<a href="http://jfzx.xjtu.edu.cn/info/1006/3210.htm">最近三年的新入职教师</a>，之前三年的计算机系，软院的老师多为本校土博，在现在很多二本都要求海归博士的大背景下，西交还能有如此魄力，团结一心，不崇洋媚外，这是何等难能可贵的精神！</p><p>8。在以上这些令人振奋的进步之余，西交的创新港也在如火如荼地建设着。2个月前据某前去规划建设的老师称，一共近5000亩地租出去了3200亩，剩下1800亩尚在建设之中。不得不说学校领导眼光之长远，懂得把经济利益放在第一位，先赚钱再建设，这样才有长远的发展。可想而知，假以时日创新港必将成为下一个曲江校区，为西交之崛起增光添彩。</p><p>以上只列举了西交计算机众多优点中的几个，还有太多可圈可点之处，在计算机学科蓬勃发展的今天，西交计算机必将成为国内一流，享誉世界！</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Inflation</title>
      <link href="/2020/05/20/Inflation/"/>
      <url>/2020/05/20/Inflation/</url>
      
        <content type="html"><![CDATA[<p>虽然以前辅修过金融学，但是对于许多内容还是一知半解，也很难形成体系。最近又看了一些资料，就作为笔记记录在此。 ## 定义 Wikipedia对于通货膨胀的定义是：</p><blockquote><p>In economics, inflation is a sustained increase in the general price level of goods and services in an economy over a period of time. When the general price level rises, each unit of currency buys fewer goods and services; consequently, inflation reflects a reduction in the purchasing power per unit of money - a loss of real value in the medium of exchange and unit of account within the economy.</p></blockquote><p>直观来看，就是因为货币发行量大于实际流通中所需的货币量，单位货币购买力下降，<strong>物价持续上升</strong>。 那么印多少钱合适呢？有这样一个式子：<span class="math display">\[流通中所需的货币量=\frac{商品价格总额}{流通次数}\]</span> 举例来看：A用1元买了B的面包，B用这一元买了C的牛奶，C用这一元买了A的水果。面包、牛奶、水果的价格总额是3元，流通了3次，所以实际只需要1元就够了。 ## 作用 适当的通胀率(可以用CPI衡量)是可以促进经济发展的，比如适当的物价上涨，你当然希望立即就去购买商品，而不是等它涨价之后再去购买，这样就刺激了经济发展。 相反，如果通胀很严重(一般认为大于2%)，尤其是想要通过货币超发刺激经济(货币型通胀)，控制不好就可能成为下一个津巴布韦。 再来看看国内的一些例子：2008年全球经济危机，中国为了保持经济高速增长，向市场投放4万亿，货币供给大量增加，所以我总感觉08年之后物价就涨得有点快~地方政府为了拉动GDP，房价一路飙升。大家买不起？没关系，首付少一些，银行多放些贷款，过量放贷导致物价上升。 ## 例子 我们都知道：商品买的人越多，越火，价格也就越高。投机商就会借机涌入市场，因为即使不是刚需，我也可以买一些，等以后涨了再卖出去，这样就可以赚取差价套利。 随着刚需和投机商的大量涌入，需求持续增加，远远大于供给，价格继续增长。 涨到很多人凭个人收入都买不起，不论刚需还是投机者钱都不够了，怎么办？ 贷款。 银行钱也不够了，怎么办？ 开印钞机，大家需求这么旺盛，拉动经济的大好机会。 大家都有了钱，泡沫持续繁荣，价格越来越高，自己腰包里的钱没有涨，怎么办？只能自己少出一点，多向银行借点，这样等到超出个人的偿还能力，就是<strong>次贷</strong>。 地方政府、开发商和投机者赚得盆满钵满，大家一看，卧槽这么赚钱，都把钱扔进了房地产，制造业被挤压的没有生存空间。 当房价到顶，大家都绝望的时候，投机商就开始抛售，供给增加，需求减少，价格下跌，这很可能引发经济断崖式下跌，GDP没有了，银行的贷款无法收回，完蛋。 那么所谓的软着陆是什么？ 银行不准借给投机者，刚需的如果不还钱，加入黑名单。还要多把钱借给刚需，如果价格下跌，刚需的钱一定可以收回来。限购令、交税都是为了限制投机商进入。 但是房价还不能跌得太快，怎么办？刺激刚需：买房有补贴，首付继续降低。什么？这样还不买，好，不买房的不给上户口，子女不能上学，于是就只能为国接盘，谁的利益受到了损害，这是很明显的事情。这部分需求填补了投机者退出去的那部分，需求还在，就不会暴跌。渐渐地，泡沫消失，一切回归正常。但是这损害了未来的消费能力，再加上老龄化社会到来，前景不容乐观。 <a href="https://www.zhihu.com/question/19894997/answer/123847049">参考链接</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Image Filter and Recover</title>
      <link href="/2020/05/03/Image%20Filter%20and%20Recover/"/>
      <url>/2020/05/03/Image%20Filter%20and%20Recover/</url>
      
        <content type="html"><![CDATA[<p>这是CS50的第四次大作业，顺便学习了图像的入门知识。 ## 基础 黑白图(bitmap)的每个像素点只能取值0/1，1代表白色，0代表黑色。 常见的图片格式有JPEG/PNG/BMP，这些格式都支持RGB，每个像素点可以用多个bit表示，常见的是24-bit，红、绿、蓝分别由8bit表示，范围0~255。 BMP图的开始位置有两个header，第一个叫<code>BITMAPFILEHEADER</code>，14B；第二个叫<code>BITMAPINFOHEADER</code>，40B。接下来的每个像素点是按照BGR的顺序存储的。 ## 过滤器 Image Filter就是对原图的像素点的像素进行操作，得到一幅新图。主要有下面几种：</p><ul><li>Grayscale 将RGB图变为灰度图。将每个像素点的R/G/B的值改为相同，值越大，亮度越大。一般取三色的平均值。</li><li>Sepia 比较像怀旧滤镜，有很多算法可以做，主要就是对3种颜色乘一些系数，做一些加减运算。</li><li>Reflection 左右翻转。</li><li>Blur 图像模糊，对每个像素点的每种颜色，取其周围3*3格子的平均值。</li><li>Edges 边缘检测，可以用Sobel Operator去做： Blur是对周围的格子取平均，Sobel是求一个加权和，对于x和y方向，有两个kernel： <img src="https://img-blog.csdnimg.cn/20200502165239931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 对每个像素点的每种颜色，用周围3*3格子的对应颜色分别去乘Gx/Gy，得到加权和sumx/sumy。 以x为例，如果左右两边差不多，那么加权和接近0，否则得到一个大正数/负数，说明很有可能是<strong>两个物体的分界</strong>。 综合考虑x和y方向，取<span class="math inline">\(\sqrt{sumx^2+sumy^2}\)</span>，再四舍五入到0~255之间。 对于边缘的格子，可以做padding，围一圈全黑(0)的格子，相当于不用计算。 ## 图片恢复 JPEG的前三个字节分别是<code>0xff, 0xd8, 0xff</code>，第四个字节的前四位是<code>1110</code>，这些可以唯一标识JPEG文件。 记忆卡上所有图片是连续存储的，最小单位每块512B，不到一块的后面补0，不影响显示，每张图片可能占若干块。 可以每次读512B扔到buffer里，如果是jpeg，就将其写入新文件、继续读512B，直到遇到下一个jpeg。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Computational Geometry</title>
      <link href="/2020/04/20/Computational%20Geometry/"/>
      <url>/2020/04/20/Computational%20Geometry/</url>
      
        <content type="html"><![CDATA[<h2 id="矩形重叠">矩形重叠</h2><p>看过某司一道笔试题：给<span class="math inline">\(n\)</span>个矩形左下和右上坐标（不能斜放），求重叠最多处矩形个数。 这道题本身不难：可以遍历所有矩形边界组成的点，计算<strong>该点被多少矩形包围</strong>，从而选出最大值。 由此引申出一个问题：<strong>判断两个矩形重叠</strong>。</p><ul><li>如果正向思考，会有很多种情况：包含、重叠某个角、交叉... 那么如果逆向思考：什么情况两个矩形不重叠？无非就是<span class="math inline">\(A(p_1, p_2)\)</span>在<span class="math inline">\(B(p_3, p_4)\)</span>的上下左右： <span class="math display">\[(p_2.y&gt;=p_3.y)\vee(p_4.y&gt;=p_1.y)\vee(p_3.x&gt;=p_2.x)\vee(p_1.x&gt;=p_4.x)\]</span> 取反后用De Morgan's law化简就是重叠的情况： <span class="math display">\[(p_2.y&lt;p_3.y)\wedge(p_4.y&lt;p_1.y)\wedge(p_3.x&lt;p_2.x)\wedge(p_1.x&lt;p_4.x)\]</span> ## 线段交点 联立方程组求解当然没问题，也可以用几何的方法解： <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDQvMTI2MDU4MS0yMDIwMDQyMDA5Mjk1NTI0OS05MzA1Nzg4NjkucG5n?x-oss-process=image/format,png" /> 易知，<span class="math inline">\(\frac{AO}{BO}=\frac{AE}{BF}=\frac{S_{ACD}}{S_{BCD}}\)</span>，两个三角形面积可以用叉积求得，又<span class="math inline">\(\vec{AO}=\frac{AO}{AB}\vec{AB}=\frac{AO}{AO+BO}\vec{AB}\)</span>，所以<span class="math inline">\(\vec{O&#39;O}=\vec{O&#39;A}+\vec{AO}\)</span>，即可求得<span class="math inline">\(O\)</span>点坐标。 ## 线段覆盖 有若干线段<span class="math inline">\([l_i,r_i]\)</span>以及目标线段<span class="math inline">\([a,b]\)</span>，需要用尽可能多的线段去覆盖目标线段，且线段之间不相交，线段长度之和最小。 直观上看：我们的策略首先以长度为准则：显然不妥，选了黑的就不是最优 <img src="https://img-blog.csdnimg.cn/20200729213724839.png" alt="在这里插入图片描述" /> 按照起始点： <img src="https://img-blog.csdnimg.cn/20200729213754372.png" alt="在这里插入图片描述" /> 按照结束点：最优 <img src="https://img-blog.csdnimg.cn/20200729213857178.png" alt="在这里插入图片描述" /> 从前向后取区间，最小化对后面的影响，选择最早结束的区间。 ## 向量旋转 <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDQvMTI2MDU4MS0yMDIwMDQyMDA5NDU1Mzg4My0xOTgxNzI0NjU3LnBuZw?x-oss-process=image/format,png" /> 三角变换可得： <span class="math display">\[\vec b=(xcos\alpha-ysin\alpha,ycos\alpha+xsin\alpha)\]</span> ## 多边形面积 <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDQvMTI2MDU4MS0yMDIwMDQyMDEwMTQxNjU5NC0xMjc1OTkyNDExLnBuZw?x-oss-process=image/format,png" /> 三角剖分： <span class="math display">\[S_{ABCDEF}=\frac{\vec{OA}\times\vec{OB}+\vec{OB}\times\vec{OC}+...+\vec{OF}\times\vec{OA}}{2}\]</span> 即： <span class="math display">\[S=A_n\times A_1+\sum_{i=1}^{n-1}A_i\times A_{i+1}=x_ny_1-y_nx_1+\sum_{i=1}^{n-1}x_iy_{i+1}-y_ix_{i+1}\]</span> ## 凸包 包围所有给定点并且周长最小的多边形。</li></ul><p><img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229164832081-268323827.jpg" alt="image" /> 直接求不好算，需要旋转坐标轴： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229164921157-1565408775.png" alt="image" /> <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229164931460-670765424.png" alt="image" /> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloest</span>(<span class="params">self, x, y, l, w, yaw</span>):</span></span><br><span class="line">        <span class="comment"># 原始坐标系逆时针旋转theta = yaw - 90得到坐标系(xx,yy)</span></span><br><span class="line">        theta = math.radians(yaw - <span class="number">90</span>)</span><br><span class="line">        xx = x * math.cos(theta) + y * math.sin(theta)</span><br><span class="line">        yy = -x * math.sin(theta) + y * math.cos(theta)</span><br><span class="line"></span><br><span class="line">        points = [(xx + w / <span class="number">2</span>, yy + l / <span class="number">2</span>), (xx - w / <span class="number">2</span>, yy - l / <span class="number">2</span>), (xx + w / <span class="number">2</span>, yy - l / <span class="number">2</span>), (xx - w / <span class="number">2</span>, yy + l / <span class="number">2</span>)]</span><br><span class="line">        dis = [a ** <span class="number">2</span> + b ** <span class="number">2</span> <span class="keyword">for</span> a, b <span class="keyword">in</span> points]</span><br><span class="line">        ans = points[dis.index(<span class="built_in">min</span>(dis))]</span><br><span class="line">        ans_x = ans[<span class="number">0</span>] * math.cos(theta) - ans[<span class="number">1</span>] * math.sin(theta)</span><br><span class="line">        ans_y = ans[<span class="number">0</span>] * math.sin(theta) + ans[<span class="number">1</span>] * math.cos(theta)</span><br><span class="line">        <span class="keyword">return</span> ans_x, ans_y</span><br></pre></td></tr></table></figure></p><hr /><p><em>reference</em> <em><a href="https://zhuanlan.zhihu.com/p/68617952">洛谷日报#142 计算几何初步</a></em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW</title>
      <link href="/2020/04/13/INTERVIEW%20#5/"/>
      <url>/2020/04/13/INTERVIEW%20#5/</url>
      
        <content type="html"><![CDATA[<h2 id="笔试">笔试</h2><p>150min，3题，每题100分，自己果然还是个蒟蒻呢~ 最近状态好差，虽然做了一些题，但还是考得稀烂，大概有几点需要加强：</p><ul><li><strong>独立</strong>做题，不要一边看板子一边写代码，更不要一开始就看题解；</li><li>对之前研究过的一些<strong>专项模板</strong>，要非常熟练敲出来；</li><li>“题海”战术要继续，薄弱算法要<strong>专项练习</strong>：即使内推，也免不了笔试，保持手感很重要。</li></ul><p>先补下题： ## No. 1 <img src="https://img-blog.csdnimg.cn/20200413151415498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> Pass 90% 开始觉得BFS可以做，但不知道怎么写，于是转去从<code>(x-l,y-l)</code>遍历到<code>(x+l,y+l)</code>，写了一下发现<code>l</code>会变，下一轮循环遍历范围可能增大，不知道怎么写下去，又转去DFS，因为DFS每一次递归都可以自动更改<code>l</code>的值，不知道为毛没有AC。 其实只要每一次都搜索整个图，去吃满足条件的补给品，直到<strong>剑的长度不变</strong>。 我TM竟然没想到用长度作为终止条件，而且暴力时候太谨慎，不敢把整个图过一遍(只有500*500的数据范围啊，蠢哭了)，自己给自己增加难度~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="keyword">int</span> m, l;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; l;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">g</span>(m, vector&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">cin &gt;&gt; g[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l != ans) &#123;</span><br><span class="line">ans = l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[i][j] &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">dist</span>(x, y, i, j) &lt;= l) &#123;</span><br><span class="line">l += g[i][j];</span><br><span class="line">g[i][j] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="no.-2">No. 2</h2><p><img src="https://img-blog.csdnimg.cn/20200413151429730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> Pass 10% 并查集都能写挂，真无语了。。。唉，菜是原罪 后来发现是自己模板有问题，结果一直T：<strong>大多数情况下T的原因不在于输入输出，而在于算法</strong>，血的教训。。。 回头看以为是个裸题，但是涉及到并查集的删除操作，索性直接用<code>vector&lt;int&gt;</code>存每个元素到其集合的映射关系，这样看来更是简单(一看到题就陷入树结构的并查集。。。)： 做题要看<strong>数据范围</strong>！！！<span class="math inline">\(10^7\)</span>普通并查集<span class="math inline">\(O(n)\)</span>可以过！！！而且题目很明显涉及到<strong>删除</strong>和<strong>求集合中元素个数</strong>的操作，在树结构的并查集中实现复杂！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UF</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">setNum.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unio</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (setNum[x] != setNum[y]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; setNum.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (setNum[i] == setNum[y]) &#123;</span><br><span class="line">setNum[i] = setNum[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getOut</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span>(x) != <span class="number">1</span>) &#123;</span><br><span class="line">setNum[x] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; setNum.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (setNum[x] == setNum[i]) &#123;</span><br><span class="line">++cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; setNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="function">UF <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> op, x, y;</span><br><span class="line">cin &gt;&gt; op;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">uf.<span class="built_in">unio</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">uf.<span class="built_in">getOut</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">cout &lt;&lt; uf.<span class="built_in">size</span>(x) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="no.-3">No. 3</h2><p><img src="https://img-blog.csdnimg.cn/2020041315143877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 开始就知道暴力过不了，想着骗点分算了，枚举A的所有错排<span class="math inline">\(\{B_1,B_2...\}\)</span>，计算A与B的最小距离即可，不知道为什么WA，结果爆零。。。 贴下暴力代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span>  <span class="comment">// INT_MAX</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; w[a[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == b[i]) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">find</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b[i]) - a.<span class="built_in">begin</span>() - i;</span><br><span class="line">cur += w[b[i]] * <span class="built_in">abs</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">min</span>(ans, cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较正派的做法我有想到一点，不过当时第2题没过，心情有点烦躁，净想着骗分去了~ 要使<code>dist</code>最小，就要求错排的每个位置移动尽可能少，使得<code>pos</code>之差尽可能小。 如果n是偶数，相邻位置两两互换，<code>pos</code>之差为1； 如果n是奇数，会多一个奇数位置的坑(有点贪心的意思)，这样必然要有一个奇数位置的数移动2次，当然选择权值最小的那个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span> (t--) &#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; w[i];</span><br><span class="line">sum += w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> minIdx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (w[i] &lt; w[minIdx]) &#123;</span><br><span class="line">minIdx = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum += w[minIdx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试">面试</h2><p>收到面试通知很意外，唯一一个机会，还是面的完爆了呢。 这几天一直在看面经，说实话不难，而且很多人都没手撕代码，就有了侥幸心理。。只看了面经的代码，easy的题目都没有做出来。 第一次真正面试中写代码，紧张情绪下与平时状态完全不一样，第一次理解错题意，也没有确认就开始写，写完后才发现搞错了。。。 不知道是面试官表达能力有问题，还是我理解能力有问题，从一开始的基础知识、到后来的智力题、再到编程题，五次三番误解他的意思，总之聊的很不愉快！！！面试有时候也看运气吧~ 简单做个总结吧：</p><ul><li>回答问题、手撕代码前一定要问清楚！！！！确认函数签名等细节，还可以先描述下自己的思路；</li><li>只看面经不行，复习范围很局限，还是要系统学习、疯狂练习，平时有100%状态，面试才可能有70%状态；</li><li>多参加面试，锻炼下高压下的思路和码力，任何时候都要冷静分析。</li></ul><p>很难过了，后面应该还会再投一些公司吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TOP-K Problems</title>
      <link href="/2020/03/31/TOP-K%20Problems/"/>
      <url>/2020/03/31/TOP-K%20Problems/</url>
      
        <content type="html"><![CDATA[<h2 id="最小的k个数">最小的K个数</h2><ul><li>直接数组排序，取出前K个。复杂度<span class="math inline">\(O(nlogn)\)</span>。</li><li>分治 此题只要求出最小的K个数，并不要求这K个数有序。 我们可以借鉴快排中的<code>partition</code>做法，将比第K个数小的都放前面，其余都放后面，即得到答案，但是这种方法会<strong>改变原有数组</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line"><span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">end = index - <span class="number">1</span>;</span><br><span class="line">index = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">start = index + <span class="number">1</span>;</span><br><span class="line">index = <span class="built_in">partition</span>(nums, start, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(<span class="built_in">begin</span>(nums), <span class="built_in">begin</span>(nums) + k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">empty</span>() || l &lt; <span class="number">0</span> || r &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pivotIndex = <span class="built_in">randomNum</span>(l, r);</span><br><span class="line"><span class="built_in">swap</span>(nums[pivotIndex], nums[r]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> smaller = l - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt;= nums[r]) &#123;</span><br><span class="line">++smaller;</span><br><span class="line"><span class="built_in">swap</span>(nums[smaller], nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++smaller;</span><br><span class="line"><span class="built_in">swap</span>(nums[smaller], nums[r]);</span><br><span class="line"><span class="keyword">return</span> smaller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randomNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));  <span class="comment">// use system time as seed</span></span><br><span class="line"><span class="keyword">return</span> x + <span class="built_in">rand</span>() % (y - x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以得到递归关系：<span class="math inline">\(T(n)=T(n/2)+n\)</span>，由主定理可知复杂度<span class="math inline">\(O(n)\)</span>。 与快排不同的是：快排要处理2个子问题，故为<span class="math inline">\(T(n)=2T(n/2)+n\)</span>，复杂度<span class="math inline">\(O(nlogn)\)</span>。 关于复杂度，还可以用代入法证明： <span class="math display">\[T(n)=T(n/2)+n=T(n/4)+n/2+n=T(n/8)+n/4+n/2+n=...\]</span> 重复k次后： <span class="math display">\[T(n)=T(n/2^k)+n/2^{k-1}+...+n/2+n\]</span> 故：<span class="math inline">\(T(n)=n+n/2+n/4+...+1=2n+1\)</span> - 堆/红黑树 主要思路是用容器存储K个数，之后不断更新：如果当前值小于容器最大值，替换最大值。 用最大堆作为容器，删除及插入<span class="math inline">\(O(lgk)\)</span>，故总复杂度<span class="math inline">\(O(nlgk)\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// max heap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">priority_queue&lt;<span class="keyword">int</span>&gt; <span class="title">topKMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">top</span>() &gt; * it) &#123;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然也可以使用红黑树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt; <span class="number">1</span> || k &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiset&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; ms;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = nums.<span class="built_in">begin</span>(); it != nums.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line"><span class="keyword">if</span> (ms.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">ms.<span class="built_in">insert</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (*ms.<span class="built_in">begin</span>() &gt; * it) &#123;</span><br><span class="line">ms.<span class="built_in">erase</span>(ms.<span class="built_in">begin</span>());</span><br><span class="line">ms.<span class="built_in">insert</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(ms.<span class="built_in">begin</span>(), ms.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之所以说这种解法适用于海量数据，是因为很多时候不能一次性把数据读入内存处理，这种解法可以从硬盘一次读一个，判断是否放入容器即可，只需要在内存中存储容器即可。 ## 最常出现的K个数</p><ul><li>统计出现频率，排序后取出前K个。复杂度<span class="math inline">\(O(nlgn)\)</span>。</li><li>最小堆。维护K个数，如果新数的频率大于堆顶，替换之。复杂度<span class="math inline">\(O(nlgk)\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">++cnt[nums[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : cnt) &#123;</span><br><span class="line">q.<span class="built_in">emplace</span>(p.second, p.first);</span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;++i) &#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().second);</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>桶排。用很多桶记录不同频率到对应数字的映射。时间<span class="math inline">\(O(n)\)</span>，空间<span class="math inline">\(O(n)\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxFre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            maxFre = <span class="built_in">max</span>(maxFre, ++cnt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; bucket;  <span class="comment">// freq -&gt; nums</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : cnt) &#123;</span><br><span class="line">            bucket[p.second].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = maxFre;i &gt; <span class="number">0</span>;--i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> a : bucket[i]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(a);</span><br><span class="line">                <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Egg Dropping Puzzle</title>
      <link href="/2020/03/22/Egg%20Dropping%20Puzzle/"/>
      <url>/2020/03/22/Egg%20Dropping%20Puzzle/</url>
      
        <content type="html"><![CDATA[<h2 id="the-two-egg-problem">The Two Egg Problem</h2><p>曾经是Google的一道经典题。 题意：有一个百层高楼，鸡蛋在<span class="math inline">\(L\)</span>层及以下扔都不碎，在<span class="math inline">\(L\)</span>层以上都会碎。现在某人有<span class="math inline">\(k\)</span>个鸡蛋，问在<strong>最坏情况下</strong>，至少扔多少次(用<span class="math inline">\(m\)</span>表示)可以确定<span class="math inline">\(L\)</span>的值。 分析：先来考虑<span class="math inline">\(k=1\)</span>的情况。只有1个鸡蛋，为了得到一个确定的<span class="math inline">\(L\)</span>，只能从第一层开始，逐渐尝试增加楼层高度，因此<span class="math inline">\(m=100\)</span>时，无论<span class="math inline">\(L\)</span>的值是多少，都可以被确定。 再来考虑<span class="math inline">\(k=\infty\)</span>的情况。这种情况就变为了binary search的问题，先拿一个在50层扔，如果碎，则在25层扔；如果不碎，则在75层扔...即<span class="math inline">\(m=7\)</span>。 最后来考虑<span class="math inline">\(k=2\)</span>的情况。因为<span class="math inline">\(k=1\)</span>只能一层一层试，所以第一个鸡蛋应该尽可能缩小搜索空间，但是如果第一个鸡蛋的楼层间隔太小(比如在2层、4层...)，无疑会增加<span class="math inline">\(m\)</span>。不妨取第一个鸡蛋在10层、20层...，共10次；假如第一个在10层没碎，在20碎了，那么第二个鸡蛋可以尝试11、12...19，共9次；故<span class="math inline">\(m=19\)</span>。 上面方案的问题在于：如果临界楼层比较高，那么第二个鸡蛋的次数是确定的，但第一个就需要多试几次，总次数就会增加。 那么如何使得不论临界楼层在哪，<span class="math inline">\(m\)</span>的值都不会波动呢？ 很简单，只要第一个多扔一次，确定的范围(第二个要试的次数)减小，总次数就会均衡。 对于第一个鸡蛋，第一次在<span class="math inline">\(a\)</span>层扔，如果不碎，第二次向上增加<span class="math inline">\(a-1\)</span>层...直到最后只向上增加<span class="math inline">\(1\)</span>层：<span class="math inline">\(a+(a-1)+...+1\geq100\)</span>，故<span class="math inline">\(a\geq13.7\)</span>。 鸡蛋一：在14层、27层、39层、50层、60层、69层、77层、84层、90层、95层、99层、100层扔，共12次； 鸡蛋二：如果蛋一在14层碎了，蛋二要扔13次，共14次；如果蛋一在27层碎了，蛋二要扔12次，共14次...故<span class="math inline">\(m=14\)</span>。 ## Super Egg Problem 对于<span class="math inline">\(k=2\)</span>，我们有了一个比较好的解决方案。那么现在有<span class="math inline">\(k\)</span>个鸡蛋，楼高<span class="math inline">\(n\)</span>层，<a href="https://leetcode.com/problems/super-egg-drop/">问题</a>(记作<span class="math inline">\(m(k,n)\)</span>)又该如何解决？ <span class="math inline">\(k=1\)</span>和<span class="math inline">\(n=1\)</span>的情况比较简单： |n1|2|3|4|...| |--|--|--|--|--|--| |1|1|1|1|1| |2|2| |3|3| |...| | 那么如果我们递归地思考：任选一层<span class="math inline">\(h\)</span>扔第一个鸡蛋，无非有碎和不碎2种情况： 碎：临界楼层在1~h之间，问题规模缩小为<span class="math inline">\(m(k-1,h-1)\)</span>； 不碎：临界楼层在h~n之间，问题规模缩小为<span class="math inline">\(m(k,n-h)\)</span>。 所以：<span class="math inline">\(m_h(k,n)=1+max\{ m(k-1,h-1),m(k,n-h)\}\)</span>。 对于<span class="math inline">\(h\)</span>，可以采用枚举的方法，计算<span class="math inline">\(m_h(k,n)\)</span>，在其中选出一个最小的值，故问题得到解决： <span class="math display">\[m(k,n)=min\{m_h(k,n)\},h=1,2,...n\]</span> Base Case就是<span class="math inline">\(k=1\)</span>和<span class="math inline">\(n=1\)</span>。 时间复杂度<span class="math inline">\(O(KN^2)\)</span>，空间复杂度<span class="math inline">\(O(KN)\)</span>。 记忆化递归：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">memo</span>(K + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(K, N, memo);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[K][N]) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[K][N];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= N;++i) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">superEggDrop</span>(K - <span class="number">1</span>, i - <span class="number">1</span>), <span class="built_in">superEggDrop</span>(K, N - i)));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[K][N] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述最直观的解法复杂度太高，无法通过Leetcode的数据。如何优化呢？ <span class="math inline">\(m(K,N)\)</span>表示该问题的解，如果鸡蛋数<span class="math inline">\(K\)</span>固定，随着楼层数<span class="math inline">\(N\)</span>增加，问题的解一定是增加的。 我们又把问题分解为了2个子问题<span class="math inline">\(m(k-1,h-1)\)</span>和<span class="math inline">\(m(k,n-h)\)</span>，<span class="math inline">\(m(k-1,h-1)\)</span>随<span class="math inline">\(h\)</span>单调递增，<span class="math inline">\(m(k,n-h)\)</span>单调递减(<a href="https://zhuanlan.zhihu.com/p/92288604">图源</a>)： <img src="https://img-blog.csdnimg.cn/20200319150302530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 此时<span class="math inline">\(min(max(...))\)</span>就是求中间的折点，可以使用Binary Search，时间复杂度降为<span class="math inline">\(O(KNlgN)\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">memo</span>(K + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(K, N, memo);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(memo[K][N]) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[K][N];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = N + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> broken = <span class="built_in">helper</span>(K - <span class="number">1</span>, m - <span class="number">1</span>, memo), noBroken = <span class="built_in">helper</span>(K, N - m, memo);</span><br><span class="line">            <span class="keyword">if</span>(broken &gt; noBroken) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="number">1</span> + broken);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, <span class="number">1</span> + noBroken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        memo[K][N] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，此题还有<span class="math inline">\(O(KN)\)</span>的做法，甚至还有一种数学做法可以达到<span class="math inline">\(O(KlgN)\)</span>的时间复杂度和<span class="math inline">\(O(1)\)</span>的空间复杂度，由于本人水平实在有限，就不再探索。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>风雨混沌 曙光难觅</title>
      <link href="/2020/03/21/%E9%A3%8E%E9%9B%A8%E6%B7%B7%E6%B2%8C%20%E6%9B%99%E5%85%89%E9%9A%BE%E8%A7%85/"/>
      <url>/2020/03/21/%E9%A3%8E%E9%9B%A8%E6%B7%B7%E6%B2%8C%20%E6%9B%99%E5%85%89%E9%9A%BE%E8%A7%85/</url>
      
        <content type="html"><![CDATA[<p>懵懵懂懂的少年，夏日刺眼的阳光，还有，操场飘飞的国旗~ &gt; 我志愿加入中国共产主义青年团 &gt; 坚决拥护党的领导 &gt; 遵守团的章程，执行团的决议 &gt; 履行团员义务，严守团的纪律 &gt; 勤奋学习，积极工作 &gt; 吃苦在前，享乐在后 &gt; 为共产主义事业而奋斗！</p><p>那时的我，有着初中生独特的稚气，涉世未深，但满怀激情。</p><p>并不太理解口中的誓词，但仍然高举右拳。声音高亢洪亮，目光笃定坚毅。</p><p>虽渺小，却坚定。我相信，风雨永远阻挡不了彩虹！</p><p>可是，成长了七年之后，我却愈发难以判断这个世界的真伪！</p><p>因为我的认知已经被完全颠覆 <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200320115313972-500146240.png" /> 一个无数青年向往的团体，千千万中国学子的梦想源地，究竟都在做些什么？</p><p><strong>或许这再也不是我熟悉的那个共青团了，永远都不是了。</strong></p><p>北京，中产，却连自己的孩子都保护不了。</p><p>祖国的花朵还不曾来得及绽放，就已烙下了深深的童年阴影。不久后，事情不了了之的时候，那些所谓的“叔叔医生、爷爷医生”会逍遥法外（如果还有法律的话），继续它们的生活，仿佛从未出现一样......可是受伤的心灵又由谁来抚慰呢？</p><p>【我有一个长长的望远镜，一直能伸到你的家里，你说什么话做什么事，我都知道。】</p><p>略显艺术的欺骗，让人恐怖、胆寒。</p><p>长长的望远镜难道不应该用来看星星吗？</p><p>事后，有人冷眼相望，有人造谣撞骗，有人疯狂洗地......</p><p>很欣慰的是：<strong>正义永远不会缺失。</strong></p><p>很多媒体人，顶着压力去探求真相；很多明星，站出来追问谴责；很多你我一样的普通人，持续关注着后续进展，尽力去捍卫孩子们的权益。</p><p>我说，很温暖，谢谢你，谢谢你们！ <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200320115322124-352552867.png" /> 前苏联总理Nikolai Rizhkov在反省苏联垮台时曾说：</p><blockquote><p>我们监守自盗，行贿受贿，无论在报纸、新闻还是在讲台上，都谎话连篇，我们一面沉溺于自己的谎言，一面为彼此佩戴奖章。而且所有人都在这么干，从上到下，从下到上！</p></blockquote><p>很失望，很愤怒。</p><p>但我想，重要的是：</p><p>在洞透人性的善恶后，我们依然渴望曙光，那是对生命的尊重！ 写于2017年11月29日，知乎</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A Volunteer Teacher</title>
      <link href="/2020/03/20/A%20Volunteer%20Teacher/"/>
      <url>/2020/03/20/A%20Volunteer%20Teacher/</url>
      
        <content type="html"><![CDATA[<p>“支教是我一直以来一个小小的梦想，我渴望告诉孩子们外面的世界，渴望让他们学会感恩，学会如何去爱。”</p><p>大一暑假，爱心社面试中，我如是说道。</p><p>之所以对支教有如此深的执念，大概是由于我真切地体会过教育资源的不公，体会过乡镇学校与城市学校巨大的差距吧。</p><p>抛开师资以及硬件设施，单就视野而言，乡镇的学生就已经错失了很多机会，也许你在某一方面有些天赋，但却没有触碰的可能。有的人已经凭借出色的OI成绩保送时，我却不知道什么是信息学竞赛；有的人通过自主招生降分录取时，我才发现自己无处准备，乏善可陈。</p><p>而现在，我一定尽力把精彩的世界展现给他们，用“科技之光”和“趣味地理”两个主题唤起孩子们的向往，激励他们去努力。</p><p>对我而言，支教的目的并不在于教会孩子们每道题目的解法，而是要在他们幼小的心里埋下一颗种子，一颗梦想、未来与希望的种子。哪怕将来只有一粒种子生根、发芽，我也觉得不枉此行。</p><p>我从未思考“支教有意义吗”这样的问题，因为</p><p><strong>很多事情需要你亲身经历，才能找到其中的意义。</strong></p><hr /><p>回来之后写的总结</p><h2 id="心之所向-即是光亮">心之所向 即是光亮</h2><blockquote><p>——XXX初中支教总结</p><p>此去有泪，了无遗憾。转眼就是三天，此刻，在透亮舒心的图书馆，我一遍遍忆起你们的样子，也回味着自己的影子，我想用最华丽的篇章来写下属于我们的故事。</p><p>能一步步走到今天，得感谢曾在我生命中闪亮、发光的每个人。他们有的，我清楚地知道是谁，什么关系，而有的我甚至都叫不上名字，留下的也许只有一抹瞬间，一个背影。他们闯进你的生命里，然后转身匆匆就走。颇具戏剧性的是，我可能连偿还他们的机会都不曾有过。所以我唯一可以做的就是：怀着一颗感恩的心，将这份爱心传承下去，这大概就是人生的意义所在了吧。</p><p>幸运的是，上天没有辜负我的心愿；而我，亦没有辜负自己。</p><p>史乡虽小，却足够温馨。我们自己“筑巢”，赶集买菜；掐着手表上课，生怕错过每一分的精髓；笑着和你们打闹，生怕留下一丢丢的隔阂……</p><p>素质拓展，我体验到了如此强大的班级凝聚力。扬起的灰尘，只是我们荡漾青春的背景；燥热的酷夏，带给我们永无止境的激情。一站到底，我感受到了如此强烈的知识渴求。能载着你们遨游知识的海洋，领略大千世界，很欣慰，很幸福。联欢会，我无语凝噎，只好用心倾听，倾听你们欢歌下隐藏的淡淡的哀伤。</p><p>所幸，我见证了一切。见证了史乡之夜，你们那么努力地写下自己的心愿，载着孔明灯，渐飞向那天际。你们可曾知道：用梦想点缀的夜空有多么浪漫吗？见证了细雨之下，我们那么温馨地挤入同一把小伞，漫步在湿滑的街边。你们可曾知道：这么温情的陪伴有多么感人吗？见证了篝火晚会，我们那么嘶哑地唱着班歌，伴着声声蝉鸣，飘向广阔的麦田。你们又可曾知道：这么真实的倾诉有多么难得吗？</p><p>故事很多，却不敢一一道来，因为我怕自己陷入回忆的漩涡而难以自拔。短暂的时光，我甚至不曾来得及想象别离。不知道我的心愿是否给你们带去了哪怕一丝丝光亮，史乡的我们很幸福，但我不想只是怀念你们那时的笑靥，我更渴望看到你们未来的欢喜。</p><p>我讨厌离别，但故事却终将结束。如果，这段相遇的过往是岁月的恩赐，那么，你们，一定是上苍派来的最美的天使。虽然我从未见过天使，但我想，你们就是她在人间的名字。当最后，我们的眼泪不约而同地掉落，我许下了承诺：不久就重逢。愿那时，也遇到同样美好的你们。</p><p>生命的长度很难去拓展，但宽度却由我们自己决定。支教不过一个小小的心愿，但其蕴含的精神震撼却挥之不去，深深烙在了脑海。</p><p>“真正的平静，不是远离车马喧嚣，而是在心中修篱种菊。”这短暂而又漫长的生活，当生活赋予无限的压力时，当痛苦悄然降临时，愿我也能守住自我，守住内心。对我而言，公益的脚步从未停止，我想趁着年轻，尽情绽放！</p></blockquote><p>支教期间写的推送 <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929900&amp;idx=2&amp;sn=6e36434e4664cd3e82912240136679f7&amp;mpshare=1&amp;scene=1&amp;srcid=1027ug4p7BJeIVmoWGS73wpX#rd">【弦歌史乡】许你夜空中最亮的星</a> <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929882&amp;idx=1&amp;sn=4ae30cb4c297a7abac52c2b9a2ecbaef&amp;mpshare=1&amp;scene=1&amp;srcid=10270FdciDePyzqf4Fu4wD8T#rd">【弦歌史乡】许你夜空中最亮的星</a> 小伙伴们写的 <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929840&amp;idx=2&amp;sn=633f9339c32983a3cee2004e63bef309&amp;mpshare=1&amp;scene=1&amp;srcid=1031zCbbE172mOWeZKj4vUId#rd">【手拉手系列】弦歌史乡</a> <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929845&amp;idx=1&amp;sn=2550b5901dcbcf939132c8314d83fb5d&amp;mpshare=1&amp;scene=1&amp;srcid=1031SLclYWY2gEysGRqYqkZ0#rd">【弦歌史乡】惟愿给你们最缤纷的万花筒</a> <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929855&amp;idx=1&amp;sn=e3526c7cea74f4e29f1946c0d50fd109&amp;mpshare=1&amp;scene=1&amp;srcid=1031Q7f8QOZm9TskDsELKKHD#rd">【弦歌史乡】放眼看世界</a> <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929858&amp;idx=1&amp;sn=94eed8f13d7b6e3445c7e677377c58e3&amp;mpshare=1&amp;scene=1&amp;srcid=1031tbnwMYimOjyxMvigSkg6#rd">【弦歌史乡】《哥哥姐姐们，请你们不要再来支教了》之问</a> <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929873&amp;idx=1&amp;sn=89047f782ca2d10d4954cc2aba42d3b6&amp;mpshare=1&amp;scene=1&amp;srcid=1031YjO6PqJX7cik00q5zMZ4#rd">【弦歌史乡】风雨无阻，我们陪你们回家</a> <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929900&amp;idx=1&amp;sn=eb3445881fe1d1a13662ae097afcb0de&amp;mpshare=1&amp;scene=1&amp;srcid=1031KbjExxgjiPZrkIhPqgVD#rd">【弦歌史乡】如果我们不曾相遇</a> <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzUxMjA5Ng==∣=2649929904&amp;idx=1&amp;sn=efb1e2807e0527791e101435a74b2bb8&amp;mpshare=1&amp;scene=1&amp;srcid=1031dPimn6zynOREw3CoOA3r#rd">【弦歌史乡】离而欢歌</a> 写于2017年11月1日，知乎</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Football Memory</title>
      <link href="/2020/03/19/Football%20Memory/"/>
      <url>/2020/03/19/Football%20Memory/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200319114221838-110416057.png" /> 以前，觉得自己是因为单纯喜欢足球这项运动，所以才会一直坚持去踢。</p><p>后来，逐渐处于“半退役”状态时，才体会到“兄弟”一词于我的意义。</p><p>高一开始接触足球，然而并没有一见钟情，只是当做普通的体育课去完成。</p><p>那年巴西世界杯，用手机看文字直播，糟心极了。也说不清喜欢哪个队，只知道德国和西班牙很厉害。</p><p>高二下学期，偶然的机会，从乒乓石台偷偷遛到球场，落日的余晖下，打进一球，彻底点燃了我对足球的热情，从此一发不可收拾，结下了难解之缘。 <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200319114324647-1576480051.png" alt="美妙的足球场" /> 曾在滂沱的大雨中，注视着足球，卷带着雨水，缓缓窜进球门，我们相佣而呼，忘情庆祝；也曾在似火的的骄阳里，与汗水共舞，祈求一丝微风，带走难耐的酷热……</p><p>念念不忘那场7:1的巅峰，横扫高三四班的荣耀。上场前的不自信，场边的呐喊助威，场上的互相呼应，整个班级凝聚得令人生畏，我们不惜体力地跑动围抢，仿佛是用生命在战斗。</p><p>进球的场景已经略显模糊，只记得中场有一脚逆天的左脚吊射，让所有人瞠目；</p><p>我通过一粒点球上演了“职业生涯”第一次帽子戏法，7:0。</p><p>老师在最后时刻接门将长传，禁区角左脚凌空爆射破门，一脚“天外飞仙”将比分定格为了7:1，那粒进球被我们啧啧称道了整整一年，直至毕业以后。</p><p>比赛结束以后，我很激动，前所未有的激动，很想去拥抱兄弟们，感谢他们的努力。之后的生物课根本没怎么听课，脑子里全是胜利的喜悦。 <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200319114420479-2137446397.png" alt="仅存的足球记忆" /> 那些简单而又纯粹的岁月里，买不起专业的球鞋，也没有华丽的配合，比赛中踢出一个简单的二过一都会回味很久很久。突破、盘带、射门，都没有系统地训练，我们有的，只是一腔热血。 <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200319114458736-1744296868.png" alt="当年的球鞋" /> 旺盛的精力至今想来都很可怕，我们可以不吃不喝，从中午12点一直踢到晚上9点。传球、射门、分边，下底传中、突破过人，浪费了好机会之后，也会“开飞机”谢罪，丝毫感受不到疲倦。</p><p>一年多的时间里，玩坏了好几个球，足球几乎是那个时候最爱的放松活动。</p><p>很难形容喜爱到了什么程度，晚上睡觉都在想着该怎么传球。早操后最喜欢讨论的不是数理题目，而是国际足坛谁最厉害。</p><p>也曾通宵去看西班牙国家德比，三个人挤在一张床上，巴萨2:1赢了皇马，感慨苏亚雷斯的强大以及布拉沃的神勇，第二天早起昏昏沉沉去吃早饭的样子还历历在目。</p><p>总是在班级的报纸上寻找关于足球的新闻，仅有的几本足球杂志不知道翻了多少遍，成为了午饭时唯一的消遣。</p><p>后来无数次想要重拾那感觉，却再也找不回来了。不论是重回高中的球场，亦或是穿上高端的球鞋，还是拥有高水平的队友…… <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200319114543630-2030872958.png" alt="重回高中球场" /> 后来快要毕业之际，我们买了四件皇马球衣，两黑两白，甚是吸引目光。</p><hr /><p>我们，也曾少年！</p><p>唉！这tmd的青春啊！</p><p>不由得又想起了之前的一个故事 &gt; 十多年前，我读高中，同桌是个安静漂亮的姑娘，很是喜欢我，但也许是启蒙过晚的原因，我对她熟视无睹，我唯一的爱好就是踢球，而她唯一的爱好就是看我踢球...... &gt; &gt; 我当时非常喜欢德国队，不厌其烦地向她灌输金色轰炸机如何厉害，哈斯勒如何牛逼，虽然她听不懂，但还是安安静静地看着我，眼含笑意。 &gt; &gt; 时光荏苒，当德国队折戟法国世界杯的那个夏天，我高三已经快毕业了，临别那天，我送了一张克林斯曼的明信片给她，她满心欢喜，毕竟三年来我第一次送她东西...... &gt; &gt; 慢慢的，克林斯曼从球员变成了教练，我大学毕业、工作、应酬，整日在推杯换盏中虚与委蛇，不知不觉间很多人和事情都已淡忘，只有看球的时候偶尔也会想起当年同桌的她。 &gt; &gt; 去年春节回家，无事可做，决定去踢踢球，结果没跑几步就气喘吁吁，索性坐在场边看其他人踢，看了一会儿，视线被一个身穿德国队18号球衣的孩子吸引了，感觉这孩子盘带、传球很有章法，趁那孩子休息的时候，我主动过去和他攀谈起来。 &gt; &gt; “踢得不错嘛，几岁了？” &gt; &gt; “8岁了。” &gt; &gt; “踢这么好，平时没少踢吧？” &gt; &gt; “平时没怎么踢，我爸爸不喜欢我踢球，说踢球没用。” &gt; &gt; 我一愣，顿时接不上话，气氛显得有些沉闷，我换了个话题。 &gt; &gt; “你喜欢德国队？” &gt; &gt; “嗯。” &gt; &gt; “那你最喜欢德国队哪个球星？” &gt; &gt; “克林斯曼。”他不假思索地回答道。 &gt; &gt; “嘿，你也知道克林斯曼啊？”我顿时来了兴致。 &gt; &gt; 他骄傲地回答：“当然了，我妈妈有一张他的明信片，她说克林斯曼是金色轰炸机......”</p><p>写于2018年1月20日，知乎</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Senior Year</title>
      <link href="/2020/03/18/Senior%20Year/"/>
      <url>/2020/03/18/Senior%20Year/</url>
      
        <content type="html"><![CDATA[<p>高三的故事真的太多太多，不知道该从哪里写起。</p><p>在一个弱省，一个弱区，中考是全区第三，由于户籍制度的限制，要想去市里的顶级高中需要缴纳高昂的借读费，最后只能留在县城中学读书，就这样很懵逼地以全校第一进入到了高中（因为一、二名都走了）。</p><p>高一高二跟着老师的步调上课听讲、写作业，那个时候天真烂漫，加上学校的竞争并不激烈，所以我并不明白好的大学意味着什么。直到高二后半段，班主任让所有人写一个目标中的大学，然后将大家的梦想挂在了教室墙壁的中央，我才慢慢醒悟。和很多人一样，在对学校并没有什么了解的情况下，我填了清华。</p><p>那时的我，虽然听说学校好几年才能出一两个清华北大，嘴上说着自己肯定考不上，心里不以为然，但是却并没有从心底真正意识到清华的难度。另一方面，我当时并没有极强的渴望去清华，也许是一直以来学习压力不大，成绩上的优越感很强，滋生出了自负的萌芽。现在看来真是很奇怪和矛盾的一件事。</p><p>很快就高三了，竞赛之路显然走不通，据我所知，十年内只有一个学长通过化学竞赛被保送到了清华，其他人甚至连进入全国复赛的机会都没有，而我只拿到了数学竞赛的三等奖，毫无悬念地被pass掉了。</p><p>上学期接连的几次测试我都是第一，老师们对我寄予了厚望，不停地找我谈话，鼓励、劝诫，我真的觉得有些厌烦了。</p><p>这是高三的一次成绩记录（别见笑）。当时还是蛮认真的。 <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDMvMTI2MDU4MS0yMDIwMDMxODA4MzcxMTA4MC0xNTMzNjcwODI0LnBuZw?x-oss-process=image/format,png" /></p><p>不巧的是：自从高二下学期喜欢上足球以后，觉得自己像着魔一样疯狂的迷恋。在紧张压抑的高三，我却经常放弃午休和周天放假的时间去踢球，在应该拼命学习的时光里肆意挥霍着大把大把的青春，在足球场上奔跑。更可笑的是：我不断地告诉自己，踢球是为了锻炼身体，锻炼身体是为了更好地学习，在这样的谎言中欺骗着自己。回过头来，那时踢球的确有虚荣心和表现欲作祟，但我真的很喜欢踢。不是有句话：男人一旦爱上了足球，就是一辈子的事。不置可否的是：足球严重影响了我的复习和学习成绩。接下来的考试我几乎很少拿到第一名，最要命的是：随着复习的加深和题目难度的增大，我的理综严重下滑，化学甚至已经到了及格的边缘，物理奇差无比，生物偏科。每次考试几乎都是靠着语文、数学、英语的优势来弥补不足。</p><p>2015年春节后第二天，我参加了为期十天的校外集训，经过名师的指点后，我的化学有了突飞猛进的提高，语文也有了一定程度的提升。但也正是经过这次集训，我可怕地意识到：清华于我而言其实已经非常遥远了，或者说是不可能的了。和我一起参加培训的，除了我们学校的前十名，还有其他地方的优秀的学生。他们表现出的实力几乎完全碾压我，分析那些稍有难度的题目时，我感到的几乎全是燥热，在我花了十分钟理清思路后，有的人只用了两分钟就给出了正确答案。我终于承认了自己菜鸡一般的存在，井底之蛙的滋味使我自己苦笑不已。</p><p>我记得那次走之前参加了一模考试，通过关系很不错的朋友知道了成绩，我掉到了第十名。她发短信告诉我学校的雪下得很大，她们一起打雪仗了，但此刻我其实很恐慌，不过聊天时没有刻意表现出来罢了。</p><p>那天晚上，我开始认真地分析自己离清华差的有多远。在如此弱省，裸分至少需要700左右才能确保一个名额。而我在题目最简单的一次也不过考了684，这次真的慌了。</p><p>回去以后，我拼命地补习生物，体育课就一个人在教室恶补知识点。</p><p>这是当时的笔记： <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDMvMTI2MDU4MS0yMDIwMDMxODA4MzcyNzIyMy0xNjA4ODEwMjY1LnBuZw?x-oss-process=image/format,png" /> 真的要好好感谢当时年轻的生物老师，至今仍然清晰的记得：连续很多天下午上完课后，我被叫到她的办公室，利用晚自习前的时间给我分析试卷中的错误，找出我复习的盲点和难点。每次她都只喝一杯粥，和家里人打电话也是三言两语就挂断了。没有她，我的生物简直不敢想象。之后对生物的恐惧感彻底没了，高考生物也算是出色发挥了！</p><p>但是物理刷题效率依然很低，也不肯去思考那些难题，4月份的时候甚至都讨厌去做物理作业。整个体系十分混乱，基本的8道选择题，每道题6分，我几乎错2道。碰到变形过的实验题，也经常被虐的很惨，压轴题很少全部做出来，印象中估计也就完全正确三次吧。</p><p>理综尤其是巨烂的物理让我模考吃尽了苦头，其余科目好不容易攒下的优势一下子就全没了。</p><p>令人眷恋的时间总是过的飞快，上完最后一节课后，大家都给老师们写临别赠言，而我写的是：敬爱的班主任，我可能去不了清华了，您的梦也是我自己的梦，可能很难实现了。对不起！还有写了一些废话。5.23号全班拍毕业照，班主任找到我，跟我谈了一次，还是告诉我不要泄气，实力还是在的，加油一定可以的。我只是点点头，为了不让他失望。</p><p>接着就是一个礼拜的假期，也是自由复习。只是记得我回了趟家，回家前班主任打电话劝我多出去走走，放松放松，平静心态。我已经忘记了那周是怎么度过的，只记得6.1号返校，又进行了两次无批改的考练，我知道：最后的决战只能硬着头皮上了。</p><p>高考前一天，父亲给我熬了排骨汤，但我并没有胃口。那天晚上，在宾馆就是睡不着，tmd就是觉得身体很痒，一直折腾到一点钟才入睡。我到考点门口时，老班在发准考证，大家看起来有说有笑，心情都还不错。</p><p>语文感觉答得挺不错，数学压轴题没做出来，这对追求满分的我而言，不算是个好事，但也不至于太烂。</p><p>6.6号晚上的欧冠决赛是巴萨对阵尤文图斯，那晚我的睡眠质量还不错，对此毫无印象，甚至没有一点挂念。</p><p>最虚的理综还是来了，不出所料，我考砸了。所有人都预测压轴题会是电磁学，但那年的电磁学考的很简单，压轴题变成了力学。浏览完试卷，我整个人都蒙了，那道20多分的题我只写了第一小问，前面还有几道选择题毫无思路。匆匆做完其他题之后，蒙了答案，也该交卷了。走出考场，觉得大地一直在摇晃。我没有去班级的集合地点，直接回了宾馆。</p><p>下午的英语，本来于我而言毫无压力的一科，我的手心却一直在冒汗，写作文时手甚至一直在抖动。响铃之后，一切都结束了。</p><p>老妈接我回去的路上，我脸色阴沉，一句话都没说。下午没有吃饭，就去操场了，根本不敢对答案。那一刻，我觉得整个世界仿佛都已经坍塌了。</p><p>第二天早上只是很简单地估了分，去了趟学校汇报。有人约着去唱歌，我婉拒了。然后灰头土脸的回家。那十几天，我呆在家里，一步都没有出去，想了很多很多：纠结、梦想、友谊……我告诉父母要去复读。我爸说：等成绩出来吧，那个时候你如果还是想复读，再去吧。</p><p>6.25号中午出分，离清华差了60分。理综和数学很糟糕，一向自认为数学不错的我竟然只有128分，我无法想象，一时很难接受。我觉得自己就是一个彻彻底底的loser，没有颜面见人。</p><p>填志愿时咨询了很多人，已经没有心力去厦大或者出省，也没有选择去复读。9月份进入了一所非常普通的985就读。</p><p>上大学后，经历的多了，也就逐渐释然了，虽然我妈还是不时用数学来调侃我（我也不清楚是不是亲妈）。</p><p>客观来说，环境因素的确起了很大作用，但于我而言，失败更多的还是由于懒惰、自傲等自身的因素造成。慢慢平复心态后，只是觉得愧对那些一直以来陪伴、支持、鼓励我的人：我的父母，班主任，任课老师们，让关心的人失望了！现在回学校还是会不好意思去见老师。</p><p>过去的事情无法更改，只能用来怀念。我的高三，无悔但有憾！写这些，并没有觉得自己怀才不遇什么的。只是想好好回顾一下高三时的心路历程，因为这也许是我的青春里最为遗憾的事了！</p><p>完 写于2017年4月3日，知乎</p><p>大学写的一篇文章：年少轻狂，总喜欢写一些煽情的文字。 &gt; 依然清晰记得六月八号的那个下午：当英语考试结束的铃声如预期般传来，周围人迅速起立，椅子与地面摩擦的声音一阵接一阵，刺耳极了…… &gt; 我也被巨大的人流裹挟着，来到操场。没有欣喜若狂，也没有悲痛欲绝，内心出奇的平静。看到骚动的人群，我猛地意识到：原来这么快就结束了！ &gt; 熙熙攘攘的家长们纷纷冲上前来，用从未有过的热情给予孩子拥抱，场面之宏大，令人动容。 &gt; 费力挤出人群，快步走在路上。虽然已经临近黄昏，但阳光依然火辣，刺的人甚至睁不开眼。轻轻地抬起头，便扫到了骊山的背影，一种莫名的孤独涌上心头。脑海里瞬间浮现出那一张张稚嫩的面孔，我开始回忆那即将散落的满地芳华，倾尽全力去捡拾，纵使它们终将流逝…… &gt; 早晨揉着惺忪的睡眼，用从不敢怠慢的脚步匆匆跨入教室，昏昏沉沉地为高考宣誓，却也忍不住聊几句闲话;午饭随便地应付之后，盯着倒计时牌就开始奋笔疾书，尽管困的要死，却也要开几句玩笑;无趣的晚自习令人口干舌燥，老师们的辅导好似对牛弹琴，但课间一个个却生龙活虎…… <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDIwMDMvMTI2MDU4MS0yMDIwMDMxODA4NDQ0ODkwMS0xMTk3MzQ2MjI1LnBuZw?x-oss-process=image/format,png" /> &gt; 我们曾郑重地写下奋斗目标，渴望金榜题名;我们曾在球场上一起流汗，拼尽全力去赢得比赛;我们曾感念恩师，眼泪就是那份情谊最忠实的见证;我们也曾惺惺相惜，叹惋年华易逝，青春不在…… 一次次的考试击打着本就脆弱的心灵，成绩左右着我们的心情。开始时的迷茫和彷徨伴随着无数次的打击而无影无踪，开学时的锐气也渐渐被磨平了棱角，不知不觉竟然坚持到了最后，留下了毕业照上那一张张可爱的脸庞，成为我们永生不可磨灭的记忆温存。 不论最初的梦想是否实现，也不论现在的生活是否幸福， 不论你同不同意，愿不愿意，这一切都已如烟般散去，留下的只有空气中的些许味道，不知道是苦是甜，供我们回味、品嗅。 正如电影《匆匆那年》里方茴所写，“不悔梦归处，只恨太匆匆。”假如青春可以重来，我依然会选择迈出相同的脚步，选择沿着相同的足迹，和你们一起去丈量梦想的距离。 我愿意，你们愿意吗? &gt; 写于2015年11月7日</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>High School Memory</title>
      <link href="/2020/03/17/High%20School%20Memory/"/>
      <url>/2020/03/17/High%20School%20Memory/</url>
      
        <content type="html"><![CDATA[<p>无数的回忆，却不知怎么讲起。</p><p>生命中黄金般的三年留在了那里，留在了教室、食堂，留在了操场、水房。丁香台的幽怨、风范楼的纪念……时间逝去的了无痕迹。 暮去朝来，脑海里的记忆渐成碎片，模糊，远去……可青春残存的余温却不时袭来，让人不知所措。 难吃的饭菜，打水的长队，漫长的台阶，无尽的作业，这被吐槽的一切，我该怎样留住？</p><p>恍惚的日子里，我们沐浴着初春的阳光，穿着蓝白色的校服，三三两两，去清扫校门口的垃圾，飞舞的塑料袋好像永远都跟你作对，高一的卫生红旗班总也不是我们。 刚入学的我们难脱稚气，宿舍的卧谈会不知道开到了几点，三国杀也总是通宵通宵地玩。体育课后的历史课，简直是睡觉的天堂，老师略显无奈，不过并没有人care。</p><p>二年级的教室并没有变化，我一度觉得无聊。清洁区变到了教室后面，仲夏的中午拿着笤帚，扫扫松针，偶尔会有几片落叶，倒也非常惬意呢！ 学习任务貌似重了一些，感觉大家更加熟悉和融洽了。让我印象颇深的两件事：一是教师节那天，国旗下的演讲。莫名其妙地成了要演讲的人，没见过那么大场面，所以提前一周就在准备，演讲稿不知道背了几百遍，周天的晚自习啥也没干，盯着看了两节课，手心直冒汗。第二天上台慷慨激昂地背完了稿子，也算是没给班级丢人；二是期中考试后的家长会，教室装扮着气球，彩带，音乐竟然是“爸爸去哪了”，老师，家长，学生共处一室，感觉其乐融融，真的很温馨。。。 搬出了宿舍，租房子住倒也安静。不过院里大部分都认识，还是会经常“联谊”。 之后文理分科，学业考试，有走的人，也有来的。下学期有了竞赛培训，很喜欢翘掉晚自习 ，溜出教室去听数学竞赛。</p><p>高三搬到了更靠近后花园——骊山的风范楼，体育课很方便咯。大家时间紧张，所以楼后面的空地自然成了最佳锻炼地。课间的羽毛球，足球，跳绳略显疯狂啊！ 学校要求冬天早晨跑早操，真的是感人肺腑，无语凝噎。纵然好多领导（Lu Xiang，Wang Jian）监督，还是有人去厕所或者蹲着系鞋带。。。跑完冻如狗，回到异常温暖的教室，再吃点夹馍，零食什么的，早读只能睡过去了。 相对来说，我更喜欢广播体操。悠闲的大课间，上个厕所，晃到操场，晒晒太阳，活动一下筋骨。下来时候还能聊聊天，打打闹闹，也算是“偷得浮生半日闲”了。</p><p>每次考完试，操场就变为了乐园，火爆程度超乎想象。在球场奔跑，听着风的声音，跑累了就躺下来看天，看云，看夕阳，考试的阴影一扫而光，那是我最开心的时刻之一。大家会一起玩到很晚，“下山”去吃东西。 很喜欢坐在教室靠窗的位置，呼吸几口新鲜的空气，压抑感瞬间消失，上课扭过头就是小树小花。下雪的日子还可以赏景，雪景可美了！ 贴几张喜欢的～ <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200317145955582-1438830147.png" /> <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200317150009418-1659103469.png" /> <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200317150020999-14015772.png" /> <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200317150030273-1471598340.png" /> 毕业之后，学校就升级成陕西省示范高中了（也算是没有辜负我们为了迎接检查，频繁打扫卫生啊）。 虽然实力有限，水平不高，经费不足，饭菜难吃（母校就是我们自己随便黑，却决不允许外人说一句闲话的神奇地方），但进步可见，未来可期！ 给帅气无敌，宛若天仙的母校再次打call～ <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200317150039438-994418279.png" /> <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200317150049066-681633682.png" /> <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200317150053530-631484450.png" /> <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200317150059306-93407777.png" /> <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200317150105634-1361526225.png" /> <img src="https://img2020.cnblogs.com/blog/1260581/202003/1260581-20200317150112433-1502532336.png" /> 纵观这三年，奋斗的时光恍如昨日。从学习结果的角度来说，我无疑是失败的。但论人格的成熟，收获的友谊，价值观的塑造，我又觉得自己是无比幸运的。很多老师的教诲至今仍然记忆犹新，也许会受益终身： &gt; 1，不被嘲笑的梦想不值得被实现。 &gt; 2，高考并不会决定什么，但它必定会成为你人生当中的分水岭。 &gt; 3，......</p><p>逝去的岁月没有人能抓住，不论你多么眷恋，亦或有多少遗憾，都要藏在心底，因为前路漫漫！ 以后若有人问起你的青春，你大可以掰着手指，细数学校曾经的沧桑，拾起被风吹落的故事，那是你私藏的幸福！ 写于2017年10月16日，知乎</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>士兵突击随想</title>
      <link href="/2020/03/16/%E5%A3%AB%E5%85%B5%E7%AA%81%E5%87%BB%E9%9A%8F%E6%83%B3/"/>
      <url>/2020/03/16/%E5%A3%AB%E5%85%B5%E7%AA%81%E5%87%BB%E9%9A%8F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>这部2006年上映的作品豆瓣评分9.3，时至今日仍然有人乐此不疲地讨论剧情和启发，我想称之为经典应该不算过分。 这部剧我至少完整看过3遍，随着阅历增加，对某些角色的体会也变得更深刻。 ## 许三多 许三多是幸福的。从老马、史今到袁朗，他的成长，总有贵人相助，再加上自身近乎于偏执地努力，成为“兵王”并非意外。 <strong>每个开始，总会艰难一些。</strong> 初来乍到，面对自家坦克，他举手投降，连长怒了。于是，红三连，五班。 就像初入社会，没什么朋友，周围的东西和我们格格不入，许三多的境遇大抵如此了。 那个“无数班长的坟墓，所有孬兵的天堂”，他活得很简单、很纯粹：负重跑步、整理内务，日日如此，还为连队修了条路。 <strong>无人问津的地方，你有得选择。</strong>你可以放弃，可以混日子；也可以认真，可以努力。 重回钢七连，仍然没有人相信他，除了班长，那个有过承诺的班长。 说实话，那个时候，我讨厌许三多。讨厌他的愚笨，讨厌他不争气，最讨厌的，他拖垮了史今。 史今的心思全部倾注给了许三多，那么优秀的班长，在天安门前抱头痛哭，怎叫人不心疼！ 有人说，史今给许三多打好了地基，袁朗则在地基上盖好了房子。 是的，没有史今，就不会有后来的许三多。 333个腹部绕杠，许三多开始了自己的蜕变。 七连改编，他又把“不抛弃，不放弃”诠释到了极致。 不焦虑，耐得住寂寞。 <img src="https://img-blog.csdnimg.cn/20200316141449843.png" alt="在这里插入图片描述" /> 在最绝望的情况下，在完全失去理想和希望的情况下，也会尽自己最大的努力。 失手杀掉毒贩，他也怀疑过自己，怀疑过这支部队，因为他相信人性本善，每个人都可以好好活。 不过历经波折，最终还是艰难地完成了心智的转变。 无意批评，许三多是好兵，但他绝非将才。可能与他成长的家庭有关，父亲的教育方式让他绝对服从、勇于认错，但他缺乏思考。 没有思考，就没有大局观；没有大局观，自然不能指挥别人。 ## 吴哲 吴哲我比较喜欢，尽管被塑造得稍稍理想了些。 年少有为，技术出众。 他对自己有着清醒的认识，对这个世界同样如此。 一如演习后他对袁朗所说：</p><blockquote><p>我成为不了他，而他亦取代不了我。</p></blockquote><p>不会畏惧权威，永远坚持理想。 当他发现现实环境与期望之所相距甚远，他会质疑、会抗议，会去维护自己的理想。 理想让他仰望星空，“平常心”使他脚踏实地。 <img src="https://img-blog.csdnimg.cn/20200316141511696.png" alt="在这里插入图片描述" /> 附上袁朗的点评</p><blockquote><p>我不会践踏你们的理想和希望，我不能，因为那是我最珍惜的部分，也是我选择你们的第一要素，我只是想，你们在没有这些东西的情况下也能生存，在更加真实和残酷的环境里还能生存。 我敬佩一位老军人，他说他费尽心血却不敢妄谈胜利，他只想他的部下能在战场上少死几个，他说这是军人的人道。 这个人略显轻浮，但心理稳重。坚持自己的原则，充满希望和乐观。重要的是，他能跟许三多这样的兵交朋友，这一点，就不会毁于他很容易产生的优越感。 ## 袁朗 最完美的人，也是无数人想成为的人。 他似乎总是站在上帝视角，洞悉一切，指点迷津。 军事素养拔尖，一举枪，便打掉了成才的狙击梦。 有能力、有思想，也有情义。 老A选拔的最后，伍六一放弃，我明明看到了袁朗强忍的泪水。 许三多决定复员，他并不是强行挽留。给他钱，给他假，给他自由，我想，这么做，他心里是有底的。 演习评估的剧情，异常精彩。袁朗手术刀般精准地评价了每个人，他看得透他们。 “不抛弃，不放弃”，他理解的深刻得多。正因为如此，他给了成才第二次机会；也正因为如此，才有了许三多坠落后，他对成才说的话：</p></blockquote><blockquote><p>百万大军数年心血，人走人留，抛家舍业，一切数据和非数据的结果都要在这几天检验，最后得不出一个公平的结果，因为我的战士要在战场上和他的朋友重拾友谊。 你开始珍惜，可你真懂珍惜了吗？不抛弃，不放弃，你倒记住了，你也这样告诉许三多，那么先想想，做到这六个字的人抛弃了什么，放弃了什么。想吧，现在。</p></blockquote><p>初次看这段，我也一脸懵逼。 后来才知，许三多为了胜利付出了鲜血，他创造的机会才是真正值得珍惜的，抓住机会获取胜利、为军队改革提供经验，远比立刻抢救队友意义重大的多。 他循循善诱，告诉成才一个指挥官应该做什么，告诉他战场上应该怎样取舍。 袁朗说自己年轻时最像成才，比吴哲更专心，比成才更知道自己想要什么。 我想，袁朗最终也算是给自己找到了接班人吧。 <img src="https://img-blog.csdnimg.cn/20200316140043328.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/2020031614005371.png" alt="在这里插入图片描述" /> ## 成才 相比之下，成才的路的确坎坷的多。 经历了荣光，也熬过了低谷，最后做到了出众。 这个人物塑造地很真实，他会为了个人利益抛弃战友，但也会在需要理智时做出正确选择，而许三多感情用事更多一些，这在战场上是致命的，尤其对于指挥官而言。 <img src="https://img-blog.csdnimg.cn/202003161416111.png" alt="在这里插入图片描述" /> 袁朗曾经对他寄予厚望，但演习后一切似乎又戛然而止：</p><blockquote><p>你老把一切当成你的对立，总想征服一切，费了这么大的力，我们只想在你们没有战争的时候，就经历第一场战争。战争中伤亡最重的总是新兵，因为没有心理经历，没有适应时间。 理由你太见外，任何个人和团体很难在你的心里占到一席之地。你很活跃，也很有能力，但你很封闭，你总是在自己的世界里，想自己的，做自己的。成才，我们这伙人不只是为了对抗，你的战友，甚至你的敌人，需要你去理解、融洽和经历。 <strong>你经历的每个地方、每个人、每件事，都需要你付出时间和生命，可你从来没付出感情，你总是冷冰冰的把它们扔掉，那你的努力是为了什么？为一个结果虚耗人生？</strong> 你该想的不是怎么成为一个特种兵，是善待自己做好普通一兵。 七连只是你的一个过路的地方，如果再有更好的去处，这儿也是你过路的地方，我们不敢跟这样的战友一起上战场。 我对你很失望，我一直在想，这么一个优秀的兵，为什么不能把我们当成他的战友。从那天起我开始对你失望，你们是团队的核心、精神、唯一的财富，其它都是虚的，我无法只看你们的表现，我更看重的是人。 我终于发现这世界上还有你在意的人，可这并不能说明你就学会了珍惜。</p></blockquote><p>很多时候，觉得世界并非纯粹的黑白，每个人的选择，也不能简单地用对错衡量。 第一次收看的时候，我十分讨厌这个家伙：自私、虚伪、圆滑，为了成绩不顾一切。他被淘汰出局时，观众看得很解气。作为对比，许三多单纯、团结、向上，虽然早期经历挫折，但后期军旅之路愈发风顺，这也是观众喜闻乐见的情节。 但随年岁增长，我们会发现许三多这样的人几乎不存在，而早期的成才则比比皆是。 能从五班重新走回老A，大多数人看到了他超乎寻常的冷静和神乎其神的枪法，却少有人关心他在五班的日子是怎么渡过的。要知道：从山峰跌落，要远比在平地上摔倒疼的多。唯一关心他的只有许三多（有这样的朋友，真是不知道交到什么好运气了）：</p><blockquote><p>你说他逃避了你设计的经历，这个你在意，可他真实经历了什么，你根本就不在意。你设计的几个小时，难道比他过的这段日子还要难吗？你要是去过五班就不会这样。</p></blockquote><p>后来他说自己只是草原上一个跑丢了的兵。 草原五班的这段经历弥足珍贵，成才学着知足常乐、学着善待别人，他真的后悔了。 浴火重生，他真该感谢袁朗，让他重新起跑，而且跑得不算太晚。 最后的演习，很显然，他唯一的机会了。 这次没有让袁朗失望：</p><blockquote><p>你像个指挥员开始思考问题了。 吴哲领路，我不在的时候成才领队。</p></blockquote><p>事实上，这就是对成才的肯定。 袁朗故意暴露，一是掩护行动，二可能也想培养成才吧。</p><blockquote><p>你的路还很长，比许三多要长的多，同时你的迷茫要比他多得多，如果这是你的路，你愿意来老A吗？</p></blockquote><p>成才可算成才了~ 写于2018年8月28日，知乎</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Longest XXX</title>
      <link href="/2020/03/11/Longest%20XXX/"/>
      <url>/2020/03/11/Longest%20XXX/</url>
      
        <content type="html"><![CDATA[<h2 id="longest-common-substring">Longest Common Substring</h2><ul><li>Brute Force 遍历<code>a</code>和<code>b</code>所有位置的组合，向后延伸，直到遇到两个不同的字符，复杂度是<span class="math inline">\(n^3\)</span>级别。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回所有结果</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">longestCommonSubstring</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                string cur;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = i, n = j; m &lt; a.<span class="built_in">size</span>() &amp;&amp; n &lt; b.<span class="built_in">size</span>(); ++m, ++n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[m] != b[n]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur += a[m];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.<span class="built_in">size</span>() &amp;&amp; cur.<span class="built_in">size</span>() &gt;= maxLen) &#123;</span><br><span class="line">                    maxLen = cur.<span class="built_in">size</span>();</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>DP 暴力解有很多重复计算：比如以<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>为起点去向后延伸，我们可能需要比较<span class="math inline">\(i+1\)</span>和<span class="math inline">\(j+1\)</span>、<span class="math inline">\(i+2\)</span>和<span class="math inline">\(j+2\)</span>...而以<span class="math inline">\(i+1\)</span>和<span class="math inline">\(j+1\)</span>为起点时，仍然要比较<span class="math inline">\(i+2\)</span>和<span class="math inline">\(j+2\)</span>，<strong>重叠子问题</strong>给动态规划带来了可能。 暴力做法是将每个<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>作为起点，现在我们考虑将<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>作为终点，令<span class="math inline">\(L(i,j)\)</span>表示text1[0...i]和text2[0...j]中的最长子串的长度（不是非要以<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>作为结尾）： <span class="math display">\[L(i,j)=\begin{cases}1+L(i-1,j-1)&amp; \text{a[i]=b[j]}\\0&amp; \text{a[i]!=b[j]}\end{cases}\]</span> 为了简便，假设下标从1开始，那么边界条件：<span class="math inline">\(L(0,j)=0,L(i,0)=0\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">L</span>(<span class="number">1</span> + a.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> + b.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">L[i][j] = <span class="number">1</span> + L[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">L[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">maxLen = <span class="built_in">max</span>(maxLen, L[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显然时间降为<span class="math inline">\(O(n^2)\)</span>，空间升为<span class="math inline">\(O(n^2)\)</span>。仔细观察，计算<span class="math inline">\(L(i,j)\)</span>只需要左上方<span class="math inline">\(L(i-1,j-1)\)</span>的信息，所以我们按照斜线方向计算，可以将空间优化到<span class="math inline">\(O(1)\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="comment">// from the up-right corner</span></span><br><span class="line"><span class="keyword">int</span> row = <span class="number">0</span>, col = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (row &lt; a.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> curLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = row, j = col; i &lt; a.<span class="built_in">size</span>() &amp;&amp; j &lt; b.<span class="built_in">size</span>(); ++i, ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">++curLen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">curLen = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">maxLen = <span class="built_in">max</span>(maxLen, curLen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (col &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">--col;  <span class="comment">// 斜线左移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">++row;   <span class="comment">// 斜线下移</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(TODO)输出所有的最长公共子串</p><h2 id="longest-common-subsequence">Longest Common Subsequence</h2><ul><li>Brute Force 找到<code>a</code>的所有子序列，判断是否是<code>b</code>的子序列，指数级复杂度，也就没有写出来的必要了。</li><li>DP 重叠子问题很明显，而且LCS具有最优子结构，令<span class="math inline">\(L(i,j)\)</span>表示text1[0...i]和text2[0...j]的LCS长度（不是非要以<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>作为结尾）： <span class="math display">\[L(i,j)=\begin{cases}1+L(i-1,j-1)&amp; \text{a[i]=b[j]}\\max\{L(i-1,j),L(i,j-1)\}&amp; \text{a[i]!=b[j]}\end{cases}\]</span> 为了简便，假设下标从1开始，那么边界条件：<span class="math inline">\(L(0,j)=0,L(i,0)=0\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = text1.<span class="built_in">size</span>(), n = text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">L</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    L[i][j] = <span class="number">1</span> + L[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    L[i][j] = <span class="built_in">max</span>(L[i - <span class="number">1</span>][j], L[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, L[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间和空间都是<span class="math inline">\(O(mn)\)</span>。类似的，<span class="math inline">\(L(i,j)\)</span>依赖于左上角<span class="math inline">\(L(i-1,j-1)\)</span>、左边<span class="math inline">\(L(i,j-1)\)</span>、上边<span class="math inline">\(L(i-1,j)\)</span>，可以只存储上一行和当前行的<span class="math inline">\(L\)</span>。进一步考虑：可以只存储当前行的<span class="math inline">\(L\)</span>，外加一个变量<span class="math inline">\(pre\)</span>存储左上角<span class="math inline">\(L(i-1,j-1)\)</span>，空间可以优化到<span class="math inline">\(O(min(m,n))\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = text1.<span class="built_in">size</span>(), n = text2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m &lt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">longestCommonSubsequence</span>(text2, text1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">curRow</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;++i) &#123;</span><br><span class="line">            pre = curRow[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n;++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = curRow[j];</span><br><span class="line">                <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    curRow[j] = <span class="number">1</span> + pre;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    curRow[j] = <span class="built_in">max</span>(curRow[j], curRow[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, curRow[j]);</span><br><span class="line">                pre = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(TODO)输出所有的最长公共子串 ## Longest Increasing Subsequence</p><ul><li>DP <span class="math inline">\(dp[i]\)</span>表示从左向右扫描直到以a[i]元素结尾的序列所形成的LIS的长度，且子序列包含a[i]： <span class="math display">\[dp[i]=max\{dp[i],1+dp[j]\}, 0\leq j&lt;i,a[i]&gt;a[j]\]</span></li></ul><p>最终答案即是<span class="math inline">\(dp\)</span>数组的最大值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>();++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    curMax = <span class="built_in">max</span>(curMax, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = <span class="number">1</span> + curMax;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(n^2)\)</span>，空间<span class="math inline">\(O(n)\)</span>。</p><ul><li>DP+Binary Search 遍历数组的过程中，不停填充<span class="math inline">\(dp\)</span>数组，维护<span class="math inline">\(dp\)</span>数组使得其存储递增序列： 如果<span class="math inline">\(nums[i]&lt;dp[0]\)</span>，更新<span class="math inline">\(dp[0]\)</span>； 如果<span class="math inline">\(nums[i]&gt;dp[len]\)</span>，<span class="math inline">\(++len\)</span>，并且存入<span class="math inline">\(nums[i]\)</span>； 如果<span class="math inline">\(nums[i]\)</span>介于<span class="math inline">\(dp\)</span>中间，就二分查找<span class="math inline">\(nums[i]\)</span>的位置，并更新相应的<span class="math inline">\(dp\)</span>值。 举例来说，<span class="math inline">\(nums=[0,8,4,12,2]\)</span>，<span class="math inline">\(dp\)</span>数组： <span class="math inline">\([0]\)</span> <span class="math inline">\([0,8]\)</span> <span class="math inline">\([0,4]\)</span> <span class="math inline">\([0,4,12]\)</span> <span class="math inline">\([0,2,12]\)</span> 虽然<span class="math inline">\(dp\)</span>数组最终存储的不是LIS，但长度确是LIS的长度：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; dp[<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[<span class="number">0</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; dp[len]) &#123;</span><br><span class="line">                dp[++len] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = <span class="built_in">biSearch</span>(dp, <span class="number">0</span>, len, nums[i]);</span><br><span class="line">                dp[index] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[m]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(nlgn)\)</span>，空间<span class="math inline">\(O(n)\)</span>。 ## Longest Palindromic Substring</p><ul><li>Brute Force 枚举每个子串的起始和结束位置，判断是否回文。时间<span class="math inline">\(O(n^3)\)</span>，空间<span class="math inline">\(O(1)\)</span>。</li><li>DP 假设输入<code>ababa</code>，如果我们已经判断了<code>bab</code>是回文的，那么<code>ababa</code>就不需要再扫描一遍，因为两端都是<code>a</code>。 所以一个很直观的动规： 令<span class="math inline">\(dp(i,j)\)</span>去<strong>记忆</strong><span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>之间的串是否回文，那么转移方程： <span class="math display">\[dp(i,j)=dp(i+1,j-1)\&amp;\&amp;s[i]=s[j]\]</span> 边界条件<span class="math inline">\(dp(i,i)=true,dp(i,i+1)=(s[i]=s[i+1])\)</span>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充方向：由边界条件dp(i,i)向其他地方扩展，只需要填充j&gt;i的三角形部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">length</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">length</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                    end = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][i + <span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt; s.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j] &amp;&amp; maxLen &lt; j - i + <span class="number">1</span>) &#123;</span><br><span class="line">                        start = i;</span><br><span class="line">                        end = j;</span><br><span class="line">                        maxLen = end - start + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(n^2)\)</span>，空间<span class="math inline">\(O(n^2)\)</span>。 - Expand Around Center 回文串都是镜像对称的，可以遍历整个串，从当前位置向两边延伸，直到遇到不相等的字母。这里要考虑字符串长度的奇偶：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">if</span> (!n)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> len1 = <span class="built_in">expandCenter</span>(s, i, i);</span><br><span class="line"><span class="keyword">int</span> len2 = <span class="built_in">expandCenter</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">max</span>(len1, len2);</span><br><span class="line"><span class="keyword">if</span> (len &gt; end - start + <span class="number">1</span>) &#123;</span><br><span class="line">start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">end = i + len / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expandCenter</span><span class="params">(string s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.<span class="built_in">length</span>() &amp;&amp; s[start] == s[end]) &#123;</span><br><span class="line">--start;</span><br><span class="line">++end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> end - start - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(n^2)\)</span>，空间<span class="math inline">\(O(1)\)</span>。</p><ul><li>Manacher's Algorithm（待填） 时间<span class="math inline">\(O(n)\)</span>。</li></ul><h2 id="longest-palindromic-subsequence">Longest Palindromic Subsequence</h2><ul><li>DP 令<span class="math inline">\(dp(i,j)\)</span>表示介于<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>间的LPS的长度，那么状态转移方程： <span class="math display">\[dp(i,j)=\begin{cases}2+dp(i+1,j-1)&amp; \text{s[i]=s[j]}\\max\{dp(i+1,j),dp(i,j-1)\}&amp; \text{s[i]$\neq$s[j]}\end{cases}\]</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; n;++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间<span class="math inline">\(O(n^2)\)</span>，空间<span class="math inline">\(O(n^2)\)</span>。 同样，空间可以优化到<span class="math inline">\(O(n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i) &#123;</span><br><span class="line">            pre = dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; n;++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(i == j) &#123;</span><br><span class="line">                    dp[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">                    dp[j] = pre + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = tmp;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oliver Twist</title>
      <link href="/2020/03/07/Oliver%20Twist/"/>
      <url>/2020/03/07/Oliver%20Twist/</url>
      
        <content type="html"><![CDATA[<p>对于济贫院那些绅士们而言，贫民好吃懒做、贪得无厌。他们消耗的食物即是对教区最大的威胁。</p><p>绅士们的利益得不到满足时，孤儿们只能被驱之而后快，甚至被“加价出售”。</p><blockquote><p>然而，眼泪这种东西根本无法触及Bumble先生的灵魂，他的心是防水的。</p></blockquote><p>小Oliver被卖到棺材店做学徒，受尽欺凌，却从未忘记反抗。 <img src="https://img-blog.csdnimg.cn/2020030720431780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="Oliver Twist" /> 逃离了魔窟，迎来的并非光明，而是欺骗。</p><p>骗他少不更事，骗他无依无靠，差点把他骗成了小偷。</p><blockquote><p>与其说这是白昼的诞生，不如说是黑夜的死亡。</p></blockquote><p>全书随处可见反讽口吻，英国的很多社会问题跃然纸上。</p><p>Oliver很幸运，Brownlow先生收留了他，照顾他，让他拥有了第一段短暂而又美妙的时光——小孩子应得的时光。</p><p>可是那种社会，善总是被恶击败。</p><p>无奈，重入贼巢。</p><blockquote><p>诡计多端的老犹太已经使这孩子误入歧途，他用孤独与忧郁去熏陶奥利弗的心，让他感到在这样一个阴森凄凉的地方，无论与谁为伍都比独自一人沉浸在忧愁苦恼中好受一些，他现在正将毒汁缓慢地注入Oliver的灵魂，企图熏染他，将那颗心变黑，永远改变它的颜色。</p></blockquote><p>他曾寄希望于Nancy，而Nancy亦没有辜负他。</p><p>先是保护他免遭毒打，后又不顾危险，报信给Brownlow先生。</p><p>幸运女神再一次光顾了小Oliver，枪伤让他与死神擦肩而过，来到希望的田野。</p><p>就这样开始了第二段毫无忧虑的时光。</p><blockquote><p>在睡梦中的孩子发出微笑，彷佛这些怜悯的表示唤醒了某种令人愉快的梦境，那里有他从未领略过的爱心与温情。有的时候，一支亲切的乐曲，一处幽静地方的潺潺水声，一朵花的芳香，甚而只是说出一个熟悉的字眼，会突然唤起一些模糊的记忆，那是一些不曾出现过的场景，它们会像微风一样飘散，彷佛刹那间唤醒了某种久以别离的、比较快乐的往事，而这种记忆单靠苦思冥想是怎么也想不起来的。</p></blockquote><p>Nancy是悲惨的，明明有机会逃离苦海，却因为不合时宜的爱情（也许是爱情吧）葬送了自己。</p><blockquote><p>她觉得自己积重难返，难以抛弃过去的生活，即使她讨厌它。</p></blockquote><p>天真地以为Bill会和她一起去过一些“干净”的日子。</p><p>恶的外表下隐藏着善，这无疑是可悲的，令人唏嘘的。</p><p>或许她的死亡是在救赎过去犯下的罪，是一种解脱，也是她很好的归宿了吧。</p><p>善恶终有报。</p><p>Bill杀人后疯狂地救火，不过只是掩饰自己犯下的罪行、求得一丝可怜的心理安慰而已，繁忙过后，留给他的只有煎熬和无尽的苦痛。</p><p>至于Fagin，那个恶魔</p><blockquote><p>这是他的最后一夜，一种意识到自己已经濒临绝境的幻灭感正向他那晦暗的灵魂全力袭来。</p></blockquote><p>抠抠索索一辈子，绞刑架确是他最终的栖息地。</p><p>如书中所言，</p><blockquote><p>在生活中我们不是置身事外的观众，而是粉墨登场的演员。</p></blockquote><p>降生后的角色是上帝赋予的，我们无能为力。</p><p>能做的，只是像小Oliver一样，永怀希望与感恩。</p><p>写于2018年8月26日，知乎</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Knapsack Problem</title>
      <link href="/2020/02/23/Knapsack%20Problem/"/>
      <url>/2020/02/23/Knapsack%20Problem/</url>
      
        <content type="html"><![CDATA[<figure><img src="https://img2020.cnblogs.com/blog/1260581/202110/1260581-20211025165013919-396364265.png" alt="" /><figcaption>image</figcaption></figure><h2 id="背包">0-1背包</h2><ul><li>描述：N件物品，第i件的重量是w[i]，价值v[i]。有一个容量为W的背包，求将哪些物品放入背包可使总价值最大。每件物品可以用<strong>0或1次</strong>。</li><li>分析：根据题意，可以写出表达式： <span class="math display">\[max(\Sigma v_ix_i), s.t. \Sigma w_ix_i&lt;=W, x_i\in\{0, 1\}\]</span> 最直接的思路就是：对于每件物品，都有yes/no两种选择，尝试所有的组合，记录每个组合的价值，选出满足重量条件的最大价值。时间复杂度<span class="math inline">\(O(2^n)\)</span>，空间复杂度<span class="math inline">\(O(n)\)</span>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// backtracking</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">knapsack01</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v, string&amp; ans)</span> </span>&#123;</span><br><span class="line"><span class="function">string <span class="title">cur</span><span class="params">(w.size(), <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, W, w, v, cur, ans);</span><br><span class="line"><span class="keyword">return</span> maxV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> curW, <span class="keyword">int</span> curV, <span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v, string&amp; cur, string&amp; ans)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 到达叶子结点，得到一个解，所以在这里更改最终结果</span></span><br><span class="line"><span class="keyword">if</span> (s &gt;= w.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">if</span> (maxV &lt; curV) &#123;</span><br><span class="line">ans.<span class="built_in">assign</span>(cur);</span><br><span class="line">maxV = curV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// as for goods s, two choices</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">cur[s] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curW + i * w[s] &lt;= W) &#123;</span><br><span class="line">curW += i * w[s];</span><br><span class="line">curV += i * v[s];</span><br><span class="line"><span class="built_in">dfs</span>(s + <span class="number">1</span>, curW, curV, W, w, v, cur, ans);</span><br><span class="line">curW -= i * w[s];</span><br><span class="line">curV -= i * v[s];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxV = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的程序可以通过剪枝进行优化，下来换一种思路： 令<code>dp[i][j]</code>表示有前i件物品可选，背包容量为j时具有的最大价值，问题转化为求<code>dp[N][0...W]</code>的最大值，边界条件： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一列全0，第一行取决于物品0体积与背包大小关系</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(w.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = w[<span class="number">0</span>]; j &lt;= W; ++j) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = v[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 假设3件物品，<span class="math inline">\(w=\{1,1,2\}\)</span>，<span class="math inline">\(v=\{1,2,4\}\)</span>，<span class="math inline">\(W=2\)</span>，先用递归形式分析，每件物品只有yes/no两种状态： <img src="https://img-blog.csdnimg.cn/20200223185930802.png" alt="在这里插入图片描述" /> 可以看到，求解过程中有很多<strong>重叠子问题</strong>，故可以采用记忆化递归求解，时间复杂度即为子问题数量<span class="math inline">\(O(NW)\)</span>，空间复杂度<span class="math inline">\(O(NW)\)</span>。 记忆化递归可以写成自底向上的动态规划，状态转移方程： <span class="math display">\[dp[i][j]=max\{dp[i-1][j], v[i]+dp[i-1][j-w[i]]\}\]</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp-&gt;space complexity O(NW)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">knapsack01</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N, vector&lt;<span class="keyword">int</span>&gt;(W + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = w[<span class="number">0</span>]; j &lt;= W; ++j) &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = v[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &lt; w[i]) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], v[i] + dp[i - <span class="number">1</span>][j - w[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[N - <span class="number">1</span>][W];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 前i件物品只依赖于前i-1件物品，<span class="math inline">\(dp\)</span>数组的更新方向为： <img src="https://img-blog.csdnimg.cn/20200223200829966.png" alt="在这里插入图片描述" /> 所以可以使用滚动数组降低空间复杂度为<span class="math inline">\(O(W)\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp-&gt;space complexity O(W)</span></span><br><span class="line"><span class="comment">// method 1: use temp array</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">knapsack01</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = w[i - <span class="number">1</span>]; j &lt;= W; ++j) &#123;</span><br><span class="line">temp[j] = <span class="built_in">max</span>(temp[j], v[i - <span class="number">1</span>] + dp[j - w[i - <span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line">dp.<span class="built_in">swap</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method 2: use scrolling array</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">knapsack01</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, vector&lt;<span class="keyword">int</span>&gt;&amp; w, vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = w.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = w[<span class="number">0</span>]; j &lt;= W; ++j) &#123;</span><br><span class="line">    dp[j] = v[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="comment">// iterate j reversely, avoid dp override</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= w[i]; --j) &#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], v[i] + dp[j - w[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>01背包有一些细节需要注意： - 两个for循环的先后：核心在于当前值取决于其正上方的值和上一行前面的某个值，二维中行优先和列优先都可以保证更新当前值之前其需要的两个值已经更新，故可以颠倒；一维中列优先是不可以的，因为上一行前面的某个值会被覆盖 - 二维和一维j的遍历顺序：二维正反都可以；一维只能反向，否则会被覆盖</p><p>有一道比较类似的题目<a href="https://leetcode.com/problems/target-sum/">Target Sum</a>，分析下此题顺便再练习下DP的套路。 题意是这样：给定一些<strong>非负</strong>数字，可以给每个数字添上<code>+</code>或<code>-</code>号，使得添加后的所有数字之和等于<code>S</code>。数组大小不超过20，<code>S</code>大小不超过1000。 我第一次做感觉这是个纯暴力DFS，枚举所有可能，复杂度<span class="math inline">\(O(2^n)\)</span>。 这道题和0/1背包不同之处在于：数组里的所有数字都必须用到。</p><p>接着我们试着做一些优化： 换种方式看问题：在这堆数字中选一些作为正数集合<span class="math inline">\(P\)</span>，剩下作为负数集合<span class="math inline">\(N\)</span>，那么有<span class="math inline">\(sum(P)-sum(N)=S\)</span>，<span class="math inline">\(sum(P)+sum(N)+sum(P)-sum(N)=sum(nums)+S=2*sum(P)\)</span>，故<span class="math inline">\(sum(P)=(sum(nums)+S)/2\)</span>，同时注意到<span class="math inline">\(sum(nums)+S\)</span>是偶数。 所以问题转化为在数组中寻找一些数作为正数，使得这些数的和为<span class="math inline">\((sum(nums)+S)/2\)</span>，求这样的组合有多少种。这就转化为了0/1背包问题。</p><p>我们用<span class="math inline">\(dp(i,j)\)</span>表示从前i个数中选出和为j的方案数目，有状态转移方程<span class="math inline">\(dp(i,j)=dp(i-1,j)+dp(i-1,j-nums[i])\)</span>，如果纯粹暴力递归，有很多重叠子问题（类似背包问题的那个图）。Base Case就是，<span class="math inline">\(dp(0,0)=1\)</span>，即选出和为0的方案，就是每个都不选一种；否则当<code>i = 0 || j &lt; 0</code>时，<span class="math inline">\(dp(i,j)=0\)</span>。</p><p>所以先用记忆化搜索：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">memo</span>(<span class="number">21</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">1001</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> sum &lt; S || (sum + S) &amp; <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">cnt</span>(nums, memo, nums.<span class="built_in">size</span>(), (sum + S) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp;memo, <span class="keyword">int</span> idx, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!idx &amp;&amp; !sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!idx || sum &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (memo[idx][sum] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[idx][sum];</span><br><span class="line">        memo[idx][sum] = <span class="built_in">cnt</span>(nums, memo, idx - <span class="number">1</span>, sum) + <span class="built_in">cnt</span>(nums, memo, idx - <span class="number">1</span>, sum - nums[idx - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> memo[idx][sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改一下Bottom-Up的形式，更新方向从左到右、从上到下，注意这里j不能从<code>nums[i - 1]</code>开始，否则j的前半部分无法更新到正确的值，后面如果用到就是错误的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            sum += num;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; S || (sum + S) &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">21</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">1001</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 不能for (int j = nums[i - 1]; j &lt;= (sum + S) &gt;&gt; 1; ++j)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= (sum + S) &gt;&gt; <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()][(sum + S) &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后来优化空间：<span class="math inline">\(dp(i,j)\)</span>取决于<span class="math inline">\(dp(i-1,j)\)</span>和<span class="math inline">\(dp(i-1,j-num[i-1])\)</span>，所以只要用一个一维数组<span class="math inline">\(dp(j)\)</span>记录上一行的所有值即可，这里必须反向更新，因为如果正向，上一行的j-num[i-1]位置已经被新值覆盖，计算结果出错。如果反向：上一行需要的2个位置都没有被覆盖：<span class="math inline">\(dp(j)=dp(j)+dp(j-nums[i-1])\)</span>。 初始时候(0,0)位置为1，即<span class="math inline">\(dp(0)=1\)</span>，以后<span class="math inline">\(dp(0)\)</span>会不断更新。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &lt; S || (S + sum) &amp; <span class="number">1</span> ? <span class="number">0</span> : <span class="built_in">numSubsetSum</span>(nums, (S + sum) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubsetSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">/* 等价写法</span></span><br><span class="line"><span class="comment">        for (int j = target; j &gt;= 0; --j)&#123;</span></span><br><span class="line"><span class="comment">if (j - nums[i] &gt;= 0)</span></span><br><span class="line"><span class="comment">dp[j] += dp[j - nums[i]];</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="comment">// 只有j&gt;=nums[i]才更新，否则沿用上一行的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i]; --j) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ## 完全背包 - 每件物品可以使用<strong>任意多次</strong>。 - 一个Naive的思路： 虽然题目描述每件物品可以使用任意多次，但实际上由于W的限制，每件物品最多使用<span class="math inline">\(\lfloor W/w[i] \rfloor\)</span>次。这样我们可以将每件物品拆为<span class="math inline">\(\lfloor W/w[i] \rfloor\)</span>件，问题就转化为了0-1背包。子问题仍然有NW个，但是求解每个子问题需要<span class="math inline">\(O(W/w[i])\)</span>，总的时间复杂度<span class="math inline">\(O(\Sigma (W/w[i])*W)\)</span>，也即<span class="math inline">\(O(W*拆后物品件数)\)</span>。 - 更tricky的做法：W无法改变，只能改变<strong>拆后物品件数</strong>。这里可以使用二进制的思想：假设我们某件物品可以使用<span class="math inline">\(10=8+2\)</span>次，原本需要复制出10件，现在只要复制出2件，价值和重量是原来的8倍和2倍，这样就降低了复杂度。 - 完全背包有<span class="math inline">\(O(NW)\)</span>的算法</p><p><span class="math inline">\(dp(i,j)=max\{dp(i-1,j-kw[i])+kv[i]\},0\leq kw[i]\leq j\)</span> 为了得到更加简洁的表示，考虑： <span class="math display">\[dp(i,j-w[i])=max\{dp(i-1,j-w[i]-aw[i])+av[i]\},0\leq aw[i]\leq j-w[i],a\geq 0 \\=max\{dp(i-1,j-(a+1)w[i])+av[i]\},0\leq aw[i]\leq j-w[i],a\geq 0 \\=max\{dp(i-1,j-kw[i])+(k-1)v[i]\},0\leq (k-1)w[i]\leq j-w[i],k\geq 1 \\=max\{dp(i-1,j-kw[i])+kv[i]\}-v[i],0\leq (k-1)w[i]\leq j-w[i],k\geq 1\]</span> 因此当<span class="math inline">\(k\geq 1\)</span>时有<span class="math inline">\(max\{dp(i-1,j-kw[i])+kv[i]\}=dp(i,j-w[i])+v[i]\)</span> 综上有<span class="math inline">\(dp(i,j)=max\{dp(i-1,j),dp(i,j-w[i])+v[i]\}\)</span>，状态<span class="math inline">\(dp(i,j-w[i])\)</span>包含了第i件物品被选择若干次后的最大价值。 完全背包两个for循环的顺序也可以颠倒，但是j的遍历只能而且应该正向。 ## 多重背包 - 每件物品最多可以使用<span class="math inline">\(num[i]\)</span>次。 - 同样，Naive的思路就是将每件物品都复制<span class="math inline">\(num[i]\)</span>次，问题转化为0-1背包，复杂度<span class="math inline">\(O(\Sigma nums[i]*W)\)</span>。 - 将<span class="math inline">\(num[i]\)</span>用二进制表示，价值和重量变为原来的相应倍，降低复杂度。 ## Future 后续还有混合背包、二维费用的背包等，详情可以学习<a href="https://comzyh.com/upload/PDF/Pack-PDF-Comzyh.pdf">背包九讲</a>。 </int></int></int></int>&lt;/vector<int></int>&lt;/vector<int></int></int>&lt;/vector<int></int></int></int></int></int></int></int></int></int>&lt;/vector<int></int></int></int>&lt;/vector<int></int></int></int></int></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shortest Path</title>
      <link href="/2020/02/18/Shortest%20Path/"/>
      <url>/2020/02/18/Shortest%20Path/</url>
      
        <content type="html"><![CDATA[<h2 id="dijkstra">Dijkstra</h2><p>BFS可以用来求无权图的最短路径，Dijkstra是<strong>单源最短路径</strong>算法，<strong>只能用于所有边权值为正的图</strong>，本质上还是贪心，思想：</p><ol type="1"><li>将所有结点分为两类：已经确定最短路径的点集<span class="math inline">\(u\)</span>、未确定最短路径的点<span class="math inline">\(v\)</span>；</li><li>初始化<span class="math inline">\(dis[start]=0\)</span>，其余结点<span class="math inline">\(dis\)</span>设为无穷大；</li><li>找出一个<span class="math inline">\(dis\)</span>最小的<span class="math inline">\(v\)</span>中的点<span class="math inline">\(x\)</span>，将其标记为<span class="math inline">\(u\)</span>，遍历<span class="math inline">\(x\)</span>的所有<strong>出边</strong>，若<span class="math inline">\(dis[y]&gt;dis[x]+weight\)</span>，则更新<span class="math inline">\(y\)</span>点到源点的最短路径长度<span class="math inline">\(dis[y]=dis[x]+weight\)</span>；</li><li>重复，直到所有点都在<span class="math inline">\(u\)</span>中。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 邻接矩阵版，适合顶点比较少的图，复杂度O(V^2) */</span></span><br><span class="line"><span class="keyword">int</span> vertexNum, adjMatrix[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];  <span class="comment">// 起点到各点最短路径长度</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXN] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexNum; i++) &#123;</span><br><span class="line">dis[i] = INFINITY;</span><br><span class="line">&#125;</span><br><span class="line">dis[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexNum; i++) &#123;</span><br><span class="line"><span class="comment">// 寻找未访问点中dis最小的</span></span><br><span class="line"><span class="keyword">int</span> u = <span class="number">-1</span>, minDis = INFINITY;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexNum; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; minDis) &#123;</span><br><span class="line">u = j;</span><br><span class="line">minDis = dis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (u == <span class="number">-1</span>)  <span class="comment">// 剩余的点与起点不连通</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">visited[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 以u为中介试图优化dis[j]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexNum; j++) &#123;</span><br><span class="line"><span class="comment">// 未访问、u可达、路过u可以使dis[j]更优</span></span><br><span class="line"><span class="keyword">if</span> (visited[j] == <span class="literal">false</span> &amp;&amp; adjMatrix[u][j] != INFINITY &amp;&amp; dis[u] + adjMatrix[u][j] &lt; dis[j])</span><br><span class="line">dis[j] = dis[u] + adjMatrix[u][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 邻接表版，复杂度O(V^2+E) */</span></span><br><span class="line"><span class="keyword">int</span> vertexNum;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];  <span class="comment">// dis[i]表示源点到i点的最小距离</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXN] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> des;  <span class="comment">// 边的目标顶点</span></span><br><span class="line"><span class="keyword">int</span> weight;  <span class="comment">// 边的权值</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; adjList[MAXN];   <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; vertexNum;i++) &#123;</span><br><span class="line">dis[i] = INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line">dis[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; vertexNum;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = <span class="number">-1</span>, minDis = INT_MAX;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; vertexNum;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(visited[j] == <span class="literal">false</span> &amp;&amp; dis[j] &lt; minDis) &#123;</span><br><span class="line">u = j;</span><br><span class="line">minDis = dis[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(u == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">visited[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; adjList[u].<span class="built_in">size</span>();j++) &#123;</span><br><span class="line"><span class="comment">// 直接获得u能到达的点</span></span><br><span class="line"><span class="keyword">int</span> v = adjList[u][j].des;</span><br><span class="line"><span class="keyword">if</span>(visited[v] == <span class="literal">false</span> &amp;&amp; dis[v] &gt; dis[u] + adjList[u][j].weight) &#123;</span><br><span class="line">dis[v] = dis[u] + adjList[u][j].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找<span class="math inline">\(dis[u]\)</span>的循环可以用堆来优化，使得复杂度降为<span class="math inline">\(O(VlogV+E)\)</span>。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    pq = []</span><br><span class="line">    heapq.heappush(pq, (<span class="number">0</span>, s))</span><br><span class="line"></span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    parent = &#123;s : <span class="literal">None</span>&#125;</span><br><span class="line">    dis = &#123;s : <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> g:</span><br><span class="line">        <span class="keyword">if</span> v != s:</span><br><span class="line">            dis[v] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(pq) &gt; <span class="number">0</span>):</span><br><span class="line">        pair = heapq.heappop(pq)</span><br><span class="line">        cur_dis = pair[<span class="number">0</span>]</span><br><span class="line">        cur_vertex = pair[<span class="number">1</span>]</span><br><span class="line">        marked.add(cur_vertex)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur_vertex].keys():</span><br><span class="line">            <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                <span class="keyword">if</span> cur_dis + g[cur_vertex][adj] &lt; dis[adj]:</span><br><span class="line">                    heapq.heappush(pq, (cur_dis + g[cur_vertex][adj], adj))</span><br><span class="line">                    parent[adj] = cur_vertex</span><br><span class="line">                    dis[adj] = cur_dis + g[cur_vertex][adj]</span><br><span class="line">    <span class="keyword">return</span> parent, dis</span><br></pre></td></tr></table></figure></p><h2 id="bellman-ford">Bellman-Ford</h2><p>可以计算含有负权的边，检测是否存在一个从源结点可以到达的权重为负值的环路（负权环）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellmanFord</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edge, vector&lt;<span class="keyword">int</span>&gt;&amp; dis, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == start)</span><br><span class="line">dis[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dis[i] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.<span class="built_in">size</span>(); ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edge.<span class="built_in">size</span>(); ++j)</span><br><span class="line">dis[edge[j][<span class="number">1</span>]] = <span class="built_in">min</span>(dis[edge[j][<span class="number">1</span>]], dis[edge[j][<span class="number">0</span>]] + edge[j][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> negCycle = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge.<span class="built_in">size</span>(); ++i)</span><br><span class="line"><span class="keyword">if</span> (dis[edge[i][<span class="number">1</span>]] &gt; dis[edge[i][<span class="number">0</span>]] + edge[i][<span class="number">2</span>]) &#123;</span><br><span class="line">negCycle = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> negCycle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度<span class="math inline">\(O(VE)\)</span>。 ## Floyd-Warshall 多源最短路径算法。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> k = <span class="number">0</span>;k &lt; m.<span class="built_in">size</span>();++k)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; m.<span class="built_in">size</span>();++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line"><span class="comment">// m不能用INT_MAX初始化，会溢出，用0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">if</span> (m[i][k] + m[k][j] &lt; m[i][j])</span><br><span class="line">m[i][j] = m[i][k] + m[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 不能用于含有<strong>负权环</strong>的图，这种图不存在最短路径。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CompressIt</title>
      <link href="/2020/02/13/CompressIt/"/>
      <url>/2020/02/13/CompressIt/</url>
      
        <content type="html"><![CDATA[<h2 id="结构">结构</h2><p>压缩软件的核心在于压缩算法。基于Huffman编码的压缩算法思路：</p><ol type="1"><li>以<strong>二进制方式</strong>读取源文件，按照每8bits作为一个字符；</li><li>统计每个字符的出现频率即为叶子结点的权值，按照Huffman算法得到每个叶子的编码；</li><li>对源文件的每个字符，将新的编码组合为二进制流，按照每8bits一个单位写入压缩文件。</li></ol><p>举例来看： 假设我们有待压缩源文件<code>hello</code>，<code>h</code>的ASCII码为<code>01101000</code>，同理可得整个文件的二进制形式<code>0110100001100101011011000110110001101111</code>，共5B，40bits。 根据Huffman算法：得到<code>h</code>的编码为<code>00</code>，同理可得整个文件的Huffman编码为<code>0001111110</code>，末尾不够8bits，采用补0的方法可得<code>0001111110000000</code>，按照每8bits一个单位，写入压缩文件的是<code>31</code>和<code>255</code>对应的字符，共2B，16bits。 解压缩流程是压缩的逆过程：</p><ol type="1"><li>以<strong>二进制方式</strong>读取压缩文件；</li><li>每次取1bit，从Huffman树的根结点出发，找到某个叶子即为源字符。</li></ol><h2 id="效果">效果</h2><p>做一个简单的比较：</p><table><thead><tr class="header"><th>压缩软件</th><th>测试文件</th><th>压缩率</th><th>测试文件</th><th>压缩率</th></tr></thead><tbody><tr class="odd"><td>CompressIt</td><td>txt(840B)</td><td>70.4%</td><td>png(282KB)</td><td>101%</td></tr><tr class="even"><td>WinRaR</td><td>txt(840B)</td><td>14.4%</td><td>png(282KB)</td><td>100%</td></tr></tbody></table><p>压缩率和压缩时间和专业软件没法比。之所以出现压缩文件大于源文件，是因为压缩文件中还存储了Huffman树等信息，为解压所需。 对于不同内容的文件，得到的压缩文件大小也不尽相同，这主要与Huffman编码的性质有关。 ## 理论分析 Huffman编码依赖于信源的统计特征，其背后的原理在于为出现频率高的字符分配尽可能短的码长，这样就可以降低平均码长： <span class="math display">\[L=\Sigma p_il_i\]</span> 使得<span class="math inline">\(L\)</span>最短的编码就是最优编码，可以证明Huffman编码是一种最优编码。 同时Huffman编码还是前缀码，简化了解码过程。 假设一种理想情况：源文件长<span class="math inline">\(len\)</span>很大，共有<span class="math inline">\(m\)</span>种不同字符，每个字符用8bits表示，并且每种字符出现频率<span class="math inline">\(\frac{len}{m}\)</span>相同，忽略掉存储Huffman树等信息所需的空间。 这棵完全二叉树共有结点<span class="math inline">\(n=2*m-1\)</span>个，那么树深度为<span class="math inline">\(h=1+\lfloor log_2n \rfloor\)</span>，每个字符的压缩长度为<span class="math inline">\(h-1=\lfloor log_2n \rfloor\)</span>，故压缩后的串长度为<span class="math inline">\(\frac{(h-1)*len}{8}\)</span>，可得压缩率<span class="math inline">\(\frac{h-1}{8}\)</span>，即： <span class="math display">\[\alpha=\frac{\lfloor log_2(2*m-1) \rfloor}{8}\]</span> 源文件中不同字符种类<span class="math inline">\(m\)</span>越小，即源文件分布越集中，压缩效果越好。 如果和定长编码比较，可以得到压缩率： <span class="math display">\[\alpha=\frac{\lfloor log_2(2*m-1) \rfloor}{\lceil log_2(m) \rceil}\]</span> <span class="math inline">\(m\)</span>取值256时，Huffman树是一棵满二叉树，压缩率为100%，并不比8位固定长度编码更高效。 ## 收获</p><ul><li><code>EOF</code>和<code>feof()</code> <code>EOF</code>是一个定义在<code>cstdio</code>头文件中的宏，一般为-1：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EOF (-1)</span></span><br></pre></td></tr></table></figure><p>但是如果按照二进制读取文件，对于文件中的-1又该如何处理？ 阮一峰的博客说：</p><blockquote><p>在Linux系统之中，EOF根本不是一个字符，而是当系统读取到文件结尾，所返回的一个信号值（也就是-1）。至于系统怎么知道文件的结尾，资料上说是通过比较文件的长度。</p></blockquote><p>我们通常会写出下面程序来读取文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = <span class="built_in">fgetc</span>(fp)) != EOF) &#123;</span><br><span class="line"><span class="comment">// your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是<code>fgetc()</code>在到达文件结尾和发生读取错误的情况下都会返回<code>EOF</code>，所以上述代码不严谨，采用<code>feof()</code>函数来判断文件结尾：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">feof</span>(fp)) &#123;</span><br><span class="line">ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line"><span class="comment">// your code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是采用<code>feof()</code>也有一个问题：读取最后一个字符后，<code>feof()</code>仍然返回0，进入循环，<code>fgetc()</code>再向后读取一个字符，<code>feof()</code>才返回1，这样程序会多循环一次。 所以比较安全的写法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line"><span class="keyword">while</span> (ch != EOF) &#123;</span><br><span class="line"><span class="comment">// your code here</span></span><br><span class="line">ch = <span class="built_in">fgetc</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">feof</span>(fp))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;End-of-File reached.&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Something went wrong.&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>虚析构函数 基类的析构函数一般写成虚函数，做个测试：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">base</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">base</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;destructor in base&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f in base&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derive</span> :</span><span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">derive</span>() &#123;&#125;;</span><br><span class="line">~<span class="built_in">derive</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;destructor in derive&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f in derive&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">base* p = <span class="keyword">new</span> derive;</span><br><span class="line">p-&gt;<span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f in derive</span><br><span class="line">destructor in derive</span><br><span class="line">destructor in base</span><br></pre></td></tr></table></figure><p>如果基类的析构函数不是虚函数，输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f in derive</span><br><span class="line">destructor in base</span><br></pre></td></tr></table></figure><p>结果并没有调用派生类的析构函数，造成内存泄漏。 所以基类的虚析构函数的作用是：<strong>当一个基类指针删除一个派生类对象，确保调用派生类的析构函数</strong>。 - 二进制文件 在压缩过程中，对于不同格式源文件的读取都是采用二进制方式<code>rb</code>。 实际上二进制文件和文本文件并没有本质区别，你所看到的内容取决于打开文件的软件对二进制流的解释方式，文件扩展名帮助计算机知道应该用哪种解释方式，通常的文本文件的解释方式有ASCII码和Unicode码。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Union-Find</title>
      <link href="/2020/01/26/Union-Find/"/>
      <url>/2020/01/26/Union-Find/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>并查集是一种用来维护集合的数据结构，底层通过<code>parent</code>数组实现，每个集合只有唯一的根结点，并将其作为该集合的标志。</p><p>并查集有两个基本操作： 1. 并：合并两集合； 2. 查：查询某元素的父结点。</p><p>初始化所有元素都是一个独立的集合： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> parent[MAXN];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    parent[i] = i;    <span class="comment">// i元素的父结点初始化为自己，也可以初始化为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="合并与查找">合并与查找</h2><ul><li>Find 查找某个元素属于哪个集合（如果单独成集就返回自己），返回该集合的代表元素（即parent为-1的那个元素/parent为自身的那个元素）。 查找的同时可以通过<strong>路径压缩</strong>来将均摊复杂度降低为<span class="math inline">\(O(1)\)</span>。查找某个结点时，将其经过的全部结点直接连到父结点，这样下次查询时次数就会减少。</li><li>Union 合并时可以遵循<strong>按秩合并</strong>原则，将秩小的树合并到秩大的树，降低路径压缩时的开销。 将两个不同的集合合并为一个集合，只要将其中一个集合的根结点的<code>parent</code>指向另一个集合的根结点即可。 对于属于同一个集合的两个元素的合并没有意义，所以我们一般只对两个不同的集合进行合并，这样避免同一个集合成环，因此并查集的每个集合都是一棵树。</li></ul><p>并查集可以将均摊复杂度变为<span class="math inline">\(O(1)\)</span>，但如果涉及到删除元素、计算每个集合元素个数等操作时，实现会有些复杂； 好吧！计算每个集合元素个数以及统计有多少个集合并不复杂，计算元素个数可以开一个数组cnt初始全为1，每次merge都更新cnt即可，cnt[i]即为根为i的集合包含的元素个数 统计多少个集合遍历所有元素，遇到不同的根结点就更新ans。</p><p><a href="https://www.zxpblog.cn/2020/02/17/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%AD%97%E5%85%B8%E6%A0%91%E5%92%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/">最原始的并查集</a>虽然复杂度稍差，但是可以完成的功能比较多。 <a href="https://www.cnblogs.com/EIMadrigal/p/12693959.html">原始并查集实现</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unionFind</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; parents_;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ranks_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unionFind</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;++i) &#123;</span><br><span class="line">            parents_.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            ranks_.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the root of x</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// path compression</span></span><br><span class="line">        <span class="keyword">if</span>(x != parents_[x]) &#123;</span><br><span class="line">            parents_[x] = <span class="built_in">Find</span>(parents_[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parents_[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge set u and v</span></span><br><span class="line">    <span class="comment">// false -&gt; u and v are already in one set</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootu = <span class="built_in">Find</span>(u);</span><br><span class="line">        <span class="keyword">int</span> rootv = <span class="built_in">Find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(rootu == rootv)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// merge low rank to high rank</span></span><br><span class="line">        <span class="keyword">if</span>(ranks_[rootu] &lt; ranks_[rootv]) &#123;</span><br><span class="line">            parents_[rootu] = rootv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ranks_[rootv] &lt; ranks_[rootu]) &#123;</span><br><span class="line">            parents_[rootv] = rootu;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            parents_[rootu] = rootv;</span><br><span class="line">            ++ranks_[rootv];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一道例题：<a href="https://www.luogu.com.cn/problem/P1551">亲戚</a> 不做路径压缩可以求<a href="https://www.nowcoder.com/profile/135924065/codeBookDetail?submissionId=83987857">最小环长</a></p><p>检测无向图是否有环：对于图中每条边（类似kruskal），不断将结点通过并查集合并，如果在加入边(i,j)前，i和j已经同属一个集合，意味着i和j必然有某条其他路径连通，那么这条路径和该边一起必然构成环。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; g;  <span class="comment">// edge list</span></span><br><span class="line">g.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">g.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">g.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_cycle</span><span class="params">(vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; g)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> rootx = <span class="built_in">Find</span>(g[i].first);</span><br><span class="line"><span class="keyword">int</span> rooty = <span class="built_in">Find</span>(g[i].second);</span><br><span class="line"><span class="keyword">if</span> (rootx == rooty) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Union</span>(rootx, rooty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="种类并查集todo">种类并查集（TODO）</h2><p>普通并查集的特点就是只有一个集合，比如上述例题只有亲戚一个集合。如果涉及到多个集合，就需要种类并查集。 假如有n个集合，常用的手法就是开一个n倍大小的并查集。 <a href="https://www.luogu.com.cn/problem/P2024">食物链</a> <a href="https://www.luogu.com.cn/problem/P1892">团伙</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linked List-3</title>
      <link href="/2020/01/26/Linked%20List-3/"/>
      <url>/2020/01/26/Linked%20List-3/</url>
      
        <content type="html"><![CDATA[<p>第一篇<a href="https://www.cnblogs.com/EIMadrigal/p/12130882.html">终结Linked List（一）</a>、<a href="https://www.cnblogs.com/EIMadrigal/p/12130892.html">终结Linked List（二）</a>主要讲了单链表的基础知识，接下来的第二篇主要讲一些比较经典的问题。 ## 一、<code>Count()</code> 给一个单链表和一个整数，返回这个整数在链表中出现了多少次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Given a list and an int, return the number of times </span><br><span class="line">that int ocucurs in the list.</span><br><span class="line">*/</span><br><span class="line">int Count(struct node* head,int searchFor)</span><br><span class="line">&#123;</span><br><span class="line">int cnt = 0;</span><br><span class="line">struct node* cur = head;</span><br><span class="line"></span><br><span class="line">while (cur != NULL)</span><br><span class="line">&#123;</span><br><span class="line">if (cur-&gt;data == searchFor)</span><br><span class="line">cnt++;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用<code>for</code>循环实现。 ## 二、<code>GetNth()</code> 给一个单链表和一个index，返回index位置上的数值，类似<code>array[index]</code>操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Given a list and an index, return the data in the nth</span><br><span class="line">node of the list. The nodes are numbered from 0.</span><br><span class="line">Assert fails if the index is invalid (outside 0..length - 1).</span><br><span class="line">*/</span><br><span class="line">int GetNth(struct node* head,int index)</span><br><span class="line">&#123;</span><br><span class="line">int len = 0;</span><br><span class="line">struct node* cur = head;</span><br><span class="line"></span><br><span class="line">while (cur)</span><br><span class="line">&#123;</span><br><span class="line">if (len == index)</span><br><span class="line">&#123;</span><br><span class="line">return cur-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(0);  //如果走到这一行，表达式的值为假，断言失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三deletelist">三、<code>DeleteList()</code></h2><p>给一个单链表，删除所有节点，使<code>head</code>为<code>NULL</code>。 删除链表<code>&#123;1,2,3&#125;</code>的示意图： <img src="https://img-blog.csdnimg.cn/201904071952350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void DeleteList(struct node** headRef)</span><br><span class="line">&#123;</span><br><span class="line">struct node* cur = *headRef;  //deref headRef to get the real head</span><br><span class="line"></span><br><span class="line">while (*headRef)</span><br><span class="line">&#123;</span><br><span class="line">cur = *headRef;</span><br><span class="line">*headRef = cur-&gt;next;</span><br><span class="line">free(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 四、<code>Pop()</code> 给一个链表，删掉头节点，返回头节点的数据。 内存示意图： <img src="https://img-blog.csdnimg.cn/20190407230157807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">The opposite of Push().Takes a non-empty list and </span><br><span class="line">remove the front node, and returns the data which was in that node.</span><br><span class="line">*/</span><br><span class="line">int pop(struct node** headRef)</span><br><span class="line">&#123;</span><br><span class="line">assert(*headRef != NULL);</span><br><span class="line">int ans = (*headRef)-&gt;data;  //pull out the data before the node is deleted</span><br><span class="line"></span><br><span class="line">struct node* cur = *headRef;</span><br><span class="line">*headRef = (*headRef)-&gt;next;   //unlink the head node for the caller</span><br><span class="line">free(cur);    //free the head node</span><br><span class="line"></span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五insertnth">五、<code>InsertNth()</code></h2><p>可以在<code>[0,length]</code>的任意位置插入指定元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">A more general version of Push().</span><br><span class="line">Given a list, an index &#x27;n&#x27; in the range 0..length,</span><br><span class="line">and a data element, add a new node to the list so that</span><br><span class="line">it has the given index.</span><br><span class="line">*/</span><br><span class="line">void InsertNth(struct node** headRef,int index,int data)</span><br><span class="line">&#123;</span><br><span class="line">//position 0 is a special case</span><br><span class="line">if (index == 0)</span><br><span class="line">&#123;</span><br><span class="line">Push(headRef, data);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">int cnt = 0;</span><br><span class="line">struct node* cur = *headRef;</span><br><span class="line"></span><br><span class="line">while (cnt &lt; index - 1)</span><br><span class="line">&#123;</span><br><span class="line">assert(cur != NULL);   //if this fails, the index was too big</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(cur != NULL);    //tricky:you have to check one last time</span><br><span class="line"></span><br><span class="line">Push(&amp;(cur-&gt;next), data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码坑有点多，可以通过<strong>画图</strong>或者<strong>单步跟踪</strong>的方法调试。 <code>InsertNthTest()</code>可以用来测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void InsertNthTest()</span><br><span class="line">&#123;</span><br><span class="line">struct node* head = NULL;   //start with the empty list</span><br><span class="line"> </span><br><span class="line">InsertNth(&amp;head, 0, 13);   //&#123;13&#125;</span><br><span class="line">InsertNth(&amp;head, 1, 42);    //&#123;13,42&#125;</span><br><span class="line">InsertNth(&amp;head, 1, 5);     //&#123;13,5,42&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六sortedinsert">六、<code>SortedInsert()</code></h2><p>给定一个有序链表和一个节点，将该节点插入到合适的位置。 共有三种方法： 1、Uses special case code for the head end <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void SortedInsert(struct node** headRef,struct node* newNode)</span><br><span class="line">&#123;</span><br><span class="line">//Special case for the head end</span><br><span class="line">if (newNode-&gt;data &lt;= (*headRef)-&gt;data || *headRef == NULL)</span><br><span class="line">&#123;</span><br><span class="line">newNode-&gt;next = *headRef;</span><br><span class="line">*headRef = newNode;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">//Locate the node before the point of insertion</span><br><span class="line">struct node* cur = *headRef;</span><br><span class="line">while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;data &lt; newNode-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2、Dummy node strategy for the head end 用<code>dummy node</code>这种方法一般不需要处理特殊情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void SortedInsert2(struct node** headRef,struct node* newNode) &#123;</span><br><span class="line">struct node dummy;</span><br><span class="line">struct node* cur = &amp;dummy</span><br><span class="line">dummy.next = *headRef;</span><br><span class="line"></span><br><span class="line">while (cur-&gt;next &amp;&amp; newNode-&gt;data &gt;= cur-&gt;next-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = newNode;</span><br><span class="line"></span><br><span class="line">*headRef = dummy.next;  //头指针永远指向dummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Local references strategy for the head end</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void SortedInsert3(struct node** headRef,struct node* newNode)</span><br><span class="line">&#123;</span><br><span class="line">struct node** curRef = headRef;</span><br><span class="line"></span><br><span class="line">while (*curRef &amp;&amp; (*curRef)-&gt;data &lt;= newNode-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">curRef = &amp;((*curRef)-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newNode-&gt;next = *curRef;  //Bug:(*curRef)-&gt;next  is incorrect</span><br><span class="line"></span><br><span class="line">*curRef = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表反转">链表反转</h2><p>206 92 25 链表反转的题目都是套路，如果要反转[l,r)内的部分，需要记录l的前一个结点 让cur = l, prev = r 循环次数等于[l,r)内的结点数，每次循环都是标准操作 tmp = cur.next cur.next = prev prev = cur cur = tmp 最终cur指向r，prev指向l即反转后的第一个结点 头结点主要看你是反转整个链表还是一部分，反转整个链表就没必要了，因为l直接指向头结点 92题可以直接按照上述方法做，但是开始要把r指向正确的位置，相当于多走了一遍，因此开始把prev设置为None，反转结束先通过l前一个结点修正l的指针指向cur，再让l前一个结点指向prev</p><p>25题因为要分组反转，所以需要判断剩余的结点够不够k个，因此r必然需要向后走一遍去判断，因此[l,r)肯定要走2遍。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Minimum Spanning Tree</title>
      <link href="/2020/01/26/Minimum%20Spanning%20Tree/"/>
      <url>/2020/01/26/Minimum%20Spanning%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="一prim">一、Prim</h2><p>Prim算法的思想是：</p><ol type="1"><li>整个顶点集为<span class="math inline">\(V\)</span>，初始选一个起点<span class="math inline">\(s\)</span>，令集合<span class="math inline">\(u=\{s\}, v=\{\}\)</span>；</li><li>在集合<span class="math inline">\(u\)</span>与集合<span class="math inline">\(V-u\)</span>中的点组成的边中，选一条权值最小的边<span class="math inline">\(u_0v_0\)</span>加入MST，并且将<span class="math inline">\(u_0\)</span>加入<span class="math inline">\(u\)</span>；</li><li>重复直到MST有<span class="math inline">\(n-1\)</span>条边或<span class="math inline">\(n\)</span>个顶点为止。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> adjMax[MAXN][MAXN];  <span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;   <span class="comment">//顶点数目</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN] = &#123;<span class="number">0</span>&#125;, cost[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cost[i] = adjMax[<span class="number">0</span>][i];  <span class="comment">//集合u与集合V-u中的i点间距离最小值</span></span><br><span class="line">visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">visited[<span class="number">0</span>] = <span class="literal">true</span>;   <span class="comment">//已经在MST中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)  <span class="comment">//再找n-1个点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//找到连接u和V-u的最小边并记录位置</span></span><br><span class="line"><span class="keyword">int</span> tmp = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[j] == <span class="literal">false</span> &amp;&amp; cost[j] &lt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">tmp = cost[j];</span><br><span class="line">pos = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans += tmp;</span><br><span class="line">visited[pos] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入某点后，V-u中的点j到u的距离可能变短，故更新cost[j]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[j] == <span class="literal">false</span> &amp;&amp; cost[j] &gt; adjMax[pos][j])</span><br><span class="line">&#123;</span><br><span class="line">cost[j] = adjMax[pos][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能：邻接矩阵表示不依赖于边数，复杂度<span class="math inline">\(O(|V|^2)\)</span>，适合边稠密的图。 ## 二、Kruskal 该算法思想：将所有边的权值递增排序，如果加入某边后不构成回路，则将该边加入MST，直到MST中有<span class="math inline">\(n-1\)</span>条边或<span class="math inline">\(n\)</span>个顶点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用结构体存储边的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> start, des;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;edge[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//用并查集判断有没有环</span></span><br><span class="line"><span class="keyword">int</span> UFSets[MAXN];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">UFSets[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在S中查找并返回包含x的树的根</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (S[x] &gt;= <span class="number">0</span>)</span><br><span class="line">x = S[x];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = <span class="built_in">find</span>(UFSets, edge[i].start);</span><br><span class="line"><span class="keyword">int</span> v = <span class="built_in">find</span>(UFSets, edge[i].des);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (u == v)  <span class="comment">//edge[i]的两端点有相同的祖先，成环</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">ans += edge[i].val;</span><br><span class="line">UFSets[u] = v;  <span class="comment">//合并两个并查集</span></span><br><span class="line">cnt++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cnt == n - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>性能：复杂度<span class="math inline">\(O(ElogE)\)</span>，适合边稀疏、顶点多的图。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Segment Tree</title>
      <link href="/2020/01/15/Segment%20Tree/"/>
      <url>/2020/01/15/Segment%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="引言">引言</h2><p><a href="https://leetcode.com/problems/range-sum-query-mutable/">Leetcode307</a> 这道题如果没有优化, 那么单次query的时间复杂度<span class="math inline">\(O(n)\)</span>, 单次update复杂度<span class="math inline">\(O(1)\)</span> 如果用前缀和数组, 那么单次query的时间复杂度<span class="math inline">\(O(1)\)</span>, 单次update复杂度<span class="math inline">\(O(n)\)</span>, 因为update(i)会使得前缀和数组i以后的元素均更新</p><p>因此如果query和update非常多次, 上面的2种方式效率都比较低.</p><p>这道题除了使用树状数组，还可以使用线段树。 线段树是一种平衡二叉树，支持快速区间查找<span class="math inline">\(O(lgn+k)\)</span>和更新<span class="math inline">\(O(lgn)\)</span>。</p><h2 id="线段树">线段树</h2><p>线段树核心思想是叶子结点负责保存原始信息，非叶结点负责其孩子表示范围的union，可以是求和、最值等： <img src="https://img-blog.csdnimg.cn/20200115103411544.png" alt="在这里插入图片描述" /> 对于每个结点，需要存储起始点、终止点、值、左右指针：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">segTreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">segTreeNode</span>(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> val, segTreeNode* left = <span class="literal">nullptr</span>, segTreeNode* right = <span class="literal">nullptr</span>) : <span class="built_in">start</span>(start), <span class="built_in">end</span>(end), <span class="built_in">val</span>(val), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">segTreeNode</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span> left;</span><br><span class="line"><span class="keyword">delete</span> right;</span><br><span class="line">left = right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">int</span> end;</span><br><span class="line"><span class="keyword">int</span> val;    <span class="comment">// can be sum, min, max...</span></span><br><span class="line">segTreeNode* left;</span><br><span class="line">segTreeNode* right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建树可以通过递归方式进行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">segTreeNode* <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start == end)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">segTreeNode</span>(start, end, nums[start]);</span><br><span class="line"><span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> left = <span class="built_in">buildTree</span>(start, mid, nums);</span><br><span class="line"><span class="keyword">auto</span> right = <span class="built_in">buildTree</span>(mid + <span class="number">1</span>, end, nums);</span><br><span class="line"><span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">segTreeNode</span>(start, end, left-&gt;val + right-&gt;val, left, right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<strong>更新</strong>操作，只要找到叶子结点，一路向上更新至根结点，复杂度<span class="math inline">\(O(lgn)\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(segTreeNode* root, <span class="keyword">int</span> i, <span class="keyword">int</span> newVal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;start == i &amp;&amp; root-&gt;end == i) &#123;</span><br><span class="line">root-&gt;val = newVal;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = root-&gt;start + (root-&gt;end - root-&gt;start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (i &lt;= mid)</span><br><span class="line"><span class="built_in">update</span>(root-&gt;left, i, newVal);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">update</span>(root-&gt;right, i, newVal);</span><br><span class="line">root-&gt;val = root-&gt;left-&gt;val + root-&gt;right-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<strong>查询</strong>操作，查询范围有三种情况：</p><ol type="1"><li>范围正好和根结点负责的范围一致，直接返回；</li><li>范围由某个下层结点负责，找到该结点返回其值；</li><li>范围由两个下层结点组合负责，返回两个结点的sum。</li></ol><p>查询最好情况复杂度<span class="math inline">\(O(1)\)</span>，最坏情况<span class="math inline">\(O(lgn+k)\)</span>，<span class="math inline">\(k\)</span>是某层结点的数目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(segTreeNode* root, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i == root-&gt;start &amp;&amp; j == root-&gt;end)</span><br><span class="line"><span class="keyword">return</span> root-&gt;val;</span><br><span class="line"><span class="keyword">int</span> mid = root-&gt;start + (root-&gt;end - root-&gt;start) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= mid)  <span class="comment">// 查询范围完全落在左子树</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(root-&gt;left, i, j);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; mid)  <span class="comment">// 查询范围完全落在右子树</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(root-&gt;right, i, j);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(root-&gt;left, i, mid) + <span class="built_in">query</span>(root-&gt;right, mid + <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><ul><li><a href="https://zxi.mytechroad.com/blog/sp/segment-tree-sp14/">花花酱 Segment Tree 线段树 SP14</a></li><li><a href="https://www.cnblogs.com/TenosDoIt/p/3453089.html">一步一步理解线段树</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Binary Index Tree</title>
      <link href="/2020/01/13/Binary%20Index%20Tree/"/>
      <url>/2020/01/13/Binary%20Index%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="引言">0 引言</h2><p><a href="https://leetcode.com/problems/range-sum-query-mutable/">Leetcode307</a> 这道题给一个<strong>可变</strong>数组，求从<span class="math inline">\(i\)</span>到<span class="math inline">\(j\)</span>的元素之和。 一个naive的做法是，每次查询都从<span class="math inline">\(i\)</span>累加到<span class="math inline">\(j\)</span>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        nums_ = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        nums_[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = i;l &lt;= j;++l)</span><br><span class="line">            ans += nums_[l];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法每次更新的复杂度为<span class="math inline">\(O(1)\)</span>，<strong>每次查询</strong>的复杂度为<span class="math inline">\(O(n)\)</span>。 ## 1 树状数组 为了降低查询的复杂度，引入Binary Index Tree(Fenwick Tree)： BIT其实并不是树，而是维护了一个前缀和数组<code>prefixSums_</code>： 假设有一个数组： <img src="https://img-blog.csdnimg.cn/20200113150644122.png" alt="在这里插入图片描述" /> 那么我们的tree： <img src="https://img-blog.csdnimg.cn/20200113151522944.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 0是dummy node，将结点的二进制表示的最后一个1翻转，就能得到其父结点。</p><p>下来填充这棵树： <span class="math inline">\(1=0+2^0\)</span>，存储从下标0开始的前1个数的和：3（0，0）； <span class="math inline">\(2=0+2^1\)</span>，存储从下标0开始的前2个数的和：5（0，1）； <span class="math inline">\(3=2^1+2^0\)</span>，存储从下标2开始的前1个数的和：-1（2，2）； <span class="math inline">\(4=0+2^2\)</span>，存储从下标0开始的前4个数的和：10（0，3）； <span class="math inline">\(5=2^2+2^0\)</span>，存储从下标4开始的前1个数的和：5（4，4）； <span class="math inline">\(6=2^2+2^1\)</span>，存储从下标4开始的前2个数的和：9（4，5）； <span class="math inline">\(7=2^2+2^1+2^0\)</span>，存储从下标6开始的前1个数的和：-3（6，6）； <span class="math inline">\(8=0+2^3\)</span>，存储从下标0开始的前8个数的和：19（0，7）； <span class="math inline">\(9=2^3+2^0\)</span>，存储从下标8开始的前1个数的和：7（8，8）； <span class="math inline">\(10=2^3+2^1\)</span>，存储从下标8开始的前2个数的和：9（8，9）； <span class="math inline">\(11=2^3+2^1+2^0\)</span>，存储从下标10开始的前1个数的和：3（10，10）； 填充后的tree： <img src="https://img-blog.csdnimg.cn/20200113154240511.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 接下来就可以根据这棵树来计算<code>prefixSums_</code>： 假如要计算<span class="math inline">\(0-5\)</span>的和，从下标6出发，一直加到dummy node，得到<code>prefixSums_[6]=9+10=19</code>； 要计算<span class="math inline">\(0-9\)</span>的和，从下标10出发，一直加到dummy node，得到<code>prefixSums_[10]=9+19=28</code>。 以计算<span class="math inline">\(0-9\)</span>的和为例，结点10存储的是（8，9）的<strong>部分和</strong>，结点8存储的是（0，7）的<strong>部分和</strong>，所以加起来就是<span class="math inline">\(0-9\)</span>的和。 ## 2 快速实现 上面求结点的父结点、将下标拆解为二进制去填充树的方式很慢，来看一种稍快的方式。 <strong>查询</strong>时，我们需要计算从某结点到dummy node的和，这就涉及计算该结点的parent： 假如要求结点7的parent，7的二进制原码为<code>111</code>，-7的补码为<code>001</code>，将原码和补码按位与得<code>001</code>，用原码减去<code>001</code>，得<code>110=6</code>，即7的父结点是6。 <strong>更新</strong>时，我们需要更新所有包含该结点的部分和结点： 假如更新了结点1，1的二进制原码为<code>001</code>，-1的补码为<code>111</code>，将原码和补码按位与得<code>001</code>，用原码加上<code>001</code>，得<code>010=2</code>，即还要更新结点2，更新了结点2，还要更新结点4...... 最后来看下非常简洁的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; prefixSums_;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">BIT</span>(<span class="keyword">int</span> n) : <span class="built_in">prefixSums_</span>(n + <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; prefixSums_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            prefixSums_[i] += delta;</span><br><span class="line">            i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += prefixSums_[i];</span><br><span class="line">            i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>BIT每次查询以及更新的复杂度都是<span class="math inline">\(O(lgn)\)</span>，适用于动态的更新以及实时查询。 ## 3 Reference <a href="https://youtu.be/CWDQJGaN1gY">Fenwick Tree or Binary Indexed Tree</a> <a href="https://zxi.mytechroad.com/blog/sp/fenwick-tree-binary-indexed-tree-sp3/">花花酱 Fenwick Tree / Binary Indexed Tree SP3</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Binary Search</title>
      <link href="/2020/01/11/Binary%20Search/"/>
      <url>/2020/01/11/Binary%20Search/</url>
      
        <content type="html"><![CDATA[<h2 id="基本型">基本型</h2><p>对于一个<strong>没有重复元素</strong>的<strong>有序</strong>数组，查找某个元素，存在返回index，否则返回-1。 二分查找有4个地方容易混淆： 1. lr初始化，即区间定义。可以是[l,r]，也可以是[l,r) 1. while的循环条件：可以是小于/小于等于 1. lr更新：可以是mid/mid+1/mid-1 1. 返回值：可以是l/r/mid/其他值</p><p>如果区间初始化为左闭右闭，循环条件就应该是小于等于，因为等于时待检查区间还有1个元素，需要继续；并且r的更新应该是mid-1，因为已经确定mid不是target且右边界是闭的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果区间定义为左闭右开，此时循环条件小于，等于时表示区间为空；当mid&gt;target时r应该为mid，因为mid不是target且右边界开，即下一次不会考虑mid。这种情况如果没找到最终必然有l==r</p><p>我最常用的板子是左闭右开<code>[l, r)</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// version 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// avoid dead loop</span></span><br><span class="line"><span class="keyword">if</span> (target == nums[mid])</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">l = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">// not found</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// version 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (target == nums[mid])</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">// not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微扩展一些的题目有<code>lower_bound()</code>和<code>upper_bound()</code>，都是数组中有<strong>重复元素</strong>： 对于<code>lower_bound()</code>，即查找满足<span class="math inline">\(x&gt;=target\)</span>的最小<span class="math inline">\(x\)</span>的index： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可变形为查找最后一个小于<span class="math inline">\(target\)</span>的数：即<span class="math inline">\(l-1\)</span>。 对于<code>upper_bound()</code>，即查找满足<span class="math inline">\(x&gt;target\)</span>的最小<span class="math inline">\(x\)</span>的index： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (target &gt;= nums[mid])</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可变形为查找最后一个小于等于<span class="math inline">\(target\)</span>的数：即<span class="math inline">\(l-1\)</span>。</p><p>Leetcode 704/35/34/69/367</p><h2 id="rotated-sorted-array"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">Rotated Sorted Array</a></h2><p>Find the index of the target if it is in the array, else return -1. All values of the array are <strong>unique</strong>.</p><p>We can find that at least half of the elements are sorted, so we should find out whether it's on the left or the right.</p><p>Let's see an example: [0,1,2,3]{all sorted}, [3,0,1,2]{right}, [2,3,0,1]{left or right}, [1,2,3,0]{left}. Another example: [0,1,2,3,4]{all sorted}, [4,0,1,2,3]{right}, [3,4,0,1,2]{right}, [2,3,4,0,1]{left}, [1,2,3,4,0]{left}. It is important to know that the sorted side is <strong>at least half of the array</strong> (longer). So the mid is in this side.</p><p>We can compare nums[mid] with nums[left] (or nums[right]) to decide which side is sorted. If <code>nums[mid]&gt;nums[left]</code>, then left half is sorted, else right is sorted.</p><p>The second step is to compare the target with nums[mid] to narrow down the range.</p><ul><li>Left half is sorted. If target&gt;nums[mid], it must lie in the right interval. So we can make left pointer forward left = mid + 1. <img src="https://img-blog.csdnimg.cn/20210303220721888.png" alt="在这里插入图片描述" /> If target&lt;nums[mid], there exists 2 situations: <img src="https://img-blog.csdnimg.cn/20210303214903684.png" alt="在这里插入图片描述" /> The first graph means target is less than mid but bigger than or equal to left, we move the right pointer toward left right = mid. The second graph means target is less than left, thus we move the left pointer towards right left = mid + 1.</li></ul><p>Finally if nums[mid]==nums[left], it means that left and mid are pointing to the same element due to the distinct values. In this case right must be mid or mid + 1. Where is the target? It must be on the right side of mid (actually nums[right]) or it do not exist. So we can move the left pointer by 1 to see nums[right] is equal to target or not.</p><ul><li>Right half is sorted. You can analysis this by yourself.</li></ul><p>We can write the following code based on the previous discussion:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[m]:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]: <span class="comment"># left side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &gt; nums[m]:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &gt;= nums[l]:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]: <span class="comment"># right side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &lt; nums[m]:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt;= nums[r]:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="rotated-sorted-array-ii"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">Rotated Sorted Array II</a></h2><p>It is the same as the last one except that the array may contains <strong>duplicates</strong>. And you do not need to find the index but return true or false.</p><p>The code is the same except that you should return T or F.</p><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Find Minimum in Rotated Sorted Array</a> shares the same idea:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans, nums[m])</span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[l])</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, nums[m])</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="rotated-sorted-array-yyds"><a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/">Rotated Sorted Array yyds</a></h2><p>In this case you should return the index of the target in a duplicated array. If you do not know the idea above, this will be a little harder to solve since there are many corner cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[m]:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, m)</span><br><span class="line">                r = m - <span class="number">1</span> <span class="comment"># do not return since there might be smaller index</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[l]: <span class="comment"># left side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &gt; nums[m]:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &gt;= nums[l]:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[m] &lt; nums[l]: <span class="comment"># right side is sorted</span></span><br><span class="line">                <span class="keyword">if</span> target &lt; nums[m]:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> target &lt; nums[r]:</span><br><span class="line">                        l = m + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> target &gt; nums[r]:</span><br><span class="line">                        r = m - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> target == nums[l]:</span><br><span class="line">                            ans = <span class="built_in">min</span>(ans, l)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> ans == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Regular Expression</title>
      <link href="/2020/01/10/Regular%20Expression/"/>
      <url>/2020/01/10/Regular%20Expression/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p></blockquote><p>先看一个判断Email地址是否合法的例子： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\\w+@\\w+(\\.\\w&#123;2,3&#125;)*\\.\\w&#123;2,3&#125;&quot;</span></span><br></pre></td></tr></table></figure> 一般Email地址的格式为：<code>X@X.com</code>，<code>X</code>表示一个或多个字符，<code>.com</code>后面可能还会跟有<code>.cn</code>等。总结这些规律，我们用上述的regex来匹配。 当然，这种匹配可能会遗漏某些特殊的Email地址，想要更大范围的覆盖，还需要更为复杂精巧的设计。 接着解释下上面的regex： <code>\\w</code>表示匹配字母/数字/下划线/汉字； <code>+</code>表示字符可以出现一次/多次； <code>(\\.\\w&#123;2,3&#125;)*</code>表示类似<code>.edu</code>格式的字符串可以出现零次/多次。 <code>\</code>在计算机科学中一般表示转义，形如<code>\w</code>的叫做<strong>元字符</strong>，类似的还有：</p><table><thead><tr class="header"><th>元字符</th><th>意义</th></tr></thead><tbody><tr class="odd"><td>.</td><td>除换行符外任意字符</td></tr><tr class="even"><td>数字</td><td></td></tr><tr class="odd"><td></td><td>字母/数字/汉字/下划线</td></tr><tr class="even"><td>单词的开始/结束</td><td></td></tr><tr class="odd"><td>^</td><td>字符串的开始</td></tr><tr class="even"><td>$</td><td>字符串的结束</td></tr></tbody></table><p>还可以通过<code>[]</code>表示元字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;[abc]23&quot;</span></span><br></pre></td></tr></table></figure><p>这样<code>a23</code>，<code>b23</code>，<code>c23</code>都是匹配的字符串。 形如<code>+</code>，<code>*</code>叫做<strong>修饰限定符</strong>，用来控制某类串重复多少次：</p><table><thead><tr class="header"><th>修饰限定符</th><th>意义</th></tr></thead><tbody><tr class="odd"><td>*</td><td>0次/多次</td></tr><tr class="even"><td>+</td><td>1次/多次</td></tr><tr class="odd"><td>？</td><td>0次/1次</td></tr><tr class="even"><td>{n}</td><td>n次</td></tr><tr class="odd"><td>{n,}</td><td>n次/更多次</td></tr><tr class="even"><td>{n,m}</td><td>n~m次</td></tr></tbody></table><p>很多语言和文本编辑器都集成了正则表达式引擎，以Java为例来测试下上述例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String regex = <span class="string">&quot;\\w+@\\w+(\\.\\w&#123;2,3&#125;)*\\.\\w&#123;2,3&#125;&quot;</span>;</span><br><span class="line">String s1 = <span class="string">&quot;hello@stu.edu.cn&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(s1.matches(regex))</span><br><span class="line">System.out.println(<span class="string">&quot;Valid Address!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述内容只是最最基本的关于正则表达式的知识，还有零宽断言、递归匹配等更加复杂的内容有待挖掘~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Programming</title>
      <link href="/2020/01/06/Dynamic%20Programming/"/>
      <url>/2020/01/06/Dynamic%20Programming/</url>
      
        <content type="html"><![CDATA[<p>DP是算法学习中非常重要的一种思想，关于动态规划的解释，可以参考<a href="https://www.zhihu.com/question/23995189/answer/613096905?hb_wx_block=1">这篇文章</a>。 ## 概念 使用DP三个条件：</p><ol type="1"><li>最优子结构：待解决的问题可以被分解为若干子问题，并且递归地找到子问题的最优解；</li><li>重叠子问题：在解决子问题的过程中，很多子问题都会被求解多次，第一次计算后存储该子问题的解，以后就可以直接使用，即降低了时间复杂度。如果子问题没有重叠，那么这就是<strong>分治</strong>的问题；</li><li>无后效性：子问题的最优解是确定的，完全可以用来解决更大的子问题。</li></ol><p>DP一般有两种形式：</p><ul><li>Top-down: 记忆化递归可能stackoverflow</li><li>Bottom-up</li></ul><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>=&quot;&quot;&gt; hash;               <span class="comment">// memory dict</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(i, j, ...)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">base_case</span><span class="params">(i, j)</span></span></span><br><span class="line"><span class="function"><span class="keyword">return</span> ...</span>;</span><br><span class="line"><span class="keyword">if</span> (i, j) <span class="keyword">not</span> in hash</span><br><span class="line">hash[(i, j)] = ...;</span><br><span class="line"><span class="keyword">return</span> hash[(i, j)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">f</span>(n, m);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DP</span></span><br><span class="line"><span class="keyword">int</span> dp[][];   <span class="comment">// need padding sometimes</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = ...;   <span class="comment">// base case</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j =  <span class="number">0</span>;j &lt; m;++j)</span><br><span class="line">dp[i][j] = ...                <span class="comment">// 状态转移</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br></pre></td></tr></table></figure><h2 id="分类">分类</h2><ul><li>基础题：LeetCode 509/70/746/62/63/343/96/<a href="https://www.cnblogs.com/EIMadrigal/p/11478906.html">Fibonacci</a></li><li>背包问题：<ul><li><a href="https://www.cnblogs.com/EIMadrigal/p/12345051.html">0/1 Knapsack</a>：LeetCode 416/1049/494/474</li><li><a href="https://www.cnblogs.com/EIMadrigal/p/12345051.html">Unbounded Knapsack</a>：LeetCode 518/377/70/322/279/139</li></ul></li><li>House Thief：LeetCode 198/213/337</li><li>股票问题：LeetCode 121/122/123/188/309/714</li><li>Longest Common Substring/Subsequeunce：LeetCode 300/1143/1035/674/718/53/392/115/583/72/647/516</li></ul><h2 id="步骤">步骤</h2><p>一般来讲，都是通过暴力-&gt;记忆化递归-&gt;Bottom-up三部曲，当然熟悉后可以快速判断这是一个DP问题，然后直接写出Bottom-up的解法。 我个人认为最难的一步在于判断出你的暴力解法满足DP的性质（你要能认出来这是一个DP问题），可以用DP去优化暴力解法。 - 确定问题分类 - 确定状态：需要几个变量来跟踪目前的状态，一般来讲至少需要index，因为这决定了我们已经考虑过了哪些值，没考虑哪些值，正在考虑哪些值。选定的变量组合要能唯一确定一个状态 - 状态转移：为了达到base case，当前状态怎么才能由之前的状态得到。也就是Top-down逐渐分解问题，每一次递归调用都会分解一下 - base case：一般比较简单，不废话了 - code：思路清楚了，也不难 - 优化：一般优化空间复杂度</p><h2 id="ref">Ref</h2><p><a href="https://leetcode.com/problems/target-sum/discuss/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions.">DP IS EASY! 5 Steps to Think Through DP Questions.</a> &lt;/int,&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>留白</title>
      <link href="/2020/01/01/%E7%95%99%E7%99%BD/"/>
      <url>/2020/01/01/%E7%95%99%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<p>hello</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是P问题、NP问题和NPC问题</title>
      <link href="/2020/01/01/%E4%BB%80%E4%B9%88%E6%98%AFP%E9%97%AE%E9%A2%98%E3%80%81NP%E9%97%AE%E9%A2%98%E5%92%8CNPC%E9%97%AE%E9%A2%98/"/>
      <url>/2020/01/01/%E4%BB%80%E4%B9%88%E6%98%AFP%E9%97%AE%E9%A2%98%E3%80%81NP%E9%97%AE%E9%A2%98%E5%92%8CNPC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>很久之前观看WJMZBMR特奖答辩时听到了<span class="math inline">\(P!=NP\)</span>，一直似懂非懂，看了Matrix67的<a href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a>，<del>特意作文纪念</del> 。</p><p>一张图就可以解释三者间的关系：<img src="https://img-blog.csdnimg.cn/20190728150856295.png" alt="在这里插入图片描述" /> ## 什么是P问题、NP问题和NPC问题 这或许是众多OIer最大的误区之一。 你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是NPC问题是一个多大的错误。</p><p>还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有<span class="math inline">\(O(1)\)</span>的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是<span class="math inline">\(O(n)\)</span>，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于<span class="math inline">\(O(n^2)\)</span>的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是<span class="math inline">\(O(a^n)\)</span>的指数级复杂度，甚至<span class="math inline">\(O(n!)\)</span>的阶乘级复杂度。不会存在<span class="math inline">\(O(2*n^2)\)</span>的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，<span class="math inline">\(O (n^3+n^2)\)</span>的复杂度也就是<span class="math inline">\(O(n^3)\)</span>的复杂度。因此，我们会说，一个<span class="math inline">\(O(0.01*n^3)\)</span>的程序的效率比<span class="math inline">\(O(100*n^2)\)</span>的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终<span class="math inline">\(O(n^3)\)</span>的复杂度将远远超过<span class="math inline">\(O(n^2)\)</span>。我们也说，<span class="math inline">\(O(n^{100})\)</span>的复杂度小于<span class="math inline">\(O(1.01^n)\)</span>的复杂度。</p><p>容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是<span class="math inline">\(O(1),O(log(n)),O(n^a)\)</span>等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是<span class="math inline">\(O(a^n)\)</span>和<span class="math inline">\(O(n!)\)</span>型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p><p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。The Halting Problem就是一个著名的不可解问题，在我的Blog上有过专门的介绍和证明。再比如，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p><p>下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。哪些问题是P类问题呢？通常NOI和NOIP不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。</p><p>接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100 小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。</p><p>之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。</p><p>很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。</p><p>NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。</p><p>目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p><p>为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。</p><p>简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。</p><p>“问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。</p><p>很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。</p><p>现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。</p><p>当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p><p>好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p><p>NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</p><p>既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p><p>顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p><p>不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。下文即将介绍它。</p><p>下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。</p><p>逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。 什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。 <img src="https://img-blog.csdnimg.cn/20190728155740104.png" alt="在这里插入图片描述" /> 这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。</p><p>有输出无论如何都不可能为True的逻辑电路吗？有。下面就是一个简单的例子。 <img src="https://img-blog.csdnimg.cn/20190728155803196.png" alt="在这里插入图片描述" /> 上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。</p><p>回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。</p><p>逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。</p><p>有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pointers and Memory</title>
      <link href="/2020/01/01/Pointers%20and%20Memory/"/>
      <url>/2020/01/01/Pointers%20and%20Memory/</url>
      
        <content type="html"><![CDATA[<p><em>Stanford CS Education Library #102</em> ## Basic Pointers 指针主要有两个用途：使不同的代码段共享信息、方便链表（树）的处理。 指针示意图： <img src="https://img-blog.csdnimg.cn/2019041619200938.png" alt="在这里插入图片描述" /> <code>dereference</code>操作会根据指针的值去找到它的<code>pointee</code>。 <code>NULL</code>是一个特殊的指针值（一般是地址0），表示这个指针不指向任何<code>pointee</code>。 <img src="https://img-blog.csdnimg.cn/20190416193109659.png" alt="在这里插入图片描述" /> 指针的赋值会使得两个指针指向相同的<code>pointee</code>，但<code>pointee</code>本身不会改变： <img src="https://img-blog.csdnimg.cn/20190416192708547.png" alt="在这里插入图片描述" /> 传指针vs传值： <img src="https://img-blog.csdnimg.cn/20190416193445969.png" alt="在这里插入图片描述" /> 定义一个指针后，这个指针是没有被初始化的： <img src="https://img-blog.csdnimg.cn/2019041619372662.png" alt="在这里插入图片描述" /> 这时候如果进行<code>dereference</code>操作会发生Runtime Error. 对于Java、LISP等语言，当定义一个指针时，系统会将其设置为<code>NULL</code>，并且会在<code>dereference</code>操作时检查其值，这也是Java比较慢的原因之一。 <img src="https://img-blog.csdnimg.cn/20190416194404553.png" alt="在这里插入图片描述" /> 一个比较典型的指针错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BadPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* p;  <span class="comment">//allocate the pointer, but not the pointee</span></span><br><span class="line">*p = <span class="number">42</span>; <span class="comment">//serious RE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>*p</code>时： <img src="https://img-blog.csdnimg.cn/20190416195104100.png" alt="在这里插入图片描述" /></p><h2 id="local-memory">Local Memory</h2><p>函数开始运行时，会为局部变量分配内存，结束运行会回收内存。 看一个错误的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TAB -- The Ampersand Bug function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">TAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">return</span> (&amp;temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Victim</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* ptr;</span><br><span class="line">ptr = TAB();</span><br><span class="line">*ptr = <span class="number">42</span>;    <span class="comment">//The pointee was local to TAB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于<code>TAB()</code>返回了一个局部变量的地址，但这个局部变量的空间已经被回收，<code>ptr</code>指针没有<code>pointee</code>。</p><h2 id="reference-parameters">Reference Parameters</h2><p>传值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> worth)</span> </span>&#123;</span><br><span class="line">worth++;</span><br><span class="line"><span class="comment">// T2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> netWorth = <span class="number">55</span>;  <span class="comment">//T1</span></span><br><span class="line">B(netWorth);</span><br><span class="line"><span class="comment">// T3 -- B() did not change netWorth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190416203356234.png" alt="在这里插入图片描述" /> 传指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>* worthRef)</span> </span>&#123;</span><br><span class="line">(*worthRef)++;</span><br><span class="line"><span class="comment">// T2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> netWorth = <span class="number">55</span>;  <span class="comment">//T1</span></span><br><span class="line">B(&amp;netWorth);</span><br><span class="line"><span class="comment">// T3</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190416203939385.png" alt="在这里插入图片描述" /> 传指针在c++中可以通过<strong>传引用</strong>的方式实现： <img src="https://img-blog.csdnimg.cn/20190416205349526.png" alt="在这里插入图片描述" /></p><h2 id="heap-memory">Heap Memory</h2><p>分配示意图： <img src="https://img-blog.csdnimg.cn/20190416205821650.png" alt="在这里插入图片描述" /> 释放示意图： <img src="https://img-blog.csdnimg.cn/20190416210059909.png" alt="在这里插入图片描述" /> 释放后，指针虽然还在，但却不可以在使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size以字节为单位，分配成功返回指针，失败返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要size，因为heap manager之前已经记录过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* heapBlockPointer)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190416211219354.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20190416211242340.png" alt="在这里插入图片描述" /> 一个<code>StringCopy()</code>的例子： <img src="https://img-blog.csdnimg.cn/20190416211900707.png" alt="在这里插入图片描述" /> 对于分配的堆内存，只有一个负责释放的，要么是<code>caller</code>，要么是<code>callee</code>： <img src="https://img-blog.csdnimg.cn/20190416212610387.png" alt="在这里插入图片描述" /></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linked List-2</title>
      <link href="/2020/01/01/Linked%20List-2/"/>
      <url>/2020/01/01/Linked%20List-2/</url>
      
        <content type="html"><![CDATA[<h2 id="三编码技巧">三、编码技巧</h2><p><strong>1、遍历链表</strong> 先将<code>head</code>指针赋值给一个局部变量<code>current</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//return the number of nodes in a list (while-loop version)</span><br><span class="line">int Length(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">int count = 0;</span><br><span class="line">struct node* current = head;</span><br><span class="line"></span><br><span class="line">while (current != NULL)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (current = head; current != NULL; current = current-&gt;next) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>2、通过传递<code>reference pointer</code>改变某个指针</strong> 看个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Change the passed in head pointer to be NULL</span><br><span class="line">//Uses a reference pointer to access the caller&#x27;s memory</span><br><span class="line">void ChangeToNull(struct node** headRef)  //takes a pointer to the value of interest</span><br><span class="line">&#123;</span><br><span class="line">*headRef = NULL;//use * to access the value of interest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ChangeCaller()</span><br><span class="line">&#123;</span><br><span class="line">struct node* head1;</span><br><span class="line">struct node* head2;</span><br><span class="line"></span><br><span class="line">ChangeToNull(&amp;head1);//use &amp; to compute and pass a pointer to</span><br><span class="line">ChangeToNull(&amp;head2);//the value of interest</span><br><span class="line">//head1 and head2 are NULL at this point</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块的思想是和（一）中的<code>Push()</code>类似。 内存示意图： <img src="https://img-blog.csdnimg.cn/20190330151133187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <strong>3、通过<code>Push()</code>建立链表（头插法）</strong> 这种方式的优点是速度飞快，简单易行，缺点是得到的链表是逆序的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct node* AddAtHead()</span><br><span class="line">&#123;</span><br><span class="line">struct node* head = NULL;</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt; 6; i++)</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;head, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//head == &#123;5,4,3,2,1&#125;;</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、尾插法建立链表</strong> 这种方法需要找到链表最后一个节点，改变其<code>.next</code>域： <img src="https://img-blog.csdnimg.cn/20190330155111506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><ul><li>插入或者删除节点，需要找到该节点的前一个节点的指针，改变其<code>.next</code>域；</li><li>特例：<strong>如果涉及第一个节点的操作，那么一定要改变<code>head</code>指针。</strong></li></ul><p><strong>5、特例+尾插法</strong> 如果要构建一个新的链表，那么头节点就要单独处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithSpecialCase()</span><br><span class="line">&#123;</span><br><span class="line">struct node* head = NULL;</span><br><span class="line">struct node* tail;</span><br><span class="line"></span><br><span class="line">//deal with the head node here, and set the tail pointer</span><br><span class="line">Push(&amp;head, 1);</span><br><span class="line">tail = head;</span><br><span class="line"></span><br><span class="line">//do all the other nodes using &quot;tail&quot;</span><br><span class="line">for (int i = 2; i &lt; 6; i++)</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;(tail-&gt;next), i);   //add node at tail-&gt;next</span><br><span class="line">tail = tail-&gt;next;     //advance tail to point to last node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return head;    //head == &#123;1,2,3,4,5&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、临时节点建立</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithDummyNode()</span><br><span class="line">&#123;</span><br><span class="line">struct node dummy;   //dummy node is temporarily the first node</span><br><span class="line">struct node* tail = &amp;dummy;   //build the list on dummy.next</span><br><span class="line"></span><br><span class="line">dummy.next = NULL;</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt; 6; i++)</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;(tail-&gt;next), i);</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//the real result list is now in dummy.next</span><br><span class="line">//dummy.next == &#123;1,2,3,4,5&#125;</span><br><span class="line">return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7、本地指针建立</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithLocalRef()</span><br><span class="line">&#123;</span><br><span class="line">struct node* head = NULL;</span><br><span class="line">struct node** lastPtrRef = &amp;head;   //start out pointing to the head pointer</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt; 6; i++)</span><br><span class="line">&#123;</span><br><span class="line">Push(lastPtrRef, i);  //add node at the last pointer in the list</span><br><span class="line">//advance to point to the new last pointer</span><br><span class="line">lastPtrRef = &amp;((*lastPtrRef)-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return head;  //head == &#123;1,2,3,4,5&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块可能有些抽象： 1）<code>lastPtrRef</code>开始指向<code>head</code>指针，以后指向链表最后一个节点中的<code>.next</code>域； 2）在最后加上一个节点； 3）让<code>lastPtrRef</code>指针向后移动，指向最后一个<strong>节点的<code>.next</code>域</strong>。 <code>(*lastPtrRef)-&gt;next</code>可以理解为<code>*lastPtrRef</code>指针指向的节点的<code>next</code>域。 <img src="https://img-blog.csdnimg.cn/20190403193507385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ## 四、代码示例 <strong>1、AppendNode()</strong> 1) 不使用<code>Push()</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct node* AppendNode(struct node** headRef, int num)</span><br><span class="line">&#123;</span><br><span class="line">struct node* current = *headRef;</span><br><span class="line">struct node* newNode;</span><br><span class="line"></span><br><span class="line">newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">newNode-&gt;data = num;</span><br><span class="line">newNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">//special case for length 0</span><br><span class="line">if (current == NULL)</span><br><span class="line">&#123;</span><br><span class="line">*headRef = newNode;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">//Locate the last node</span><br><span class="line">while (current-&gt;next != NULL)</span><br><span class="line">&#123;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>使用<code>Push()</code>函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct node* AppendNode(struct node** headRef, int num)</span><br><span class="line">&#123;</span><br><span class="line">struct node* current = *headRef;</span><br><span class="line"></span><br><span class="line">//special case for length 0</span><br><span class="line">if (current == NULL)</span><br><span class="line">&#123;</span><br><span class="line">Push(headRef, num);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">//Locate the last node</span><br><span class="line">while (current-&gt;next != NULL)</span><br><span class="line">&#123;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Build the node after the last node</span><br><span class="line">Push(&amp;(current-&gt;next), num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、CopyList</strong> 用一个指针遍历原来的链表，两个指针跟踪新生成的链表（一个<code>head</code>，一个<code>tail</code>）。</p><ol type="1"><li>不使用<code>Push()</code>函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">struct node* current = head;   //used to iterate over the original list</span><br><span class="line">struct node* newList = NULL;   //head of the new list</span><br><span class="line">struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line"></span><br><span class="line">while (current != NULL)</span><br><span class="line">&#123;</span><br><span class="line">if (newList == NULL)    //special case for the first new node</span><br><span class="line">&#123;</span><br><span class="line">newList = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">newList-&gt;data = current-&gt;data;</span><br><span class="line">newList-&gt;next = NULL;</span><br><span class="line">tail = newList;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">tail-&gt;next = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">tail = tail-&gt;next;</span><br><span class="line">tail-&gt;data = current-&gt;data;</span><br><span class="line">tail-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 内存示意图： <img src="https://img-blog.csdnimg.cn/20190407094454488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li><li>使用<code>Push()</code>函数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList2(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">struct node* current = head;   //used to iterate over the original list</span><br><span class="line">struct node* newList = NULL;   //head of the new list</span><br><span class="line">struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line"></span><br><span class="line">while (current != NULL)</span><br><span class="line">&#123;</span><br><span class="line">if (newList == NULL)    //special case for the first new node</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;newList, current-&gt;data);</span><br><span class="line">tail = newList;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;(tail-&gt;next), current-&gt;data);   //add each node at the tail </span><br><span class="line">tail = tail-&gt;next;       //advance the tail to the new last node;</span><br><span class="line">&#125;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>使用<code>Dummy Node</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList3(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">struct node* current = head;   //used to iterate over the original list</span><br><span class="line">struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line">struct node dummy;            //build the new list off this dummy node</span><br><span class="line"></span><br><span class="line">dummy.next = NULL;</span><br><span class="line">tail = &amp;dummy;      //start the tail pointing at the dummy</span><br><span class="line"></span><br><span class="line">while (current != NULL)</span><br><span class="line">&#123;</span><br><span class="line">Push(&amp;(tail-&gt;next), current-&gt;data);   //add each node at the tail</span><br><span class="line">tail = tail-&gt;next;                    //advance the tail to the new last node</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>使用<code>Local References</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList4(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">struct node* current = head;   //used to iterate over the original list</span><br><span class="line">struct node* newList = NULL;   //head of the new list</span><br><span class="line">struct node** lastPtr;           </span><br><span class="line"></span><br><span class="line">lastPtr = &amp;newList;      //start off pointing to the head itself</span><br><span class="line"></span><br><span class="line">while (current != NULL)</span><br><span class="line">&#123;</span><br><span class="line">Push(lastPtr, current-&gt;data);   //add each node at the lastPtr</span><br><span class="line">lastPtr = &amp;((*lastPtr)-&gt;next);    //advance lastPtr</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想是使用<code>lastPtr</code>指针指向每个节点的<code>.next</code>域这个指针，而不是指向节点本身。</p><ol start="5" type="1"><li>使用<code>Recursive</code>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList5(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">struct node* current = head;</span><br><span class="line">if (head == NULL)</span><br><span class="line">return NULL;</span><br><span class="line">else &#123;</span><br><span class="line">struct node* newList = (struct node*)malloc(sizeof(struct node));  //make one node</span><br><span class="line">newList-&gt;data = current-&gt;data;</span><br><span class="line"></span><br><span class="line">newList-&gt;next = CopyList5(current-&gt;next);    //recur for the rest</span><br><span class="line">return newList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linked List-1</title>
      <link href="/2020/01/01/Linked%20List-1/"/>
      <url>/2020/01/01/Linked%20List-1/</url>
      
        <content type="html"><![CDATA[<p>链表一直是面试的重点问题，恰好最近看到了Stanford的一篇<a href="http://cslibrary.stanford.edu/">材料</a>，涵盖了链表的基础知识以及派生的各种问题。 第一篇主要是关于链表的基础知识。 ## 一、基本结构 <strong>1、数组回顾</strong> 链表和数组都是用来存储一堆数据的集合，其中单个元素的类型可以有很多种。 通过数组下标可以直接访问数组中的元素，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ArrayTest()</span><br><span class="line">&#123;</span><br><span class="line">int scores[100];</span><br><span class="line"></span><br><span class="line">//初始化前3个元素</span><br><span class="line">scores[0] = 1;</span><br><span class="line">scores[1] = 2;</span><br><span class="line">scores[2] = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的是：整个数组被分配了一整块内存： <img src="https://img-blog.csdnimg.cn/2019032615150057.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" /> 数组元素之所以能被快速访问，原因在于其地址的计算是通过首地址加上偏移值得到的，只有一次乘法和一次加法运算而已。 数组的缺点在于：</p><ul><li>数组的大小是固定的：数组的规模在编译时就被确定，当然你可以在运行时通过<code>malloc</code>在堆中改变数组的大小，不过很麻烦；</li><li>由于上述原因，所以很多人就会定义一个很大的数组，不过这又会导致两个问题： 1）数组的大部分空间可能被浪费掉； 2）如果程序需要更大的空间，就会崩溃。</li><li>在数组前面插入元素代价很大，需要移动很多元素。 链表也有自己的优缺点，只不过和数组刚好互补：链表会在需要时为每个节点单独分配内存。 <strong>2、指针回顾</strong> 指针存储了变量的地址，如果指针的值是<code>NULL</code>（c/c++中<code>NULL</code>可以表示逻辑<code>false</code>），那么该指针不指向任何变量。 在c/c++中，没有初始化的指针就是野指针，对野指针进行<code>dereference</code>操作可能导致程序崩溃。 两个指针的赋值结果就是都指向相同的内存区域。 <code>malloc()</code>函数用来在堆中申请一块内存，并且返回一个指向该块的指针，如果申请失败，会返回<code>NULL</code>，使用后，需要用<code>free()</code>去释放。这些堆函数原型都在<code>stdlib.h</code>头文件中声明。 <strong>3、链表</strong> 一个包含<code>&#123;1,2,3&#125;</code>三个元素的链表： <img src="https://img-blog.csdnimg.cn/20190326161911717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 空链表的<code>head</code>的值是<code>NULL</code>，<strong>编程时要考虑到这种边界情况</strong>。</li></ul><p>节点的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">int data;</span><br><span class="line">struct node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>指向节点的指针类型是<code>struct node*</code>。 接着看看上图中的链表是怎么建立的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Build the list &#123;1,2,3&#125; in the heap and store</span><br><span class="line">its head pointer in a local stack variable.</span><br><span class="line">Returns the head pointer to the caller.</span><br><span class="line">*/</span><br><span class="line">struct node* BuildOneTwoThree()</span><br><span class="line">&#123;</span><br><span class="line">//there are three pointers in the stack, but pointer assignment link the list.</span><br><span class="line">struct node* head = NULL;</span><br><span class="line">struct node* second = NULL;</span><br><span class="line">struct node* third = NULL;</span><br><span class="line"></span><br><span class="line">//allocate 3 nodes</span><br><span class="line">head = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">second = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">third = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">head-&gt;data = 1;    //setup first node</span><br><span class="line">head-&gt;next = second;   //note:pointer assignment rule</span><br><span class="line"></span><br><span class="line">second-&gt;data = 2;    //setup second node</span><br><span class="line">second-&gt;next = third;</span><br><span class="line"></span><br><span class="line">third-&gt;data = 3;    //setup third node</span><br><span class="line">third-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">//at this point, the linked list referenced by &quot;head&quot;</span><br><span class="line">//matches the list in the drawing.</span><br><span class="line">return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何求链表中的元素个数呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Given a linked list head pointer, compute </span><br><span class="line">and return the number of nodes in the list.</span><br><span class="line">*/</span><br><span class="line">int Length(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">struct node* current = head;</span><br><span class="line">int count = 0;</span><br><span class="line"></span><br><span class="line">while (current != NULL)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，传递进函数的只是头指针，这样调用者和被调用者都有了头指针，但是却共享了整个链表。</p><ul><li><code>current</code>指针占据的空间会被自动释放，但是堆中的链表仍然保留；</li><li><code>while</code>循环已经考虑了空链表的情况；</li><li><code>current</code>最后的值会是<code>NULL</code>。 调用<code>Length()</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void LengthTest()</span><br><span class="line">&#123;</span><br><span class="line">struct node* myList = BuildOneTwoThree();</span><br><span class="line">int len = Length(myList);    //results in len == 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用<code>Length()</code>之前： <img src="https://img-blog.csdnimg.cn/20190326172043909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li><li>执行<code>Length()</code>过程中： <img src="https://img-blog.csdnimg.cn/20190326172354519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li></ul><h2 id="二链表建立">二、链表建立</h2><p>用<code>BuildOneTwoThree()</code>函数来建立链表未免有些古板，下面用头插法建立链表：</p><p>1、分配节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct node* newNode;</span><br><span class="line">newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">newNode-&gt;data = data_client_wants_stored;</span><br></pre></td></tr></table></figure><p>2、让新节点的<code>next</code>指向当前链表的第一个节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newNode-&gt;next = head;</span><br></pre></td></tr></table></figure><p>3、让<code>head</code>指针指向链表的第一个节点： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = newNode;</span><br></pre></td></tr></table></figure> 整理下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void LinkTest()</span><br><span class="line">&#123;</span><br><span class="line">struct node* head = buildTwoThree();  //suppose this builds list &#123;2,3&#125;</span><br><span class="line">struct node* newNode;</span><br><span class="line"></span><br><span class="line">newNode = (struct node*)malloc(sizeof(struct node));  //allocate</span><br><span class="line">newNode-&gt;data = 1;</span><br><span class="line"></span><br><span class="line">newNode-&gt;next = head;   //link next</span><br><span class="line"></span><br><span class="line">head = newNode;   //link head</span><br><span class="line"></span><br><span class="line">//now head points to the list &#123;1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图： <img src="https://img-blog.csdnimg.cn/20190326205401503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <em>先看一个错误的示范：</em> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void WrongPush(struct node* head,int data)</span><br><span class="line">&#123;</span><br><span class="line">struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">newNode-&gt;data = data;</span><br><span class="line">newNode-&gt;next = head;</span><br><span class="line">head = newNode;    //NO this line does not work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WrongPushTest()</span><br><span class="line">&#123;</span><br><span class="line">struct node* head = buildTwoThree();  </span><br><span class="line"></span><br><span class="line">WrongPush(head, 1);    //try to push 1 on front -- doesn&#x27;t work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个问题就在于C语言的<strong>值传递</strong>，在<code>WrongPush()</code>中对<code>head</code>指针的改变不会影响到<code>WrongPushTest</code>中的我们需要的<code>head</code>指针。 这个问题传统的解决方案是传递当前值的指针给函数而不是传递一份当前值的拷贝，即： 要改变调用者中<code>int</code>的值，就传一个<code>int*</code>给被调用者。在这个例子中，要改变<code>struct node*</code>，就要传递<code>struct node**</code>。也即：<code>head</code>的类型是<code>pointer to a struct node</code>，想要改变这个指针，就需要传一个指向该指针的指针<code>pointer to a pointer to a struct node</code>。 <strong>规则就是：<code>to modify caller memory, pass a pointer to that memory.</code></strong></p><p><em>所以正确的代码如下：</em> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Takes a list and a data value.</span><br><span class="line">Creates a new link with the given data and pushes it</span><br><span class="line">onto the front of the list.</span><br><span class="line">The list is not passed in by its head pointer.</span><br><span class="line">Instead the list is passed in as a &quot;reference&quot; pointer</span><br><span class="line">to the head pointer -- this allows us to modify the caller&#x27;s memory.</span><br><span class="line">*/</span><br><span class="line">void Push(struct node** headRef,int data)</span><br><span class="line">&#123;</span><br><span class="line">struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">newNode-&gt;data = data;</span><br><span class="line">newNode-&gt;next = *headRef;//the * to dereferences back to the real head </span><br><span class="line">*headRef = newNode;    //ditto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PushTest()</span><br><span class="line">&#123;</span><br><span class="line">struct node* head = buildTwoThree();//suppose this returns the list &#123;2,3&#125;</span><br><span class="line"></span><br><span class="line">Push(&amp;head, 1);    //note the &amp;</span><br><span class="line">Push(&amp;head, 13);</span><br><span class="line"></span><br><span class="line">//head is now the list &#123;13,1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 内存示意图： <img src="https://img-blog.csdnimg.cn/20190330143627528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 如果是C++，那么可以用<strong>引用</strong>完成上述工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Push in C++ -- We just add a &amp; to the right hand side of the head parameter type,</span><br><span class="line">and the compiler makes that parameter work by reference. So this code changes the </span><br><span class="line">caller&#x27;s memory, but no extra uses of * are necessary -- we just access &quot;head&quot; directly,</span><br><span class="line">and the compiler makes that change reference back to the caller.</span><br><span class="line">*/</span><br><span class="line">void Push(struct node*&amp; head,int data)</span><br><span class="line">&#123;</span><br><span class="line">struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">newNode-&gt;data = data;</span><br><span class="line">newNode-&gt;next = head;//No extra use of * necessary on head -- the compiler</span><br><span class="line">head = newNode;    //just takes care of it behind the scenes.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PushTest()</span><br><span class="line">&#123;</span><br><span class="line">struct node* head = buildTwoThree();//suppose this returns the list &#123;2,3&#125;</span><br><span class="line"></span><br><span class="line">Push(head, 1);    //No extra use &amp; necessary -- the compiler </span><br><span class="line">Push(head, 13);   //takes care of it here too. Head is being changed by these calls. </span><br><span class="line"></span><br><span class="line">//head is now the list &#123;13,1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>老实人的摸索与反思——写在高考七年后</title>
      <link href="/2019/12/02/%E8%80%81%E5%AE%9E%E4%BA%BA%E7%9A%84%E6%91%B8%E7%B4%A2%E4%B8%8E%E5%8F%8D%E6%80%9D%E2%80%94%E2%80%94%E5%86%99%E5%9C%A8%E9%AB%98%E8%80%83%E4%B8%83%E5%B9%B4%E5%90%8E/"/>
      <url>/2019/12/02/%E8%80%81%E5%AE%9E%E4%BA%BA%E7%9A%84%E6%91%B8%E7%B4%A2%E4%B8%8E%E5%8F%8D%E6%80%9D%E2%80%94%E2%80%94%E5%86%99%E5%9C%A8%E9%AB%98%E8%80%83%E4%B8%83%E5%B9%B4%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<p><em>说明：本文是徐国曦老师写于2018年6月，我第一次看到此文是在2019年4月中旬。鉴于我当时状态很糟糕，此文给了我极大的震撼与启发，每每读来都有不同的感受，遂摘录于此。 附：<a href="https://zhuanlan.zhihu.com/p/37859452">原文链接</a></em></p><table><colgroup><col style="width: 100%" /></colgroup><tbody><tr class="odd"><td>说明：上篇《老实人的归国与失身》获得了超过预想的关注，文中虽声明“本故事纯属虚构”，但实际上真实情况与艺术加工大约各占一半。上篇文章想要表达的主题可能并不十分清楚，不同人看到的东西会有极大不同。因此在今天这篇文章中我将详细讲一下这些年来发生的事情以及自己的一些思考，本文句句事实，不说一句大话、假话、空话，不贩卖焦虑，不灌任何鸡汤和毒鸡汤。我也不讳言自己身上出现的问题，曾经的生活充满不堪，有些遮蔽在眼前的玻璃滤镜总要有需要被打破的一天。</td></tr><tr class="even"><td>时至今日，我也是时候与过去的自己告别，开始新的第二人生了。我也希望将自己的经历写出来，给境遇相似的人提供一些可能的思考或警示。几年折腾下来，不敢说积累了多少人生经验，但是讲教训我这里是有很多的，这篇文章的目的也在于用亲身经历指出我自己及处境相似的年轻人思维和行动上的误区。其中的一些个人想法可能不完善或者不成熟，也欢迎批评指教。</td></tr></tbody></table><p>认真投决定命运的硬币，却不知道最后要去哪里。 ——题记</p><h2 id="section">0</h2><p>在文章开始之前，先放几篇在某段时间内引发广泛讨论的微信文，读者们或多或少可能看过其中一些：</p><ol start="0" type="1"><li><a href="https://www.zhihu.com/question/277691008">《老实人的归国与失身》</a> 作者是我自己</li><li><a href="https://www.zhihu.com/question/50766928">《T大本科舍友阶级分化实录，该何去何从？》</a></li><li><a href="https://www.zhihu.com/question/44186681">《凭什么我辛苦二十年，现在却比别人差那么多？》</a></li><li><a href="https://www.zhihu.com/question/52031149">《我上了985 211才发现自己一无所有》</a></li><li><a href="https://www.zhihu.com/question/65098412">《一个月就辞职，一个北大女生的求职悲欢》</a></li></ol><p>这些文章可能可以或多或少的反映当前包括我在内部分名校学生所面临的现实问题与认知偏差。也因此，因为视角有限，必然不代表整个年轻人群体的普遍现象，更不能说契合多数人的价值观，请带着批判的眼光看到上面提到的所有文章，也包括我这篇。 ## 1 好了废话不多说，开始讲故事，十年经历，尽在此篇。如果觉得故事过长，请直接看最后的结论。</p><p>美西时间2018年6月6日下午，我上完了学生时代的最后一节课程，只待最后的考试、毕业、回国、入职。打开朋友圈，看到大家都在怀念当年的高考，作为一个上了大学后就基本没再怎么提起高考这茬事的人，突然觉得这个事情好遥远。不过从尘埃落定以来我也一直想找个机会分享一下我个人几年来遇到的事情，就索性在高考七年之后学生时代临近结束的时候，进行一次彻底的总结，向过去的自己说再见，轻装迎接未知的未来。这篇的主题其实和高考本身没有多大关系，不过还是像上篇一样，从高中时代讲起。</p><p>如同《老实人的归国与失身》当中讲到的那样，我十年之前升入一个高考大省省会的重点高中，虽然管理并非变态到监狱式的程度，但是由于升学压力的缘故，大部分学生的日子还是过得相对波澜不惊。在一个在郊区住校，一两周回一趟家，手机都不一定人手一部，诺基亚N95就能称霸，上QQ空间可能是最好的娱乐活动的时代，我们的日常生活也不像十年之后的今天有着各种各样的诱惑。如同我现在看到快手抖音和知乎上的00后们接受着我们从没想过的信息，做着我们想追求却曾经不敢去做的事情，18岁的他们姿势水平可能完爆25岁的自己，就觉得时代的发展如同车轮一般，而90后已经成了被冲在沙滩上的前浪。</p><p>而在那样的环境下，可想而知，学生当中最受欢迎的群体并不是只知道好好学习的书呆子（虽然我自己可能并不是），而永远都是绯闻缠身的帅哥靓女们，家里有一些背景考到一本线就能上本地985的关系户，手机一周一换的富二代，carry大家打游戏的大咖，带着些许叛逆的所谓不良少年，甚至高中时代成熟的早偷尝禁果还顺便能给朋友们性启蒙的人。虽然当我之后见到更大的世界之后发现这都不算什么，但放在当时，这些现象还是对很多十五六岁经历一片空白的少男少女有着一定杀伤力的。</p><p>在这些人面前，我竟有些自卑，说不清楚自己除了成绩稍微好一些之外还有什么优点，更何况成绩根本没好到可以完爆他们的程度。而我个人的课余生活就更是单调，<strong>上晚自习看《萌芽》追连载小说得到的快乐，可能并不亚于几年之后在国际期刊发表一作文章的快乐</strong>。人在成长过程中都是这样，小时候得到个玩具就能高兴好几天，可是长大之后很有可能金钱和权力等这些世俗成功标准的降临都带不来一样的感动了。人的阈值总是随时间而增长的，这是好事还是坏事呢？</p><p>我在这所高中成绩比较稳定位于年级中上，课余和寒暑假的时间都用来搞竞赛，虽然略吃力但也有所收获。正常情况下单凭高考考到中等985学校没问题，如果竞赛保送可以去前十学校。我自己高中时候的目标是上清华北大，但由于从当时的情况看来过于不切实际，因此也很少跟别人提起。到了高三，竞赛获了省一拿到了保送资格，报了清华和另外一所华五学校，清华没考过线，另外一所学校过了录取线却把我调剂到了法医专业。由于实在是不想读这个专业，不得不放弃保送资格强行拼高考。高三一年各次模拟考试我的成绩稳定在六百三四十（虽然事后看来，模拟题和高考真题完全不是一个路数），即便加上竞赛加分，离梦想的学校也相距太远。以至于到了高三的五月，我竟觉得“就这样吧，考到哪算哪”。</p><p>于是高考前最后的一个月我连作业都懒得做了，每天用几乎全部的时间研究历年高考真题，琢磨里面的规律。2011年高考的三天也波澜不惊的过去了，甚至高考之后答案都懒得去对，抱着出了分之后随便报个志愿的弃疗态度就去睡了十五天大觉。结果出乎意料的是超常发挥了近三十分，莫名其妙的考到了全市前五全省前五十，竟然可以真的报清北了。</p><p>鉴于当时的确不知道自己喜欢什么和适合什么专业，当天急急忙忙的就和清华签了约，而专业也是招生老师推荐给我的，我想都没想就接受了，身边的长辈也全都给我说：</p><p><strong>“你都上了清华了，学什么专业不重要”。</strong></p><p>那个时候自己对未来的想法只有： <strong>“我想做一个科学家”</strong></p><p>（然而可能连什么是科学家都不甚清楚），看到是个理工科专业，就糊里糊涂接受了。这就是一个典型的战术上勤奋战略上懒惰的例子。</p><p>我本人并非小县城出身，与“学霸”这个词更是八竿子打不着。但是，可能时至今日我自己身上仍然还有一些小县城学霸思维方式的残余。尤其在高考大省，我们很多人在18岁之前除了学习什么都不懂，而工人阶级或者知识分子的父母从小告诉我们的就是“<strong>读书改变命运</strong>”甚至是“<strong>考个好大学什么都不用愁了</strong>”。</p><p>固然在他们那个时代可能是这样，但是如今，这样的“<strong>努力就能得到回报</strong>”、“<strong>一分耕耘一分收获</strong>”的单线程的、线性的思维方式在更大程度上是对生活的一种不完全归纳甚至是片面归纳。从小地方考入最高学府，必须承认眼界和见识必然比不过一部分同龄人：2017年夏天我在斯坦福带过一个国内初中生组成的所谓“游学团”，平均年龄十三四岁，平均去过十几二十个国家，有的甚至是来美国开独奏会的，聊天当中处处被教做人，甚至有白比他们年龄长一倍的感觉，这样的眼界和见识怎么比？</p><p>事实上，比无头苍蝇乱撞般瞎努力更重要的是选择，比选择更重要的是信息，还有历史行程、社会形势、贵人相助以及运气等因素。<strong>有时候必须承认人与人的差距可能努力程度占三分，而其他因素，占七分，甚至九十七分</strong>。也因此，小县城学霸以及我这样的伪“小县城学霸”到了顶尖名校之后不可避免会有一定失落感，这也是现实存在的一个问题。 ## 2 从这一刻起，没有金刚钻却强行揽了瓷器活的日子开始了。德不配位，必会撞墙。不过话说回来，如果没有当年的撞墙也不会有如今的成长。下面所有的故事，可以称为“<strong>一个名校（主流价值观中的）差生的试错与教训</strong>”。整个过程，也就是跟自己的局限、幼稚与无知斗争的过程。</p><p>虽然从考上清华那一刻开始自己就隐隐约约感觉到，高考一次的成功不能说明太多问题，更没有一劳永逸的感觉，然而现实永远比想象的更加要命。大一第一学期我和高三的辛苦程度差不多，但是期中考试的成绩竟然是（大约）年级倒数前三（年级100人左右），有一门差点没及格。看到成绩的时候我突然懂得了很多事情，而大学四年的目标，也由在本领域做出点成绩变成了安全毕业。</p><p>我当时的想法就是，既然学术（单说成绩方面）这条路走不通，那索性就去多试试别的。于是我从那之后几乎每学期都选35-40学分的课，想拓展自己的视野，找找自己可能能行的方面究竟在哪里。同时加了学生会，加了社团，认识了一些从当时看来闪闪发光的牛人，甚至还有过做了个互联网信息平台差点创业的经历。故事发展到这里，从外界看来似乎我的大学生活将要过得风生水起，然而似乎并没这么简单。</p><p>到了大二，我逐渐认识到自己对本专业并没有像自己想象的那般兴趣，而且学习也越来越吃力。带着困惑，我去咨询了一些前辈，前辈给的建议都是“好好学专业课，好好做科研，当你用到你所学的知识的时候你自然会喜欢的”（这是我唯一能得到的信息，尽管帮助着实有限）。于是我进了实验室（这在当时已经算起了个大早），然而发现根本不知道自己学的知识能够如何用到科研当中。此时此刻，同年级里有的同学已经开始接独立课题，有的同学已经有文章发表（非一作，不过放到现在，大二发一作的也已经不计其数了）。我在想，成绩拼不过不要紧，科研别输给他们。</p><p>终于在大三的时候，换过好几个实验室，我在一个交叉学科方向找到了自己的兴趣，而且这个方向一做就是四年。至于成绩，好的时候年级倒数1/3，差的时候年级倒数1/6，已经不在乎了。凭这样的成绩直接申国外博士几乎是不可能的，保研本系或者本校也差一点，于是不得不通过读硕士找个跳板，试图积累成绩以外的其他资源。其实在这个阶段，我也想过未来发展的其他可能性，但苦于真的不知道该去哪寻找信息（甚至那个时候大部分出国党都不知道有暑期研修这东西存在，反观今日，没个海外研修都不好意思出国），周围以我的眼界所能听到的声音也是“万般皆下品，唯有科研高”这样的价值观占主导，所以我并不觉得这里面有什么问题，或者并不知道自己选择这条路有多少是出于自己真心所想，而又有多少是出于随大流或者生活的惯性。</p><p>于是我算是在两眼一抹黑的情况下申请出国，匆匆忙忙准备申请材料，运气还算好，也拿到了较为不错的录取，还提前联系好了将来想跟的导师和实验室。再加上大四一年拼命科研，虽然到最后成绩仍然在倒数1/4，但国内国际期刊均有论文收获，这对于大学四年没得过任何荣誉（如果课余参加的一些数学物理方面的竞赛不算的话，只算官方荣誉）没拿过任何奖学金甚至很少受到赏识的自己来说也觉得没白来一遭。四年来受到的自信心打击太多，甚至到了最后已经被碾压到心如止水了，也越来越觉得有些时候人与人的差距不是通过努力能够追上的。即便如此，最后也涉险毕业，准备去美国开始一段新的人生，虽然直到本科毕业，我连一次出国经历也都没有。 ## 3 在另一段“没有金刚钻却强行揽了瓷器活”的经历开始之前，我觉得这里有必要评价一下<strong>名校学渣</strong>这种客观存在且无数人经历过或正在经历的状态。</p><p>曾经知乎上有个问题，叫“在清华大学当学渣是种怎样的体验？”，回答者甚众，甚至在我本科时代的周围，包括我自己在内，都有很多人实实在在的经历过这样的挫折。很多时候当我们分享起自己被碾压的经历，会换来别人的不理解，甚至是“何不食肉糜”。然而这里面的痛苦却是真实的，我也见过有人因为学习成绩跟不上，退学的有之，休学的有之，抑郁的有之，甚至自杀的都存在。<strong>在很多情况下成绩成了衡量一个人唯一或者最重要的标准，赢者通吃，而在这一评价体系下没有胜出的人就很难得到主流舆论体系的承认。</strong></p><p>本科毕业之后我曾经跟一些这种处境的学弟学妹聊过，看到他们的迷茫我似乎也看到了当年自己的影子。那种自卑、焦虑、挫折、不被承认的感觉是的的确确困扰着我们当中很多人的，更何况名校学生对自己的期待和现实很难不产生心理落差。</p><p>由于人与人的痛苦是不共通的，每个人的解决方案也不尽相同。放在我身上，当我被学习成绩打击的时候，我当时的选择是在学生会做好事情，去实验室做好科研，而身边一些人可能是通过外出实习、体育运动、恋爱等方式排解。当被主流评价体系打击到怀疑自己存在的价值和意义时，我现在能给出的建议是，<strong>出去申请实习（甚至完全不必是自己对口行业的实习）</strong>，真正接触一下工作是怎样的，破除单一价值观带来的禁锢（不管这种单一价值观是外界强加的还是自己想象的），你会发现原来自己还能做出这样的贡献。我们在学校里的跑道只有一条，但实际上现实生活中的跑道有无数条。树挪死人挪活，换个环境很多时候都会带来不错的发挥。</p><p>现在，我想提出这样一个问题：<strong>如果读者作为名校毕业生，在大学四年过去之后，享受了较好的教育资源，你认为在什么方面自己应该具有一定优势</strong>？文章的最后我将谈一下自己对这个问题的看法。 ## 4 2015年夏天，我仍然是在两眼一抹黑的情况下来到了美国。清华四年的经历虽然洗刷掉了我所有的骄傲和大部分的自信心，让我明白自己其实实力也就是中人之资，但还是模模糊糊抱着一个想当科学家的梦想。可是此时，我面临的主要矛盾已经变成了看到了更大的世界和自己内心可怜的信息量和姿势水平之间的矛盾。</p><p>本科期间我对象牙塔里的这一些规则或者体系有了一定的了解，但对社会的认知其实比刚入大学的时候并没有多少长进。在国内的时候，本身和其他背景的人交流就不多，科研压力也让我每天都在闷头向前赶，却很少抬起头来想想为什么，或者看看周围更广阔的风景。结果就是，到了美国，当不得不睁眼看世界的时候，发现身边的人一个比一个生活多姿多彩光鲜亮丽，而自己就像一个只知道埋头干活反而连活都干不好的傻B。</p><p>诸位别笑，这的确是我来到美国的第一感觉。一个见识有限的人突然到了一个大环境当中，不可避免有一种刘姥姥进了大观园的感觉。很多人的经历也让我大开眼界，有好的也有坏的，好的让我觉得“我大学期间都错过了什么”，而不好的让我觉得“原来还有这样的人存在，服气服气”。也因此，来到美国一两个月，我的三观就几乎被刷新了一遍。</p><p>在科研领域遇到的挫折（实际上什么都没做出来）让我发现这条路并非这么容易，生活中遇到过不靠谱的人和事太多我也只能说自己曾经太傻太天真。经历了刚出国换环境的阵痛，我再次陷入了不知道将来想做什么的困惑当中。但是所不同的是，这一次，我知道的信息更多，有一定可以选择的余地，也做好了试错的准备。</p><p>但是主业也容不得耽误，于是匆匆忙忙填完了博士申请，结果在关键时刻一篇投往顶级期刊的一作文章被拒，唯一可以拿得出手的砝码丢了，拿到的是隔壁学校降转硕士的录取（按照当时的情况留本校可能可以拿到博士，但在当时的环境下过得实在是太不开心，加之所在的研究方向不喜欢，不想一直这样下去）。</p><p>虽然不甘心但是也没办法，实力不济加上运气不好，只能接受现实，第一时间联系好了自己想做的方向的导师，因为正常情况下做得好是能留下来读博的。同时我利用这当中的空闲时间，投过咨询机构的实习，尝试了他们的思维方式。之后又投了几家金融业的实习，虽然做的也并不愉快。我试图通过这个，去弥补本科期间，甚至更早的时候，对这个社会，对各个将来可能从事的行业认知的缺失。然而事实告诉我，你还是太年轻，想的太简单。</p><p>说到这里，我想谈一下我们很多年轻人对这个社会认知的问题。我们在真正独立走上社会之前，接受的宣传是通过主流价值观为主的。但即使这样，这样的信息也难免偏颇，很多时候我们只看到了事物的A面，而没有看到B面，甚至可能还有S面。就单说科研领域，社会告诉我们的是做出成果无尽荣光，可是却不会告诉我们一将功成万骨枯，以及很多领域象牙塔和工业界存在脱节。金融领域我们看到从业者西装革履光鲜亮丽，但是背后却有朝八晚三不为人知的辛酸。创业圈更是这样，有人ICO，IPO一夜暴富，可更多的却是亏完了钱打水漂睡沙发的窘迫。</p><p>打个比方，我所在的城市高楼林立科技发达，然而当夜幕降临在一些不为人知的角落，也存在流浪者、大麻甚至是枪击。很多时候我们带着有色的，甚至可能是带着粉红泡泡的眼镜去看待社会，这个滤镜是我们了解社会的为数不多的途径，即便它存在失真。因此初出茅庐的人很容易去带着单纯的心态去相信A面是社会的全貌，然而当撞到南墙的时候，可能会遭到这样的批评：“<strong>你对社会的认知存在偏差，这锅你不背谁背</strong>？”你总觉得哪里不对，却无法反驳。</p><p>确实我们在往上攀登和向广阔的未知天地进发的时候，每一步都在离开自己的舒适区，这也就意味着我们在小圆内对世界的认知是没法向外延拓的。每一步都存在风险，每一步都在跳未知的坑，再加上人生不如意十之八九，难免怀疑人生，其实到最后不管是焦虑还是佛系，都是挣扎之后的结果。打碎面前的云山雾罩似乎很容易，但是人总愿意去相信事物对自己有利的一面，而潜意识的厌恶可能存在的风险。到了这里，闭关自守也罢，虚无主义也罢，随着这样的恶性循环慢慢成了我们挥之不去的绊脚石。也因此，很多时候虽然道理就在那里摆着，但唯有撞南墙尝苦果，才能让我们冲破这层人性原罪的束缚，去认知更大的更全面的新世界。 ## 5 如果说刚刚出国的时候的情况是两眼一抹黑，那么一年之后的状态就是面前摆着几条道路，每条似乎都通向光明的前途，你却根本不知道该选哪一条。所幸导师对我很好，不管是在学术方面还是在生活方面都给了我很多人生经验和指引，让我有一种发自内心的因为受到知遇之恩所以必须要好好干活的感觉。受到这样的激励，我也立志在科研领域做出自己的一份贡献，然而由于接触的世界越来越大，我开始听到了很多不同的声音，而这些声音是我从来没有想象过的。</p><p>就比如说2016年很火的两篇帖子<a href="https://www.zhihu.com/question/50766928">《T大本科舍友阶级分化实录，该何去何从？》</a>与<a href="https://www.zhihu.com/question/44186681">《凭什么我辛苦二十年，现在却比别人差那么多？》</a>。从局外人的角度看来，我们可以说里面的主人公书生气过重，博士快要毕业了仍然没有认清楚一个事实，即你的学习成绩和学术成果和你将来在世俗评价标准下的成功只有很弱的相关性。可是话说回来，这样的谴责虽然道理正确，但并无助于解决问题，而且难免有一种站着说话不腰疼的感觉。更重要的是，久居象牙塔中的我们（包括我在内，也曾具有上述的思维误区），<strong>跟社会的接触少了，就很容易用这种单一的线性的价值观去评判自己和他人，尤其是和别人一比较，各种不如意便会纷至沓来</strong>。而且还是那个问题，人总愿意去相信对自己有利的观点，这就很容易用战术上的勤奋去掩盖战略上的懒惰（即便我在很长时间的科研当中也是如此，没仔细想why就去想how并亲身实践了无数种错误的how，结果自然是充满了无用功和南辕北辙）。</p><p>从上面这个现象引申出来另一个现象，即对部分存在产学研脱节现象学科的劝退，想必大家都了解了许多。如今信息比以前通畅得多，大学新生选择专业以及高校毕业生选择行业的时候比几年之前更懂得去参考历史的行程决定个人的发展方向，其实也未尝不是个好事。我个人曾经也是一个劝退者，但是如今，我觉得更应该做的是，消除信息不对称，也就是让了解信息有限的人们不仅认识到学术这条路的A面，更要了解其B面，对将来可能面临的风险有一个充分的估计，想明白自己追求的是什么。<strong>经过深思熟虑之后做出的选择，要比冲着高大上的标签或者七大姑八大姨的期待做出的选择，要更加理性</strong>。在这个方面，我自己就是活生生的目标不明确东一榔头西一棒子乱打的反例。</p><p>不得不承认做科研的经历是有一定痛苦的（其实任何事情都这样，不存在既高大上又光鲜亮丽的事情）。在自己的课题研究过程中，无数次遇到解不出来的公式，跑不出来的程序，和理论不一样的实验结果，以及各式各样用尽世间已有知识解释不了的问题。与此同时，周围的很多人在积极谋求转行，而金融和互联网成为了转行的首选。在这样的气氛中，除非是自己心里有明确目标且能塌下心来坐得住的人，否则包括我在内的很多人也难免被舆论影响，盖因心里虽然有目标但目标根本不坚定。此时此刻，我再次陷入迷茫，经常思考两个问题：1.我为什么要来这里？2.我将来到底想做什么？ ## 6 时间到了2017年，在社会经历着指数型的科技发展浪潮的过程当中，一种名为勃学的新思潮发展的如火如荼。简而言之，勃学基于失败学，我们每个人都有自己的失败，我们要对自身的失败有清醒的认识。从外界看来，取得了一定世俗成就的人本应是成功的，这样的失败是不是何不食肉糜呢？但是确实，这种思潮确实反映了一部分通过自我奋斗达到一定高度，所看到的世界却灰暗了许多的人们的认同感，尤其是名校毕业生和中产人士。为什么明明已经得到了很多，它们却带来了无尽的挫败感呢？</p><p>这里不谈阶级固化、精英主义等高大上的话题，只想举一个例子。我们的祖辈可能一生都没有走出过小镇，日出而作日落而息生活简单而充实。我们每个人都有那种小学初中同学，早早离开学校进入社会，在我本人朋友圈里看到的一些例子是，他们没有离开家乡，在家乡做着一些相对低收入低技术含量的工作，例如摆摊开店，大部分已经结婚生子，看起来十分快乐，现世安稳岁月静好。而我们很多人，从高考的残酷竞争中杀出来进入名校，可能还出国见了更大的世界，或是找到了高收入的工作，可为什么得不到他们的那种快乐呢？</p><p>我们或许可以这样思考，古人提出过人生三境界，如果我们永远不走出自己的舒适区，那么就是“<strong>看山是山看水是水</strong>”，或者说“我未入过繁华之境，未听过喧嚣的声音，未见过太多生灵，未有过滚烫心情，所以也未觉大洋正中有多么安静”。也因此，对客观世界的认知符合自己的常识，可以很轻易的通过自己的常识得到快乐。</p><p>然而到了第二境界，“<strong>看山不是山看水不是水</strong>”，当我们见了更大的世界，发现自己的一套体系已经不足以解释自己看到的世界，就比如苦心孤诣探索学术十几年，主观上做出了足够的努力，却在客观上收获不了自己想要的“书中自有黄金屋，书中自有颜如玉”，认知崩塌陷入对自己的怀疑，不管归因于“错的是我”抑或是“错的是世界”，价值观就会解体重塑。无论是打破幻影还是打破枷锁，这个过程都是十分痛苦的。</p><p>然而大部分人终其一生也很难达到第三境界，“<strong>看山还是山看水还是水</strong>”，没有一定经历和成就，这一层是连想都很难想象到的。即便是”众里寻他千百度；蓦然回首，那人却在灯火阑珊处“的”啊，原来你也在这里“，不经历一番”昨夜西风凋碧树，独上高楼，望尽天涯路“和”衣带渐宽终不悔，为伊消得人憔悴“的苦痛挣扎也是无法实现的。由于我自己远远没有达到这一境界，因此不多赘述。但总之，”你所认为的世界运行的规律“和”世界真实的运行规律“两者之间大部分情况下存在夹角，甚至有时候夹角还是钝角。因此，你不得不不断地调整自己对世界的认知，而这里面的阻力和惯性，以及调整之后与之前状态的错位，就容易让人怀疑自己所想所做到底对不对。</p><p>曾经有两篇阅读量极高的文章，<a href="https://www.zhihu.com/question/52031149">《我上了985 211才发现自己一无所有》</a>和<a href="https://www.zhihu.com/question/65098412">《一个月就辞职，一个北大女生的求职悲欢》</a>。虽然和勃学并未有联系，但反映的问题却是共通的。有些人对这种现象的批评，包括”无病呻吟“也罢，”庸俗矫情“也罢，其实仔细想想是站不住脚的，由于痛苦不共通，这就像问抑郁症的人为啥要自杀一样缺乏同理心，更何况我相信每个人都有过这样的怀疑和纠结，只是程度不同而已。人生对每个人都只有一次，进入社会见到更大的世界，必然面临着自我和世界的冲突，而处在冲突当中的个人，很容易将自己遇到的问题放大，陷入痛苦，就像小时候辛苦搭好的积木倒塌之后仿佛失去了全世界一样。从这个意义上来说，我倒是觉得同为年轻人的自己和这里面提到的主人公有一定共鸣。同是天涯沦落人，相逢何必曾相识？不过话说回来，该类文章其实反映了一个问题，就是“<strong>学区房值钱（个人奋斗几十年都不一定买得起）</strong>”和“<strong>学历不值钱（名校毕业生的世俗成就达不到内心期望）</strong>”之间的矛盾。所以，这个错位背后，是哪里错了呢？（这个问题我也没有想明白）。 ## 7 人生总有想不明白的哲学问题，就像科研也永远不能一路顺风一样。2017年发生过太多的事情，以至于刚脱胎换骨一遍的三观又被现实撕得粉碎。其间遇到了转博被拒的挫折，认识了硅谷科技界上百的IT工作者，回国看到了祖国翻天覆地的变化，也经历了对自己价值的彻底怀疑，人际关系的全面崩溃，甚至无数次夜不能寐在凌晨四点的帕罗奥图的天空下失声痛哭。</p><p>然而，冥冥之中总有个声音对我说：</p><p>“<strong>你得到今天的这一切，本来就是运气眷顾，你还想要什么呢</strong>？”</p><p>对啊，能走到今天，我所拥有的东西本来就不是和自己的能力匹配的，你是不是太贪得无厌了？</p><p><strong>“将寄托于花朵的思念用言语来表达出来，我丝毫不想伤害这个世界，如果没有聆听者的话，你就可以放任自己为所欲为吗？</strong></p><p><strong>然而，然而，你却把打算摘给别人的花留下，然后看到他的时候，却为了能得到赞扬把花送给他。</strong></p><p><strong>能找到这么漂亮的花，我是个好孩子吧。我来告诉你怎样去摘这朵花吧！</strong></p><p><strong>像这样假装亲切，好好炫耀一番。 以花为借口亲近他，伪君子。”</strong></p><p>——《School Days》 清浦刹那</p><p>我真的问心无愧吗？</p><p>我的初心是什么？为什么扭曲成了现在这个鬼样子？你看重的东西真的不是虚无缥缈的吗？</p><p>是不是一开始一切都错了呢？</p><p>为什么在给别人建议的时候从未失手，到自己身上就撞南墙撞得头破血流了呢？</p><p><strong>为什么会这样呢？？？</strong></p><p>2017年的冬天格外寒冷，在无尽的挣扎当中，整个冬天不仅科研没有进展，甚至什么都没干，极端的时候甚至想用安眠药一了百了。<strong>（题外话：我知道很多人曾经有过这样的想法，但是在这种时候，请一定一定去找自己信得过的人倾诉，或者去找专业的人员帮助解决心理问题</strong>。如果没有，我本人愿意做一个倾听者，也承诺保密所了解到的一切信息，毕竟我曾经在这样的痛苦中挣扎过。这种情况的人，我彻夜长谈过的，至少有三个，他们现在都已走出了内心的阴影，重获了生活的快乐。）</p><p>人们对于坏消息的第六感往往是非常准确的，尤其是在人生境遇处在低谷的时候。当转博被拒的时候我就觉得有些一厢情愿的事情可能就要到头了。于是我通过各种途径联系了外校的部分教授，硬着头皮再次投了一次博士申请，但是越来越觉得我想要的东西和我正在做的事情已经完全南辕北辙了。</p><p>2017年12月，由于对人生的怀疑和对现实的弃疗，我时常和各种人聊天，谈论各种各样的迷茫及困苦。与三十五岁恋爱都没谈过的博后促膝长谈，也与四十几岁孤身一人漂泊美国的研究员对月举杯。这就是我曾经想做的事情的B面，可是如果换成我，我愿意去赌这一个未知的未来吗？扪心自问，答案是否定的。</p><p><strong>“差一点骗了自己骗了你</strong></p><p><strong>爱与被爱不一定成正比</strong></p><p><strong>我知道被疼是一种运气</strong></p><p><strong>但我无法完全交出自己”</strong></p><p>——《可惜不是你》 梁静茹</p><p>所以，你确定自己不是叶公好龙吗？</p><p>这条路上所需要的努力（1分）、热情（3分）、运气（6分），你一个也没有。</p><p>你的初心可能没错，但是你所做的所想的，和你所追求的东西，完全是两个不同的方向。</p><p>这场持续三年的梦境，是时候该落幕了。</p><p>转过头来2018年到了，雨神似乎笼罩了湾区，终日不见阳光，让人的心情不由得也变得压抑。但是，梦醒了，是时候该回到原点重新开始了。</p><p>留下来读博做不到我不惊讶，联系好的教授放了我鸽子我也不惊讶，反正已经习惯了，起了个大早赶了个晚集的人又不止一个。然而收到第一个offer的时候我心里却五味杂陈。</p><p>一月的寒风中我前所未有的点上了一根烟让自己冷静下来（虽然我这25年来抽过的烟用两只手都能数过来）。烟雾中幻化出无数个平行世界，平行世界A中的我读完博士拿到教职走上人生巅峰令人艳羡，BCD中的我费了九牛二虎之力读完博士转行拿到了和别人本科毕业一样的工作，EFG……而平行世界XYZ中的自己，一生碌碌不得志，最后变成了MITBBS上的戾气溢出屏幕的精神已经不正常的中年loser。</p><p>路是自己选的，将来不管收获的是果，还是锅，也都是自己的。人生没有后悔药，做决策的时候多想想未来，而不要考虑沉没成本。</p><p><strong>“在终于释怀的那一刻</strong></p><p><strong>找回了久违的快乐”</strong></p><p>——《我决定》 梁静茹</p><p>自己辛苦追寻的金刚钻终究没有得到，瓷器活也只能另请高明了。 ## 8 2018年3月，我来到洛杉矶参加了一场学术会议，算是亲手给自己的追寻（本专业的）学术成就之路画下一个句号。讲完自己海报的一刻，突然有一种神清气爽的感觉，来不及放下东西，直奔加州理工去拜访几个多年未见的好朋友。此时此刻，我终于彻底想明白了一个道理，“<strong>科研和世俗成功两者之间即便不是垂直，夹角也至少有88°</strong>”。有人问88°是怎么得来的，我说用量角器量出来的。量出这个角度，我花了三年，而另一些人，甚至是十三年，三十年。饭桌上跟几个博士在读的朋友聊过，发现原来他们这等神人也有世俗的烦恼（虽然这是废话，但我的思维始终没有转过这个弯来）。家家有本难念的经，我们都是普通人，为什么要互相比较一些有的没的来给自己增加不必要的烦恼呢？求仁得仁，想要什么，就冲着那个方向放手一搏吧。</p><p>于是在几个月的刷题和几年来积累的计算机方面的知识、能力和项目经历的基础上，3月下旬的某一天我一夜之间通过各路朋友的内推向国内互联网公司投了五十份简历。虽然自己这几年来学术上不敢说有所收获，但是人脉和软实力上所积累的一切是我至今不悔留美三年的一个很重要的原因。虽然自己的知识体系必然不系统，但是我个人觉得自己的水平和科班CS大三大四的水平还是比较相当的（除了没有相关科研及实习经历以外）。闻道有先后，术业有专攻，如是而已，终究亡羊补牢也没晚多少。由于名校牌子的加成，整个求职过程还算顺利，连轴面试将近一个月，国内最后拿到4个offer，美国这边也投了几个小公司并都走到了最后一面，由于国内的offer到了，加之我个人在这里实在是过得不快乐，所以就没再继续面下去。本着此心安处是吾乡的原则，选完城市，再选公司，兜兜转转回到了最熟悉的五道口，加入一家蒸蒸日上的创业公司。（题外话：在五道口的前辈和友人们欢迎到时找我约饭。）</p><p>由于我实力有限加上并非走的正常校招流程，具体的求职细节就不在这里讲了，以防班门弄斧。如果同为转专业且对这个过程有兴趣将来可以私聊。当然不得不承认，由于求职始于匆忙，中间各种问题也出过不少，还出过一个差点没法毕业的乌龙，不过最终的结果还算不错，经过了几年的尝试，用了无数次排除法，在此刻虽然我也不敢说自己一定喜欢做什么，但是有把握说自己不喜欢做什么。这就像一个深度优先搜索一样，撞了南墙再回头，虽然有时候走了不少冤枉路撞了不少南墙，比别人晚到了目的地，可是看到的东西也更多了。</p><p>我曾经想过，如果高中多搞一门竞赛会怎样，大学选择一个不同的专业会怎样，研究生期间年年暑假出去实习会怎样，再仔细一想，在没有信息的情况下有多少人能做出这样的选择，而从最终结果看起来也不过是小的得失而已。有些事情放在当时看，重要吗？的确重要。可是从更长远的时间看来，什么都不是。如同幼儿园丢了个小红花，中学错过了喜欢的人，高考失利，求职遇挫，每个人都会对此做出应激反应，可是几年之后回首，也不过是饭桌上的一件谈资而已。</p><p>在上篇《老实人的归国与失身》中我曾经提到，求职过程中受到高中同学的内推，文中提到的高中同学本科位于家乡普通一本，通过考研来到了北京，积累了无数的实习经历最终在另一家独角兽企业独当一面。文中结尾提到的“明明是我先来的，为什么会变成这样呢？”本来是一个出自《白色相簿2》的梗，招致了一些不懂背景的人的误会。什么叫做线性思维/学生思维？这就是。早起的人不一定能赶上集，生活本来也没有先来后到。更何况别人在另一些方面比自己先来，比如工业界经验，比如对社会的认知，这都是象牙塔本身所给不了自己的。该篇文章中的主人公可能也是幸存者偏差的产物。</p><p>前段时间和朋友讨论，说到了不同的人在不同阶段所做的努力和承受的痛苦。从高考大省杀出来固然需要拼命，但从考研大省逆袭何尝不需要努力，而且艰苦程度也是非亲历者不能想象。我们能看到的例子是通过个人奋斗逆袭走上人生巅峰的人们，可是在这背后的B面，多少人在这一过程中折戟撞墙，最终成为了默默无闻的普通人，他们的故事又如何去表达出来呢？</p><p>什么是幸存者偏差？2018年高考全国二卷的作文就很能说明问题。</p><p><img src="https://img-blog.csdnimg.cn/20191202223556152.png" alt="在这里插入图片描述" /> 2018年6月，在即将离开美国的时候，我与科研大佬聊过他们申请教职当中的悲与喜，与硅谷科技从业者谈到科技下一步的发展方向，与现在的牛人本科生讨论他们的梦想，与00后一代学习他们的价值体系和处世方式，也与在国内的本科同学们交流不同行业的求职经历，以及当前日新月异的一线城市。曾经的自己只顾脚下的一条路，以为这就是整个世界，到头来路越走越窄以至于痛撞南墙。而抬起头来，发现参差多态乃是幸福本源，生活的跑道比自己想象的还要多得多。而这个时代恰恰也是信息量爆炸的时代，每个人都在追寻自己的梦想，就看谁能把握住这里面的机会。</p><p><strong>“回想起历往云烟终于让我全都看透</strong></p><p><strong>闭着眼低头走过那份温柔”</strong></p><p>——《涙の理由》 栗林美奈实</p><p>总之，运气眷顾，在一个新的领域，我在不知道自己有没有金刚钻的情况下又接下了瓷器活。可如今最大的不同就是，即便没有金刚钻，我也知道如何去获得它。即便无法获得，我也知道如何打磨现有的资源使之无限接近真正的金刚钻。几年的摸索告诉了我这样的方法论，也算是不虚此行了。感谢一路上遇到的前辈和同辈，感谢他们给我的指引和人生经验，感谢遇到的挫折使我想明白自己内心深处究竟想要的是什么，感谢命运待我还算不薄。路还很长，所以更要心无旁骛望着远方。</p><p>最后放一张图，描述在这么多年来我”想当一名科学家“的这个愿望的强烈程度是如何变化的。虽然走到现在，这条路上的追寻暂时鸣金收兵了，但失之东隅收之桑榆，我也看到了更广阔的风景，开始了另一条路上新的追寻。</p><p><img src="https://img-blog.csdnimg.cn/20191202223756684.png" alt="在这里插入图片描述" /> ## 9 时光飞逝，我自己的学生时代即将结束。清华四年经历告诉了我自己的能力是有局限的，而美国三年经历告诉了我天有多高地有多厚。虽然初心只是自己幼稚时候的一厢情愿，但人在长大的过程中都会变的，甚至在半年之前我都没有料到今天是这样的结局，计划永远赶不上变化，而未知的未来可能信息量更大。有时候我在思考一个问题：我一路以来享受了最好的教育资源，可是有没有做出相符的成绩和贡献呢？如果没有的话，我从中积累了什么优势呢？眼界，人脉，还是对更大的世界的认知，对自己较为全面的评价？</p><p>如果限制我们的成就的是外在因素，很多时候我们只会惋惜命运待人不公。就如同如果基础教育能够普及，广袤的非洲能走出多少科学家？可是这里面无数的聪明人就因为食不果腹而终其一生无法为人类的发展做出贡献。而我自己，出身明明优于90%的同辈人，享受着最好的教育资源，不缺天时地利人和，想要找到贵人相助也不难，在人生的重要选择关口也不乏运气垂青，理应有着更大的使命，为这个世界做出自己更大的贡献。然而，有时候事情的发展偏离了预想的轨道，现实情况和自我期待出现错位，明明自己能力达不到却不得不去努力争取，明明追寻的东西就在眼前看似唾手可得但就是得不到，那种失落和不甘心，如同差一点爬到高峰又狠狠摔下，带来的痛苦就要比在平地上跌倒要强烈得多。</p><p>我的经历和反思讲完了，在最后，我觉得有必要给出一些简单的结论：</p><p><strong>（0）选择正确的方向比努力更重要，而信息的通畅是做出明智选择的保证。将获取信息的能力从1提到2，边际效应要远远胜过努力程度由9提到10。</strong></p><p><strong>（1）对于名校同学，有时候我们自身带着一种骄傲，但在校内评价体系下受到的打击会令我们自卑，两者叠加在一起会让我们很难对自己有准确的定位。然而，既然享受着资源优势，而且终究都要走出象牙塔走向社会（即便是立志从事科研工作也不能免除与更大的世界打交道），不如早点接触真实的工作环境，在找到自己价值所在的同时，提前排除错误选项或者选定正确选项，不至于到最后赢在了成绩却输在了社会经验。</strong></p><p><strong>（2）对于非名校同学，高考、毕业学校这些东西和将来的成绩的相关度是很弱的，通过主动获取信息做出明智的选择，避免无头苍蝇一般的无效努力，进而比名校学生优秀的也大有人在。没有那种小心翼翼瞻前顾后患得患失，反而更大胆去试错和总结经验，这些都不是从书本上能够学到的。</strong></p><p><strong>（e）(e=2.718281828) 综上所述，高考考的如何和去什么学校读书真的没那么重要，在需要努力的时候尽力而为，但永远记得仅仅是努力本身是没有价值的。打怪升级获得的奖励，从来都不是和打怪的难度成正比。</strong></p><p><strong>（3）老实人们会习惯性认为，努力读书、努力工作等等才是能力，然而，真相却是，“不老实”可能是一种比个人奋斗更重要的能力。</strong></p><p><strong>（π）(π=3.141592654) 因此，老实，其实并不是一个好事。</strong></p><p>满纸荒唐言，一把辛酸泪。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ABOUT</title>
      <link href="/2019/10/23/ABOUT/"/>
      <url>/2019/10/23/ABOUT/</url>
      
        <content type="html"><![CDATA[<h2 id="about-me">ABOUT ME</h2><p>伪理想主义者，爱好广泛却飘忽不定，EI Madrigal是我常用的昵称。目前兴趣是System Programming和Machine Learning，但均无任何建树。</p><h2 id="about-this-site">ABOUT THIS SITE</h2><p>这个站点创建于2018年2月，部分文章是我曾经的公众号、知乎回答以及之前博客内容的迁移。</p><p>目前<a href="https://www.cnblogs.com/EIMadrigal/">国内版</a>和<a href="https://eimadrigal.github.io/">海外版</a>保持同步更新，有朝一日花点闲钱买个<code>.com</code>域名再合并！</p><p><strong>转载烦请联系本人，否则将追究侵权责任。</strong></p><h2 id="contact">CONTACT</h2><p>Email : andrew.renj@gmail.com</p><h2 id="donate">DONATE</h2><p>如果您觉得阅读之后有所收获，可以请我喝杯奶茶！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2019/10/02/Codeforces%20Round%20#590/"/>
      <url>/2019/10/02/Codeforces%20Round%20#590/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1234">Round #590</a> 题目答案：<a href="https://codeforces.com/blog/entry/70233">官方Editorial</a>、<a href="https://github.com/EIMadrigal/CF">My Solution</a> ## A. Equalize Prices Again 签到题还WA了一发，向上取整有点问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my wrong code, 1.0 * sum返回double</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">1.0</span> * sum / n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//right code</span></span><br><span class="line">(<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="number">1.0</span> * sum / n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ceil()原型</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p><code>float</code>能保证6位精度（有效数字），<code>double</code>能保证15位精度。但是<code>float</code>和<code>double</code><strong>默认都只显示6位有效数字</strong>，所以一旦<code>1.0 * sum / n</code>大于6位，函数返回的<code>double</code>就显示不全，造成精度损失（比如结果应该是<code>5336844</code>，但返回<code>5.33684e+006</code>），故进行强制类型转换。 ## B1. Social Network (easy version) 题意：屏幕可以容纳<span class="math inline">\(k\)</span>条短信，有若干朋友发来<span class="math inline">\(n\)</span>条短信。如果某个朋友已经在屏幕上，不做改变；否则将其他朋友下移，新收到的朋友置顶。求最终自顶向下显示在屏幕上的朋友。 思路：按照题意模拟，我搞得有些繁琐（用<code>queue + set</code>来考虑是否将新来的短信放入屏幕，再用<code>queue.size()</code>和<span class="math inline">\(k\)</span>判断是否需要将旧短信<code>pop()</code>，最后将队列中的元素逆序输出）。 ## B2. Social Network (hard version) 数据量变到了<span class="math inline">\(10^5\)</span>级别，官方题解和我在B1中的思路一致。不过最后输出我是先压栈，题解是先存入<code>vector</code>，再用<code>reverse()</code>函数逆序，复杂度<span class="math inline">\(O(nlogk)\)</span>。 ## C. Pipes 模拟题：比赛时候发现了既然可以无限旋转，那么管道一共有2类：<span class="math inline">\(12\)</span>一样，<span class="math inline">\(3456\)</span>一样。 水流到<span class="math inline">\(12\)</span>这类，只能水平向右流； 流到<span class="math inline">\(3456\)</span>这类，那么另一行对应的位置也必须是<span class="math inline">\(3456\)</span>类，水就会换一行流动（异或即可换行），否则水没法继续流动。 最后判断水能否流到第二行第<span class="math inline">\(n\)</span>列。 ## D. Distinct Characters Queries 题意：给一字符串和<span class="math inline">\(q\)</span>次查询，查询分为两类：一类是替换字符串中某个字母，另一类是求子串中非重复字符的个数。 比赛时的思路是：遇到第一类查询就按规则替换，第二类先拿到子串，依次把子串的每个字符放入<code>set</code>中，最后返回<code>set.size()</code>即是非重复字符个数。 此题的教训就是要学会根据数据量级猜算法：1s/2s时限，C++运算次数大约在<span class="math inline">\(10^7\)</span>，本题的数据范围<span class="math inline">\(10^5\)</span>，我傻傻地把<span class="math inline">\(O(n^2)\)</span>的算法交了三次，TLE了三次，我还以为是<code>cin</code>的问题。。。 参考下大佬经验：<a href="https://www.acwing.com/blog/content/32/">由数据范围反推算法复杂度</a>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round</title>
      <link href="/2019/09/23/Codeforces%20Round%20#587/"/>
      <url>/2019/09/23/Codeforces%20Round%20#587/</url>
      
        <content type="html"><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1216">Round #587</a> 题目答案：<a href="https://codeforces.com/blog/entry/69954">官方Editorial</a>、<a href="https://github.com/EIMadrigal/CF">My Solution</a> ## A. Prefixes 题意：给一字符串，只含有<code>'a'</code>或<code>'b'</code>，需要改变某些位置（<code>'a'</code>变<code>'b'</code>或<code>'b'</code>变<code>'a'</code>），使得该字符串任意偶数长度前缀中<code>'a'</code>和<code>'b'</code>个数相等，求改变的最少次数以及更改后的字符串。</p><p>题解：遍历，判断<code>s[2i]</code>和<code>s[2i+1]</code>是否相等。如果相等，需要一次更改，并将其中一个改为不同字母。 ## B. Shooting 题意：给<span class="math inline">\(n\)</span>个编号<span class="math inline">\(1\)</span>~<span class="math inline">\(n\)</span>的射击目标，每个目标有不同的耐久度，假设已经击倒了<span class="math inline">\(x\)</span>个目标，将要射击第<span class="math inline">\(i\)</span>个目标，那么需要<span class="math inline">\(a_i*x+1\)</span>次才可以击倒该目标，<span class="math inline">\(a_i\)</span>为第<span class="math inline">\(i\)</span>个目标的耐久度。求击倒所有目标的最少射击次数以及射击次序。</p><p>题解：贪心。想要射击次数最少，就要先射击耐久度大的目标，所以按照耐久度由大到小排序，同时记录对应的目标序号。 ## C. White Sheet 题意：给定三个矩形，两黑一白，判断两个黑色矩形是否可以完全覆盖白色矩形，不能完全覆盖输出<code>YES</code>。</p><p>题解：分两种情况，记白色矩形面积为<span class="math inline">\(S_w\)</span>，一个黑色矩形与白色矩形交叉面积为<span class="math inline">\(S_{wb1}\)</span>，另一个黑色矩形与白色矩形交叉面积为<span class="math inline">\(S_{wb2}\)</span>，两黑色矩形交叉面积为<span class="math inline">\(S_{bb}\)</span>： 1、两黑色矩形无交叉：只要<span class="math inline">\(S_{wb1}+S_{wb2}&lt;S_w\)</span>，就可以看到白色矩形； 2、两黑色矩形有交叉：如果<span class="math inline">\(S_{wb1}+S_{wb2}-S_{bb}&lt;S_w\)</span>，可以看到白色矩形。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Recursion and Backtracking</title>
      <link href="/2019/09/16/Recursion%20and%20Backtracking/"/>
      <url>/2019/09/16/Recursion%20and%20Backtracking/</url>
      
        <content type="html"><![CDATA[<h2 id="tree-recursion">Tree Recursion</h2><p>递归是计算机科学中一个非常重要的概念，对于斐波那契那种比较简单的递归，分析起来比较容易，但是由于二叉树涉及指针操作，所以模拟下遍历过程中系统栈的情况。 以二叉树中序遍历为例演示： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">TreeNode* left;</span><br><span class="line">TreeNode* right;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 中序遍历的递归实现： <img src="https://img-blog.csdnimg.cn/20190915232047750.png" alt="在这里插入图片描述" /> 假设二叉树如图所示： <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDE5MDkvMTI2MDU4MS0yMDE5MDkxNTIzMTQyMDE5MS0xMTMxOTk2Nzc2LnBuZw?x-oss-process=image/format,png" /> 其中序遍历序列为<span class="math inline">\(2413\)</span>，可以在VS中用单步调试的方法跟踪相应的变量： 当<code>root==NULL(root指向2的左孩子)</code>时，此时的系统栈（将1和2都压栈，因为中序遍历需要先访问左孩子）： <img src="https://img-blog.csdnimg.cn/20190916223229149.png" alt="在这里插入图片描述" /> 这时<code>if</code>不成立，执行83行的<code>return</code>语句，接着退栈，回到78行，此时的<code>root指向2(因为此时程序已经来到了新的栈顶)，并且向这个新栈顶返回了一个空的seq</code>： <img src="https://img-blog.csdnimg.cn/20190916223847870.png" alt="在这里插入图片描述" /> 接着执行79行(因为这是上一个函数<code>return</code>的，所以不会再一次执行78行)，将2存入<code>seq</code>中； 执行80行（<code>root</code>指向4），进而执行78行，<code>root</code>指向4的左孩子，此时的系统栈（很明显可以看到从<strong>栈底到栈顶依次存放根结点到当前<code>root</code>结点的路径</strong>上的结点）： <img src="https://img-blog.csdnimg.cn/20190916225924483.png" alt="在这里插入图片描述" /> 同样，执行<code>return</code>语句，退栈，将<code>seq</code>(里面只有2)返回到这一层，这一层的<code>root</code>指向4，接着将4存入<code>seq</code>； 到80行，调用<code>inOrder()</code>使得<code>root</code>指向4的右孩子，右孩子为空，所以返回并退栈，<code>root</code>重新指向4，此时80行执行完毕，整个<code>if</code>执行完毕，返回<code>seq</code>并退栈，<code>root</code>返回到了2，以2为根结点的子树中序遍历完毕，系统栈： <img src="https://img-blog.csdnimg.cn/20190916230804141.png" alt="在这里插入图片描述" /> 继续执行，return到78行，<code>root</code>指向1，将1存入seq，以此类推，就可以得到整个的遍历序列。</p><p>最关键的是：之所以要递归调用<code>inOrder</code>，就是因为现在还不想访问当前的结点（对于中序，要先找到最左边的结点），所以通过递归的方式将当前暂时不想访问的结点压入系统栈，找到了想访问的结点后，访问它并利用退栈操作返回父结点。 有关树的问题，有一些通用的模板： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one root</span></span><br><span class="line"><span class="function">func <span class="title">solve</span><span class="params">(root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)  <span class="keyword">return</span> ...</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">f</span>(root) <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">solve</span>(root-&gt;left);</span><br><span class="line">    r = <span class="built_in">solve</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(root, l , r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// two roots</span></span><br><span class="line"><span class="function">func <span class="title">solve</span><span class="params">(p, q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == null &amp;&amp; q == null)  <span class="keyword">return</span> ...</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">f</span>(p, q)  <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">solve</span>(p.child, q.child);</span><br><span class="line">    r = <span class="built_in">solve</span>(p.child, q.child);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(p, q, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典递归">经典递归</h2><p>除了树这种本身就是递归定义的结构外，还有一些search的问题也可以通过递归解决： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">length</span>() &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> s[<span class="number">0</span>] == s[s.<span class="built_in">length</span>() - <span class="number">1</span>] &amp;&amp;</span><br><span class="line"><span class="built_in">isPalindrome</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>, s.<span class="built_in">length</span>() - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NotFound = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSearch</span><span class="params">(vector&lt;string&gt;&amp; v, <span class="keyword">int</span> start, <span class="keyword">int</span> stop, string key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; stop) <span class="keyword">return</span> NotFound;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (start + stop) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (key == v[mid])</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (key &gt; v[mid])</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BSearch</span>(v, mid + <span class="number">1</span>, stop, key);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">BSearch</span>(v, start, mid - <span class="number">1</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == k || k == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">C</span>(n - <span class="number">1</span>, k) + <span class="built_in">C</span>(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(string soFar, string rest)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="string">&quot;&quot;</span>)</span><br><span class="line">cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">string next = soFar + rest[i];</span><br><span class="line">string remaining = rest.<span class="built_in">substr</span>(<span class="number">0</span>, i) + rest.<span class="built_in">substr</span>(i + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">permute</span>(next, remaining);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">per</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> d, vector&lt;<span class="keyword">bool</span>&gt;&amp; used, vector&lt;<span class="keyword">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == d) &#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (used[i])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">used[i] = <span class="literal">true</span>;</span><br><span class="line">cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"><span class="built_in">per</span>(nums, n, d + <span class="number">1</span>, used, cur, ans);</span><br><span class="line">cur.<span class="built_in">pop_back</span>();</span><br><span class="line">used[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对数组a的[l, r]做全排列</span></span><br><span class="line"><span class="comment"> * 每个数字都要充当第一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">cout &lt;&lt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line"><span class="built_in">swap</span>(a[l], a[i]);  <span class="comment">// 第i个元素充当第一个</span></span><br><span class="line"><span class="built_in">perm</span>(a, l + <span class="number">1</span>, r);  <span class="comment">// 剩余元素全排列</span></span><br><span class="line"><span class="built_in">swap</span>(a[l], a[i]);  <span class="comment">// 恢复状态，保证下个做第一个元素的状态正确</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200704153124426.png" alt="在这里插入图片描述" /> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">com</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == d) &#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line"><span class="built_in">com</span>(nums, n, d + <span class="number">1</span>, i + <span class="number">1</span>, cur, ans);</span><br><span class="line">cur.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsets</span><span class="params">(string soFar,string rest)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rest == <span class="string">&quot;&quot;</span>)</span><br><span class="line">cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// add to subset, remove from rest, recur</span></span><br><span class="line"><span class="built_in">subsets</span>(soFar + rest[<span class="number">0</span>], rest.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// do not add to subset, remove from rest, recur</span></span><br><span class="line"><span class="built_in">subsets</span>(soFar, rest.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200704153731705.png" alt="在这里插入图片描述" /> 从递归树可以看到：Permutation和Subsets都是关于<em>选择</em>的问题，树的深度代表选择的次数，每层的宽度代表每次决定时的选项。这种都是Exhaustive Recursion，所以复杂度很高。</p><h2 id="backtracking">Backtracking</h2><figure><img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211129144559235-1738742177.png" alt="" /><figcaption>image</figcaption></figure><p>主要可以解决<strong>组合问题</strong>、<strong>排列问题</strong>、<strong>子集问题</strong>、<strong>字符串切割问题</strong>、<strong>棋盘问题</strong>，这些问题都可以抽象为<strong>多叉树的搜索问题</strong></p><figure><img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211129090136628-461210128.png" alt="" /><figcaption>image</figcaption></figure><p>回溯用来搜索选择性问题（a series of choices）的所有/部分解，每做一次选择，就递归一次，如果约束条件不满足，需要<strong>回退到上一层递归的参数状态</strong>。 通过约束条件的剪枝可以避免对整个搜索空间的穷举，从而提高效率。</p><p>三个关键点：</p><ol type="1"><li>Choice 明确要做的决定，<strong>每次递归代表一次决定，每次的决策结果都保存在这一层的call stack中</strong>。 eg. 遍历二叉树时，当处在某一层的某结点时，下一次递归调用是向左还是向右。</li><li>Constraints 怎样剪枝，当前状态已经invalid，不必再从该状态继续搜索，直接返回。</li><li>Goal 找到target后，就要回溯到上一层，进行其它可能性的搜索。</li></ol><p>Pattern： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// backtracking</span></span><br><span class="line"><span class="keyword">bool</span>/<span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(configuration conf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (no more choices)  <span class="comment">// base case</span></span><br><span class="line"><span class="keyword">return</span> (conf is goal state);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (all available choices) &#123;</span><br><span class="line"><span class="keyword">try</span> one choice c:</span><br><span class="line"><span class="comment">// solve from here, if works out, you are done</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">solve</span>(conf with choice c made))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">unmake choice c;   <span class="comment">// explore other solutions</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// tried all choices, no soln found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>几个例子：</p><ol type="1"><li>N-Queens 对照N皇后问题，明确三个关键点： 1）对于每一列，要做的决定是将Q放在哪一行，每次递归都会进入下一列的决策； 2）约束条件：不能出现在同一行、同一列、同一斜线； 3）目标：当在最后一列成功放置Q后，就可以回溯到上一层去探索其它解。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(grid&lt;<span class="keyword">bool</span>&gt;&amp; board, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (col &gt;= board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rowToTry = <span class="number">0</span>; rowToTry &lt; board.<span class="built_in">size</span>(); ++rowToTry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSafe</span>(board, rowToTry, col)) &#123;</span><br><span class="line">            <span class="built_in">placeQueen</span>(board, rowToTry, col);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(board, col + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">removeQueen</span>(board, rowToTry, col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>Sudoku <img src="https://img-blog.csdnimg.cn/20200704162901848.png" alt="在这里插入图片描述" /> 将1-9放入格子，要求每行、每列、每块不能有重复数字。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(Grid&lt;<span class="keyword">int</span>&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the gird to check, we should check all the grids</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all grids assigned successfully</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">findUnassigned</span>(grid, row, col)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; ++num) &#123; <span class="comment">// options are 1-9</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">noConflict</span>(grid, row, col, num)) &#123;</span><br><span class="line">            <span class="built_in">grid</span>(row, col) = num; <span class="comment">// try assign</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(grid)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">grid</span>(row, col) = UNASSIGNED; <span class="comment">// undo and try again</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>球员归化</title>
      <link href="/2019/09/10/%E7%90%83%E5%91%98%E5%BD%92%E5%8C%96/"/>
      <url>/2019/09/10/%E7%90%83%E5%91%98%E5%BD%92%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="历史时刻">历史时刻？</h2><p>2019年9月10日，2022年卡塔尔世界杯亚洲区预选赛，马尔代夫对阵中国。 归化球员Elkeson身披11号球衣，代表中国男足首发出战。 不久之前，Elkeson加入中国国籍，甚至连自己中文名字（艾克森）还不会写、国歌都不会唱，却成为了国家队的一员。</p><h2 id="福还是祸">福还是祸？</h2><p>我个人一直是坚定地反对无血缘归化，可是舆论好像支持的比较多。 回顾历史，国足只在2002年打进过一次世界杯。受到零几年黑球、假球的影响，我们的足球人才出现了严重的断档，自然国家队的水平也长期徘徊在亚洲二三流。 长期无缘世界杯让我们的球迷焦躁不安，更是由于老大喜欢足球，并且多次在公开场合表示要把中国足球搞上去，中国足协出了各种各样的奇葩政策：</p><ol type="1"><li>高薪聘请国外教练：里皮、阿里汉、卡马乔，解约卡马乔时支付5000万违约金；</li><li>在中超联赛施行U23政策，俱乐部也是上有政策、下有对策：U23球员的出场时间非常可怜，只是满足足协最低要求而已；</li></ol><p>可惜，就是不把主要精力放在青训上，总想着捷径：当然，这也是官僚一贯的急功近利作风，前人栽树后人乘凉的事想都不要想。 中超联赛踢得如火如荼，可是没有跑道的专业球场屈指可数； 外援垄断了射手榜和关键位置，国内球员只是陪跑； 如果静下心来踏踏实实做好青训，规范我们的联赛，开展俱乐部各级梯队的比赛，做好校园足球的普及和推广，就像姚明对中国篮球的改革一样，那么我们10年后一定可以打进世界杯，可惜领导从来不会有这样的耐心。 其实我们的目标只是打进世界杯而已，从来就不是提高中国足球的水平。围绕这个任务，所有的一切也都得到了非常合理的解释：在恒大建立国家集训队、无血缘归化...... 有人说归化可以带动中国足球水平的提高，让越来越多的孩子走上职业联赛，并且归化和青训可以同时进行。。。 就足协那个尿性，一旦从归化中尝到了甜头，还有谁愿意冒着风险、付出成本去做青训？ 我对Elkeson并不反感，从2013年亚冠就开始看他的比赛。在俱乐部层面，他给中国足球带来了亚冠冠军；平时生活中对中国文化也很尊重； 加入中国国籍可能有对于这个国家的热爱，但是背后是8~9位数的薪资以及复杂的利益纠缠，否则怎么会那么轻易主动放弃自己祖国国籍？ Elkeson只是第一个，后面可能还有高拉特、费尔南多、阿洛伊西奥......这就是恒大许老板所谓的“全华班”？ 这样即使打进世界杯，看着巴西人组成的前锋线，球迷心里真的还会有那份民族自豪感吗？ 另外，归化对于联赛的公平运作也是毁灭性的打击。其他俱乐部的外援都去恒大，足协钦定的政策谁敢不从？ 喊了这么多年联赛职业化，可惜中超的职业化只是政治因素下的可笑的玩物！ 曾经，国家队的每场比赛我都不会错过：赢了我激动地欢呼，输了我会难过好几天。见过它的高光，也陪伴它走过低谷。 这次我是真的失望到无法接受：从今天开始，我不会再关注中国足球的任何消息，这潭泛着恶臭的死水已经开始恶心到我了！ 以后就看看梅西、阿森纳和西班牙就行了~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高墙与鸡蛋</title>
      <link href="/2019/09/05/%E9%AB%98%E5%A2%99%E4%B8%8E%E9%B8%A1%E8%9B%8B/"/>
      <url>/2019/09/05/%E9%AB%98%E5%A2%99%E4%B8%8E%E9%B8%A1%E8%9B%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="村上在耶路撒冷">村上在耶路撒冷</h2><p>2009年春天，村上春树获得了“耶路撒冷文学奖”。当时巴勒斯坦和以色列之间的冲突愈演愈烈，很多人都劝阻村上不要去以色列领奖，何况村上其实对公开场合发表演讲、接受采访这些事是比较排斥的。 他最终还是决定出席（原因他在演讲时解释了），并且发表了极为精彩的演说--“高墙与鸡蛋”。 全文还是不太好找，不过最终在林少华先生的博客中找到了中文版（林少华先生是村上小说很重要的翻译家）：<a href="http://blog.sina.com.cn/s/blog_48f36ce00100e3qd.html">原文链接</a></p><blockquote><p>我作为一个小说家，换句话说，作为以巧妙说谎为职业的人来到这里、来到耶路撒冷市。</p></blockquote><blockquote><p>当然，说谎的不都是小说家。诸位知道，政治家屡屡说谎，外交官和军人说谎，二手车推销员、肉铺和建筑业者也说谎。但小说家说谎和他们说谎的不同之处在于：小说家说谎不受道义上的谴责。莫如说谎说得越大越高明，小说家越能得到人们的赞赏和好评。为什么呢？</p></blockquote><blockquote><p>这是因为，小说家能够通过巧妙说谎、通过栩栩如生的虚构而将真相拽到另一场所投以另一光照。以其固有的形式捕捉真相并予以准确描述在许多情况下是不可能的。惟其如此，我们才要把真相引诱出来移去虚构地带，通过将其置换为虚构形式来抓住真相的尾巴。但为此必须首先在自己心底明确真相的所在，这是巧妙说谎所需要的重要资格。</p></blockquote><blockquote><p>可是今天我不准备说谎，打算尽可能说实话。一年之中我也有几天不说谎，今天恰好是其中的一天。</p></blockquote><blockquote><p>实话实说好了。关于此次来以色列接受耶路撒冷文学奖，不少人劝我最好拒绝。甚至警告说如果前来，将开展不买我的书的运动。无须说，理由在于加沙地区的激战。迄今为止，已不止一千人在被封锁的城区丧生，据联合国报告，大多数是儿童、老人等手无寸铁的平民。</p></blockquote><blockquote><p>接到获奖通知以来，我本人也一再自问：这种时候来以色列接受文学奖果真是妥当的行为吗？不会给人以支持作为纷争当事者一方、拥有占绝对优势的军事力量并积极行使的国家及其方针的印象吗？那当然不是我所希望的。我不认可任何战争，不支持任何国家。同时，自不待言，我的书在书店被人拒买也不是我所希求的。</p></blockquote><blockquote><p>然而，经过深思熟虑，我重新坚定了来这里的决心。原因之一，就在于有那么多人劝我最好别来。或许我有一种大部分小说家都有的“犟脾气”--别人叫我“别去那里”、“别干那个”、尤其那样警告我的时候，我就偏偏想去或想干，此乃小说家的nature（天性）。为什么呢？因为小说家属于这样一种人：无论刮怎样的逆风，也只能相信自己实际目睹、自己实际手摸的东西。</p></blockquote><blockquote><p>正因如此，我才出现在这里。较之不来，选择了来；较之什么也不看，选择了看点儿什么；较之什么也不说，选择了向诸位说点儿什么。</p></blockquote><blockquote><p>有一句话（message）请允许我说出来，一句个人性质的话。这句话在我写小说时总在我脑袋里挥之不去。它并非写在纸上贴在墙壁，而是刻于我的脑壁。那是这样一句话：</p></blockquote><blockquote><p><strong>假如这里有坚固的高墙和撞墙破碎的鸡蛋，我总是站在鸡蛋一边。</strong></p></blockquote><blockquote><p>是的，无论高墙多么正确和鸡蛋多么错误，我也还是站在鸡蛋一边。正确不正确是由别人决定的，或是由时间和历史决定的。假如小说家站在高墙一边写作--不管出于何种理由--那个作家又有多大价值呢？</p></blockquote><blockquote><p>那么，这一隐喻到底意味什么呢？在某种情况下它是简单明了的。轰炸机、坦克、火箭、白燐弹、机关枪是坚硬的高墙。被其摧毁、烧毁、击穿的非武装平民是鸡蛋。这是这一隐喻的一个含义。</p></blockquote><blockquote><p>但不仅仅是这个，还有更深的含义。请这样设想好了：我们每一个人都或多或少分别是一个鸡蛋，是具有无可替代的灵魂和包拢它的脆弱外壳的鸡蛋。我是，你们也是。再假如我们或多或少面对之于每一个人的坚硬的高墙。高墙有个名称，叫作体制（System）。体制本应是保护我们的，而它有时候却自行其是地杀害我们和让我们杀人：<strong>冷酷</strong>地、高效地、而且系统性地（Systematically）。</p></blockquote><blockquote><p>我写小说的理由，归根结底只有一个，那就是为了让个人灵魂的尊严浮现出来，将光线投在上面。经常投以光线，敲响警钟，以免我们的灵魂被体制纠缠和贬损。这正是故事的职责，对此我深信不疑。不断试图通过写生与死的故事、写爱的故事来让人哭泣、让人惧怕、让人欢笑，以此证明每个灵魂的无可替代性--这就是小说家的工作。我们为此而日复一日地认真编造故事。</p></blockquote><blockquote><p>我的父亲去年夏天去世了，活了九十岁。他是个退休教师，也是个兼职佛教僧侣。在研究生院就读期间被征召入伍，参加了中国大陆的战斗。我小的时候，他每天早上都在饭前向佛坛献上长长的深深的祈祷。一次我问父亲为什么祈祷，他回答为了在战场死去的人，为了在那里--无论友方敌方--失去性命的人。每次看见父亲祈祷的身姿，我都觉得那里似乎漂浮着死亡的阴影。</p></blockquote><blockquote><p>父亲去世了，其记忆--还没等我搞清是怎样的记忆--也彻底消失了。但是，那里漂浮的死亡气息仍留在我的记忆中。那是我从父亲身上继承的少数然而宝贵的事项之一。</p></blockquote><blockquote><p>我在这里想向诸位传达的只有一点：我们都是超越国籍、种族和宗教的一个一个的人，都是面对体制这堵高墙的一个一个的蛋。看上去我们毫无获胜的希望。墙是那么高那么硬，那么冰冷。假如我们有类似获胜希望那样的东西，那只能来自我们相信自己和他人的灵魂的无可替代性并将其温煦聚拢在一起。</p></blockquote><blockquote><p>请这样想想看。我们每一个人都有可以拿在手中的活的灵魂，体制则没有。不能让体制利用我们，不能让体制自行其是。不是体制创造了我们，而是我们创造了体制。</p></blockquote><blockquote><p>我想对诸位说的仅此一点。</p></blockquote><blockquote><p>荣获耶路撒冷奖，我很感谢。感谢世界很多地方都有看我书的人。我要向耶路撒冷的每一位读者致以谢意。毕竟是因了你们的力量我才出现在这里的。但愿我们能够共同拥有什么--非常有意义的什么。我很高兴得以来此向诸位讲话。</p></blockquote><p>村上的小说一直强调个人的自由，他也一直希望每个个体都能拥有独特的生活方式、活出自我，而不是被体制化（Institutionalization）。 其实发表演讲时，如果不是因为战争的背景以及村上的解释，那么我对于<strong>永远站在鸡蛋一边</strong>是无法苟同的：试想如果鸡蛋（弱势者）的行为的确非常过分，那么如此绝对地站队是不是有些混淆是非呢？ 不过村上的浅层隐喻是在讽刺战争对平民的伤害，更深层次的是对体制的搏斗以及自由的向往，这些观点足以让我信服。</p><h2 id="hard-boiled">Hard-Boiled</h2><p>这篇演说比较有趣的地方在于：村上这个系统建构狂魔为读者解释了他的一本小说的名字（这个我也是从杨照老师那里了解的）：《世界末日与冷酷仙境》。 这本小说本来是直接用英语命名，把英语写成日语外来语起名。原来叫做Hard-Boiled Wonderland and the End of the World，Wonderland比较明显出自于Alice's Adventures in Wonderland（爱丽丝梦游仙境），但是Hard-Boiled只看字面意思的话，很难理解为什么会翻译成冷酷，应该是沸腾加热这种意思才对啊~ Hard-Boiled一般就只用在美国人吃早餐时候：服务员会问你要的eggs是要soft-boiled or hard-boiled？全熟的蛋也不能叫做冷酷吧？ 美国在上世纪有一类流行小说叫做Hard-Boiled Detective Story，村上一直受西方文学影响，而且很喜欢这种类型的小说。 所谓硬汉侦探小说，其实并不是大家想象中的那种超级英雄：无坚不摧、拯救世界。 这种Hard-Boiled“硬汉”其实只是看起来很酷，戴个墨镜，实际上只是在逞强而已，他们是在社会上摸爬滚打多年、不断受挫，内心很柔弱、很受伤的一群人，成为侦探是因为他们和罪犯有着相似的生活经历，所以了解他们。 这种类型的硬汉虽然不会轻易认输，但是其实也是在苦苦支撑而已，就像是早餐店里那种Hard-Boiled eggs，以为自己成熟了，但是如果这种蛋碰到墙上，那么破碎的必然是蛋，而高墙不会有任何损失。 即使这样，村上也还是会<strong>永远站在鸡蛋一边，无论高墙多么正确和鸡蛋多么错误。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>翻唱与抄袭</title>
      <link href="/2019/08/31/%E7%BF%BB%E5%94%B1%E4%B8%8E%E6%8A%84%E8%A2%AD/"/>
      <url>/2019/08/31/%E7%BF%BB%E5%94%B1%E4%B8%8E%E6%8A%84%E8%A2%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="缘由">缘由</h2><p>曾经，《老男孩》风靡一时，无数人热泪盈眶，我也感动得一塌糊涂。筷子兄弟也凭借此歌迅速走红，获得无数粉丝青睐。 我起初对日本音乐了解甚少，平时也不太接触。偶然听到山口百惠、中森明菜等一些昭和时代歌姬的演唱之后，才逐渐开始欣赏日本音乐。 毫不夸张地说，日本音乐在亚洲绝对顶级水准。这也造就了一大批靠翻唱、抄袭日本曲目成名的歌手，以及一些我们曾经为之泪流满面的歌曲。 当然，拿到原创的允许进行翻唱无可厚非，但是没有版权、重新填词并公开商演又是一种怎样的行为呢？</p><h2 id="ありがとう">ありがとう</h2><p>大桥卓弥的《ありがとう》（谢谢），就是《老男孩》的原曲。 <a href="https://b23.tv/av22011510">原曲</a>关于亲情的MV非常感人。</p><p>筷子兄弟在没有授权的情况下填词发布，后来面临起诉时才购买版权。这种“先上车后补票”的行为并不少见，据说《父亲》的旋律是把福山雅治的《milk tea》副歌部分和宫本笑里的《stay with me》副歌部分拼凑到一起的，不过并没有实锤。有人戏谑（ありがとう网易云热评）：“在知道老男孩是翻唱的之后，我一点也不好奇为什么筷子兄弟的曲风一下从老男孩变成了小苹果”。</p><h2 id="反思">反思</h2><p>很多网友戏称：中岛美雪养活了大半个华语音乐圈。 很不幸，国内许多歌手的代表作都是翻唱美雪阿姨的：任贤齐的《伤心太平洋》、王菲的《容易受伤的女人》...... 刘若英的《后来》是翻唱Kiroro的《未来へ》，《很爱很爱你》也是翻唱这个组合的同一张专辑...... 再看最近，自称“原创歌手”的花粥代表作《盗将行》、《出山》都涉嫌抄袭； <a href="https://b23.tv/av45107069">《出山》原曲</a> 附上<a href="https://b23.tv/av45298740">左右声道对比</a></p><p>神曲《起风了》也是翻唱高桥优的《ヤキモチ》（吃醋），附上<a href="https://b23.tv/av23618612/p1">MV链接</a> 真的太多太多了，我曾经在贴吧看过一个统计，国内知名歌手翻唱日本歌手的歌曲一共列了好几十个页面...... 说这些不是为了引战，我们要正视差距，填词都很不错，优秀的作曲真的太少太少，所以周杰伦才那么难能可贵。 反观日本，几乎每个歌手都是创作者，作品的旋律也非常优美，能把人深深吸引进故事里，而不是写一些口水歌。 唱功再好，最多就是个singer，成为不了musician~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Norwegian Wood</title>
      <link href="/2019/08/26/Norwegian%20Wood/"/>
      <url>/2019/08/26/Norwegian%20Wood/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>《挪威的森林》是村上春树很有名的一部小说，但我想大多数人阅读的时候都只是把书名当作一个符号，而不是作为故事去追究。 我国台湾知名文学评论家杨照先生说过：村上的书里有太多太多典故，如果你只是把这些典故当作符号看待，那么会少很多阅读的乐趣。你探寻这些典故越深，就越能体会村上想要表达的意思。 那么《挪威的森林》是怎么来的？</p><h2 id="the-beatles">the Beatles</h2><p>了解村上的人都知道：他生命中最重要的几件事就是写作、听音乐、长跑和翻译。 Norwegian Wood(This Bird Has Flown)是Beatles在1965年发行的歌，这首歌的歌词非常简单：</p><blockquote><p>I once had a girl Or should I say she once had me She showed me her room Isn't good Norwegian wood?</p></blockquote><blockquote><p>She asked me to stay And she told me to sit anywhere So I looked around And I noticed there wasn't a chair I sat on a rug biding my time</p></blockquote><blockquote><p>Drinking her wine We talked until two and then she said "It's time for bed" She told me she worked In the morning and started to laugh I told her I didn't And crawled off to sleep in the bath</p></blockquote><blockquote><p>And when I awoke I was alone This bird had flown So I lit a fire Isn't it good Norwegian wood?</p></blockquote><p>歌词的寓意很明显：这个女孩喜欢男孩，想和他滚床单，男孩激动地陪她喝酒聊天。 等他早上醒来的时候，发现女孩已经走了，本来在他手里的鸟飞走了，好似喝醉后的一场梦，转瞬无影踪。 可是Norwegian wood为什么莫名其妙出现在这里？</p><h2 id="故事">故事</h2><p>这首歌基本上是John Lennon完成的，歌词原本是<strong>Isn't good? Knowing she would</strong> 创作完成后，唱片公司觉得歌词的意味太明显，在60年代这样的歌词有些太过直白。 唱片公司要求John修改歌词，调皮的John就利用谐音把<strong>Knowing she would</strong>改成了<strong>Norwegian wood</strong> 改完之后，起初录音时候他还是唱<strong>Knowing she would</strong>，于是唱片公司下了最后通牒：如果还这样唱，那这首歌不能收录。 就这样，John Lennon唱出了<strong>Norwegian wood</strong>，村上听着<strong>Norwegian wood</strong>写出了<strong>Norwegian wood</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Blog Customization</title>
      <link href="/2019/08/19/Blog%20Customization/"/>
      <url>/2019/08/19/Blog%20Customization/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>从大二开始写博客，主要为了记录自己学习过程中的问题。尝试使用过CSDN、博客园等公共服务，也用Github pages搭建过自己的博客，但效果都不令人满意。CSDN广告太多，界面乌烟瘴气，而且很多博客内容都是抄袭而来；博客园模板比较单一，而且对Markdown的支持不友好；Github pages很自由，但是搭建以及发布文章比较麻烦。<a href="https://eimadrigal.blogspot.com/">blogspot</a>对国内用户很不友好。</p><p>后来在网上浏览别人的博客园时，才发现原来是可以自己定制博客的，遂写此文。</p><h2 id="皮肤">皮肤</h2><p>皮肤也就是博客的背景，博客园提供了一些模板，可以在管理-&gt;设置-&gt;博客皮肤中选择。 如果你对于CSS比较熟悉，那完全可以自己写一个网页的样式，然后勾选禁用模板默认CSS。 <img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825184956989-1010438394.png" alt="img" /> 如果你不熟悉Web开发，可以找一些别人写好的页面定制代码，复制到页面定制CSS代码框中。 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Monokai Sublime style. Derived from Monokai by noformnocontent http://nn.mit-license.org/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">pre &#123;</span><br><span class="line">    <span class="comment">/*控制代码不换行*/</span></span><br><span class="line">    <span class="attribute">white-space</span>: pre;</span><br><span class="line">    <span class="attribute">word-wrap</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cnblogs-markdown</span> <span class="selector-class">.hljs</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1.3em</span> <span class="number">2em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#272822</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFF</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">700px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs</span>,</span><br><span class="line"><span class="selector-class">.hljs-tag</span>,</span><br><span class="line"><span class="selector-class">.hljs-subst</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f8f8f2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-strong</span>,</span><br><span class="line"><span class="selector-class">.hljs-emphasis</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#a8a8a2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-bullet</span>,</span><br><span class="line"><span class="selector-class">.hljs-quote</span>,</span><br><span class="line"><span class="selector-class">.hljs-number</span>,</span><br><span class="line"><span class="selector-class">.hljs-regexp</span>,</span><br><span class="line"><span class="selector-class">.hljs-literal</span>,</span><br><span class="line"><span class="selector-class">.hljs-link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ae81ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-code</span>,</span><br><span class="line"><span class="selector-class">.hljs-title</span>,</span><br><span class="line"><span class="selector-class">.hljs-section</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-class</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#a6e22e</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-strong</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-emphasis</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-keyword</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-tag</span>,</span><br><span class="line"><span class="selector-class">.hljs-name</span>,</span><br><span class="line"><span class="selector-class">.hljs-attr</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f92672</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-symbol</span>,</span><br><span class="line"><span class="selector-class">.hljs-attribute</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#66d9ef</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-params</span>,</span><br><span class="line"><span class="selector-class">.hljs-class</span> <span class="selector-class">.hljs-title</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f8f8f2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-string</span>,</span><br><span class="line"><span class="selector-class">.hljs-type</span>,</span><br><span class="line"><span class="selector-class">.hljs-built_in</span>,</span><br><span class="line"><span class="selector-class">.hljs-builtin-name</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-id</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-attr</span>,</span><br><span class="line"><span class="selector-class">.hljs-selector-pseudo</span>,</span><br><span class="line"><span class="selector-class">.hljs-addition</span>,</span><br><span class="line"><span class="selector-class">.hljs-variable</span>,</span><br><span class="line"><span class="selector-class">.hljs-template-variable</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#e6db74</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hljs-comment</span>,</span><br><span class="line"><span class="selector-class">.hljs-deletion</span>,</span><br><span class="line"><span class="selector-class">.hljs-meta</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#75715e</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 黑色主题makedown代码结束 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*makedown行间代码样式 */</span></span><br><span class="line"><span class="selector-class">.cnblogs-markdown</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#c7254e</span>;</span><br><span class="line">    <span class="attribute">border</span>: none <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f9f2f4</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: sans-serif <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*引言样式*/</span></span><br><span class="line"><span class="selector-tag">blockquote</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">strong</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*博客顶部容器包括标题、副标题、导航栏*/</span></span><br><span class="line"><span class="comment">/* 博客标题和副标题 */</span></span><br><span class="line"><span class="selector-id">#blogTitle</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blogTitle</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blogTitle</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*博客导航栏 */</span></span><br><span class="line"><span class="selector-id">#navList</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#navList</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.blogStats</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*sideBar博客侧边栏容器*/</span></span><br><span class="line"><span class="selector-id">#sideBar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.newsItem</span>, <span class="selector-class">.catListComment</span>, <span class="selector-class">.catListEssay</span>, <span class="selector-class">.catListView</span>, <span class="selector-class">.catListFeedback</span>,</span><br><span class="line"><span class="selector-id">#blog-calendar</span>, <span class="selector-id">#sidebar_postcategory</span>, <span class="selector-id">#sidebar_postcategory</span>, <span class="selector-id">#sidebar_postarchive</span>, <span class="selector-id">#sidebar_search</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">2px</span> <span class="number">3px</span> <span class="number">#A7A8AD</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sideBarMain</span> <span class="selector-tag">h3</span>, <span class="selector-class">.newsItem</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">0.5em</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">http://www.cnblogs.com/skins/red_autumnal_leaves/images/titlebg.png</span>) no-repeat left center <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sideBarMain</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-left-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-bottom-right-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sideBarMain</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*侧边栏公告*/</span></span><br><span class="line"><span class="selector-id">#blog-news</span> &gt; <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="comment">/*头像*/</span></span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#profile_block</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#profile_block</span> &gt; <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#F60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*公告结束*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 日历 */</span></span><br><span class="line"><span class="selector-id">#blog-calendar</span>, <span class="selector-id">#calendar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">td</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#59a020</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">table</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#59a020</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">    <span class="attribute">background</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#blog-calendar</span> <span class="selector-tag">table</span> u &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*日历结束*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置背景色和字体大小*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*mainContent主体内容容器*/</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">95%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#mainContent</span> <span class="selector-class">.forFlow</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">310px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#mainContent</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">310px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#post_detail</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标题title样式 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#topics</span> <span class="selector-class">.postTitle</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cb_post_title_url</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-position</span>: left center;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主体内容样式 */</span></span><br><span class="line"><span class="selector-class">.postBody</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">    <span class="comment">/*标题h2*/</span></span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#d6dbdf</span>8a;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#cnblogs_post_body</span> <span class="selector-tag">h4</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#topics</span> <span class="selector-class">.postDesc</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 个性签名 */</span></span><br><span class="line"><span class="selector-id">#MySignature</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">8px</span> <span class="number">1px</span> <span class="number">10px</span> <span class="number">#989898</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#FFF</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">17px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: solid <span class="number">5px</span> <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#F3F3F3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">50%</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">2.4</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">40px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#MySignature</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#4183c4</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#MySignature</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#MySignature</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关注收藏等几个按钮 */</span></span><br><span class="line"><span class="selector-id">#green_channel</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#green_channel</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>: none;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 禁用下划线 */</span></span><br><span class="line"><span class="selector-class">.postBody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-class">.postBody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>, <span class="selector-class">.postBody</span> <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上一篇下一篇 */</span></span><br><span class="line"><span class="selector-id">#post_next_prev</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#535353</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*底部隐藏作者，隐藏推荐和反对*/</span></span><br><span class="line"><span class="selector-id">#author_profile</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#div_digg</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*隐藏广告*/</span></span><br><span class="line"><span class="selector-id">#ad_t2</span>, <span class="selector-id">#cnblogs_c1</span>, <span class="selector-id">#under_post_news</span>, <span class="selector-id">#cnblogs_c2</span>, <span class="selector-id">#under_post_kb</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*评论*/</span></span><br><span class="line"><span class="comment">/*评论列表*/</span></span><br><span class="line"><span class="selector-id">#blog-comments-placeholder</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.feedback_area_title</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">//www.cnblogs.com/skins/red_autumnal_leaves/images/titlebg.png</span>) no-repeat left center <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#55895B</span>;</span><br><span class="line">    <span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*侧边评论*/</span></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-class">.recent_comment_body</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提交评论按钮 */</span></span><br><span class="line"><span class="selector-id">#btn_comment_submit</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: solid <span class="number">1px</span> <span class="number">#fd6d0d</span>d1 <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fd6d0d</span>d1 <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="标题和导航栏">标题和导航栏</h2><figure><img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825185903232-1879765133.png" alt="" /><figcaption>img</figcaption></figure><p>标题和子标题的修改也在管理-&gt;设置中； 导航栏的控件在管理-&gt;选项中勾选，这里还包含侧边栏的控件，可以根据需要自行选择。 <img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825190124197-141259783.png" alt="img" /></p><h2 id="侧边栏公告">侧边栏公告</h2><figure><img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825190343070-1772796324.png" alt="" /><figcaption>img</figcaption></figure><p>这部分的修改也在管理-&gt;设置中，不过修改前需要发邮件给博客园后台申请JS权限。 这里主要有3点： 一、动态时钟 这个我是copy了<a href="https://www.cnblogs.com/jingmoxukong/p/7826982.html">详谈如何定制自己的博客园皮肤</a>； 二、背景音乐 背景音乐的添加需要进入网易云音乐网页后，找到喜欢的音乐，生成外链播放器，然后复制那段HTML代码到侧边栏公告即可。 <img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825191108110-1169449336.png" alt="img" /> 这里要注意：博客园不支持iframe插件，所以只能采用flash插件！ 三、访客统计 <img src="https://img2018.cnblogs.com/blog/1260581/201908/1260581-20190825191224704-336517055.png" alt="img" /> 这个功能可以去<a href="http://www.flagcounter.com/">flagcounter</a>完成，同样复制HTML代码到侧边栏公告即可。我的博客把这个放到了页脚html代码中，所以可以看到这个在左下角显示。 完整的博客侧边栏公告代码，注意：其中的网易云音乐和访问人数需要自己生成外链！ <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!---  自定义侧边栏  ---&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mySideBar&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p_b_follow&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0);&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;follow(&#x27;ca5022e9-4171-4a38-e168-08d4ef52ecb5&#x27;)&quot;</span>&gt;</span>+Follow Me<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>student@XJTU<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span>Email：andrew_ren@163.com<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--- 动态时钟  ---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">wmode</span>=<span class="string">&quot;transparent&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://files.cnblogs.com/files/jingmoxukong/honehone_clock_tr.swf&quot;</span> <span class="attr">quality</span>=<span class="string">&quot;high&quot;</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#FDF6E3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;240&quot;</span> <span class="attr">height</span>=<span class="string">&quot;110&quot;</span> <span class="attr">name</span>=<span class="string">&quot;honehoneclock&quot;</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">allowscriptaccess</span>=<span class="string">&quot;always&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/x-shockwave-flash&quot;</span> <span class="attr">pluginspage</span>=<span class="string">&quot;http://www.macromedia.com/go/getflashplayer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--- 网易云音乐  ---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;//music.163.com/style/swf/widget.swf?sid=26511658&amp;type=2&amp;auto=1&amp;width=320&amp;height=66&quot;</span> <span class="attr">width</span>=<span class="string">&quot;340&quot;</span> <span class="attr">height</span>=<span class="string">&quot;86&quot;</span>  <span class="attr">allowNetworking</span>=<span class="string">&quot;all&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--- 访问人数  ---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://info.flagcounter.com/myYT&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s01.flagcounter.com/count2/myYT/bg_FFFFFF/txt_000000/border_CCCCCC/columns_2/maxflags_4/viewers_0/labels_1/pageviews_1/flags_0/percent_0/&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Flag Counter&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--- 导入js库  ---&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"> <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;c_n4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;860&quot;</span> <span class="attr">height</span>=<span class="string">&quot;968&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: fixed; top: 0px; left: 0px; z-index: -1; opacity: 0.5;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure> 最后点击保存即可。</p><h2 id="自适应手机屏幕">自适应手机屏幕</h2><p>博客园的模板并没有自适应手机屏幕，可以参考<a href="https://www.cnblogs.com/lvdabao/p/5245247.html">这篇博文</a>修改CSS中的参数，就可以得到自适应移动设备的网页。</p><h2 id="reference">Reference</h2><p>当前使用的是在<a href="https://github.com/Summertime-Wu/make_cnblogs_better">这个</a>基础上做了一些魔改。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Counting Sort and Radix Sort</title>
      <link href="/2019/06/30/Counting%20Sort%20and%20Radix%20Sort/"/>
      <url>/2019/06/30/Counting%20Sort%20and%20Radix%20Sort/</url>
      
        <content type="html"><![CDATA[<h2 id="counting-sort">Counting Sort</h2><p>计数排序适用于数据量很大，但是数据类别很少的情况，可以做到线性时间。 举例来看：如果有100万个字符串，但只有cat, dog, person三种类型，采用基于比较的排序方式，可以做到<span class="math inline">\(NlogN\)</span>，计数排序采用了一种完全不同的思想：</p><ul><li>新建一个<code>counts[3]</code>，记录每种类型数据的出现次数；</li><li>遍历待排序数组，完成<code>count[]</code>的统计，并创建一个结果数组<code>sorted[]</code>： <img src="https://img-blog.csdnimg.cn/20200624082843898.png" alt="在这里插入图片描述" /></li><li>基于<code>count[]</code>，我们完全可以知道第一个cat应该放置在0，第一个dog应该放置在<code>count[0]=4</code>处，第一个person应该放置在<code>count[0]+count[1]=6</code>处，为了更加清晰，创建一个<code>starts[3]</code>表示每类数据中的第一个的起始位置： <img src="https://img-blog.csdnimg.cn/20200624083353219.png" alt="在这里插入图片描述" /></li><li>接着第二次遍历待排序数组，遇到第一个cat，我们知道它应该放在<code>sorted[starts[0]]</code>；第一个dog应该放在<code>sorted[starts[1]]</code>，第二个dog应该放在<code>sorted[starts[1]+1]</code>。或者可以这样做：每当放置完一个dog，就<code>++starts[1]</code>，这样下一次的dog还是会放在<code>sorted[starts[1]]</code>，最终结果： <img src="https://img-blog.csdnimg.cn/20200624084335135.png" alt="在这里插入图片描述" /></li></ul><p>对于字符串排序，我们需要规定<code>counts[]</code>中每个下标对应哪种类型。如果对于非负整数，我们可以用<code>counts[i]</code>表示i的出现次数，接着遍历<code>counts[]</code>，将整数i放置<code>counts[i]</code>次；如果有负数，可以找到最小值min和最大值max，平移到0~max-min即可。</p><h2 id="radix-sort">Radix Sort</h2><p>计数排序的前提就是需要知道待排序数组的内容/范围，那么如果范围很大，空间上是无法忍受的，由此来看更加general的基数排序：如果给定某种基（二进制2/十进制10/小写字母26）下的待排序数据，基数排序会逐位处理。基数排序有两种方式：</p><ol type="1"><li>LSD(Least Significant Digit) 首先按照最右边一位排序，依次处理左边的每一位： 356, 112, 904, 294, 209, 820, 394, 810； 820, 810, 112, 904, 294, 394, 356, 209； 904, 209, 810, 112, 820, 356, 294, 394； 112, 209, 294, 356, 394, 810, 820, 904。 由于对第二位排序不能改变第一位排序的结果，所以要求按位排序算法必须是<strong>稳定</strong>的。</li><li>MSD(Most Significant Digit) 从左到右处理，MSD需要用到桶： [112], [294, 209], [356, 394], [820, 810], [904]； 对于每个桶采用类似的方法直到最后一位，以[294, 209]为例，接着处理第二位：[209], [294]。 最后收集每个桶中的元素即可。 ## Reference <a href="https://github.com/EIMadrigal/CS61B/tree/master/lab13">具体实现</a>不知道LSD哪里实现的有问题，提交AutoGrader总是超时。 <a href="https://sp18.datastructur.es/materials/lab/lab13/lab13">lab 13 Radix Sorts</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Naïve Bayes</title>
      <link href="/2019/06/08/Na%C3%AFve%20Bayes/"/>
      <url>/2019/06/08/Na%C3%AFve%20Bayes/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><h2 id="details">Details</h2><h2 id="example">Example</h2><h2 id="implementation">Implementation</h2><h2 id="properties">Properties</h2><p>NBC有坚实的数学基础，稳定的分类效率，超参数少（先验），对缺失数据不敏感，算法简单。 如果属性较多且相关性比较大，决策树优于NBC，否则NBC性能很好。</p><p>垃圾邮件分类器 事先做一个vocabulary存放常用的单词，如果邮件中包含vocabulary的第j个单词，特征向量中<span class="math inline">\(x_j=1\)</span> 朴素贝叶斯假设给定标签前提下各个属性是独立的（条件独立）： <span class="math inline">\(P(x_1,...,x_d|y)=P(x_1|y)P(x_2|y,x_1)...P(x_d|y,x_1,...,x_{d-1})=P(x_1|y)P(x_2|y)...P(x_d|y)\)</span> <span class="math inline">\(P(x_2|y,x_1)\)</span>表示在<span class="math inline">\((y,x_1)\)</span>的条件下<span class="math inline">\(x_2\)</span>发生的概率 <span class="math inline">\(P(junk|D)=\frac{P(junk)P(D|junk)}{P(D)},P(normal|D)=\frac{P(normal)P(D|normal)}{P(D)}\)</span> P(junk)/P(normal)根据邮件库的比例即可 P(D|junk)=P(word1,word2,...,wordn|junk)，联合概率分布的数据是稀疏的，在垃圾邮件集合中出现与当前邮件相同的邮件概率。 P(word1|junk)P(word2|word1,junk)P(word3|word2,word1,junk)... 如果条件独立假设成立， P(word1|junk)P(word2|junk)P(word3|junk)...只要统计垃圾邮件中每个单词的频率</p><p>拼写纠正 max P(猜测用户希望输入的单词|实际输入单词) <span class="math inline">\(P(h_1|D),P(h_2|D)\)</span> <span class="math inline">\(P(h|D)\propto P(h)P(D|h)\)</span> 对给定的观测数据，一个猜测的好坏正比于先验和这个猜测生成观测数据的可能性大小（似然）</p><p>假设实际输入D=thew,h1=the,h2=thaw <span class="math inline">\(P(h_1|D)=\)</span>the本身在词典中的出现概率及输入the前提下输thew的可能</p><p>ID3（Iterative Dichotomiser 3）迭代二叉树3代，启发式算法 以信息增益做属性选择，选择分裂后信息增益最大的属性进行分裂</p><ol type="1"><li>top-down贪心遍历可能的决策树空间</li><li>核心问题在于如何选择划分属性</li><li>按照信息增益选择分类能力最好的属性</li><li>属性的每个值产生一个分支，将训练数据放在合适的分支，不回溯考虑之前的选择</li></ol><p>都知道熵用来衡量随机变量的不确定性，在这里就是刻画数据集的不纯度 条件熵是指在某个条件下，随机变量的不确定性 信息增益即熵-条件熵，即某条件下信息不确定性减少的程度 举例来看：明天下雨的熵为2，阴天条件下下雨的熵是0.01（即阴天下雨的可能性很大，所以不确定性很小），信息增益=2-0.01=1.99，获知阴天后，下雨的不确定性减少了很多，信息增益很大，所以阴天对下雨这一推断很重要，意味着这个特征很关键。</p><p>IG衡量给定属性区分训练样例的能力 <span class="math inline">\(Entropy(S)=\sum_{i=1}^{c}-p_ilog_2p_i\)</span>，c表示该属性有c个取值，Pi表示子集中样例占总数的比例。介于[0,1]之间，所有样例属于1类，最纯，熵为0；平分熵最大为1</p><p>一个属性的IG意味着用该属性分割样例导致的熵减的期望， <span class="math inline">\(IG(S,A)=E(S)-\sum_{i=1}^{c}\frac{|S_i|}{|S|}E(S_i)\)</span></p><p>C4.5用信息增益率作为属性选择的依据，构造过程中会进行剪枝（不考虑只有几个元素的结点，避免过拟合） 率即用相对性衡量（10经过10s到20，1经过1s到2，虽然前者的增益大，但如果用速度增加率即加速度衡量是一样的）</p><p>可以处理非离散数据和不完整数据</p><p>当前数据集S，当前属性A有c个取值，S需要被分割为c个子集 <span class="math inline">\(GainRatio(S,A)=\frac{IG(S,A)}{SplitInfo(S,A)}\)</span> <span class="math inline">\(SplitInfo(S,A)=-\sum_{i=1}^{c}\frac{|S_i|}{|S|}log_2\frac{|S_i|}{|S|}\)</span> 如果A能完全分割，那么splitinfo=0；如果对半分，那么=1，即splitinfo阻碍选择值均匀分布的属性 如果splitinfo=0，可以先计算每个属性的信息增益，选择增益&gt;平均值的属性再去应用增益比率，因为如果splitinfo=0，即A能完全分割，意味着信息增益=0，不可能&gt;平均值</p><p>实际中决策树的过拟合是比较严重的，C4.5克服了ID3用IG选择属性时倾向选择取值多的属性的不足。</p><p>马尔可夫随机过程： s1：名词 s2：动词 s3：形容词 转移矩阵A=0.3 0.5 0.2;0.5 0.3 0.2;0.4 0.2 0.4即A11表示s1后面跟着s1的概率</p><p>若某段话第一个词为名词s1，那么该句子是“名动形名”的概率是多少？ <span class="math inline">\(P(s1,s2,s3,s1|model)=P(s1)P(s2|s1)P(s3|s2)P(s1|s3)=1*A12*A23*A31=0.004\)</span>？？？ 马尔科夫链：转移弧上有概率的非确定有限状态自动机，圈代表状态，每个结点的出度加起来是1 隐马尔可夫模型HMM：状态转换是不可观察的</p><p>EM（expectation maximization） 假设数据点是围绕k个核心点的k个正态分布源产生，目标是根据已知点推断正态分布的核心及参数，这也是一个贝叶斯问题</p><p>矛盾之处在于：蛋与鸡的问题 只有已知哪些点属于同一个圈，才能预测参数 只有参数靠谱，才能知道哪些点属于哪个圈</p><p>解这种问题，一般要先随机给蛋或鸡，随便猜一个参数，计算每个点属于哪个圈，接着重新评估参数，直至最后参数基本不变，有点kmeans那味。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/07/#Week7%20Neural%20Networks%20Learning/"/>
      <url>/2019/06/07/#Week7%20Neural%20Networks%20Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="一cost-function-and-backpropagation">一、Cost Function and Backpropagation</h2><p>神经网络的损失函数： <span class="math display">\[J(\Theta) = - \frac{1}{m} \sum_{i=1}^m \sum_{k=1}^K \left[y^{(i)}_k \log ((h_\Theta (x^{(i)}))_k) + (1 - y^{(i)}_k)\log (1 - (h_\Theta(x^{(i)}))_k)\right] + \frac{\lambda}{2m}\sum_{l=1}^{L-1} \sum_{i=1}^{s_l} \sum_{j=1}^{s_{l+1}} ( \Theta_{j,i}^{(l)})^2\]</span> <img src="https://img-blog.csdnimg.cn/20190520213954195.png" alt="在这里插入图片描述" /> 这个cost function是在logistic regression基础上演变而来，只是神经网络有很多输出结点，而logistic regression只有一个输出结点，所以这个cost function只是把所有的K个输出结点的损失函数进行累加。</p><p>得到cost function后，为了寻找使得<span class="math inline">\(J(\theta)\)</span>最小的那组参数<span class="math inline">\(\theta\)</span>，我们需要知道<span class="math inline">\(J(\theta)\)</span>关于每个<span class="math inline">\(\theta\)</span>的偏导数，而后向传播算法可以帮助我们计算偏导数： <img src="https://img-blog.csdnimg.cn/20190520215248992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 对于每个训练样本，先利用forward propagation计算每一层的<span class="math inline">\(a\)</span>： <img src="https://img-blog.csdnimg.cn/20190520215514406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 接着利用样本真实标签<span class="math inline">\(y^{(t)}\)</span>计算最后一层的误差值；</p><p>之后从右向左计算每一层（输入层除外）的误差： <img src="https://img-blog.csdnimg.cn/20190520215848578.png" alt="在这里插入图片描述" /> 这样每个样本一次正向、一次反向来更新误差矩阵： <img src="https://img-blog.csdnimg.cn/20190520220141936.png" alt="在这里插入图片描述" /> 向量化表示： <img src="https://img-blog.csdnimg.cn/2019052022020666.png" alt="在这里插入图片描述" /> 最后，就可以得到偏导数： <img src="https://img-blog.csdnimg.cn/20190520220255255.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20190520220307411.png" alt="在这里插入图片描述" /> ## 二、Backpropagation in Pratice 为了使用<code>fminunc</code>等高级的优化方法来求得cost function的最小值，所以将<span class="math inline">\(\theta\)</span>这个矩阵展成向量传入<code>fminunc</code>，完成后可以通过<code>reshape</code>从向量中提取<span class="math inline">\(\theta^{(1)}、\theta^{(2)}\)</span>等： <img src="https://img-blog.csdnimg.cn/20190521193802355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><p>为了确保我们使用Backpropagation求得的偏导数的正确性，可以使用Gradient Checking（<strong>很慢</strong>）来检验： 根据偏导数定义： <span class="math display">\[\dfrac{\partial}{\partial\Theta_j}J(\Theta) \approx \dfrac{J(\Theta_1, \dots, \Theta_j + \epsilon, \dots, \Theta_n) - J(\Theta_1, \dots, \Theta_j - \epsilon, \dots, \Theta_n)}{2\epsilon}\]</span> <span class="math display">\[一般\epsilon=10^{-4}\]</span> 通过将这种方式计算的偏导数与之前Backpropagation求得的偏导数比较，即可得知Backpropagation的正确性。</p><p>之前在Linear Regression和Logistic Regression，我们可以用全0来初始化<span class="math inline">\(\theta\)</span>，但在神经网络中，这样做会有问题，所以采用<strong>随机初始化</strong>： <img src="https://img-blog.csdnimg.cn/20190521195045220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 最后，从整体捋一遍流程： 1、选择网络结构： <img src="https://img-blog.csdnimg.cn/20190521195351245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 2、训练神经网络：</p><p>对每一个训练样本： <img src="https://img-blog.csdnimg.cn/20190521195432613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Multilayer Perceptron</title>
      <link href="/2019/06/06/Multilayer%20Perceptron/"/>
      <url>/2019/06/06/Multilayer%20Perceptron/</url>
      
        <content type="html"><![CDATA[<h2 id="non-linear-hypotheses">Non-linear Hypotheses</h2><p>线性回归和逻辑回归在特征很多时，计算量会很大。 一个简单的三层神经网络模型： <span class="math display">\[a_i^{(j)} = \text{&quot;activation&quot; of unit $i$ in layer $j$}\]</span><span class="math display">\[\Theta^{(j)} = \text{matrix of weights controlling function mapping from layer $j$ to layer $j+1$}\]</span> <img src="https://img-blog.csdnimg.cn/20190519144739691.png" alt="在这里插入图片描述" /> 其中：<span class="math display">\[a_1^{(2)} = g(\Theta_{10}^{(1)}x_0 + \Theta_{11}^{(1)}x_1 + \Theta_{12}^{(1)}x_2 + \Theta_{13}^{(1)}x_3)\]</span><span class="math display">\[a_2^{(2)} = g(\Theta_{20}^{(1)}x_0 + \Theta_{21}^{(1)}x_1 + \Theta_{22}^{(1)}x_2 + \Theta_{23}^{(1)}x_3)\]</span><span class="math display">\[a_3^{(2)} = g(\Theta_{30}^{(1)}x_0 + \Theta_{31}^{(1)}x_1 + \Theta_{32}^{(1)}x_2 + \Theta_{33}^{(1)}x_3)\]</span><span class="math display">\[h_\Theta(x) = a_1^{(3)} = g(\Theta_{10}^{(2)}a_0^{(2)} + \Theta_{11}^{(2)}a_1^{(2)} + \Theta_{12}^{(2)}a_2^{(2)} + \Theta_{13}^{(2)}a_3^{(2)})\]</span> ## vectorized implementation 将上面公式中函数<span class="math inline">\(g\)</span>中的东西用<span class="math inline">\(z\)</span>代替： <span class="math display">\[a_1^{(2)} = g(z_1^{(2)})\]</span><span class="math display">\[a_2^{(2)} = g(z_2^{(2)})\]</span><span class="math display">\[a_3^{(2)} = g(z_3^{(2)})\]</span> 令<span class="math inline">\(x=a^{(1)}\)</span>： <span class="math display">\[z^{(j)} = \Theta^{(j-1)}a^{(j-1)}\]</span> 得到： <span class="math display">\[\begin{aligned}z^{(j)} = \begin{bmatrix}z_1^{(j)} \\ z_2^{(j)} \\ \cdots \\z_n^{(j)}\end{bmatrix}\end{aligned}\]</span></p><p>这块的记号比较多，用例子梳理下： 实现一个逻辑与的神经网络： <img src="https://img-blog.csdnimg.cn/20190321105245428.png" alt="在这里插入图片描述" /> 那么： <img src="https://img-blog.csdnimg.cn/20190321105438230.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20190321105453184.png" alt="在这里插入图片描述" /> 所以有： <img src="https://img-blog.csdnimg.cn/20190321105628787.png" alt="在这里插入图片描述" /> 再来一个多层的，实现XNOR功能（两输入都为0或都为1，输出才为1）： <img src="https://img-blog.csdnimg.cn/20190321110644318.png" alt="在这里插入图片描述" /> 基本的神经元：</p><ul><li>逻辑与 <img src="https://img-blog.csdnimg.cn/2019032111133091.png" alt="在这里插入图片描述" /></li><li>逻辑或 <img src="https://img-blog.csdnimg.cn/20190321111355954.png" alt="在这里插入图片描述" /></li><li>逻辑非 <img src="https://img-blog.csdnimg.cn/20190321111411429.png" alt="在这里插入图片描述" /> 先构造一个表示后半部分的神经元：<img src="https://img-blog.csdnimg.cn/20190321111519333.png" alt="在这里插入图片描述" /> 这样的： <img src="https://img-blog.csdnimg.cn/20190321111806888.png" alt="在这里插入图片描述" /> 接着将前半部分组合起来： <img src="https://img-blog.csdnimg.cn/20190321112023420.png" alt="在这里插入图片描述" /> ## Multiclass Classification <img src="https://img-blog.csdnimg.cn/20190321165848893.png" alt="在这里插入图片描述" /> ## Motivation ## Implementation</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> FashionMNIST</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>():</span></span><br><span class="line">    <span class="comment"># My data is in ../data/FashionMNIST/raw &amp; ../data/FashionMNIST/processed</span></span><br><span class="line">    train_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    test_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    train_iter = DataLoader(train_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    test_iter = DataLoader(test_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> train_iter, test_iter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">W1 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (num_inputs, num_hiddens)), dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">b1 = torch.zeros(num_hiddens, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">W2 = torch.tensor(np.random.normal(<span class="number">0</span>, <span class="number">0.01</span>, (num_hiddens, num_outputs)), dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">b2 = torch.zeros(num_outputs, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># W1 = nn.Parameter(torch.randn(num_inputs, num_hiddens, requires_grad=True) * 0.01)</span></span><br><span class="line"><span class="comment"># b1 = nn.Parameter(torch.zeros(num_hiddens, requires_grad=True))</span></span><br><span class="line"><span class="comment"># W2 = nn.Parameter(torch.randn(num_hiddens, num_outputs, requires_grad=True) * 0.01)</span></span><br><span class="line"><span class="comment"># b2 = nn.Parameter(torch.zeros(num_outputs, requires_grad=True))</span></span><br><span class="line">params = [W1, b1, W2, b2]</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">    param.requires_grad_(requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span>(<span class="params">X</span>):</span></span><br><span class="line">    <span class="keyword">return</span> torch.<span class="built_in">max</span>(<span class="built_in">input</span>=X, other=torch.zeros(X.shape))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">X</span>):</span></span><br><span class="line">    X_exp = torch.exp(X)</span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_exp / partition</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">net</span>(<span class="params">X</span>):</span></span><br><span class="line">    X = X.reshape((-<span class="number">1</span>, num_inputs))</span><br><span class="line">    H = relu(torch.matmul(X, W1) + b1)</span><br><span class="line">    output = torch.matmul(H, W2) + b2</span><br><span class="line">    <span class="keyword">return</span> softmax(output)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_entropy</span>(<span class="params">y_predict, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> -torch.log(y_predict[<span class="built_in">range</span>(<span class="built_in">len</span>(y_predict)), y])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sgd</span>(<span class="params">params, lr, batch_size</span>):</span></span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param.data -= lr * param.grad / batch_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy</span>(<span class="params">net, data_iter</span>):</span></span><br><span class="line">    acc_sum, n = <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        acc_sum += (net(X).argmax(dim=<span class="number">1</span>) == y).<span class="built_in">float</span>().<span class="built_in">sum</span>().item()</span><br><span class="line">        n += y.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> acc_sum / n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, batch_size=<span class="number">256</span>, lr=<span class="number">0.1</span>, params=<span class="literal">None</span>, optimizer=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_loss_sum, train_acc_sum, n = <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            y_predict = net(X)</span><br><span class="line">            l = cross_entropy(y_predict, y).<span class="built_in">sum</span>()</span><br><span class="line">            l.backward()</span><br><span class="line">            sgd(params, lr, batch_size)</span><br><span class="line"></span><br><span class="line">            W1.grad.data.zero_()</span><br><span class="line">            b1.grad.data.zero_()</span><br><span class="line">            W2.grad.data.zero_()</span><br><span class="line">            b2.grad.data.zero_()</span><br><span class="line"></span><br><span class="line">            train_loss_sum += l.item()</span><br><span class="line">            train_acc_sum += (y_predict.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().item()</span><br><span class="line">            n += y.shape[<span class="number">0</span>]</span><br><span class="line">        test_acc = evaluate_accuracy(net, test_iter)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch %d, loss %.4f, train_acc %.4f, test_acc %.4f&#x27;</span></span><br><span class="line">              % (epoch + <span class="number">1</span>, train_loss_sum / n, train_acc_sum / n, test_acc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span></span><br><span class="line">    train_iter, test_iter = load_data()</span><br><span class="line">    train(net, train_iter, test_iter, cross_entropy, <span class="number">10</span>, lr=<span class="number">0.1</span>, params=params)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.init <span class="keyword">as</span> init</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> FashionMNIST</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>():</span></span><br><span class="line">    <span class="comment"># My data is in ../data/FashionMNIST/raw &amp; ../data/FashionMNIST/processed</span></span><br><span class="line">    train_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    test_data = FashionMNIST(root=<span class="string">&#x27;../data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">False</span>, transform=transforms.ToTensor())</span><br><span class="line">    train_iter = DataLoader(train_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    test_iter = DataLoader(test_data, batch_size=<span class="number">256</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> train_iter, test_iter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_inputs, num_outputs, num_hiddens</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.l1 = nn.Linear(num_inputs, num_hiddens)</span><br><span class="line">        self.relu1 = nn.ReLU()</span><br><span class="line">        self.l2 = nn.Linear(num_hiddens, num_outputs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        X = X.view(X.shape[<span class="number">0</span>], -<span class="number">1</span>)</span><br><span class="line">        o1 = self.relu1(self.l1(X))</span><br><span class="line">        o2 = self.l2(o1)</span><br><span class="line">        <span class="keyword">return</span> o2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_params</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> self.parameters():</span><br><span class="line">            init.normal_(param, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_accuracy</span>(<span class="params">net, data_iter</span>):</span></span><br><span class="line">    acc_sum, n = <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        acc_sum += (net(X).argmax(dim=<span class="number">1</span>) == y).<span class="built_in">float</span>().<span class="built_in">sum</span>().item()</span><br><span class="line">        n += y.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> acc_sum / n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, batch_size=<span class="number">256</span>, lr=<span class="number">0.1</span>, params=<span class="literal">None</span>, optimizer=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_loss_sum, train_acc_sum, n = <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            y_predict = net(X)</span><br><span class="line">            l = loss(y_predict, y).<span class="built_in">sum</span>()</span><br><span class="line">            l.backward()</span><br><span class="line"></span><br><span class="line">            optimizer.step()</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">            train_loss_sum += l.item()</span><br><span class="line">            train_acc_sum += (y_predict.argmax(dim=<span class="number">1</span>) == y).<span class="built_in">sum</span>().item()</span><br><span class="line">            n += y.shape[<span class="number">0</span>]</span><br><span class="line">        test_acc = evaluate_accuracy(net, test_iter)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch %d, loss %.4f, train_acc %.4f, test_acc %.4f&#x27;</span></span><br><span class="line">              % (epoch + <span class="number">1</span>, train_loss_sum / n, train_acc_sum / n, test_acc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line">net = Net(num_inputs, num_outputs, num_hiddens)</span><br><span class="line">net.init_params()</span><br><span class="line"></span><br><span class="line">loss = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    train_iter, test_iter = load_data()</span><br><span class="line">    train(net, train_iter, test_iter, loss, <span class="number">10</span>, optimizer=optimizer)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Advice for applying ML &amp; ML System Design</title>
      <link href="/2019/06/05/Advice%20for%20applying%20ML%20&amp;%20ML%20System%20Design/"/>
      <url>/2019/06/05/Advice%20for%20applying%20ML%20&amp;%20ML%20System%20Design/</url>
      
        <content type="html"><![CDATA[<h2 id="一the-problem-of-overfitting">一、The Problem of Overfitting</h2><p><img src="https://img-blog.csdnimg.cn/20190320163616569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20190320164216967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 欠拟合（high bias）：模型不能很好地适应训练集； 过拟合（high variance）：模型过于强调拟合原始数据，测试时效果会比较差。 处理过拟合： 1、丢弃一些特征，包括人工丢弃和算法选择； 2、正则化：保留所有特征，但减小参数的值。 ## 二、Cost Function 过拟合一般是由高次项引起，那么我们可以通过增加某些项的cost，来降低它们的权重。 在梯度下降过程中，要使损失函数变小，那么<span class="math inline">\(\theta\)</span>就会变得很小，所以假设函数中的<span class="math inline">\(\theta\)</span>就会变小，该项的权重就会降低。</p><p>如果不知道要惩罚哪些特征，可以一起惩罚（除了<span class="math inline">\(\theta_0\)</span>）。 将代价函数改为： <img src="https://img-blog.csdnimg.cn/20190320165635129.png" alt="在这里插入图片描述" /> <span class="math inline">\(\lambda\)</span>是正则化参数。 如果<span class="math inline">\(\lambda\)</span>过大，那么所有的参数都会最小化，那么假设就会变为<span class="math inline">\(h_\theta(x)=\theta_0\)</span>，造成欠拟合。 ## 三、Regularized Linear Regression <span class="math inline">\(\theta_0\)</span>没有正则化处理，所以梯度下降要分情况： <img src="https://img-blog.csdnimg.cn/20190320170642494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 化简下： <img src="https://img-blog.csdnimg.cn/20190320170825316.png" alt="在这里插入图片描述" /> 可以看到： 正则化后的参数更新比原来多减小了一个值。</p><p>再看线性回归的另外一个工具：常规方程。 <img src="https://img-blog.csdnimg.cn/20190320171502423.png" alt="在这里插入图片描述" /> 推导过程省略...... ## 四、Regularized Logistic Regression 对于逻辑回归的代价函数，同样增加一个正则化表达式： <img src="https://img-blog.csdnimg.cn/2019032019010815.png" alt="在这里插入图片描述" /> 梯度下降算法与线性回归相同，不过<span class="math inline">\(h_\theta(x)\)</span>不同。 <img src="https://img-blog.csdnimg.cn/20190320190430424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><h2 id="一evaluating-a-learning-algorithm">一、Evaluating a Learning Algorithm</h2><p>训练后测试时如果发现模型表现很差，可以有很多种方法去更改：</p><ol type="1"><li>用更多的训练样本；</li><li>减少/增加特征数目；</li><li>尝试多项式特征；</li><li>增大/减小正则化参数<span class="math inline">\(\lambda\)</span>。 那么该怎么去选择采用哪种方式呢？ 一般将70%的数据作为训练集，30%的数据作为测试集。 先用训练集最小化<span class="math inline">\(J_{train}(\Theta)\)</span>，得到一组参数值<span class="math inline">\(\Theta\)</span>； 然后计算测试集误差<span class="math inline">\(J_{test}(\Theta)\)</span>： 对于<strong>线性回归</strong>： <img src="https://img-blog.csdnimg.cn/20190603210422113.png" alt="在这里插入图片描述" /> 对于<strong>逻辑回归</strong>： <img src="https://img-blog.csdnimg.cn/20190603210631921.png" alt="在这里插入图片描述" /> 测试集的平均误差（分类错误的比率）： <img src="https://img-blog.csdnimg.cn/20190603210807680.png" alt="在这里插入图片描述" /> 假设要选择用几次多项式<span class="math inline">\(d\)</span>去作为假设函数，那么做法就是不断尝试<span class="math inline">\(d\)</span>，选择一个在测试集上损失最小的<span class="math inline">\(d\)</span>，以此作为模型泛化能力的衡量。但是这样是有问题的，因为<span class="math inline">\(d\)</span>相当于是被测试集训练的，再用测试集去测试，很不公平。所以一般将数据集分为3部分：60%训练集、20%交叉验证集、20%测试集： <img src="https://img-blog.csdnimg.cn/20190605102227988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ## 二、Bias vs. Variance 看图： <img src="https://img-blog.csdnimg.cn/20190719151251691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="图来自知乎" /> <img src="https://img-blog.csdnimg.cn/20190605102435642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 正则化和Bias/Variance的关系： <img src="https://img-blog.csdnimg.cn/20190605102608526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 训练集大小与Bias/Variance的关系： <img src="https://img-blog.csdnimg.cn/20190605102730371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20190605102745765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ## 三、Error Analysis Andrew推荐的流程： <img src="https://img-blog.csdnimg.cn/20190605103603490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ## 四、Handling Skewed Data 如果数据集中正负类的数据规模差距过大，只用误差衡量模型是不可靠的，此时需要查准率和召回率两个指标。 <img src="https://img-blog.csdnimg.cn/20190605104947575.png" alt="在这里插入图片描述" /> 如何权衡这两个指标，一般使用<span class="math inline">\(F1\)</span>得分： <span class="math display">\[F_1=2\frac{PR}{P+R}\]</span></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Logistic Regression</title>
      <link href="/2019/06/04/Logistic%20Regression/"/>
      <url>/2019/06/04/Logistic%20Regression/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>If y only takes a finite set of discrete values such as {0,1}, then using Linear Regression to predict a <span class="math inline">\(\hat y&gt;1/\hat y&lt;0\)</span> does not make sense at all. But fortunately we can fix Linear Regression to produce a value between [0,1]. ## Details We choose sigmoid/logistic function to map the value: <span class="math display">\[h_\theta(x)=g(\theta^Tx),g(z)=\frac{1}{1+e^{-z}}\]</span> <img src="https://img-blog.csdnimg.cn/20190516212200143.png" alt="在这里插入图片描述" /> We can assume that: <span class="math display">\[h_\theta(x)=P(y=1|x;\theta)\\1-h_\theta(x)=P(y=0|x;\theta)\]</span> Or more compactly: <span class="math display">\[p(y|x;\theta)=[h_\theta(x)]^y[1-h_\theta(x)]^{1-y}\]</span> Now we will use maximum likelihood to fit parameters <span class="math inline">\(\theta\)</span>, assume n training examples are independent, then the likelihood of the parameters is: <span class="math display">\[L(\theta)=p(\vec y|X;\theta)=\prod_{i=1}^{n}p(y^{(i)}|x^{(i)};\theta)=\prod_{i=1}^{n}[h(x^{(i)})]^{y^{(i)}}[1-h(x^{(i)})]^{1-y^{(i)}}\]</span> To make life easier, we use the log likelihood: <span class="math display">\[l(\theta)=log\ L(\theta)=\sum_{i=1}^{n}y^{(i)}log\ h(x^{(i)})+(1-y^{(i)})log\ (1-h(x^{(i)}))\]</span> Let's first take out one example <span class="math inline">\((x,y)\)</span> to derive the stochastic gradient ascent rule: <span class="math display">\[\frac{\partial}{\partial\theta_j}l(\theta)=[y\frac{1}{g(\theta^Tx)}-(1-y)\frac{1}{1-g(\theta^Tx)}]\frac{\partial}{\partial\theta_j}g(\theta^Tx) \\=[y\frac{1}{g(\theta^Tx)}-(1-y)\frac{1}{1-g(\theta^Tx)}]g(\theta^Tx)(1-g(\theta^Tx))\frac{\partial}{\partial\theta_j}\theta^Tx \\=[y(1-g(\theta^Tx))-(1-y)g(\theta^Tx)]x_j=(y-h_\theta(x))x_j\]</span> Then we can update the parameters: <span class="math display">\[\theta_j=\theta_j+\alpha(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}\]</span></p><p>Here we use maximum likelihood to get the update rule. Generally we would like to minimize the object function. So we can add a negative sign to the maximum likelihood's formula, it is called <strong>logistic loss</strong>. Thus there exists another way to understand it.</p><p>The loss on a single sample can be formulated as follows: <span class="math display">\[cost(h_{\theta}(x),y)=\left\{\begin{aligned}-log(h_{\theta}(x))\ \ \ if\ y=1\\-log(1-h_{\theta}(x))\ \ \ if\ y=0\end{aligned}\right.\]</span> If y=1 and the prediction=1, then loss=0; else if y=1 and the prediction=0, then loss=<span class="math inline">\(+\infin\)</span> is a huge penalty for the totally wrong prediction. It is the same for y=0.</p><p>We can unify the two cases together and the loss for the whole training data is: <span class="math display">\[cost((h_{\theta}(x),y))=-ylog(h_{\theta}(x))-(1-y)log(1-h_{\theta}(x))\\=-\frac{1}{m}\sum_{i=1}^{m}[y^{(i)}log(h_{\theta}(x^{(i)}))+(1-y^{(i)})log(1-h_{\theta}(x^{(i)}))]\]</span> Here the reason why we don't use the MSE loss such as Linear Regression is that the <span class="math inline">\(J(\theta)\)</span> is non-convex and very hard to optimize for the global optimum.</p><p>To make life easier again, we can write the formula as the vectorized version: <span class="math display">\[h = g(X\theta),J(\theta) = \frac{1}{m} \cdot \left(-y^{T}\log(h)-(1-y)^{T}\log(1-h)\right)\]</span> Then our goal is to minimize <span class="math inline">\(J(\theta)\)</span> and get appropriate parameters <span class="math inline">\(\theta\)</span> and use <span class="math inline">\(h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}\)</span> to get our predictions.</p><p>Since it is a little complex to get answer analytically, so we still use Gradient Descent to minimize the loss numerically. The update rule is the same as the above one: <span class="math display">\[\theta_j=\theta_j+\alpha\frac{1}{m}\sum_{i=1}^{m}(y^{(i)}-h_{\theta}(x^{(i)}))x_j^{(i)}\]</span> Here you should notice that all <span class="math inline">\(\theta_j\)</span> should be updated simultaneously when you program. Again the vectorized version: <span class="math display">\[\theta=\theta-\frac{\alpha}{m}X^T[g(X\theta)-y]\]</span> It is the same formula as the Linear Regression except that <span class="math inline">\(h_\theta(x)\)</span> is different. ## 牛顿法 除了用梯度上升法去最大化<span class="math inline">\(l(\theta)\)</span>，牛顿迭代法也能干这件事。</p><p>普通同学都是在求方程的零点<span class="math inline">\(f(\theta)=0\)</span>时接触到牛顿法，其更新规则为： <span class="math display">\[\theta=\theta-\frac{f(\theta)}{f^{&#39;}(\theta)}\]</span> 这个规则可以理解为：我们一直在用一个线性函数去近似<span class="math inline">\(f\)</span>，因此希望下一次迭代的<span class="math inline">\(\theta\)</span>就是该线性函数的零点： <img src="https://img-blog.csdnimg.cn/20210616190823439.png" alt="在这里插入图片描述" /> 再结合一点高中数学，<span class="math inline">\(l(\theta)\)</span>极大值点处的一阶导数为0，因此只要令<span class="math inline">\(l^{&#39;}(\theta)=0\)</span>就能解出对应的<span class="math inline">\(\theta\)</span>： <span class="math display">\[\theta=\theta-\frac{l^{&#39;}(\theta)}{l^{&#39;&#39;}(\theta)}\]</span> 由于逻辑回归中<span class="math inline">\(\theta\)</span>是向量而非scalar，因此需要稍稍改变下更新规则： <span class="math display">\[\theta=\theta-H^{-1}\nabla_{\theta}l(\theta)\]</span> 其中，Hessian阵中的元素为<span class="math inline">\(H_{ij}=\frac{\partial^2l(\theta)}{\partial\theta_i\partial\theta_j}\)</span>。</p><p>牛顿法通常比梯度上升收敛快得多，因为利用了<span class="math inline">\(l(\theta)\)</span>的二阶信息，但是存储和求解<span class="math inline">\(H^{-1}\)</span>开销会比较大。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linear Regression</title>
      <link href="/2019/06/03/Linear%20Regression/"/>
      <url>/2019/06/03/Linear%20Regression/</url>
      
        <content type="html"><![CDATA[<h2 id="线性回归模型">线性回归模型</h2><p><span class="math display">\[h_{\theta}(x)=\sum_{i=0}^{d}\theta_ix_i=\theta^Tx=x^T\theta\]</span> 其中，<span class="math inline">\(x_0=1\)</span>，<span class="math inline">\(d\)</span>表示<span class="math inline">\(x\)</span>的特征数量。</p><p>在给定训练集下，需要用学习算法确定参数<span class="math inline">\(\theta\)</span>，使得模型的预测值<span class="math inline">\(h(x)\)</span>与真实值<span class="math inline">\(y\)</span>尽可能接近。为了精确地描述这种接近程度，定义损失函数： <span class="math display">\[J(\theta)=\frac{1}{2}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2\]</span> 问题转化为选择一组<span class="math inline">\(\theta\)</span>使得<span class="math inline">\(J(\theta)\)</span>最小，这里有2种求解方法：</p><ol type="1"><li>梯度下降</li><li>Normal Equation ## 梯度下降 梯度下降的motivation非常直观，首先随机选择一组参数<span class="math inline">\(\theta\)</span>，接着沿<span class="math inline">\(J(\theta)\)</span>下降最快的方向更新<span class="math inline">\(\theta\)</span>，经过若干次迭代就有望找到令<span class="math inline">\(J(\theta)\)</span>收敛的参数<span class="math inline">\(\theta\)</span>： <span class="math display">\[\theta_j=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta)\]</span> 将<span class="math inline">\(J(\theta)\)</span>的偏导数代入即得到所谓的batch gradient descent更新规则： <span class="math display">\[\theta_j=\theta_j-\alpha\sum_{i=1}^{n}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}\]</span> 其向量化表示为： <span class="math display">\[\theta=\theta-\alpha\sum_{i=1}^{n}(h_\theta(x^{(i)})-y^{(i)})x^{(i)}\]</span> 由于损失函数<span class="math inline">\(J(\theta)\)</span>是凸二次函数，因此总能收敛到唯一的全局最小值。</li></ol><p>batch gradient descent一次更新需要计算所有训练样本，开销较大，因此有同学提出了stochastic gradient descent，每遇到一个训练样本就进行一次参数更新： <span class="math display">\[\theta=\theta-\alpha(h_\theta(x^{(i)})-y^{(i)})x^{(i)}\]</span> stochastic gradient descent一般比batch gradient descent收敛快，但是有可能在<span class="math inline">\(J(\theta)\)</span>的最优点附近振荡，永远无法收敛到精确最优。不过一般选择最优点附近的参数也可以接受，还可以通过递减学习率<span class="math inline">\(\alpha\)</span>确保其精确收敛。</p><p>值得一提的是：梯度下降算法存在“锯齿”效应，因此为了加速收敛，通常要进行归一化处理使得不同特征的尺度相近。 ## Normal Equation 除了用迭代的方式求解<span class="math inline">\(J(\theta)\)</span>的最小值，还可以用数学工具直接求得闭式解。</p><p>为了简洁地表示后续求导，使得人生不要太过凌乱，我们首先研究下<span class="math inline">\(J(\theta)\)</span>的向量表示： 假设训练集<span class="math inline">\(X\)</span>和对应的标签<span class="math inline">\(y\)</span>分别为： <span class="math display">\[X=\left[\begin{matrix} (x^{(1)})^T \\ (x^{(2)})^T \\ \vdots \\ (x^{(n)})^T \\\end{matrix}\right],y=\left[\begin{matrix} y^{(1)} \\ y^{(2)} \\ \vdots \\ y^{(n)} \\\end{matrix}\right]\]</span> 由于<span class="math inline">\(h_{\theta}(x^{(i)})=(x^{(i)})^T\theta\)</span>，所以有： <span class="math display">\[X\theta-y=\left[\begin{matrix} (x^{(1)})^T\theta \\ (x^{(2)})^T\theta \\ \vdots \\ (x^{(n)})^T\theta \\\end{matrix}\right]-\left[\begin{matrix} y^{(1)} \\ y^{(2)} \\ \vdots \\ y^{(n)} \\\end{matrix}\right]=\left[\begin{matrix} h_{\theta}(x^{(1)})-y^{(1)}  \\ h_{\theta}(x^{(2)})-y^{(2)} \\ \vdots \\ h_{\theta}(x^{(n)})-y^{(n)} \\\end{matrix}\right]\]</span> 根据向量运算法则<span class="math inline">\(x^Tx=\sum_ix_i^2\)</span>，终于得到了<span class="math inline">\(J(\theta)\)</span>的简单点的表示： <span class="math display">\[\frac{1}{2}(X\theta-y)^T(X\theta-y)=\frac{1}{2}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2=J(\theta)\]</span> 利用高中数学导数的知识，只要求得<span class="math inline">\(J(\theta)\)</span>关于参数<span class="math inline">\(\theta\)</span>的导数并令其为0，就大功告成了： <span class="math display">\[\nabla_{\theta}J(\theta)=\frac{1}{2}(X\theta-y)^T(X\theta-y)\\=\frac{1}{2}\nabla_{\theta}[(X\theta)^TX\theta-(X\theta)^Ty-y^T(X\theta)+y^Ty]=\frac{1}{2}\nabla_{\theta}[\theta^T(X^TX)\theta-y^T(X\theta)-y^T(X\theta)]\\=\frac{1}{2}\nabla_{\theta}[\theta^T(X^TX)\theta-2(X^Ty)^T\theta]=\frac{1}{2}(2X^TX\theta-2X^Ty)=X^TX\theta-X^Ty\]</span> 哦，高中数学好像不太够，还要知道<span class="math inline">\(a^Tb=b^Ta,\nabla_{x}Ax=A^T,\nabla_{x}x^TAx=(A+A^T)x\)</span>。</p><p>结束了无聊的数学推导，所谓的Normal Equation就来了： <span class="math display">\[X^TX\theta=X^Ty\]</span> 我们暂时先不考虑<span class="math inline">\(X^TX\)</span>不可逆的情况，最终的解析解就是<span class="math inline">\(\theta=(X^TX)^{-1}X^Ty\)</span>。这种方法不需要做Feature Scaling，但是只能用于容易求解的模型。 ## Probabilistic view 当观测数据满足一些假设条件时，就可以自然而然地推导出均方误差形式的损失函数。</p><p>假设观测数据满足： <span class="math display">\[y^{(i)}=\theta^Tx^{(i)}+\epsilon^{(i)}\]</span> 其中，<span class="math inline">\(\epsilon^{(i)}\)</span>表示偏差项，并且<span class="math inline">\(\epsilon^{(i)}\)</span>服从IID的高斯分布，即<span class="math inline">\(\epsilon^{(i)}\sim \mathcal{N}(0, \sigma^2)\)</span>。</p><p>在满足上述假设的条件下，给定<span class="math inline">\(x^{(i)}\)</span>，观测到的<span class="math inline">\(y^{(i)}\)</span>满足概率分布<span class="math inline">\(y^{(i)}|x^{(i)};\theta\sim \mathcal{N}(\theta^Tx^{(i)}, \sigma^2)\)</span>，即： <span class="math display">\[p(y^{(i)}|x^{(i)};\theta)=\frac{1}{\sqrt{2\pi }\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2 \sigma^2})\]</span> 我们希望选择合适的参数<span class="math inline">\(\theta\)</span>，使得在整个训练集上最大化观测数据出现的概率，也就是所谓的极大似然估计： <span class="math display">\[\prod_{i=1}^{n}p(y^{(i)}|x^{(i)};\theta)=\prod_{i=1}^{n}\frac{1}{\sqrt{2\pi }\sigma}exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2 \sigma^2})=L(\theta)\]</span> To make our life easier，采用对数似然函数的形式去求<span class="math inline">\(L(\theta)\)</span>的最大值： <span class="math display">\[l(\theta)=log\ L(\theta)=nlog\ \frac{1}{\sqrt{2\pi }\sigma}-\frac{1}{2\sigma^2}\sum_{i=1}^n(y^{(i)}-\theta^Tx^{(i)})^2\]</span> 因此，最大化<span class="math inline">\(L(\theta)\)</span>与最小化<span class="math inline">\(J(\theta)=\frac{1}{2}\sum_{i=1}^{n}(h_{\theta}(x^{(i)})-y^{(i)})^2\)</span>等价，也就证明了均方误差损失函数的合理性。</p><p>值得一提的是：上述假设并不唯一，存在其它合理的假设同样能够证明均方误差作为损失函数的合理性。 ## 局部加权线性回归 在朴素的线性回归中，训练模型得到的参数<span class="math inline">\(\theta\)</span>是固定的，对于每个要预测的点<span class="math inline">\(x\)</span>计算<span class="math inline">\(\theta^Tx\)</span>就完事了。这种参数化的学习算法在预测时不需要训练数据的支持，非常快捷。</p><p>局部加权线性回归的motivation在于：朴素线性模型强行拟合所有训练样本，因为模型简单往往欠拟合。对于任意一个样本<span class="math inline">\(x\)</span>，如果只根据其周围几个样本来建立局部的线性模型，且距离<span class="math inline">\(x\)</span>越近其在损失函数中的权值越大，就得到了所谓的Locally Weighted Linear Regression： <span class="math display">\[J(\theta)=\frac{1}{2}\sum_{i=1}^{n}w^{(i)}(h_{\theta}(x^{(i)})-y^{(i)})^2\]</span> 直观上看：如果一个点权值较大，其对损失函数的贡献就越大；如果权值较小，那么该点基本可以忽略不计。</p><p>权值一般会设计为指数函数： <span class="math display">\[w^{(i)}=exp(-\frac{(x^{(i)}-x)^T(x^{(i)}-x)}{2\tau^2})\]</span> 其中，<span class="math inline">\(x\)</span>表示待测试样本，<span class="math inline">\(\tau\)</span>负责控制随距离增加权值的衰减快慢。</p><p>另外，与kNN类似，LWR也是一种懒惰学习算法，即只有给出测试样例时才会训练并预测。因此，这种非参数算法在预测时需要存储训练集，并且参数数量会随训练集大小线性增长。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Machine Learning Introduction</title>
      <link href="/2019/06/02/Machine%20Learning%20Introduction/"/>
      <url>/2019/06/02/Machine%20Learning%20Introduction/</url>
      
        <content type="html"><![CDATA[<p>对一个背后的pattern很复杂的问题，我们无法显式编程求解，就需要ML。如果能做到100%正确并且这个过程并不很复杂，就完全没有必要上ML。</p><p>ML我们并没有也不可能直接考虑所有可能出现的情况，然后用对应的方法解决。此时我们编写的程序其实是在操纵一个学习器，它可以根据模型参数的不同灵活应对输入的情况，并且每组参数都可以很好地处理输入的变化。</p><p>现实生活中有许多不同类型的问题，因此学习器也有很多不同的类型，不同类型的学习器针对不同的问题，当然也可以一对多或者多对一或者多对多。训练就是要根据数据获得一组表现良好的参数，下次给出相似类型的输入，我们的模型（参数固定的学习器）可以获得良好的预测表现。此外，还要有一个衡量当前这组参数表现好坏的措施，这就是objective function，训练时要用algorithm去有策略地调整参数，优化objective/loss function。</p><p>数据的难点在于：数量要够只是基本，数据应该合理反应所有可能的类别，对于特定任务的特征选择也应该慎重，比如简历筛选时如果把历史面试结果作为一个特征，那么就很可能在无意中引入historical injustices。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Topological Sort</title>
      <link href="/2019/06/01/Topological%20Sort/"/>
      <url>/2019/06/01/Topological%20Sort/</url>
      
        <content type="html"><![CDATA[<p>拓扑排序将有向无环图的所有顶点排成一个线性序列，使得其中任意两个顶点<span class="math inline">\(u、v\)</span>，若存在有向边<span class="math inline">\(u-&gt;v\)</span>，那么在线性序列中<span class="math inline">\(u\)</span>必然在<span class="math inline">\(v\)</span>之前。</p><p>思想：</p><ol type="1"><li>将所有入度为0的顶点入队；</li><li>取队首结点输出，删除所有从该结点出发的边，并将这些边到达的顶点的入度减1，若某顶点入度减为0，将其入队；</li><li>重复2，直到队列为空。若进过队的结点数为<span class="math inline">\(n\)</span>，排序成功，否则<strong>图中有环</strong>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*复杂度O(V+E)*/</span></span><br><span class="line"><span class="keyword">int</span> vertexNum;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; adjList[MAXV];  <span class="comment">//邻接表 </span></span><br><span class="line"><span class="keyword">int</span> inDegree[MAXV];    <span class="comment">//顶点入度，读入时记录</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;   <span class="comment">//若有多个入度为0的顶点要选择编号最小的，可使用priority_queue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有入度为0的顶点入队 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; vertexNum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> front = q.<span class="built_in">front</span>();</span><br><span class="line">cout &lt;&lt; front &lt;&lt; endl;  <span class="comment">//输出拓扑序列</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; adjList[front].<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = adjList[front][i];  <span class="comment">//front的后继结点</span></span><br><span class="line">inDegree[v]--;</span><br><span class="line"><span class="keyword">if</span>(indegree[v] == <span class="number">0</span>)</span><br><span class="line">q.<span class="built_in">push</span>(v); </span><br><span class="line">&#125;</span><br><span class="line">adjList[front].<span class="built_in">clear</span>();   <span class="comment">//删掉从该顶点出发的所有边</span></span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cnt == vertexNum)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>``` // dfs version, reverse ans is the topological sequence enum states {UNKNOWN, VISITING, VISITED}; bool hasCycle(vector&lt;vector<int>&gt;&amp; graph, int cur, vector<int>&amp; state, vector<int>&amp; ans) { if (state[cur] == VISITING) return true; if (state[cur] == VISITED) return false;</p><pre><code>state[cur] = VISITING;for (auto neighbors : graph[cur]) &#123;    if (hasCycle(graph, neighbors, state, ans))        return true;&#125;state[cur] = VISITED;ans.push_back(cur);return false;</code></pre><p>} ```</int></int>&lt;/vector<int></int></int></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mathematics for Machine Learning</title>
      <link href="/2019/05/24/Mathematics%20for%20Machine%20Learning/"/>
      <url>/2019/05/24/Mathematics%20for%20Machine%20Learning/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p><span class="math inline">\(f(\mathbf{x}) = \boldsymbol{\beta}^\top\mathbf{x}\)</span> <span class="math display">\[\frac{df}{d\mathbf{x}} = \begin{bmatrix}\frac{df}{dx_1} \\\vdots \\\frac{df}{dx_n}\end{bmatrix} = \begin{bmatrix}\beta_1 \\\vdots \\\beta_n\end{bmatrix} = \boldsymbol{\beta}\]</span></p><p><span class="math inline">\(\frac{d}{d\mathbf{x}}(\mathbf{x}^\top A \mathbf{x}) = (\mathbf{A} + \mathbf{A}^\top)\mathbf{x}.\)</span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2019/05/19/Linux/"/>
      <url>/2019/05/19/Linux/</url>
      
        <content type="html"><![CDATA[<h2 id="linux">Linux</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pwd  # print working directoty</span><br><span class="line">cd /  # change directory 输入文件夹部分名按tab自动补全 如果文件夹名字含有空格，需要将文件名用&quot;&quot;括起来</span><br><span class="line">mkdir  # make directory</span><br><span class="line">rmdir  # remove directory</span><br><span class="line">rm a.txt  # remove file</span><br><span class="line">ls -l  # list files</span><br><span class="line">touch filename  # create an empty file</span><br><span class="line">cp lab1/original lab2/dup  # 将original复制为dup</span><br><span class="line">cat a.txt  # capture</span><br><span class="line">less a.txt  # q退出</span><br><span class="line">diff a.txt b.txt</span><br><span class="line">head a.txt -n 5  # 查看前5行</span><br><span class="line">tail a.txt -n 5  # 查看后5行</span><br><span class="line">wc -w a.txt  # 查看单词数目 -l行数 -c字符</span><br><span class="line">mv lab1/a.txt lab2/  # 移动</span><br><span class="line">mv lab1/a.txt lab1/newname.txt  # 重命名</span><br><span class="line">rm filename  # delete</span><br><span class="line">xterm  # open a new terminal window</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line">chmod u-r a.txt  # 作者权限删掉r g-r o-r 小组和其他人删除可读权限</span><br><span class="line">chmod u+r a.txt</span><br><span class="line">chmod go-r a.txt</span><br><span class="line">chmod 444 a.txt  # 100 100 100对应u g o的r w x权限</span><br><span class="line"></span><br><span class="line">grep searchword a.txt  # 包含单词searchword的内容，也可正则</span><br><span class="line">grep ^Hello a.txt  # 以Hello开头的内容</span><br><span class="line">grep searchword a.txt | wc  # 命令组合</span><br><span class="line"></span><br><span class="line">ls &gt; a.txt  # 重定向</span><br></pre></td></tr></table></figure><p>脚本<code>test.sh</code>就是一坨命令，执行脚本就是按照顺序执行这些命令。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh test.sh  # 运行脚本</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">a=10  # 赋值不能加空格</span><br><span class="line">echo $a  # 使用变量时加$ echo输出</span><br><span class="line">c=`expr $a + $b`  # 运算符两侧必须加空格</span><br><span class="line">c=`expr $a \* $b`  # \(\)</span><br><span class="line"></span><br><span class="line">if [ $a -gt $b ]  # 比较大小不能用 &gt; &lt; =</span><br><span class="line">then</span><br><span class="line">    echo $a</span><br><span class="line">else</span><br><span class="line">    echo $b</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">for x in 1 2 3  # for x in &#123;1 .. 3&#125;</span><br><span class="line">do</span><br><span class="line">echo $x</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">x=1</span><br><span class="line">while [ $x -le 10]</span><br><span class="line">do</span><br><span class="line">echo $x</span><br><span class="line">x=`expr $x + 1`</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">a=&quot;hello&quot;</span><br><span class="line">b=&quot;world&quot;</span><br><span class="line"></span><br><span class="line">read a</span><br><span class="line">read b</span><br><span class="line">c=`expr $a + $b`</span><br><span class="line">echo $a + $b = $c</span><br><span class="line"></span><br><span class="line">if [ $a = $b ]</span><br><span class="line">if [ $a != $b ]</span><br><span class="line">str3=&quot;$str1$str2&quot;  # 拼接</span><br><span class="line">if [ -z $str1 ]  # 是否为空 -n是否为不空</span><br><span class="line"></span><br><span class="line">arr=(1 2 3)  # 只能用bash test.sh</span><br><span class="line">echo $&#123;arr[1]&#125;</span><br><span class="line">for i in $&#123;arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">echo $USER  # global variable 当前登录用户</span><br><span class="line">cd $HOME</span><br><span class="line">cd ~</span><br><span class="line">echo $PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 原PATH拼接新路径 不要写成PATH=/home</span></span><br><span class="line">PATH=$PATH:/home/ubuntu/dir  # 可执行程序只能在当前目录下执行，如果要在其他目录执行需要配置环境变量，配置后该目录下的所有可执行程序都可以在任意地方执行</span><br><span class="line"></span><br><span class="line">zip hello.zip *  # 打包所有文件</span><br><span class="line">zip hello.zip -r hello/*  # 递归打包所有子文件夹</span><br><span class="line"></span><br><span class="line">unzip hello.zip</span><br><span class="line"></span><br><span class="line">tar -zcvf hello.tar.gz hello/  # -z使用gzip压缩</span><br><span class="line">tar -zxvf hello.tar.gz  # 解压</span><br><span class="line"></span><br><span class="line">wget url -O newname  # 下载</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Random Forest</title>
      <link href="/2019/05/15/Random%20Forest/"/>
      <url>/2019/05/15/Random%20Forest/</url>
      
        <content type="html"><![CDATA[<h2 id="decision-tree">Decision Tree</h2><h2 id="details">Details</h2><p>决策树的发展经历了CART(Classification and Regression Tree), ID3, C4.5等多个阶段： CART是一种二叉树，分类树采用基尼系数，回归树采用平方误差。 ID3主要用于分类，是一种多叉树结构，采用信息增益。 C4.5主要用于分类，是一种多叉树结构，采用信息增益比。 最终的模型为： <span class="math display">\[f(x)=\sum_{i=1}^{m}C_iI(x\in R_i),I(x\in R_i)=\begin{cases}1, &amp; \text{x$\in$ $R_i$}  \\0, &amp; \text{else}\end{cases}\]</span> m表示数据集被划分的子集数目，<span class="math inline">\(C_i\)</span>表示第i个单元的输出值 ## Example ## Implementation ## Properties</p><h2 id="motivation">Motivation</h2><p>Random Forest is some kind of ensemble learning method, just as its name indicates. The base learner is decision tree and RF uses Bagging to integrate. The difference mainly lies in the word 'Random'. The original decision tree selects the best attribute while RF has two steps to select a split attribute for each base learner:</p><ul><li>Select k attributes from <span class="math inline">\(A\)</span> randomly;</li><li>Select the best attribute from the k attributes. If k=1 then it's total random selection; If k=<span class="math inline">\(|A|\)</span> then it's the same as decision tree. The recommended is <span class="math inline">\(k=log_2|A|\)</span>.</li></ul><p>The intuition behind this is to increase the diversity of the base learners. In original bagging method we just use the sample disturbance of the training data. But in RF we add the attribute disturbance thus making the learner generalize very well.</p><p>As you can imagine, RF's performance is worse than Bagging during the early time of the training process. Since we just use a subset of the attributes so the base learner performs not that well. But with the increase of the number of base learners, it will gradually use the whole information and then has a low generation error. By the way, RF is often faster than Bagging since we only use a subset to train the base learners.</p><h2 id="随机森林回归">随机森林回归</h2><p>决策树回归的叶子结点代表一小片区域，落入该区域的训练样例的均值被用来作为该区域的预测值： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211102104210878-1445042394.png" alt="image" /> 例如上图中右下角的叶子结点的值552.899就是落入该区域的5个样本的均值。 随机森林则是由若干棵决策树通过某些“随机”的方式构建而成，包括样本随机和属性随机，最终的预测结果由所有树的平均得到。 但是它不像线性回归那样在预测时可以外推，如果仔细观察最终参与决策的树的某一部分： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211102105550016-162430821.png" alt="image" /> 可以看到：在carat&lt;0.905和z&lt;3.915这个区域共有4个训练样本，因此测试集中任意一个落入此区域的样本都会被预测为4个样本的均值2775.75，自然也就不会超过这4个样本的取值极限。 如果要预测某个target value超出训练集极限的样例，其预测结果仍然是训练集中某些样本的均值。</p><p>缺失值处理：我在科研中见到的都是先用常数填充训练数据和测试数据，再去扔给模型训练和预测。 我使用sklearn中标准的RandomForestRegressor进行了尝试，如果训练数据包含缺失值，那么训练将会报错。 ## Example ## Implementation ## Properties ## Refs <a href="https://neptune.ai/blog/random-forest-regression-when-does-it-fail-and-why">Random Forest Regression: When Does It Fail and Why?</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linked List Cycle</title>
      <link href="/2019/05/11/Linked%20List%20Cycle/"/>
      <url>/2019/05/11/Linked%20List%20Cycle/</url>
      
        <content type="html"><![CDATA[<h2 id="一单链表是否有环">一、单链表是否有环</h2><p><a href="https://leetcode.com/problems/linked-list-cycle/">题目描述</a> 快慢指针：若链表有环，则两指针必在将来某一时刻相遇：</p><ul><li>直观来看：本质上就是物理上的相对运动。快指针每次2步，慢指针每次1步。 如果没有环，快指针先到达链尾，结束； 如果有环，相对速度为1，即相当于慢指针静止，快指针每次1步，则必然在一圈之内相遇。</li><li>那如果快指针每次3步，4步呢？由之前的相对运动，我们知道两个指针不一定相遇。那么什么情况下可以相遇呢？ <img src="https://img-blog.csdnimg.cn/20200309193026391.png" alt="在这里插入图片描述" /> 当S第一次到达环口，F可能已经在环里转了n圈。假设S的速度为<span class="math inline">\(v_s\)</span>，F的速度为<span class="math inline">\(v_f\)</span>，环长为<span class="math inline">\(L\)</span>，经过时间<span class="math inline">\(t\)</span>相遇： <span class="math display">\[disS=L_1, disF=L_1+L_2+nL\]</span> 即问题转化为是否存在正整数<span class="math inline">\(t\)</span>，使得S和F在环内走过的路程相等： <span class="math display">\[v_st\%L=(L_2+nL+v_ft)\%L\]</span> 根据模运算性质： <span class="math display">\[(L_2+nL+(v_f-v_s)t)\%L=0\]</span> 再化简： <span class="math display">\[(L_2+(v_f-v_s)t)\%L=0\]</span> 也就是当<span class="math inline">\(L_2+(v_f-v_s)t\)</span>是环长<span class="math inline">\(L\)</span>的整数倍，快慢指针可以相遇。 回头去看最简单的情形：<span class="math inline">\(v_f-v_s=1\)</span>，则<span class="math inline">\(t=mL-L_2\)</span>，取<span class="math inline">\(m=1,t=L-L_2\)</span>。所以经过<span class="math inline">\(t\)</span>步必然相遇。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 单链表定义</span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int x):val(x),next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasCycle(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">    if (head == NULL)</span><br><span class="line">   return false;</span><br><span class="line">  ListNode* fast = head;</span><br><span class="line">  ListNode* slow = head;</span><br><span class="line">  while (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    if(fast == slow)</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ## 二、寻找环的入口 <a href="https://leetcode.com/problems/linked-list-cycle-ii/">题目描述</a> 设链头距离环的入口距离为<span class="math inline">\(L_1\)</span>，<strong>相遇点</strong>距离入口距离为<span class="math inline">\(L_3\)</span>，环的长度为<span class="math inline">\(L\)</span>： <img src="https://img-blog.csdnimg.cn/20200309203553400.png" alt="在这里插入图片描述" /> 证明的本质在于求出<span class="math inline">\(L_1\)</span>与<span class="math inline">\(L_3\)</span>的关系。 在（一）中我们已经证明了S从入口到相遇只走了<span class="math inline">\(L-L_2&lt;L\)</span>步，即小于1圈。 由于快指针走过的路程是慢指针的2倍： <span class="math display">\[L_1+L_2+nL+2(L-L_2)=2(L_1+L-L_2)\]</span> 即： <span class="math display">\[L_1=L_2+nL\]</span> 又<span class="math inline">\(L_3=L-(L-L_2)=L_2\)</span>，故有： <span class="math display">\[L_1=nL+L_3\]</span> n表示S第一次到达入口时，快指针已经绕了<span class="math inline">\(n\)</span>圈。 也就是说：设两个指针<span class="math inline">\(p_1, p_2\)</span>，<span class="math inline">\(p_1\)</span>指向链头，<span class="math inline">\(p_2\)</span>指向相遇点，每次都走一步，则两指针必在环的入口相遇。 通俗理解：<span class="math inline">\(p_1\)</span>指针先走<span class="math inline">\(L_3\)</span>步，此时<span class="math inline">\(p_1\)</span>距离环入口还有<span class="math inline">\(L_1-L_3=nL\)</span>步，同时<span class="math inline">\(p_2\)</span>也走了<span class="math inline">\(L_3\)</span>步，刚好到环入口。接着<span class="math inline">\(p_1\)</span>继续走<span class="math inline">\(nL\)</span>步，<span class="math inline">\(p_2\)</span>开始绕环<span class="math inline">\(n\)</span>圈，必相遇。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//单链表定义</span><br><span class="line">struct ListNode&#123;</span><br><span class="line">int val;</span><br><span class="line">ListNode* next;</span><br><span class="line">ListNode(int x):val(x),next(NULL) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">ListNode* detectCycle(ListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">auto fast = head;</span><br><span class="line">auto slow = head;</span><br><span class="line">while(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">if(fast == slow)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">if(!fast || !fast-&gt;next)   //无环,fast走到尽头</span><br><span class="line">return nullptr;</span><br><span class="line"></span><br><span class="line">slow = head;   //一个指向链头,另一个指向相遇点</span><br><span class="line">while(slow != fast)</span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&gt;next;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return slow;    //找到入口</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Subarray</title>
      <link href="/2019/05/05/Maximum%20Subarray/"/>
      <url>/2019/05/05/Maximum%20Subarray/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>给定一个序列<span class="math inline">\(A_0\)</span>、<span class="math inline">\(A_1\)</span>、<span class="math inline">\(A_2\)</span>、...、<span class="math inline">\(A_{n-1}\)</span>，求<span class="math inline">\(A_i+A_{i+1}+...+A_j\)</span>的最大值。 ## 解一 暴力枚举左端点<span class="math inline">\(i\)</span>和右端点<span class="math inline">\(j\)</span>，之后计算<span class="math inline">\(A_i\)</span>和<span class="math inline">\(A_j\)</span>之间的和，时间复杂度<span class="math inline">\(O(n^3)\)</span>，很容易TLE。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define INF 0x7FFFFFFF</span><br><span class="line"></span><br><span class="line">int sub_sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">int MAX = -INF;</span><br><span class="line">for(int i = 0;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = i; j &lt; n; j++)</span><br><span class="line">  &#123;</span><br><span class="line">   int temp = 0;</span><br><span class="line">   for (int k = i; k &lt;= j; k++)</span><br><span class="line">  &#123;</span><br><span class="line">    temp += a[k];</span><br><span class="line">  &#125;</span><br><span class="line">   if (temp &gt; MAX)</span><br><span class="line">   &#123;</span><br><span class="line">   MAX = temp;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解二">解二</h2><p>输入数据时记录前缀和，预处理<span class="math inline">\(sum[i] = A[0] + ... + A[i]\)</span>，因此<span class="math inline">\(A_i+A_{i+1}+...+A_j=sum[j]-sum[i-1]\)</span>，复杂度优化为<span class="math inline">\(O(n^2)\)</span>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int sub_sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">int MAX = -INF;</span><br><span class="line">for(int i = 0;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j = i;j &lt; n;j++&#125;</span><br><span class="line">&#123;</span><br><span class="line">int temp = sum[j] - sum[i - 1];</span><br><span class="line">if(temp &gt; MAX)</span><br><span class="line">MAX = temp;</span><br><span class="line">else</span><br><span class="line">temp = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解三">解三</h2><p>动态规划，复杂度<span class="math inline">\(O(n)\)</span>。 定义状态数组<span class="math inline">\(dp[i]\)</span>，表示以<span class="math inline">\(A[i]\)</span>结尾的连续序列的最大和，这样就只有两种情况： 1，该连续序列只有<span class="math inline">\(A[i]\)</span>这一个元素； 2，该序列有多个元素，从之前的<span class="math inline">\(A[p]\)</span>开始，到<span class="math inline">\(A[i]\)</span>结束。 对于1，最大和就是<span class="math inline">\(A[i]\)</span>； 对于2，最大和是<span class="math inline">\(dp[i - 1]+A[i]\)</span>，因为<span class="math inline">\(dp[i]\)</span>要求以<span class="math inline">\(A[i]\)</span>结尾，所以即使<span class="math inline">\(A[i]\)</span>为负数，<span class="math inline">\(dp[i]\)</span>仍然等于<span class="math inline">\(dp[i - 1]+A[i]\)</span>。 所以<strong>状态转移方程</strong>就是： <span class="math display">\[dp[i]=max{\{A[i],dp[i-1]+A[i]\}}\]</span> 边界是<span class="math inline">\(dp[0]=A[0]\)</span>。 所以枚举<span class="math inline">\(i\)</span>，得到<span class="math inline">\(dp\)</span>数组，求出<span class="math inline">\(dp\)</span>数组最大值即可。</p><p>可以看到，每次计算<span class="math inline">\(dp[i]\)</span>只用到<span class="math inline">\(dp[i-1]\)</span>，不直接用到之前的信息，这就是状态的<strong>无后效性</strong>，只有这样，动态规划才可能得到正确结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int dp[5010];</span><br><span class="line">dp[0] = a[0];</span><br><span class="line"></span><br><span class="line">int sub_sum(int a[],int n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i = 1;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">//状态转移方程</span><br><span class="line">dp[i] = max(a[i],dp[i - 1] + a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int k = 0;</span><br><span class="line">for(int i = 1;i &lt; n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(dp[i] &gt; dp[k])</span><br><span class="line">k = i;</span><br><span class="line">&#125;</span><br><span class="line">return dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免使用<span class="math inline">\(dp[]\)</span>数组，可以将空间复杂度优化为<span class="math inline">\(O(1)\)</span>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int allSum = INT_MIN, curSum = 0;</span><br><span class="line">        </span><br><span class="line">        int n = nums.size();</span><br><span class="line">        for(int i = 0;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum = max(nums[i], curSum + nums[i]);</span><br><span class="line">            if(curSum &gt; allSum)</span><br><span class="line">            &#123;</span><br><span class="line">                allSum = curSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return allSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Graph &amp; Tree Search</title>
      <link href="/2019/05/03/Graph%20&amp;%20Tree%20Search/"/>
      <url>/2019/05/03/Graph%20&amp;%20Tree%20Search/</url>
      
        <content type="html"><![CDATA[<h2 id="graph-search">Graph Search</h2><h3 id="graph-representation">Graph Representation</h3><figure><img src="https://img-blog.csdnimg.cn/20200218153739820.png" alt="" /><figcaption>在这里插入图片描述</figcaption></figure><ul><li>邻接矩阵</li></ul><table><thead><tr class="header"><th>i/j</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr class="odd"><td>0</td><td><span class="math inline">\(\infty\)</span></td><td>-1</td><td>4</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td>1</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td>3</td><td>2</td><td>2</td></tr><tr class="odd"><td>2</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="even"><td>3</td><td><span class="math inline">\(\infty\)</span></td><td>1</td><td>5</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td></tr><tr class="odd"><td>4</td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td><span class="math inline">\(\infty\)</span></td><td>-3</td><td><span class="math inline">\(\infty\)</span></td></tr></tbody></table><p>用<code>vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, INF))</code>表示，<code>g[i][j]</code>表示从顶点<span class="math inline">\(i\)</span>到顶点<span class="math inline">\(j\)</span>的权重，空间复杂度<span class="math inline">\(O(|V|^2)\)</span>，适用于稠密图，用的不多； - 邻接表 链表比较少用，基本都用动态数组：</p><table><thead><tr class="header"><th>0</th><th>(1,-1)</th><th>(2,4)</th><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr class="odd"><td>1</td><td>(2,3)</td><td>(3,2)</td><td>(4,2)</td><td>-</td><td>-</td></tr><tr class="even"><td>2</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr class="odd"><td>3</td><td>(1,1)</td><td>(2,5)</td><td>-</td><td>-</td><td>-</td></tr><tr class="even"><td>4</td><td>(3,-3)</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>用<code>vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g</code>表示，<code>g[i][j].first</code>表示从顶点<span class="math inline">\(i\)</span>出发到达的顶点<span class="math inline">\(k\)</span>，<code>g[i][j].second</code>表示从顶点<span class="math inline">\(i\)</span>到顶点<span class="math inline">\(k\)</span>的权值，空间复杂度<span class="math inline">\(O(|V|+|E|)\)</span>。 - 边表 每个三元组表示一条边，上图的所有边表示为：<span class="math inline">\((0,1,-1),(0,2,4),(1,2,3),(1,3,2),(1,4,2),(3,1,1),(3,2,5),(4,3,-3)\)</span> 用<code>vector&lt;vector&lt;int&gt;&gt; e</code>表示，<code>e[i][0]</code>表示顶点<span class="math inline">\(u\)</span>，<code>e[i][1]</code>表示顶点<span class="math inline">\(v\)</span>，<code>e[i][2]</code>表示<span class="math inline">\(u\)</span>到<span class="math inline">\(v\)</span>的权值，空间复杂度<span class="math inline">\(O(|E|)\)</span>。</p><h3 id="bfs">BFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    queue = []</span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    parent = &#123;s : <span class="literal">None</span>&#125;  <span class="comment"># for shortest path</span></span><br><span class="line">    queue.append(s)</span><br><span class="line">    marked.add(s)</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(queue) &gt; <span class="number">0</span>):</span><br><span class="line">        cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur]:</span><br><span class="line">            <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                marked.add(adj)</span><br><span class="line">                queue.append(adj)</span><br><span class="line">                parent[adj] = cur</span><br><span class="line">        <span class="built_in">print</span>(cur)</span><br><span class="line">    <span class="keyword">return</span> parent</span><br></pre></td></tr></table></figure><h3 id="dfs">DFS</h3><p>从起点出发，标记走过的点，如果发现没有走过的点，随便选一个向前走，无路可走就回退。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    stack.append(s)</span><br><span class="line">    marked.add(s)</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(stack) &gt; <span class="number">0</span>):</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur]:</span><br><span class="line">            <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                marked.add(adj)</span><br><span class="line">                stack.append(adj)</span><br><span class="line">        <span class="built_in">print</span>(cur)</span><br></pre></td></tr></table></figure><p>很不幸的是：上面的代码是错的。举个例子：g有ABCDEF6个结点，边为AB AC BC BD CD CE DE DF，如果走ABDE的话，最终答案应该是ABDECF，但是上述代码的结果是ABDEFC，显然不是合法的DFS结果。</p><p>问题在于标记结点是否访问的时机不对，在D弹出后，直接把EF入栈并标记为已访问，下次到E时发现C已被标记，但此时C很明显并未访问。 不应在入栈时标记，而应该在弹出时标记。因为入栈时并没有真正地访问该节点，出栈时才真正访问。 可以参考<a href="https://github.com/joepachou/NoteBook/issues/116">CS61b</a> 正确的代码如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    stack.append(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(stack) &gt; <span class="number">0</span>):</span><br><span class="line">        cur = stack.pop()</span><br><span class="line"><span class="keyword">if</span> cur <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">        marked.add(cur)</span><br><span class="line">        <span class="keyword">for</span> adj <span class="keyword">in</span> g[cur]:</span><br><span class="line">            <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                stack.append(adj)</span><br><span class="line">        <span class="built_in">print</span>(cur)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    <span class="keyword">global</span> marked</span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    marked.add(s)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    <span class="keyword">for</span> adj <span class="keyword">in</span> g[s]:</span><br><span class="line">        <span class="keyword">if</span> adj <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">            dfs(g, adj)</span><br></pre></td></tr></table></figure></p><ul><li><strong>判断从V出发能否走到终点</strong> <img src="https://img-blog.csdnimg.cn/20190409221625486.png" alt="在这里插入图片描述" /> <strong>- 判断从V出发能否走到终点，若能，记录路径</strong></li></ul><p>栈的作用就是在走投无路之时留给你的退路。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Node path[MAX_LEN];  <span class="comment">// MAX_LEN取节点总数即可</span></span><br><span class="line"><span class="keyword">int</span> depth;  <span class="comment">// 当前点的深度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(V)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (V为终点) &#123;</span><br><span class="line">path[depth] = V;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (V为旧点) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将V标记为旧点;</span><br><span class="line">path[depth++] = V;</span><br><span class="line"></span><br><span class="line">对和V相邻的每个节点U &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Dfs</span>(U))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--depth;   <span class="comment">//从V走不到终点，把V排除出数组,回退到V的父节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">所有点标记为新点;</span><br><span class="line">depth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Dfs</span>(起点)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= depth; i++) &#123;</span><br><span class="line">cout &lt;&lt; path[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>- 遍历图上所有节点</strong> <img src="https://img-blog.csdnimg.cn/20190409225110387.png" alt="在这里插入图片描述" /></p><p>邻接矩阵存储遍历复杂度<span class="math inline">\(O(n^2)\)</span>，因为对每个节点，都要判断其它所有节点是否相邻。 邻接表遍历复杂度<span class="math inline">\(O(n+e)\)</span>。</p><p>1、<a href="http://poj.org/problem?id=1164">城堡问题</a> 给一个地图以及每个格子周围的墙所代表数字之和，求该地图有多少房间，最大房间的面积。</p><p>分析： 要先判断每个格子周围有什么墙，注意到1，2，4，8的二进制形式<code>0001</code>、<code>0010</code>、<code>0100</code>、<code>1000</code>，所以只要将输入数字与1，2，4，8相与，就能知道该方块周围有什么墙。 把方块看作节点，相邻两个方块如果没有墙，就在这两节点之间连一条边，转换为图。 房间个数：图中的极大连通子图个数 <strong>极大连通子图：一个连通子图，加任意一个图中的其他点就不连通，这个子图就是极大连通子图。</strong></p><p>具体： 对每个房间进行DFS，得到该房间所在的极大连通子图，染色所有能够到达的房间，最后统计共用了几种颜色以及每种颜色的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> room[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> color[<span class="number">50</span>][<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;   <span class="comment">//标记方块是否染色,初始都未被访问</span></span><br><span class="line"><span class="keyword">int</span> maxRoomArea = <span class="number">0</span>, roomNum = <span class="number">0</span>, curRoomArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span>   <span class="comment">//从i,j出发遍历极大连通子图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (color[i][j])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">color[i][j] = roomNum;   <span class="comment">//该方块染色</span></span><br><span class="line">curRoomArea++;</span><br><span class="line"><span class="keyword">if</span> ((room[i][j] &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i, j - <span class="number">1</span>);  <span class="comment">//没有西墙，向西走</span></span><br><span class="line"><span class="keyword">if</span> ((room[i][j] &amp; <span class="number">2</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i - <span class="number">1</span>, j);</span><br><span class="line"><span class="keyword">if</span> ((room[i][j] &amp; <span class="number">4</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i, j + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ((room[i][j] &amp; <span class="number">8</span>) == <span class="number">0</span>) <span class="built_in">Dfs</span>(i + <span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row, column;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;row, &amp;column);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;room[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!color[i][j])   <span class="comment">//找到一个新的房间</span></span><br><span class="line">&#123;</span><br><span class="line">roomNum++;</span><br><span class="line">curRoomArea = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Dfs</span>(i, j);          <span class="comment">//探索该房间（极大连通子图）</span></span><br><span class="line">&#125;</span><br><span class="line">maxRoomArea = <span class="built_in">max</span>(curRoomArea, maxRoomArea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n%d&quot;</span>, roomNum, maxRoomArea);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<a href="http://bailian.openjudge.cn/practice/4103">踩方格</a> 递归，从<span class="math inline">\((i,j)\)</span>出发走n步的方案数就等于先走一步，从其它三个格子走n-1步的方案数之和。 前提就是该方块没走过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isVisited[<span class="number">20</span>][<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//访问过直接返回</span></span><br><span class="line"><span class="keyword">if</span> (isVisited[i][j])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//递归边界</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == n)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">isVisited[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以走三个方向</span></span><br><span class="line">ans += <span class="built_in">Dfs</span>(i - <span class="number">1</span>, j, n - <span class="number">1</span>);</span><br><span class="line">ans += <span class="built_in">Dfs</span>(i, j - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">ans += <span class="built_in">Dfs</span>(i, j + <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回前表示当前格子可以重新被访问，以后的走法可能会访问到</span></span><br><span class="line">isVisited[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">Dfs</span>(<span class="number">20</span>, <span class="number">20</span>, n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<a href="http://poj.org/problem?id=1724">ROADS</a> 很多时候，并不需要一条路走到黑，这就是深搜中的<strong>剪枝</strong>。 <img src="https://img-blog.csdnimg.cn/20190414173437346.png" alt="在这里插入图片描述" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*存储边,不需要起点,G(i)表示从i出发*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Road</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> destination, len, toll;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*邻接表存储图*/</span></span><br><span class="line">vector&lt;vector&lt;Road&gt;&gt; <span class="built_in">G</span>(<span class="number">110</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, n, r;</span><br><span class="line"><span class="keyword">int</span> minLen;   <span class="comment">//探索过的最短的路径</span></span><br><span class="line"><span class="keyword">int</span> totalLen;   <span class="comment">//正在探索的最短路径</span></span><br><span class="line"><span class="keyword">int</span> totalCost;   <span class="comment">//正在探索的花费</span></span><br><span class="line"><span class="keyword">int</span> visited[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> minL[<span class="number">110</span>][<span class="number">10010</span>]; <span class="comment">//minL[i][j]:从1走到城市i，且花了j块钱的最优路径长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == n)   <span class="comment">//找到了路径</span></span><br><span class="line">&#123;</span><br><span class="line">minLen = <span class="built_in">min</span>(minLen, totalLen);</span><br><span class="line"><span class="keyword">return</span>;   <span class="comment">//强制结束函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = G[s].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">Road r = G[s][i];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断有没有足够的钱走到r.destination*/</span></span><br><span class="line"><span class="keyword">if</span> (totalCost + r.toll &gt; k) <span class="comment">//钱不够，试下一条边</span></span><br><span class="line"><span class="keyword">continue</span>;     <span class="comment">//可行性剪枝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!visited[r.destination])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*最优性剪枝*/</span></span><br><span class="line"><span class="comment">//当前走过的路长度已经大于之前的minLen，就没必要走下去</span></span><br><span class="line"><span class="keyword">if</span> (totalLen + r.len &gt;= minLen)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//走到r.d时花费同样的钱走过的路长度大于之前相同花费的路长度</span></span><br><span class="line"><span class="keyword">if</span> (totalLen + r.len &gt;= minL[r.destination][totalCost + r.toll])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">minL[r.destination][totalCost + r.toll] = totalLen + r.len;</span><br><span class="line"></span><br><span class="line">totalLen += r.len;</span><br><span class="line">totalCost += r.toll;</span><br><span class="line">visited[r.destination] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(r.destination);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*不走r.destination*/</span></span><br><span class="line">visited[r.destination] = <span class="number">0</span>; <span class="comment">//换下条边之前将访问标志清0</span></span><br><span class="line">totalLen -= r.len;</span><br><span class="line">totalCost -= r.toll;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从城市1开始深搜整个图，找到所有能到达n的，选最优的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;n, &amp;r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> source;</span><br><span class="line">Road r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;source, &amp;r.destination, &amp;r.len, &amp;r.toll);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (source != r.destination)</span><br><span class="line">&#123;</span><br><span class="line">G[source].<span class="built_in">push_back</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">totalLen = <span class="number">0</span>, totalLen = <span class="number">0</span>;</span><br><span class="line">minLen = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;   <span class="comment">//置为无穷大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">110</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10010</span>; j++)</span><br><span class="line">minL[i][j] = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">visited[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);  <span class="comment">//走完了所有路</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (minLen &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, minLen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、<a href="http://poj.org/problem?id=1190">生日蛋糕</a> <img src="https://img-blog.csdnimg.cn/20190414175732766.png" alt="在这里插入图片描述" /><img src="https://img-blog.csdnimg.cn/20190414182524737.png" alt="在这里插入图片描述" /> <a href="http://bailian.openjudge.cn/practice/2816/">练习1</a> <a href="http://bailian.openjudge.cn/practice/2488/">练习2</a> <a href="http://bailian.openjudge.cn/practice/1321/">练习3</a></p><h2 id="tree-search">Tree Search</h2><p>二叉树结点定义： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">Node *left;</span><br><span class="line">Node *right;</span><br><span class="line"><span class="built_in">Node</span>(): <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">Node</span>(<span class="keyword">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">Node</span>(<span class="keyword">int</span> x, Node *left, Node *right): <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 多叉树结点定义： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    vector&lt;Node*&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="bfs-1">BFS</h3><ol type="1"><li><p>二叉树的层序遍历 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">travel</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">queue&lt;Node *&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">Node *cur = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>多叉树的层序遍历 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">level_order</span>(Node* root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans[depth].<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (Node* child : cur-&gt;children) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h3 id="dfs-1">DFS</h3><ol type="1"><li>二叉树 先序遍历： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line"><span class="built_in">travel</span>(root-&gt;left, vec);</span><br><span class="line"><span class="built_in">travel</span>(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代1</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) s.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) s.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代2</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">travel</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">stack&lt;Node *&gt; s;</span><br><span class="line">Node *cur = root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">push</span>(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">cur = s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>中序遍历： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">travel</span>(root-&gt;left, vec);</span><br><span class="line">vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line"><span class="built_in">travel</span>(root-&gt;right, vec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">travel</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">stack&lt;Node *&gt; s;</span><br><span class="line">Node *cur = root;</span><br><span class="line">    <span class="comment">// s.push(root)</span></span><br><span class="line"><span class="comment">// while (!s.empty())</span></span><br><span class="line"><span class="comment">// 这样也可，不过为了统一</span></span><br><span class="line"><span class="keyword">while</span> (cur || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line">s.<span class="built_in">push</span>(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后序遍历： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">travel</span>(root-&gt;left, vec);</span><br><span class="line"><span class="built_in">travel</span>(root-&gt;right, vec);</span><br><span class="line">vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">travel</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">stack&lt;Node *&gt; s;</span><br><span class="line">Node *cur = root;</span><br><span class="line">Node *last_vis = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur &amp;&amp; last_vis != root) &#123;</span><br><span class="line"><span class="keyword">while</span> (cur &amp;&amp; cur != last_vis) &#123;</span><br><span class="line">s.<span class="built_in">push</span>(cur);</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">cur = s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cur-&gt;right || cur-&gt;right == last_vis) &#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">last_vis = cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">s.<span class="built_in">push</span>(cur);</span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li>多叉树 先根遍历 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(Node* root, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    ans.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">for</span> (Node* child : root-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">preorder</span>(child, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cur-&gt;children.<span class="built_in">rbegin</span>(); it != cur-&gt;children.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>后根遍历 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node *child : root-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(child, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node *cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cur-&gt;children.<span class="built_in">begin</span>(); it != cur-&gt;children.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="refs">Refs</h2><p><a href="https://www.icourse163.org/learn/PKU-1001894005?tid=1205957211#/learn/content?type=detail&amp;id=1210422520">郭炜老师MOOC</a> <a href="http://faculty.cs.niu.edu/~mcmahon/CS241/Notes/Data_Structures/binary_tree_traversals.html">Binary Tree Traversals</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Character Array and Character Pointer</title>
      <link href="/2019/04/29/Character%20Array%20and%20Character%20Pointer/"/>
      <url>/2019/04/29/Character%20Array%20and%20Character%20Pointer/</url>
      
        <content type="html"><![CDATA[<p>最近复习数据结构实验时，碰到这么一行代码，看的有点不爽。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef char** HuffmanCode;</span><br></pre></td></tr></table></figure><p>借此梳理下数组和指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int* p; //指针变量p中存的地址代表的内存单元中的数据是整型</span><br></pre></td></tr></table></figure><p>在32位平台下，由于p存的是地址，故p的值是32位。 不论p指向什么类型的数据，指针变量p本身都是整型。</p><p>c中没有<code>string</code>类型，所以一般用字符数组表示字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char str[15] = &quot;Hello World&quot;;</span><br></pre></td></tr></table></figure><p>c规定数组名表示数组在内存中的首地址，就是<code>str = &amp;str[0]</code>，我们一般输出字符串时<code>printf("%s",str);</code>，首地址就可以输出整个字符串。</p><p>在c中可以这么干：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *s;</span><br><span class="line">s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure><p>一个字符串赋值给一个指针变量？？</p><p>事实上，c的编译器会给字符串常量分配内存，假设<code>"Hello"</code>的地址是<code>0x0000000000404000 0x0000000000404001 0x0000000000404002 0x0000000000404003 0x0000000000404004 0x0000000000404005</code>，（我是64位环境） 其实是<code>s = "Hello" = 0x0000000000404000</code>，c编译器把这个串看作首地址。</p><p>做个测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%s\n&quot;,s);</span><br><span class="line">printf(&quot;%s\n&quot;,0x0000000000404000);</span><br><span class="line">这两行的效果是一样的。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char str[10];</span><br><span class="line">char* s;</span><br></pre></td></tr></table></figure><p><code>str</code>表示首地址，<code>s</code>也保存首地址，所以可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = str;</span><br><span class="line">但是不可以 str = s;</span><br></pre></td></tr></table></figure><p>因为数组名是一个常量，不能被赋值。 事实上，<code>char str[10]</code>编译器会分配10个内存单元，而<code>char* s</code>只是定义了一个指针变量，32位环境下只分配4个字节，用来保存字符串首地址。</p><p>不信测试下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof(str) = 10;</span><br><span class="line">sizeof(s) = 4;   //分配四个字节来保存地址</span><br></pre></td></tr></table></figure><p>所以数组名和指针变量本质上是不同的。</p><p>接下来我们看看<code>char**与char* a[]</code>： 对于<code>char* a[]</code>，a实质上还是一个数组，这个数组保存的元素是<code>char*</code>类型的，<code>char*</code>也就是存着地址的变量。</p><p>所以可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* a[] = &#123;&quot;me&quot;,&quot;you&quot;,&quot;him&quot;&#125;;</span><br></pre></td></tr></table></figure><p>这时在32位环境下<code>sizeof(a) = 12</code>，因为a中的3个元素都是<code>char*</code>指针，而指针变量占4个字节。 可以打印出来看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%p %p %p\n&quot;,a[0],a[1],a[2]);</span><br><span class="line">printf(&quot;%p %p %p\n&quot;,&amp;a[0],&amp;a[1],&amp;a[2]);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019021915473671.png" alt="在这里插入图片描述" /> 数组中3个元素保存了3个地址，也就是3个字符串的首地址。</p><p>对于<code>char** s</code>： 二级指针变量s保存一级指针<code>char*</code>的地址，我们可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = a;</span><br></pre></td></tr></table></figure><p>数组名<code>a=&amp;a[0]=62FE30</code>，而这个地址中（即a[0]）保存的是<code>404000</code>这个地址，也就是字符串<code>"me"</code>的首地址，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*s = 404000 = &quot;me&quot;;</span><br></pre></td></tr></table></figure><p>易错点1： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char** s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure> 这是错的，因为s是<code>char**</code> ，而"Hello"是<code>char*</code>。 虽然都是地址，但是"Hello"表示的地址中内容是H，char型； s存的地址中的内容（<code>*s</code>）是<code>char*</code>型，指针类型。</p><p>易错点2： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char** s;</span><br><span class="line">*s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure> 这样编译不会错，但是运行时<code>printf("%s",*s);</code>就会崩溃。</p><p>假设<code>s=0x1000</code>，在<code>0x1000</code>内存单元中存的是"Hello"的地址<code>0x2000</code>，即<code>*s = 0x2000</code>，这样执行时先找到<code>0x1000</code>，然后是<code>0x2000</code>，没有问题。</p><p>但<code>char** s;</code>，s存的是一个随机的地址，也就是野指针，<code>*s</code>就可能会崩溃。</p><p>所以要先分配一个地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char** s;</span><br><span class="line">s = (char**) malloc(sizeof(char**));</span><br><span class="line">*s = &quot;Hello&quot;;</span><br></pre></td></tr></table></figure><p>这样s就有了可用的地址。</p><p>参考： https://blog.csdn.net/liusicheng2008_liu/article/details/80412586</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm Exercises</title>
      <link href="/2019/04/24/Algorithm%20Exercises/"/>
      <url>/2019/04/24/Algorithm%20Exercises/</url>
      
        <content type="html"><![CDATA[<p>汇总一些常见的算法题目，<a href="https://github.com/EIMadrigal/AlgorithmAnswer">参考代码</a> 注：部分题目没有合适的oj地址</p><h2 id="枚举">枚举</h2><p><a href="http://poj.org/problem?id=1543">Perfect Cubes</a> <a href="http://poj.org/problem?id=1006">Biorhythms</a> <a href="http://poj.org/problem?id=1013">Counterfeit Dollar</a> <a href="http://poj.org/problem?id=1222">EXTENDED LIGHTS OUT</a> <a href="http://cxsjsxmooc.openjudge.cn/2019t2springsum2/001/">特殊密码锁</a> <a href="http://cxsjsxmooc.openjudge.cn/2019t2springsum2/002/">拨钟问题</a></p><h2 id="递归">递归</h2><p><a href="http://bailian.openjudge.cn/practice/2730/">nn的阶乘</a> <a href="http://bailian.openjudge.cn/practice/4147/">汉诺塔问题</a> <a href="http://bailian.openjudge.cn/practice/2698/">N皇后问题</a> <a href="http://bailian.openjudge.cn/practice/2694/">逆波兰表达式</a> <a href="http://bailian.openjudge.cn/practice/4132/">四则运算表达式求值</a> <a href="http://bailian.openjudge.cn/practice/4017/">爬楼梯</a> <a href="http://bailian.openjudge.cn/practice/1664/">放苹果</a> <a href="http://bailian.openjudge.cn/practice/2787/">算24</a> <a href="http://bailian.openjudge.cn/practice/2748/">全排列</a></p><h2 id="二分">二分</h2><p><a href="http://bailian.openjudge.cn/practice/4142/">二分法求方程的根</a> <a href="http://bailian.openjudge.cn/practice/4143/">和为给定数</a> <a href="http://poj.org/problem?id=2456">Aggressive Cows</a></p><h2 id="分治">分治</h2><p><a href="http://noi.openjudge.cn/ch0204/7617/">输出前k大的数</a> <a href="http://noi.openjudge.cn/ch0204/7622/">排列的逆序数</a></p><h2 id="动态规划">动态规划</h2><p><a href="http://poj.org/problem?id=1163">The Triangle</a> <a href="http://bailian.openjudge.cn/practice/2757">最长上升子序列</a> <a href="http://poj.org/problem?id=1458">最长公共子序列</a> <a href="http://bailian.openjudge.cn/practice/4152/">最佳加法表达式</a> <a href="http://poj.org/problem?id=1661">Help Jimmy</a> <a href="http://bailian.openjudge.cn/practice/2755/">神奇的口袋</a> <a href="http://poj.org/problem?id=1088">滑雪</a> <a href="http://poj.org/problem?id=3624">0-1背包问题</a> <a href="http://noi.openjudge.cn/ch0405/6047/">分蛋糕</a></p><h2 id="深搜">深搜</h2><p><a href="http://poj.org/problem?id=1164">The Castle</a> <a href="http://bailian.openjudge.cn/practice/4103/">踩方格</a> <a href="http://poj.org/problem?id=1724">ROADS</a> <a href="http://poj.org/problem?id=1190">生日蛋糕</a></p><h2 id="广搜">广搜</h2><p><a href="http://poj.org/problem?id=3278">Catch That Cow</a> <a href="http://bailian.openjudge.cn/practice/4127/">迷宫问题</a> <a href="http://bailian.openjudge.cn/practice/4115/">鸣人和佐助</a> <a href="http://poj.org/problem?id=1077">Eight</a></p><h2 id="贪心">贪心</h2><p><a href="http://bailian.openjudge.cn/practice/4110">Santa Clau's Gifts</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW</title>
      <link href="/2019/04/15/INTERVIEW%20#4/"/>
      <url>/2019/04/15/INTERVIEW%20#4/</url>
      
        <content type="html"><![CDATA[<p>120min, 5题。本菜鸡怒跪。</p><ol type="1"><li>变身程序员 <img src="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113449318-2123072016.png" alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(读取时可以按行读取，直到读到空行为止，再对读取过的所有行做转换处理)</span><br><span class="line">输出描述：</span><br><span class="line">如果能将所有的产品经理变成程序员，输出最小的分钟数；</span><br><span class="line">如果不能将所有的产品经理变成程序员，输出-1。</span><br><span class="line">示例1：</span><br><span class="line">输入：</span><br><span class="line">0 2</span><br><span class="line">1 0</span><br><span class="line">输出：</span><br><span class="line">-1</span><br><span class="line">示例2：</span><br><span class="line">输入：</span><br><span class="line">1 2 1</span><br><span class="line">1 1 0</span><br><span class="line">0 1 1</span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">示例3：</span><br><span class="line">输入：1 2</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br><span class="line">输出：</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>此题与<a href="https://leetcode.com/problems/rotting-oranges/">rotting-oranges</a>类似。 基本思想就是将所有的程序员入队，BFS所有的产品经理，最后检查是否还有产品经理存在。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy, <span class="keyword">int</span> t) :<span class="built_in">x</span>(xx), <span class="built_in">y</span>(yy), <span class="built_in">time</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> grid[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*按行读取输入*/</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, str))</span><br><span class="line">    &#123;</span><br><span class="line">        col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[row][col++] = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        row++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//将所有程序员入队</span></span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(i, j, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    node s;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        s = q.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*四个方向遍历*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> newx = s.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newy = s.y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//没有越界并且找到一枚产品经理</span></span><br><span class="line">            <span class="keyword">if</span> (newx &gt;= <span class="number">0</span> &amp;&amp; newx &lt; row &amp;&amp; newy &gt;= <span class="number">0</span> &amp;&amp; newy &lt; col &amp;&amp; grid[newx][newy] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[newx][newy] = <span class="number">2</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(newx, newy, s.time + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li>特征提取 <img src="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113606327-1298909116.png" alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">1</span><br><span class="line">8</span><br><span class="line">2 1 1 2 2</span><br><span class="line">2 1 1 1 4 2 1 1 2 2</span><br><span class="line">2 2 2 1 4</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1 1 1</span><br><span class="line">1 1 1</span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">说明：</span><br><span class="line">特征&lt;1，1&gt;在连续的帧中出现3次，相比其他特征连续出现的次数大，所以输出3</span><br><span class="line">备注：</span><br><span class="line">如果没有长度大于2的特征运动，返回1</span><br></pre></td></tr></table></figure><p>可以使用pair存储当前特征，使用map存储当前特征上一次出现的行数以及当前特征连续出现的长度。 <del>还是对C++不熟唉</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, fea_num, res;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;M);</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>=&quot;&quot;&gt; cur;</span><br><span class="line">        <span class="comment">//当前特征上一次出现的行数以及连续出现的长度</span></span><br><span class="line">        map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>=&quot;&quot;&gt;, <span class="keyword">int</span>&gt; lastIndex, length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;fea_num);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; fea_num; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;cur.first, &amp;cur.second);</span><br><span class="line">                <span class="keyword">if</span> (lastIndex[cur] == i)</span><br><span class="line">                &#123;</span><br><span class="line">                    length[cur]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    length[cur] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                lastIndex[cur] = i + <span class="number">1</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(res, length[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>机器人跳跃 <img src="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113621644-2143156756.png" alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例1：</span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">3 4 3 2 4</span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">示例2：</span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">4 4 4</span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">示例3：</span><br><span class="line">输入：</span><br><span class="line">3</span><br><span class="line">1 6 4</span><br><span class="line">输出：</span><br><span class="line">3</span><br><span class="line">备注：</span><br><span class="line">1 &lt;= N &lt;= 10^5</span><br><span class="line">1 &lt;= H(i) &lt;= 10^5</span><br></pre></td></tr></table></figure><p><del>据说是小学数学，还想了半天。</del> 根据题意可推出：<span class="math inline">\(dp[k + 1] = 2*dp[k] - H[k + 1]\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">H</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;H[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>)</span></span>;  <span class="comment">//dp[k]表示从第k级开始需要的能量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="built_in">ceil</span>((dp[i + <span class="number">1</span>] + H[i + <span class="number">1</span>]) / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>毕业旅行问题 <img src="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190418161743511-1863478998.png" alt="img" /> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">4</span><br><span class="line">0 2 6 5</span><br><span class="line">2 0 4 4</span><br><span class="line">6 4 0 2</span><br><span class="line">5 4 2 0</span><br><span class="line">输出：</span><br><span class="line">13</span><br></pre></td></tr></table></figure></li></ol><p>典型的TSP问题，据说动态规划能够得到理论最优解，<del>然而本渣看不懂状态转移方程</del>。 贪心算法：从某城市出发，每次在未到达的城市中选择最近的一个，直到遍历完所有城市，最后回到出发地。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1&lt;&lt;30;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m[<span class="number">20</span>][<span class="number">20</span>], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> edge_count = <span class="number">0</span>, flag[<span class="number">20</span>] = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>, next;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (edge_count &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[j] &amp;&amp; m[cur][j] &amp;&amp; m[cur][j] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                next = j;</span><br><span class="line">                min = m[cur][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += m[cur][next];</span><br><span class="line">        flag[next] = <span class="number">1</span>;</span><br><span class="line">        edge_count++;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res += m[cur][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="5" type="1"><li>过河 <img src="https://img2018.cnblogs.com/blog/1260581/201904/1260581-20190415113646291-699967742.png" alt="img" /></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">4</span><br><span class="line">1 1 1 1</span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>每次过河只能2个或3个人，这种过河问题遵循<strong>能者多劳</strong>原则，即花费时间少的人折返去接其他人。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>], dp[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">        dp[<span class="number">2</span>] = a[<span class="number">1</span>], dp[<span class="number">3</span>] = a[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//前i个人过河的最短时间</span></span><br><span class="line">            dp[i] = <span class="built_in">min</span>( dp[i - <span class="number">1</span>] + a[<span class="number">0</span>] + a[i - <span class="number">1</span>],dp[i - <span class="number">2</span>] + a[<span class="number">1</span>] + a[i - <span class="number">1</span>] );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </algorithm></cstdio></cstdio></int></int></vector></cmath></cstdio>&lt;/pair&lt;int,&gt;&lt;/int,&gt;</algorithm></map></utility></cstdio></node></queue></string></algorithm></cstdio></iostream></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Simple Math Problems</title>
      <link href="/2019/04/10/Simple%20Math%20Problems/"/>
      <url>/2019/04/10/Simple%20Math%20Problems/</url>
      
        <content type="html"><![CDATA[<h2 id="最大公约数-最小公倍数">最大公约数 &amp; 最小公倍数</h2><p>Euclid's Algorithm：若<span class="math inline">\(b\neq0\)</span>，那么<span class="math inline">\(gcd(a,b)=gcd(b,a\%b)\)</span>。 若<span class="math inline">\(a&lt;b\)</span>，定理会先交换a和b。 注意：0和任意正整数a的gcd是a。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 时间复杂度<span class="math inline">\(O(lgb)\)</span>，因为每次递归问题规模都会缩减一半以上。 最小公倍数<span class="math inline">\(lcm=\frac{a*b}{gcd}\)</span>。</p><ul><li>扩展欧几里得算法 可以计算出满足下式的三元组<span class="math inline">\((d,x,y)\)</span>： <span class="math display">\[d = GCD(a, b) = ax + by\]</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Euclid_extend</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == b) &#123;</span><br><span class="line">*x = <span class="number">1</span>;</span><br><span class="line">*y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> r = Euclid_extend(b,a%b,x,y);</span><br><span class="line"><span class="keyword">int</span> temp = *x;</span><br><span class="line">*x = *y;</span><br><span class="line">*y = temp - (*y)*(a/b);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <em>简单证明：</em> <span class="math inline">\(b=0\)</span>是递归基，易得一组解<span class="math inline">\(x=1,y=0\)</span>; <span class="math inline">\(b \neq0\)</span>时： 首先递归求解： <span class="math display">\[d&#39;=gcd(b,a\%b)=bx&#39;+(a\%b)y&#39; \ \ \ \ \  \ \ \ \ \ \ \ \ \ (1)\]</span> 我们知道： <span class="math display">\[d=gcd(a,b)=d&#39;=gcd(b,a\%b)\ \ \ \ \ \ \ \ \ \ \ \ \ (2)\]</span> <span class="math display">\[a\%b=a-b*\biggl\lfloor a/b \biggr\rfloor\ \ \ \ \ \ \ \ \ \ \ (3)\]</span> 将(2)(3)式带入(1)： <span class="math display">\[d=bx&#39;+(a-b\biggl\lfloor a/b \biggr\rfloor)y&#39;=ay&#39;+b(x&#39;-\biggl\lfloor a/b \biggr\rfloor y&#39;)\]</span> 所以，令<span class="math inline">\(x=y&#39;\)</span>、<span class="math inline">\(y=x&#39;-\biggl\lfloor a/b \biggr\rfloor y&#39;\)</span>，就可以满足<span class="math inline">\(d=ax+by\)</span>。</li></ul><h2 id="分数">分数</h2><p>PAT甲1088是比较经典的分数处理问题，求2个分数的和、差、积、商，输出最简形式。 表示、化简、运算、输出，代码阐释得很清楚。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span> &#123;</span></span><br><span class="line">        ll nume,deno;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.deno &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                a.deno = -a.deno;</span><br><span class="line">                a.nume = -a.nume;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.nume == <span class="number">0</span>) &#123;</span><br><span class="line">                a.deno = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">int</span> d = <span class="built_in">gcd</span>(<span class="built_in">abs</span>(a.nume),<span class="built_in">abs</span>(a.deno));</span><br><span class="line">               a.nume /= d;</span><br><span class="line">               a.deno /= d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">add</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.deno;</span><br><span class="line">        res.nume = a.deno * b.nume + a.nume * b.deno;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">sub</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.deno;</span><br><span class="line">        res.nume = a.nume * b.deno - a.deno * b.nume;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">times</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.deno;</span><br><span class="line">        res.nume = a.nume * b.nume;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">divide</span><span class="params">(Fraction a,Fraction b)</span> </span>&#123;</span><br><span class="line">        Fraction res;</span><br><span class="line">        res.deno = a.deno * b.nume;</span><br><span class="line">        res.nume = a.nume * b.deno;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reduction</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFrac</span><span class="params">(Fraction a)</span> </span>&#123;</span><br><span class="line">        a = <span class="built_in">reduction</span>(a);</span><br><span class="line">        <span class="keyword">if</span>(a.nume &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.deno == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,a.nume);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(a.nume) &gt; <span class="built_in">abs</span>(a.deno)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld/%lld&quot;</span>,a.nume / a.deno,<span class="built_in">abs</span>(a.nume) % a.deno,a.deno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld&quot;</span>,a.nume,a.deno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a.nume &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Fraction a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld/%lld%lld/%lld&quot;</span>,&amp;a.nume,&amp;a.deno,&amp;b.nume,&amp;b.deno);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; + &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(<span class="built_in">add</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; - &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(<span class="built_in">sub</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; * &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(<span class="built_in">times</span>(a,b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">showFrac</span>(a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; / &quot;</span>);</span><br><span class="line">        <span class="built_in">showFrac</span>(b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(b.nume == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Inf\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">showFrac</span>(<span class="built_in">divide</span>(a,b));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="素数">素数</h2><p>1、判断素数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="comment">// 1不是素数，也不是合数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> square_root = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= square_root; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、打素数表</p><p>第一种方法是枚举判断。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn], num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime_table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i)) &#123;</span><br><span class="line">            prime[num++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种是Eratosthenes筛法，复杂度<span class="math inline">\(O(nloglogn)\)</span> <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211224154934702-698444567.png" alt="image" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isprime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">fill</span>(isprime, isprime + n + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (isprime[i])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">                isprime[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步的优化是欧拉筛，复杂度<span class="math inline">\(O(n)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isprime[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; primes;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">fill</span>(isprime, isprime + n + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isprime[i])</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : primes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isprime[p * i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 3、分解质因子 注意：1要特判。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factor</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> x,cnt; <span class="comment">//x为质因子,cnt为该质因子个数</span></span><br><span class="line">&#125;fac[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;  <span class="comment">//记录不同因子个数</span></span><br><span class="line"><span class="comment">//枚举小于等于sqrt(n)内的所有质因子,判断哪个是n的因子</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;prime[i] &lt;= <span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % prime[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                fac[num].x = prime[i];</span><br><span class="line">                fac[num].cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(n % prime[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        fac[num].cnt++;</span><br><span class="line">                        n /= primep[i];</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果n仍然大于1,说明n有一个大于sqrt(n)的质因子</span></span><br><span class="line"><span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        fac[num].x = n;</span><br><span class="line">        fac[num++].cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/100051075">素数筛</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mobile Communication</title>
      <link href="/2019/04/03/Mobile%20Communication/"/>
      <url>/2019/04/03/Mobile%20Communication/</url>
      
        <content type="html"><![CDATA[<p>最近面试有被问到LTE，感觉说得不太清楚，重新整理一遍。</p><h2 id="第一代移动通信系统">第一代移动通信系统</h2><p>1G，诞生于1980年左右。<strong>模拟通信系统</strong>，抗干扰性能差，使用FDMA技术，主要用来传输<strong>话音</strong>信号，最拉风的就是“大哥大”。 采用蜂窝组网，又叫小区制移动通信。将网络服务区划分为许多cell，每个cell设置一个基站，移动站的发送和接收都要通过基站进行。 1G的制式有很多种：瑞士、荷兰、俄罗斯等使用的NMT，美国、澳大利亚使用的AMPS，英国使用的TACS等。</p><h2 id="第二代移动通信系统">第二代移动通信系统</h2><p>2G是<strong>数字通信系统</strong>，因此抗干扰能力大大增强。同时引入了CDMA和TDMA技术，提供了<strong>低速数字通信</strong>（短信）服务。</p><p>2G的制式主要是欧洲的GSM(Global System for Mobile Communication)。 不久，2G就演变为了支持<strong>数据服务</strong>的2.5G（能上网）。2.5G包括了GPRS(General Packet Radio Service)和EDGE(Enhanced Data rate for GSM Evolution)。</p><h2 id="第三代移动通信系统">第三代移动通信系统</h2><p>3G主要采用了CDMA技术，使用混合的交换机制（电路交换、分组交换），可以提供丰富的多媒体服务（话音、数据、视频等）。 3G的标准主要有三种：欧洲的WCDMA（中国联通采用）、美国的CDMA2000（中国电信使用）、中国的TD-SCDMA（中国移动使用）。 制定标准的过程也是利益冲突与妥协的过程，欧洲这边成立了3GPP组织，美国主导了3GPP2组织，中国当然是加入了3GPP。</p><h2 id="第四代移动通信系统">第四代移动通信系统</h2><p>国际电信联盟（ITU）提出了4G的需求，4G的大名是IMT-Advanced(International Mobile Telecommunications-Advanced)。 4G标准的制定者，一个是3GPP，一个是IEEE。 3GPP提出了LTE(Long-Term Evolution)和LTE-Advanced，IEEE提出了WirelessMAN-Advanced。 LTE是3G和4G之间的过渡技术，也被称为3.9G。由于高通放弃了3GPP2转而投向LTE的怀抱，所以LTE应用得很广泛。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW</title>
      <link href="/2019/04/01/INTERVIEW%20#3/"/>
      <url>/2019/04/01/INTERVIEW%20#3/</url>
      
        <content type="html"><![CDATA[<p><em>菊厂的面试本来没打算记录，因为当时投的是非技术岗（技术支持）。为了全面，就寥做记录。</em> <em>菊厂的面试因为有口头保密协议，所以不能透露具体题目。</em></p><h1 id="群面">0 群面</h1><p>简历通过筛选后，会有短信通知去面试。 非技术岗第一轮是所谓“集体面试”，持续1.5h，菊厂两种形式：小组讨论（6人及以下）、小组辩论（12人分2组，6人/组）。 小组讨论一般是3位面试官会给一个问题，要求讨论之后给出一个解决方案； 小组辩论在分好组之后，会有一个简短的自我介绍环节； 接着拿到辩题，会有15~20Min左右的组内讨论时间； 讨论完毕后，每组需要选一个发言人阐述本方论点（建议口才不是很好的同学不要抢这个发言人）； 再下来就是针对对方的论点论据进行辩论（这时候一定要积极举手回答）； 最后会让每个人选一个要淘汰的本组同学并阐明理由，之后面试官进行总结。 群面结束后，没有通过的人就可以回家了。 我其实比较讨厌辩论，感觉就是两组人围绕着两个极端去互相反驳对方，可是明明很多时候是完全可以trade-off的，并不是非此即彼。</p><h1 id="半技术面">1 半技术面</h1><p>之所以叫做半技术面，是因为菊厂非技术岗的二面有点XX。据说会根据你的专业背景提问，如果不太对口就不会提问技术问题。 很不幸，我的面试官原来也是学通信的。简单聊了下简历上的项目之后，就开始疯狂追问网络问题，我可能没太get到他的point，交流不太顺畅，这一面表现不太好。 不过不知道是不是因为长太帅了（捂脸~），这一面竟然给过了。</p><h1 id="高管面">2 高管面</h1><p>通过二面后，会把你请到一个逼格有点高的地方，等着被高管临幸。 这种聊的就比较随意了，侃天侃地侃人生。 你的人生有嘛规划啊，你遇到最大的挫折是嘛啊，怎么克服的啊，你了解华为公司嘛...... 如果要把你派到非洲，愿不愿意啊，三年你愿意，十年你愿意么？ 总之，华为的文化就是你要绝对服从公司的安排，不怕吃苦，不怕牺牲，为公司倾情奉献。。。 最后你有什么问题的话，可以问他。</p><h1 id="英语测试">3 英语测试</h1><p>如果通过前三轮面试，最后有一个英语测试。 这个不知道什么标准，反正差不多三部分：1、单选题；2、朗读句子？（记不清了）；3、给2个topic，说一段话。 我这感人的口语水平，第三部分噼里啪啦自己都不知道说的啥。。。 全部完成后，就可以回去等消息了。 P.s. 即使四轮面试全部通过，也不意味着就能拿到offer。熟悉菊厂的同学都知道有个资源池，过面试后先进池子里泡着，公司会根据HC和前一批的违约情况从池子里分批捞人，建议不要一棵树上吊死。 <em>其它菊厂面经 ：https://zhuanlan.zhihu.com/p/24427674</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW</title>
      <link href="/2019/03/28/INTERVIEW%20#2/"/>
      <url>/2019/03/28/INTERVIEW%20#2/</url>
      
        <content type="html"><![CDATA[<p>吐槽下ZZ的面试安排：面试时间12：30不说了，周围没有饭店，中午就没吃饭。。。不像其他公司给每个人安排不同的面试时间，这样可以节约大家的时间，SPDB是把一大批人都安排在了12：30，而且面试是5个面试官对一个人，生生地把可以并行的工作给整废了，大部分时间都浪费在了无意义的等待上。</p><h2 id="机试">机试</h2><p>50min三道题，考察地很基础，基本之前都练过。利用的是<a href="http://hustoj.com/oj/">华科的OJ</a>，IDE有Dev-C++、Eclipse、PyCharm，Dev-C++没太用过，所以调试得很慢很慢。。。</p><ol type="1"><li><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2051">十进制转二进制</a> “除基取余，逆序排列”。每次将要转换的数除以基数Q，将余数作为<strong>低位</strong>存储直到商为0，将所有位由高到低输出即可。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, num[<span class="number">40</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            num[len++] = n % <span class="number">2</span>;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>之所以用do...while循环，是因为如果输入为0，用while会直接跳出循环，结果出错。 2. 求出200以内所有3的倍数的数字和 没啥好说的。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(i % <span class="number">3</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 3. <a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805415005503488">质因子分解</a> 这题寒假练过，不过机考时候忘了，素数表打的好像有问题。。。幸亏测试数据弱，就手工写了一个数组存了前面20个素数，结果AC了。。。</p><ul><li>如果一个正整数n是一个合数，那么它的因子必然是在<span class="math inline">\(\sqrt n\)</span>左右两侧成对出现；</li><li>推广到质因子，如果n存在[2,n]内的质因子，那么这些质因子要么全部小于等于<span class="math inline">\(\sqrt n\)</span>，要么只有一个大于<span class="math inline">\(\sqrt n\)</span>，其余都小于等于<span class="math inline">\(\sqrt n\)</span>。</li></ul><p>所以算法是： 1）枚举1~<span class="math inline">\(\sqrt n\)</span>内的所有质因子，判断其是否是n的因子； 2）如果1）结束后<span class="math inline">\(n\geq 1\)</span>，那么其必然有且仅有一个大于<span class="math inline">\(\sqrt n\)</span>的质因子，记录该因子； 3）输入是1要特判。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是int范围，数组开10足够了，</span></span><br><span class="line"><span class="comment">//因为2*3*5*7*11*13*17*19*23*29就超过int了，所以我手工写一个数组也足够了。。。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fac</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> cnt;  <span class="comment">//质因子x的个数</span></span><br><span class="line">&#125;fac[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == a)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sqr = <span class="built_in">sqrt</span>(<span class="number">1.0</span>*a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sqr; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(a % i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[maxn], num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//打素数表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primeTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            prime[num++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">primeTable</span>();  <span class="comment">//记得写，我好像没写这句。。。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">int</span> diffFacNum = <span class="number">0</span>;  <span class="comment">//n的不同质因子个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld=&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == n)  <span class="comment">//特判1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sqr = <span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举2~sqrt(n)的质因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; prime[i] &lt;= sqr; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % prime[i] == <span class="number">0</span>)  <span class="comment">//如果该质因子是n的因子</span></span><br><span class="line">            &#123;</span><br><span class="line">                fac[diffFacNum].x = prime[i];</span><br><span class="line">                fac[diffFacNum].cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//计算该质因子的个数</span></span><br><span class="line">                <span class="keyword">while</span> (n % prime[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fac[diffFacNum].cnt++;</span><br><span class="line">                    n /= prime[i];</span><br><span class="line">                &#125;</span><br><span class="line">                diffFacNum++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必有一个大于sqrt(n)的质因子</span></span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fac[diffFacNum].x = n;</span><br><span class="line">            fac[diffFacNum++].cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diffFacNum; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, fac[i].x);</span><br><span class="line">            <span class="keyword">if</span> (fac[i].cnt &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;^%d&quot;</span>, fac[i].cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="面试">面试</h2><p>面试期间也被问到了一道题： 大致意思就是有一个正整数n，找出一个比n大且每位数字之和=n的每位数字之和的最小数，比如输入050，那么输出104。 我开始的思路是从n开始向上枚举，直到找到满足要求的数； 其实更优的解法是：对于在050~099之间的数根本不用考虑，因为必然不满足每位数字之和=n的每位数字之和，这样可以提高效率。</p><h2 id="其它">其它</h2><p>1、语言：Java多态、C的数据类型； 2、数据结构：链表是否有环（烂大街了）； 3、操作系统：进程状态及转换、进程线程区别。 </cmath></cstdio></cstdio></cstdio></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Bias-Variance Analysis</title>
      <link href="/2019/03/25/Bias-Variance%20Analysis/"/>
      <url>/2019/03/25/Bias-Variance%20Analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="motivation">Motivation</h2><p>对于机器学习模型<span class="math inline">\(g\)</span>的泛化性能的分析不仅可以通过实验的方式进行评估，还可以从理论上进行分析，这也是learning theory研究的一部分。 ## 推导 首先假设无噪，定义在训练集<span class="math inline">\(D\)</span>上学习到的模型<span class="math inline">\(g^{(D)}\)</span>的期望泛化误差为： <span class="math display">\[E_{out}(g^{(D)})=E_x[(g^{(D)}(x)-f(x))^2]\]</span> 先使用小学数学做点预备： <span class="math display">\[E_D[g^{(D)}(x)]=\bar g(x)\\E_D[g^{(D)}(x)^2]-\bar g(x)^2=E_D[(g^{(D)}(x)-\bar g(x))^2]=var(x)\\\bar g(x)^2-2E_D[g^{(D)}(x)]f(x)+f(x)^2=(\bar g(x)-f(x))^2=bias(x)^2\]</span> 不同的方式会生成不同的训练集<span class="math inline">\(D\)</span>，因此<span class="math inline">\(g\)</span>的总的期望泛化误差为： <span class="math display">\[E_D[E_{out}(g^{(D)})]=E_D[E_x[(g^{(D)}(x)-f(x))^2]]=E_x[E_D[(g^{(D)}(x)-f(x))^2]]\\=E_x[E_D[g^{(D)}(x)^2]-2E_D[g^{(D)}(x)]f(x)+f(x)^2]\\=E_x[E_D[g^{(D)}(x)^2]-\bar g(x)^2+\bar g(x)^2-2E_D[g^{(D)}(x)]f(x)+f(x)^2]\\=E_x[var(x)+bias(x)^2]=E_x[var(x)]+E_x[bias(x)^2]=var+bias^2\]</span></p><p>如果数据有噪，还是用MSE推一个漂亮的分解，其他的损失函数可能没有这么好搞： 以下推导针对单条测试样例<span class="math inline">\((x,y)\)</span>，其中<span class="math inline">\(y=f(x)+\epsilon,E_D(\epsilon)=0,V_D(\epsilon)=\sigma^2\)</span>，噪声只需要均值为0即可，甚至都不需要是高斯分布。 <span class="math display">\[E_D[(g^{(D)}(x)-y)^2]=E_D[(f(x)+\epsilon-g^{(D)}(x))^2]\\=E_D[\epsilon^2]+E_D[(g^{(D)}(x)-f(x))^2]+E_D[2\epsilon(g^{(D)}(x)-f(x))]\\=V_D[\epsilon]+E_D[\epsilon]^2+E_D[(g^{(D)}(x)-f(x))^2]+E_D[\epsilon]E_D[2(g^{(D)}(x)-f(x)]\\=\sigma^2+E_D[(g^{(D)}(x)-f(x))^2]\\=\sigma^2+E_D[g^{(D)}(x)-f(x)]^2+V_D[g^{(D)}(x)-f(x)]\\=\sigma^2+(f(x)-E_D[g^{(D)}(x)])^2+V_D[g^{(D)}(x)]\\=\sigma^2+(\bar g(x)-f(x))^2+var(x)=\sigma^2+bias(x)^2+var(x)\]</span> 其中测试样例噪声<span class="math inline">\(\epsilon\)</span>与<span class="math inline">\(f(x),g^{(D)}(x)\)</span>均独立，因此拆为乘积。</p><p>可以看到：bias表达的是所有可能的训练数据集训练出的所有模型的平均值与真实值的差异，variance表达的是同等规模的不同的训练数据集学习到的模型之间的差异。 当训练数据无穷多时，数据扰动对模型的泛化性能没有影响，variance就为0，此时复杂模型的bias通常更低，泛化能力也就更强。 训练数据较少时，复杂模型的variance很大，此时即使训练误差很低，泛化误差也会很高，即所谓的过拟合。 ## Refs <a href="https://nbviewer.org/github/tournami/Learning-From-Data-MOOC/blob/master/Homework%204.html">Bias and Variance</a> <a href="https://engineering.purdue.edu/ChanGroup/ECE595/files/chapter4.pdf">Learning Theory</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java FAQ</title>
      <link href="/2019/03/21/Java%20FAQ/"/>
      <url>/2019/03/21/Java%20FAQ/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>Jar包本来在project structure中，按绿色按钮也可以执行，但从命令行就会报错：找不到对应的包。 Idea为了从命令行编译程序，必须将jar包的路径添加到系统变量classpath中，再在idea中project structure中添加该jar，重启计算机。 ## 多线程 Java有2种方式实现多线程：</li></ol><p>继承<code>Thread</code>类</p><p>单线程程序即只有主方法的线程，该线程由JVM负责启动，其他线程由程序员负责启动。<code>Thread</code>类中实例化的对象代表一个线程，继承后重写<code>run()</code>方法，将该线程的功能实现放在<code>run()</code>方法中，调用<code>Thread</code>类中的<code>start()</code>方法启动线程，<code>start()</code>方法会调用覆盖后的<code>run()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>Runnable</code>接口</p><p>第一种方法的缺陷在于：如果程序需要继承其他类而非<code>Thread</code>类，但Java是单继承语言，此时就无法通过该方式实现多线程，此时就需要采用第二种方法。创建<code>Runnable</code>对象后，将其传递给<code>Thread</code>类的构造方法，调用<code>start()</code>方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较疑惑的地方在于：Java中接口和抽象类是不能实例化的，即<code>Runnable</code>接口是不能实例化的，但是代码中却<code>new Runnable()</code>。这里实际上首先构造了一个<code>implements Runnable</code>的匿名内部类，然后构造了该类的一个实例，接着用<code>Runnable</code>表示该类的类型。</p><p>不使用匿名内部类： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;Hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test hello = new Test();</span><br><span class="line">        Thread thread = new Thread(hello);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>K-Nearest Neighbors</title>
      <link href="/2019/03/07/K-Nearest%20Neighbors/"/>
      <url>/2019/03/07/K-Nearest%20Neighbors/</url>
      
        <content type="html"><![CDATA[<p>k-NN可以做分类及回归，对新的测试实例t，在训练集中找与t<strong>最近</strong>的k个实例，用投票法决定t属于哪个类，显然这是一种懒惰学习。</p><p>既然要找最近的k个，就会涉及距离度量问题，下面以2个样本点（每个点有n个维度）间的距离为例枚举一些度量方式：</p><ol type="1"><li>Minkowski距离：<span class="math inline">\(\sqrt[p]{\sum_{i=1}^{n}|x_{1i}-x_{2i}|^p}\)</span>，p=1时是曼哈顿距离，p=2时是欧氏距离，<span class="math inline">\(p\to\infty\)</span>时是切比雪夫距离<span class="math inline">\(max_{i}|x_{1i}-x_{2i}|\)</span></li><li>标准欧式距离：为了克服欧氏距离各个维度数据粒度不一致对最终结果的影响，将每个维度标准化后采用欧氏距离的计算方法：<span class="math inline">\(y_{1i}=\cfrac{x_{1i}-u_i}{s_i}\)</span>，<span class="math inline">\(\sqrt{\sum_{i=1}^{n}(y_{1i}-y_{2i})^2}=\sqrt{\sum_{i=1}^{n}\cfrac{(x_{1i}-x_{2i})^2}{s_i^2}}\)</span></li><li>Mahalanobis Distance：修正了各维度之间的相关性及粒度不一致性 样本向量<span class="math inline">\(x\)</span>到均值向量<span class="math inline">\(u\)</span>之间的马氏距离： <img src="https://img-blog.csdnimg.cn/20210201184937356.png" alt="在这里插入图片描述" /> 样本向量<span class="math inline">\(x\)</span>到样本向量<span class="math inline">\(y\)</span>之间的马氏距离： <img src="https://img-blog.csdnimg.cn/20210201185035296.png" alt="在这里插入图片描述" /> 如果协方差矩阵是单位阵，即每个维度之间没有相关关系，即欧氏距离；如果协方差矩阵是对角阵，即标准欧氏距离</li><li>Bhattacharyya Distance：衡量概率分布的相似性， <span class="math inline">\(D_B(p,q)=-ln(BC(p,q)),BC(p,q)=\sum\sqrt{p(x)q(x)},BC(p,q)=\int\sqrt{p(x)q(x)}dx\)</span></li><li>余弦相似性</li><li>Jaccard Similarity Coefficient：衡量集合相似性：<span class="math inline">\(J(A,B)=\cfrac{|A\cap B|}{|A\cup B|}\)</span> Jaccard Distance：集合区分度：<span class="math inline">\(1-J(A,B)\)</span> 假设有4个二值维度，样例A={0111}，B={1011}，则<span class="math inline">\(J=\frac{M_{11}}{M_{01}+M_{10}+M_{11}},J^{&#39;}=1-J\)</span>，<span class="math inline">\(M_{11}\)</span>表示A和B中均为1的维度个数</li><li>Pearson Correlation Coefficient： 总体Pearson系数：<span class="math inline">\(\rho=\frac{Cov(X,Y)}{\sqrt{DXDY}}\)</span> 相关距离：<span class="math inline">\(1-\rho\)</span> 样本Pearson系数：<span class="math inline">\(r=\frac{\sum(X_i-\bar X)(Y_i-\bar Y)}{\sqrt{\sum(X_i-\bar X)^2\sum(Y_i-\bar Y)^2}}=\frac{1}{n-1}\sum(\frac{X_i-\bar X}{S_x})(\frac{Y_i-\bar Y}{S_y})\)</span></li></ol><p>除了距离度量，还有k的选择：k太小容易过拟合，k太大会使得与测试实例较远的训练样例也会起作用。</p><p>kNN的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearestNeighbor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">self, X, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; X is N*D &quot;&quot;&quot;</span></span><br><span class="line">        self.Xtr = X</span><br><span class="line">        self.ytr = y</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span>(<span class="params">self, X</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; X is N*D &quot;&quot;&quot;</span></span><br><span class="line">        num_test = X.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># make sure output type matches input type</span></span><br><span class="line">        Ypred = np.zeros(num_test, dtype = self.ytr.dtype)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_test):</span><br><span class="line">            distances = np.<span class="built_in">sum</span>(np.<span class="built_in">abs</span>(self.Xtr - X[i,:]), axis = <span class="number">1</span>)</span><br><span class="line">            min_index = np.argmin(distances)</span><br><span class="line">            Ypred[i] = self.ytr[min_index]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> Ypred</span><br></pre></td></tr></table></figure><p>为了加快预测速度，可以使用k-d tree来存储训练集，本质上也是一种平衡二叉树： 建树的过程可以递归进行：</p><ul><li>确定划分域：对训练集，统计每个维度的方差，选择方差最大的属性，意味着沿着该维度数据比较分散，容易获得较高的分辨率</li><li>确定结点：将数据集按照划分域排序，正中间的点选为结点</li><li>确定左(值小于父亲)右（值大于父亲）孩子</li><li>设置左右孩子的parent域</li></ul><p>往往训练样例的维度是很高的，所以很难每个维度都去分割，所以sklearn中的kNN如果用k-d tree实现，会有一个参数<code>leaf_size</code>控制树的深度。 建好后，就可以快速查找测试样例的邻居。</p><p>假设训练集为<span class="math inline">\(X_{m\times k}\)</span>，测试集为<span class="math inline">\(Y_{n\times k}\)</span>，此时需要计算训练集中每条样本与测试集中每条样本的距离，为了加速矩阵运算，不能使用循环，最终结果为<span class="math inline">\(R_{m\times n}=X\circ X+Y\circ Y-2XY^T\)</span>，具体推导可以参考<a href="https://zhuanlan.zhihu.com/p/146076139">NumPy之计算两个矩阵的成对平方欧氏距离</a>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW</title>
      <link href="/2019/03/06/INTERVIEW%20#1/"/>
      <url>/2019/03/06/INTERVIEW%20#1/</url>
      
        <content type="html"><![CDATA[<h2 id="数据对齐存储">数据对齐存储</h2><p>在32位系统中：int占4Bytes，short占2Bytes，char占1Byte，加起来应该是7Bytes，但是下面这段代码输出却是8。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">short</span> y;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>计算机对于基本类型数据在内存中的存储位置有些限制，即<strong>内存对齐</strong>。 处理器取数据一般不按照单个字节，而是双字节、四字节等进行，假设这种存取粒度为4Bytes，也就是说处理器只能从首地址为4的倍数的地址读取数据。如果没有对齐存储，取数据会很麻烦，可能需要两次读取并且剔除掉无用的字节。 每个编译器都有默认的对齐模数，那么<strong>有效对齐值=min{对齐模数，结构体中最长数据类型长度}。</strong> <strong>规则1：第一个成员offset为0，其后成员的offset=min{有效对齐值，该类型字节数}；</strong> <strong>规则2：结构体总大小必须为有效对齐值的整数倍，否则编译器会自动填充。</strong> 再看前面的例子，int占0<sub>3，short占4</sub>5，char占6，总长度为7，不是4的整数倍，所以地址7是填充字节，共8Bytes。</p><h2 id="栈-堆不是数据结构中的栈和堆">栈 &amp; 堆（不是数据结构中的栈和堆）</h2><ol type="1"><li>内存栈区 编译器自动进行分配和释放，存放局部变量、函数的参数等。 Windows下栈向低地址扩展，大小只有几MB，如果开一个很大的局部数组，就会提示stack overflow。</li><li>内存堆区 malloc或者new返回的内存区域，使用完需要用户free或delete，否则容易内存泄漏。如果程序员不释放，那么结束时由操作系统回收。 堆向高地址扩展，由于系统采用空闲链表存储空闲内存，所以是不连续的。系统在收到内存申请的请求后，会由低地址向高地址遍历空闲链表，找到第一个满足的空闲块，删除该结点，并将该块的首地址返回。如果分配的空间大于申请的，会将剩余部分重新链接回空闲链表。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Heap中开辟10Bytes，同时在Stack中压入p，p的值为10Bytes的首地址</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></li><li>常数区 存放字符串常量等，程序结束由系统回收。</li><li>静态区 存放全局变量或者静态变量，初始化的和没有初始化的分别存放在不同的区域，程序结束后由系统释放。</li><li>代码区 存放程序代码。 ## 其它 排序复杂度、人工智能概念、模型的建立等。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CC__ FAQ</title>
      <link href="/2019/03/04/CC__%20FAQ/"/>
      <url>/2019/03/04/CC__%20FAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="指针和引用">指针和引用</h2><ol type="1"><li>指针是一个新的变量，存储另一个变量的地址，可以通过指针修改另一个变量；引用是一个别名，对引用的操作就是对变量本身的操作。</li><li>指针可以有多级；引用只有一级。</li><li>指针的大小一般4B；引用的大小一般取决于被引用对象大小。</li><li>指针可以为空；引用不能为空。</li><li>传参选择：返回被调函数局部变量的内存时传指针，使用后及时释放避免内存泄漏；返回局部变量的引用没有意义，会自动销毁。传指针需要单独开辟内存；在对栈空间大小敏感时（如递归）传引用，无需创建临时变量，开销更小。类对象作为参数时传引用是C++传递类对象的标准方式。</li></ol><h2 id="空类">空类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sizeof(A) = 1</span></span><br></pre></td></tr></table></figure><p>空类的大小之所以为1，因为标准规定完整对象的大小&gt;0，否则两个不同对象可能拥有相同的地址，故编译器会生成1B占位符。 那么两个对象为什么不能地址相同呢？</p><blockquote><p>There would be no way to distinguish between these two objects when referencing them with pointers.</p></blockquote><p>空类中到底都有什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>();  <span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">A</span>(<span class="keyword">const</span> A&amp;);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">~<span class="built_in">A</span>();  <span class="comment">// 析构函数</span></span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;);  <span class="comment">// 赋值运算符</span></span><br><span class="line">A* <span class="keyword">operator</span>&amp;();  <span class="comment">// 取址运算符（非const）</span></span><br><span class="line"><span class="keyword">const</span> A* <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;  <span class="comment">// 取址运算符（const）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>仅仅声明一个类，不会创建这些函数。只有当定义类的对象时，才会产生。 ## 多态和虚函数 面向对象的语言的特点就是封装、继承和多态。封装和继承都比较好理解，那么多态到底什么意思？ 简单来说：不同对象接收相同的消息产生不同的行为。 C++中的多态分为静态多态(函数和运算符重载)和动态多态(继承和虚函数)。 定义虚函数<code>f</code>，是为了用基类的引用或指针调用派生类的<code>f</code>，最终调用哪个<code>f</code>取决于传入的实参，即在运行时选择函数的版本，也就是所谓的动态绑定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;  <span class="comment">// 覆盖Base::f</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Derived&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Base* p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">p-&gt;<span class="built_in">f</span>();  <span class="comment">// 调用派生类的f()</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基类指针<code>p</code>调用虚函数<code>f</code>，<code>f</code>作用的可能是基类对象，也可能是派生类对象，这就是多态（同样消息作用于不同类型对象产生不同的行为）的一种方式，即动态多态。 正因为编译器无法确定使用哪个虚函数，所以所有的<strong>虚函数必须定义</strong>，否则编译器会报错。</p><p>构造函数不能是虚函数，因为构造对象时必须明确知道其类型。如果是虚函数，调用时只需要提供接口，编译器无法知道你想构造继承树的哪个类型。 C++他爹Bjarne Stroustrup是这么说的： &gt; A virtual call is a mechanism to get work done given partial information. In particular, "virtual" allows us to call a function knowing only an interfaces and not the exact type of the object. To create an object you need complete information. In particular, you need to know the exact type of what you want to create. Consequently, a "call to a constructor" cannot be virtual.</p><p>析构函数是虚函数，因为要确保执行相应对象的析构函数。如果基类指针指向派生类对象，会调用派生类的析构函数，然后调用基类的析构函数。 <img src="https://img-blog.csdnimg.cn/20200229202936650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ## 纯虚函数 与虚函数必须定义相反，纯虚函数无须定义（要定义必须在类的外部），含有纯虚函数的类是<strong>抽象基类</strong>。 抽象基类定义好接口，继承该类的其他类可以覆盖这个接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 声明纯虚函数</span></span><br></pre></td></tr></table></figure><p>之所以要引入纯虚函数，是因为很多时候基类产生对象是没有意义的。比如动物类可以派生出狗、猪等子类，但动物类生成对象毫无意义。 因此，不能创建抽象基类的对象，派生类必须覆盖(override)以定义自己的<code>f</code>，否则派生类仍然是抽象基类。 ## 重载&amp;覆盖&amp;重写</p><ul><li>重载(overload)：在类内部发生。函数名相同，参数个数、参数类型、参数顺序至少有一种不同。返回值类型可以相同，也可不同；</li><li>覆盖(override)：覆盖基类的虚函数。函数名相同，参数相同，基类函数必须是虚函数；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span>B &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;  <span class="comment">// 正确：f1与基类中的f1匹配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：B没有形如f2(int)的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：f3不是虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：B没有名为f4的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>重写(overwrite)：派生类的函数屏蔽了同名的基类函数： 派生类函数与基类函数同名，参数不同。不论基类函数是否为虚函数，都会被隐藏； 派生类函数与基类函数同名，参数相同。基类函数不为虚函数，会被隐藏； ## static C++中<code>static</code>关键字用来<strong>声明类的成员</strong>：</p></li><li><p>类的静态成员变量或函数属于类而非对象，只有一份副本；</p></li><li><p>静态成员函数没有<code>this</code>指针，只能访问类的静态数据；</p></li><li><p>静态成员函数不能定义为虚函数；</p></li><li><p>静态成员变量初始化<code>int Base::name = 0</code></p></li></ul><p>如果不是在类中声明成员，还有下面用法：</p><ul><li><p>隐藏作用：多文件编译时，定义的全局变量和函数都是整个工程可见的，只要使用时加上<code>extern</code>关键字即可。如果加上<code>static</code>关键字，那么该变量或函数就变为<strong>仅当前文件</strong>可见，这样我们可以在不同文件中定义同名的变量或函数而不用担心冲突。</p></li><li><p>全局生存期：<code>static</code>变量存储在静态数据区，默认值为0，<strong>只被初始化一次</strong>，即使作为局部变量，生存期也为整个程序，但作用域与普通变量相同，退出函数后即使变量存在，但不能使用。 ## const</p></li><li><p>定义const对象：一旦创建其值不能改变，故const对象必须初始化。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> bufSize = <span class="number">512</span>;  <span class="comment">// the same as the previous one</span></span><br></pre></td></tr></table></figure><p>由于const对象默认只在文件内有效，所以如果要在文件间共享：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp定义并初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>;</span><br><span class="line"><span class="comment">// file1.h可以仅声明，不初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;</span><br></pre></td></tr></table></figure><ul><li>常量指针（const pointer）：指针本身（存在指针中的地址）不可变。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;num;  <span class="comment">// p将一直指向num</span></span><br></pre></td></tr></table></figure><ul><li>指向常量的指针（pointer to const）：指针指向的对象不可变。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span>* p = &amp;pi;  <span class="comment">// 错误，p是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span>* p = &amp;pi;  <span class="comment">// 正确</span></span><br><span class="line">*p = <span class="number">4.1</span>;  <span class="comment">// 错误，不能改变*p的值 </span></span><br></pre></td></tr></table></figure><ul><li>修饰成员函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 不能改变数据成员，const对象不能调用非const成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>修饰类对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A obj;  <span class="comment">// obj为常量对象，任何成员都不能被修改，任何非const成员函数都不能被调用</span></span><br><span class="line">obj.<span class="built_in">f1</span>();  <span class="comment">// 错误</span></span><br><span class="line">obj.<span class="built_in">f2</span>();  <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A* obj  = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">obj-&gt;<span class="built_in">f1</span>();  <span class="comment">// 错误</span></span><br><span class="line">obj-&gt;<span class="built_in">f2</span>();  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><ul><li>转为非const</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pc;  <span class="comment">// pc指向内容不可变</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);  <span class="comment">// 正确，但是通过p写值是未定义行为</span></span><br></pre></td></tr></table></figure><h2 id="类型转换">类型转换</h2><p>类型转换分为隐式转换和显式转换。 显式转换有四种：</p><ul><li><code>static_cast</code> 没有底层const都可以，使用比较普遍。 基类-&gt;派生类：不安全 主要执行非多态转换，代替C中的转换。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = &amp;d;</span><br><span class="line"><span class="keyword">double</span>* dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure><ul><li><code>dynamic_cast</code> 运行时类型检查， 将基类指针或引用安全转换为派生类的指针或引用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type是类，且有虚函数</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type*&gt;(e);  <span class="comment">//e是指针</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e);  <span class="comment">//e是左值</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e);  <span class="comment">//e不是左值</span></span><br></pre></td></tr></table></figure><ul><li><code>const_cast</code> 改变底层const。 常量指针转为非常量指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cp;</span><br><span class="line"><span class="keyword">char</span>* q = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// wrong, static_cast不能用于底层const</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><code>reinterpret_cast</code> 比较危险，不太用。处理无关类型转换，重新解释对象的比特模型。 ## new/delete/malloc/free <code>new/delete</code>是C++运算符，需要编译器支持，所以不需要指定大小，返回相应对象类型的指针，分配失败会抛出<code>std::bad_alloc</code>异常，<code>new</code>会调用<code>operator new()</code>申请内存(用<code>malloc</code>实现)，调用构造函数初始化成员变量，返回相应指针，<code>delete</code>先调用析构函数，再调用<code>operator delete()</code>函数释放内存(用<code>free</code>实现)； <code>malloc/free</code>是库函数，不由编译器控制，需要显式指出大小，返回<code>void*</code>，需要强制类型转换，分配失败返回<code>NULL</code>指针，无法完成对象的构造和析构。</li></ul><h2 id="智能指针">智能指针</h2><p><code>new</code>完后没有<code>delete</code>，内存泄漏。为了减少程序员的负担，引入智能指针：</p><ul><li><code>shared_ptr</code> 允许多个指针指向同一个对象。通常与<code>make_shared</code>函数结合食用：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p = make_shared&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br></pre></td></tr></table></figure><p>实现方式一般是reference counting，在堆上申请资源并返回指针后，在堆上申请一个共享的引用计数器，每来一个指针指向该对象，++计数器。当计数器为0时，会自动释放指向的对象。 2个指针成员，一个指向对象，一个指向计数器 面试有可能被要求手撕一个： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySharePtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">mySharePtr</span>() :<span class="built_in">refCnt</span>(<span class="literal">nullptr</span>), <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySharePtr</span>(T* res) :<span class="built_in">refCnt</span>(<span class="literal">nullptr</span>), <span class="built_in">ptr</span>(res) &#123;</span><br><span class="line"><span class="built_in">add</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySharePtr</span>(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; p) :<span class="built_in">refCnt</span>(p.refCnt), <span class="built_in">ptr</span>(p.ptr) &#123;</span><br><span class="line"><span class="built_in">add</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">mySharePtr</span>() &#123;</span><br><span class="line"><span class="built_in">remove</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lvalue is assigned, --counter</span></span><br><span class="line">mySharePtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; that) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;that) &#123;</span><br><span class="line"><span class="built_in">remove</span>();</span><br><span class="line"><span class="keyword">this</span>-&gt;ptr = that.ptr;</span><br><span class="line"><span class="keyword">this</span>-&gt;refCnt = that.refCnt;</span><br><span class="line"><span class="built_in">add</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; other) &#123;</span><br><span class="line"><span class="keyword">return</span> ptr == other.ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; other) &#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">operator</span>==(other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRef</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line"><span class="keyword">return</span> *refCnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// if null, create counter = 1, else ++counter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">++(*refCnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">refCnt = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --counter, if counter = 0, free memory</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">--(*refCnt);</span><br><span class="line"><span class="keyword">if</span> (*refCnt == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> refCnt;</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">refCnt = <span class="literal">nullptr</span>;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span>* refCnt;</span><br><span class="line">T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li><code>unique_ptr</code> 看名字就知道，独占对象。 ##指针和引用 引用只是一个别名，不是一种数据类型，不占存储空间，不能建立数组的引用 引用必须初始化，指针不必 引用初始化后不能改变，指针可以改变指向的对象 不存在指向空值的引用，存在指向空值的指针 ## 成员变量初始化顺序 基类静态变量/全局变量：静态成员变量必须类外初始化 派生类静态变量/全局变量 基类成员变量：按照在类中定义的顺序，而不是初始化列表中的顺序 派生类成员变量 ## TODO 初始化列表好处： 1、const成员变量只能 2、引用只能 3、效率：初始化列表比赋值操作少一次默认构造函数，因为程序要默认构造临时对象（等号右边）后才能赋值</li></ul><p>函数缺省： 某个参数有默认值，缺省参数仍在后边 调用时如果略去一个参数传递，则略去后面所有</p><p>异常处理： 抛出异常，没有被特定的catch语句捕获，函数调用堆栈会被解退（函数终止，销毁局部变量，控制权转到调用它的那个函数）， 并在下一个外层try..catch捕获，最后没有任何catch捕获，调用terminate，abort退出。</p><p>传参时传引用与传指针效果相同 传引用，没有产生实参的副本，直接对实参操作 传指针，被调函数需要给形参分配空间，可读性差，需要传地址做实参，传引用更简单清晰</p><p>预处理、编译、汇编、链接</p><p>操作系统 * 用户告诉操作系统执行hello程序 * 操作系统到硬盘找到该程序 * 由编译程序将用户源程序编译成若干个目标模块 * 由链接程序将目标模块和相应的库函数链接成装入模块 * 操作系统分配内存，由装入程序将装入模块装入内存 * 为执行hello程序创建执行环境（创建新进程） * 操作系统设置CPU上下文环境，并跳到程序开始处 * 程序的第一条指令执行 * 程序执行与printf对应的系统调用 * 操作系统分配设备 * 执行显示驱动程序 * 窗口系统将像素写入存储映像区</p><pre><code>（1）每个节点或者是黑色，或者是红色。</code></pre><p>　　(2)根节点是黑色。</p><p>　　(3)每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p><p>　　(4)如果一个节点是红色的，则它的子节点必须是黑色的。</p><p>　　(5)从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。[这里指到叶子节点的路径]</p><p>模板特化、偏特化 内存池</p><p>volatile： 加volatile的关键字不进行编译器优化，保证对特殊地址的稳定访问 不能把他放在cache或寄存器中重复使用 防止优化编译器把变量从内存装入 CPU 寄存器 两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行</p><p>拷贝构造： 创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象 通过使用另一个同类型的对象来初始化新创建的对象。 复制对象把它作为参数传递给函数。 复制对象，并从函数返回这个对象。</p><p>map key类型：必须支持&lt;运算符</p><p>数据库缓存一致： 并发操作导致不一致，本质上修改数据库和删除缓存耦合在一起，使得其他操作有可能读出脏数据 解决方案：解耦，延迟双删：写-&gt;删缓存-&gt;修改数据库-&gt;延时-&gt;再次删缓存 二：内存队列：写修改数据库，将数据id放入队列，消费者线程消费即可</p><p>浏览器： DNS解析（DNS缓存、OS缓存、路由器缓存、递归搜索）、尝试建立TCP连接、发送HTTP请求(get)、服务器处理请求（查询） 返回HTML，浏览器解析渲染、关闭TCP连接</p><p>线性探测、拉链、再哈希、公共溢出区</p><p>UDP对实时性要求高，数据准确性要求不是太高的场合、视频通话、QQ主要UDP为主，TCP为辅 ## Resource <a href="https://en.cppreference.com/w/">cppreference</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>INTERVIEW</title>
      <link href="/2019/02/28/INTERVIEW%20#0/"/>
      <url>/2019/02/28/INTERVIEW%20#0/</url>
      
        <content type="html"><![CDATA[<h2 id="造成网络延迟的可能原因">造成网络延迟的可能原因</h2><p>1，WiFi所有用户上下行流量共用一个信道，当用户太多或者有人在下载大的资源时带宽不够，丢包； 2，线路质量不佳导致信噪比太低，比如光纤损耗太大等。</p><h2 id="ipv6优势">IPv6优势</h2><p>1，IPv4地址不够用，IPv6有<span class="math inline">\(2^{128}\)</span>个地址； 2，使用更小的路由表，转发速度更快； 3，扩充了DHCP协议，支持自动配置；安全性更高，有更好的头部格式，允许扩容......</p><h2 id="找到单向无环链表的中间元素若结点总数为偶数返回第二个元素">找到单向无环链表的中间元素，若结点总数为偶数，返回第二个元素</h2><p><a href="https://leetcode.com/problems/middle-of-the-linked-list/">leetcode类似题目</a></p><p>只扫描一遍的做法：设两个指针，初始指向头结点，p1每次走两步，p2每次走一步，p1到达链尾，p2到达中间。假设链表带有头结点。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*单链表定义*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode* next;</span><br><span class="line"><span class="built_in">ListNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode * <span class="title">middle</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">ListNode* fast = head;</span><br><span class="line">ListNode* slow = head;</span><br><span class="line"><span class="keyword">while</span> (fast &amp;amp;&amp;amp; fast-&amp;gt;next)</span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&amp;gt;next-&amp;gt;next;</span><br><span class="line">slow = slow-&amp;gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="给出四个点坐标判断是否是凸四边形">给出四个点坐标，判断是否是凸四边形</h2><p>不妨扩展下该问题，给出任意n个点，判断<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2108">是否凸多边形</a>。</p><p>凸多边形就是所有内角均小于180°，方法有好几种，这里利用定点凹凸性判断： 设当前三个连续的顶点<span class="math inline">\(P_0, P_1, P_2\)</span>，计算向量<span class="math inline">\(P_0P_1\)</span>, <span class="math inline">\(P_1P_2\)</span>的叉积，若结果为正，表示多边形顶点逆时针转；若结果为负，两向量夹角大于180°，则为凹多边形。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;p[<span class="number">600000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cross_p</span><span class="params">(point a, point b,point c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b.x - a.x) * (c.y - b.y) - (c.x - b.x) * (b.y - a.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isConvex</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//叉积量值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cross_p</span>(p[i], p[(i + <span class="number">1</span>) % n], p[(i + <span class="number">2</span>) % n]) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isConvex</span>(n))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;convex\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;concave\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="两个位数在10万位以内的数乘法">两个位数在10万位以内的数乘法</h2><p><a href="https://leetcode.com/problems/multiply-strings/">高精度</a></p><p>高精度乘法，模仿我们笔算的过程。每一位<span class="math inline">\(res[i + j]\)</span>的构成：<span class="math inline">\(res[i + j] + carry + a[i] * b[j]\)</span>，注意去掉结果的前导0。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">120</span>], b[<span class="number">120</span>], res[<span class="number">250</span>];</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">        <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lena = num1.<span class="built_in">size</span>(), lenb = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lena; i++)</span><br><span class="line">            a[i] = num1[lena - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenb; i++)</span><br><span class="line">            b[i] = num2[lenb - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenb; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lena; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i + j] = res[i + j] + a[j] * b[i] + carry;</span><br><span class="line">                carry = res[i + j] / <span class="number">10</span>;</span><br><span class="line">                res[i + j] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i + lena] = carry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len_res = lena + lenb;</span><br><span class="line">        <span class="comment">//去掉结果的前导0,若结果为0，保留一个0</span></span><br><span class="line">        <span class="keyword">while</span> (res[len_res - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; len_res &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len_res--;</span><br><span class="line">        &#125;</span><br><span class="line">        　　　　　　　<span class="comment">//使用字符串流将整数转为字符串</span></span><br><span class="line">        stringstream ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len_res - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            ans &lt;&lt; res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="其它">其它</h2><p>1，操作系统：CPU调度，用户态&amp;内核态，IPC，各种锁，实时系统； 2，数据结构：判断有向图是否存在回路（拓扑排序、求最短路、关键路径、BFS），排序（快排、冒泡、选择、插入），链表是否有环； 3，计网：ARP、TCP/UDP、NAT、802.11ac协议，ping过程； 4，C++多态。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统 FAQ</title>
      <link href="/2019/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20FAQ/"/>
      <url>/2019/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20FAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="进程和线程">进程和线程</h2><ol type="1"><li>联系: 线程存在于进程内部, 一个进程可以有多个线程, 一个线程只能属于一个进程.</li><li>区别: 进程是运行时程序的封装, 是系统进行资源分配和资源调度的基本单位; 线程是进程的子任务, 是CPU分配和调度的基本单位. 进程创建需要系统分配内存, CPU和文件句柄等资源, 销毁时要进行相应的回收, 因此进程的管理开销大; 线程开销小. 进程间不会互相影响; 一个线程崩溃会导致进程崩溃, 从而影响其他线程. ## 进程调度算法</li><li>先来先服务(FCFS): 按照到达任务队列的顺序调度, 非抢占式, 易于实现, 效率低性能差, 有利于CPU繁忙型作业(长作业)不利于IO繁忙型(短作业).</li><li>短作业优先(SJF): 每次从任务队列选择预计时间最短的作业运行, 非抢占式, 性能最优, 平均周转时间最低, 吞吐量大, 不利于长作业, 会出现饥饿现象, 完全未考虑作业的优先级, 不能用于实时系统.</li><li>最短剩余时间优先: 首先选择预计时间最短的作业运行, 如果新作业服务时间小于当前作业的剩余时间, 抢占CPU.</li><li>高响应比优先: 在后备作业队列中选择响应比最高的, 非抢占式, 需要计算响应比耗费资源. <span class="math inline">\(响应比=1+\frac{等待时间}{服务时间}\)</span></li><li>时间片轮转(RR): 可以响应所有用户的请求, 适于分时系统.</li><li>多级反馈队列: UNIX使用的调度算法. 多个不同优先级的队列按照RR调度, 如果未完成就进入下一优先级, 新来进程可以根据优先级抢占. ## 死锁</li><li>原因: (1) 系统资源不足; (2) 进程推进顺序不当; (3) 资源分配不当.</li><li>必要条件: (1) 互斥访问: 一个资源每次只能被一个进程访问; (2) 占有并请求: 进程因请求资源阻塞时对已占有的资源保持不放; (3) 不可剥夺: 进程已经获取的资源不能被强制剥夺; (4) 循环等待: 多个进程间形成资源的循环等待关系.</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Computer Science Roadmap</title>
      <link href="/2019/02/15/Computer%20Science%20Roadmap/"/>
      <url>/2019/02/15/Computer%20Science%20Roadmap/</url>
      
        <content type="html"><![CDATA[<p>有感于国内令人发指的CS教育（尤其某校的计算机基本就是一堆SB在自嗨自娱自乐而已），决定自学为主。 主要资源是四大的比较完整的课程：video+reading+lab - <a href="https://github.com/prakhar1989/awesome-courses">Awesome CS Courses</a> - <a href="https://conanhujinming.github.io/comments-for-awesome-courses/">名校公开课程评价网</a> - <a href="https://teachyourselfcs.com/">Teach Yourself Computer Science</a> - <a href="https://github.com/huangrt01/CS-notes">RT Huang的自学笔记</a> - <a href="https://learn-sys.github.io/">LEARNSYS</a> - <a href="https://github.com/ossu/computer-science">OSSU</a> - <a href="https://www.zhihu.com/question/308850392/answer/1324509357">如何学习设计模式？</a></p><p>video比较费时间，而且我看视频总是来不及反应，好像不太适合我，所以一般只在看不懂材料时去针对性地看看视频。（当然一些讲得非常好的视频除外）</p><hr /><h2 id="basics">Basics</h2><ul><li><strong>Programming Languages</strong>: 精通C，熟悉1~2门(Java/Python/C++/Go)，了解一门(Haskell/Rust/)，掌握debug技巧</li><li><strong>Tools/Frameworks</strong>: 熟悉Linux系统的各项操作，最好看下源码，掌握Git等工具和框架</li><li><strong>Math</strong>: Linear Algebra/Probability/Statistics/Combinatorial Mathematics/Discrete Mathematics/Calculus 现用现学</li><li><strong>Core Courses</strong>: DS/Algorithms/OS/Organization/Network/DB</li></ul><h2 id="coding-interview">Coding Interview</h2><p>这方面<strong>很弱很弱</strong>，要勤奋练习，经常性在blog<strong>分析总结</strong>，<strong>穿透做过的题目及变种</strong>。</p><p>不要抱着可能撞到原题的心态去准备，反复练习提升自己的能力，需要有较多的训练量。</p><p><strong>Python快速过，Java也行，千万不要用C++浪费生命！！！</strong></p><p>复杂度最优，Google Doc/白纸练习，Bug-Free easy 5min medium 10~15min hard 15~20min</p><p>G实习：中文2轮：45min, 自我介绍+warm-up+hard, 1~2道medium题，白板 G校招：4轮（3中+1英），同上</p><ul><li><strong>Data structure</strong>：哈希表、堆、AVL、链表动手实现一遍，B树啥的都能扯扯~</li><li><strong>Algorithms</strong> <a href="https://leetcode-cn.com/problemset/lcof/">《剑指offer》</a> 67/67 <a href="https://leetcode-cn.com/problemset/lcci/">Cracking the Coding Interview</a> 40+/109 <a href="https://leetcode.com/">Leetcode</a> 310+/700+ <a href="https://www.nowcoder.com/">牛客笔试题</a></li><li><strong>System design</strong></li></ul><h2 id="projectspaper">Projects/Paper</h2><p><strong>选一个前沿的、不太讨厌的方向，研究研究，做点小项目</strong>，具体的方向可以参考<a href="http://csrankings.org/">CSRankings</a></p><ul><li>实习项目</li><li>学校大作业</li><li>兴趣项目：AutoML-ID, CMU 15-319, CS231n的3个小项目</li><li>开源项目</li></ul><h2 id="others">Others</h2><ul><li>GPA/数学/英语</li><li>比赛奖项</li><li>沟通交流能力</li><li>面试技巧 面经技巧只是锦上添花，最重要的还是及格的实力。nothing replaces hard work. 面经是告诉你这家公司面试的时候喜欢问哪些知识，而不是告诉你他们喜欢问哪些特定的问题。 更是一次需要充满着沟通与交流的谈话，让面试官认为他/她愿意成为你的同事</li></ul><p><strong>关于项目</strong> 背景主要包括场景、问题定义、需求、自己负责的部分扮演的角色等等。 指出项目中的困难点和解决方案</p><p><strong>关于paper</strong>：research的背景</p><p><strong>关于做题</strong> 1. 问清题目：数据范围是多少？这个数组的大小范围是多少？能不能给个样例？如果输入是这个，那输出应该是什么 2. 确认函数签名 3. 确认思路：修改输入数据 4. 确认corner case处理方式 5. 编码过程中不断交流 6. 主动测试：写完后不要急于告诉面试官写完了，手动跑一个样例：在屏幕上写出中间变量的当前取值，然后用鼠标光标告诉面试官现在程序跑到了哪一行代码，当前各个变量的取值是多少等等 7. 主动分析复杂度 8. 讨论算法的trade-off</p><p><strong>关于其它</strong> 先拿一些自己不target的公司练练手 虽然我不太懂，但是可以试着说一下 说出自己的insight:cache不友好 获得监督信息与正反馈 模拟面试</p><h2 id="how-to-learn">How to learn</h2><p>It is very important to take classes around my future work. It doesn't matter you learn it slowly, the most important part is that you <strong>take it seriously</strong> and build a <strong>solid foundation</strong>. 根据大佬们的经验，一门课大概要花150-300小时，每天2小时至少也要2个半月，所以千万千万不要着急，不要急于求成，总想着完成任务，多多反思自己到底学到了什么？真的透彻地理解了吗？又有多少内化到自身的知识体系？ 还有就是最好按照他们的课表时间上课，同时上的课最好不要超过2门（经过血泪实践，我只能1门单线程┭┮﹏┭┮，他们课程内容实在太充实了...，然后自己还有一堆屁事...）</p><p><strong>严格遵守学术规范</strong>，独立完成之后可以参考别人，修正自己。</p><p>Recently I've changed my way to learn new things. Previously I just wanted to understand the new things and tried to memorize all the details of a specific problem, or just translated others' materials into my words, which melted my brain and showed a very low efficiency. The reason why I learn things this way (passively) is mostly due to the Chinese's cramming education. But for me, heuristic teaching (actively) is more appropriate. The specific problem/model/algorithm is important, but the <strong>motivation</strong> is much more important. <strong>Everything has its motivation.</strong> So I decide to write my blogs with the following components:</p><ol type="1"><li>Motivation: What problems do we meet? Why propose this one?</li><li>Details: Mathematical derivation or tricky things.</li><li>Example: Use a handy example to illustrate.</li><li>Implementation: Code it out or use it to <strong>solve the problem</strong>.</li><li>Properties: <strong>When</strong> should/can we use the method? When shouldn't/can't? <strong>Why</strong>? What's the benefits and drawbacks if we use it?</li><li>Can we make some improvements on the off-the-shelf method for a specific problem?</li></ol><h2 id="todo-done-list">TODO &amp; DONE LIST</h2><p>Count the courses I've taken so far: 1. Introduction to Computer Science. Harvard University "This is CS 50". It should be the first class of CS rather than Haoqiang Tan's C Programming Language. 2. Linear Algebra. Massachusetts Institute of Technology If you want to learn Linear Algebra, just follow this one and you'll be fine. 3. Mathematics for Computer Science. Massachusetts Institute of Technology Very interesting course but I only took several lectures. SAD~ 4. Data Structures. University of California, Berkeley Strong recommend for Data Structure. You'll pick up Java from the interesting projects. 5. Introduction to Computer Systems. Carnegie Mellon University If you only want to take one system course, then select this one. But I haven't finished the whole lectures and labs. SAD again~ 6. Introduction to Database Systems. Carnegie Mellon University Hard for me. Just finished lab1. I'll come back one day~ 7. Machine Learning. Stanford University It's almost the first course I took after I found the true CS courses. But I forgot a lot. Sorry Andrew~ 8. Positive Psychology. Harvard University When I start to be anxious or depressed I'll go and find the lecture. Tal is an amazing teacher and I'm sure you'll become happier. 9. Convolutional Neural Networks for Visual Recognition. Stanford University High quality, especially its readings.</p><p>CS144 + Go + CS5412 + 6.828 + 6.824 + 6.031 + SICP + 6.033 + CS262</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP 3-Way Handshake</title>
      <link href="/2019/01/04/TCP%203-Way%20Handshake/"/>
      <url>/2019/01/04/TCP%203-Way%20Handshake/</url>
      
        <content type="html"><![CDATA[<p>TCP是面向连接的协议，其数据传输过程分为建立连接、数据传送、释放连接三个阶段。 ## 0 建立连接 建立连接的过程也就是常说的“三次握手”：</p><ul><li><p>客户端向服务器端发送一个SYN报文（SYN=1表示这是一个连接请求或连接接收报文），并随机选取一个起始序号x；</p></li><li><p>服务器端应答一个SYN报文，同时ACK（确认位）置1【ACK=1时TCP报文段首部中的ack（确认号字段）才有效】，随机选取一个服务器端的起始序号y，并将ack字段设为x+1，表示已经收到客户端发来的SYN报文，期待收到序号为x+1的下一个报文；</p></li><li><p>客户端应答一个ACK报文，将序号设为x+1，并且ack字段设为y+1，表示已经收到服务器端的SYN报文，期待收到序号为y+1的下一个报文。 <em>注：序列号seq也称ISN(Initial Sequence Number)</em> <img src="https://img-blog.csdnimg.cn/20190920214108996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="图片来自百度" /> 之所以要采用三次握手机制而不是两次或四次，要从握手机制的目的说起： 握手主要是为了确认<strong>双方的发送、接收能力</strong>是否正常，顺带初始化序号seq，为以后的数据传送做好准备，所以： 第一次握手：服务器收到客户端发来的网络包，<strong>服务器就明白</strong>客户端的发送能力、服务器的接收能力正常； 第二次握手：服务器发包，客户端收到后，<strong>客户端就明白</strong>服务器的发送、接收，客户端的发送、接收都是正常的； 二次握手后，客户端倒是全明白了，但是<strong>服务器端无法确认客户端能否正常接收、服务器是否正常发送</strong>，所以两次握手不够； 第三次握手：服务器收到客户端发送的网络包，服务器确认了自己上次的发送正常、客户端接收也正常，所以四次握手是多余的。 ## 1 补充问题</p></li><li><p>序列号(ISN)之所以随机生成，是为了避免被攻击（若固定，则下一次传送的ack就显而易见）；</p></li><li><p>前两次握手不可以携带数据，第三次可以携带。第一次握手服务器端接收能力未知，如果携带数据就可能丢失。第二次客户端接收能力未知，如果携带数据也可能丢失。第三次客户端知道服务器接收正常，并且自己已经处于ESTABLISHED状态；</p></li><li><p>服务器发出SYN报文后，处于SYN-RCVD状态，此时不同的连接请求会被放在<strong>半连接队列</strong>里，三次握手完成后的连接请求被放在<strong>全连接队列</strong>里。</p></li></ul><h2 id="连接释放">2 连接释放</h2><p>连接释放的过程也就是常说的“四次挥手”： P.S. <em>图中以客户端发起释放请求为例</em></p><ol type="1"><li>客户端发送释放请求，将FIN（终止位）置1，表示客户端已经发完数据，请求释放；</li><li>服务器发一个ACK报文，确认号ack为u+1，这时从客户端到服务器的连接被释放，处于<strong>半关闭状态</strong>；</li><li>如果服务器也要断开连接，就向客户端发送连接释放报文（FIN=1）；</li><li>客户端发送一个应答报文，序列号seq为u+1，等待一段时间（2MSL）确保服务器收到ACK报文，之后关闭连接。</li></ol><p><img src="https://img-blog.csdnimg.cn/20190920223118842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="图片源自百度" /> 客户端之所以要等待2MSL时间才关闭，有两个原因：</p><ul><li>一旦服务器没有收到ACK报文，服务器就会重发FIN报文，客户端再次收到FIN报文，就知道之前发送的ACK报文丢失，会重置时间等待计时器为2MSL并重传ACK报文。 如果没有这段等待时间，万一服务器没有正常接收ACK报文，接下来重传的FIN报文段就无法到达客户端，服务器无法正常关闭。</li><li>客户端发完最后一个ACK报文，经过2MSL，本次连接产生的报文都会从网络中消失，避免下一次新连接出现本次旧的连接请求报文段。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell Sort</title>
      <link href="/2019/01/03/Shell%20Sort/"/>
      <url>/2019/01/03/Shell%20Sort/</url>
      
        <content type="html"><![CDATA[<h2 id="思想">思想</h2><p>希尔排序(Shell Sort)是基于插入排序的一种<strong>不稳定</strong>排序方法。 1，将整个序列分为h个子序列； 2，第一趟将每个子序列进行插入排序； 3，第二趟将增量缩小，重复2； 4，直至增量为1，就是简单插入排序。</p><p>eg: <img src="https://img-blog.csdn.net/20180707130824188?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" /> <img src="https://img-blog.csdn.net/20180707130836718?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" /> ## 实现 ##</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 100</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int a[MAXSIZE + 1];  //a[1]~a[MAXSIZE]存储元素</span><br><span class="line">int length;</span><br><span class="line">&#125;Sqlist;</span><br><span class="line"></span><br><span class="line">/*升序排列*/</span><br><span class="line">void Shell_Sort(Sqlist* L)</span><br><span class="line">&#123;</span><br><span class="line">int h = 1;</span><br><span class="line">while (h &lt; L-&gt;length / 3)</span><br><span class="line">h = 3 * h + 1;         //增量取值</span><br><span class="line">while (h &gt;= 1)</span><br><span class="line">&#123;</span><br><span class="line">//从增量的那组进行插入排序</span><br><span class="line">for (int i = h; i &lt;= L-&gt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line">int j = i;</span><br><span class="line">int get = L-&gt;a[j];</span><br><span class="line">//同组元素中与其前一个比较</span><br><span class="line">while (j - h &gt;= 0 &amp;&amp; L-&gt;a[j - h] &gt; get)</span><br><span class="line">&#123;</span><br><span class="line">L-&gt;a[j] = L-&gt;a[j - h];</span><br><span class="line">j = j - h;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;a[j] = get;</span><br><span class="line">&#125;</span><br><span class="line">h = h / 3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">Sqlist L;</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d&quot;, &amp;(L.length));</span><br><span class="line">for (int i = 1; i &lt;= L.length; i++)</span><br><span class="line">scanf(&quot;%d&quot;, &amp;(L.a[i]));</span><br><span class="line"></span><br><span class="line">Shell_Sort(&amp;L);</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt;= L.length; i++)</span><br><span class="line">printf(&quot;%d &quot;, L.a[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度">复杂度</h2><p>希尔排序最优时间复杂度<span class="math inline">\(O(n)\)</span>，最差情况下也突破了平方级别的运行时间。 对于最差情况，之前的冒泡、选择要消除逆序，采用交换相邻元素的方法，也就是每次只能消除一个逆序，那么希尔每次交换隔得很远的元素，每次可以消除多个逆序，这样就节省了大量的交换时间。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 FAQ</title>
      <link href="/2019/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20FAQ/"/>
      <url>/2019/01/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20FAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="tcp连接">TCP连接</h2><p>建立TCP连接的过程需要使用一些系统调用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Notations</title>
      <link href="/2018/12/24/Notations/"/>
      <url>/2018/12/24/Notations/</url>
      
        <content type="html"><![CDATA[<p>下面四种记号是为了建立函数间的相对级别。 CLRS上的一张图很直观： <img src="https://img-blog.csdn.net/20180517130818654" alt="这里写图片描述" /></p><h2 id="大o记号"><strong>大O记号</strong></h2><p>定义：如果存在正常数<span class="math inline">\(c\)</span>和<span class="math inline">\(n_0\)</span>，使得当<span class="math inline">\(N\ge n_o\)</span>时<span class="math inline">\(T(N)\le cf(N)\)</span>，记<span class="math inline">\(T(N)=O(f(N))\)</span>。</p><p>举个栗子： 当<span class="math inline">\(N &lt; 1000\)</span>时，<span class="math inline">\(1000N\gt N^2\)</span>，但<span class="math inline">\(N^2\)</span>增长率更大，所以最终<span class="math inline">\(N^2\)</span>会更大，即<span class="math inline">\(O(N^2)=1000N\)</span>。</p><p>也就是说，总会存在某个点<span class="math inline">\(n_0\)</span>，从这个点以后<span class="math inline">\(cf(N)\)</span>至少和<span class="math inline">\(T(N)\)</span>一样大，忽略常数因子，即<span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>小于等于<span class="math inline">\(f(N)\)</span>的增长率。</p><p>那么为什么这个常数因子<span class="math inline">\(c\)</span>可以忽略呢？ 当<span class="math inline">\(N\ge n_o\)</span>时，<span class="math inline">\(T(N)\le cf(N)\)</span>，也就是<span class="math inline">\(\frac{T(N)}{f(N)}\le c\)</span>。此时如果<span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>大于<span class="math inline">\(f(N)\)</span>的增长率，那么<span class="math inline">\(\frac{T(N)}{f(N)}\)</span>不可能小于某个常数，也就是<span class="math inline">\(c\)</span>不存在，与我们的前提条件矛盾，所以说忽略掉常数因子后，<span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>仍然小于等于<span class="math inline">\(f(N)\)</span>的增长率。</p><p>那么既然<span class="math inline">\(T(N)\)</span>是以不快于<span class="math inline">\(f(N)\)</span>的速度增长，也就可以说<span class="math inline">\(f(N)\)</span>是<span class="math inline">\(T(N)\)</span>的一个上界(upper bound)，即<strong>最坏情况</strong>。</p><h2 id="omega记号"><strong><span class="math inline">\(\Omega\)</span>记号</strong></h2><p>定义：如果存在正常数<span class="math inline">\(c\)</span>和<span class="math inline">\(n_0\)</span>，使得当<span class="math inline">\(N\ge n_o\)</span>时<span class="math inline">\(T(N)\ge cg(n)\)</span>，记<span class="math inline">\(T(N)=\Omega(g(n))\)</span>。</p><p>与上述大O的分析类似，可知： <span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>大于等于<span class="math inline">\(g(N)\)</span>的增长率，<span class="math inline">\(g(N)\)</span>是<span class="math inline">\(T(N)\)</span>的一个下界(lower bound)，即<strong>最好情况</strong>。</p><h2 id="theta记号"><strong><span class="math inline">\(\Theta\)</span>记号</strong></h2><p>定义：当且仅当<span class="math inline">\(T(N)=\Omega(h(n))\)</span>、<span class="math inline">\(T(N)=O(h(n))\)</span>时， <span class="math inline">\(T(N)=\Theta(f(n))\)</span>。</p><p>那么这个就是说<span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>等于<span class="math inline">\(h(N)\)</span>的增长率，即<strong>最坏情况和最好情况相同</strong>。</p><h2 id="小o记号"><strong>小o记号</strong></h2><p>定义：若<span class="math inline">\(T(N)=O(p(n))\)</span>且<span class="math inline">\(T(N)\neq\Theta(p(n))\)</span>时， <span class="math inline">\(T(N)=o(f(n))\)</span>。</p><p>与大O不同，小o表示<span class="math inline">\(T(N)\)</span>的<strong>增长率</strong>小于<span class="math inline">\(p(N)\)</span>的增长率，不包括等于。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nakamori Akina</title>
      <link href="/2018/11/18/Nakamori%20Akina/"/>
      <url>/2018/11/18/Nakamori%20Akina/</url>
      
        <content type="html"><![CDATA[<p>听过中森明菜的歌以后，一直想写点什么。恰好前段时间看过她的一个<a href="https://b23.tv/av13810011">访谈</a>，节目里已经39岁左右的明菜看着已经有些衰老，但是那份属于她的天真却好像要溢出屏幕。</p><p>节目里主持人问她为什么不用手机还在用电话卡，像是昭和时代穿越来的一样，她回答说自己没什么朋友去联系，一个人也不怎么去其他地方。看到这，我马上想到了《难破船》的热评：</p><p><img src="https://img2020.cnblogs.com/blog/1260581/202005/1260581-20200518233734136-841229768.jpg" /></p><p>你可能很难想象患有严重社交障碍的她当年是怎样的风姿绰约： 安利1：李健的《车站》大家应该都听过，翻唱的水准很高，不过我还是更喜欢<a href="https://b23.tv/av5270243">《駅》</a>，这是竹内玛莉亚专门为中森明菜创作的歌曲； 安利2：<a href="https://b23.tv/av7033508">《难破船》</a>的混剪视频，惊为天人。</p><p>上世纪70年代的日本乐坛是山口百惠的天下，然而在1980年，只有20岁的山口百惠突然宣布退出娱乐圈，随后与三浦友和结婚，如此退隐使得日本乐坛出现了一片巨大的空白。</p><p>中森明菜通过选秀节目出道，甜美的外表、独特的嗓音加上经纪公司的宣传，她迅速蹿红，被誉为继山口百惠之后新的“歌姬”。</p><p>80年代中期，凭借《ミ・アモーレ》和《DESIRE -情热-》，中森明菜连续两年获得日本唱片大赏。热情的舞台形象和不俗的唱功使得她成为了当时日本乐坛无可动摇的霸主，甚至被人称为“昭和时代的Lady Gaga”。后来据徐克回忆：《倩女幽魂》的聂小倩本来是邀请中森明菜扮演的，不过被拒绝了。</p><p>与在事业上的蒸蒸日上不同的是，她与近藤真彦的恋情危机开始逐渐爆发。近藤被誉为“日本第一渣男”，与松田圣子、梅艳芳等女星之间有着无数绯闻，媒体的报导更是推波助澜，中森明菜受到了很大的打击。也正是在这时候，她发布了单曲《难破船》，曲风开始变得哀伤深沉。</p><p>爱情的坎坷加上家人的天坑，中森明菜于1989年在近藤的住所割腕自杀，不过在送往医院后得救。在这一年的最后一天，为了挽救不断下滑的人气，近藤哄骗着明菜说会在记者会上宣布两人结婚，并特意在会场挂上了金屏风（婚礼常用装饰）。</p><p>傻傻的明菜出席之后，近藤在记者会上翻脸，把所有错误全部归因于明菜一个人，并且声称明菜的自杀与自己丝毫没有关系，也完全没有和明菜结婚的打算。而深陷爱情之中的明菜一个人承担了所有过错，在发布会上道歉。</p><p>之后近藤迅速与某富家女子成婚，并且利用权势限制明菜的发展。</p><p>回过头来再去听《难破船》，只觉得情到深处无怨尤：</p><blockquote><p>折れた翼広げたまま 展开折断的翅膀</p><p>あなたの上に落ちて行きたい<br />好想坠落在你身上</p><p>海の底へ沈んだなら 如果能沉入海底</p><p>泣きたいだけ抱いてほしい 好想你能拥抱我到尽情哭泣</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>敏感词过滤</title>
      <link href="/2018/09/24/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/"/>
      <url>/2018/09/24/%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="需求">需求</h2><p>在一个非常大的文件中存在着很多敏感词，现在需要将这些敏感词全部替换为*，时间响应要求较高（几百毫秒）。 ## 思路 要做这个事，首先需要知道哪些词是敏感的，因此需要有一个敏感词词库。 例如文本是"abcdefghi"，长度为<span class="math inline">\(n\)</span>，敏感词库是{"de", "bca", "bcf"}，词库长度为<span class="math inline">\(l_1\)</span>，每个词的长度为<span class="math inline">\(l_2\)</span>。</p><p>比较直接的做法：对每个敏感词，利用暴力匹配或KMP算法查找并作替换，这些单模式串匹配算法的缺点很明显，需要多次扫描文本<span class="math inline">\(O(n(l_1+l_2))\)</span>。</p><p>目前主流的做法主要是多模式串匹配算法： 1. Trie树：将敏感词库建树，用3个指针去搞，<a href="https://zhuanlan.zhihu.com/p/65115496">具体在这里</a>，查询复杂度<span class="math inline">\(O(nl_2)\)</span>，建树复杂度<span class="math inline">\(O(l_1l_2)\)</span>。 2. AC自动机：是Trie树的扩展，增加了一个fail指针，避免指针回溯，<a href="https://www.cnblogs.com/shengyang17/p/13719653.html">具体在这里</a>，复杂度一般优于Trie树。 3. DFA确定有穷自动机：利用状态转移，<a href="https://blog.csdn.net/weixin_36586120/article/details/113482752">具体在这里</a>，时间复杂度<span class="math inline">\(O(n)\)</span>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Onedrive File Open Problem</title>
      <link href="/2018/08/16/Onedrive%20File%20Open%20Problem/"/>
      <url>/2018/08/16/Onedrive%20File%20Open%20Problem/</url>
      
        <content type="html"><![CDATA[<p>在用Onenote 2016写笔记时，同步到Onedrive后就变成了Internet快捷方式，而且直接打开时会出现提示： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108200433406-2018295429.png" alt="image" /></p><h2 id="原因">原因</h2><p>用Onenote客户端在Onedrive上创建的笔记本是一种特殊文件，用Onedrive客户端将文件同步到本地的话，就会变成Internet快捷方式，不能直接打开； 但是如果用Onedrive网页版的话，就可以正常使用。</p><h2 id="解决">解决</h2><p>在Onenote客户端，“文件”-&gt;“打开”，找到你的笔记本，打开即可看到内容。</p><h2 id="参考">参考</h2><p><a href="http://cn.onenotegem.com/24120352653838239064/-onedrive-onenote-internet-url">onedrive-onenote-internet-url</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JSON Introduction</title>
      <link href="/2018/07/14/JSON%20Introduction/"/>
      <url>/2018/07/14/JSON%20Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="理解">理解</h2><p>JSON（JavaScript Object Notation），一种轻量级的数据交换格式，基于JS的一个子集，但其数据格式与语言无关。 通俗来说，如果你是PHP，要和JS互相发送信息，那么这时候就可以先将PHP发的信息转为JSON，再发给JS。 那么有人要问了，为什么自己不能直接学会PHP和JS，直接先将PHP的信息转为JS，不就OK了？ 没错，但是如果你要发给C++，发给Python，发给其他各种各样的语言呢？难道你要学会所有语言，再去发信息？显然不可能。 所以： &gt; You are now able to learn only one programming language, in addition to the communications language, JSON, in order to communicate with ANY other programming language.</p><p>但要注意：JSON并不是编程语言，只是一种规定的数据格式，这种格式的数据便于计算机处理。 JSON比较规范的定义是： &gt; JSON is the text grammer/format for the information that is being sent between programming language.</p><p>除了JSON以外，还有一种用于交流的数据格式，XML（Extensiable Markup Language）。但是JSON更加流行。</p><h2 id="格式">格式</h2><p>JSON有两种结构： 1，Object：对象用<code>&#123;</code>开始，用<code>&#125;</code>结束，对象中的一系列非排序的pair中，名称和值之间用<code>:</code>分开； 2，Array：数组用<code>[</code>开始，用<code>]</code>结束，数组成员之间用<code>,</code>分开。 名称（name）是字符串； 值（value）可以是：字符串、数值、对象、布尔值、数组或者<code>null</code>。 字符串：用<code>""</code>表示； 数值：可以是小数或负数，也可用<code>e</code>、<code>E</code>表示为指数格式； 对象：就是上述的Object； 布尔值：<code>true</code>或<code>false</code>； 数组：就是上述的Array。 举个栗子： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object &amp; Array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Andrew&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="string">&quot;36&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;number&quot;</span>:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;12345678&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;fax&quot;</span>: <span class="string">&quot;87654321&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;address&quot;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;Beijing&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;code&quot;</span>: <span class="string">&quot;10000&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考">参考</h2><p><a href="https://www.quora.com/What-is-JSON-2/answers/50464172?share=8534699f&amp;srid=5OZ0m">quora</a> <a href="https://zh.wikipedia.org/wiki/JSON">wiki</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>System Call</title>
      <link href="/2018/07/02/System%20Call/"/>
      <url>/2018/07/02/System%20Call/</url>
      
        <content type="html"><![CDATA[<h2 id="内容">内容</h2><p>设计系统调用，将系统的相关信息(CPU型号、操作系统的版本号、系统中的进程等类似于Windows的任务管理器的信息)以文本形式列表显示于屏幕，并编写用户程序予以验证。</p><h2 id="思想">思想</h2><ul><li>系统调用是应用程序和操作系统内核之间的功能接口，可以使用户使用操作系统提供的有关设备管理、输入输出系统、文件系统和进程控制、通信以及存储管理等方面的功能，不必了解系统程序的内部结构和有关硬件细节，从而减轻用户负担、保护系统以及提高系统资源利用率的作用。</li><li>模块是在内核空间运行的程序，实际上是一种目标文件，不能单独运行但其代码可在运行时链接到系统中作为内核的一部分运行或卸载。Linux内核模块是一个编译好的、具有特定格式的独立目标文件，用户可以通过系统提供的一组与模块相关的命令将模块加载进内核，当内核模块被加载后，有如下特点：</li><li>与内核一起运行在相同的内核态和内核地址空间；</li><li>运行时与内核具有同样的特权级；</li><li>可方便地访问内核中的各种数据结构。</li><li>内核模块还可以很容易地被移出内核，当用户不再需要某模块功能时，可以从内核卸载以节省系统主存开销。</li><li>用户修改代码后，只需重新编译加载模块，不必重新编译内核和引导系统。</li></ul><h2 id="基础知识">基础知识</h2><ul><li>内核模块编程与用户态编程的区别：</li></ul><ol type="1"><li>内核模块编程不能使用C函数库，内核模块只能使用一些内核函数。比如，输出信息时使用内核函数<code>printk</code>，而不是标准库函数<code>printf</code>。</li><li>内核模块代码运行在核心态，这意味着函数使用的栈是核心栈，这个空间非常有限，一般是4KB或者8KB，所以不能定义占用很大空间的自动变量。</li><li>内核代码为了节省开销，不能使用浮点运算。</li></ol><ul><li>典型内核模块组成：</li></ul><ol type="1"><li>头文件声明。其中<code>module.h</code>和<code>init.h</code>是必不可少的。<code>Module.h</code>包含加载模块时需要的函数和符号定义；<code>init.h</code>包含模块初始化和清理函数的定义。如果在加载时允许用户传递参数，模块中还应包含<code>moduleparam.h</code>头文件。</li><li>模块许可声明。从内核2.4.10版本开始，模块必须通过<code>MODULE_LICENSE</code>宏声明此模块的许可证，否则在加载模块时会显示"kernel tainted(内核被污染)"的警告信息。从<code>linux/module.h</code>文件中可以看到，被内核接受的许可证有GPL、GPL v2、GPL and additional rights、Dual BSD/GPL、Dual MPL/GPL、Dual MIT/GPL和Proprietaty。</li><li>初始化和清理函数声明。 内核模块必须调用宏<code>module_init</code>和<code>module_exit</code>去注册初始化和清理函数。初始化和清理函数必须在宏<code>module_init</code>和<code>module_exit</code>使用前定义，否则会出现编译错误。这两个函数配对使用，例如当初始化函数申请了一个资源，那么清理函数就应该释放这个资源，使得模块不留下任何副作用。除了模块初始化函数和清理函数，还可以根据需要设计编写其它函数。</li></ol><ul><li>proc文件系统 在linux操作系统中，提供了一套在用户态检查内核状态和系统特征的机制，就是进程文件系统(process file system)。 Proc文件系统将进程信息、系统的硬件信息(包括CPU、内存状态及网卡等各种硬件设备)、系统相关机制(中断、I/O)等内容全部映射为虚拟的linux文件。它以一种特殊的文件系统的方式，为访问系统内核数据的操作提供接口。这些文件的内容都不存在于任何存储设备上，而是在读/写的时候才根据系统中的有关信息生成出来，或者映射到系统中的有关变量或者数据结构。 系统中当前运行的每一个每一个进程都有一个对应的目录在/proc下，以进程的ID为目录名： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108195514838-1179859005.png" alt="image" /></li></ul><p>除了与进程有关的子目录，/proc还有一些内核信息的目录： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108195533943-914673534.png" alt="image" /></p><h2 id="实现">实现</h2><p><a href="https://github.com/EIMadrigal/system_call">源代码、实现过程及结果</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>进程软中断通信</title>
      <link href="/2018/06/30/%E8%BF%9B%E7%A8%8B%E8%BD%AF%E4%B8%AD%E6%96%AD%E9%80%9A%E4%BF%A1/"/>
      <url>/2018/06/30/%E8%BF%9B%E7%A8%8B%E8%BD%AF%E4%B8%AD%E6%96%AD%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>使用系统调用fork()创建两个子进程，再用系统调用signal()让父进程捕捉键盘上发出的中断信号（即按ctrl+c键），当父进程接收到这两个软中断的某一个后，父进程用系统调用kill()向两个子进程分别发出整数值为16和17软中断信号，子进程获得对应软中断信号，然后分别输出下列信息后终止： Child process 1 is killed by parent !! Child process 2 is killed by parent !! 父进程调用wait()函数等待两个子进程终止后，输入以下信息，结束进程执行： Parent process is killed!!</p><p>流程图： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194427772-238897206.png" alt="image" /></p><h2 id="实现">实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> wait_flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid1,pid2;</span><br><span class="line"></span><br><span class="line">    signal(<span class="number">2</span>,stop1);   <span class="comment">//signal 3 is ctrl+\,signal 2 is ctrl+c</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pid1 = fork()) == <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(pid1 &gt; <span class="number">0</span>)      <span class="comment">//now is in the parent process</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((pid2 = fork()) == <span class="number">-1</span>);   <span class="comment">//creat child process 2</span></span><br><span class="line">        <span class="keyword">if</span>(pid2 &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sleep(<span class="number">5</span>);       <span class="comment">//sleep函数被信号中断后，就会导致延时失效，直接跳到sleep的下一行</span></span><br><span class="line">            kill(pid1,<span class="number">16</span>);  <span class="comment">//kill process1,send 16</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            kill(pid2,<span class="number">17</span>); <span class="comment">//kill process2, send 17</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nParent process is killed!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            signal(<span class="number">17</span>,stop2);   <span class="comment">//wait for 2 about 17</span></span><br><span class="line">            <span class="keyword">while</span>(wait_flag)</span><br><span class="line">                ;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nChild process 2 is killed by parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        signal(<span class="number">16</span>,stop2);</span><br><span class="line">        <span class="keyword">while</span>(wait_flag)</span><br><span class="line">            ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nChild process 1 is killed by parent!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);   <span class="comment">//execute normally and quit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nParent process catches the interruption signal!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wait_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nChild process catches the interruption signal!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果">结果</h2><p>5s内没有按终止键： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194549740-1526578900.png" alt="image" /></p><p>5s内按下ctrl+c： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194609530-785223659.png" alt="image" /></p><h2 id="附">附</h2><p>系统调用signal(sig,function)：捕捉中断信号sig后执行function规定的操作。 参数定义：<code>int sig</code>，<code>void* func()</code> sig共有19个值： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194710456-891175051.png" alt="image" /></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sorting</title>
      <link href="/2018/05/25/Sorting/"/>
      <url>/2018/05/25/Sorting/</url>
      
        <content type="html"><![CDATA[<h2 id="bubble-sort">Bubble Sort</h2><p>冒泡排序也许是大部分人CS生涯里学到的第一种排序算法，它的基本思想是：依次比较两个相邻记录的关键字，如果逆序就进行交换，直到没有逆序的记录。</p><p>每一趟排序可以将前<span class="math inline">\(i\)</span>个元素的最大值冒泡到最后，因此共需<span class="math inline">\(n-1\)</span>趟；每一趟都要比较<span class="math inline">\(j\)</span>和<span class="math inline">\(j+1\)</span>的值，因此<span class="math inline">\(j\)</span>取值为<span class="math inline">\([0,i-1]\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>])</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[k] &gt; nums[k + <span class="number">1</span>])</span><br><span class="line">            <span class="built_in">swap</span>(nums[k], nums[k + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bubble</span>(nums, l, r - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序也是可以稍稍优化的：试想如果序列是<span class="math inline">\([2,1,3,4,5]\)</span>，其实我们只需交换前两个元素，即第一趟有交换，走完第二趟发现没有交换时就可以结束了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> has_swap = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; has_swap; --i) &#123;</span><br><span class="line">has_swap = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>])</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">has_swap = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于最后优化的代码，可以看到： 最好的情况就是待排序列已经全部有序，这样要进行<span class="math inline">\(n-1\)</span>次比较，时间复杂度O(n)； 最坏的情况就是待排序列全部逆序，需要进行n(n-1)/2次比较，并且还有等数量级的交换，时间复杂度<span class="math inline">\(O(n^2)\)</span>。</p><h2 id="selection-sort">Selection Sort</h2><p>所谓选择排序，就是持续选择<span class="math inline">\([i+1,n-1]\)</span>中最小的元素并与<span class="math inline">\(i\)</span>交换，因此前面的部分必然全局有序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> min_id = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[min_id]) min_id = j;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[min_id]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序需要N次交换以及<span class="math inline">\(\frac{N^2}{2}\)</span>次比较，数据移动次数与数组大小呈线性关系，移动次数是最少的。 时间复杂度<span class="math inline">\(O(n^2)\)</span>。</p><h2 id="insertion-sort">Insertion Sort</h2><p>插入排序其实就是打牌：每次拿到一张牌<span class="math inline">\(i\)</span>，从<span class="math inline">\(i-1\)</span>开始向前扫描寻找第一个使得<span class="math inline">\(cur&gt;nums[j]\)</span>的位置<span class="math inline">\(j\)</span>，找到位置后将<span class="math inline">\([j+1,i-1]\)</span>所有元素向后移一位，接着将拿到的牌放到<span class="math inline">\(j+1\)</span>。不能保证前面的部分全局有序，因为后面拿到的牌可能是最小的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> cur = nums[i];</span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; cur &lt; nums[j]) &#123;</span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">--j;</span><br><span class="line">&#125;</span><br><span class="line">nums[j + <span class="number">1</span>] = cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：元素全部有序，<span class="math inline">\(N-1\)</span>次比较、<span class="math inline">\(0\)</span>次交换；复杂度<span class="math inline">\(O(n)\)</span>。 最坏情况：元素全部逆序，大约<span class="math inline">\(\frac{N^2}{2}\)</span>次比较和<span class="math inline">\(\frac{N^2}{2}\)</span>次交换，复杂度<span class="math inline">\(O(n^2)\)</span>。 平均情况下：大约<span class="math inline">\(\frac{N^2}{4}\)</span>次比较和<span class="math inline">\(\frac{N^2}{4}\)</span>次交换，复杂度<span class="math inline">\(O(n^2)\)</span>。 ## 折半插入排序 直接插入排序前面的子序列是有序的，所以如果是顺序表，那么可以先折半查找出元素的待插入位置，再统一移动该位置之后的所有元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void insertionSortOptimized(int A[], int n)</span><br><span class="line">&#123;</span><br><span class="line">//将A[i]插入到合适位置</span><br><span class="line">for (int i = 1; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">int tmp = A[i];</span><br><span class="line">int low = 0, high = i - 1;</span><br><span class="line">while (low &lt;= high)</span><br><span class="line">&#123;</span><br><span class="line">int mid = (low + high) &gt;&gt; 1;</span><br><span class="line">if (A[mid] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">high = mid - 1;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">low = mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//统一后移元素</span><br><span class="line">for (int j = i - 1; j &gt;= low; j--)</span><br><span class="line">&#123;</span><br><span class="line">A[j + 1] = A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A[low] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能：折半插入排序将元素比较次数减少为<span class="math inline">\(O(nlogn)\)</span>，但是移动次数依然是<span class="math inline">\(O(n^2)\)</span>，故总的时间复杂度为<span class="math inline">\(O(n^2)\)</span>。</p><h2 id="merge-sort">Merge Sort</h2><p>归并排序是将几个有序表归并为一个新的有序表，初始时可以看作<span class="math inline">\(n\)</span>个有序子表，2路归并排序将其合并为<span class="math inline">\(n/2\)</span>个有序子表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(high - low + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = low; <span class="comment">// 左有序开始位置</span></span><br><span class="line"><span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 右有序开始位置</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line"><span class="keyword">if</span> (num[i] &lt; num[j]) &#123;</span><br><span class="line">tmp[k++] = num[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tmp[k++] = num[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">tmp[k++] = num[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= high)</span><br><span class="line">tmp[k++] = num[j++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">num[low + i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &gt;= high)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">mergeSort</span>(num, low, mid);</span><br><span class="line"><span class="built_in">mergeSort</span>(num, mid + <span class="number">1</span>, high);</span><br><span class="line"><span class="built_in">Merge</span>(num, low, mid, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能：需要辅助数组，空间复杂度<span class="math inline">\(O(n)\)</span>； 每一趟归并<span class="math inline">\(O(n)\)</span>，需要<span class="math inline">\(O(logn)\)</span>趟归并，故时间复杂度<span class="math inline">\(O(nlogn)\)</span>。</p><h2 id="heap-sort">Heap Sort</h2><p>堆是一种将数组看作complete binary tree的数据结构，分为大顶堆（parent&gt;=children）和小顶堆（parent&lt;=children），由于父结点和孩子结点这种奇妙的大小关系，堆也被用来做排序了...对于一颗完全二叉树，结点<span class="math inline">\(i\)</span>的父结点为<span class="math inline">\((i-1)//2\)</span>，孩子结点为<span class="math inline">\(2i+1,2i+2\)</span>。</p><p>排序前先要建堆，有2种主要的建堆方法（以大顶堆为例）： 1. Top-down Top-down的方式主要通过<code>HeapInsert</code>的方法，从空heap开始，每次插入并向上调整<code>sift_up</code>一个元素，复杂度<span class="math inline">\(O(nlgn)\)</span>。 2. Bottom-up Bottom-up的方式主要依赖于一种叫做<code>heapify</code>的操作，你也可以叫它嬉皮化。对某个结点a进行<code>heapify</code>非常简单：对比a以及a两个孩子<span class="math inline">\(c_1,c_2\)</span>的值，如果a是最大的，操作结束；否则将a与<span class="math inline">\(max(c_1,c_2)\)</span>交换，递归直到a变为叶子结点或者a是三者中最大值，<code>heapify</code>操作的复杂度为<span class="math inline">\(O(lgn)\)</span>。 可以发现：一次<code>heapify</code>下沉操作<code>sift_down</code>只能保证从a向下交换的路径上的每一棵局部小子树满足堆的性质（即只对原数组的部分位置进行了调整），并不能保证整棵树都满足堆的性质，甚至无法保证向下交换的整条路径满足根结点最大（如<code>[3 2 4 0 1 6 8]</code>对根操作后变为<code>[4 2 8 0 1 6 3]</code>），所以为了建堆，需要从最后一个非叶子结点<span class="math inline">\((n-1-1)//2\)</span>（也即最后一个结点的父结点）开始，对之前的每个结点都进行<code>heapify</code>操作，这样就可以保证整棵树都满足堆的性质。时间复杂度为<span class="math inline">\(O(n)\)</span>，<a href="https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity">How can building a heap be O(n) time complexity?</a> 那么<code>heapify</code>建堆能不能从前向后进行呢？答案是不能，还是上面那个例子。从前往后最大元素调不到堆顶，从后往前则已经保证了父结点是最大的，因此最大元素可以一直向上调。</p><p>建好堆后，堆顶元素即为最大值，此时将堆顶（数组的第一个元素）和最后一个元素交换，则最后一个元素有序（最大值），但破坏了大顶堆性质，对堆顶元素进行<code>heapify</code>下沉操作（只需<code>heapify</code>前n-1个元素），保持大根堆即可： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在[start, end]范围内对nums[start]向下调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * start + <span class="number">1</span>, right = <span class="number">2</span> * start + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> max_idx = start;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= end &amp;&amp; nums[left] &gt; nums[max_idx]) max_idx = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= end &amp;&amp; nums[right] &gt; nums[max_idx]) max_idx = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_idx != start) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[max_idx]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, max_idx, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify_iter</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> parent = start, child = <span class="number">2</span> * parent + <span class="number">1</span>;  <span class="comment">// parent和child作为双指针迭代</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= end &amp;&amp; nums[child + <span class="number">1</span>] &gt; nums[child]) ++child;</span><br><span class="line">        <span class="keyword">if</span> (nums[parent] &gt;= nums[child]) <span class="keyword">break</span>;  <span class="comment">// 父亲最大无法继续下沉</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[parent], nums[child]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = <span class="number">2</span> * parent + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last_idx = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (last_idx - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums, i, last_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">build_heap</span>(nums);</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Bottom-up方式的堆排序时间复杂度<span class="math inline">\(O(nlogn)\)</span>。 一般求前<span class="math inline">\(K\)</span>大元素都采用堆排序，因为只需要调整<span class="math inline">\(K\)</span>次，故<span class="math inline">\(O(nlogK)\)</span>，而快排要将所有元素排完后才能取出前<span class="math inline">\(K\)</span>个。</p><h2 id="希尔排序">希尔排序</h2><p>基本思想：将待排序表分为若干<span class="math inline">\(A[i], A[i+d], A[i+2d]...\)</span>子表，<span class="math inline">\(d\)</span>称为增量，对这些子表执行直接插入排序，当整个表中的元素“基本有序”时，对整个表来一次直接插入排序。 由于需要快速定位某个子表中的元素，所以只能用于顺序表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void shellSort(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">const int n = nums.size();</span><br><span class="line">for (int d = n &gt;&gt; 1; d &gt; 0; d &gt;&gt;= 1) // 增量选之前的一半</span><br><span class="line">for (int i = d; i &lt; n; ++i)  // 将nums[i]插入有序子表</span><br><span class="line">if (nums[i] &lt; nums[i - d]) &#123;</span><br><span class="line">int tmp = nums[i];</span><br><span class="line">int j;</span><br><span class="line">// 查找插入位置</span><br><span class="line">for (j = i - d; j &gt;= 0 &amp;&amp; tmp &lt; nums[j]; j -= d)</span><br><span class="line">nums[j + d] = nums[j];  // 后移</span><br><span class="line">nums[j + d] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能：时间复杂度依赖于选取的增量序列，大约是<span class="math inline">\(O(n^{1.3})\)</span>，最坏是<span class="math inline">\(O(n^2)\)</span>。</p><h2 id="quick-sort">Quick Sort</h2><p>分治。 选一个<code>pivot</code>，将比<code>pivot</code>小的元素放在左边，比<code>pivot</code>大的元素放在右边，对左右两个子数组递归调用<code>QuickSort</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组共分为3段：</span></span><br><span class="line"><span class="comment"> * (l, smaller_idx]：比pivot小的</span></span><br><span class="line"><span class="comment"> * [smaller_idx + 1, i - 1]：比pivot大的</span></span><br><span class="line"><span class="comment"> * [i, r]：还未访问的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));  <span class="comment">// use system time as seed</span></span><br><span class="line"><span class="keyword">int</span> pivotIndex = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">swap</span>(nums[pivotIndex], nums[l]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> smaller_idx = l;  <span class="comment">// 当前时刻刚好小于等于pivot的元素索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt;= nums[l]) &#123;  <span class="comment">// 发现比pivot小的</span></span><br><span class="line"><span class="comment">// 加一后指向第一个比pivot大的</span></span><br><span class="line"><span class="built_in">swap</span>(nums[++smaller_idx], nums[i]);  <span class="comment">// 将比pivot小的nums[i]换到前面</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(nums[smaller_idx], nums[l]);</span><br><span class="line"><span class="keyword">return</span> smaller_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = num[low];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; num[high] &gt;= pivot) &#123;</span><br><span class="line">--high;</span><br><span class="line">&#125;</span><br><span class="line">num[low] = num[high];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; num[low] &lt;= pivot) &#123;</span><br><span class="line">++low;</span><br><span class="line">&#125;</span><br><span class="line">num[high] = num[low];</span><br><span class="line">&#125;</span><br><span class="line">num[low] = pivot;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">int</span> pivot_idx = <span class="built_in">partition</span>(num, low, high);</span><br><span class="line"><span class="built_in">qSort</span>(num, low, pivot_idx - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">qSort</span>(num, pivot_idx + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归，用栈保存要操作的范围的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qSortNotR</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(low);</span><br><span class="line">s.<span class="built_in">push</span>(high);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> r = s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> l = s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> pivotPos = <span class="built_in">partition</span>(num, l, r);</span><br><span class="line"><span class="keyword">if</span> (l &lt; pivotPos - <span class="number">1</span>) &#123;</span><br><span class="line">s.<span class="built_in">push</span>(l);</span><br><span class="line">s.<span class="built_in">push</span>(pivotPos - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pivotPos + <span class="number">1</span> &lt; r) &#123;</span><br><span class="line">s.<span class="built_in">push</span>(pivotPos + <span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">push</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>划分的两个子问题规模分别为0和n时，时间复杂度最坏为<span class="math inline">\(O(n^2)\)</span>； 两个子问题规模相同时，时间复杂度最好为<span class="math inline">\(O(nlgn)\)</span>，平均性能更接近最好情况。 假设输入数据的所有排列不是等概率的，那么为了避免最坏情况的发生，选择pivot可以<strong>随机</strong>进行，这样被pivot分开的两个子问题规模会接近<span class="math inline">\(n/2\)</span>。</p><p>复杂度的证明既可以用主定理，也可以自己推导，在最优情况下： <span class="math display">\[T(n)=2T(n/2)+n \\T(n)=2(2T(n/4)+n/2)+n=4T(n/4)+2n \\T(n)=4(2T(n/8)+n/4)+2n=8T(n/8)+3n \\... \\T(n)=nT(1)+nlogn=n+nlogn\]</span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Random Number Generator</title>
      <link href="/2018/05/24/Random%20Number%20Generator/"/>
      <url>/2018/05/24/Random%20Number%20Generator/</url>
      
        <content type="html"><![CDATA[<p><code>rand()</code>函数可以产生[0,RAND_MAX]之间的均匀的<strong>伪随机数</strong>，它定义在头文件<code>stdlib.h</code>中，函数原型： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>C标准库的实现是： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*rand: return pseudo-number integer on 0...32767*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = next*<span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*srand: set seed for rand()*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果没有初始化“随机数种子”，那么默认初始种子是1，1*1103515245+12345，return得到第一个伪随机数，接着将这个结果作为下次的种子，带入式子得到第二个伪随机数... 之所以定义为<code>unsigned int</code>，是防止数值溢出后不会出现负值。 直接调用<code>rand()</code>，会导致产生的是同一套随机数，所以我们使用<code>srand()</code>来初始化随机数种子。 要注意的是：不同编译器计算随机数的方法不尽相同，所以即使给<code>srand()</code>传递相同的参数，也可能产生不同的随机数序列。 举个栗子： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*产生0-9的随机数*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  <span class="comment">//初始化随机数种子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rand()%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用<code>rand()%n</code>产生[0,n)之间的随机数，那么一旦<span class="math inline">\(n&gt;RAND\_MAX\)</span>，这种做法就会失效。 如果你对精度的要求不高，可以采用如下办法： 先用<code>rand()/RAND_MAX</code>，得到[0,1]之间的随机实数，然后扩大n-1倍，四舍五入，就可得到[0,n-1]之间的随机数。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*产生10个[0,99999]之间的随机数*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">double</span> random_doub;</span><br><span class="line">    <span class="keyword">int</span> random_num;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  <span class="comment">//初始化随机数种子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        random_doub = (<span class="keyword">double</span>)rand() / RAND_MAX; <span class="comment">//生成[0,1]之间的随机数</span></span><br><span class="line">        random_num = (<span class="keyword">int</span>)((n - <span class="number">1</span>)*random_doub + <span class="number">0.5</span>); <span class="comment">//生成[0,n-1]之间的随机数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,random_num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108194141397-884629663.png" alt="image" /> &lt;/time.h&gt;&lt;/stdlib.h&gt;&lt;/stdio.h&gt;&lt;/time.h&gt;&lt;/stdlib.h&gt;&lt;/stdio.h&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Function-time()</title>
      <link href="/2018/05/23/Function-time()/"/>
      <url>/2018/05/23/Function-time()/</url>
      
        <content type="html"><![CDATA[<p><code>time()</code>函数返回自1970年1月1日0点以来经过的秒数，每秒变化一次? <code>time()</code>函数定义在头文件<code>&lt;time.h&gt;</code>中，原型是： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure></p><p>如果<code>arg</code>不是空指针，那么函数返回<code>time_t</code>类型的calendar time，并且把结果保存在<code>arg</code>指向的对象； 如果<code>arg == NULL</code>，那么函数只是返回一个值，值不能存储在空指针指向的对象。 之前不明白为什么要设计一个参数<code>arg</code>，直接返回一个值就好了啊？ 有大神说，这是因为： &gt; 很久很久以前，据说<code>time_t</code>是个<code>struct</code>，那时候c语言不支持函数返回<code>struct</code>，所以只能用指针传进去。</p><p>那么<code>time_t</code>到底是什么类型呢？ 看看cppreference.com的定义：</p><blockquote><p>The encoding of calendar time in <code>time_t</code> is unspecified, but most systems conform to POSIX specification and return a value of integral type holding the number of seconds since the Epoch.Implementations in which <code>time_t</code> is a 32-bit signed interger(many historical implementations) fail in the year 2038.</p></blockquote><p>就是说：C标准委员会并没有定义<code>time_t</code>的精度，也没有指定标准的Epoch，所以这取决于你的operating system以及你的compiler。 如果你的系统支持<strong>POSIX标准</strong>(包括很多类Unix系统、Windows系统)，那么<code>time_t</code>是一个<code>signed int 32</code>，最大表示范围是2147483647秒，标准Epoch是1970年1月1日0点，所以最终时间就是2038年1月19日，这就是著名的<a href="https://en.wikipedia.org/wiki/Year_2038_problem">2038年问题</a>。</p><p>那么这个函数的实现，GNU C Library是这么写的： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span>                <span class="comment">/* For NULL.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys time.h=&quot;&quot;&gt;</span></span></span><br><span class="line"><span class="comment">/* Return the current time as a `time_t&#x27; and also put it in *T if T is</span></span><br><span class="line"><span class="comment">   not NULL.  Time is represented as seconds from Jan 1 00:00:00 1970.  */</span></span><br><span class="line"><span class="function"><span class="keyword">time_t</span></span></span><br><span class="line"><span class="function"><span class="title">time</span> <span class="params">(<span class="keyword">time_t</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">  <span class="keyword">time_t</span> result;</span><br><span class="line">  <span class="keyword">if</span> (__gettimeofday (&amp;tv, (struct timezone *) <span class="literal">NULL</span>))</span><br><span class="line">    result = (<span class="keyword">time_t</span>) <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = (<span class="keyword">time_t</span>) tv.tv_sec;</span><br><span class="line">  <span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">    *t = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (time)</span><br></pre></td></tr></table></figure></p><p>如果返回<code>time_t</code>类型的值，说明调用成功； 如果返回<code>(time_t)(-1)</code>，说明无法取得现在的时间，调用失败。 举个栗子，获得当前时间： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> current = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*把日期和时间转为字符串*/</span></span><br><span class="line">    <span class="built_in">string</span> = ctime(&amp;current);</span><br><span class="line">    <span class="keyword">if</span> (current == (<span class="keyword">time_t</span>)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to get the current time!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The current time is %s&quot;</span>, <span class="built_in">string</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d seconds since the Epoch)\n&quot;</span>,current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108191119700-2067131670.png" alt="image" /> &lt;/stdlib.h&gt;&lt;/time.h&gt;&lt;/stdio.h&gt;</sys>&lt;/time.h&gt;&lt;/stddef.h&gt;&lt;/time.h&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FTP Protocol</title>
      <link href="/2018/05/22/FTP%20Protocol/"/>
      <url>/2018/05/22/FTP%20Protocol/</url>
      
        <content type="html"><![CDATA[<p>FTP(File Transfer Protocol)是因特网上的一种文件传送协议。</p><h2 id="基本原理">基本原理</h2><p>FTP协议基于客户/服务器模式，属于应用层，使用TCP可靠的运输服务。 FTP的服务器进程由<strong>1个主进程</strong>和<strong>若干从进程</strong>组成：主进程负责接受新请求，从进程负责处理单个请求。这样，1个FTP服务器就可以同时为多个客户进程服务。</p><h2 id="工作过程">工作过程</h2><p>FTP工作分为主动模式和被动模式。 不论哪种模式，首先，客户从一个随机的端口N(1024-65535)向服务器的命令端口21发起请求，建立起<strong>控制连接</strong>。 - 主动模式 客户随机打开某个端口(1024-65535)，在这个端口等待服务器的数据，所以要通过控制连接告诉服务器自己用哪个端口传送数据，接着服务器收到文件传送命令以及客户端口号，从自己的数据端口20向客户发起数据连接。 FTP传送完一个文件，数据连接就会关闭，而控制连接贯穿整个会话。</p><ul><li>被动模式 如果客户被防火墙限制，不能接受到来的TCP连接，这时候就需要被动模式来传输： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108185312740-1401371750.png" alt="image" /> 首先，客户通过控制连接向服务器发送命令PASV； 接着，服务器向客户发送自己的IP地址和自己打算用来传送数据的端口号； 最后，客户通过刚才接收的IP地址和服务器端口号，用自己任意一个端口(1024-65535)向服务器开的那个端口建立数据连接。 通俗点，就是： 主动模式：建立数据通道，服务器主动去连接客户； <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108185349044-1665399483.png" alt="image" /> 被动模式：建立数据通道，服务器被动地被客户连接。 <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108185409921-1806947979.png" alt="image" /></li></ul><p>再通俗点，就是： 主动模式： 客户：我开了一个端口，你来连我吧； 被动模式： 客户：mmp，被防火墙搞了，收不到你发来的数据连接了； 服务器：哦，没事，我开了个端口，你连我就好了。</p><h2 id="参考">参考</h2><p><a href="www.serv-u.com/kb/1138/Active-and-Passive-FTP-Transfers-Defined">Active and Passive FTP Transfers Defined</a> <a href="https://en.wikipedia.org/wiki/File_Transfer_Protocol">wiki</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>File Operations</title>
      <link href="/2018/05/19/File%20Operations/"/>
      <url>/2018/05/19/File%20Operations/</url>
      
        <content type="html"><![CDATA[<p>在刷题测试程序时，为了避免每次都手工输入，我们可以把输入数据保存在文件中；为了避免输出太长，我们将输出也写入文件中，方便与标准答案文件进行比较。 文件使用一般有两种方法：输入输出重定向、fopen。</p><ul><li>重定向 这种方法比较简单，只要在main()函数的开始加上： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">freopen(<span class="string">&quot;input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure></li></ul><p>就可以将标准I/O(键盘输入、屏幕输出)转为读写文件。 万一比赛要求标准I/O，而你还想用文件操作来测试代码时，提交时切记删除重定向语句。 为了避免你忘记这茬，可以如下处理： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NATIVE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NATIVE</span></span><br><span class="line">    freopen(<span class="string">&quot;input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//your code here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样子，本机测试时可以使用重定向；如果要求标准I/O，提交时只需删掉<code>#define NATIVE</code>即可。</p><ul><li>fopen 如果比赛要求使用文件读写，但禁止重定向方式，这时可以使用fopen方式： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fin, *fout;</span><br><span class="line">    fin = fopen(<span class="string">&quot;input.txt&quot;</span>.<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    fout = fopen(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把scanf改为fscanf,把printf改为fprintf</span></span><br><span class="line">    <span class="built_in">fscanf</span>(fin,<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">fprintf</span>(fout,<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line">    <span class="comment">//your code here</span></span><br><span class="line"></span><br><span class="line">    fclose(fin);</span><br><span class="line">    fclose(fout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这时候，如果要求标准I/O，只需要： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fin = <span class="built_in">stdin</span>;</span><br><span class="line">fout = <span class="built_in">stdout</span>;</span><br></pre></td></tr></table></figure></p><p>最后，简单说下<strong>文件比较</strong>(windows下)： 进入cmd，如果两个文件在同一目录： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fc</span> 1.txt 2.txt</span><br></pre></td></tr></table></figure></p><p>如果两个文件不在同一目录： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fc</span> <span class="string">&quot;c:\1.txt&quot;</span> <span class="string">&quot;d:\2.txt&quot;</span></span><br></pre></td></tr></table></figure></p><p>可以使用<code>fc /?</code>查看fc命令的一些参数： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108184941074-1492015913.png" alt="image" /> &lt;/stdio.h&gt;&lt;/stdio.h&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2018/05/18/Git/"/>
      <url>/2018/05/18/Git/</url>
      
        <content type="html"><![CDATA[<p>Git是版本控制系统的一种，用来维护多人协作项目的开发进程。</p><p>首先来看看单人开发的需求，最原始的VCS就在你我身边😂： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229105452773-1749378952.png" alt="image" /></p><p>假如在本地保存了多个版本，<code>HEAD</code>总是指向最新的版本： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229110354288-1305060165.png" alt="image" /></p><p>如果Version 3出现了严重的bug，可以回退到Version 2继续操作。但是如果Version 3包含了很多我们希望保留的change，就需要将其与Version 2比对，而后将这些changes拷贝到Version 2，一个好的VCS就需要支持<code>diff</code>操作帮程序员们找到两个版本之间的差异。</p><p>除此之外，为了防止本地机器故障，我们希望把本地的所有版本都在云上备份，这样即使你的设备原地爆炸，也不用担心被老板炒鱿鱼。 <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229111609065-1819873752.png" alt="image" /> 另外，你可以借助云的中转实现多地工作。当然偶尔也会出现一些小问题：假如现在云上和本地的稳定版本都是Version 5，你996下班后还想为公司做贡献，就在家里开始对Version 5一顿操作得到了Version 5L却忘了上传，第二天上班在公司又是对Version 5一通different的操作得到了Version 5D并上传，第二天下班从云上直接拉取Version 5D到本地，价值几个亿的Version 5L就再也找不到了...这里就需要<code>merge</code>操作来合并分支。</p><p>更重要的是，程序员们可以随时随地借助云上的备份进行协作，完成超大项目的撕逼工作。 为了保证出bug有人背锅，还需要记录who/when/what，VCS里叫做<code>annotate/blame</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git init  # 将该目录用Git管理</span><br><span class="line">git add haha.txt kaka.txt  # 将haha.txt，kaka.txt添加到仓库</span><br><span class="line">git commit -m &quot;upload&quot;  # 将文件提交到仓库，本次提交说明是upload</span><br><span class="line">git remote add origin git@github.com:EIMadrigal/Leetcode.git  # 将本地仓库与远程仓库关联</span><br><span class="line">git push -u origin main  # 将本地库的内容第一次推送到远程仓库</span><br><span class="line">git push origin main  # 以后的推送</span><br><span class="line">git rm -r --cached haha  # 删除文件夹haha</span><br><span class="line">git status  # 查看仓库的状态</span><br><span class="line">git diff  # 查看具体修改的内容</span><br><span class="line">git log  # 查看提交历史纪录</span><br><span class="line">git show  # 提交详情</span><br><span class="line">git checkout -- [file]  # 回退</span><br><span class="line">git reset --hard HEAD^  # HEAD表示当前版本，HEAD^表示上一个版本</span><br><span class="line">git reflog  # 查看命令的历史纪录</span><br></pre></td></tr></table></figure><p><a href="https://www.v2ex.com/t/786515">Windows怎么设置cmd/git bash走代理</a></p><h2 id="refs">Refs</h2><p><a href="https://missing.csail.mit.edu/2020/version-control/">Version Control (Git)</a> <a href="https://web.mit.edu/6.031/www/fa21/classes/05-version-control">Reading 5: Version Control</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vim Introduction</title>
      <link href="/2018/05/18/Vim%20Introduction/"/>
      <url>/2018/05/18/Vim%20Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="配置">配置</h2><p>安装原生态的Vim之后，界面是这样的： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211114103208063-1995368165.png" alt="image" /> 行号，没有；自动缩进，没有；括号匹配，没有.</p><p>为了我们使用的方便，进行一些基本的配置： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/vim/vimrc</span><br></pre></td></tr></table></figure> 进入配置界面: <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211114103509711-1162498509.png" alt="image" /></p><p>可以删掉注释或添加新的配置: <img src="https://img2020.cnblogs.com/blog/1260581/202007/1260581-20200703081231240-949289722.png" alt="image" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set number  # 左侧显示行号</span><br><span class="line">set ts=4  # Tab键长度4个空格</span><br><span class="line">set expandtab  # 输入Tab自动转换为空格</span><br><span class="line">set cursorline  # 突出显示当前行</span><br><span class="line">set autoindent  # 自动缩进</span><br><span class="line">set showmatch  # 显示括号匹配</span><br><span class="line">syntax on</span><br></pre></td></tr></table></figure><h2 id="使用">使用</h2><p>Vim有三种模式：输入模式、命令模式和末行命令模式。 输入模式用来输入文字，命令模式用来下达编排文件的操作指令，末行命令模式用来进行文件存档、离开编辑器等操作: <img src="https://img2020.cnblogs.com/blog/1260581/202007/1260581-20200703081319488-2115051699.png" alt="image" /></p><ol type="1"><li>进入及离开 末行模式下： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:w  # 保存当前文件</span><br><span class="line">:x  # 保存文件并退出</span><br><span class="line">:q!  # 放弃此次编辑并强制退出</span><br><span class="line">:wq a.txt  # 保存退出</span><br><span class="line">:syntax on  # 一次性语法高亮</span><br><span class="line">:set number  # 一次性显示行号</span><br></pre></td></tr></table></figure></li><li>基本编辑 命令模式下按v进入visual模式： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d  # 选中目标文字段，按d(delete)剪切</span><br><span class="line">y  # 选中目标文字段，按y(yank)复制</span><br><span class="line">p  # 移动光标到目标位置，按p(put)粘贴</span><br></pre></td></tr></table></figure></li></ol><p>命令模式: hjkl和方向键类似,w可以按词向后移动,b按词向前移动,ctrl+f/ctrl+b与pageup/down功能一样 88gg直接跳到第88行 10j向下跳10行 10k向上跳10行 /Node高亮所有Node以后 按n后跳 按shift+n前跳 cc/dd/yy,按u取消操作 c2c删掉连续2行 p粘贴,按u取消操作</p><p>编辑模式: ctrl+n自动补全</p><p>插件: vim plug vim awesome</p><h2 id="中文输入">中文输入</h2><p>确保键盘输入系统选中fcitx，搜狗拼音输入法基于fcitx(Free Chinese Input Toy for X)框架，所以要选中fcitx： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229103046336-1159122227.png" alt="image" /></p><p>下载并安装搜狗输入法<a href="https://pinyin.sogou.com/linux/?r=pinyin">安装包</a>，切换到安装包所在的目录，改下安装包的名字，不然太长了不方便，我这里改为<code>ha.deb</code>，之后安装： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i ha.deb</span><br></pre></td></tr></table></figure></p><p>这里可能会提示依赖关系不满足(没提示的话跳过即可)： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229103335451-1935103123.png" alt="image" /></p><p>这是由于你的电脑可能没有安装有关fictx的内容，修复依赖关系： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -f</span><br></pre></td></tr></table></figure></p><p>顺利的话，桌面右上角会出现键盘图标： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229103537949-1620971579.png" alt="image" /> 可以看到搜狗输入法已经安装。</p><p>如果看不到搜狗的图标(尤其是第一次安装)，重启系统。 右键键盘图标，选择configure(或者搜fcitx configuration)： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229103624730-632103575.png" alt="image" /></p><p>你现在应该没有Sogou Pinyin这一项，点那个+号： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211229103646985-2704756.png" alt="image" /></p><p>取消Only Show Current Language前的对号，搜索Sogou Pinyin，点击OK。 现在，输入法应该已经安装好了。可以去桌面那个键盘图标看看了~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ISA Introduction</title>
      <link href="/2018/05/16/ISA%20Introduction/"/>
      <url>/2018/05/16/ISA%20Introduction/</url>
      
        <content type="html"><![CDATA[<p>介绍一下X86、MIPS、ARM三种指令集：</p><h2 id="x86指令集">X86指令集</h2><p>X86指令集是典型的CISC(Complex Instruction Set Computer)指令集。 X86指令集外部看起来是CISC指令集，事实上，它是采用类RISC内核，将部分复杂指令通过micro-op模式进行翻译成简单指令，再处理。 X86指令集的几个特性</p><ul><li>后向兼容 Intel每推出一代新处理器，总会兼容以前处理器的feature。这是由于长期积累的用户习惯和生态环境不容更改，否则没法赚钱了~ 后向兼容导致指令集愈发庞大、愈发复杂，同时功耗也会比较大，不过由于Intel超高的工艺水平，这都不是事。</li><li>变长指令 X86指令集采用变长指令(1-15Bytes)，一般每条指令为2-3Bytes。这样可以提高码字的利用率，但也使得译码以及读取指令时比较复杂，因为不知道一条指令应该读多长。</li><li>多种寻址方式 X86指令集可以采用多种寻址方式，比如立即寻址、寄存器寻址、寄存器相对寻址……</li><li>通用寄存器个数有限 X86-32的系统有8个通用寄存器，之后X86-64系统扩展到了16个。</li><li>指令执行时，最多只能有一个操作数在内存里，另一个操作数必为立即数或者寄存器。</li><li>由于后向兼容以及类RISC内核，导致功耗增加；同时，有很多复杂的指令利用率很低。</li></ul><h2 id="mips指令集">MIPS指令集</h2><p>MIPS指令集是典型的RISC(Reduced Instruction Set Computer)指令集。 精简指令集系统的设计思想就是：把复杂指令集中一些不常用的指令踢出指令集，这些复杂指令由日益强大的软件技术(编译)去实现，这样使得每个指令的流水线分段比较均匀，充分利用了处理器的流水线结构，提高了主频。 MIPS指令集以32个寄存器为中心，只能通过<strong>Load/Store</strong>指令访问内存，其余涉及计算的指令都从寄存器堆中读取数据，并且将计算结果写入寄存器堆中。 另外，MIPS指令的格式比较规整，所有指令长度一致，指令操作码都在固定的位置；寻址方式、对于每条指令的操作都很简单。 那么CISC与RISC的区别是什么呢？ 最大的区别在于：RISC只能通过<strong>Load/Store</strong>指令访问内存，而CISC指令集则没有这个限制。</p><h2 id="arm指令集">ARM指令集</h2><p>ARM指令集属于RISC指令集，每条指令32位。 ARM也有16位的压缩指令集，这是为了避免32位出现的码字浪费，提高运行速度推出的。</p><ul><li>ARM指令由于属于RISC指令集，一般完成的操作比较简单。程序员可以通过多条简单的指令组合实现一个复杂的操作。</li><li>同样的，ARM指令集也是只能通过<strong>Load/Store</strong>指令读取内存中的数据到寄存器，其余的指令只能对寄存器的操作数进行处理。</li><li>大多数指令长度相同，字段位置(尤其是操作码的位置)固定，且具有“条件执行”模式。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fourier Transform</title>
      <link href="/2018/05/06/Fourier%20Transform/"/>
      <url>/2018/05/06/Fourier%20Transform/</url>
      
        <content type="html"><![CDATA[<p>为了在统一框架里分析周期信号与非周期信号，可以给周期信号也建立傅里叶变换。 有两种方法求周期信号的傅里叶变换：</p><ol type="1"><li><p>利用傅里叶级数进行构造 对于周期信号<em><span class="math inline">\(x(t)\)</span></em>，其傅里叶级数展开式为： <span class="math display">\[x(t) = \sum_{k = -\infty}^{+\infty}a_ke^{jkw_0t}\]</span> 系数<span class="math inline">\(a_k\)</span>表示为： <img src="https://img-blog.csdn.net/20180510103617263?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" /> 由于 <img src="https://img-blog.csdn.net/20180510104202240?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" /> 说明周期性复指数信号的频谱是一个冲激，那么我们推广这个关系，可得： <img src="https://img-blog.csdn.net/20180510104448987?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" /> 表明：周期信号的傅里叶变换由一系列等间隔的冲激函数线性组合而成，每个冲激分别位于信号各次谐波的频率处，其强度是傅里叶级数系数的<span class="math inline">\(2\pi\)</span>倍。</p></li><li><p>周期延拓 这种方法先将<span class="math inline">\(x(t)\)</span>在一个周期内截断，得信号<span class="math inline">\(x_T(t)\)</span>，求出<span class="math inline">\(x_T(t)\)</span>的傅里叶变换<span class="math inline">\(X_T(w)\)</span>，再对<span class="math inline">\(X_T(w)\)</span>周期延拓得<span class="math inline">\(X(w)\)</span>。 具体来说： 根据<span class="math inline">\(\delta\)</span>函数性质，有： <span class="math display">\[x(t) = x_T(t)*\sum_{k = -\infty}^{+\infty}\delta(t - kT)\]</span> 设周期冲激串<span class="math inline">\(\sum_{k = -\infty}^{+\infty}\delta(t - kT)\)</span>的傅里叶变换为<span class="math inline">\(F(w)\)</span>， 由时域卷积定理： <span class="math display">\[X(w) = X_T(w)F(w)\]</span> 又时域周期为T的周期冲激串的傅里叶变换在频域是一个周期为<span class="math inline">\(\frac{2\pi}{T}\)</span>的周期冲激串，即： <span class="math display">\[F(w) = \frac{2\pi}{T}\sum_{k = -\infty}^{+\infty}\delta(w - \frac{2\pi k}{T})\]</span> 故可得： <span class="math display">\[X(w) = \frac{2\pi}{T}X_T(w)\sum_{k = -\infty}^{+\infty}\delta(w - \frac{2\pi k}{T})\]</span> 也就是： <span class="math display">\[X(w) = w_0\sum_{k = -\infty}^{+\infty}X_T(kw_0)\delta(w - kw_0)\]</span> 我们对比两种方法得到的结果，可知： 周期信号傅里叶级数的系数<span class="math inline">\(a_k = \frac{1}{T}X_T(kw_0)\)</span></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ProcessThread Synchronization</title>
      <link href="/2018/04/28/ProcessThread%20Synchronization/"/>
      <url>/2018/04/28/ProcessThread%20Synchronization/</url>
      
        <content type="html"><![CDATA[<h2 id="进程同步">进程同步</h2><p>进程间同步和进程间通信没必要区分过于清楚，一般能通信的机制也能用于同步。进程间通信（IPC）有以下几种： - 信号量（semaphores）：低级通信方式，分为整型和记录型； - 共享内存（shared memory）：高级方式； - 消息队列（message passing）：高级方式； - 管道通信（pipe）：高级方式。 - 套接字（socket）：网络上不同进程通信 - 信号（signal）：</p><p>进程间同步方式有： - 信号量（semaphores）： - 管程（monitors）：</p><p>由于进程之间一般是独立的，所以进程同步机制大多不需要锁。</p><h2 id="线程同步">线程同步</h2><p>线程同步机制有以下几种：</p><ul><li>互斥锁（mutex）：排他性访问共享数据，用来保护临界区。某个线程加锁后，其它要加锁的线程将被阻塞，申请失败进入休眠，直到锁被释放。</li><li>读写锁（ReadWriteLock）：用于读者-写者问题，共有三种状态：不加锁、读模式加锁、写模式加锁。每次只有一个线程可以占用写模式的锁，但可以有多个线程占有读模式锁。</li><li>自旋锁（spinlock）：专为多处理器并发引入，不断循环测试锁的状态，申请线程不会休眠，忙等锁。</li><li>条件变量（condition variables）</li><li>信号量（semaphores）：有更多取值空间，实现更复杂的同步。</li></ul><p>信号量和PV原语的使用可归纳为三种情形： 1. 把信号量视为<strong>加锁标志位</strong>，其目的是为了实现对某个<strong>唯一的共享数据</strong>的<strong>互斥访问</strong>，如各个进程间的某共享变量，数据库中的某个记录。 共享数据的值与信号量本身的值没有直接关系，信号量的作用仅仅是作为加锁标志位。其特征是<strong>信号量初始值为1</strong>，然后在一个进程内部对它进行配对的PV操作。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P(mutex);  <span class="comment">// mutex的初始值为1</span></span><br><span class="line">访问该共享数据;</span><br><span class="line">V(mutex);</span><br><span class="line">非临界区</span><br></pre></td></tr></table></figure></p><ol start="2" type="1"><li><p>把信号量视为某种类型的<strong>共享资源的剩余个数</strong>，目的是实现对这种类型的共享资源的访问，如各种I/O设备。 信号量的取值具有实际意义，即为<strong>空闲资源的个数</strong>。多个进程可以同时使用这种类型的资源，直到所有空闲资源均已用完。 其特征是信号量的<strong>初始值为<span class="math inline">\(N\geq 1\)</span></strong>，然后<strong>在一个进程内部对它进行配对的PV操作</strong>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P(resource);  <span class="comment">// resource的初始值为N</span></span><br><span class="line">使用该资源;</span><br><span class="line">V(resource);</span><br><span class="line">非临界区</span><br></pre></td></tr></table></figure></p></li><li><p>把信号量作为<strong>进程间同步</strong>的工具，利用它来设定<strong>两个进程在运行时的先后顺序</strong>。比如，它可以是某个共享资源的当前个数，但是由一个进程负责生成该资源，而另一个进程负责消费该资源，由此引发了两个进程间的先后顺序。 其特征是信号量的<strong>初始值为<span class="math inline">\(N\geq 0\)</span></strong>，然后<strong>在一个进程里对其使用V原语，增加资源个数，而在另一个进程里对其使用P原语，减少资源个数，</strong>从而实现两个进程之间的同步关系。 <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108183225108-1461792452.png" alt="image" /></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Process Synchronization-Example 2</title>
      <link href="/2018/04/20/Process%20Synchronization-Example%202/"/>
      <url>/2018/04/20/Process%20Synchronization-Example%202/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>理发店有一位理发师，一把理发椅和N把供等候的顾客坐的椅子。 如果没有顾客，理发师在理发椅上睡觉； 当有一个顾客到来时，他必须先唤醒理发师； 如果顾客来时理发师正在理发，如果有空椅子，坐下等待，否则离开。 用PV操作解决上述问题中的同步和互斥关系。</p><h2 id="分析">分析</h2><p>将顾客看作N个生产者，理发师是1个消费者。 理发师和椅子是临界资源，故顾客间是互斥关系； 理发师和顾客是同步关系。</p><p>信号量设置： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore barberReady = <span class="number">0</span>  互斥量，只能取<span class="number">0</span>或<span class="number">1</span>  </span><br><span class="line">Semaphore accessSeat = <span class="number">1</span>  互斥量，如果为<span class="number">1</span>，表明椅子数可以增加或减少，相当于给椅子加锁，避免两个顾客同时坐一把椅子</span><br><span class="line">Semaphore num_wait = <span class="number">0</span>   坐在椅子上等待的顾客数</span><br><span class="line"><span class="keyword">int</span> seat_free    空着的椅子数目</span><br></pre></td></tr></table></figure> <a href="https://en.wikipedia.org/wiki/Sleeping_barber_problem">参考wiki</a></p><h2 id="解答">解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顾客进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(accessSeat);  <span class="comment">//试图坐下</span></span><br><span class="line">        <span class="keyword">if</span>(seat_free &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            seat_free--;  <span class="comment">//坐下</span></span><br><span class="line">            V(num_wait);  <span class="comment">//试图唤醒理发师，</span></span><br><span class="line">            V(accessSeat);  <span class="comment">//不用再锁着椅子</span></span><br><span class="line">            P(baberReady); <span class="comment">//等待理发师ready</span></span><br><span class="line">            理发;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            V(accessSeat);  <span class="comment">//释放加在椅子上的锁</span></span><br><span class="line">            离开;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*理发师进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(num_wait);   <span class="comment">//尝试获得一位顾客，如果没有，去睡觉</span></span><br><span class="line">        P(accessSeat);   <span class="comment">//尝试获得椅子锁，更改空闲椅子数目</span></span><br><span class="line">        seat_free++;    <span class="comment">//空椅子加1</span></span><br><span class="line">        V(baberReady);    <span class="comment">//理发师准备好了</span></span><br><span class="line">        V(accessSeat);    <span class="comment">//无需继续锁着椅子</span></span><br><span class="line">        理发;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Process Synchronization-Example 1</title>
      <link href="/2018/04/11/Process%20Synchronization-Example%201/"/>
      <url>/2018/04/11/Process%20Synchronization-Example%201/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>把学生和监考老师都看作进程，学生有N人，教师1人。考场门口每次只能进出一个人，进考场原则是先来先进。当N个学生都进入考场后，教师才能发卷子。学生交卷后可以离开考场，教师要等收上来全部卷子并封装卷子后才能离开考场。问： - 需要设置几个进程？ - 用PV操作解决上述问题的同步互斥关系。</p><h2 id="分析">分析</h2><blockquote><p>考场门口每次只能进出一个人</p></blockquote><p>考场门口是共享资源。</p><blockquote><p>当N个学生都进入考场后，教师才能发卷子 教师要等收上来全部卷子并封装卷子后才能离开考场</p></blockquote><p>这是两个同步行为。</p><p>信号量设置： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">door = <span class="number">1</span>    <span class="comment">//能否进出门口</span></span><br><span class="line">mutex1 = <span class="number">1</span></span><br><span class="line">mutex2 = <span class="number">1</span>   <span class="comment">//互斥信号量</span></span><br><span class="line">sr = <span class="number">0</span>   <span class="comment">//学生是否到齐</span></span><br><span class="line">eb = <span class="number">0</span>    <span class="comment">//考试开始</span></span><br><span class="line">eo = <span class="number">0</span>     <span class="comment">//考试结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_stu = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num_paper = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><h2 id="解答">解答</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*学生进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">student</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(door);</span><br><span class="line">    进门;</span><br><span class="line">    V(door);</span><br><span class="line">    P(mutex1);  <span class="comment">//增加学生人数</span></span><br><span class="line">    num_stu++;</span><br><span class="line">    <span class="keyword">if</span>(num_stu == N)</span><br><span class="line">    V(sr);</span><br><span class="line">    V(mutex1);</span><br><span class="line">    P(eb);  <span class="comment">//等教师宣布开始考试</span></span><br><span class="line">    考试;</span><br><span class="line">    交卷;</span><br><span class="line">    P(mutex2);   <span class="comment">//增加试卷份数</span></span><br><span class="line">    num_paper++;</span><br><span class="line">    <span class="keyword">if</span>(num_paper == N)</span><br><span class="line">    V(eo);</span><br><span class="line">    V(mutex2);</span><br><span class="line">    P(door);</span><br><span class="line">    出门;</span><br><span class="line">    V(door);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*教师进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">teacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P(door);</span><br><span class="line">    进门;</span><br><span class="line">    V(door);</span><br><span class="line">    P(sr);  <span class="comment">//最后一个学生唤醒老师</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= N;i++)</span><br><span class="line">    发卷子;</span><br><span class="line">    V(eb);     <span class="comment">//开始考试</span></span><br><span class="line">    P(eo);   <span class="comment">//等待考试结束</span></span><br><span class="line">    封装;</span><br><span class="line">    P(door);</span><br><span class="line">    出门;</span><br><span class="line">    V(door);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pattern Matching</title>
      <link href="/2018/04/02/Pattern%20Matching/"/>
      <url>/2018/04/02/Pattern%20Matching/</url>
      
        <content type="html"><![CDATA[<p>字符串模式匹配，即子串的定位操作。就是判断主串S中是否存在给定的子串，如果存在，那么返回子串在S中的位置，否则返回-1。 实现这种操作有两种算法：</p><h2 id="朴素的模式匹配算法">朴素的模式匹配算法</h2><p>设主串S长度为n，子串T长度为m。 对于主串的每个字符，做长度为m的循环，判断是否与子串匹配。 最好的情况就是一开始就匹配成功，时间复杂度<span class="math inline">\(O(1)\)</span>；最坏的情况就是每次匹配失败都是在T的最后一个元素，复杂度<span class="math inline">\(O(nm)\)</span>;平均情况复杂度<span class="math inline">\(O(n+m)\)</span>。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">size</span>() &gt; s.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; j &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[j] == s[i]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == t.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="kmp算法">KMP算法</h2><p>KMP主要分两步： 1. 进行T的自匹配，这一步关键在于得到Next数组，从T的第一位开始对自身匹配，在某一位置能匹配的最长长度即是当前位置Next值。 Next中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度，将Next[0] = -1。 举例来说：T=ababaca，前缀为pre，后缀为post。 i = 1: 要处理"a", pre = "", post = "", Next[1] = 0; i = 2: 要处理"ab", pre = a, post = b, Next[2] = 0; i = 3: 要处理"aba", pre = {a, ab}, post = {ba, a}, Next[3] = 1; i = 4: 要处理"abab", pre = {a, ab, aba}, post = {bab, ab, b}, Next[4] = 2; i = 5: 要处理"ababa", pre = {a, ab, aba, abab}, post = {baba, aba, ba, a}, Next[5] = 3; ...... Next数组{-1，0，0，1，2，3，0，1} 2. S与T的匹配，这步的匹配和朴素匹配没有太大差异，只是主串S的指针不用回溯，而将子串的指针j回溯到Next[j]位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextCompute</span><span class="params">(string t, vector&lt;<span class="keyword">int</span>&gt;&amp; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || t[i] == t[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(t.size() + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">nextCompute</span>(t, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; (<span class="keyword">int</span>)s.<span class="built_in">size</span>() &amp;&amp; j &lt; (<span class="keyword">int</span>)t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == t[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == t.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进kmp算法">改进KMP算法</h2><p>主要改进了Next数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计算next数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next_compute</span><span class="params">(<span class="keyword">char</span> T[], <span class="keyword">int</span>* next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == j || T[i] == T[j]) &#123;   <span class="comment">// 自匹配</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i] != T[j])</span><br><span class="line">                next[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[i] = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];  <span class="comment">// 字符不同，j值回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></int></int></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Damaged Hard Drive and Reinstall System</title>
      <link href="/2018/03/29/Damaged%20Hard%20Drive%20and%20Reinstall%20System/"/>
      <url>/2018/03/29/Damaged%20Hard%20Drive%20and%20Reinstall%20System/</url>
      
        <content type="html"><![CDATA[<h2 id="缘由">缘由</h2><p>我是ACER笔记本，电脑从桌子上重摔，之后几天可以正常使用。可是后来看完视频准备退出的时候，发现所有页面已经卡死了，内存占用已经超过了80%，任务管理器没有反应，不得已按了电源键强制关机。 接着就再也启动不了，开机后一直显示No bootable device。 进入BIOS发现检测不到硬盘，估计是硬盘损坏了。啊~所有数据全都GG了！！！</p><h2 id="硬盘处理">硬盘处理</h2><p>先是用WinPE启动盘进入DiskGenius查看，没有我的HDD； 接着拆机，把硬盘重新插拔一下（也许是连接松了呢~），还是没用； 最后用硬盘盒子接到室友电脑，还是无法检测，这下彻底确认硬盘凉了； 拿去维修店，专业人员检测后说是磁头坏了，修复数据1T要800RMB，哇穷~ 换块新的要480，有点坑哦！ 还是自己买一块希捷的，加上各种优惠，不到300RMB。</p><h2 id="重装系统">重装系统</h2><p>第一次重装系统，折腾了很久，试错的细节记不清了，只说一下大体的步骤：</p><ol type="1"><li>插上新硬盘之后，先用WinPE启动，用DiskGenius将硬盘的MBR格式转为GPT格式，此时不用分区；</li><li>插上U盘启动盘，重启电脑，按F2进入BIOS，切记关掉Boot Security，否则系统无法安装；</li><li>如果出现安装程序无法创建新的系统分区，也无法定位现有系统分区的提示，建议如下处理： a-在安装界面按Shift+F10进入命令行； b-输入diskpart启动磁盘程序，接着输入list disk查看电脑的硬盘； c-按提示输入select disk 0，选中编号为0的磁盘，输入clean，删除硬盘所有数据； d-输入convert GPT，转换格式，然后list partition，查看分区情况； e-输入create partition efi size<em>100，创建EFI分区，大小100MB； f-输入create partition msr size</em>128，创建MSR分区，大小128MB； g-输入create partition primary size*50000，创建主分区，大小50GB。(建议这个系统盘分的大一点，否则以后清理很麻烦)； h-输入list partition，查看分区情况。 P.s. 遇到这种情况，网上有的说可以重新插拔u盘启动盘，刷新；或者利用Windows自带的引导文件安装，具体的可以自己试试~</li><li>下来一路Next，装系统即可。</li></ol><h2 id="再次遭殃">再次遭殃</h2><p>距离上次硬盘事件已经过去了一年半，当我开心地吃着零食追着剧，想把页面切到咪咕下几首歌时，电脑瞬间卡死。 后来反思了一下：一是我习惯长期不关电脑，只是进入睡眠状态，可能资源本身已经占用很多了；二是打开的页面太多，而且切换太过频繁。 强制关机后就Game Over了~（遇到这种情况，一定不要继续操作，等着吧！等到听不到硬盘的转动声再按电源键！！！） BIOS偶尔还能检测到HDD，经过专业人士检测：硬盘损坏，600RMB修复1T，好像比上次便宜了一些~ 一般机械硬盘保修期都是2年，所以就免费换了块新的~ 建议有条件的直接上固态吧，条件差点的可以固态装系统、机械存文件，没条件的就凑合用吧。。。 这次数据损失不大，吃了一堑还是有点用的，不过备份频率得改为一周一次了。 重装系统可以去老毛桃做个启动盘，把Windows的ISO镜像拷到U盘根目录，开机进入Win PE系统后，里面有个一键装机的软件~ 不过不知道是不是由于机型的原因，那个软件我的本用不了（垃圾Acer）： 所以就利用UltraISO把ISO镜像写入到U盘，插上之后开机，就会进入Windows的安装引导程序，分区也会在其中的一步引导你去做。 不同机型可能稍有差异，具体步骤可以参考<a href="https://blog.csdn.net/weixin_43175701/article/details/84349445">笔记本换硬盘装系统完整教程</a>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fibonacci Sequence</title>
      <link href="/2018/02/07/Fibonacci%20Sequence/"/>
      <url>/2018/02/07/Fibonacci%20Sequence/</url>
      
        <content type="html"><![CDATA[<h2 id="递归">递归</h2><p>斐波那契数列定义： <span class="math display">\[F(n)=\left\{\begin{matrix}0, n=0\\1, n=1\\F(n-1)+F(n-2), n&gt;1\end{matrix}\right.\]</span> 递归解法最直观，但是复杂度也最高：<span class="math inline">\(O(2^n)\)</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="comment">//细节可以处理非法输入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 为了避免重复计算，可以将每一步计算得到的<span class="math inline">\(F(i)\)</span>存起来，这样的话时间复杂度降为<span class="math inline">\(O(n)\)</span>，但空间复杂度升为<span class="math inline">\(O(n)\)</span>。 ## 通项 求解通项的方法有好几种，下面展示一种用线性代数求解的方法： 斐波那契数列的递推公式是二阶差分方程，先用一点小技巧将其化为一阶： <span class="math display">\[\begin{cases}F_{k+2}=F_{k+1}+F_{k}\text{}\\F_{k+1}=F_{k+1}\text{}\\\end{cases}\]</span> 我们令<span class="math inline">\(u_k=\begin{bmatrix}F_{k+1}\\F_{k}\\\end{bmatrix}\)</span>，那么<span class="math inline">\(u_{k+1}=\begin{bmatrix}F_{k+2}\\F_{k+1}\\\end{bmatrix}=\begin{bmatrix}1\ 1\\1\ 0\\\end{bmatrix}u_k\)</span>。 矩阵<span class="math inline">\(A=\begin{bmatrix} 1\ 1\\1\ 0\\\end{bmatrix}\)</span>，令<span class="math inline">\(det(A-\lambda I)=\lambda^2-\lambda-1=0\)</span>，求得<span class="math inline">\(\lambda=\frac{1\pm \sqrt5}{2}\)</span>，对应于两个特征值的特征向量为<span class="math inline">\(x_1=\begin{bmatrix} \lambda_1\\ 1\\ \end{bmatrix},x_2=\begin{bmatrix} \lambda_2\\ 1\\ \end{bmatrix}\)</span>。 求得特征值和特征向量后，我们将<span class="math inline">\(u_0=\begin{bmatrix} F_1\\ F_0\\ \end{bmatrix}=\begin{bmatrix} 1\\ 0\\ \end{bmatrix}=c_1x_1+c_2x_2\)</span>，解得<span class="math inline">\(c_1=-\frac{1}{\sqrt5}, c_2=\frac{1}{\sqrt5}\)</span> 故 <span class="math inline">\(u_k=S\Lambda^{k}c=\begin{bmatrix} c_1\lambda_1^{k+1}+c_2\lambda_2^{k+1}\\c_1\lambda_1^{k}+c_2\lambda_2^{k}\\\end{bmatrix}\)</span> 所以通项公式可以表示为<span class="math inline">\(F(n)=C_1\lambda_1^n+C_2\lambda_2^n\)</span>。 故斐波那契数列的通项公式为：<span class="math inline">\(F(n)=\frac{1}{\sqrt5}[(\frac{1+\sqrt5}{2})^n-(\frac{1-\sqrt5}{2})^n]\)</span> 用公式求解的复杂度为<span class="math inline">\(O(1)\)</span>，但是由于无理数在计算机中的存储不是精确的，所以结果的精度很难保证。 ## 分治 通过矩阵形式的递推： <span class="math display">\[\begin{bmatrix}F(n)\\ F(n-1)\end{bmatrix}=\begin{bmatrix}1\  1\\ 1\  0\end{bmatrix}\begin{bmatrix}F(n-1)\\ F(n-2)\end{bmatrix}\]</span> 不断向下递推，可以得到： <span class="math display">\[\begin{bmatrix}F(n)\\ F(n-1)\end{bmatrix}={\begin{bmatrix}1\  1\\ 1\  0\end{bmatrix}}^{n-1}\begin{bmatrix}F(1)\\ F(0)\end{bmatrix}\]</span> 接下来就是求解矩阵的高次方，通过<a href="https://baike.baidu.com/item/快速幂/5500243">快速幂</a>可以在<span class="math inline">\(O(logn)\)</span>时间内进行计算： 整数的快速幂代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> half = raise(base, <span class="built_in">exp</span> / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> base * half * half;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> half * half;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将传入的参数改为矩阵，乘法改为矩阵乘法，就可以得到矩阵快速幂： 以二阶矩阵为例，求解斐波那契数列： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;base,ans;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">multi</span><span class="params">(Matrix a, Matrix b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) <span class="comment">//第i行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)  <span class="comment">//第j列</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.a[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                res.a[i][j] += a.a[i][k] * b.a[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">QuickPow</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base.a[<span class="number">0</span>][<span class="number">0</span>] = base.a[<span class="number">0</span>][<span class="number">1</span>] = base.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    base.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;   <span class="comment">//初始化矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果矩阵初始化为单位阵</span></span><br><span class="line">    ans.a[<span class="number">0</span>][<span class="number">0</span>] = ans.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    ans.a[<span class="number">1</span>][<span class="number">0</span>] = ans.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = multi(ans, base);</span><br><span class="line">        &#125;</span><br><span class="line">        base = multi(base, base);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    QuickPow(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.a[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 动态规划 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">        ans = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Refs <a href="https://www.zhihu.com/question/28062458/answer/39763094">斐波那契数列</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hardware Introduction</title>
      <link href="/2018/01/20/Hardware%20Introduction/"/>
      <url>/2018/01/20/Hardware%20Introduction/</url>
      
        <content type="html"><![CDATA[<p>计算机硬件组成可以概括为下图： <img src="https://img2020.cnblogs.com/blog/1260581/202007/1260581-20200709090940726-1373637720.png" /> ## CPU CPU生产商主要是Intel和AMD。 Intel的产品主要有四种：</p><ul><li>Celeron(赛扬)：低端处理器</li><li>Pentium(奔腾)：比赛扬强，比酷睿弱</li><li>Xeon(至强)：属于服务器处理器 -E3 -E5 -E7</li><li>Core(酷睿) -i3 -i5 -i7</li></ul><p>AMD产品主要有三种： - FX系列：旗舰级多核处理器，AMD FX-8350 - Athlon(速龙)系列：入门级多核处理器，AMD Athlon X4 870K - A系列(APU)：A4，A6，A8，A10依次增强，集成了核心显卡，A10-7870K</p><p>以Core i7-4770K为例，Core系列i7级别第4代处理器，770代表性能编号，代数相同，编号越大，性能越好；K代表可超频。 笔记本CPU可能带有后缀U/Y/M等： - U：超低功耗笔记本CPU - Y：极低功耗笔记本CPU，比U更省电 - M：笔记本CPU</p><h2 id="显卡">显卡</h2><p>显卡分为核显和独显，核显集成于CPU内部，独显与CPU独立。 独显由GPU(图形处理器)和其他结构(显存，散热模块，PCB板等)组成。 目前生产GPU的主流厂商有三家：AMD，NVIDIA，Intel： - AMD(A卡) -HD系列：AMD HD 7970 x2---第7代高端(数字9代表高端，8中端，7低端)双核GPU，第三位7代表性能，3，5，7，9依次增强，x2代表双核心。 -R系列：AMD R9 M290X---R9：R系列高端；M：笔记本GPU；290X：2代高性能增强型GPU。</p><ul><li><p>NVIDIA(N卡) NVIDIA GTX 980 TI：X表示性能比GT系列更强；980：9代高性能；TI：增强型。</p></li><li><p>Intel(I卡) I卡都是核显，有两个系列： -HD系列：HD P4600---P：企业级；4600：代表性能，一般数字越大，性能越好。 -Iris(锐炬)系列：Iris Pro 5200---Pro：专业版；5200：代表性能，同上。</p></li></ul><p>显存：SDDR3，DDR3，GDDR3，GDDR5，同容量下性能依次增加。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Rabbit and Turtle</title>
      <link href="/2016/10/15/Rabbit%20and%20Turtle/"/>
      <url>/2016/10/15/Rabbit%20and%20Turtle/</url>
      
        <content type="html"><![CDATA[<p>知乎上有这样一个问题：<a href="https://www.zhihu.com/question/22364825/answer/27255001">如果兔子都在拼命奔跑，是什么给了作为乌龟的你前进的动力？</a> 随着视野的不断开阔，我们难免怀疑自身前进的意义，曾经有很长一段时间我也深陷其中，直到看到余亦多先生的回答才有所感悟。</p><blockquote><p>我想每个人成长的经历中，都会或多或少曾被“自卑”的情绪所笼罩。我自己就是一个一直纠缠于“失败者”情结的人。</p><p>小时候因为痴肥，体育课上在同学面前抬不起头；搬到大城市，因为口音以及内向的性格，成为全班男生的出气筒；到了高中，进到全省理科实验班，才知道有些学霸的智商，是自己一辈子都无法企及的；初到美国，被身边同学认为是FOB，来自第三世界国家的乡巴佬；混进所谓的世界名校，看到身边一大波牛人，陷入平庸的沮丧；好不容易挤到纽约华尔街，看到名校中选出的所谓“精华”，才开始面对自己综合能力的缺失。</p><p>再回到香港，身边很多投行同事的业务能力与人际能力都远胜于我，只能在高压力的环境下苟延残喘；从乙方转到甲方开始做PE投资后，当跟索罗斯的儿子同桌斗智斗勇时，才能深刻体会“家学渊源”与“赢在起跑线”对一个人的意义。</p><p>由外资换到国企，开始看到体制内藏龙卧虎的主流玩家真正在玩什么，才意识到以前在边缘化外资环境下膨胀出各种不接地气的泡沫有多么可笑；随后开始接触到保险、银行以及其他金融领域的强人们，才知道在整个金融大版图中，十倍百倍于自己原来折腾的小池塘规模的资金，是在做什么。</p><p>分享了上面一大段，其实我想说的，最重要是如下几点：<br />1、就像talich老师在我去斯坦福念书以前赠我的那句话： 到了那儿，不用指望成为牛人，但至少你知道大海有多宽，能看到牛人在做什么，就够了。 对乌龟来讲，兔子存在的意义在于，至少让它知道这世界还有“兔子”的存在，以及兔子跑得有多快。盗用一句标语：让你看到更大的世界，这本身就是最大的意义。 2、兔子的存在，能够让乌龟直面自己就是一只乌龟这个事实。有勇气面对真实的自己，才能准确的定位自己的位置，也才能冷静的思考最适合自己的人生规划。而这，很多时候恰恰是最知易行难的事。 3、其实人越往后走，越会深刻体会到“阶级”的不可逾越性。愤青的时候会咒骂：“这世界为什么这么不公平。”可当你不再被荷尔蒙冲昏头脑时，也许你会开始思考：既然现在是这种情况，那我应该做点什么呢？当你绞尽心机让自己变得更好的同时，也许你也在让这个世界变得更好。</p><p>当樱木花道完成两万球的训练之后，他才知道流川枫有多厉害。 因为在一次比赛中，他看到流川枫的一个中投，这个起跳，这个姿势，这个弧线，竟然是他训练中想象的最完美的画面。 他很气，紧握这拳头，又不甘心，他问教练：这只狐狸是从什么时候开始打篮球的？ 安西教练：你应该好好的盯着流川枫的姿势，尽可能的模仿他，然后用3倍于他的训练量训练。这样，你才有可能在高中阶段之内超越他。 流川枫是那只兔子，幸运的是，樱木大概也是。</p><p>题主的困惑在于，樱木是个天才，尚且如此，而你，可能只是木暮。 李宗盛有一首歌，歌词是这样的： 最近比较烦比较烦比较烦，我看那远方怎么也看不到岸，那个后面还有一班天才追赶，写一首皆大欢喜的歌，是越来越难。</p><p>中年危机全都是这样的： 前面比你牛逼的人一眼都望不到岸，后面一班天才，比你有精力，比你聪明，比你学历高，比你国际化。而你，小孩成绩你得操心，老婆吃秘书的醋你也得操心，父母身体逐渐糟糕，最可怕的是你头发越来越少，身体越来越胖。</p><p>题主的困惑在于，比你天才的那个人，还比你努力；比题主的困惑更可怕的是，这个比你努力的天才，还比你年轻，比你有精力，这意味着，即使你想努力，你也没有那个精力努力。这就更无力了。</p><p>《蜗居》里面，宋思明想抢郭海藻。他比小贝成熟、稳重、懂得女孩的心思，样貌也不差；他有钱，有人际，能帮海藻解决问题。 若是宋思明未婚，小贝拿什么跟人家拼？小贝可能一辈子都达不到宋思明的高度，即使拼尽全力。 这才是无力感。 所以，我们能做什么。</p><p>如果你是个绝对的蠢蛋，那我只能说，请你尽量少的认识这个世界，最好一辈子不要离开你生活的地方，有时候知道的越多，越痛苦。当你看到那么繁华的城市，那么美丽的女孩，那么高端大气上档次的生活都与你无关的时候，更多的痛苦便会袭来。 如果你是个笨蛋，又不肯努力，那也请你知道少一点。 如果你不是个绝对的蠢蛋，又愿意努力，请你参考第一段安西老师的话：盯着那只兔子的每一个动作，能学多少学多少，然后以他三倍的训练量训练。</p><p>兔子一定会打盹的，即使牛逼如牛顿，30岁之后也再无建树；也不是每个像科比一样的天才，都知道洛杉矶凌晨四点的样子；你知道洛克李吗？火影里那个相信笨鸟先飞的热血少年，他说，努力的天才也是天才。 我曾经在一个答案中说过，勤奋，可能是这个世界上最被高估的美德。但是对于一个毫无天赋的人来讲，可以依仗的就只有勤奋了。</p><p>如此，即便你还是追不上兔子，你可以是乌龟里跑得快的那一个。 如此，即便你是木暮，你也能做成一个，每天都比昨天好一点点的木暮。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

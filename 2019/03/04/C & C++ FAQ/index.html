<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Monaco:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eimadrigal.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C&#x2F;C++常见问题">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;C++ FAQ">
<meta property="og:url" content="https://eimadrigal.github.io/2019/03/04/C%20&%20C++%20FAQ/index.html">
<meta property="og:site_name" content="EI Madrigal&#39;s Space">
<meta property="og:description" content="C&#x2F;C++常见问题">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://eimadrigal.github.io/2019/03/04/C%20&%20C++%20FAQ/虚表.png">
<meta property="article:published_time" content="2019-03-04T12:37:32.000Z">
<meta property="article:modified_time" content="2022-09-02T01:54:55.703Z">
<meta property="article:author" content="EIMadrigal">
<meta property="article:tag" content="Language">
<meta property="article:tag" content="Interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eimadrigal.github.io/2019/03/04/C%20&%20C++%20FAQ/虚表.png">

<link rel="canonical" href="https://eimadrigal.github.io/2019/03/04/C%20&%20C++%20FAQ/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C/C++ FAQ | EI Madrigal's Space</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EI Madrigal's Space</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2019/03/04/C%20&%20C++%20FAQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C/C++ FAQ
        </h1>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-04 20:37:32" itemprop="dateCreated datePublished" datetime="2019-03-04T20:37:32+08:00">2019-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-09-02 09:54:55" itemprop="dateModified" datetime="2022-09-02T09:54:55+08:00">2022-09-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">C/C++常见问题</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="指针和引用">指针和引用</h2>
<ol type="1">
<li>指针是一个新的变量，存储另一个变量的地址，可以通过指针修改另一个变量；引用是一个别名，对引用的操作就是对变量本身的操作。</li>
<li>指针可以有多级；引用只有一级。</li>
<li>指针的大小一般4B；引用的大小一般取决于被引用对象大小。</li>
<li>指针可以为空；引用不能为空。</li>
<li>传参选择：传参时传引用与传指针效果相同，传引用，没有产生实参的副本，直接对实参操作，传指针，被调函数需要给形参分配空间，可读性差，需要传地址做实参，传引用更简单清晰。返回被调函数局部变量的内存时传指针，使用后及时释放避免内存泄漏；返回局部变量的引用没有意义，会自动销毁。传指针需要单独开辟内存；在对栈空间大小敏感时（如递归）传引用，无需创建临时变量，开销更小。类对象作为参数时传引用是C++传递类对象的标准方式。</li>
</ol>
<p>引用只是一个别名，不是一种数据类型，不占存储空间，不能建立数组的引用<br />
引用必须初始化，指针不必<br />
引用初始化后不能改变，指针可以改变指向的对象<br />
不存在指向空值的引用，存在指向空值的指针</p>
<h2 id="空类">空类</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sizeof(A) = 1</span></span><br></pre></td></tr></table></figure>
<p>空类的大小之所以为1，因为标准规定完整对象的大小&gt;0，否则两个不同对象可能拥有相同的地址，故编译器会生成1B占位符。
那么两个对象为什么不能地址相同呢？</p>
<blockquote>
<p>There would be no way to distinguish between these two objects when
referencing them with pointers.</p>
</blockquote>
<p>空类中到底都有什么呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>();  <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp;);  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>();  <span class="comment">// 析构函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;);  <span class="comment">// 赋值运算符</span></span><br><span class="line">    A* <span class="keyword">operator</span>&amp;();  <span class="comment">// 取址运算符（非const）</span></span><br><span class="line">    <span class="keyword">const</span> A* <span class="keyword">operator</span>&amp;() <span class="keyword">const</span>;  <span class="comment">// 取址运算符（const）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仅仅声明一个类，不会创建这些函数。只有当定义类的对象时，才会产生。</p>
<h2 id="多态polymorphism">多态Polymorphism</h2>
<p>OOP的特点包括封装、继承和多态。</p>
<p>封装的目的是将类的<strong>实现</strong>和<strong>使用</strong>分离，隐藏实现细节，保留部分接口和方法供外人使用，避免程序互相依赖，使得模块松耦合。<br />
继承是为了复用基类中的属性和方法，实现了代码的可重用性。<br />
多态按照字面意思：同一接口的多种不同的实现方式，同种操作作用于不同的对象可以产生不同的行为和执行结果。可以有效避免代码冗余重复，重复是万恶之源！！</p>
<p>根据状态确定时间分为静态多态和动态多态，静态多态在编译时就确定了，动态多态运行时确定。</p>
<p>静态多态主要包括函数重载和运算符重载，动态多态主要通过继承和虚函数实现。定义虚函数<code>f</code>，是为了用基类的引用或指针调用派生类的<code>f</code>，最终调用哪个<code>f</code>取决于对象的实际类型（基类还是派生类），即在运行时选择函数的版本，也就是所谓的<strong>动态绑定</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;animal&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line">  ~<span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal* animal = <span class="keyword">new</span> Dog;</span><br><span class="line">animal-&gt;<span class="built_in">f</span>();  <span class="comment">// 输出animal  </span></span><br></pre></td></tr></table></figure>
<p>将函数<code>f</code>改为虚函数： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;animal&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Dog</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dog&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal* animal = <span class="keyword">new</span> Dog;</span><br><span class="line">animal-&gt;<span class="built_in">f</span>();  <span class="comment">// 输出dog </span></span><br></pre></td></tr></table></figure></p>
<p>当基类指针指向派生类对象，用该指针调用同名成员函数时，基类声明为虚函数（子类可以不写<code>virtual</code>）就会调用派生类的<code>f</code>，否则调用基类的<code>f</code>。</p>
<p>如果没有虚函数，管理大量的派生类对象<code>Dog/Cat</code>等就需要声明相应的指针，有虚函数的话，就可以声明为指针数组<code>Animal* animals[5]</code>指向相应的派生类对象，然后直接<code>animals[i]-&gt;f()</code>即可。</p>
<h3 id="构造函数和析构函数">构造函数和析构函数</h3>
<p>析构函数可以并且应当是虚函数，因为要确保执行相应对象的析构函数。如果基类指针指向派生类对象，会调用派生类的析构函数并释放资源，然后调用基类的析构函数。当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。否则<code>delete animal</code>时调用<code>Animal</code>的析构函数，<code>Dog</code>的资源未释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造时，先调用父类构造函数，再调用子类构造函数</span></span><br><span class="line"><span class="comment"> * 析构时，先调用子类析构函数，再调用父类析构函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 子类构造函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 调用父类构造函数</span></span><br><span class="line"><span class="comment"> *  2. 把CDerived的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  3. 初始化CDerived的成员变量</span></span><br><span class="line"><span class="comment"> *  4. 调用函数Init()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 父类构造函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 把CBase的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  2. 初始化CBase的成员变量</span></span><br><span class="line"><span class="comment"> *  3. 调用函数Init()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 子类析构函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 把CDerived的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  2. 调用函数Uninit()</span></span><br><span class="line"><span class="comment"> *  3. 调用父类CBase的析构函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 父类析构函数流程：</span></span><br><span class="line"><span class="comment"> *  1. 把CBase的虚函数表地址赋值给对象的虚函数表指针</span></span><br><span class="line"><span class="comment"> *  2. 调用函数Uninit()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 构造函数或析构函数中调用虚函数与普通函数调用方式一样，相当于调用CBase::Init()</span></span><br><span class="line"><span class="comment"> * 由于编译器对构造函数和析构函数做了特殊处理，因此不会多态</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 虚函数调用过程：</span></span><br><span class="line"><span class="comment"> *  1. 获取this指针的地址</span></span><br><span class="line"><span class="comment"> *  2. 通过this指针得到虚函数表地址，通常this指针指向vptr</span></span><br><span class="line"><span class="comment"> *  3. 虚函数表地址加上函数在表内偏移量得到函数地址</span></span><br><span class="line"><span class="comment"> *  4. 通过call命令调用函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 调用父类还是子类的函数，关键在于vptr指向父类还是子类的虚函数表</span></span><br><span class="line"><span class="comment"> * 构造函数和析构函数中，vptr均设置为指向当前类的虚函数表，因此均调用当前类的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;  <span class="comment">// 重写f</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">f</span>();  <span class="comment">// 调用派生类的f()</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基类指针<code>p</code>调用虚函数<code>f</code>，<code>f</code>作用的可能是基类对象，也可能是派生类对象，这就是多态（同样消息作用于不同类型对象产生不同的行为）的一种方式，即动态多态。
正因为编译器无法确定使用哪个虚函数，所以所有的<strong>虚函数必须定义</strong>，否则编译器会报错。</p>
<p><strong>构造函数不能是虚函数</strong>，因为构造对象时必须明确知道其类型。如果是虚函数，调用时只需要提供接口，编译器无法知道你想构造继承树的哪个类型。</p>
<p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，<strong>由于对象还未创建成功，编译器无法知道对象的实际类型</strong>，是类本身还是类的派生类等等</p>
<p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p>
<p>C++他爹Bjarne Stroustrup是这么说的：</p>
<blockquote>
<p>A virtual call is a mechanism to get work done given partial
information. In particular, "virtual" allows us to call a function
knowing only an interfaces and not the exact type of the object. To
create an object you need complete information. In particular, you need
to know the exact type of what you want to create. Consequently, a "call
to a constructor" cannot be virtual.</p>
</blockquote>
<p>构造函数或者析构函数中调用虚函数会怎样？<br />
在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式，无法<a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/35632207">实现多态</a>。<br />
在析构函数中调用虚函数，此时调用的是子类的函数实现方式。</p>
<p>函数只声明不定义有什么问题？<br />
类中普通函数没问题，虚函数链接时会报错<code>undefined reference to vtable for Base</code>，无法获取虚函数的地址并填充虚表。<a
target="_blank" rel="noopener" href="https://python.iitter.com/other/173960.html">参考</a></p>
<p>https://www.geeksforgeeks.org/can-static-functions-be-virtual-in-cpp/</p>
<h3 id="虚函数表-虚函数指针">虚函数表 &amp; 虚函数指针</h3>
<p>编译器处理虚函数的方法是：如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过vptr找到类中的虚函数表，找到相应的函数进行调用。</p>
<p>一个类的所有实例共享同一张虚表：</p>
<figure>
<img src="虚表.png" alt="虚函数表与虚函数指针" />
<figcaption aria-hidden="true">虚函数表与虚函数指针</figcaption>
</figure>
<h3 id="纯虚函数">纯虚函数</h3>
<p>与虚函数必须定义相反，纯虚函数无须定义（要定义必须在类的外部），含有纯虚函数的类是<strong>抽象基类</strong>。
抽象基类定义好接口，继承该类的其他类可以覆盖这个接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 声明纯虚函数</span></span><br></pre></td></tr></table></figure>
<p>之所以要引入纯虚函数，是因为很多时候基类产生对象是没有意义的。比如动物类可以派生出狗、猪等子类，但动物类生成对象毫无意义。
因此，不能创建抽象基类的对象，派生类必须覆盖(override)以定义自己的<code>f</code>，否则派生类仍然是抽象基类。</p>
<p>用基类的指针（引用）调用虚函数时就发生动态绑定：运行时，虚函数根据绑定对象的实际类型，选择调用函数的版本。
<a
target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/8262288d505d4fc599ebd9c8e7fd86ce">虚函数sizeof</a></p>
<h2 id="重载-覆盖-重写">重载 &amp; 覆盖 &amp; 重写</h2>
<ul>
<li>重载(overload)：在类内部发生。函数名相同，参数个数、参数类型、参数顺序至少有一种不同。返回值类型可以相同，也可不同；</li>
<li>覆盖(override)：覆盖基类的虚函数。函数名相同，参数相同，基类函数必须是虚函数；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span>B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;  <span class="comment">// 正确：f1与基类中的f1匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：B没有形如f2(int)的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：f3不是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 错误：B没有名为f4的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>重写(overwrite)：派生类的函数屏蔽了同名的基类函数：
派生类函数与基类函数同名，参数不同。不论基类函数是否为虚函数，都会被隐藏；
派生类函数与基类函数同名，参数相同。基类函数不为虚函数，会被隐藏；</li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://www.zhihu.com/question/21455159">函数重载按照返回类型</a><br />
<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html">C++函数重载</a></p>
<h2 id="static">static</h2>
<p>C++中<code>static</code>关键字用来<strong>声明类的成员</strong>：</p>
<ul>
<li>类的静态成员变量或函数属于类而非对象，只有一份副本；</li>
<li>静态成员函数没有<code>this</code>指针，只能访问类的静态数据；</li>
<li>静态成员函数不能定义为虚函数；</li>
<li>静态成员变量初始化<code>int Base::name = 0</code></li>
</ul>
<p>如果不是在类中声明成员，还有下面用法：</p>
<ul>
<li>隐藏作用：多文件编译时，定义的全局变量和函数都是整个工程可见的，只要使用时加上<code>extern</code>关键字即可。如果加上<code>static</code>关键字，那么该变量或函数就变为<strong>仅当前文件</strong>可见，这样我们可以在不同文件中定义同名的变量或函数而不用担心冲突。</li>
<li>全局生存期：<code>static</code>变量存储在静态数据区，默认值为0，<strong>只被初始化一次</strong>，即使作为局部变量，生存期也为整个程序，但作用域与普通变量相同，退出函数后即使变量存在，但不能使用。</li>
</ul>
<p>在C语言中主要有<a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/572547/what-does-static-mean-in-c">2种用途</a>:</p>
<ul>
<li>函数内的<code>static</code>变量在函数结束后仍然保持其值;</li>
<li><code>static</code>全局变量/函数只能在其定义的文件中调用,
可以用来进行访问控制和封装.</li>
</ul>
<h2 id="const"><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110159656">const</a></h2>
<ul>
<li>定义const对象：一旦创建其值不能改变，故const对象必须初始化。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> bufSize = <span class="number">512</span>;  <span class="comment">// the same as the previous one</span></span><br></pre></td></tr></table></figure>
<p>由于const对象默认只在文件内有效，所以如果要在文件间共享：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp定义并初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = <span class="number">512</span>;</span><br><span class="line"><span class="comment">// file1.h可以仅声明，不初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;</span><br></pre></td></tr></table></figure>
<ul>
<li>常量指针（const
pointer）：指针本身（存在指针中的地址）不可变，不能指向其他变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;num;  <span class="comment">// p将一直指向num</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指向常量的指针（pointer to const）：无法通过指针修改对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span>* p = &amp;pi;  <span class="comment">// 正确</span></span><br><span class="line">*p = <span class="number">4.1</span>;  <span class="comment">// 错误，不能通过p修改pi的值 </span></span><br></pre></td></tr></table></figure>
<ul>
<li>修饰成员函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 不能修改成员变量，const对象不能调用非const成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>修饰类对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A obj;  <span class="comment">// obj为常量对象，任何成员都不能被修改，任何非const成员函数都不能被调用</span></span><br><span class="line">obj.<span class="built_in">f1</span>();  <span class="comment">// 错误</span></span><br><span class="line">obj.<span class="built_in">f2</span>();  <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> A* obj  = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">obj-&gt;<span class="built_in">f1</span>();  <span class="comment">// 错误</span></span><br><span class="line">obj-&gt;<span class="built_in">f2</span>();  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<ul>
<li>转为非const</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* pc;  <span class="comment">// pc指向内容不可变</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);  <span class="comment">// 正确，但是通过p写值是未定义行为</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a和b必须是独立内存区域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inline">inline</h2>
<p>优点是没有函数调用开销，加快运行；缺点是增大代码体积，容易出现page
fault从而拖慢性能。<br />
<a
target="_blank" rel="noopener" href="https://algorithmlixuan.github.io/2018/10/11/c++lession4/">内联函数</a></p>
<h2 id="类型转换">类型转换</h2>
<p>类型转换分为隐式转换和显式转换。 显式转换有四种：</p>
<ul>
<li><code>static_cast</code> 没有底层const都可以，使用比较普遍。
基类-&gt;派生类：不安全 主要执行非多态转换，代替C中的转换。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = &amp;d;</span><br><span class="line"><span class="keyword">double</span>* dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dynamic_cast</code> 运行时类型检查，
将基类指针或引用安全转换为派生类的指针或引用：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type是类，且有虚函数</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type*&gt;(e);  <span class="comment">//e是指针</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e);  <span class="comment">//e是左值</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e);  <span class="comment">//e不是左值</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>const_cast</code> 改变底层const。
常量指针转为非常量指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cp;</span><br><span class="line"><span class="keyword">char</span>* q = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// wrong, static_cast不能用于底层const</span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>reinterpret_cast</code>
比较危险，不太用。处理无关类型转换，重新解释对象的比特模型。</li>
</ul>
<h2 id="newdeletemallocfree">new/delete/malloc/free</h2>
<p><code>new/delete</code>是C++运算符，需要编译器支持，所以不需要指定大小，返回相应对象类型的指针，分配失败会抛出<code>std::bad_alloc</code>异常，<code>new</code>会调用<code>operator new()</code>申请内存(用<code>malloc</code>实现)，调用构造函数初始化成员变量，返回相应指针，<code>delete</code>先调用析构函数，再调用<code>operator delete()</code>函数释放内存(用<code>free</code>实现)；<br />
<code>malloc/free</code>是库函数，不由编译器控制，需要显式指出大小，返回<code>void*</code>，需要强制类型转换，分配失败返回<code>NULL</code>指针，无法完成对象的构造和析构。</p>
<p><code>new/delete/malloc/free</code>都是线程安全的，通过锁实现。</p>
<h2 id="智能指针">智能指针</h2>
<p><a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14482830/stdshared-ptr-thread-safety">线程安全问题</a>
https://www.quora.com/Is-the-C-smart-pointer-a-thread-safe-design
<code>new</code>完后没有<code>delete</code>，内存泄漏。为了减少程序员的负担，引入智能指针：</p>
<ul>
<li><code>shared_ptr</code>
允许多个指针指向同一个对象。通常与<code>make_shared</code>函数结合食用：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p = make_shared&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>实现方式一般是reference
counting，在堆上申请资源并返回指针后，在堆上申请一个共享的引用计数器，每来一个指针指向该对象，++计数器。当计数器为0时，会自动释放指向的对象。<br />
2个指针成员，一个指向对象，一个指向计数器<br />
面试有可能被要求手撕一个： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySharePtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mySharePtr</span>() :<span class="built_in">refCnt</span>(<span class="literal">nullptr</span>), <span class="built_in">ptr</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySharePtr</span>(T* res) :<span class="built_in">refCnt</span>(<span class="literal">nullptr</span>), <span class="built_in">ptr</span>(res) &#123;</span><br><span class="line">        <span class="built_in">add</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySharePtr</span>(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; p) :<span class="built_in">refCnt</span>(p.refCnt), <span class="built_in">ptr</span>(p.ptr) &#123;</span><br><span class="line">        <span class="built_in">add</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">mySharePtr</span>() &#123;</span><br><span class="line">        <span class="built_in">remove</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lvalue is assigned, --counter</span></span><br><span class="line">    mySharePtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; that) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;that) &#123;</span><br><span class="line">            <span class="built_in">remove</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;ptr = that.ptr;</span><br><span class="line">            <span class="keyword">this</span>-&gt;refCnt = that.refCnt;</span><br><span class="line">            <span class="built_in">add</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr == other.ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> mySharePtr&lt;T&gt;&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">operator</span>==(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRef</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">            <span class="keyword">return</span> *refCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// if null, create counter = 1, else ++counter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">            ++(*refCnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            refCnt = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --counter, if counter = 0, free memory</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (refCnt) &#123;</span><br><span class="line">            --(*refCnt);</span><br><span class="line">            <span class="keyword">if</span> (*refCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> refCnt;</span><br><span class="line">                <span class="keyword">delete</span> ptr;</span><br><span class="line">                refCnt = <span class="literal">nullptr</span>;</span><br><span class="line">                ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* refCnt;</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>unique_ptr</code> 看名字就知道，独占对象。</p></li>
<li><p><code>weak_ptr</code> <a
target="_blank" rel="noopener" href="https://www.cnblogs.com/yocichen/p/10563124.html">std::weak_ptr</a></p></li>
</ul>
<h2 id="成员变量初始化顺序">成员变量初始化顺序</h2>
<p>初始化成员列表好处： 1. const成员变量只能初始化不能赋值 2.
引用只能在定义时初始化，不能重新赋值 3.
高效：初始化列表比赋值操作少一次默认构造函数，因为程序要默认构造临时对象（等号右边）后才能赋值</p>
<h2 id="指针函数和函数指针">指针函数和函数指针</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针函数: 返回类型是指针的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* s = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(a + b);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> (*func)(<span class="keyword">int</span>, <span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*func)(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*minus)(<span class="keyword">int</span>, <span class="keyword">int</span>) = sub;  <span class="comment">// minus是函数指针</span></span><br><span class="line"><span class="keyword">int</span>* m = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">operation</span>(<span class="number">3</span>, *m, minus);</span><br></pre></td></tr></table></figure>
<p><code>class</code>的成员变量和成员函数默认都是<code>private</code>，<code>struct</code>的成员变量和成员函数默认都是<code>public</code>。<code>class</code>的继承默认是私有继承，<code>struct</code>的继承默认是公有继承，公有还是私有取决于子类而非父类。<code>class</code>可以用作模板，<code>struct</code>不可以。</p>
<p>基类静态变量/全局变量：静态成员变量必须类外初始化
派生类静态变量/全局变量
基类成员变量：按照在类中定义的顺序，而不是初始化列表中的顺序
派生类成员变量</p>
<p>范围for循环 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>&amp; i : nums)  <span class="comment">// allow modification in nums</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : nums)  <span class="comment">// access by value</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">CoordinateArea</span> &#123;</span> ONE, TWO &#125;;</span><br><span class="line">CoordinateArea a = CoordinateArea::ONE;</span><br></pre></td></tr></table></figure>
<h2 id="volatile">volatile</h2>
<p>编译器对加<code>volatile</code>关键字的变量的代码不进行编译器优化，保证对特殊地址的稳定访问。不能把他放在cache或寄存器中重复使用，防止优化编译器把变量从内存装入CPU寄存器。两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。总是重新从内存读取数据，即使前面的指令刚刚从该内存地址读取过。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a = i;</span><br><span class="line"><span class="keyword">int</span> b = i;</span><br></pre></td></tr></table></figure> 多任务间每个任务共享的标志应该<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/62060524">加volatile</a>。</p>
<h2 id="stl">STL</h2>
<p><a
target="_blank" rel="noopener" href="https://www.jianshu.com/p/78c700c8d72d">C++11新特性</a>：自动类型推导、范围for、Lambda表达式、智能指针、
### <a
target="_blank" rel="noopener" href="https://www.cnblogs.com/linuxAndMcu/p/14621819.html">迭代器失效</a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> () &#123;</span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 优先队列 <a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/344121142">优先队列的三种方式</a><br />
<a
target="_blank" rel="noopener" href="https://www.cnblogs.com/shona/p/12163381.html">自定义排序</a></p>
<h3 id="vector">vector</h3>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/377186496">vector的push_back过程</a><br />
<code>clear</code>将size置0，不会改变capacity，不会释放内存，可以用<code>vector&lt;int&gt;().swap(vec)</code>来释放内存。并发读是线程安全的，STL的所有容器并发写都<a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11144294/are-stdvectors-threadsafe">不是线程安全的</a>。扩容时也是线程不安全的。vector扩容时，内存位置发生改变导致Segmentation
fault错误。因为vector在扩容时会将内容全部拷贝到新的内存区域中，原有的内存区域被释放，此时如果有线程依然在向旧的内存区域读或写就会出问题。
https://segmentfault.com/a/1190000041334904</p>
<h3 id="map">map</h3>
<p><a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/48066839">map与unordered_map</a></p>
<h2 id="全局变量">全局变量</h2>
<p>Global variables in a single translation unit (source file) are
initialized in the order in which they are defined. The order of
initialization of global variables in different translation units is
unspecified.<br />
<a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3746238/c-global-initialization-order-ignores-dependencies">ref1</a><br />
<a
target="_blank" rel="noopener" href="https://gamedev.stackexchange.com/questions/91958/why-it-s-recommended-to-keep-global-variable-initialization-and-the-objects-con">ref2</a></p>
<p>函数缺省： 某个参数有默认值，缺省参数仍在后边
调用时如果略去一个参数传递，则略去后面所有</p>
<p>异常处理：
抛出异常，没有被特定的catch语句捕获，函数调用堆栈会被解退（函数终止，销毁局部变量，控制权转到调用它的那个函数），
并在下一个外层try..catch捕获，最后没有任何catch捕获，调用terminate，abort退出。</p>
<p>模板特化、偏特化 内存池</p>
<p>数据库缓存一致：
并发操作导致不一致，本质上修改数据库和删除缓存耦合在一起，使得其他操作有可能读出脏数据
解决方案：解耦，延迟双删：写-&gt;删缓存-&gt;修改数据库-&gt;延时-&gt;再次删缓存
二：内存队列：写修改数据库，将数据id放入队列，消费者线程消费即可</p>
<p>浏览器：
DNS解析（DNS缓存、OS缓存、路由器缓存、递归搜索）、尝试建立TCP连接、发送HTTP请求(get)、服务器处理请求（查询）
返回HTML，浏览器解析渲染、关闭TCP连接</p>
<p>预处理、编译、汇编、链接</p>
<p>操作系统 * 用户告诉操作系统执行hello程序 * 操作系统到硬盘找到该程序 *
由编译程序将用户源程序编译成若干个目标模块 *
由链接程序将目标模块和相应的库函数链接成装入模块 *
操作系统分配内存，由装入程序将装入模块装入内存 *
为执行hello程序创建执行环境（创建新进程） *
操作系统设置CPU上下文环境，并跳到程序开始处 * 程序的第一条指令执行 *
程序执行与printf对应的系统调用 * 操作系统分配设备 * 执行显示驱动程序 *
窗口系统将像素写入存储映像区</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="EIMadrigal WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="EIMadrigal Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>EIMadrigal
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://eimadrigal.github.io/2019/03/04/C%20&%20C++%20FAQ/" title="C&#x2F;C++ FAQ">https://eimadrigal.github.io/2019/03/04/C & C++ FAQ/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Language/" rel="tag"><i class="fa fa-tag"></i> Language</a>
              <a href="/tags/Interview/" rel="tag"><i class="fa fa-tag"></i> Interview</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/04/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="prev" title="C++多线程编程">
      <i class="fa fa-chevron-left"></i> C++多线程编程
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/03/06/INTERVIEW%201/" rel="next" title="INTERVIEW 1">
      INTERVIEW 1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">指针和引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">空类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81polymorphism"><span class="nav-number">3.</span> <span class="nav-text">多态Polymorphism</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">构造函数和析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8-%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">3.2.</span> <span class="nav-text">虚函数表 &amp; 虚函数指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">纯虚函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-%E8%A6%86%E7%9B%96-%E9%87%8D%E5%86%99"><span class="nav-number">4.</span> <span class="nav-text">重载 &amp; 覆盖 &amp; 重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">5.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const"><span class="nav-number">6.</span> <span class="nav-text">const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inline"><span class="nav-number">7.</span> <span class="nav-text">inline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">8.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#newdeletemallocfree"><span class="nav-number">9.</span> <span class="nav-text">new&#x2F;delete&#x2F;malloc&#x2F;free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">10.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">11.</span> <span class="nav-text">成员变量初始化顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">12.</span> <span class="nav-text">指针函数和函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">13.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stl"><span class="nav-number">14.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">14.1.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">14.2.</span> <span class="nav-text">map</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">15.</span> <span class="nav-text">全局变量</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EIMadrigal"
      src="/images/favicon.png">
  <p class="site-author-name" itemprop="name">EIMadrigal</p>
  <div class="site-description" itemprop="description">Hello World</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">179</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/EIMadrigal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:andrew.renj@gmail.com" title="E-Mail → mailto:andrew.renj@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/EIMadrigal" title="cnblogs → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-codiepie fa-fw"></i>cnblogs</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/EIMadrigal" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EIMadrigal</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">Total views: <span id="busuanzi_value_site_pv"></span></span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">Total visitors: <span id="busuanzi_value_site_uv"></span></span>
    <span class="post-meta-divider">|</span>

<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);
    var countOffset = 20000;

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset);
            clearInterval(int);
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '285afe6e2d34f997b740',
      clientSecret: 'f3e77970aacbc5a14421e48db34996ed8223f7e9',
      repo        : 'EIMadrigal.github.io',
      owner       : 'EIMadrigal',
      admin       : ['EIMadrigal'],
      id          : 'bd98bf4bb8be97e29fc3d25e99076e5c',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eimadrigal.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Hello World">
<meta property="og:type" content="website">
<meta property="og:title" content="EI Madrigal&#39;s Space">
<meta property="og:url" content="https://eimadrigal.github.io/index.html">
<meta property="og:site_name" content="EI Madrigal&#39;s Space">
<meta property="og:description" content="Hello World">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="EIMadrigal">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://eimadrigal.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>EI Madrigal's Space</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EI Madrigal's Space</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2022/01/13/CS231n%20Assignment%20#2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/13/CS231n%20Assignment%20#2/" class="post-title-link" itemprop="url">CS231n Assignment</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-13 15:34:00" itemprop="dateCreated datePublished" datetime="2022-01-13T15:34:00+08:00">2022-01-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="fully-connected-neural-network">Fully-connected Neural Network</h2>
<p>我好菜啊！！很早就写完代码了，gradient check也过了，但是需要过拟合50张图片的时候一直不太对，调了几下学习率，我看train acc只有0.14左右，loss曲线波动也很大： <img src="https://img2020.cnblogs.com/blog/1260581/202109/1260581-20210912161403754-1113281186.png" alt="image" /> 因为最后要100%的train acc嘛，我看差的挺远的，就开始怀疑是网络哪里写错了，就没管超参数，检查代码检查了好几天tmd，深度学习debug还真是无从下手...后来跑去看了下别人的东西，发现原因竟然是不会调参(T^T)。</p>
<p>仔细看下，这里还是很明显的，20个epoch训练损失才下降了一点点，说明学习率太小了。 <img src="https://img2020.cnblogs.com/blog/1260581/202109/1260581-20210912162656860-43278840.png" alt="image" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2022/01/01/%E6%88%91%E7%9A%842021/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/01/%E6%88%91%E7%9A%842021/" class="post-title-link" itemprop="url">我的2021</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-01 15:21:00" itemprop="dateCreated datePublished" datetime="2022-01-01T15:21:00+08:00">2022-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Life/" itemprop="url" rel="index"><span itemprop="name">Life</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/01/01/%E6%88%91%E7%9A%842021/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2021/12/28/%E9%9D%A2%E7%AD%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/28/%E9%9D%A2%E7%AD%8B/" class="post-title-link" itemprop="url">面筋</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-28 09:04:00" itemprop="dateCreated datePublished" datetime="2021-12-28T09:04:00+08:00">2021-12-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语言基础-cc">1. 语言基础 (C/C++)</h1>
<h4 id="堆和栈有什么区别">（2） 堆和栈有什么区别</h4>
<ul>
<li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li>
<li>堆空间因为会有频繁的分配释放操作，会产生内存碎片</li>
<li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小 #### （3）堆快一点还是栈快一点？（字节提前批一面） 栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。 #### （4） new和delete是如何实现的，new 与 malloc的异同处 在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</li>
</ul>
<p>new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名 #### （5）既然有了malloc/free，C++中为什么还需要new/delete呢？ https://blog.csdn.net/leikun153/article/details/80612130</p>
<ul>
<li><p>malloc/free和new/delete都是用来申请内存和回收内存的。</p></li>
<li><p>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。 #### （6） C和C++的区别 包括但不限于：</p></li>
<li><p>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。</p></li>
<li><p>C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete</p></li>
<li><p>C++中还有函数重载和引用等概念，C中没有 #### （7）delete和delete[]的区别</p></li>
<li><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p></li>
<li><p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p></li>
</ul>
<h4 id="cjava的联系与区别包括语言特性垃圾回收应用场景等java的垃圾回收机制">（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h4>
<p>包括但不限于： * C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。 * C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法 * C++有指针，Java没有指针，只有引用 * JAVA和C++都有构造函数，但是C++有析构函数但是Java没有 #### （9）C++和python的区别 包括但不限于： 1. python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。 2. python使用缩进来区分不同的代码块，C++使用花括号来区分 3. C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等 4. python的库函数比C++的多，调用起来很方便 #### （10） Struct和class的区别 * 使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的 * struct的继承默认是public继承，而class的继承默认是private继承 * class可以用作模板，而struct不能 #### （11） define 和const的联系与区别（编译阶段、安全性、内存占用等） 联系：它们都是定义常量的一种方法。</p>
<p>区别： * define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。 * define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。 * define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。 * const可以定义函数而define不可以。 #### （12） 在C++中const的用法（定义，用途） * const修饰类的成员变量时，表示常量不能被修改 * const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</p>
<h4 id="c中的static用法和意义">（13） C++中的static用法和意义</h4>
<p>static的意思是静态的，可以用来修饰变量，函数和类成员。 * 变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。</p>
<ul>
<li><p>函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。</p></li>
<li><p>类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。</p></li>
</ul>
<p>【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。</p>
<p>注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。 #### （14） 计算下面几个类的大小： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl; <span class="number">0</span>;=<span class="string">&quot;&quot;</span> <span class="number">1</span>;=<span class="string">&quot;&quot;</span> <span class="number">4</span>(<span class="number">32</span>位机器)=<span class="string">&quot;&quot;</span> <span class="number">8</span>(<span class="number">64</span>位机器);=<span class="string">&quot;&quot;</span> __vptr，其大小是<span class="number">4</span>字节&lt;br=<span class="string">&quot;&quot;</span> ```=<span class="string">&quot;&quot;</span> ```c++=<span class="string">&quot;&quot;</span> a=<span class="string">&quot;&quot;</span> a;=<span class="string">&quot;&quot;</span> class=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;=<span class="string">&quot;&quot;</span> <span class="built_in">fun</span>()&#123;&#125;=<span class="string">&quot;&quot;</span> <span class="keyword">int</span>=<span class="string">&quot;&quot;</span> <span class="built_in">main</span>()&#123;=<span class="string">&quot;&quot;</span> <span class="keyword">return</span>=<span class="string">&quot;&quot;</span> <span class="keyword">virtual</span>=<span class="string">&quot;&quot;</span> &#123;=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span> &#125;;=<span class="string">&quot;&quot;</span> 因为有虚函数的类对象中都有一个虚函数表指针=<span class="string">&quot;&quot;</span> 在c\+\+中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为<span class="number">0</span>了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。=<span class="string">&quot;&quot;</span> 空类的大小是<span class="number">1</span>，=<span class="string">&quot;&quot;</span> 空类的实例大小就是类的大小，所以<span class="built_in"><span class="keyword">sizeof</span></span>(a)=<span class="string">&quot;1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。&quot;</span> 输出=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">```C++</span><br><span class="line">class A &#123; <span class="keyword">static</span> <span class="keyword">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl; ####=<span class="string">&quot;&quot;</span> *=<span class="string">&quot;&quot;</span> ++内存管理（热门问题）=<span class="string">&quot;&quot;</span> <span class="number">0</span>;=<span class="string">&quot;&quot;</span> <span class="number">1.</span>=<span class="string">&quot;&quot;</span> <span class="number">1</span>;=<span class="string">&quot;&quot;</span> <span class="number">1</span>）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，**由于对象还未创建成功，编译器无法知道对象的实际类型**，是类本身还是类的派生类等等=<span class="string">&quot;&quot;</span> <span class="number">2.</span>=<span class="string">&quot;&quot;</span> <span class="number">2</span>）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了=<span class="string">&quot;&quot;</span> <span class="number">3.</span>=<span class="string">&quot;&quot;</span> <span class="number">3657717.</span>html)=<span class="string">&quot;&quot;</span> <span class="number">4.</span>=<span class="string">&quot;&quot;</span> <span class="number">4</span>;=<span class="string">&quot;&quot;</span> <span class="number">5.</span>=<span class="string">&quot;&quot;</span> <span class="number">50688337</span>)=<span class="string">&quot;&quot;</span> <span class="number">51088091</span>)=<span class="string">&quot;&quot;</span> <span class="number">81870219</span>=<span class="string">&quot;&quot;</span> <span class="number">98889139</span>=<span class="string">&quot;&quot;</span> <span class="number">99497160</span>=<span class="string">&quot;&quot;</span> [c++中的静态绑定和动态绑定](https:=<span class="string">&quot;&quot;</span> ```=<span class="string">&quot;&quot;</span> ```c++=<span class="string">&quot;&quot;</span> a=<span class="string">&quot;&quot;</span> a;=<span class="string">&quot;&quot;</span> article=<span class="string">&quot;&quot;</span> b;=<span class="string">&quot;&quot;</span> blog.csdn.net=<span class="string">&quot;&quot;</span> c=<span class="string">&quot;&quot;</span> c++=<span class="string">&quot;&quot;</span> c++中的重载和重写的区别：=<span class="string">&quot;&quot;</span> c++的stl介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等=<span class="string">&quot;&quot;</span> c++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。=<span class="string">&quot;&quot;</span> c++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）=<span class="string">&quot;&quot;</span> class=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl;=<span class="string">&quot;&quot;</span> details=<span class="string">&quot;&quot;</span> https:=<span class="string">&quot;&quot;</span> ifumi=<span class="string">&quot;&quot;</span> <span class="keyword">int</span>=<span class="string">&quot;&quot;</span> lihao21=<span class="string">&quot;&quot;</span> list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为<span class="built_in">o</span>(n);=<span class="string">&quot;&quot;</span> list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=<span class="string">&quot;”、“&lt;”等&quot;</span> lizhenghn=<span class="string">&quot;&quot;</span> <span class="built_in">main</span>()&#123;=<span class="string">&quot;&quot;</span> map底层是采用红黑树实现的，插入删除查询时间复杂度都是<span class="built_in">o</span>(<span class="built_in">log</span>(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。=<span class="string">&quot;&quot;</span> p=<span class="string">&quot;&quot;</span> qq_36359022=<span class="string">&quot;&quot;</span> qq_43152052=<span class="string">&quot;&quot;</span> <span class="keyword">return</span>=<span class="string">&quot;&quot;</span> <span class="keyword">static</span>=<span class="string">&quot;&quot;</span> stl中unordered_map和map的区别=<span class="string">&quot;&quot;</span> stl中vector的实现=<span class="string">&quot;&quot;</span> stl中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。=<span class="string">&quot;&quot;</span> stl中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。=<span class="string">&quot;&quot;</span> stl从广义来讲包括了三类：算法，容器和迭代器。=<span class="string">&quot;&quot;</span> stl源码中的hash表的实现=<span class="string">&quot;&quot;</span> unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现=<span class="string">&quot;操作符。&quot;</span> unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过<span class="number">8</span>时，就自动转为红黑树进行组织。=<span class="string">&quot;&quot;</span> vector::iterator和list::iterator都重载了“\+\+”运算符。=<span class="string">&quot;&quot;</span> vector使用的注意点及其原因，频繁对vector调用push_back\(\)对性能的影响和原因。=<span class="string">&quot;&quot;</span> vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以<span class="number">2</span>倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为<span class="built_in">o</span>(n)。=<span class="string">&quot;&quot;</span> vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=<span class="string">&quot;”，“&lt;”等操作符。&quot;</span> weixin_30379911=<span class="string">&quot;&quot;</span> www.cnblogs.com=<span class="string">&quot;&quot;</span> &#123;=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span> &#125;;=<span class="string">&quot;&quot;</span> &#125;;;=<span class="string">&quot;&quot;</span> 为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。=<span class="string">&quot;&quot;</span> 二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找<span class="number">1</span>^<span class="number">2</span>,<span class="number">2</span>^<span class="number">2</span>,<span class="number">3</span>^<span class="number">2</span>,<span class="number">4</span>^<span class="number">2.</span>....i^<span class="number">2</span>个位置。=<span class="string">&quot;&quot;</span> 介绍面向对象的三大特性，并且举例说明每一个。=<span class="string">&quot;&quot;</span> 代码区，存放程序的二进制代码=<span class="string">&quot;&quot;</span> 但由于链表的特点，能高效地进行插入和删除。=<span class="string">&quot;&quot;</span> 使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。=<span class="string">&quot;&quot;</span> 全局=<span class="string">&quot;&quot;</span> 关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。=<span class="string">&quot;&quot;</span> 动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。=<span class="string">&quot;&quot;</span> 包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象=<span class="string">&quot;&quot;</span> 即<span class="number">4</span>个字节=<span class="string">&quot;&quot;</span> 双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。=<span class="string">&quot;&quot;</span> 在c\+\+中，内存分成<span class="number">5</span>个区，他们分别是堆、栈、全局=<span class="string">&quot;&quot;</span> 在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。=<span class="string">&quot;&quot;</span> 在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。=<span class="string">&quot;&quot;</span> 在析构函数中调用虚函数，此时调用的是子类的函数实现方式。=<span class="string">&quot;&quot;</span> 基类的析构函数一般写成虚函数的原因=<span class="string">&quot;&quot;</span> 堆，就是那些由<span class="keyword">new</span>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<span class="keyword">new</span>就要对应一个<span class="keyword">delete</span>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。=<span class="string">&quot;&quot;</span> 多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。=<span class="string">&quot;&quot;</span> 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。=<span class="string">&quot;&quot;</span> 多态的实现（和下个问题一起回答）=<span class="string">&quot;&quot;</span> 多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：https:=<span class="string">&quot;&quot;</span> 大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用<span class="built_in">push_back</span>()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。=<span class="string">&quot;&quot;</span> 如果多重继承和多继承的话，子类的虚函数表长什么样子？=<span class="string">&quot;&quot;</span> 如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。=<span class="string">&quot;&quot;</span> 如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。=<span class="string">&quot;&quot;</span> 如果需要大量的插入和删除，而不关心随机存取，则应使用list。=<span class="string">&quot;&quot;</span> 如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块=<span class="string">&quot;&quot;</span> 实现编译器处理虚函数表应该如何处理=<span class="string">&quot;&quot;</span> 容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。=<span class="string">&quot;&quot;</span> 对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。=<span class="string">&quot;&quot;</span> 对象复用的了解，零拷贝的了解=<span class="string">&quot;&quot;</span> 封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的<span class="keyword">private</span>和<span class="keyword">public</span>；=<span class="string">&quot;&quot;</span> 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。=<span class="string">&quot;&quot;</span> 建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。=<span class="string">&quot;&quot;</span> 开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，stl的hashtable就是采用这种实现方式。=<span class="string">&quot;&quot;</span> 总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;=<span class="string">&quot;&quot;</span> 普通函数也不占用类大小=<span class="string">&quot;&quot;</span> 构造函数为什么一般不定义为虚函数=<span class="string">&quot;&quot;</span> 构造函数或者析构函数中调用虚函数会怎样=<span class="string">&quot;&quot;</span> 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。=<span class="string">&quot;&quot;</span> 浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。=<span class="string">&quot;&quot;</span> 深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。=<span class="string">&quot;&quot;</span> 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）=<span class="string">&quot;&quot;</span> 算法包括排序，复制等常用算法，以及不同容器特定的算法。=<span class="string">&quot;&quot;</span> 纯虚函数=<span class="string">&quot;&quot;</span> 纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承=<span class="string">&quot;&quot;</span> 线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。=<span class="string">&quot;&quot;</span> 继承使得子类可以复用父类的成员和方法，实现了代码重用；=<span class="string">&quot;&quot;</span> 编译器处理虚函数的方法是：=<span class="string">&quot;&quot;</span> 而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。=<span class="string">&quot;&quot;</span> 虚函数：在基类的函数前加上<span class="keyword">virtual</span>关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.=<span class="string">&quot;&quot;</span> 详见：[c++虚函数表剖析](https:=<span class="string">&quot;&quot;</span> 详见：[虚函数的作用及其底层实现机制](https:=<span class="string">&quot;&quot;</span> 详见：https:=<span class="string">&quot;&quot;</span> 输出=<span class="string">&quot;&quot;</span> 迭代器就是在不暴露容器内部结构的情况下对容器的遍历。=<span class="string">&quot;&quot;</span> 重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。=<span class="string">&quot;&quot;</span> 重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。=<span class="string">&quot;&quot;</span> 零拷贝指的是在进行操作时，避免cpu从一处存储拷贝到另一处存储。在linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用<span class="built_in">mmap</span>()来代替read调用。=<span class="string">&quot;&quot;</span> 静态存储区和常量存储区和代码区。=<span class="string">&quot;&quot;</span> 静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部<span class="keyword">static</span>变量，全局<span class="keyword">static</span>变量）、全局变量和常量。=<span class="string">&quot;&quot;</span> 静态成员a不占用类的大小，所以类的大小就是b变量的大小=<span class="string">&quot;&quot;</span> 静态成员存放在静态存储区，不占用类的大小,=<span class="string">&quot;&quot;</span> 静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。=<span class="string">&quot;&quot;</span> 静态绑定和动态绑定的介绍=<span class="string">&quot;&quot;</span> 面向对象的三大特性是：封装，继承和多态。=<span class="string">&quot;&quot;</span> 首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。=<span class="string">&quot;&quot;</span> （<span class="number">15</span>）=<span class="string">&quot;&quot;</span> （<span class="number">16</span>）=<span class="string">&quot;&quot;</span> （<span class="number">17</span>）解决哈希冲突的方式？=<span class="string">&quot;&quot;</span> （<span class="number">18</span>）=<span class="string">&quot;&quot;</span> （<span class="number">19</span>）=<span class="string">&quot;&quot;</span> （<span class="number">20</span>）=<span class="string">&quot;&quot;</span> （<span class="number">21</span>）c++中vector和list的区别=<span class="string">&quot;&quot;</span> （<span class="number">22</span>）=<span class="string">&quot;&quot;</span> （<span class="number">23</span>）=<span class="string">&quot;&quot;</span> （<span class="number">24</span>）=<span class="string">&quot;&quot;</span> （<span class="number">25</span>）=<span class="string">&quot;&quot;</span> （<span class="number">26</span>）=<span class="string">&quot;&quot;</span> （<span class="number">27</span>）=<span class="string">&quot;&quot;</span> （<span class="number">28</span>）=<span class="string">&quot;&quot;</span> （<span class="number">29</span>）=<span class="string">&quot;&quot;</span> （<span class="number">30</span>）=<span class="string">&quot;&quot;</span> （<span class="number">31</span>）=<span class="string">&quot;&quot;</span> （<span class="number">32</span>）=<span class="string">&quot;&quot;</span> （<span class="number">33</span>）=<span class="string">&quot;&quot;</span> （<span class="number">34</span>）=<span class="string">&quot;&quot;</span>&gt;用程序调用<span class="built_in">mmap</span>()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用<span class="built_in">write</span>(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</span><br><span class="line"></span><br><span class="line">#### （<span class="number">35</span>） 介绍C++所有的构造函数</span><br><span class="line">C\+\+中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数</span><br><span class="line">* 默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</span><br><span class="line">* 重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</span><br><span class="line">* 拷贝构造函数是在发生对象复制的时候调用的。 </span><br><span class="line">#### （<span class="number">36</span>） 什么情况下会调用拷贝构造函数（三种情况）</span><br><span class="line">* 对象以值传递的方式传入函数参数 </span><br><span class="line"></span><br><span class="line">  &gt;如 ` <span class="keyword">void</span> <span class="built_in">func</span>(Dog dog)&#123;&#125;;`</span><br><span class="line">* 对象以值传递的方式从函数返回</span><br><span class="line"></span><br><span class="line">  &gt;如 ` Dog <span class="built_in">func</span>()&#123; Dog d; <span class="keyword">return</span> d;&#125;`</span><br><span class="line">* 对象需要通过另外一个对象进行初始化</span><br><span class="line"></span><br><span class="line">详见：[C++拷贝构造函数详解](https:<span class="comment">//blog.csdn.net/lwbeyond/article/details/6202256)</span></span><br><span class="line">#### （<span class="number">37</span>） 结构体内存对齐方式和为什么要进行内存对齐？</span><br><span class="line">因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</span><br><span class="line"></span><br><span class="line">对齐规则：</span><br><span class="line">* 第一个成员在与结构体变量偏移量为<span class="number">0</span>的地址</span><br><span class="line">* 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</span><br><span class="line">* 对齐数=编译器默认的一个对齐数 与 该成员大小的较小值。</span><br><span class="line">* linux 中默认为<span class="number">4</span></span><br><span class="line">* vs 中的默认值为<span class="number">8</span></span><br><span class="line">结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）</span><br><span class="line"></span><br><span class="line">#### （<span class="number">38</span>） 内存泄露的定义，如何检测与避免？</span><br><span class="line">动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</span><br><span class="line"></span><br><span class="line">造成内存泄漏的几种原因：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）类的构造函数和析构函数中<span class="keyword">new</span>和<span class="keyword">delete</span>没有配套</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）在释放对象数组时没有使用<span class="keyword">delete</span>\[\]，使用了<span class="keyword">delete</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是<span class="keyword">virtual</span>，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）没有正确的清楚嵌套的对象指针</span><br><span class="line"></span><br><span class="line">避免方法：</span><br><span class="line"><span class="number">1.</span> malloc/free要配套</span><br><span class="line"><span class="number">2.</span> 使用智能指针；</span><br><span class="line"><span class="number">3.</span> 将基类的析构函数设为虚函数；</span><br><span class="line">#### （<span class="number">39</span>） C++的智能指针有哪些</span><br><span class="line">C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。</span><br><span class="line">* auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。</span><br><span class="line">* unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针。</span><br><span class="line">* shared_ptr可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</span><br><span class="line">* weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。</span><br><span class="line">#### （<span class="number">40</span>） 调试程序的方法</span><br><span class="line">* 通过设置断点进行调试</span><br><span class="line">* 打印log进行调试</span><br><span class="line">* 打印中间结果进行调试</span><br><span class="line">#### （<span class="number">41</span>） 遇到coredump要怎么调试</span><br><span class="line">coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</span><br><span class="line"></span><br><span class="line">* 使用gdb命令对core文件进行调试</span><br><span class="line"></span><br><span class="line">以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</span><br></pre></td></tr></table></figure> mkdir coredumpTest vim coredumpTest.cpp <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在编辑器内键入</span><br></pre></td></tr></table></figure> #include&lt;stdio.h&gt; int main(){ int i; scanf("%d",i);//正确的应该是&amp;i,这里使用i会导致segment fault printf("%d",i); return 0; } <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译</span><br></pre></td></tr></table></figure> g++ coredumpTest.cpp -g -o coredumpTest <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行</span><br></pre></td></tr></table></figure> ./coredumpTest <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用gdb调试coredump</span><br></pre></td></tr></table></figure> gdb [可执行文件名] [core文件名] <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### （42） inline关键字说一下 和宏定义有什么区别</span><br><span class="line">inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</span><br><span class="line"></span><br><span class="line">1、内联函数在编译时展开，而宏在预编译时展开</span><br><span class="line"></span><br><span class="line">2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</span><br><span class="line"></span><br><span class="line">3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</span><br><span class="line"></span><br><span class="line">4、宏不是函数，而inline是函数</span><br><span class="line"></span><br><span class="line">5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</span><br><span class="line"></span><br><span class="line">6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</span><br><span class="line"></span><br><span class="line">7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</span><br><span class="line">#### （43） 模板的用法与适用场景 实现原理</span><br><span class="line">用template \&lt;typename t\=&quot;&quot;&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了</span><br><span class="line"></span><br><span class="line">编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。</span><br><span class="line">#### （44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</span><br><span class="line">成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：</span><br></pre></td></tr></table></figure> class A{ int id; string name; FaceImage face; A(int&amp; inputID,string&amp; inputName,FaceImage&amp; inputFace):id(inputID),name(inputName),face(inputFace){} // 成员初始化列表 }; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。  </span><br><span class="line"></span><br><span class="line">另外，有三种情况是必须使用成员初始化列表进行初始化的：</span><br><span class="line">* 常量成员的初始化，因为常量成员只能初始化不能赋值</span><br><span class="line">* 引用类型</span><br><span class="line">* 没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化</span><br><span class="line"></span><br><span class="line">详见[C++ 初始化列表](https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html)</span><br><span class="line">#### （45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</span><br><span class="line">* 自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</span><br><span class="line">* nullptr</span><br><span class="line">：nullptr是为了解决原来C\+\+中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的</span><br><span class="line"></span><br><span class="line">* lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：</span><br><span class="line">`[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125;`</span><br><span class="line">* thread类和mutex类</span><br><span class="line">* 新的智能指针 unique_ptr和shared_ptr</span><br><span class="line"></span><br><span class="line">* 更多详见：https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</span><br><span class="line">#### （46） C++的调用惯例（简单一点C++函数调用的压栈过程）</span><br><span class="line">函数的调用过程：</span><br><span class="line"></span><br><span class="line">1）从栈空间分配存储空间</span><br><span class="line"></span><br><span class="line">2）从实参的存储空间复制值到形参栈空间</span><br><span class="line"></span><br><span class="line">3）进行运算</span><br><span class="line"></span><br><span class="line">形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</span><br><span class="line"></span><br><span class="line">数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</span><br><span class="line"></span><br><span class="line">当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。</span><br><span class="line">#### （47） C++的四种强制转换</span><br><span class="line">四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</span><br><span class="line"></span><br><span class="line">* 1）static_cast ：</span><br><span class="line">  用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。</span><br><span class="line">  &gt;特性与要点：</span><br><span class="line">    1. 它没有运行时类型检查，所以是有安全隐患的。</span><br><span class="line">    2. 在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</span><br><span class="line">    3. static_cast不能转换const，volatile等属性</span><br><span class="line">* 2）dynamic_cast：</span><br><span class="line">用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。</span><br><span class="line">dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。</span><br><span class="line">dynamic_cast如果不能转换返回NULL。</span><br><span class="line">* 3）const_cast：</span><br><span class="line">用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</span><br><span class="line">* 4）reinterpret_cast</span><br><span class="line">几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。</span><br><span class="line">#### （48）string的底层实现</span><br><span class="line">string继承自basic_string,其实是对char\*进行了封装，封装的string包含了char\*数组，容量，长度等等属性。</span><br><span class="line"></span><br><span class="line">string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</span><br><span class="line">#### （49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</span><br><span class="line">预处理，编译，汇编，链接</span><br><span class="line"></span><br><span class="line">* 预处理： 对预处理命令进行替换等预处理操作</span><br><span class="line">* 编译：代码优化和生成汇编代码</span><br><span class="line">* 汇编：将汇编代码转化为机器语言</span><br><span class="line">* 链接：将目标文件彼此链接起来</span><br><span class="line">#### （50）set，map和vector的插入复杂度</span><br><span class="line">set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。</span><br><span class="line"></span><br><span class="line">unordered_set,unordered_map的插入复杂度是常数，最坏是O(N).</span><br><span class="line"></span><br><span class="line">vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</span><br><span class="line">#### （51）定义和声明的区别</span><br><span class="line">* 声明是告诉编译器变量的类型和名字，不会为变量分配空间</span><br><span class="line"></span><br><span class="line">* 定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次</span><br><span class="line">#### （52）typdef和define区别</span><br><span class="line"></span><br><span class="line">#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</span><br><span class="line"></span><br><span class="line">typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</span><br><span class="line"></span><br><span class="line">#### （53）被free回收的内存是立即返还给操作系统吗？为什么</span><br><span class="line">https://blog.csdn.net/YMY_mine/article/details/81180168</span><br><span class="line"></span><br><span class="line">不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</span><br><span class="line"></span><br><span class="line">#### （54）引用作为函数参数以及返回值的好处</span><br><span class="line"></span><br><span class="line">对比值传递，引用传参的好处：</span><br><span class="line"></span><br><span class="line">1）在函数内部可以对此参数进行修改</span><br><span class="line"></span><br><span class="line">2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</span><br><span class="line"></span><br><span class="line">如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</span><br><span class="line"></span><br><span class="line">用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</span><br><span class="line"></span><br><span class="line">但是有以下的限制：</span><br><span class="line"></span><br><span class="line">1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</span><br><span class="line"></span><br><span class="line">2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</span><br><span class="line"></span><br><span class="line">3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 </span><br><span class="line">#### （55）友元函数和友元类</span><br><span class="line">https://www.cnblogs.com/zhuguanhao/p/6286145.html</span><br><span class="line"></span><br><span class="line">友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</span><br><span class="line"></span><br><span class="line">1）友元函数</span><br><span class="line"></span><br><span class="line">有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure> #include <iostream></p>
<p>using namespace std;</p>
<p>class A { public: friend void set_show(int x, A &amp;a); //该函数是友元函数的声明 private: int data; };</p>
<p>void set_show(int x, A &amp;a) //友元函数定义，为了访问类A中的成员 { a.data = x; cout &lt;&lt; a.data &lt;&lt; endl; } int main(void) { class A a;</p>
<pre><code>set_show(1, a);

return 0;</code></pre>
<p>} <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</span><br><span class="line"></span><br><span class="line">2）友元类</span><br><span class="line"></span><br><span class="line">友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。        </span><br><span class="line">但是另一个类里面也要相应的进行声明</span><br><span class="line"></span><br></pre></td></tr></table></figure> #include <iostream></p>
<p>using namespace std;</p>
<p>class A { public: friend class C; //这是友元类的声明 private: int data; };</p>
<p>class C //友元类定义，为了访问类A中的成员 { public: void set_show(int x, A &amp;a) { a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;} <img src="https:=%22%22%20socket()=%22%22%20stl中的sort()算法是用什么实现的，stable_sort()呢=%22%22%20stl中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。=%22%22%20tcp和udp的区别=%22%22%20tcp和udp相关的协议与端口号=%22%22%20tcp对系统资源的要求高于udp，所以速度也比udp慢。=%22%22%20tcp怎么保证可靠性？=%22%22%20tcp拥塞控制，算法名字？（极其重要）=%22%22%20tcp提供流量控制和拥塞控制，而udp没有。=%22%22%20tcp握手以及每一次握手客户端和服务器端处于哪个状态=%22%22%20tcp数据包是没有边界的，会出现粘包的问题，udp包是独立的，不会出现粘包问题。=%22%22%20tcp断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动=%22%22%20tcp族的协议有http，https，smtp，telnet，ftp等，udp族的协议有dns，dhcp等等。=%22%22%20tcp是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ack对收发的数据进行正确性检验。而udp是无连接的协议，不管对方有没有收到或者收到的数据是否正确。=%22%22%20tcp滑动窗口协议=%22%22%20tcp的三次握手与四次挥手的详细介绍（tcp连接建立与断开是热门问题）=%22%22%20tcp的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等=%22%22%20tcp的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。=%22%22%20tcp给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。=%22%22%20tcp连接与断开详解：=%22%22%20tcp连接的每一方都有固定大小的缓冲空间，tcp的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。tcp使用的流量控制协议是可变大小的滑动窗口协议。=%22%22%20tcp（udp，ip）等首部的认识（http请求报文构成）=%22%22%20time_wait是指四次挥手中客户端接收了服务端的fin报文并发送ack报文给服务器后，仍然需要等待2msl时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入close状态了，但是我们必须假象网络是不可靠的，有可以最后一个ack丢失。如果客户端发送的ack发生丢失，服务器会再次发送fin报文给客户端，所以time_wait状态就是用来重发可能丢失的ack报文。=%22%22%20time_wait的意义（为什么要等于2msl）=%22%22%20timer）。只要tcp的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：tcp规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。=%22%22%20udp如何实现可靠传输=%22%22%20udp的头部则包括：源端口，目的端口，长度，校验和。=%22%22%20volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（cpu的优化是让该变量存放到cpu寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。=%22%22%20wdscq1234=%22%22%20window=%22%22%20write(),=%22%22%20www.cnblogs.com=%22%22%20www.zhihu.com=%22%22%20zhangliangzi=%22%22%20zhuanlan.zhihu.com=%22%22%20%7B=%22%22%20%7D=%22%22%20%7D;=%22%22%20三次握手=%22%22%20三次握手.png" alt="fig=&quot;&quot; 三次握手.png和tcp滑动窗口=&quot;&quot; 81105051=&quot;&quot; 81429627)=&quot;&quot; 8359066.html=&quot;&quot; tcp-ip详解：滑动窗口slidingwindow;=&quot;&quot; a;=&quot;&quot; accept()=&quot;&quot; ack机制，重传机制和窗口确认机制。=&quot;&quot; alifpga=&quot;&quot; answer=&quot;&quot; article=&quot;&quot; bind()=&quot;&quot; blog.csdn.net=&quot;&quot; c=&quot;&quot; c.set_show(1,=&quot;&quot; c;=&quot;&quot; class=&quot;&quot; close(),=&quot;&quot; congestion=&quot;&quot; connect()=&quot;&quot; cwnd=&quot;&quot; details=&quot;&quot; felixzh=&quot;&quot; gettogetto=&quot;&quot; https:=&quot;&quot; information=&quot;&quot; int=&quot;&quot; ip分片和完整ip报文差不多拥有相同的ip头，16位id域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个ip报文的分片。在ip头里面，16位识别号唯一记录了一个ip包的id，具有同一个id的ip分片将会重新组装；而13位片偏移则记录了某ip片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了ip分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对ip数据进行重新组织。=&quot;&quot; ip数据包的头部包括：源ip地址，目的ip地址，协议，校验和，总长度等等=&quot;&quot; junjun150013652=&quot;&quot; listen()=&quot;&quot; main(void)=&quot;&quot; ospf：详见：https:=&quot;&quot; p=&quot;&quot; protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。rip是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。=&quot;&quot; qingjiaowoxiaoxioashou=&quot;&quot; qq_22080999=&quot;&quot; qq_37964547=&quot;&quot; question=&quot;&quot; read(),=&quot;&quot; recv(),=&quot;&quot; recvfrom()=&quot;&quot; return=&quot;&quot; rip“路由信息协议(route=&quot;&quot; send(),=&quot;&quot; sendto()=&quot;&quot; shutdown()=&quot;&quot; shutdown详解" />="" 不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。="" 为什么使用三次握手，两次握手可不可以？="" 举两个例子，第一种是黑客会伪造大量syn请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫syn洪泛攻击。第二种是服务器返回给客户端的ack数据包可能会在传输的过程中丢失，而客户端没有收到该ack数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。="" 会="" 作者：姚冬="" 使用close()时，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接="" 使用友元类时注意：="" 关闭套接字="" 创建套接字="" 友元关系不具有传递性。若类b是类a的友元，类c是b的友元，类c不一定是类a的友元，同样要看类中是否有相应的申明="" 友元关系不能被继承。="" 友元关系是单向的，不具有交换性。若类b是类a的友元，类a不一定是类b的友元，要看在类中是否有相应的声明。="" 发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小="" 发送方维持一个拥塞窗口="" 发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，tcp将丢弃这个报文段和不确认收到此报文段。="" 四次挥手.png)="" 四次挥手.png](fig="" 四次挥手断开连接：="" 因为udp是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq="" 因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（mtu）就是1500字节。如果ip数据包加上头部后大小超过1500字节，就需要分片。="" 在浏览器中输入url后执行的全部过程（如www.baidu.com）="" 垃圾回收会使得c++不适合进行很多底层的操作。="" 如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。="" 客户端接收到http响应，将结果渲染展示给用户。="" 对路由协议的了解与介绍。内部网关协议igp包括rip，ospf，和外部网关协议egp和bgp.="" 就要接收方收到udp之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。="" 建立tcp服务器的各个系统调用="" 建立tcp服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。="" 建立连接="" 当tcp发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。="" 当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。="" 当vector在插入的时候，end迭代器肯定会失效="" 当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效="" 当网络拥塞时，减少数据的发送。="" 慢启动、拥塞避免、快速重传、快速恢复="" 所以在应用方面，如果强调数据的完整性和正确性用tcp，当要求性能和速度的时候，使用udp更加合适。="" 所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用tcp报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。="" 拥塞控制="" 拥塞控制.png)="" 拥塞控制和流量控制的区别="" 拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。="" 接受连接="" 接收方会在每个ack数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。="" 接收方有即时窗口（滑动窗口），随ack报文发送="" 接着是http连接，客户端向服务器发送http连接请求；="" 数据发送="" 数据接收="" 服务器对客户端发来的http请求进行处理，并返回响应；="" 服务器的系统调用](https:="" 来源：知乎="" 校验和="" 注：单凭tcp是不能保证完整性的，要是有黑客伪造tcp包，是无法识别的。="" 流量控制="" 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？="" 然后建立tcp连接，客户端与服务器通过三次握手建立tcp连接；="" 然后是css解析，将css文件解析为样式表对象来渲染dom树。="" 然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。="" 监听端口="" 确认应答+序列号="" 第一次挥手：当client没有数据要发送给server了，他会给server发送一个fin报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入fin_wait_1的第一阶段="" 第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了syn="1，client_seq=任意值i，发送之后处于SYN-SENT状态，这是第一次握手" 第三次挥手：当server发完所有数据时，他会给client发送一个fin报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成last_ack状态，等着client最后的ack信息，这是第三次挥手="" 第三次握手：client收到server发来的ack信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ack报文，报文中同样包含了ack="1这样的消息，同时呢，还包括了client_ack=k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态" 第二次挥手：当server收到client发来的fin报文后，告诉client：“我收到你的fin消息了，但是你等我发完的”此时给client返回一个ack信息，并且呢ack="seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段" 第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ack报文，这个报文中呢包含了这些字段，标志位syn和ack都为1，而小ack为i+1，此时位于syn-rcvd状态，这是第二次握手="" 第四次挥手：当client收到这个fin报文时，他会对这个消息进行确认，即给server发ack信息，但是它不相信网络，怕server收不到信息，它会进入time_wait状态，万一server没收到ack消息它可以可以重传，而当server收到这个ack信息后，就正式关闭了tcp连接，处于closed状态，而client等待了2msl这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了="" 绑定本机端口="" 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？="" 网络层分片的原因与具体实现="" 网页解析的过程与实现方法="" 考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。="" 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。="" 见上="" 解决这个问题，tcp为每一个连接设置一个持续计时器（persistence="" 计网相关="" 详见="" 详见：[建立tcp="" 详见：[网络编程socket之tcp之close="" 详见：https:="" 说一下volatile关键字的作用="" 超时重传="" 超时重传机制（不太高频）="" 这里仅展示浏览器解析服务器响应的过程，url解析和交互的完整过程在(9)="" 链接：https:="" 防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong>="" 首先是html文档解析，浏览器会将html文档生成解析树，也就是dom树，它由dom元素以及属性节点组成。="" 首先是域名解析，客户端使用dns协议将url解析为对应的ip地址；="" 首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。="" （10）="" （11）="" （12）="" （13）="" （14）="" （15）="" （16）="" （17）="" （18）="" （19）="" （1）="" （1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16="" （20）="" （2）="" （3）="" （4）="" （56）="" （57）="" （58）vector会迭代器失效吗？什么情况下会迭代器失效？="" （58）为什么c++没有实现垃圾回收？="" （5）="" （6）="" （7）="" （8）="" （9）="" （http连接无需额外连接，直接通过已经建立的tcp连接发送）="" （tcp三次握手在调用这个函数时进行）=""&gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p>
<p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p>
<p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p>
<p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd=1，进入慢启动阶段</p>
<h4 id="http协议与tcp的区别与联系">（21） http协议与TCP的区别与联系</h4>
<p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p>
<p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。 建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。 #### （22） http/1.0和http/1.1的区别 HTTP 协议老的标准是 HTTP/1.0 ，目前最通用的标准是 HTTP/1.1 。 HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http/1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<h4 id="http的请求方法有哪些get和post的区别">（23） http的请求方法有哪些？get和post的区别。</h4>
<p>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</p>
<p>get和post的区别： 1. get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源 2. get可以保存为书签，可以用缓存来优化，而post不可以 3. get把请求附在url上，而post把参数附在http包的包体中 4. 浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等 5. post可以传输二进制编码的信息，get的参数一般只支持ASCII #### （24） http的状态码 403 201等等是什么意思 详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011630575/article/details/46636535">HTTP状态码的含义</a></p>
<p>常见的状态码有： &gt;* 200 - 请求成功 &gt;* 301 - 资源（网页等）被永久转移到其它URL &gt;* 404 - 请求的资源（网页等）不存在 &gt;* 500 - 内部服务器错误 &gt;* 400 - 请求无效 &gt;* 403 - 禁止访问 #### （25） http和https的区别，由http升级为https需要做哪些操作 http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443 http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。 https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用 https://www.cnblogs.com/wqhwe/p/5407468.html</p>
<h4 id="https的具体实现怎么确保安全性">（26） https的具体实现，怎么确保安全性</h4>
<p><strong>SSL是传输层的协议</strong></p>
<p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p>
<ol type="1">
<li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li>
<li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。</li>
<li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li>
<li>Web服务器利用自己的私钥解密出会话密钥。</li>
<li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li>
</ol>
<p>服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书</p>
<p>客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数） #### （27） TCP三次握手时的第一次的seq序号是怎样产生的 第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p>
<p>seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。 #### （28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？ 65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p>
<p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。 #### （29） 对称密码和非对称密码体系 https://blog.csdn.net/qq_29689487/article/details/81634057</p>
<ul>
<li>对称加密：加密和解密使用的密钥是同一个
<ul>
<li>优点：计算量小，算法速度快，加密效率高 缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li>
<li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li>
</ul></li>
<li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密
<ul>
<li>优点：安全，不怕泄漏 缺点：速度慢</li>
<li>常用算法：RSA，ECC，DSA #### （30） 数字证书的了解（高频） <img src="fig/数字证书.jpg" alt="fig/数字证书.jpg" /></li>
</ul></li>
</ul>
<p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p>
<p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。 #### （31） 服务器出现大量close_wait的连接的原因以及解决方法 close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种： * 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法 * 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</p>
<p>处理方法： * 停止应用程序 * 修改程序里的bug #### （32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面） * 消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p>
<ul>
<li>MD5算法介绍： MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</li>
</ul>
<ol type="1">
<li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li>
<li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li>
<li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li>
<li>遍历所有分组后得到的四个变量即为结果。</li>
</ol>
<p>详见：https://blog.csdn.net/weixin_39640298/article/details/84555814</p>
<ul>
<li><p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p></li>
<li><p>加强安全性：加盐（加随机数） #### （33） 单条记录高并发访问的优化 服务器端：</p></li>
<li><p>使用缓存，如redis等</p></li>
<li><p>使用分布式架构进行处理</p></li>
<li><p>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</p></li>
<li><p>将静态资源尽可能在客户端进行缓存</p></li>
<li><p>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 = Engine X）</p></li>
</ul>
<p>数据库端： * 数据库采用主从赋值，读写分离措施 * 建立适当的索引 * 分库分表 #### （34） 介绍一下ping的过程，分别用到了哪些协议 详见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html">Ping原理与ICMP协议</a></p>
<p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p>
<ul>
<li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li>
<li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li>
<li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li>
</ul>
<p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。 #### （35） TCP/IP的粘包与避免介绍一下 因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p>
<p>导致TCP粘包的原因有三方面： * 发送端等待缓冲区满才进行发送，造成粘包 * 接收方来不及接收缓冲区内的数据，造成粘包 * 由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</p>
<p>避免粘包的措施： * 通过编程，强制使TCP发生数据传送，不必等到缓冲区满 * 优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等 * 设置固定长度的报文或者设置报文头部指示报文的长度。</p>
<h4 id="说一下tcp的封包和拆包">（36） 说一下TCP的封包和拆包</h4>
<p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。 * 封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。 * 拆包：接收方在接收到报文后提取包头中的长度信息进行截取。 #### （37） 一个ip配置多个域名，靠什么识别？ * 靠host主机名区分 * 靠端口号区分 #### （38） 服务器攻击（DDos攻击） #### （39）DNS的工作过程和原理 <img src="fig/DNS查询图解.png" /> DNS解析有两种方式：递归查询和迭代查询 * 递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。 * 迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果 #### （41）OSA七层协议和五层协议，分别有哪些 OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p>
<p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p>
<figure>
<img src="fig/网络协议层.png" alt="" /><figcaption>(fig/网络协议层.png</figcaption>
</figure>
<h4 id="ip寻址和mac寻址有什么不同怎么实现的">（42）IP寻址和MAC寻址有什么不同，怎么实现的</h4>
<p>通过MAC地址寻找主机是MAC地址寻址，通过IP地址寻找主机叫IP地址寻址。它们适用于不同的协议层，IP寻址是网络层，Mac寻址是数据链路层。</p>
<p>http://c.biancheng.net/view/6388.html</p>
<p>https://blog.csdn.net/wxy_nick/article/details/9190693</p>
<p>IP寻址的过程（ARP协议）：主机A想通过IP地址寻找到目标主机，首先分析IP地址确定目标主机与自己是否为同一网段。如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包</p>
<h1 id="数据库">3. 数据库</h1>
<h4 id="关系型和非关系型数据库的区别低频">（1） 关系型和非关系型数据库的区别（低频）</h4>
<ul>
<li>关系型数据库的优点
<ol type="1">
<li>容易理解。因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带where子句的查询）</li>
</ol></li>
<li>非关系型数据库的优点
<ol type="1">
<li>不需要经过sql层的解析，读写效率高。</li>
<li>基于键值对，数据的扩展性很好。</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。 #### （2） 什么是非关系型数据库（低频） 非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</li>
</ol></li>
</ul>
<p>适合使用非关系型数据库的场景： * 日志系统 * 地理位置存储 * 数据量巨大 * 高可用 #### （3） 说一下 MySQL 执行一条查询语句的内部执行过程？ * 连接器：客户端先通过连接器连接到 MySQL 服务器。 * 缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。 * 分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。 * 优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。 * 执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。 #### （4） 数据库的索引类型 数据库的索引类型分为逻辑分类和物理分类</p>
<p>逻辑分类： * 主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。 * 唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。 * 普通索引 一张表可以有多个普通索引，可以重复可以为空值 * 全文索引 可以加快模糊查询，不常用</p>
<p>物理分类： * 聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。 * 非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。 #### （5） 说一下事务是怎么实现的 https://blog.csdn.net/u013256816/article/details/103966510</p>
<p>https://www.cnblogs.com/takumicx/p/9998844.html</p>
<p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p>
<ul>
<li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li>
<li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li>
</ul>
<h4 id="mysql怎么建立索引怎么建立主键索引怎么删除索引">（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h4>
<p>MySQL建立索引有两种方式：用alter table或者create index。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary key(column_list) #添加一个主键索引</span><br><span class="line">alter table table_name add index (column_list)      #添加一个普通索引</span><br><span class="line">alter table table_name add unique (column_list)     #添加一个唯一索引</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name (column_list)   #创建一个普通索引</span><br><span class="line">create unique index_name on table_name (column_list)  #创建一个唯一索引</span><br></pre></td></tr></table></figure></p>
<p>Mysql删除索引同样也有两种方式：alter table 和 drop index <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name drop index index_name    #删除一个普通索引</span><br><span class="line">alter table table_name drop primary key         #删除一个主键索引</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on table table_name</span><br></pre></td></tr></table></figure> #### （7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点） https://www.cnblogs.com/wezheng/p/8399305.html * 经常搜索的列上建索引 * 作为主键的列上要建索引 * 经常需要连接（where子句）的列上 * 经常需要排序的列 * 经常需要范围查找的列</p>
<p>哪些列不适合建索引？ * 很少查询的列 * 更新很频繁的列 * 数据值的取值比较少的列（比如性别） #### （8） 索引的底层实现（重点） 数据库的索引是使用B+树来实现的。</p>
<p>（为什么要用B+树，为什么不用红黑树和B树）</p>
<p>B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p>
<p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p>
<h4 id="b树和b树的区别重点">（9） B树和B+树的区别（重点）</h4>
<figure>
<img src="./fig/Bptree.png" alt="" /><figcaption>./fig/Bptree.png</figcaption>
</figure>
<p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。 1. 关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。 2. 存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。 3. 分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。 4. 查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</p>
<p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。 #### （10） 索引最左前缀/最左匹配 假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。 #### （11） Mysql的优化（高频，索引优化，性能优化） 高频访问： * 分表分库：将数据库表进行水平拆分，减少表的长度 * 增加缓存： 在web和DB之间加上一层缓存层 * 增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</p>
<p>并发优化： * 主从读写分离：只在主服务器上写，从服务器上读 * 负载均衡集群：通过集群或者分布式的方式解决并发压力 #### （12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别 * InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表 行级锁 * MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用 表级锁 * MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景 * CSV * blackhole #### （13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题） 数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</p>
<p><strong>A: atom 原子性</strong></p>
<p>数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p>
<p><strong>C: consistency 一致性</strong></p>
<p>数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。 比如在银行转账操作后两个账户的总额应当不变。</p>
<p><strong>I: isolation 隔离性</strong></p>
<p>数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p>
<p><strong>D：durability 持久性</strong></p>
<p>数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。 如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。 #### （14）什么是脏读，不可重复读和幻读？ 详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a> * 脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。</p>
<blockquote>
<p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读 * 不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。 比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。 不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。 * 幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。 比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。 不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p>
</blockquote>
<p>避免不可重复读需要锁行，避免幻读则需要锁表。</p>
<p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。 详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html">脏读、不可重复读和幻读的区别</a></p>
<h4 id="数据库的隔离级别mysql和oracle的隔离级别分别是什么重点">（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h4>
<p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a>和<a target="_blank" rel="noopener" href="https://blog.csdn.net/fg2006/article/details/6937413">数据库隔离级别</a></p>
<p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别： * 读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题 * 读已提交 Read committed: 可以避免脏读的发生 * 可重复读 Reapeatable read: 确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现 * 串行化 Serializaion 最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</p>
<p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p>
<p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别 #### （16） 数据库连接池的作用 #### （17） Mysql的表空间方式，各自特点 * 共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 * 独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题 #### （18） 分布式事务 #### （19） 数据库的范式 https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</p>
<ul>
<li><strong>第一范式(确保每列保持原子性)</strong></li>
</ul>
<p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
<blockquote>
<p>比如 学生 选课（包括很多课程） 就不符合第一范式 * <strong>第二范式(确保表中的每列都和主键相关)</strong></p>
</blockquote>
<p>在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。</p>
<blockquote>
<p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系 * <strong>第三范式(确保非主键的列没有传递依赖)</strong></p>
</blockquote>
<p>在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</p>
<blockquote>
<p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级 * <strong>BCNF范式（确保主键之间没有传递依赖）</strong></p>
</blockquote>
<p>主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。 #### （20） 数据的锁的种类，加锁的方式 以MYSQL为例， * 按照类型来分有乐观锁和悲观锁 * 根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁） * 根据作用来分有共享锁（读锁）和排他锁（写锁）。 #### （21） 什么是共享锁和排他锁 * 共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。 * 排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</p>
<p>https://blog.csdn.net/qq_42743933/article/details/81236658 #### （22） 分库分表的理解和简介 #### （23） #### （24）数据库高并发的解决方案 1. 在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。 2. 增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢） 3. 主从读写分离，让主服务器负责写，从服务器负责读。 4. 将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。 5. 使用分布式架构，分散计算压力。 #### （25）乐观锁与悲观锁解释一下 一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</p>
<p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。 #### （26）乐观锁与悲观锁是怎么实现的 悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p>
<p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p>
<p>乐观锁有三种常用的实现形式： * 一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。 * 一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。 * 最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</p>
<h4 id="对数据库目前最新技术有什么了解吗">（27）对数据库目前最新技术有什么了解吗</h4>
<h1 id="linux">4. Linux</h1>
<h4 id="linux的io模型介绍以及同步异步阻塞非阻塞的区别超级重要">（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h4>
<p>https://blog.csdn.net/sqsltr/article/details/92762279</p>
<p>https://www.cnblogs.com/euphie/p/6376508.html</p>
<p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p>
<ul>
<li><p>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</p></li>
<li><p>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</p></li>
<li><p>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</p></li>
<li><p>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</p></li>
<li><p>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。 #### （2） 文件系统的理解（EXT4，XFS，BTRFS） #### （3） EPOLL的介绍和了解 https://zhuanlan.zhihu.com/p/56486633</p></li>
</ul>
<p>https://www.jianshu.com/p/397449cadc9a</p>
<p>https://blog.csdn.net/davidsguo008/article/details/73556811</p>
<p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p>
<p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p>
<p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p>
<ul>
<li><p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p></li>
<li><p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p></li>
<li><p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。 #### （4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？ （1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024. <img src="fig/select.png" alt="select" /> （2）poll使用链表保存文件描述符，其他的跟select没有什么不同。</p></li>
</ul>
<p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。 <img src="fig/epoll.png" alt="epoll" /> 详见 https://www.cnblogs.com/Anker/p/3265058.html</p>
<h4 id="epoll的et模式和lt模式et的非阻塞">（5） Epoll的ET模式和LT模式（ET的非阻塞）</h4>
<ul>
<li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li>
<li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。 #### （6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义） 详见：https://blog.csdn.net/qq_36357820/article/details/76606113</li>
</ul>
<ol type="1">
<li>top命令查看linux负载：</li>
<li>uptime查看linux负载</li>
<li>w查看linux负载：</li>
<li>vmstat查看linux负载 #### （7） linux的其他常见命令（kill，find，cp等等） #### （8） shell脚本用法 #### （9） 硬连接和软连接的区别 #### （10） 文件权限怎么看（rwx） #### （11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变 #### （12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令 #### （13）Linux中线程的同步方式有哪些？ #### （14）怎么修改一个文件的权限 chmod 777 (177 277 477 等，权限组合是 1 2 4，分别代表r x w ) #### （15）查看文件内容常用命令 详见： http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</li>
<li>cat 与 tac <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容</span><br><span class="line"></span><br><span class="line">cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）</span><br><span class="line"></span><br><span class="line">tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令不常用。</span><br><span class="line"></span><br><span class="line">tac语法：tac 文件名。</span><br></pre></td></tr></table></figure></li>
<li>more和less（常用） <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more</span><br><span class="line"></span><br><span class="line">more的语法：more 文件名</span><br><span class="line"></span><br><span class="line">Enter 向下n行，需要定义，默认为1行； </span><br><span class="line"></span><br><span class="line">Ctrl f 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">空格键 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">Ctrl b 返回上一屏； </span><br><span class="line"></span><br><span class="line">= 输出当前行的行号； </span><br><span class="line"></span><br><span class="line">:f 输出文件名和当前行的行号； </span><br><span class="line"></span><br><span class="line">v 调用vi编辑器； </span><br><span class="line"></span><br><span class="line">! 命令 调用Shell，并执行命令； </span><br><span class="line"></span><br><span class="line">q 退出more</span><br><span class="line"></span><br><span class="line">less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</span><br><span class="line"></span><br><span class="line">less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</span><br><span class="line"></span><br><span class="line">less的语法：less 文件名</span><br></pre></td></tr></table></figure></li>
<li>head和tail <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容</span><br><span class="line"></span><br><span class="line">head的语法：head [n number] 文件名 (number 显示行数)</span><br><span class="line"></span><br><span class="line">tail的功能恰好和head相反，只显示最后几行内容</span><br><span class="line"></span><br><span class="line">tail的语法:tail [-n number] 文件名</span><br></pre></td></tr></table></figure></li>
<li>nl <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来</span><br><span class="line"></span><br><span class="line">nl的语法：nl 文件名</span><br></pre></td></tr></table></figure></li>
<li>vim</li>
</ol>
<p>这个用的太普遍了，主要是用于编辑。</p>
<h4 id="怎么找出含有关键字的前后4行">（16）怎么找出含有关键字的前后4行</h4>
<h4 id="linux的gdb调试">（17）Linux的GDB调试</h4>
<h4 id="coredump是什么-怎么才能coredump">（18）coredump是什么 怎么才能coredump</h4>
<p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<p>coredump产生的条件 1. shell资源控制限制，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。 2. 读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界 3. 使用了线程不安全的函数，读写未加锁保护 4. 错误使用指针转换 5. 堆栈溢出 #### （19）tcpdump常用命令 用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<p>实用命令实例</p>
<p>将某端口收发的数据包保存到文件</p>
<p><code>sudo tcpdump -i any port 端口 -w 文件名.cap</code></p>
<p>打印请求到屏幕</p>
<p><code>sudo tcpdump -i any port 端口 -Xnlps0</code></p>
<p>默认启动</p>
<p><code>tcpdump</code> 普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。 监视指定网络接口的数据包</p>
<p><code>tcpdump -i eth1</code> 如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。　 #### （20） crontab命令 详见：https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</p>
<p>corntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。</p>
<ul>
<li><p>crontab命令用来对crontab文件进行管理 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1．命令格式：</span><br><span class="line">crontab [-u user] file</span><br><span class="line">crontab [-u user] [ -e | -l | -r ]</span><br><span class="line">2．命令功能：</span><br><span class="line">通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</span><br><span class="line">3．命令参数：</span><br><span class="line">-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</span><br><span class="line">file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">-i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure></p></li>
<li><p>crontab文件内容</p></li>
</ul>
<p>crond是Linux下的周期性执行系统任务的守护进程，他会根据/etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。</p>
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">minute   hour   day   month   week   command</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">minute： 表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</span><br><span class="line">在以上各个字段中，还可以使用以下特殊字符：</span><br><span class="line">星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class="line">逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</span><br><span class="line">中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</span><br><span class="line">正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</span><br></pre></td></tr></table></figure> #### （21） 查看后台进程 * jobs</p>
<p>查看当前控制台的后台进程</p>
<p>想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可</p>
<ul>
<li>ps</li>
</ul>
<p>查看后台进程</p>
<ul>
<li>top</li>
</ul>
<p>查看所有进程和资源使用情况，类似Windows中的任务管理器</p>
<p>停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）</p>
<p>退出top：输入q即可</p>
<h1 id="操作系统">5. 操作系统</h1>
<h4 id="linux理论上最多可以创建多少个进程一个进程可以创建多少线程和什么有关">（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</h4>
<p>答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。</p>
<p>至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。 #### （3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面） * 存储器：内存 * 控制器：南桥北桥 * 运算器：CPU * 输入设备：键盘 * 输出设备：显示器、网卡 #### （4） 进程之间的通信方法有哪几种 （重点） 进程之间的通信方式主要有六种，包括<strong>管道，信号量，消息队列，信号，共享内存，套接字</strong>。</p>
<ul>
<li><p>管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的</p>
<p>匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。</p>
<p>管道的底层实现 https://segmentfault.com/a/1190000009528245</p></li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。</p></li>
<li><p>信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的</p></li>
<li><p>共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p></li>
<li><p>消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。 消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。 可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p></li>
<li><p>套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p></li>
</ul>
<h4 id="进程的执行过程是什么样的执行一个进程需要做哪些工作">（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</h4>
<p>进程的执行需要经过三大步骤：编译，链接和装入。 * 编译：将源代码编译成若干模块 * 链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接） * 装入：将模块装入内存运行</p>
<p>https://blog.csdn.net/qq_38623623/article/details/78306498</p>
<p>将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p>
<p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。 #### （6） 操作系统的内存管理说一下 https://www.cnblogs.com/peterYong/p/6556619.html</p>
<p>https://zhuanlan.zhihu.com/p/141602175</p>
<p>操作系统的内存管理包括物理内存管理和虚拟内存管理 * 物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等； * 虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；</p>
<p>（面试官这样问的时候，其实是希望你能讲讲虚拟内存） #### （7） 实现一个LRU算法 用到两个数据结构：哈希+双向链表 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int,list&lt;pair&lt;int,int&gt; &gt; &gt; cache ;// 存放键，迭代器</span><br><span class="line">list&lt;pair&lt;int,int&gt;&gt; auxlist; // 存放 &lt;键，值&gt;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    int cap;</span><br><span class="line">    list&lt;pair&lt;int,int&gt;&gt; l;// front:new back:old 存放值 新的放前面，因为前面的可以取得有效的迭代器</span><br><span class="line">    map&lt;int,list&lt;pair&lt;int,int&gt; &gt;::iterator &gt; cache;// 存放键，迭代器</span><br><span class="line">public:</span><br><span class="line">    LRUCache(int capacity) &#123;</span><br><span class="line">        cap=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        auto mapitera = cache.find(key);</span><br><span class="line">        if(mapitera==cache.end())&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;// found</span><br><span class="line">            list&lt;pair&lt;int,int&gt;&gt;::iterator listItera = mapitera-&gt;second;</span><br><span class="line">            int value = (*listItera).second;</span><br><span class="line"></span><br><span class="line">            l.erase(listItera);</span><br><span class="line">            l.push_front(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.begin();</span><br><span class="line"></span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        auto itera = cache.find(key);</span><br><span class="line">        if(itera!=cache.end())&#123;// exist</span><br><span class="line">            list&lt;pair&lt;int,int&gt;&gt;::iterator listItera = itera-&gt;second;</span><br><span class="line"></span><br><span class="line">            l.erase(listItera);</span><br><span class="line">            l.push_front(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.begin();</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;// not exist</span><br><span class="line">            if(cache.size()&gt;=cap)&#123;</span><br><span class="line">                pair&lt;int,int&gt; oldpair = l.back();</span><br><span class="line">                l.pop_back();</span><br><span class="line">                cache.erase(oldpair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            l.push_front(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.begin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="line"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="line"> * int param_1 = obj-&gt;get(key);</span><br><span class="line"> * obj-&gt;put(key,value);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure> #### （8） 死锁的恢复 1. 重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。 2. 终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。 (1) 一次性全部终止；(2) 逐步终止(优先级，代价函数) 3. 剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。 (1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。 (2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。 4. 进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大： (1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。 (2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的 #### （8）什么是饥饿 饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。 #### （9） 如果要你实现一个mutex互斥锁你要怎么实现？ https://blog.csdn.net/kid551/article/details/84338619</p>
<p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag=1表明该锁已经锁住，flag=0表明锁没有锁住。 实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0； <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;flag,<span class="number">1</span>)==<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//flag=1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 因为while有可能被重入，所以可以用TestandSet()方法。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr;</span><br><span class="line">    *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### （10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？ 线程之间通信： * 使用全局变量 * 使用信号机制 * 使用事件</p>
<p>进程之间同步： https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</p>
<ul>
<li><p>信号量</p></li>
<li><p>管程 #### （13） 什么时候用多进程，什么时候用多线程 https://blog.csdn.net/yu876876/article/details/82810178</p></li>
<li><p>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></p></li>
<li><p>计算量：需要大量计算的优先使用<strong>多线程</strong> 因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</p></li>
<li><p>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</p></li>
<li><p>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</p></li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。 #### （14） 文件读写使用的系统调用 #### （15） 孤儿进程和僵尸进程分别是什么，怎么形成的？ https://www.cnblogs.com/Anker/p/3271773.html</p>
<ul>
<li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li>
<li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。 #### （16） 说一下PCB/说一下进程地址空间/ https://blog.csdn.net/qq_38499859/article/details/80057427</li>
</ul>
<p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p>
<p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p>
<p><img src="https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" /></p>
<p>进程地址空间内有： * 代码段text：存放程序的二进制代码 * 初始化的数据Data：已经初始化的变量和数据 * 未初始化的数据BSS：还没有初始化的数据 * 栈 * 堆 #### （17） 内核空间和用户空间是怎样区分的 在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</p>
<p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。 #### （18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论） https://blog.csdn.net/s_lisheng/article/details/74278765</p>
<ul>
<li>临界区</li>
<li>信号量</li>
<li>事件</li>
<li>互斥量 #### （19） 同一个进程内的线程会共享什么资源？</li>
<li>该进程的地址空间</li>
<li>全局变量</li>
<li>堆空间</li>
</ul>
<p>线程的栈空间是自己独有的 #### （20） 异常和中断的区别 #### （21） 一般情况下在Linux/windows平台下栈空间的大小 在Linux下栈空间通常是8M，Windows下是1M #### （22）虚拟内存的了解 https://www.cnblogs.com/Przz/p/6876988.html</p>
<p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。 当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。 #### （23）服务器高并发的解决方案 1. 应用数据与静态资源分离 将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p>
<ol start="2" type="1">
<li><p>客户端缓存 因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p></li>
<li><p>集群和分布式 （集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）</p></li>
</ol>
<p>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）</p>
<p>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p>
<ol start="4" type="1">
<li>反向代理 在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。 #### （24）协程了解吗（高频） 协程和微线程是一个东西。</li>
</ol>
<p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。 这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。 #### （25）那协程的底层是怎么实现的，怎么使用协程？ 协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。 #### （23）进程的状态以及转换图 * 三态模型 三态模型包括三种状态： 1. 执行：进程分到CPU时间片，可以执行 2. 就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行 3. 阻塞：有IO事件或者等待其他资源 <img src="fig/三态模型.png" /> * 五态模型 1. 新建态：进程刚刚创建。 2. 就绪态： 3. 运行态： 4. 等待态：出现等待事件 5. 终止态：进程结束 <img src="fig/五态模型.png" /></p>
<ul>
<li>七态模型
<ol type="1">
<li>新建态</li>
<li>就绪挂起态</li>
<li>就绪态</li>
<li>运行态</li>
<li>等待态</li>
<li>挂起等待态</li>
<li>终止态 <img src="fig/七态模型.png" /></li>
</ol></li>
</ul>
<h4 id="在执行malloc申请内存的时候操作系统是怎么做的内存分配的原理说一下malloc函数底层是怎么实现的进程是怎么分配内存的">（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？</h4>
<p>https://blog.csdn.net/yusiguyuan/article/details/39496057</p>
<p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap * brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小 * mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</p>
<p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p>
<p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。 #### （25）什么是字节序？怎么判断是大端还是小端？有什么用？ https://www.cnblogs.com/broglie/p/5645200.html</p>
<p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。 判断大小端的方法：使用一个union数据结构 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">  <span class="keyword">short</span> s;</span><br><span class="line">  <span class="keyword">char</span> c[<span class="number">2</span>]; <span class="comment">// sizeof(short)=2;</span></span><br><span class="line">&#125;un;</span><br><span class="line">un.s=<span class="number">0x0102</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">1</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;大端&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">2</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;小端&quot;</span>;</span><br></pre></td></tr></table></figure> 在网络编程中不同字节序的机器发送和接收的顺序不同。</p>
<h1 id="场景题算法题">6. 场景题/算法题</h1>
<h4 id="leetcode-hot100至少刷两遍剑指offer至少刷两遍-重中之重">（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h4>
<p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要 #### （1） 介绍熟悉的设计模式（单例，简单工厂模式） #### （2） 写单例模式，线程安全版本 <figure class="highlight c++"><figcaption><span>version</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">      <span class="comment">// initialize</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance==<span class="literal">nullptr</span>) instance=<span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> #### （3） 写三个线程交替打印ABC <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">0</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 1: a&quot;</span>&lt;&lt;endl; <span class="number">1</span>=<span class="string">&quot;&quot;</span> count++;=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="string">&quot;my=&quot;</span><span class="string">&quot; cv.notify_all();=&quot;</span><span class="string">&quot; finish&quot;</span>&lt;&lt;endl;=<span class="string">&quot;&quot;</span> flag=<span class="string">&quot;1;&quot;</span> <span class="built_in">printb</span>()&#123;=<span class="string">&quot;&quot;</span> thread=<span class="string">&quot;&quot;</span> unique_lock&lt;mutex=<span class="string">&quot;&quot;</span> <span class="keyword">void</span>=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span>&gt; <span class="built_in">lk</span>(mymutex);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">1</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 2: b&quot;</span>&lt;&lt;endl; <span class="number">2</span>=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="string">&quot;my=&quot;</span><span class="string">&quot; cv.notify_all();=&quot;</span><span class="string">&quot; finish&quot;</span>&lt;&lt;endl;=<span class="string">&quot;&quot;</span> flag=<span class="string">&quot;2;&quot;</span> <span class="built_in">printc</span>()&#123;=<span class="string">&quot;&quot;</span> thread=<span class="string">&quot;&quot;</span> unique_lock&lt;mutex=<span class="string">&quot;&quot;</span> <span class="keyword">void</span>=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span>&gt; <span class="built_in">lk</span>(mymutex);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">2</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 3: c&quot;</span>&lt;&lt;endl; ![](fig=<span class="string">&quot;&quot;</span> <span class="string">&quot;&lt;&lt;endl;=&quot;</span><span class="string">&quot; ####=&quot;</span><span class="string">&quot; *=&quot;</span><span class="string">&quot; 3=&quot;</span><span class="string">&quot; ```=&quot;</span><span class="string">&quot; ```c++=&quot;</span><span class="string">&quot; a=&quot;</span>a^b;<span class="string">&quot; a,int&amp;=&quot;</span><span class="string">&quot; b=&quot;</span>a^b;<span class="string">&quot; b)&#123;=&quot;</span><span class="string">&quot; cout&lt;&lt;&quot;</span>=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="string">&quot;my=&quot;</span><span class="string">&quot; cv.notify_all();=&quot;</span><span class="string">&quot; finish&quot;</span>&lt;&lt;endl;=<span class="string">&quot;&quot;</span> flag=<span class="string">&quot;0;&quot;</span> <span class="keyword">int</span>=<span class="string">&quot;&quot;</span> main=<span class="string">&quot;&quot;</span> <span class="built_in">main</span>()&#123;=<span class="string">&quot;&quot;</span> <span class="built_in">swap</span>(<span class="keyword">int</span>&amp;=<span class="string">&quot;&quot;</span> <span class="built_in">swap</span>(vector&lt;<span class="keyword">int</span>=<span class="string">&quot;&quot;</span> <span class="built_in">th1</span>(printb);=<span class="string">&quot;&quot;</span> th1.<span class="built_in">join</span>();=<span class="string">&quot;&quot;</span> <span class="built_in">th2</span>(printa);=<span class="string">&quot;&quot;</span> th2.<span class="built_in">join</span>();=<span class="string">&quot;&quot;</span> <span class="built_in">th3</span>(printc);=<span class="string">&quot;&quot;</span> th3.<span class="built_in">join</span>();=<span class="string">&quot;&quot;</span> thread=<span class="string">&quot;&quot;</span> <span class="keyword">void</span>=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span> 不使用临时变量实现swap函数=<span class="string">&quot;&quot;</span> 二维码登录流程.png)=<span class="string">&quot;&quot;</span> 二维码登录的实现过程=<span class="string">&quot;&quot;</span> 使用异或=<span class="string">&quot;&quot;</span> 加减等方式，下面给出使用异或的实现方法=<span class="string">&quot;&quot;</span> 场景题=<span class="string">&quot;&quot;</span> 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢=<span class="string">&quot;&quot;</span> 实现快排=<span class="string">&quot;&quot;</span> （<span class="number">4</span>）=<span class="string">&quot;&quot;</span> （<span class="number">5</span>）=<span class="string">&quot;&quot;</span> （<span class="number">6</span>）=<span class="string">&quot;&quot;</span> （<span class="number">7</span>）=<span class="string">&quot;&quot;</span>&gt;&amp; vec,<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    vec[a]=vec[a]^vec[b];</span><br><span class="line">    vec[b]=vec[a]^vec[b];</span><br><span class="line">    vec[a]=vec[a]^vec[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">partition</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; vec,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot=vec[start+(end-start)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123; <span class="keyword">and</span>=<span class="string">&quot;&quot;</span> start++;=<span class="string">&quot;&quot;</span> vec[end]=<span class="string">&quot;&quot;</span> vec[start]&lt;pivot)=<span class="string">&quot;&quot;</span> <span class="keyword">while</span>(start&lt;end=<span class="string">&quot;&quot;</span>&gt;pivot) end--;</span><br><span class="line">        <span class="keyword">if</span>(start&lt;end) <span class="built_in">quicksort</span>(vector&lt;<span class="keyword">int</span>=<span class="string">&quot;&quot;</span> <span class="keyword">return</span>=<span class="string">&quot;&quot;</span> start;=<span class="string">&quot;&quot;</span> <span class="built_in">swap</span>(vec,start,end);=<span class="string">&quot;&quot;</span> <span class="keyword">void</span>=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span>&gt;&amp; vec,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot=<span class="built_in">partition</span>(vec,start,end);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec,start,pivot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec,pivot+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### （8） 实现一个堆排序 堆排序的基本过程： * 将n个元素的序列构建一个大顶堆或小顶堆 * 将堆顶的元素放到序列末尾 * 将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</p>
<p>整体时间复杂度为nlogn <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    arr[a]=arr[a]^arr[b];</span><br><span class="line">    arr[b]=arr[a]^arr[b];</span><br><span class="line">    arr[a]=arr[a]^arr[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr,<span class="keyword">int</span> len,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxid=index;</span><br><span class="line">    <span class="comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">2</span>*index+<span class="number">1</span>,right=<span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找当前以index为根的子树中最大/最小的元素的下标</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;len <span class="built_in">adjust</span>(arr,len,maxid);=<span class="string">&quot;&quot;</span> <span class="keyword">and</span>=<span class="string">&quot;&quot;</span> arr[left]&lt;arr[maxid])=<span class="string">&quot;&quot;</span> arr[right]&lt;arr[maxid])=<span class="string">&quot;&quot;</span> <span class="built_in">heapsort</span>(vector&lt;<span class="keyword">int</span>=<span class="string">&quot;&quot;</span> <span class="keyword">if</span>(maxid!=<span class="string">&quot;index)&#123;&quot;</span> <span class="keyword">if</span>(right&lt;len=<span class="string">&quot;&quot;</span> maxid=<span class="string">&quot;right;&quot;</span> <span class="built_in">swap</span>(arr,maxid,index);=<span class="string">&quot;&quot;</span> <span class="keyword">void</span>=<span class="string">&quot;&quot;</span> &#125;=<span class="string">&quot;&quot;</span> 进行交换，记得要递归进行adjust,传入的index是maxid=<span class="string">&quot;&quot;</span>&gt;&amp;arr,<span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="comment">// 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(len<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">adjust</span>(arr,len,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr,<span class="number">0</span>,i);</span><br><span class="line">        <span class="built_in">adjust</span>(arr,i,<span class="number">0</span>);<span class="comment">// 注意每次adjust是从根往下调整，所以这里index是0！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;before: &quot;</span>&lt;&lt;endl; <span class="string">&quot;;=&quot;</span><span class="string">&quot; &quot;</span>&lt;&lt;endl;=<span class="string">&quot;&quot;</span> ####=<span class="string">&quot;&quot;</span> <span class="number">0</span>;=<span class="string">&quot;&quot;</span> <span class="number">8656425</span>=<span class="string">&quot;&quot;</span> ```=<span class="string">&quot;&quot;</span> ```c++=<span class="string">&quot;&quot;</span> article=<span class="string">&quot;&quot;</span> blog.csdn.net=<span class="string">&quot;&quot;</span> cout&lt;&lt;<span class="string">&quot;after:=&quot;</span><span class="string">&quot; cout&lt;&lt;endl;=&quot;</span><span class="string">&quot; cout&lt;&lt;item&lt;&lt;&quot;</span>=<span class="string">&quot;&quot;</span> details=<span class="string">&quot;&quot;</span> <span class="keyword">for</span>(<span class="keyword">int</span>=<span class="string">&quot;&quot;</span> <span class="built_in">heapsort</span>(arr,arr.<span class="built_in">size</span>());=<span class="string">&quot;&quot;</span> https:=<span class="string">&quot;&quot;</span> <span class="built_in">insertsort</span>(vector&lt;<span class="keyword">int</span>=<span class="string">&quot;&quot;</span> item:arr)=<span class="string">&quot;&quot;</span> item:arr)cout&lt;&lt;item&lt;&lt;<span class="string">&quot;=&quot;</span><span class="string">&quot; left_la=&quot;</span><span class="string">&quot; return=&quot;</span><span class="string">&quot; void=&quot;</span><span class="string">&quot; &#125;=&quot;</span><span class="string">&quot; 实现一个插入排序=&quot;</span><span class="string">&quot; （8）=&quot;</span><span class="string">&quot;&gt;&amp; nums)&#123;</span></span><br><span class="line"><span class="string">  int len=nums.size();</span></span><br><span class="line"><span class="string">  for(int i=1;i&lt;len;i++)&#123; int=&quot;</span><span class="string">&quot; j=&quot;</span>i<span class="number">-1</span>;<span class="string">&quot; key=&quot;</span>nums[i];<span class="string">&quot; while(j=&quot;</span><span class="string">&quot;&gt;=0 and nums[j]&gt;key)&#123;</span></span><br><span class="line"><span class="string">      nums[j+1]=nums[j];</span></span><br><span class="line"><span class="string">      j--;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    nums[j+1]=key;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="快排存在的问题如何优化">（9） 快排存在的问题，如何优化</h4>
<ul>
<li>3 种快排基准选择方法：</li>
</ul>
<p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p>
<ul>
<li>4种优化方式：</li>
</ul>
<p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p>
<p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p>
<p>优化3：优化递归操作</p>
<p>优化4：使用并行或多线程处理子序列 #### （10） 反转一个链表（招银网络二面） <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* root)</span></span>&#123;</span><br><span class="line">  ListNode* pre=<span class="literal">nullptr</span>,cur=root,nxt;</span><br><span class="line">  <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    nxt=cur-&gt;next;</span><br><span class="line">    cur-&gt;next=pre;</span><br><span class="line">    pre=cur;cur=nxt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### （11） Top K问题（可以采取的方法有哪些，各自优点？）（重点） <em>Top K 问题的常见形式：</em> &gt;给定10000个整数，找第K大（第K小）的数</p>
<p>给定10000个整数，找出最大（最小）的前K个数</p>
<p>给定100000个单词，求前K词频的单词</p>
<p><em>解决Top K问题若干种方法</em> * 使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。 * Quick Select算法。使用类似快排的思路，根据pivot划分数组。 * 使用排序方法，排序后再寻找top K元素。 * 使用选择排序的思想，对前K个元素部分排序。 * 将1000.....个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</p>
<ol type="1">
<li>使用最大最小堆的思路 （以top K 最大元素为例）</li>
</ol>
<p>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</p>
<blockquote>
<p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p>
</blockquote>
<p>C++中的最大最小堆要用标准库的priority_queue来实现。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="keyword">int</span> v, <span class="keyword">int</span> i): <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> struct Node &amp;n1, <span class="keyword">const</span> struct Node &amp;n2) ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> struct Node &amp;n1, <span class="keyword">const</span> struct Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>使用Quick Select的思路（以寻找第K大的元素为例）</li>
</ol>
<p>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的： 首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。 此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作； 如果左边的数组元素个数等于K-1，则第K大的数就是pivot； 如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</p>
<p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//此为Java实现</span><br><span class="line">public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">  return quickSelect(nums, k, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// quick select to find the kth-largest element</span><br><span class="line">public int quickSelect(int[] arr, int k, int left, int right) &#123;</span><br><span class="line">  if (left == right) return arr[right];</span><br><span class="line">  int index = partition(arr, left, right);</span><br><span class="line">  if (index - left + 1 &gt; k)</span><br><span class="line">    return quickSelect(arr, k, left, index - 1);</span><br><span class="line">  else if (index - left + 1 == k)</span><br><span class="line">    return arr[index];</span><br><span class="line">  else</span><br><span class="line">    return quickSelect(arr, k - (index - left + 1), index + 1, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）</li>
</ol>
<p>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K) #### （12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面） 我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</p>
<p>https://blog.csdn.net/ailunlee/article/details/84548950</p>
<h4 id="自己构建一棵二叉树使用带有null标记的前序遍历序列">（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</h4>
<p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span>&#123;</span></span><br><span class="line">    string val;</span><br><span class="line">    treeNode* left,*right;</span><br><span class="line">    <span class="built_in">treeNode</span>(string val):<span class="built_in">val</span>(val)&#123;</span><br><span class="line">        left=<span class="literal">nullptr</span>;</span><br><span class="line">        right=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">treeNode* <span class="title">vec2tree</span><span class="params">(vector&lt;string&gt;&amp; vec,<span class="keyword">int</span>&amp; start)</span></span>&#123;</span><br><span class="line">    treeNode* root;</span><br><span class="line">    <span class="keyword">if</span>(vec[start]==<span class="string">&quot;null&quot;</span>)&#123;</span><br><span class="line">        start+=<span class="number">1</span>;</span><br><span class="line">        root=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> <span class="built_in">treeNode</span>(vec[start]);</span><br><span class="line">        start+=<span class="number">1</span>;</span><br><span class="line">        root-&gt;left=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">        root-&gt;right=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree2vec</span><span class="params">(treeNode *root,vector&lt;string&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;left,vec);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;right,vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec=&#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>,&amp;start=index;</span><br><span class="line">    treeNode* root=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">    <span class="comment">//displaytree(root);</span></span><br><span class="line">    vector&lt;string&gt; mvec;</span><br><span class="line">    <span class="built_in">tree2vec</span>(root,mvec);</span><br><span class="line">    <span class="keyword">for</span>(string item:mvec) cout&lt;&lt;item&lt;&lt;<span class="string">&quot; ![](fig=&quot;</span><span class="string">&quot; &quot;</span>;=<span class="string">&quot;&quot;</span> ####=<span class="string">&quot;&quot;</span> *=<span class="string">&quot;&quot;</span> **移位计算公式：**=<span class="string">&quot;&quot;</span> <span class="number">0</span>;=<span class="string">&quot;&quot;</span> <span class="number">1.</span>=<span class="string">&quot;&quot;</span> <span class="number">1000</span>=<span class="string">&quot;&quot;</span> <span class="number">110202102</span>=<span class="string">&quot;&quot;</span> <span class="number">2</span>=<span class="string">&quot;&quot;</span> <span class="number">2.</span>=<span class="string">&quot;&quot;</span> <span class="number">3.</span>=<span class="string">&quot;&quot;</span> <span class="number">32</span>]。=<span class="string">&quot;&quot;</span> <span class="number">32</span>就是将n的二进制右移log32（也就是<span class="number">5</span>）位=<span class="string">&quot;&quot;</span> <span class="number">4.</span>=<span class="string">&quot;&quot;</span> <span class="number">5.</span>=<span class="string">&quot;&quot;</span> <span class="number">6104371.</span>html=<span class="string">&quot;&quot;</span> <span class="number">7786014</span>=<span class="string">&quot;&quot;</span> &lt;=<span class="string">&quot;m）&quot;</span> =<span class="number">4</span>*<span class="number">8</span>比特=<span class="string">&quot;32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int&quot;</span> ```=<span class="string">&quot;&quot;</span> ```sql=<span class="string">&quot;&quot;</span> a[<span class="number">1</span>+max=<span class="string">&quot;&quot;</span> article=<span class="string">&quot;&quot;</span> b+树是一种特殊的b树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。=<span class="string">&quot;&quot;</span> bitmap1.png)=<span class="string">&quot;&quot;</span> bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。=<span class="string">&quot;&quot;</span> blog.csdn.net=<span class="string">&quot;&quot;</span> b树主要应用于文件系统中，在数据库中（mongodb）也有应用，与b+树相比好处应该是有时不需要访问到叶节点就可以获取数据。=<span class="string">&quot;&quot;</span> b树也叫做b-树，或者平衡多路树，它是每个节点最多有m个子树的**平衡树**。一个m阶的b树具有如下几个特征：=<span class="string">&quot;&quot;</span> chengxiao=<span class="string">&quot;&quot;</span> cout&lt;&lt;endl;=<span class="string">&quot;&quot;</span> details=<span class="string">&quot;&quot;</span> from=<span class="string">&quot;&quot;</span> hguisu=<span class="string">&quot;&quot;</span> https:=<span class="string">&quot;&quot;</span> limit=<span class="string">&quot;&quot;</span> m=<span class="string">&quot;&quot;</span> n=<span class="string">&quot;&quot;</span> n个骰子出现和为m的概率=<span class="string">&quot;&quot;</span> p=<span class="string">&quot;&quot;</span> <span class="keyword">return</span>=<span class="string">&quot;&quot;</span> select=<span class="string">&quot;&quot;</span> t1=<span class="string">&quot;&quot;</span> www.cnblogs.com=<span class="string">&quot;&quot;</span> zhuanlan.zhihu.com=<span class="string">&quot;&quot;</span> 一致性哈希=<span class="string">&quot;&quot;</span> 介绍一下b+树和它的应用场景有哪些=<span class="string">&quot;&quot;</span> 介绍一下b树和它的应用场景有哪些=<span class="string">&quot;&quot;</span> 介绍一下红黑树和它的应用场景有哪些=<span class="string">&quot;&quot;</span> 依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为<span class="number">1</span>的就还原该数字。=<span class="string">&quot;&quot;</span> 叶节点的空节点是黑色的。=<span class="string">&quot;&quot;</span> 如果一个节点是红色的，那么它的两个子节点是黑色的。=<span class="string">&quot;&quot;</span> 如果使用<span class="keyword">int</span>型数组的形式来保存的话，一个<span class="keyword">int</span>=<span class="string">&quot;4字节&quot;</span> 它的具体过程是：先根据数组中元素最大的数n计算需要分配多大的空间。=<span class="string">&quot;&quot;</span> 它的性质是这样的：=<span class="string">&quot;&quot;</span> 对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。=<span class="string">&quot;&quot;</span> 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至<span class="number">1</span>时，整个文件恰被分成一组，算法便终止。=<span class="string">&quot;&quot;</span> 应用场景主要是stl中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logn=<span class="string">&quot;&quot;</span> 应用场景主要是数据库的索引=<span class="string">&quot;&quot;</span> 怎么写sql取表的前<span class="number">1000</span>行数据（招银网络二面）=<span class="string">&quot;&quot;</span> 所有的叶子结点都位于同一层。=<span class="string">&quot;&quot;</span> 手撕=<span class="string">&quot;&quot;</span> 查询时间复杂度也是logn=<span class="string">&quot;&quot;</span> 查询时间复杂度是logn=<span class="string">&quot;&quot;</span> 根结点至少有两个子女。=<span class="string">&quot;&quot;</span> 根节点是黑色的。=<span class="string">&quot;&quot;</span> 模拟stl中vector的实现即可，去看一下vector的源码。=<span class="string">&quot;&quot;</span> 每个中间节点都包含至多m个子树=<span class="string">&quot;&quot;</span> 每个节点不是红色就是黑色。=<span class="string">&quot;&quot;</span> 每个节点中的元素从小到大排列，节点当中k<span class="number">-1</span>个元素正好是k个子树包含的元素的值域分划。=<span class="string">&quot;&quot;</span> 每个节点包含的元素个数是其子树个数<span class="number">-1</span>（其中=<span class="string">&quot;&quot;</span> 海量数据的bitmap使用原理=<span class="string">&quot;&quot;</span> 海量数据问题（可参考左神的书）=<span class="string">&quot;&quot;</span> 然后需要推导一个整数a内如何映射<span class="number">32</span>个数据，方法是将待存储的数据模<span class="number">32</span>，然后将a中相应位置的比特置为<span class="number">1</span>。=<span class="string">&quot;&quot;</span> 红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。=<span class="string">&quot;&quot;</span> 红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是<span class="built_in">o</span>(<span class="built_in">log</span>(n))=<span class="string">&quot;&quot;</span> （<span class="number">14</span>）=<span class="string">&quot;&quot;</span> （<span class="number">15</span>）=<span class="string">&quot;&quot;</span> （<span class="number">16</span>）=<span class="string">&quot;&quot;</span> （<span class="number">17</span>）=<span class="string">&quot;&quot;</span> （<span class="number">18</span>）=<span class="string">&quot;&quot;</span> （<span class="number">19</span>）=<span class="string">&quot;&quot;</span> （<span class="number">20</span>）=<span class="string">&quot;&quot;</span> （<span class="number">21</span>）希尔排序说一下=<span class="string">&quot;&quot;</span> （<span class="number">22</span>）dijkstra算法说一下=<span class="string">&quot;&quot;</span> （<span class="number">23</span>）实现一个动态数组要怎么实现，说思路（腾讯teg一面）=<span class="string">&quot;&quot;</span> （<span class="number">24</span>）最小生成树算法说一下=<span class="string">&quot;&quot;</span> （<span class="number">25</span>）=<span class="string">&quot;&quot;</span> ，=<span class="string">&quot;&quot;</span> ：=<span class="string">&quot;&quot;</span>&gt;&gt;<span class="number">5</span>  </span><br><span class="line"></span><br><span class="line">N%<span class="number">32</span>就是求N的后<span class="number">5</span>位：N&amp; <span class="number">0x1F</span>  (<span class="number">0x1F</span> = <span class="number">00011111</span>)  </span><br><span class="line"></span><br><span class="line">模<span class="number">32</span>然后相应位置置为<span class="number">1</span>： a[i] |= <span class="number">1</span>&lt;&lt; N &amp; <span class="number">0x1F</span>  </span><br><span class="line"></span><br><span class="line">所以总的公式为： a[ N&gt;&gt;<span class="number">5</span> ] |= <span class="number">1</span>&lt;&lt; N &amp; <span class="number">0x1F</span>  </span><br><span class="line"></span><br><span class="line">**BitMap算法评价**</span><br><span class="line">* 优点：</span><br><span class="line">    <span class="number">1.</span> 运算效率高，不进行比较和移位；</span><br><span class="line">    <span class="number">2.</span> 占用内存少，比如最大的数MAX=<span class="number">10000000</span>；只需占用内存为MAX/<span class="number">8</span>=<span class="number">1250000B</span>yte=<span class="number">1.25</span>M。</span><br><span class="line">* 缺点：</span><br><span class="line">    <span class="number">1.</span> 所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用<span class="number">2</span>-bitmap）。</span><br><span class="line">    <span class="number">2.</span> 所需要的空间随着最大元素的增大而增大，当数据类似（<span class="number">1</span>，<span class="number">1000</span>，<span class="number">10</span>万）只有<span class="number">3</span>个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</span><br><span class="line"></span><br><span class="line">#### （<span class="number">26</span>） 布隆过滤器原理与优点</span><br><span class="line">布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</span><br><span class="line"></span><br><span class="line">**它的具体工作过程是这样子的：**</span><br><span class="line">假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为<span class="number">1</span>。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为<span class="number">1</span>，如果某一个相应的位不为<span class="number">1</span>，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</span><br><span class="line"></span><br><span class="line">**为什么说有可能存在呢？**</span><br><span class="line">因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到<span class="number">1</span>也可能是由于某个另外的数据映射得到的。</span><br><span class="line"></span><br><span class="line">**支持删除操作吗**</span><br><span class="line">目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为<span class="number">1</span>则计数加一，删除则减一。</span><br><span class="line"></span><br><span class="line">布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为<span class="number">1</span>，如果太少会容易误报。</span><br><span class="line"></span><br><span class="line">**布隆过滤器的大小以及哈希函数的个数怎么选择？**</span><br><span class="line">k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率</span><br><span class="line">![](fig/布隆过滤器.png)</span><br><span class="line">#### （<span class="number">27</span>） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</span><br><span class="line">#### （<span class="number">28</span>）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</span><br><span class="line">```C++</span><br><span class="line"><span class="comment">//评测题目: </span></span><br><span class="line">class FIFOQueue</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; <span class="built_in">vec</span>(initCap,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">condition_variable cv;</span><br><span class="line">mutex m;</span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;<span class="comment">// isFull</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  	unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(flag==<span class="literal">true</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        end=(end+<span class="number">1</span>)%initCap;</span><br><span class="line">        vec[end]=v;</span><br><span class="line">        cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">  	<span class="keyword">if</span>(start!=end)&#123;</span><br><span class="line">    	<span class="keyword">int</span> val = vec[start];</span><br><span class="line">    	start=(start+<span class="number">1</span>)%initCap;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">    	cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	flag=<span class="literal">false</span>;</span><br><span class="line">    	cv.<span class="built_in">notifyall</span>();</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 以上代码是面试时写的，并没有运行，也许有错误，请客观参考 # 7. 智力题 #### （1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题） * （给定了楼层数和鸡蛋数的情况）二分法+线性查找 从100/2=50楼扔起，如果破了就用另一个从0扔起直到破。如果没破就从50/2=25楼扔起，重复。 * 动态规划 #### （2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠 用二进制的思路解决问题。2的十次方是1024，使用十只小鼠喝一次即可。方法是先将每瓶水编号，同时10个小鼠分别表示二进制中的一个位。将每瓶水混合到水瓶编号中二进制为1的小鼠对应的水中。喝完后统计，将死亡小鼠对应的位置为1，没死的置为0，根据死亡小鼠的编号确定有毒的是哪瓶水，如0000001010表示10号水有毒。 #### （3） #### （4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿 寻找每个回合固定的拿取模式。最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。关键是第一次我必须先手拿（100%6=4）本（这不算在第一回合里面）。 #### （5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。 碰到就当没发生，继续走，相当于碰到的两个蚂蚁交换了一下身体。其实就是每个蚂蚁从当前位置一直走直到停止的总距离或者时间。 #### （6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶 拿走3瓶，换回1瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4=996，996/2=498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1=1499瓶。 #### （7）在24小时里面时针分针秒针可以重合几次 24小时中时针走2圈，而分针走24圈，时针和分针重合24-2=22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次 #### （8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？ 至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个； 第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个； #### （9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？ 砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组 #### （10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？ 思路：由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。 记住下面这个式子： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandNN= N( RandN()-1 ) + RandN() ;// 生成1到N^2之间的随机数</span><br><span class="line">可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度，RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙</span><br></pre></td></tr></table></figure> 比如<code>Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3<em>7）之间的数字，所以可以这么写 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int rand7()&#123;</span><br><span class="line">  int x=INT_MAX;</span><br><span class="line">  while(x&gt;21)&#123;</span><br><span class="line">    x=5*(rand5()-1)+rand5();</span><br><span class="line">  &#125;</span><br><span class="line">  return x%7+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？ </em> 第一次，分成5个赛道ABCDE，每个赛道5匹马，每个赛道比赛一场，每个赛道的第12345名记为 A1,A2,A3,A4,A5 B1,B2,B3,B4,B5等等，这一步要赛5场。 * 第二次，我们将每个赛道的前三名，共15匹。分成三组，然后每组进行比赛。这一步要赛3场。 * 第三次，我们取每组的前三名。共9匹，第一名赛道的马编号为1a,1b,1c，第二名赛道的马编号为2a,2b,2c，第三名赛道的马编号为3a,3b,3c。这时进行分析，1a表示第一名里面的第一名，绝对是所有马中的第一，所以不用再比了。2c表示第二名的三匹里头的最后一匹，3b和3c表示第三名里面的倒数两匹，不可能是所有马里面的前三名，所以也直接排除，剩下1b,1c,2a,2b,,3a，共5匹，再赛跑一次取第一第二名，加上刚筛选出来的1a就是所有马里面的最快3匹了。这一步要赛1场。 * 所以一共是5+3+1=9场。 #### 烧 香/绳子/其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？ （说了求15分钟，没说开始的15分钟还是结束的15分钟，这里是可以求最后的15分钟）点燃一根A，同时点燃另一根B的两端，当另一根B烧完的时候就是半小时，这是再将A的另一端也点燃，从这时到A燃烧完就正好15分钟。</p>
<h4 id="掰巧克力问题-nm块巧克力每次掰一块的一行或一列掰成11的巧克力需要多少次1000个人参加辩论赛1v1输了就退出需要安排多少场比赛">掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</h4>
<p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N*M块，所以要掰N*M-1次，-1是因为最开始的一块是不用算进去的。</p>
<p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1=999场。 # 8. 大数据 #### 1. 介绍一下Hadoop Hadoop是一套大数据解决方案，提供了一套分布式的系统基础架构，包括HDFS，MapReduce和YARN。 * HDFS提供分布式的数据存储 * MapReduce负责进行数据运算 * YARN负责任务调度</p>
<p>HDFS是主从架构的，包括namenode，secondarynamenode和datanode。datanode负责存储数据，namenode负责管理HDFS的目录树和文件元信息。</p>
<p>MapReduce包括jobtracker,tasktracker和client。Jobtracker负责进行资源调度和作业监控。tasktracker会周期性的通过心跳向jobtracker汇报资源使用情况。 #### 2. 说一下MapReduce的运行机制 MapReduce包括输入分片、map阶段、combine阶段、shuffle阶段和reduce阶段。分布式计算框架包括client，jobtracker和tasktracker和调度器。 * 输入分片阶段，mapreduce会根据输入文件计算分片，每个分片对应一个map任务 * map阶段会根据mapper方法的业务逻辑进行计算，映射成键值对 * combine阶段是在节点本机进行一个reduce，减少传输结果对带宽的占用 * shuffle阶段是对map阶段的结果进行分区，排序，溢出然后写入磁盘。将map端输出的无规则的数据整理成为有一定规则的数据，方便reduce端进行处理，有点像洗牌的逆过程。 https://blog.csdn.net/ASN_forever/article/details/81233547 * reduce阶段是根据reducer方法的业务逻辑进行计算，最终结果会存在hdfs上。</p>
<h4 id="介绍一下kafka">3. 介绍一下kafka</h4>
<p>https://blog.csdn.net/qq_29186199/article/details/80827085</p>
<p>https://blog.csdn.net/student__software/article/details/81486431</p>
<p>kafka是一个分布式消息队列，包括producer、broker和consumer。kafka会对每个消息根据topic进行归类，每个topic又会分成多个partition，消息会根据先进先出的方式存储。消费者通过offset进行消费。</p>
<p>kafka的特点是吞吐量高，可以进行持久化，高可用。 #### 4. 为什么kafka吞吐量高？/介绍一下零拷贝 kafka吞吐量高是因为一个利用了磁盘顺序读写的特性，速度比随机读写要快很多，另一个是使用了零拷贝，数据直接在内核进行输入和输出，减少了用户空间和内核空间的切换。</p>
<p>零拷贝：传统文件读取并发送至网络的步骤是：先将文件从磁盘拷贝到内核空间，然后内核空间拷贝到用户空间的缓冲区，再从用户空间拷贝到内核空间的socket缓冲区，最后拷贝到网卡并发送。而零拷贝技术是先将文件从磁盘空间拷贝到内核缓冲区，然后直接拷贝至网卡进行发送，减少了重复拷贝操作。 #### 5. 介绍一下spark https://blog.csdn.net/u011204847/article/details/51010205</p>
<p>spark是一个通用内存并行计算框架。它可以在内存中对数据进行计算，效率很高，spark的数据被抽象成RDD（弹性分布式数据集）并且拥有DAG执行引擎，兼容性和通用性很好。可以和Hadoop协同工作。 #### 6. 介绍一下spark-streaming https://blog.csdn.net/yu0_zhang0/article/details/80569946</p>
<p>spark-streaming是spark的核心组件之一。主要提供高效的流计算能力。spark-streaming的原理是将输入数据流以时间片进行拆分，然后经过spark引擎以类似批处理的方式处理每个时间片数据。</p>
<p>spark-streaming将输入根据时间片划分成一段一段的Dstream（也就是离散数据流），然后将每一段数据转换成RDD进行操作。</p>
<h4 id="spark的transformation和action有什么区别">7. spark的transformation和action有什么区别</h4>
<p>spark的算子分成transformation和action两类 * transformation是变换算子，这类算子不会触发提交，是延迟执行的。也就是说执行到transformation算子的时候数据并没有马上进行计算，只是记住了对RDD的逻辑操作 * action算子是执行算子，会出发spark提交作业，并将数据输出到spark #### 8. spark常用的算子说几个 spark的算子分为两类：transformation和action</p>
<p>常用的transformation算子： <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// union 求并集</span></span><br><span class="line"><span class="keyword">val</span> rdd8 = rdd6.union(rdd7)</span><br><span class="line"></span><br><span class="line"><span class="comment">// intersection 求交集 </span></span><br><span class="line"><span class="keyword">val</span> rdd9 = rdd6.intersection(rdd7)</span><br><span class="line"></span><br><span class="line"><span class="comment">// join 将rdd进行聚合连接，类似数据库的join </span></span><br><span class="line"><span class="keyword">val</span> rdd3 = rdd1.join(rdd2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// map flatMap mapPartition 传入一个函数对数据集中的每一个数据进行操作 </span></span><br><span class="line"><span class="keyword">val</span> arr1 = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> arr2 = rdd1.map(_+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// countByKey reduceByKey partitionByKey 统计每个key有多少个键值对 </span></span><br></pre></td></tr></table></figure> 常用的action算子 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce 按照一定的方法将元素进行合并 </span></span><br><span class="line"><span class="keyword">val</span> rdd2 = rdd1.reduce(_+_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// collect 将RDD转换为数组</span></span><br><span class="line">rdd1.collect</span><br><span class="line"></span><br><span class="line"><span class="comment">// top 返回最大的k个元素</span></span><br><span class="line">rdd1.top(<span class="number">2</span>)</span><br></pre></td></tr></table></figure> #### 9. 如何保证kafka的消息不丢失 https://blog.csdn.net/liudashuang2017/article/details/88576274</p>
<p>我们可以从三个方面保证kafka不丢失消息 * 首先从producer生产者方面，为send()方法注册一个回调函数，可以得知消息发送有没有成功；将重试次数retrie设置为3；设置acks参数为all，当消息被写入所有同步副本之后才算发送成功。 * 在consumer消费者方面，关闭自动提交； * 在broker集群方面，设置复制系数replica.factor为大于等于3 #### 10. kafka如何选举leader 首先启动的broker在zookeeper中创建一个临时节点并让自己称为leader，其他的节点会创建watch对象进行监听并成为follower，当broker宕机的时候，其他follower会尝试创建这个临时节点，但是只有一个能够创建成功，创建成功的broker就会成为leader。</p>
<h4 id="说下spark中的宽依赖和窄依赖">11. 说下spark中的宽依赖和窄依赖</h4>
<p>https://blog.csdn.net/a1043498776/article/details/54889922</p>
<ul>
<li>宽依赖：指子RDD的分区依赖于父RDD的所有分区，举例：groupbykey,join</li>
<li>窄依赖：指父RDD的每个分区被最多一个子RDD的分区所依赖,举例：map，filter <img src="https://img-blog.csdn.net/20170206221148299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEwNDM0OTg3NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /> #### 12. 说下spark中stage是依照什么划分的 https://zhuanlan.zhihu.com/p/57124273</li>
</ul>
<p>spark中的stage其实是一组并行的任务，spark会将多个RDD根据依赖关系划分成有向无环图DAG，DAG会被划分成多个stage，划分的依据是RDD之间的宽窄依赖。遇到宽依赖就划分stage。因为宽依赖与窄依赖的区别之一就是宽依赖会发生shuffle操作，所以也可以说stage的划分依据是是否发生shuffle操作。</p>
<h4 id="spark的内存管理是怎样的">13. spark的内存管理是怎样的</h4>
<p>https://www.jianshu.com/p/4f1e551553ae</p>
<p>https://www.cnblogs.com/wzj4858/p/8204282.html</p>
<p>spark的内存包括静态内存管理和统一内存管理两种机制。静态内存管理中存储和执行两块内存区域是分开的，统一内存管理中两块内存之间可以相互借用</p>
<ul>
<li>静态内存管理：静态内存管理机制下堆内内存包括安全内存，存储内存，shuffle内存和unroll内存</li>
</ul>
<p><img src="fig/spark内存一.png" /> * 统一内存管理：统一内存管理机制下内存分为spark内存，用户内存和保留内存三部分。用户内存存放用户代码逻辑和自定义数据结构等，保留内存存放的是spark的内部对象和逻辑。 <img src="https://upload-images.jianshu.io/upload_images/195230-f119edabb5683f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" /></p>
<h4 id="spark的容错机制是什么样的">14. spark的容错机制是什么样的</h4>
<p>https://blog.csdn.net/dengxing1234/article/details/73613484</p>
<p>spark的容错机制是通过血统（lineage）和checkpoint来实现的 。</p>
<ul>
<li>RDD的lineage可以看作是一个重做日志（redo log）记录的是它粗粒度上的transformation操作。当rdd的分区数据丢失时，它可以根据lineage重新计算来恢复数据。 在窄依赖上可以直接计算父RDD的节点数据进行恢复，在宽依赖上则要等到父RDD所有数据计算完后并将结果shuffle到子RDD上才能完成恢复。</li>
<li>如果DAG中的lineage过长，或者在宽依赖上进行checkpoint的收益更大，就会使用checkpoint进行容错，将RDD写入磁盘进行持久化存储，如果节点数据丢失，就从磁盘读取数据进行恢复。</li>
</ul>
<h1 id="hr面">9. HR面</h1>
<h4 id="自我介绍">1. 自我介绍</h4>
<p>（HR面试的自我介绍可以侧重软实力部分，项目技术方面介绍可以适当少一些） #### 2. 项目中遇到的最大难点 * 在项目中曾经遇到了新的框架不知道该如何上手的问题，以及面对新的概念，新的技术不知道从何学起。解决的办法是在官网寻找说明文档和demo，按照说明文档上的内容一步步了解，以及咨询身边有用过这个框架的同学，或者在CSDN上寻找相关博客。</p>
<ul>
<li>项目的时间比较紧迫，没有那么多的时间可以用。解决方法是把还没有完成的项目分一个轻重缓急，在有限的时间里，先做重要而且紧急的，然后完成紧急的，再做重要的。利用轻重缓急做一个取舍。 #### 3. 项目中的收获 一个是了解了相关框架的使用方法（比如Dataframe的使用，xgboost的使用等等），这些框架或者技术可以在以后的开发中使用到。和对自己开发能力的锻炼。</li>
</ul>
<p>一个是锻炼了与他人的交流能力，因为在团队项目里经常会跟别人汇报自己的想法和进度，同时也会跟其他成员沟通模块之间的交互，所以在这个过程中对自己的表达能力和理解能力都是一个很大的提升。 #### 4. 可以实习的时间，实习时长 一定要往长了说！半年起步，最好七八个月，因为实习生是可以随时跑路的。而且实习时间越长HR越青睐。 #### 5. 哪里人 #### 6. 说一下自己的性格 我是比较内向谨慎的人，平时做的多说的少。比较善于总结，在与人交流的时候更倾向于倾听别人的意见后才发言。并且别人都说我办事认真靠谱。 #### 7. 你的优缺点是什么 我的缺点是容易在一些细节的地方花费太多的时间，有时候过分追求细节。并且我的实习经验比较缺乏，对于实际项目的业务流程和工作流程不是很了解。（所以我打算通过实习来熟悉实际的软件开发的流程和技术。）</p>
<p>我的优点是责任心比较强，做事比较负责，在校期间我负责的大创项目进展很顺利，我经常组织组员们进行讨论和推进项目的开发，最后这个项目得到了92的评分，在同级别里面是比较高的。 #### 8. 有什么兴趣爱好，画的怎么样/球打的如何/游戏打的怎么样 平时的爱好是画画打游戏，在CSDN写写博客，还有就是看书，我很喜欢学到新知识掌握新技能的感觉。 #### 9. 看过最好的一本书是什么 技术类：编程之美 机器学习西瓜书 STL源码剖析 剑指offer C++primer plus</p>
<p>非技术类：明朝那些事儿 香水（聚斯金德） 解忧杂货店 人类简史 沉默的大多数 与时间做朋友（李笑来） 千年历史千年诗 #### 10. 学习技术中有什么难点 #### 11. 怎么看待加班 我觉得 任何一家单位都有可能要加班。如果自己的工作没有按时完成，那自觉加班是理所当然的，当然，自己要不断提高工作效率，避免这种原因导致的加班。如果遇到紧急任务或者突发状况时，为了顺利配合团队完成任务，我会尽自己所能加班共同完成。 #### 12. 觉得深圳怎么样（或者其他地点） #### 13. 遇见过最大的挫折是什么，怎么解决的</p>
<h4 id="职业规划">14. 职业规划</h4>
<p>在工作的第一个阶段，先尽快适应工作的环境，包括开发环境开发工具和工作流程等，把自己负责的部分快速的完成，不能出差错。第二个阶段要熟悉整个项目的业务流程，所有模块的结构和依赖关系，知道每个模块为什么要这么设计，以及它们的实现细节。第三个阶段要培养独立设计一个项目的能力，可以独立或者在别人的协作下设计项目的模块分工和架构。</p>
<p>在工作和项目中多写博客或者笔记，积累技术影响力，将经验总结成文档。同时与同事搞好关系，尝试培养领导能力和组织能力。</p>
<h4 id="目前的offer情况">15. 目前的offer情况</h4>
<p>可以如实说 #### 16. 你最大的优势和劣势是什么 * 优势：做事情有主动性，不拖沓，有责任心。举个例子：在做论文课题的时候，几乎都是我自己找老师汇报进度和找老师讨论问题，很少有被老师催的时候。每一次跟老师讨论之后都会将讨论的内容和老师提出的意见进行详细记录。在中软杯的比赛中，主动承担答辩ppt的制作，并且每次排练之后都迅速对ppt的修改意见进行落实修改，前前后后改了十几版。 * 劣势：有时候做事情比较急躁，容易导致粗心。 #### 17. 介绍在项目里面充当的角色 #### 18. 介绍一下本科获得的全国赛奖项的情况 #### 19. 最有成就感的事情/最骄傲的一件事情 * 本科的时候跟优秀的队友们一起参加中国软件杯比赛努力了四个月，最后获得了该赛题的第一名和全国一等奖的好成绩 * 保研夏令营拿到了四个学校的offer #### 20. 在实验室中担任什么角色，参加的XXX能聊聊吗 #### 22. 用两个词来形容自己 踏实 认真</int>&lt;/item&lt;&lt;"&gt;</string></string></string></string></queue></vector></iostream></node>&lt;/len;i++){&gt;&lt;/endl;&gt;</int></len></int></int></vector></iostream>&lt;/end)&gt;&lt;/end){&gt;</int>&lt;/endl;&gt;&lt;/endl;&gt;&lt;/endl;&gt;</mutex></condition_variable></mutex></thread></iostream>&lt;/int,int&gt;&lt;/pair&lt;int,int&gt;&lt;/pair&lt;int,int&gt;&lt;/int,list&lt;pair&lt;int,int&gt;&lt;/pair&lt;int,int&gt;&lt;/pair&lt;int,int&gt;&lt;/int,list&lt;pair&lt;int,int&gt;&lt;/a.data&lt;&lt;endl;}&gt;</iostream></iostream></typename>&lt;/stdio.h&gt;&lt;/sizeof(a)&lt;&lt;endl;&gt;&lt;/sizeof(a)&lt;&lt;endl;&gt;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2021/11/23/Where%20to%20go%20and%20What%20to%20do/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/23/Where%20to%20go%20and%20What%20to%20do/" class="post-title-link" itemprop="url">Where to go and What to do</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-23 06:44:00" itemprop="dateCreated datePublished" datetime="2021-11-23T06:44:00+08:00">2021-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近几周一直在下雨，天气也转凉的很快，而我则过得很低落，心情郁闷，即便做好了计划还是啥也不想干，工作生活混乱且没有任何心劲，唯一比较开心的就是晚上和欣儿聊会天~但是她有时候也不是特别懂我的感受</p>
<p>造成上述现象的原因很多也很凌乱，我试着列一下吧： 1. 被傻逼小老板打了小报告，整天给她搬砖反倒被她捅了一刀，心里很不爽，本来就不想科研，这下更不想弄了。容我再说一句，zxy yydsb 2. 投出去的论文感觉大概率会被拒掉，而且有的补充材料没有提交，心里一直没底，被拒一定会影响自己的后续工作学习安排，还tmd被狗日的zxy抢了一作 3. 整个互联网的大环境在变差，竞争更加激烈，十分担心自己忍受不了这种高压残酷的工作环境，而且算法岗更加惨烈，也没什么出彩的简历，也不知道将来到底要干啥工作 4. 浙大的哥们也和我每天吐槽都是负能量爆棚的事情，日常看不到积极的因素 5. 西交的这帮傻逼们（从学校到学院再到老师同学）为什么都这么奇葩呢？我觉得自己现在也跟傻逼一样... 6. 要自学的东西太多了，算法题也做不出来，项目也进展不动，论文也看不进去，被湮没了 7. 想要做手术但是不知道有没有时间和陪我的人，还要花钱，这手术tmd还相当尴尬... 8. 想抓紧时间找个npy去make love，释放下欲望，一直tmd没有进展，也不知道要不要等赵欣考完研再去表白 9. 回家了几次，发现tmd农民真的太可怜了，干着最贱的活拿着最少的钱，zf不知道咋搞的。而且一出生条件就比别人差，以后买房娶妻啥的都很社会很残酷，当然我并没有埋怨父母，我父母都很伟大 10. 自己也不会social，平时能深入交流的朋友也很少，整的都快孤僻了 11. 天气边变冷了，最近也很少运动了，可能也有影响吧 12. 性格也比较弱势，还是说佛系，总之在涉及利益的事情上不够上进，不够自私，因此也经常吃亏吧，这样估计工作了就是背锅侠（只知道闷头干活，却忘了漂亮地展示自己和斗争取得属于自己的利益）...但是也不知道是好是坏 13. 表达沟通能力也比较欠缺（面对面时也说不清楚事情），容易紧张，面试肯定吃亏，屁大点事都会睡不着觉 14. 脸上不知道咋回事长了一堆痘，很长时间也下不去，烦啊 15. 还有二战的一年还不知道找工作影响咋样，怎么解释呢</p>
<p>尽量不要想着回宿舍学习，尤其是在实验室晚上比较累的时候，可以听会歌放松一下，然后继续在实验室学习</p>
<p>不想过得太累，那就索性不要有什么压力，该做什么就做什么，随缘随喜好</p>
<p>做梦装逼： 尘埃落定，要去Google Singapore啦！ 感谢晨光和Google Sydney修唯学长的内推，感谢胡神、聪爷、经纬哥和晨光不厌其烦的mock，当然还有佳薇姐精心的coordinate~ 坦白说，在西交的这几年过得不怎么开心，个中滋味，只有自己清楚，也希望换个环境会有所改善吧~ 坡县见啦~</p>
<p>如果长时间艳羡别人的生活，我指的不是真心祝福交流，而是向往，想去往那里，这是一个危险的信号。这意味着你对自己的生活状态很不满意，意味着焦虑不安，意味着对自己的目标产生了怀疑，这时候就要停下来认真思考：yes or no 如果no那么就要重新确定目标，否则就完全没必要走入羡慕他人的状态，因为你坚信自己做的事情是内心真正想要的，对自己的目前生活状态就会保持自信，还有什么比追求内心更加美妙的事情吗？ 那么我呢？我并不怀疑自己的目标，因此应当对自己目前的状况感到自信，我正在攀登！</p>
<p>努力学习，冲！</p>
<p>还是有进步的，以前老想着完成任务，将自己的简历变丰富。现在更注重培养自身对于课程内容的思考，更关注自己的创造性工作或者自己亲手的实现，更关注自己的理解见解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2021/11/23/Wilcoxon%20signed-rank%20test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/23/Wilcoxon%20signed-rank%20test/" class="post-title-link" itemprop="url">Wilcoxon signed-rank test</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-23 06:33:00" itemprop="dateCreated datePublished" datetime="2021-11-23T06:33:00+08:00">2021-11-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="motivation">Motivation</h2>
<p>Wilcoxon符号秩检验是一种非参数检验方法（总体没有高斯分布），t检验貌似要数据服从高斯分布。</p>
<p>具体是这么操作的： 假如有两组数据<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>需要检验对比：<span class="math inline">\((X_i,Y_i)\)</span>首先被转为差值<span class="math inline">\(X_i-Y_i\)</span>，记为<span class="math inline">\(Z_i\)</span>，假设<span class="math inline">\(Z_i\neq 0\)</span>且绝对值均不等： 1. 计算<span class="math inline">\(|Z_i|\)</span> 2. 将<span class="math inline">\(|Z_i|\)</span>排序得排序后的索引<span class="math inline">\(R_i\)</span> 3. 检验统计量<span class="math inline">\(T=\sum sgn(Z_i)R_i\)</span> 4. 通过对比<span class="math inline">\(T\)</span>和原假设下的分布求出p值</p>
<p>如果存在<span class="math inline">\(Z_i=0\)</span>，有几种处理方法： 1. <code>zero_method="wilcox"</code>：忽略所有等于0的数据 2. <code>zero_method="pratt"</code>：排序时考虑为0的项，排完后扔掉这些0项的秩 3. <code>zero_method="zsplit"</code>：</p>
<h2 id="refs">Refs</h2>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test">Wilcoxon signed-rank test</a> <a target="_blank" rel="noopener" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wilcoxon.html">scipy.stats.wilcoxon</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2021/11/12/CS144%20Lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/12/CS144%20Lab/" class="post-title-link" itemprop="url">CS144 Lab</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-12 12:49:00" itemprop="dateCreated datePublished" datetime="2021-11-12T12:49:00+08:00">2021-11-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://cs144.github.io/">Introduction to Computer Networking</a>是Stanford的网络课，据说lab质量很高，就把它作为转System后的第一个小系统吧！</p>
<h2 id="准备工作">准备工作</h2>
<p>Stanford大气！能让我们这些野鸡学校的同学接触到最顶级的教育资源，甚至开放了lab，也希望大伙不要把题解po到github上！</p>
<p>因此我做的是Fall 2021的版本，所有的starter code都在<a target="_blank" rel="noopener" href="https://github.com/CS144/sponge">这里</a>。</p>
<p>至于如何在自己的github上备份代码，参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10065526/github-how-to-make-a-fork-of-public-repository-private">这里</a>。</p>
<p>虚拟机平台用的是VirtualBox，144官方提供了基于Ubuntu的系统镜像，CPU和RAM随便设。</p>
<p>大致按照<a target="_blank" rel="noopener" href="https://stanford.edu/class/cs144/vm_howto/">官方文档</a>配置环境，windows环境可以用powershell，无需<a target="_blank" rel="noopener" href="https://putty.org/">Putty</a>。 开启虚拟机，通过ssh client建立TCP连接到远程主机的某端口：<code>ssh user@remote -p port</code>，<code>user</code>是在远程主机的用户名，<code>remote</code>是远程机器的地址（IP/域名），<code>port</code>是ssh server监听的端口，默认22（即登录请求会送进远程主机的22端口），上面通过-p参数改变了该端口。</p>
<p>不过遇到了点问题： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211103183846716-1107297673.png" alt="image" /> 奇怪！远程虚拟机明明安装了ssh服务!</p>
<p>从主机去ping虚拟机超时，但是虚拟机可以ping通主机，参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mengjie88/p/11803879.html">这个设置</a>成功ping通，后来发现国内的这些blog都是在胡说八道，真正的原因和解决方案在<a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/145997/trying-to-ssh-to-local-vm-ubuntu-with-putty">这里</a>，本质上是虚拟机的端口转发没设置好，设置好后VB会把连接localhost:2222的TCP请求转发到虚拟机的22号端口。</p>
<p>关于IDE，开始用的VIM，后来想用vscode，Host上安装vscode以及remote-ssh插件，关于配置网上一大堆教程，自行学习吧，powershell以后就负责编译运行了。</p>
<h2 id="lab-0">Lab 0</h2>
<h3 id="networking-by-hand">Networking by hand</h3>
<p>这些小游戏都是为了翻译翻译：什么是可靠的双向字节流，网络通过这种抽象完成许多重要的交互，如上网冲浪、发邮件等。</p>
<p>第一个事是要手动模拟浏览器的请求过程（注意手速，不然还没输完就408 Timeout了）： 1. <code>telnet cs144.keithw.org http</code>：<code>telnet</code>作为一种client程序，负责和服务器的某个服务建立连接。用telnet客户端程序在本机和服务器之间开一个可靠的字节流，并请求服务器的http服务（80端口），连接成功证明端口可用 2. 建立连接后就要通过HTTP协议请求内容：需要告诉服务器所请求URL的path和host：<code>GET /hello HTTP/1.1</code> <code>Host: cs144.keithw.org</code>，不过为啥需要host呢？难道服务器不知道自己的ip吗，好像是因为服务器可以同时运行多个网站/服务 3. <code>Connection: close</code>：表示希望服务器一旦完成响应，就关闭连接 4. 输入回车（空行）：表示HTTP请求头结束，接下来是请求数据（当然GET没有，POST有）</p>
<p>其实这就是一个HTTP请求报文，效果： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211104155702139-1679706369.png" alt="image" /> 作业就是瞎玩： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211104215913218-403717095.png" alt="image" /></p>
<p>第二个事是学着发邮件，请求服务器的SMTP服务（主要用来发邮件），我试试和自己的邮箱互动下： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211106090516675-391035638.png" alt="image" /> 这里要注意：首先要开启IMAP/SMTP服务，还需要获取第三方客户端登录的授权码，登录时邮箱名称和授权码都需要Base64格式。</p>
<p>文档里说From地址是可以伪造的，有点神奇，垃圾邮件可能挺喜欢干这事！但是我实际操作时是伪造不了的： <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211106091008967-598610443.png" alt="image" /> 因为已经登录了本人账户，所以发件人必须一致，Stanford那个没有登录，也许是商业邮件系统一般都比较完善？</p>
<p>第三个事是作为服务器去监听，主要使用所谓的瑞士军刀netcat： <code>netcat -v -l -p 9090</code>：-v表示显示执行命令过程，-l表示开启监听，-p表示在指定端口监听 <code>telnet localhost 9090</code>： 然后服务器（netcat）和客户端（telnet）就可以通信啦！</p>
<h3 id="network-program-using-an-os-stream-socket">Network program using an OS stream socket</h3>
<p>这部分让同志们利用操作系统内核提供的stream socket从Internet上抓网页，和上文中手动抓差不多，不过这次是把手动过程写成代码。</p>
<p>由于Internet只能提供尽最大努力交付的数据报服务，因此这些数据报可能会：丢失、乱序、内容更改、重复，所以通常OS会把Internet的这种抽象转为可靠的双向字节流，以便应用层软件使用。OS一般使用socket来完成这种转变并向程序员提供接口，socket和文件描述符类似，一旦建立连接就能进行可靠的通信。后续会自己实现一个TCP去揣摩这种转变。</p>
<p>这个简单的web client程序有几个要注意的地方： 1. 由于<code>connection: close</code>，因此服务器只会处理一次http请求 2. 服务器响应后就会关闭从server到client的socket连接，但是client的<code>socket.read()</code>可以持续读：If the connection is broken on a stream socket, but data is available, then the read() function reads the data and gives no error. If the connection is broken on a stream socket, but no data is available, then the read() function returns 0 bytes as EOF. 3. EOF一般是一个定义为-1的宏，因此没有对应的ASCII字符，因此也无法显示出来（可以强制转int），C语言将其定义在某个头文件的宏里（可以直接用EOF判断），C++一般使用函数判断。EOF的作用就是client可以判断是否读完了server发来的响应，终端输入windows环境是ctrl+Z，linux是ctrl+D 4. 为什么一个<code>read()</code>不够呢？因为<code>read()</code>是有limit的，超过上限就得多次读，<code>std:string FileDescriptor::read(const size_t limit=std::numeric_limits&lt;size_t&gt;::max())</code> 5. 及时关掉socket的写功能是一个<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4160347/close-vs-shutdown-socket">好习惯</a></p>
<figure>
<img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211207143452338-2049325007.png" alt="" /><figcaption>image</figcaption>
</figure>
<h3 id="an-in-memory-reliable-byte-stream">An in-memory reliable byte stream</h3>
<p>在单机上实现一个可靠的字节流（内存里当然是可靠的），writer可以结束字节流输入，reader读到EOF后就无法继续读。 基本可以理解为一个容量为<code>capacity</code>的buffer，<code>capacity</code>用来进行流量控制，文档说了只会进行单线程操作，因此不用担心并发的读/写。 需要注意：流本身可以无限长，<code>capacity</code>存储的是已经写入但还未读取的字节，哪怕<code>capacity = 1</code>，只要writer每次写入一个字节，reader读走，这个流就可以无限长。</p>
<p>开始想用<code>queue</code>，但是<code>queue</code>无法支持<code>peek_output</code>操作，那就用<code>deque</code>了。 <code>size_t write(const std::string &amp;data)</code>：如果长度大于<code>capacity</code>该如何处理？这种情况多余的写入只能被丢弃，就和网络上超出线路容量的写入被丢弃一样。 <code>size_t bytes_read() const</code>返回的是所有pop的字节数目，包括<code>read(const size_t len)</code>和<code>pop_output(const size_t len)</code>。 <code>bool input_ended() const</code>返回流输入是否结束；<code>bool eof() const</code>是reader判断是否读取到了流输出的结束位置，因此必须满足writer已经有过写入且buffer为空。</p>
<p>记得先<code>make format</code>，再<code>make</code>编译，最后<code>make check_lab0</code>自动化测试。</p>
<h2 id="lab-1">Lab 1</h2>
<p>接下来的4个lab要自行实现一个TCP，模块如下： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211207210801604-1226780700.png" alt="image" /></p>
<p>由于sender会将发送的字节流分割为若干segments，每段不超过1460B，封装为数据报交给网络传送，但这些segments可能会乱序、丢失、重复、交叉重叠、长度不一，但是不会出现inconsistent的段，因此Lab 1要实现一个流重组器，将收到的字节流中的segments拼接还原为其原本正确的顺序。</p>
<p><code>StreamReassembler</code>会用一个可靠字节流<code>ByteStream</code>作为输出：as soon as the reassembler knows the next byte of the stream, it will write it into the <code>ByteStream</code>. 接着应用层就可以从<code>ByteStream</code>读取有序的字节流。<code>StreamReassembler</code>和<code>ByteStream</code>的容量大小是一样的，不过<code>ByteStream</code>真正的size（绿色部分）是动态变化的。</p>
<p><code>push_substring(const string &amp;data, const uint64_t index, const bool eof)</code>一旦超出<code>StreamReassembler</code>的容量，就只能丢弃该碎片（或者丢弃部分）； <img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211118103108010-1947303917.png" alt="image" /> 根据上图：可以想象为我们拥有一条index从0开始的无限长的字节流，每个段都有自己在流中的位置，随着应用层读取流中的数据，<code>StreamReassembler</code>就像一个滑动的窗口，落在该窗口内的段都需要被按序组装。</p>
<p>显然，需要用某种数据结构把不能直接写入<code>ByteStream</code>中的segments存起来：<strong>data+index</strong>即可唯一确定，因此单个segment可以用类、结构体或<code>std::pair</code>存储，为了方便起见，在segment结构体中增加成员变量<code>len</code>来指示其有效长度。 由于可能需要根据index快速查找合并位置，因此最好按序存储，并且自动去重，所有不能写入的segments可以用<code>std::set</code>来存，底层基于红黑树实现。</p>
<p>处理逻辑： 1. 新来段是否超出/部分超出了<code>StreamReassembler</code>的窗宽，如超过则进行剪切； 2. 新来段是否和<code>ByteStream</code>之前（蓝色+绿色部分）有重叠，如有则切除重叠部分； 3. 合并新段和暂存段：确定新段插入位置，不断将其前后的暂存段往新段上合并，直到找不到可以继续合并的暂存段； 4. 判断能否写入<code>ByteStream</code>； 5. <strong>处理后</strong>新段的eof为true：<del>若暂存区为空，结束向<code>ByteStream</code>的写入</del>结束写入的时机可能会导致潜在bug，后面有血泪教训；若暂存区非空，<del>报错</del>，可能是last segment先到达但还不能写入，因此存入暂存区。</p>
<p>根据上述逻辑准备用3个函数完成： 1. <code>void _cut_overlap(segment &amp;seg);</code>完成12 2. <code>void _merge_segs(segment &amp;seg);</code>完成3 3. <code>void _write_to_stream();</code>完成4 4. 直接在<code>push_substring()</code>处理5</p>
<p>这个实验一般就会开始出bug，我直接跪在了corner case，来了一个eof为<code>true</code>的<code>""</code>，空串是要被忽略的，但是这个空串带了我们需要的eof信息，由于在<code>_cut_overlap</code>直接返回： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (seg.index &gt;= _first_unacceptable || seg.index + seg.len &lt;= _first_unassembled) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure> 所以没有正确设置<code>_eof</code>： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211211135443937-770319647.png" alt="image" /> 测试样例<code>t_strm_reassem_single</code>报错，所有的测试源码都在<code>./tests</code>文件夹下，对应的可执行程序在<code>./build/tests</code>。 <code>sudo apt-get install gdb</code>安装GDB，找到对应的测试源码文件<code>fsm_stream_reassembler_single.cc</code>打断点开始调试，跳出<code>launch.json</code>稍作修改就可以愉快地debug（面向测试编程😂）了： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;sponge debug&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/tests/$&#123;fileBasenameNoExtension&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: g++-8 build active file&quot;,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后来第7个样例一直过不了，而且Byte Stream实际读取的字节数和真实值差距很大： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211212162034900-680357364.png" alt="image" /></p>
<p>怀疑是提前<code>end_input()</code>了，主要是下面这种case： first unassembled=7且first unacceptable很大，先来一个<code>index=9, eof=true</code>的""，再来一个<code>index=7, eof=false</code>的"ab"，如果这样判断： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_eof &amp;&amp; _unassembled_bytes == <span class="number">0</span>) &#123;</span><br><span class="line">    _output.<span class="built_in">end_input</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 很容易在第一个段就<code>end_input()</code>导致提前结束写入。 因此核心问题在于什么时候调用<code>end_input()</code>，我用了<code>_eof_index</code>来指示结束的位置而非用布尔变量<code>_eof</code>，一旦<code>_first_unassembled &gt;= _eof_index</code>就结束输入。 ## Lab 2 Lab 2要实现<code>TCPReceiver</code>，将从Internet接收的segments送入<code>StreamReassembler</code>转为可靠的<code>ByteStream</code>，以供应用层从socket读取。 除此之外，<code>TCPReceiver</code>还要负责和sender反馈：1. first unassembled字节的index，也叫做确认号<strong>acknowledgment</strong>，这样sender才知道下次该发送啥；2. first unassembled和first unacceptable之间的窗宽window size，用来告诉sender允许发送的字节范围。两者结合形成滑动窗口用来进行<strong>flow control</strong>。</p>
<p>第一件必须要处理的事就是序列号sequence number的转换：在<code>StreamReassembler</code>中我们用的是64位的stream index，因此不太可能溢出，但是TCP header空间宝贵，所以第一个字节的index采用32位的seqno，这样就带来几个问题： 1. stream index可以近似于无限大，但是seqno只能从<span class="math inline">\(0\sim2^{32}-1\)</span>不断循环； 2. 为了安全起见，seqno并不是从0开始，而是取一个随机数Initial Sequence Number(ISN)来表示stream的开始SYN(beginning of stream)； 3. TCP header中的SYN和FIN(end of stream)标志位都要被分配seqno，但是SYN和FIN并不是真正的数据，只是表示流的开始和结束。</p>
<figure>
<img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211216213718402-1668481893.png" alt="" /><figcaption>image</figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th>isn</th>
<th>isn+1</th>
<th>isn+2</th>
<th>...</th>
<th>2^32-2</th>
<th>2^32-1</th>
<th>0</th>
<th>1</th>
<th>...</th>
<th>isn-2</th>
<th>isn-1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>1</td>
<td>2</td>
<td>...</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2^32-2</td>
<td>2^32-1</td>
</tr>
<tr class="even">
<td>2^32</td>
<td>2^32+1</td>
<td>2^32+2</td>
<td>...</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2^33-2</td>
<td>2^33-1</td>
</tr>
<tr class="odd">
<td>NaN</td>
<td>0</td>
<td>1</td>
<td>...</td>
<td>first unassemble</td>
<td>...</td>
<td></td>
<td>first unacceptable</td>
<td></td>
<td>2^32-3</td>
<td>2^32-2</td>
</tr>
<tr class="even">
<td>2^32-1</td>
<td>2^32</td>
<td>2^32+1</td>
<td>...</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2^33-3</td>
<td>2^33-2</td>
</tr>
</tbody>
</table>
<p>第一行是32位的seqno，可以想象成在圆环上走路（正反走均可），二三行是64位的absolute seqno，四五行是64位的stream index。</p>
<p>absolute seqno转seqno：<span class="math inline">\(isn+n\%2^{32}\)</span>，<span class="math inline">\(n\)</span>直接强制类型转换即可截取低32位。 seqno转absolute seqno：有点麻烦，可能对应多个结果，因此选择距离<code>checkpoint</code>最近的那个结果，<code>checkpoint</code>取前一次所收段的absolute seqno。原因在于两个前后到达的段absolute seqno的差值几乎不可能超过<span class="math inline">\(2^{32}\)</span>。有个corner case是当<code>checkpoint</code>比较小时计算得到的absolute seqno可能小于0，需要加上<span class="math inline">\(2^{32}\)</span>即<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4201301/warning-left-shift-count-width-of-type"><code>1UL&lt;&lt;32</code></a>。</p>
<p>做好索引的转换后，因为麻烦的部分已经在Lab 1完成了，剩下的就是根据<code>TCPSegment</code>写一些业务逻辑。 <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211217214005787-1024116698.png" alt="image" /> 注意下SYN和FIN对ackno的处理就行： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211217214722866-2056520012.png" alt="image" /> ## Lab 3 这次的活是TCP Sender，负责将应用层的ByteStream分割为段发送，根据接收方的反馈情况进行超时重传。</p>
<p>每次收到接收方的ACK就可以知道其window size, 发送方在每次收到ACK时更新窗宽，并且在下一次收到ACK前，根据发送情况记录窗口的剩余容量，决定是否继续发送。 只要<code>_stream</code>还有需要发送的内容并且receiver还有空闲空间，<code>fill_window</code>就要一直组装成段并发送直到填满该窗口，receiver真正的free space应该是其声明的窗宽减去已发送但未被确认的所有段的长度总和，这个free space才是可以不断继续组装新段并发送时可以利用的，在<code>fill_window</code>组装新段之前要check该空间是否大于0。</p>
<p>另外，发送的第一个段是SYN段，没有数据，只有SYN和initial sequence number，SYN段发完后就返回等待receiver的connection granted，即第一次握手，此时窗宽看作1： &gt; What should my TCPSender assume as the receiver's window size before I've gotten an ACK from the receiver? One byte.</p>
<p>并且在TCP Header中SYN和FIN不能同时为1，否则应该报错RST，FIN段是可以携带数据的。</p>
<p>如果收到ack表明窗口大小为0，在<code>fill_window</code>当作1处理，但是超时的段不应double RTO，因为这是receiver的原因而非线路流量限制导致的，但是SYN段超时需要double RTO并增加重传counter，以便判断是否终止本次连接请求。</p>
<p>FIN段的处理需要仔细一些： 如果<code>_stream.read</code>以后<code>_stream.eof()</code>意味着ByteStream已经没有需要发送的东西了，这时就要考虑设置FIN的问题了，但是FIN是要占序列号的，也就意味着要在接收方的window里占空间，如果free space为50最后一段的payload size为30，那可以设置FIN；如果free space为50最后一段的payload size为51，那么最后一个字节就需要进行下一次发送，并且在下一次考虑FIN的设置问题；如果free space为50最后一段的payload size也为50，那么这段数据可以发送，但是这次没法设置FIN了，也就只能等到接收方腾出空间后才能继续。因此只有free space严格大于最后一段的payload size才可以设置FIN。</p>
<p><code>fill_window</code>有一种情况，free space还有但是<code>_stream.buffer_empty()</code>已经空了，但是只是数据发完了，FIN标志还没发，就需要再发一个段，因此这样写是不行的： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!_stream.<span class="built_in">buffer_empty</span>() &amp;&amp; _receiver_free_space) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211224201911692-472858794.png" alt="image" /></p>
<p>可以直接多循环一次然后用segment的<code>length_in_sequence</code>判断流是否真的空了以及是否要继续发送： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (_receiver_free_space) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> payload_size =</span><br><span class="line">        <span class="built_in">min</span>(&#123;_stream.<span class="built_in">buffer_size</span>(), <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(_receiver_free_space),</span><br><span class="line">             TCPConfig::MAX_PAYLOAD_SIZE&#125;);</span><br><span class="line">    TCPSegment seg;</span><br><span class="line">    <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(_receiver_free_space) &gt; payload_size) &#123;</span><br><span class="line">        seg.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">        _fin = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(_stream.<span class="built_in">read</span>(payload_size));</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    _send_segment(seg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 但是这样可能导致一直发送只包含FIN的段，因此要在while循环限定<code>_fin</code>来确保只发一次FIN段。</p>
<p>关于重传，闲来无事，把重传计时器单独写一个类，因为这个类相对比较简单，所以就和sender放在同一个头文件吧，不过据说有些公司的coding guideline有规定： &gt; Each class shall have it's own header and implementation file.</p>
<p>采用累计确认：如果发送方收到ackno代表之前的所有段都正常接收，因此用<code>std::queue</code>存没有收到ack的段（包括只被ack了一部分的段），超时后从队头开始传。 <code>_segments_outstanding</code>发送时在<code>std::queue</code>里是按照seqno有序的，只有每次收到ack才从<code>std::queue</code>里扔掉一些已经被完全确认收到的段，否则认为<code>std::queue</code>里的所有段接收方均未收到。</p>
<p>收到ack并清理完<code>_segments_outstanding</code>后，如果此时还有未被确认的段，重启计时器并将RTO和重传counter恢复初始值。 注意收到的ack可能是非法的，比如ack了一个还没有发送的段或者ack了已经收到的段的序列号 还有一个corner case在<code>send_extra.cc</code>的95行，如果收到了与上次相同的ack，计时器是不应该重启的，重传时只有收到的ackno严格大于上一次的ackno才重启。</p>
<p>计时器的启动可以参考课本： <img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211222163312884-1740072168.png" alt="image" /></p>
<h2 id="lab-4">Lab 4</h2>
<p>第一次在项目中体会到测试的重要性，也有点理解TDD的好处了，好的测试不仅能够发现问题，还能根据测试样例debug，再次跪谢Stanford~</p>
<figure>
<img src="https://img2020.cnblogs.com/blog/1260581/202112/1260581-20211225200758037-1347511939.png" alt="" /><figcaption>image</figcaption>
</figure>
<p>TCPConnection既充当接收者，也充当发送者，可以理解为实现以后就可以在你自己的主机上使用，接收别人的消息，发送自己的消息。</p>
<p>tick这里如果超过最大重传次数，不仅需要关闭连接，还要给peer发送带有RST的段：如果_sender的segments_out()不空，直接将队头的段设为RST，否则调用send_empty_segment()设置RST</p>
<p>比较抽象的是TCP的关闭这部分：</p>
<p>初步写完代码后，就对着测试样例疯狂调bug吧！！</p>
<p>遇到的第一个corner case是空ACK段（比如第3次握手），由于Lab3的sender只关注ackno和win，通过要发送的seg的length_in_sequence判断是否继续发送，第二次握手收到一个peyload=0的段，以后正常交流是不会这样的，因此第三次握手应该回一个段（可带可不带数据），但是Lab3的fill window遇到这种情况会直接返回，不会发送，我们在这里发送一个空ACK段作为第三次握手。</p>
<p>发送空的ACK段有以下情况： 1. 第3次握手可能发空的，也可能携带数据 2. 第2次挥手 3. 第4次挥手 4. keep alive</p>
<p>即只要收到了length_in_sequence&gt;0的段都需要发ack，如果sender要发数据那可以顺便携带ack，否则就要发空ACK</p>
<p>有时候打断点会瞎跳，据说是编译优化的问题， <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104111823209-669239914.png" alt="image" /> <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104113021977-665516588.png" alt="image" /></p>
<p>还有syn的处理需要考虑作为接收方和发送方两种情况分别处理</p>
<p><code>txrx.sh</code>的测试不好过</p>
<p>调单个测试用例ctest -R test_name <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104161235764-1555046156.png" alt="image" /></p>
<p>建议按照状态机来写，否则会被细节折磨死。 <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104180142069-201294829.png" alt="image" /></p>
<p>神呀！104-160一直过不了，无奈只能通过替换网上的模块找bug <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104213010425-1104108783.png" alt="image" /> 但是lab0-4全部替换仍然是那个bug，不知道哪里有问题。。。严重怀疑由于服务器在美国的原因</p>
<figure>
<img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220104220146252-1499569230.png" alt="" /><figcaption>image</figcaption>
</figure>
<p>折腾vmware，自己配环境，G++注意设好后https://blog.csdn.net/kenkao/article/details/89550641?utm_medium=distribute.pc_relevant.none-task-blog-2<sub>default</sub>baidujs_title~default-4.no_search_link&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7</p>
<p>还要修改https://www.cnblogs.com/minglee/p/9016306.html <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220105233420579-412125300.png" alt="image" /> 接着就可以正常make和测试了。 换到VMware没有任何改动一次性通过了所有测试： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220105234831224-1290189010.png" alt="image" /></p>
<p>有点离谱...第一次遇到系统级别的Bug，卡了三天，全部模块替换为别人的还是挂... ## Lab 5 实现IP/Ethernet网络接口，也叫网络适配器/网卡，</p>
<p>只要ARP表没找到，说明需要学习目标MAC地址，因此发送的IP数据报均需要缓存。</p>
<p>不论是ARP请求还是回复，都需要学习ARP表，如果是请求，还要发送ARP响应。 VMware可以过，VB还是挂 <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108112730514-116878135.png" alt="image" /></p>
<h2 id="lab-6">Lab 6</h2>
<p>这个实验要基于Lab 5的<code>NetworkInterface</code>实现一个IP路由器，负责将接收到的数据报根据路由表转发：从哪个网络接口转发以及下一跳的IP地址。 我们只负责根据生成的路由表转发，至于如何生成路由表（RIP/OSPF/BGP）无需关心。 <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220111214607248-1624579305.png" alt="image" /></p>
<p>第一个函数<code>void add_route(const uint32_t route_prefix, const uint8_t prefix_length, const optional&lt;address&gt; next_hop, const size_t interface_num);</code>负责保存每条路由信息以备后续使用。 <code>route_prefix</code>和<code>prefix_length</code>共同确定一个网段，比如<code>18.47.0.0/16</code>的<code>route_prefix=18*2^24+47*2^16,prefix_length=16</code>，如果一个数据报的目的IP是<code>18.47.x.y</code>那么该条路由即匹配。</p>
<p>如果路由器直接目的网段，路由信息的<code>next_hop</code>为空，直接通过<code>NetworkInterface</code>发送到目的IP；如果路由器通过其它路由器连接到目的网段，路由信息的<code>next_hop</code>为下一个路由器的IP。</p>
<p>第二个函数<code>void route_one_datagram(InternetDatagram &amp;dgram);</code>通过最长前缀匹配找到最佳路由，如果没有匹配的路由则丢弃数据报，如果该数据包的<span class="math inline">\(TTL\leq 1\)</span>也丢弃，否则通过最佳路由对应的<code>NetworkInterface</code>转发。</p>
<p>这里的abstraction在于路由器只需要关心IP数据报而无需关心链路层实现细节，只是通过<code>NetworkInterface</code>与链路层交互。</p>
<h2 id="lab-7">Lab 7</h2>
<p>到此为止，实现了Internet的传输层TCP协议、网络层和链路层之间的接口转换以及路由转发。 这个实验让我们用实现的这些组件和另一个人交互： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220111154943808-1022957497.png" alt="image" /></p>
<p>由于学校局域网内的IP都是私网地址（10.0.0.0/8，172.16.0.0/12，192.168.0.0/16），为了交互，需要通过<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31332694">NAT技术</a>映射到公网IP，所以使用了<code>cs144.keithw.org/104.196.238.229</code>作为中继服务器。 <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220111155822569-889084045.png" alt="image" /></p>
<p>按照文档交互： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108170606232-1565549109.png" alt="image" /> <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108170639108-1941733275.png" alt="image" /></p>
<p>任意一方按<code>ctrl+D</code>单方向关闭连接后，就不能继续发送数据，但仍可以继续接收直到peer也关闭连接。双方都关闭后，任意一方完成了lingering之后连接才真正关闭。</p>
<p>除了聊天，还可以收发文件。</p>
<p>通关截图： <img src="https://img2020.cnblogs.com/blog/1260581/202201/1260581-20220108170828819-1433823727.png" alt="image" /></p>
<h2 id="refs">Refs</h2>
<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html">【计算机网络】Stanford CS144 Lab Assignments 学习笔记</a> <a target="_blank" rel="noopener" href="http://yuzijun.life/2021-02/CS144">斯坦福计网实验 / CS144 Lab Assignments</a> <a target="_blank" rel="noopener" href="https://kiprey.github.io/2021/11/cs144-lab0/">CS144计算机网络</a>
</address>
<p></size_t></size_t></size_t></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2021/11/01/%E9%87%8D%E6%96%B0%E6%80%9D%E8%80%83%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%8A%E8%81%8C%E4%B8%9A%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/01/%E9%87%8D%E6%96%B0%E6%80%9D%E8%80%83%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%8A%E8%81%8C%E4%B8%9A%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/" class="post-title-link" itemprop="url">重新思考机器学习及职业方向选择</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-01 14:25:00" itemprop="dateCreated datePublished" datetime="2021-11-01T14:25:00+08:00">2021-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近参加了一个<a target="_blank" rel="noopener" href="https://datafountain.cn/competitions/537/">AI比赛</a>，引起了我对机器学习以及自己未来职业方向的重新思索，我发现自己现在做决定更加在乎自身的兴趣而非舆论等其他因素，也算是一种进步了吧！</p>
<p>比赛的过程我很难享受编程带来的乐趣，只有在看到AUC指标提升零点几个百分点时才会有一丝丝成就感，而在数据清洗、特征构建、魔改模型以及无脑调参这种占据算法工程师大量时间的环节感受到的只有繁琐和无聊，这不禁让我反思自己半年前的选择：如果将来步入互联网，到底是选择算法岗还是开发岗呢？</p>
<p>从世俗的角度来看，算法岗毫无疑问有着更高的薪资甚至更光明的前途，我也坚信机器学习会持续改变人类生活并且在未来应用到方方面面，但是需要多久时间可能谁也说不准。</p>
<p>从现阶段来看，AI的发展尤其是落地遇到了很多困难，突然想起了《智能计算》韩德强老师上课时指出的数据驱动的方法终究很难解释问题的本质，我当时嗤之以鼻，现在有些许赞同了。</p>
<p>从自身喜好来讲，对于不确定的东西我向来不太喜欢，然而机器学习领域充斥着大量的不确定性，大多数模型缺乏可解释性，我在操纵灰盒甚至黑盒的过程中祈求获得指标的提升，在出现bug时不好排查。除此之外，现实世界的数据大多数是杂乱繁琐的，需要花费80%以上的时间去清洗数据、构建特征，这也不是我喜欢做的事情。相对而言，我更加欣赏自己能做出来一个确定的、完整的系统呈现在眼前，它可以解决现实生活中的某个问题，并且可以重复使用（可复现），所以我决定学习重心重新回到开发岗位，当然如果时间充裕可以去算法岗实习看看再做最终的决定。</p>
<p>还有就是胡神的很多思考对我触动很深。</p>
<p>我想好啦，做system！当然我肯定会把当前分内的事情做好、该学的学懂！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2021/10/24/%E5%B1%A0%E9%BE%99%E5%B0%91%E5%B9%B4%20%E9%81%8D%E4%BD%93%E9%B3%9E%E4%BC%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/24/%E5%B1%A0%E9%BE%99%E5%B0%91%E5%B9%B4%20%E9%81%8D%E4%BD%93%E9%B3%9E%E4%BC%A4/" class="post-title-link" itemprop="url">屠龙少年 遍体鳞伤</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-24 05:15:00" itemprop="dateCreated datePublished" datetime="2021-10-24T05:15:00+08:00">2021-10-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>与恶龙斗，其乐无穷！少年怀揣利剑，不顾生死与恶龙搏斗，听起来热血沸腾，可是大多时候总是遍体鳞伤，甚至性命不保！</p>
<p>有感于最近奖学金评定以及与实验室老师之间的一些“趣事”，我想仔细思考下面几个问题： 1. 个人对于体制的反抗究竟是否值得 2. 以后采取什么样的行为完成从学生到社畜的转变</p>
<p>我相信大家从小到大，周围一定会有这种人：面对与自己利益相关的事情十分敏感，对于自身的获益锱铢必较，一丝一毫也不能退让。在学生时代，体现最为明显的就是评奖评优的加分机制：参加了某类活动的一群人总是会形成一个微妙的利益共同体，这个圈子看似脆弱隐形，但为了该类活动的加分却能爆发出惊人的一致性，与规则制定者们、其他活动利益共同体等圈子展开激烈的撕逼，毕竟每个圈子都有自己的代表利益：规则制定者向上负责，学院为了拍学部的马屁将歌唱比赛等的加分设置的和科研同样高，美其名曰培养学生的团队精神；歌唱比赛圈子自然全力支持，走方阵圈子此时不满意了：我们也是集体活动，我们也要加分！班干部圈子也不满意了：为啥它们加那么多，我们也要加这么多！</p>
<p>就这样，错综复杂的扯皮会持续到评定结束，所有圈子在撕逼中达到了利益的相对平衡，弱势圈子甚至不发声圈子自然是吃亏大户，闹得越欢的圈子自然会多分一杯羹，正应了那句老话：会哭的孩子有奶吃。</p>
<p>我作为不发声圈子的一员，默默吃瓜之余，也会为自己的利益损失感到疑惑，老实人就活该吃亏吗？</p>
<p>回顾自己的求学生涯，我一直有着比较严重的逆反心理，对于各种评定规则嗤之以鼻。高中以前事情并不复杂，只看学习成绩，赢者通吃，我又在那种评价体系下表现得不错，因此并无太多怨念。本科以及烟酒生期间，不论是出于佛系还是不屑抑或是对于规则制度的反叛，我对这些事情也撕逼甚少，结果就是少生很多气，但是利益损失也相当大，甚至以后会充当背锅侠。</p>
<p>在这种弱肉强食的环境下，总有那么一群人，可以在这些特殊的规则下左右逢源，最终达到自身的利益最大化，我相信在社会上这些只会变得更加严重。</p>
<p>现在我先来尝试回答第一个问题：与这些制度规则以及利益共同体的斗争是否值得，即心理层面的问题。我做出如下考虑： - 核心思想在于：分清楚社交边界，对于界内的朋友事情当然可以像从前一样无欲无求、佛系处理；对于界外的人群事情再也不能像以前那样无原则忍让，在保护好自身的前提下：要坚定地捍卫自己的利益，我们不能总是让老实人吃亏。因此斗争是必要的，但是要分清斗争的敌友中间派（此时觉得毛选一定要读）。 - 那么关键问题在于：如何分清敌友中间派？这个需要敏锐的观察和深入的沟通，甚至有时候还要被捅刀才能识人。举个例子：我研一时候觉得自己可以和实验室小老板做朋友，但是人心隔肚皮，被捅刀子之后才彻底认清她的丑恶嘴脸，也打消了我的幻想：工人和资本家永远不可能做朋友，但是我依然坚信不是所有的老师都是这个鬼样子： <img src="https://img2020.cnblogs.com/blog/1260581/202110/1260581-20211024124309130-337350262.png" alt="image" /> - 对于友：要互帮互助，积极联络，共度难关 - 对于中间派：要谨言慎行，有利益需求时互相利用，切记不要透露真心 - 对于敌：要坚决放弃幼稚的幻想、采用智慧的策略坚决斗争，坚定维护自身以及朋友的利益，坚决拒绝不合理的要求！</p>
<p>明确心理层面的处理后，再来看看行为层面的处理： - 核心要义在于：用魔法打败魔法！将自身和朋友利益放在首位！ - 关键问题在于：如何拥有更加高超的魔法？首先根据自身的目标不断壮大实力，须知枪杆子里出政权；此外，除了闷头干活，还要会表难点表功。两点结合起来也就是所谓的软硬实力。 - 硬实力：别无他法，选择以后刻苦再刻苦 - 软实力：平时要学会和友、中间派、敌的说话策略，该交心交心、该阳奉阴违就阳奉阴违、该果断拒绝就拒绝</p>
<p>总之，屠龙少年即使遍体鳞伤也不会终成恶龙！只是会采取更加巧妙的方式继续自己的斗争！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2021/10/16/%E7%AC%94%E8%AF%95%E5%90%88%E8%BE%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/16/%E7%AC%94%E8%AF%95%E5%90%88%E8%BE%91/" class="post-title-link" itemprop="url">笔试合辑</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-16 12:43:00" itemprop="dateCreated datePublished" datetime="2021-10-16T12:43:00+08:00">2021-10-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol type="1">
<li><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/n/705b29af83034150830e3c0e9a28e51f">送文件问题</a> 题意说人话就是：给定线段<span class="math inline">\(A_1A_2\)</span>和<span class="math inline">\(B_1B_2\)</span>，希望从<span class="math inline">\(A_1A_2\)</span>和<span class="math inline">\(B_1B_2\)</span>上分别找一个点A和B，使得<span class="math inline">\(B_1B+BA&lt;=A_1A\)</span>。 首先三角形<span class="math inline">\(B_1BA\)</span>三条边满足<span class="math inline">\(B_1A&lt;b_1b+ab\)</span>，因此快递员必然走直线<span class="math inline">\(ab_1\)</span>，即需要<span class="math inline">\(ab_1&lt;=aa_1\)</span>，即<span class="math inline">\(ab_1+aa_2&lt;=aa_1+aa_2=a_1a_2\)</span>，又在三角形<span class="math inline">\(b_1aa_2\)</span>中，<span class="math inline">\(ab_1+aa_2&gt;B_1A_2\)</span>，因此快递员必然选择走直线<span class="math inline">\(B_1A_2\)</span>，也就是说如果<span class="math inline">\(B_1A_2\)</span>的距离小于等于<span class="math inline">\(A_1A_2\)</span>的距离就能满足。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    x1, y1, x2, y2, x3, y3, x4, y4 = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    alice = (x3 - x4) ** <span class="number">2</span> + (y3 - y4) ** <span class="number">2</span></span><br><span class="line">    bob = (x1 - x4) ** <span class="number">2</span> + (y1 - y4) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> bob &lt;= alice:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No&quot;</span>)</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><a target="_blank" rel="noopener" href="https://blog.nowcoder.net/n/62d4211f496e4939a153536e8e89a3ef">及格问题</a> 我理解的题意（误）是：共有<span class="math inline">\((n+3)*20\)</span>道题，只要做对<span class="math inline">\((n+3)*12\)</span>题以上就可以及格，然后如下代码连样例都过不了： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> comb</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">72</span>, <span class="number">121</span>):</span><br><span class="line">    ans += comb(<span class="number">120</span>, i, exact=<span class="literal">True</span>) % <span class="number">202220222022</span></span><br><span class="line">    ans %= <span class="number">202220222022</span></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>DP的话：如果将dp(i,j)定义为前i门课至少做对j题的组合数，最终的答案就是dp(n+3,12(n+3))，但这样后面的状态转移可能会比较复杂。</p>
<p>所以我们将dp(i,j)定义为前i门课刚好做对j题的组合数，答案就是dp(n+3,12(n+3))+dp(n+3,12(n+3)+1)+...+dp(n+3,13(n+3))+...+dp(n+3,20(n+3)) 卧槽，好像弄错题意了... dp(1,i)=1，也就是说每一门课里做对哪些题没有区别，1门课做对1题不是20种方案，而是1种，所以排列组合也就不对了。唉，最怕读错题啊！！ 状态转移方程dp(i,j)=dp(i-1,0)+dp(i-1,1)+...+dp(i-1,j)，就是说前i门课刚好做对j题的方案数取决于前i-1门课，如果前i-1门课做对0题，那么第i门就必须要做对j题；如果前i-1门课做对1题，那么第i门就必须要做对j-1题... 这里要注意：因为一门课最多只能做对20题，所以前i-1课做对的题数要满足k &gt;= j - 20 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">mod = <span class="number">202220222022</span></span><br><span class="line"></span><br><span class="line">n += <span class="number">3</span></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> + <span class="number">20</span> * n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">21</span>):</span><br><span class="line">    dp[<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i * <span class="number">20</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># k表示前i-1课做对的题数, 第i课做对的题数&lt;=20, 即前i-1课做对的题数k &gt;= j - 20</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> k &gt;= j - <span class="number">20</span>:</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][k]</span><br><span class="line">                dp[i][j] %= mod</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误示范</span></span><br><span class="line"><span class="comment"># for i in range(12, 21):</span></span><br><span class="line">    <span class="comment"># ans += dp[n][i * n] % mod</span></span><br><span class="line">    <span class="comment"># ans %= mod</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span> * n, <span class="number">20</span> * n + <span class="number">1</span>):</span><br><span class="line">    ans += dp[n][i] % mod</span><br><span class="line">    ans %= mod</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure> 3. <a target="_blank" rel="noopener" href="https://blog.csdn.net/Derrick12/article/details/119712588">牛牛施肥</a> 这种题要注意循环不变性，就是说每一趟是否要包含第一行和最后一行，采用左闭右开，这样每一趟需要的肥料都是固定的，比较好实现而不至于淹没在细节里 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FarmerNN</span>(<span class="params">self, n, m</span>):</span></span><br><span class="line">        k, b = m // (n - <span class="number">1</span>), m % (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            ans = [k] * n</span><br><span class="line">            ans[<span class="number">0</span>], ans[-<span class="number">1</span>] = k // <span class="number">2</span>, k // <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(b):</span><br><span class="line">                ans[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans = [k] * n</span><br><span class="line">            ans[<span class="number">0</span>], ans[-<span class="number">1</span>] = k // <span class="number">2</span> + <span class="number">1</span>, k // <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, n - <span class="number">1</span> - b, -<span class="number">1</span>):</span><br><span class="line">                ans[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure> &lt;/b_1b+ab<span class="math inline">\(，因此快递员必然走直线\)</span>ab_1<span class="math inline">\(，即需要\)</span>ab_1&lt;=aa_1<span class="math inline">\(，即\)</span>ab_1+aa_2&lt;=aa_1+aa_2=a_1a_2<span class="math inline">\(，又在三角形\)</span>b_1aa_2<span class="math inline">\(中，\)</span>ab_1+aa_2&gt;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2021/09/24/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/24/%E6%97%A5%E5%B8%B8%E7%A2%8E%E7%A2%8E%E5%BF%B5/" class="post-title-link" itemprop="url">日常碎碎念</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-24 14:10:00" itemprop="dateCreated datePublished" datetime="2021-09-24T14:10:00+08:00">2021-09-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol type="1">
<li>以后还是减少在宿舍的时间吧，这个地方适合躺尸，不适合学习</li>
<li>就是太怂；不要被周围的土鳖影响定位，防止飘了，清醒的认识；keep in distance；非必要不用眼；工作是为了生活</li>
<li>真的少和他们鬼混了；没人结账，都是死皮脸；跟他们玩基本得不到任何提升，在他们面前显得牛逼没有任何卵用</li>
<li>以后少和他们出去玩吧，除了吃饭还是吃饭，很多时候还要我掏钱。而且某人已经得罪我了。以后就根据自己的需求最多和他们打打球好了或者去食堂好了，可以自己一个人去道科或者和其他朋友。 简言之，除了自身必要需求，少与他们鬼混。 重心要转到工作了，少玩点吧。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EIMadrigal"
      src="/images/favicon.png">
  <p class="site-author-name" itemprop="name">EIMadrigal</p>
  <div class="site-description" itemprop="description">Hello World</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">167</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/EIMadrigal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:andrew.renj@gmail.com" title="E-Mail → mailto:andrew.renj@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/EIMadrigal" title="cnblogs → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-codiepie fa-fw"></i>cnblogs</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/EIMadrigal" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018-02 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EIMadrigal</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">Total views: <span id="busuanzi_value_site_pv"></span></span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">Total visitors: <span id="busuanzi_value_site_uv"></span></span>
    <span class="post-meta-divider">|</span>

<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);
    var countOffset = 20000;

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset);
            clearInterval(int);
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>

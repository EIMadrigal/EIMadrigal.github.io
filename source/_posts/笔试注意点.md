---
title: 笔试注意点
url: tricks-on-algorithm-written-test
date: 2021-10-16 20:43:00
description: 踩坑血泪...
categories: Computer Science
tags: [Algorithm,Interview,Online Judge]
---

## 输入输出
 1. `cin`的结束符是空格, 制表符和回车, 读完后结束符仍然在缓冲区. `getline`的结束符是回车, 读完后结束符不在缓冲区. 读取一行有空格字符串需要`getline`.

```cpp
int n;
cin >> n;
cin.ignore();  // 忽略\n
vector<string> s(n);
for (int i = 0; i < n; ++i) {
    getline(cin, s[i]);
}

// 删掉该行所有的回车
string input;
getline(cin, input);
input.erase(remove(input.begin(), input.end(), '\r'), input.end());
input.erase(remove(input.begin(), input.end(), '\t'), input.end());
input.erase(remove(input.begin(), input.end(), '\n'), input.end());
```
 2. 将空格分隔的字符串读到`vector`

```cpp
vector<string> split(string input) {
    vector<string> res;
    istringstream ss(input);
    string tmp;
    while (ss >> tmp) {
        res.push_back(tmp);
    }
    return res;
}

vector<string> split(const string &str) {
    vector<string> tokens;
    string::size_type start = 0, end = 0;
    while ((end = str.find(" ", start)) != string::npos) {
        tokens.push_back(str.substr(start, end - start));
        start = end + 1;
    }
    tokens.push_back(str.substr(start));
    return tokens;
}

// 逗号分隔
vector<string> split(string input) {
    vector<string> res;
    istringstream ss(input);
    string tmp;
    while (getline(ss, tmp, ',')) {
        res.push_back(tmp);
    }
    return res;
}
```

 3. 知道数组大小后，可以直接读到数组中

```cpp
vector<int> nums(n);
for (int i = 0; i < n; ++i) {
    cin >> nums[i];
}
```

 4. 删除首尾空格

```cpp
s.erase(s.find_last_not_of(" ") + 1);
s.erase(0, s.find_first_not_of(" "));
```

5. 多个数最大/最小
```cpp
min({a, b, c, d, e});
*max_element(nums.begin(), nums.end());
```

## STL总结

 1. `int stoi(const string& str, size_t* idx=0, int base=10)`：`idx`指向第一个非数字字符
 2. `isalpha(int ch)`: 头文件`cctype`
 3. 对`map`或`unordered_map`按值排序
```cpp
unordered_map<string, int> record{{"a", 2}, {"b", 1}};
vector<pair<string, int>> vec(record.begin(), record.end());
std::sort(vec.begin(), vec.end(),
    [](const pair<string, int>& a, const pair<string, int>& b) {return a.second < b.second;});

for (auto it = vec.begin(); it != vec.end(); ++it) {
    cout << it->first << " ";
}
```
 2. `unordered_map`[自定义key](http://www.hawkers.cc/2016/04/unorderedmap-pair-funtor.html)  
	`unordered_map<pair<int, int>, int>`会报错，需要提供一个hash函数. 如果key不存在，访问仍然成功，返回value对象默认构造值
	```cpp
    struct PairHash {
        template<typename T, typename U>
        size_t operator() (const pair<T, U> &x) const {
            auto h1 = hash<T>()(x.first), h2 = hash<U>()(x.second);
            return h1 ^ h2;
        }
    };

    unordered_map<pair<int, int>, int, PairHash> m;
    ```
    但是`map`就不需要, map的key类型必须支持`<`运算符
 4. `sort(v.begin(), v.end(), [](int a, int b) { return a > b; })`或`sort(v.rbegin(), v.rend())`
 5. vector追加: `dest.insert(dest.end(), src.begin(), src.end())`. `vector<vector<int>>`每一维元素个数可以不同
 6. C++ 17的structured binding: `for (auto [k, v] : unordered_map)`
 7. `std::lower_bound`和`std::upper_bound`对于random-access iterators的时间复杂度是$O(lgn)$，但对于non-random-access iterators如`set::iterator`是$O(n)$的。这种情况下应使用`set`自带的`setObj.upper_bound(target)`，复杂度$O(lgn)$
 8. 反向迭代：`for (auto it = nums.rbegin(); it != nums.rend(); ++it)`
 9. `sort`记录原始索引：可以先过一遍数组，将数字和索引绑定，然后对`pair`排序。
 10. `string(10, 'x')` `string res; res += string(10, 'x');`

常见算法：

    1. 二分答案
    2. 数组、哈希表、优先队列、栈、双向队列（在头尾都操作的）
    3. 深搜：建图转化
    4. 排序
    5. 贪心: 从大到小/从小到大排序、单位价值排序
    6. 拓扑排序
    7. 并查集
    8. DP：线性、二维、背包
    9. 双指针：对撞、快慢、滑动窗口
    10. 模拟
    11. 数学：猜答案、打表
    12. 前缀和、差分

![知识点](1.jpg)

```cpp
// 一维原本：preSum[r] - preSum[l - 1]
// [l, r]区间和：preSum[r + 1] - preSum[l]
vector<int> preSum(n + 1, 0);
for (int i = 1; i <= n; ++i) {
    preSum[i] = preSum[i - 1] + nums[i - 1];
}


// 二维原本：preSum[x2][y2] - preSum[x2][y1 - 1] - preSum[x1 - 1][y2] + preSum[x1 - 1][y1 - 1]
// [x1, y1] -> [x2, y2]区间和：preSum[x2 + 1][y2 + 1] - preSum[x2 + 1][y1] - preSum[x1][y2 + 1] + preSum[x1][y1]
vector<vector<int>> preSum(m + 1, vector<int>(n + 1, 0));
for (int i = 1; i <= m; ++i) {
    for (int j = 1; j <= n; ++j) {
        preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + nums[i - 1][j - 1];
    }
}
```

```cpp
class Difference {
public:
    Difference(vector<int>& nums) {
        diff = vector<int>(nums.size(), 0);
        diff[0] = nums[0];
        for (int i = 1; i < nums.size(); ++i) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }

    // for every num in [i, j] increase delta
    void increament(int i, int j, int delta) {
        diff[i] += delta;
        if (j + 1 < diff.size()) {
            diff[j + 1] -= delta;
        }
    }

    vector<int> getArr() {
        vector<int> ans(diff.size(), 0);
        ans[0] = diff[0];
        for (int i = 1; i < ans.size(); ++i) {
            ans[i] = ans[i - 1] + diff[i];
        }
        return ans;
    }
private:
    vector<int> diff;
};
```

```cpp
// vector用c - 'a'快速定位孩子结点
class Trie {
public:
    Trie() {
        root = new TrieNode();
    }
    ~Trie() {
        if (root) {
            delete root;
        }
    }

    void insert(string word) {
        TrieNode* cur = root;
        for (char c : word) {
            if (cur->children[c - 'a'] == nullptr) {
                cur->children[c - 'a'] = new TrieNode();
            }
            cur = cur->children[c - 'a'];
        }
        cur->isEnd = true;
    }

    bool search(string word) {
        TrieNode* cur = root;
        for (char c : word) {
            if (cur->children[c - 'a'] == nullptr) {
                return false;
            }
            cur = cur->children[c - 'a'];
        }
        return cur->isEnd;
    }

    bool startWith(string prefix) {
        TrieNode* cur = root;
        for (char c : prefix) {
            if (cur->children[c - 'a'] == nullptr) {
                return false;
            }
            cur = cur->children[c - 'a'];
        }
        return true;
    }

private:
    struct TrieNode {
        TrieNode() : children(26, nullptr), isEnd(false) {}
        ~TrieNode() {
            for (TrieNode* child : children) {
                delete child;
            }
        }

        vector<TrieNode*> children;
        bool isEnd;
    };

    TrieNode* root;
};


// unordered_map用c定位孩子结点
class Trie {
public:
    Trie() {
        root = new TrieNode();
    }
    ~Trie() {
        if (root) {
            delete root;
        }
    }

    void insert(string word) {
        TrieNode* cur = root;
        for (char c : word) {
            if (cur->children.find(c) == cur->children.end()) {
                cur->children[c] = new TrieNode();
            }
            cur = cur->children[c];
        }
        cur->isEnd = true;
    }

    bool search(string word) {
        TrieNode* cur = root;
        for (char c : word) {
            if (cur->children.find(c) == cur->children.end()) {
                return false;
            }
            cur = cur->children[c];
        }
        return cur->isEnd;
    }

    bool startWith(string prefix) {
        TrieNode* cur = root;
        for (char c : prefix) {
            if (cur->children.find(c) == cur->children.end()) {
                return false;
            }
            cur = cur->children[c];
        }
        return true;
    }

private:
    struct TrieNode {
        TrieNode() : isEnd(false) {}
        ~TrieNode() {
            for (auto child : children) {
                if (child.second) {
                    delete child.second;
                }
            }
        }

        unordered_map<char, TrieNode*> children;
        bool isEnd;
    };

    TrieNode* root;
};
```

```cpp
// https://gregable.com/2007/10/reservoir-sampling.html

vector<int> reservoirSampling(vector<int>& nums, int k) {
    vector<int> res(k);
    const int n = nums.size();
    for (int i = 0; i < k; ++i) {
        res[i] = nums[i];
    }
    for (int i = k; i < n; ++i) {
        int random = rand() % i;  // [0, i - 1]
        if (random < k) {  // 概率是 k / i
            res[random] = nums[i];
        }
    }
    return res;
}
```

```cpp
class LRUCache {
public:
    LRUCache(int capacity) : capacity_(capacity) {}

    int get(int key) {
        auto it = map_.find(key);
        if (it == map_.end()) {
            return -1;
        }
        cache_.splice(cache_.begin(), cache_, it->second);
        return it->second->second;
    }

    void put(int key, int value) {
        auto it = map_.find(key);
        if (it != map_.end()) {
            it->second->second = value;
            cache_.splice(cache_.begin(), cache_, it->second);
        } else {
            if (map_.size() == capacity_) {
                map_.erase(cache_.back().first);
                cache_.pop_back();
            }
            cache_.push_front({key, value});
            map_[key] = cache_.begin();
        }
    }

private:
    int capacity_;
    list<pair<int, int>> cache_;  // list node stores (key, val) pair
    unordered_map<int, list<pair<int, int>>::iterator> map_;  // key -> node iterator
};

class LRUCache {
private:
    struct ListNode {
        int key, val;
        ListNode* prev, *next;
        ListNode() : key(0), val(0), prev(nullptr), next(nullptr) {}
        ListNode(int key, int val) : key(key), val(val), prev(nullptr), next(nullptr) {}
    };

    int capacity_;
    ListNode *head_, *tail_;
    unordered_map<int, ListNode*> map_;

public:
    LRUCache(int capacity) : capacity_(capacity) {
        head_ = new ListNode();
        tail_ = new ListNode();
        head_->next = tail_;
        tail_->prev = head_;
    }

    int get(int key) {
        if (map_.find(key) == map_.end()) {
            return -1;
        }
        ListNode* node = map_[key];
        _remove(node);
        _addHead(node);
        return node->val;
    }

    void put(int key, int value) {
        if (map_.find(key) != map_.end()) {
            ListNode* cur = map_[key];
            cur->val = value;
            _remove(cur);
            _addHead(cur);
            return;
        }
        if (map_.size() == capacity_) {
            ListNode* removed = tail_->prev;
            _remove(removed);
            map_.erase(removed->key);
            delete removed;
        }
        ListNode *node = new ListNode(key, value);
        _addHead(node);
        map_[key] = node;   
    }

    void _remove(ListNode* cur) {
        cur->prev->next = cur->next;
        cur->next->prev = cur->prev;
    }

    void _addHead(ListNode* cur) {
        cur->prev = head_;
        cur->next = head_->next;
        head_->next->prev = cur;
        head_->next = cur;
    }
};
```

```cpp
class LFUCache {
public:
    LFUCache(int _capacity) {
        capacity = _capacity;
    }

    int get(int key) {
        if (capacity == 0) {
            return -1;
        }
        auto it = keyTable.find(key);
        if (it == keyTable.end()) {
            return -1;
        }
        list<Node>::iterator node = it->second;
        int val = node->val, freq = node->freq;
        freqTable[freq].erase(node);

        if (freqTable[freq].size() == 0) {
            freqTable.erase(freq);
            if (freq == minFreq)
                minFreq++;
        }
        // 更新访问频率
        freqTable[freq + 1].push_front(Node(key, val, freq + 1));
        keyTable[key] = freqTable[freq + 1].begin();
        return val;
    }

    void put(int key, int val) {
        if (capacity == 0) {
            return;
        }
        auto it = keyTable.find(key);
        if (it != keyTable.end()) {
            auto node = it->second;
            node->val = val;
            int freq = node->freq;
            freqTable[freq].erase(node);

            if (freqTable[freq].size() == 0) {
                freqTable.erase(freq);
                if (freq == minFreq)
                    minFreq++;
            }
            // 更新访问频率
            freqTable[freq + 1].push_front(Node(key, val, freq + 1));
            keyTable[key] = freqTable[freq + 1].begin();
        }
        else {  // 插入新项
            if (keyTable.size() == capacity) {  // 换出目前使用频率最低的项
                auto old = freqTable[minFreq].back();
                freqTable[minFreq].pop_back();  // 从链表中删除
                keyTable.erase(old.key);  // 从keyTable中删除
                if (freqTable[minFreq].size() == 0) {  // 从freqTable中删除
                    freqTable.erase(minFreq);
                }
            }
            freqTable[1].push_front(Node(key, val, 1));
            keyTable[key] = freqTable[1].begin();
            minFreq = 1;
        }
    }

    struct Node {
        int key, val, freq;
        Node(int _key, int _val, int _freq) : key(_key), val(_val), freq(_freq) {}
    };

    int capacity;
    int minFreq;  // 目前的最低频率(1或单调增加)
    unordered_map<int, list<Node>::iterator> keyTable;
    unordered_map<int, list<Node>> freqTable;
};
```
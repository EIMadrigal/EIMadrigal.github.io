---
title: 计算机网络FAQ
url: computer-networks-faq
date: 2019-01-02 22:19:00
description: 计网八股文
categories: Computer Science
tags: [Network,Interview]
---

## TCP和UDP区别

 - TCP面向连接，提供可靠传输，收发数据前要3次握手建立连接，使用ACK对收发数据进行确认；UDP是无连接协议，不管对方是否收到或收到的数据是否正确
 - TCP提供流量控制和拥塞控制，UDP无
 - TCP对系统资源的要求高于UDP，因此速度稍慢
 - TCP数据包没有边界，会出现粘包问题，UDP包是独立的，没有粘包问题
 - 应用时如果强调数据的完整性和正确性应用TCP，强调性能和速度时用UDP

## TCP握手与挥手

建立TCP连接的过程需要使用一些系统调用
[SYN攻击与预防](https://www.jianshu.com/p/f62390df9627)

[TCP握手](https://www.cnblogs.com/liwei0526vip/p/14587300.html)

攻击者截取服务器回复的SYN和ACK，伪装成原主机继续通信

服务器超时重传，达到最大次数后发RST并关闭连接

客户端处于time_wait状态，同时源端口不可用，端口号很快耗尽

### TIME_WAIT状态

1. why 2MSL：确保ACK报文能够到达服务端，使服务端正常关闭连接。防止已失效的报文出现在新的连接中，导致数据错乱。
2. 

双方的(IP, Socket)四元组不能被使用。

## TCP可靠传输

 - 16位校验和：伪首部 + TCP header二进制相加取反，丢弃
 - seq + ack：接收方按序组织，避免重复，确保收到所有Segments
 - [超时重传](https://stackoverflow.com/questions/12956685)：发送方维护超时时间，没有收到ack就重传，即ARQ（包括停等，go back N，选择重传）。RTO时间采用指数回退，重传超过一定次数（比如8次）就断开连接。
 - 流量控制：收方告诉发方接收缓冲区大小，通过可变大小的滑动窗宽recv_win控制发方的发送速率
 - 拥塞控制：发送方维持拥塞窗口cwnd记录网络链路的拥塞程度，发送窗口=min{recv_win, cwnd}。慢启动，拥塞避免，快速重传，快速恢复

 1. 慢启动  
    cwnd指数增加{1, 2, 4, 8, 16, ...}，超过阈值时开始拥塞避免算法
 2. 拥塞避免  
    cwnd线性增加
 3. 快速重传  
    要求接收方每收到一个失序的报文段后就立即发出重复确认而不是等待自己发送数据时才捎带确认
    发送方只要一连收到三个重复确认就立即重传对方尚未收到的报文段，而不必等待设置的重传计时器到期
 4. 快速恢复  
    当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，为了预防网络拥塞
    将拥塞窗口cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法
    TCP Tahoe版本与TCP Reno版本的区别：Reno版本在快重传之后采用快恢复算法而不是采用慢开始算法

## UDP

UDP对实时性要求高，数据准确性要求不是太高的场合、视频通话、QQ主要UDP为主，TCP为辅
应用场景：实时音视频传输，DNS协议

 - 对延迟要求高，可靠性要求低，无法忍受重传，需要看到实时的图像和声音，中间丢一帧完全没事。
 - 网络非常可靠，不需要考虑UDP丢包的问题。
 - NAT穿透只能用UDP

## [HTTPS](https://xiaolincoding.com/network/2_http/https_rsa.html#tls-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B)

HTTP协议存在安全问题：

 - 信息明文传输, 不提供数据加密, 可能被窃听
 - 未验证通信双方身份, 可能伪装
 - 未验证报文完整性, 可能篡改

为了解决上述问题, HTTPS在HTTP的基础上增加了SSL/TLS传输层, 进行安全传输.

 - 加密: 混合加密方式. 非对称加密传输session key, 对称加密传输信息. 非对称加密需要公钥和私钥，公钥用来加密，私钥用来解密. 安全，不怕泄漏, 速度慢. 常用算法包括RSA，ECC，DSA. 对称加密计算量小，算法速度快，加密效率高, 密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲, 常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES.
 - 认证: 数字证书验证双方身份. 权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。
 - 完整性保护: 

具体细节可以参考[彻底搞懂HTTPS的加密原理](https://zhuanlan.zhihu.com/p/43789231)和[HTTP与HTTPS的区别](https://www.cnblogs.com/wqhwe/p/5407468.html).

https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。

1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接
2. Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。服务器第一次传给客户端的公钥其实包含在CA对网站信息进行加密的数字证书中
3. 客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
4. Web服务器利用自己的私钥解密出会话密钥。
5. Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。

客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）

## [TCP异常连接](https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html)

### 什么情况发送RST包

重建连接标识。当RST=1时，表明TCP连接中出现严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立连接。复位标志，用于非正常地关闭连接。它是TCP协议首部里的一个标志位。发送RST包关闭连接时，直接丢弃缓冲区的包发送RST包（这个和发FIN包不同）。而接收端收到RST包后，也不必发送ACK包来确认。

客户端和服务器TCP连接正常，突然服务器掉电重启，与客户端的TCP连接状态由于掉电而完全消失。之后，客户端发给服务器任何消息，都会触发服务器发RST作为回应。服务器之所以发RST，是因为连接不存在，通过Reset状态位，间接告诉客户端异常情况的存在。如果Reset顺利到达客户端，客户端意识到异常发生了，会立马释放该TCP连接所占用的内存资源（状态、数据）、以及端口号，且不会回复ACK

RST是客户端或服务器异常关闭tcp连接发的包，通常都是主机收到不存在的tcp通道的tcp报文，主机“被迫”回复RST告知对方tcp连接异常，收到RST的一方就会关闭这个socket，释放所有socket信息，且不会回复ACK

1. 连接未监听的端口：连接一个未监听的端口，则被连接方会发送一个RST。也就是说主机传输层TCP程序接收到一个SYN包，而这个SYN包目的端口并没有socket监听，那么主机的协议栈会直接回复一个RST
2. 目的主机或网络路径中的防火墙拦截：
3. socket接收缓冲区Recv-Q中的数据未完全被应用程序读取时关闭该socket：接收到的数据缓存在缓冲区Recv-Q，它们等待被上层应用取走，如果缓冲区Recv-Q有数据未被应用取走，而此时调用了socket.close()方法强行关闭TCP连接，那么TCP协议程序发送的就不是FIN，而是RST
4. 向已关闭的socket发送数据：主机传输层TCP协议程序接收到一条TCP数据报，而目的端口并没有socket监听，那么主机的协议栈会直接回复一个RST
5. 向已关闭的连接发送FIN：主机传输层TCP协议程序接收到一条FIN，而目的端口并没有socket监听，那么主机的协议栈会直接回复一个RST





 1. 未开启TCP keepalive，双方一直没有数据交互，客户端**主机崩溃**：服务器无法感知客户端崩溃，其TCP连接会一直处于`ESTABLISHED`状态，直到服务端重启进程。
 2. 未开启TCP keepalive，双方一直没有数据交互，客户端**进程崩溃**：客户端OS能够感知到进程崩溃，发送FIN报文，正常进行四次挥手。
 3. 未开启TCP keepalive，有数据交互，客户端**主机崩溃**，迅速重启：服务端发送的报文无法得到响应，触发超时重传机制，客户端重启完成后接收重传报文。此时如果客户端没有进程监听该报文的目标端口，客户端回复RST报文，断开连接；如果有进程监听，但是之前的TCP连接的数据结构已经丢失，客户端内核协议栈会发现找不到该TCP连接的socket结构体，回复RST报文，断开连接。
 4. 未开启TCP keepalive，有数据交互，客户端**主机崩溃**，一直没有重启：服务端超时重传达到最大次数后，内核判定该连接有问题，通过socket接口通知应用程序，断开连接。

## URL解析

 1. 域名解析，host使用DNS协议将URL解析为相应的IP
 2. host与server通过三次握手建立TCP连接
 3. 浏览器发送HTTP请求
 4. 服务器响应请求
 5. host接收响应并渲染


子网中第一个地址是网络地址，最后一个地址是广播地址

RST
 1. 直接丢弃缓冲区中的包发送RST
 2. 收到RST包不必回复ACK包

常见的发RST的情况：https://zhuanlan.zhihu.com/p/30791159
 1. SYN包试图连接一个没有任何服务监听的端口
 2. 收到了之前连接的包，但是该连接已经关闭
 


SYN泛洪攻击

服务器收到SYN连接请求后，分配缓冲区等资源，初始化连接变量。
如果客户端的第三次ACK没有收到，服务器首先会重传SYNACK，多次重传后服务器通常会在1min后终止半连接状态并且回收资源。

客户端可以发送大量的SYN段耗尽服务器的资源，合法的请求得不到响应，就是一种典型的DoS(Denial of Service)攻击。

一般通过SYN cookies预防：对比第一次和第三次握手hash值是否相同

HTTP状态码  
200 - 请求成功
301 - 资源（网页等）被永久转移到其它URL
400 - 请求无效
403 - 禁止访问
404 - 请求的资源（网页等）不存在
500 - 内部服务器错误

https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way

## HTTP请求
 1. 域名解析：首先在浏览器和OS的DNS缓存中查找，如果没有，向DNS服务器发起域名解析请求；
 2. 建立TCP连接；
 3. 发起HTTP请求；
 4. 服务器响应，浏览器获得并解析HTML，请求图片等资源，向用户渲染页面。

[状态码分类](https://www.runoob.com/http/http-status-codes.html)

## ICMP

验证网络是否畅通以及轨迹追踪，因为IP协议不提供可靠传输，如果丢包，IP并不能通知传输层是否丢包以及为何丢包，因此需要ICMP，网络层协议。

确认IP包是否成功到达目的地址  
通知在发送过程中IP包被丢弃的原因：目标不可达、源抑制、超时

ping traceroute

## 条件变量

用于多线程间状态的同步，控制其交替执行的先后顺序，条件不满足时相关线程阻塞，满足时唤醒，个人认为原理类似于线程间共享的全局变量，至于该变量如何工作还有待考究。

锁是用来保护共享资源，但是这两究竟有什么区别，为什么要同时使用，待确定。

lock guard构造时加锁，局部作用域结束析构释放锁，不够灵活。因此用unique lock

 shared和weak区别 循环引用导致内存泄漏
 
 GET：完整请求一个资源，没有请求数据
 POST：提交表单，文件等


[限流器](https://zhuanlan.zhihu.com/p/501400192)

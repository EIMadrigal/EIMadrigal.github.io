<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eimadrigal.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Hello World">
<meta property="og:type" content="website">
<meta property="og:title" content="EI Madrigal&#39;s Space">
<meta property="og:url" content="https://eimadrigal.github.io/page/10/index.html">
<meta property="og:site_name" content="EI Madrigal&#39;s Space">
<meta property="og:description" content="Hello World">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="EIMadrigal">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://eimadrigal.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>EI Madrigal's Space</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EI Madrigal's Space</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/26/Minimum%20Spanning%20Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/26/Minimum%20Spanning%20Tree/" class="post-title-link" itemprop="url">Minimum Spanning Tree</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-26 07:34:00" itemprop="dateCreated datePublished" datetime="2020-01-26T07:34:00+08:00">2020-01-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一prim">一、Prim</h2>
<p>Prim算法的思想是：</p>
<ol type="1">
<li>整个顶点集为<span class="math inline">\(V\)</span>，初始选一个起点<span class="math inline">\(s\)</span>，令集合<span class="math inline">\(u=\{s\}, v=\{\}\)</span>；</li>
<li>在集合<span class="math inline">\(u\)</span>与集合<span class="math inline">\(V-u\)</span>中的点组成的边中，选一条权值最小的边<span class="math inline">\(u_0v_0\)</span>加入MST，并且将<span class="math inline">\(u_0\)</span>加入<span class="math inline">\(u\)</span>；</li>
<li>重复直到MST有<span class="math inline">\(n-1\)</span>条边或<span class="math inline">\(n\)</span>个顶点为止。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> adjMax[MAXN][MAXN];  <span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;   <span class="comment">//顶点数目</span></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> visited[MAXN] = &#123;<span class="number">0</span>&#125;, cost[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cost[i] = adjMax[<span class="number">0</span>][i];  <span class="comment">//集合u与集合V-u中的i点间距离最小值</span></span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[<span class="number">0</span>] = <span class="literal">true</span>;   <span class="comment">//已经在MST中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)  <span class="comment">//再找n-1个点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到连接u和V-u的最小边并记录位置</span></span><br><span class="line">        <span class="keyword">int</span> tmp = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[j] == <span class="literal">false</span> &amp;&amp; cost[j] &lt; tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = cost[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += tmp;</span><br><span class="line">        visited[pos] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入某点后，V-u中的点j到u的距离可能变短，故更新cost[j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[j] == <span class="literal">false</span> &amp;&amp; cost[j] &gt; adjMax[pos][j])</span><br><span class="line">            &#123;</span><br><span class="line">                cost[j] = adjMax[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>性能：邻接矩阵表示不依赖于边数，复杂度<span class="math inline">\(O(|V|^2)\)</span>，适合边稠密的图。 ## 二、Kruskal 该算法思想：将所有边的权值递增排序，如果加入某边后不构成回路，则将该边加入MST，直到MST中有<span class="math inline">\(n-1\)</span>条边或<span class="math inline">\(n\)</span>个顶点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用结构体存储边的信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, des;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;edge[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//用并查集判断有没有环</span></span><br><span class="line"><span class="keyword">int</span> UFSets[MAXN];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    UFSets[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在S中查找并返回包含x的树的根</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (S[x] &gt;= <span class="number">0</span>)</span><br><span class="line">        x = S[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">find</span>(UFSets, edge[i].start);</span><br><span class="line">        <span class="keyword">int</span> v = <span class="built_in">find</span>(UFSets, edge[i].des);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u == v)  <span class="comment">//edge[i]的两端点有相同的祖先，成环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ans += edge[i].val;</span><br><span class="line">        UFSets[u] = v;  <span class="comment">//合并两个并查集</span></span><br><span class="line">        cnt++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>性能：复杂度<span class="math inline">\(O(ElogE)\)</span>，适合边稀疏、顶点多的图。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/18/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/18/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">贝叶斯学习</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-18 13:09:32" itemprop="dateCreated datePublished" datetime="2020-01-18T13:09:32+08:00">2020-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介">简介</h2>
<p>贝叶斯概率理论是由Thomas Bayes在1764年提出，采用一种概率的方式进行推理。贝叶斯学习有2个假设： - 观察到的样本实例并非确定性事件，而是随机的，服从某种概率分布； - 通过对观测数据样本和相关的概率特性进行推理学习能够得到最优的决策或分类。</p>
<p>贝叶斯学习为衡量多个假设的置信度提供了定量的方法，其依赖于贝叶斯决策理论（Bayesian Decision Theory）。贝叶斯决策理论是一种统计学上的方法，用来定量化地描述使用概率做出的不同决策以及这些决策付出的代价之间的权衡。首先假设一些概率值是已知的，然后根据这些已知概率推理一些未知情况下的概率值，最终利用这些推理的概率值进行决策。</p>
<p>以分类问题为例，假设有2种鱼分别是鲑鱼和鲈鱼，将w定义为观测到的鱼的类型，令<span class="math inline">\(w=w_1\)</span>代表鲈鱼，<span class="math inline">\(w=w_2\)</span>代表鲑鱼，定义<span class="math inline">\(P(w_1)\)</span>表示下一条鱼是鲈鱼的先验概率，<span class="math inline">\(P(w_2)\)</span>表示下一条鱼是鲑鱼的先验概率。先验概率反映了人们根据经验和背景知识对事物的判断，即在看到下一条鱼之前对于<span class="math inline">\(P(w_1)\)</span>和<span class="math inline">\(P(w_2)\)</span>的判断。如果没有经验上的偏好，就可以设置为均匀先验<span class="math inline">\(P(w_1)=P(w_2)\)</span>；如果有诸如海域因素、时间等背景，便可以为<span class="math inline">\(P(w_1)\)</span>和<span class="math inline">\(P(w_2)\)</span>设置不同的先验概率。另外假设只有这2种鱼，即<span class="math inline">\(P(w_1)+P(w_2)=1\)</span>。在仅有先验概率的情况下，选择先验概率大的作为最终决策，这种情况下决策错误的概率为<span class="math inline">\(min\{P(w_1),P(w_2)\}\)</span>。</p>
<p>贝叶斯决策理论是很多重要的学习算法的基础，例如朴素贝叶斯分类器、贝叶斯信念网络以及EM算法等。另外，贝叶斯决策理论为许多非贝叶斯的学习算法提供了很好的数学和框架性理论基础，对某些学习任务而言，贝叶斯学习是最实用的方法之一。</p>
<p>贝叶斯学习有以下特点： - 每个观测到的训练样本都可以很小程度上增大或减小某个假设正确的概率； - 先验知识可以和观测数据结合起来决定某个假设的最终概率，可以计算显式的假设概率； - 新实例的预测可以结合多个假设输出概率的加权值； - 通常需要一些背景知识或先前经验来确定先验概率，选出贝叶斯最优分类器计算代价比较大。</p>
<h2 id="贝叶斯定理">贝叶斯定理</h2>
<p>贝叶斯定理是贝叶斯学习的基石，给定训练数据集D，在假设空间H中寻找最优的假设h，最优假设可以定义为给定数据集D以及H中不同假设的先验概率条件下的最可能的假设。 利用贝叶斯定理，在已知假设的先验概率、观测数据以及给定假设下观测到特定数据的概率就可以计算出最有可能的假设。</p>
<p>给定数据集D以及假设空间H，定义如下记号： - 先验概率P(h)：没有训练数据前假设h的初始概率，反映了根据人们的相关认知背景，假设h成为正确假设的概率，如果没有先验知识，可以将每一个候选假设的先验概率设置为相同的。 - 先验概率P(D)：训练数据D的先验概率，即不知道哪个假设成立的前提下观测到D的概率。 - 观测数据的条件概率P(D|h)：在假设h成立的条件下观测到数据集D的概率。 - 后验概率P(h|D)：给定观测到的训练数据集D时假设h成立的概率，反映了观测到的训练数据是D时h成立的置信度。</p>
<p>利用贝叶斯定理可以计算给定训练数据集D下任一假设的后验概率： <span class="math display">\[P(h|D)=\frac{P(D|h)P(h)}{P(D)}\]</span></p>
<p>贝叶斯推理得到的结果很大程度上依赖于先验概率，并且不是完全接受或拒绝假设h，而是给出假设为真的可能性。因此可以计算每个假设的概率，输出其中概率最大的，称为最大后验概率准则（Maximum A Posteriori）。</p>
<p><span class="math display">\[
h_{MAP}=\underset{h\in H}{\operatorname{\argmax}}\ P(h|D) \\
=\underset{h\in H}{\operatorname{\argmax}}\ \frac{P(D|h)P(h)}{P(D)} \\
=\underset{h\in H}{\operatorname{\argmax}}\ P(D|h)P(h)
\]</span></p>
<p>如果假设空间中每个假设的先验概率都是相同的，即<span class="math inline">\(P(h_i)=P(h_j),\forall h_i\in H \wedge \forall h_j\in H\)</span>，那么只需要考虑给定假设h下数据D的似然P(D|h)，这样最大后验概率准则就变为了最大似然估计（Maximum Likelihood）： <span class="math display">\[
h_{ML}=\underset{h\in H}{\operatorname{\argmax}}\ P(D|h)
\]</span></p>
<h2 id="最小描述长度原则">最小描述长度原则</h2>
<p>根据奥卡姆剃刀原则，其它条件相同时选择最简单的假设，最简单的假设可以定义为描述长度最小的假设，即给定假设空间H和数据集D，应该寻找一个假设或者假设组合使得D被最大程度地压缩。定义<span class="math inline">\(L_{C}(x)\)</span>表示在编码机制C下编码x需要的最少的比特数为编码机制C下的x的描述长度。 <span class="math display">\[
h_{MDL}=\underset{h\in H}{\operatorname{\argmin}}\ L_{C_1}(h)+L_{C_2}(D|h)
\]</span></p>
<p><span class="math inline">\(L_{C_1}(h)\)</span>是假设的描述长度即比特数，反映了模型的复杂程度；<span class="math inline">\(L_{C_2}(D|h)\)</span>是当采用假设h编码后数据的描述长度，反映了错误的数目。通常会发现：一个非常复杂的假设（<span class="math inline">\(L_{C_1}(h)\)</span>大）会有一个比较好的拟合（<span class="math inline">\(L_{C_2}(D|h)\)</span>小），反之一个非常简单的假设（<span class="math inline">\(L_{C_1}(h)\)</span>小）会有比较差的拟合（<span class="math inline">\(L_{C_2}(D|h)\)</span>大）。因此希望寻找一个假设：既不会过于复杂同时还可以对数据有比较好的拟合。</p>
<p>如果对MAP的公式进行变形： <span class="math display">\[
h_{MAP}=\underset{h\in H}{\operatorname{\argmax}}\ P(D|h)P(h) \\
=\underset{h\in H}{\operatorname{\argmax}}\ log_2P(D|h)+log_2P(h) \\
=\underset{h\in H}{\operatorname{\argmin}}\ -log_2P(h)-log_2P(D|h) \\
\]</span></p>
<p>可以看到：第一项<span class="math inline">\(-log_2P(h)\)</span>对应了最优编码机制<span class="math inline">\(C_1\)</span>下h的描述长度<span class="math inline">\(L_{C_1}(h)\)</span>，第二项<span class="math inline">\(-log_2P(D|h)\)</span>对应了最优编码机制<span class="math inline">\(C_2\)</span>下数据的描述长度<span class="math inline">\(L_{C_2}(D|h)\)</span>。两者的优化目标是一致的。</p>
<h2 id="贝叶斯最优分类器">贝叶斯最优分类器</h2>
<p>通过MAP准则可以求出在给定训练数据下的最有可能的假设，那么如何求出给定训练集下一个新实例的最优预测呢？可以对新实例使用MAP准则，求得最大的假设然后进行分类。</p>
<p>但是最优的结果应该是结合所有假设的预测结果对新实例进行分类，结合的方法是通过后验概率加权： <span class="math display">\[
\underset{v_j\in V}{\operatorname{\argmax}}\ \sum_{h_i\in H}P(v_j|h_i)P(h_i|D)
\]</span></p>
<p>V表示所有可能的预测结果，<span class="math inline">\(v_j\)</span>是其中一种预测分类。<span class="math inline">\(P(v_j|h_i)\)</span>表示假设<span class="math inline">\(h_i\)</span>将新实例预测为<span class="math inline">\(v_j\)</span>的概率大小，<span class="math inline">\(P(h_i|D)\)</span>表示假设<span class="math inline">\(h_i\)</span>的后验概率。</p>
<p>例如假设空间<span class="math inline">\(H=\{h_1,h_2,h_3\}\)</span>，可能的预测结果<span class="math inline">\(V=\{+,-\}\)</span>，对于一个新实例假设有： <span class="math display">\[
P(h_1|D)=0.4, P(-|h_1)=0, P(+|h_1)=1 \\
P(h_2|D)=0.3, P(-|h_2)=1, P(+|h_2)=0 \\
P(h_3|D)=0.3, P(-|h_3)=1, P(+|h_3)=0 \\
\]</span></p>
<p>那么有： <span class="math display">\[
\sum_{h_i\in H}P(+|h_i)P(h_i|D)=0.4 \\
\sum_{h_i\in H}P(-|h_i)P(h_i|D)=0.6 \\
\]</span> 因此最终选择将新实例分类为-。</p>
<p>可以看到：贝叶斯最优分类器最大化了新实例被正确分类的概率，在使用相同假设空间和先验知识的条件下，没有其他方法比贝叶斯最优分类器的平均效果好，最终的预测结果可能对应一个不包含于<span class="math inline">\(H\)</span>的假设。</p>
<p>虽然效果很好，但是贝叶斯最优分类器计算代价非常大： - 需要遍历假设空间中的所有假设； - 当假设空间非常大时这种方式是不可行的。</p>
<p>因此可以通过吉布斯算法（Gibbs）解决。吉布斯算法根据假设的后验概率分布随机选取一个假设对新实例进行分类。可以证明：在特定条件下，该方法的期望误差最多是贝叶斯最优分类器的两倍。还可以通过采样多个假设并求其预测结果的平均值来提高吉布斯算法的性能，例如可以使用马尔科夫蒙特卡洛采样（MCMC）。</p>
<h2 id="bagging分类器">Bagging分类器</h2>
<p>虽然可以使用吉布斯算法来降低计算代价，但是从后验概率分布P(h|D)采样是比较困难的： - P(h|D)的计算本身就比较困难 - 对于不是基于概率的分类器例如SVM等P(h|D)是无法计算的 - 当假设空间很大时P(h|D)计算结果会很小</p>
<p>为了解决上述问题，引入Bagging的思想，通过对训练样本的采样实现对后验分布P(h|D)的采样。假设给定的数据集D包含m个样本，自助采样法（Bootstrap sampling）步骤如下： - 从D中有放回地采样m个样本构成数据集<span class="math inline">\(D^i\)</span> - D中大约有37%的样本不会被采样到</p>
<p>Bagging算法步骤如下： - 创建k个自助采样的数据集<span class="math inline">\(D^1,D^2,...,D^k\)</span> - 在每个数据集<span class="math inline">\(D^i\)</span>独立训练分类器<span class="math inline">\(h_i\)</span> - 通过相等权重的投票法来对新实例进行分类：</p>
<p><span class="math display">\[
c^*(x)=\underset{c}{\operatorname{\argmax}}\ \sum_{i=1}^{k}P(c|h_i,x)
\]</span> 由于自助采样法几乎和直接从后验概率分布P(h|D)采样相同，因此Bagging产生的分类器也近似于贝叶斯最优分类器。通常Bagging产生的分类器效果要优于单独的分类器，因为其有效地降低了模型的方差。</p>
<h2 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h2>
<p>假设训练集D中的每条实例x均可以被n个属性的组合<span class="math inline">\(&lt;a_1,a_2,...,a_n&gt;\)</span>描述，并且<span class="math inline">\(v(x)\in V\)</span>是一个有限的集合。那么贝叶斯方法对于新实例的分类是选择一个最有可能的目标值： <span class="math display">\[
v_{MAP}=\underset{v_j\in V}{\operatorname{\argmax}}\ P(v_j|a_1,a_2,...,a_n)
\]</span></p>
<p>通过贝叶斯定理进行变形： <span class="math display">\[
v_{MAP}=\underset{v_j\in V}{\operatorname{\argmax}}\ \frac{P(a_1,a_2,...,a_n|v_j)P(v_j)}{P(a_1,a_2,...,a_n)}
\]</span></p>
<p>那么要如何计算<span class="math inline">\(P(v_j)\)</span>和<span class="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>呢？ - <span class="math inline">\(P(v_j)\)</span>可以通过每个目标值<span class="math inline">\(v_j\)</span>在训练数据中出现的频率来估算 - 在训练数据集很小的情况下，<span class="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>的估算是不可能的，不同的<span class="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>的数目等于所有可能的目标值的数量与所有可能的样本数目的乘积。</p>
<p>为了解决上述问题，提出了朴素贝叶斯假设，即在给定目标值下样本属性之间是条件独立的： <span class="math display">\[
P(a_1,a_2,...,a_n|v_j)=\prod_{i}P(a_i|v_j)
\]</span></p>
<p>因此朴素贝叶斯分类器即为： <span class="math display">\[
v_{NB}=\underset{v_j\in V}{\operatorname{\argmax}}\ P(v_j)\prod_{i}P(a_i|v_j)
\]</span></p>
<p>其中，<span class="math inline">\(v_{NB}\)</span>是朴素贝叶斯分类器的预测输出，<span class="math inline">\(P(a_i|v_j)\)</span>是训练数据中目标值<span class="math inline">\(v_j\)</span>时属性<span class="math inline">\(a_i\)</span>的频率。不同的<span class="math inline">\(P(a_i|v_j)\)</span>的数目等于不同的目标值数量与属性数量的乘积，该数值远小于不同的<span class="math inline">\(P(a_1,a_2,...,a_n|v_j)\)</span>的数目。</p>
<p>下面举一个朴素贝叶斯分类器的例子，假设训练数据如下： <img src="https://img-blog.csdnimg.cn/286e8b45687d4d259b1ef6ba87433c2f.png" alt="在这里插入图片描述" /></p>
<p>需要对于一个新实例{Outlook=sunny, Temperature=cool, Humidity=high, Wind=strong}进行分类，所有可能的目标值是{yes, no}。因此分类器为： <span class="math display">\[
v_{NB}=\underset{v_j\in \{yes,no\}}{\operatorname{\argmax}}\ P(v_j)\prod_{i}P(a_i|v_j)
\]</span></p>
<p>从训练数据可知，<span class="math inline">\(P(v_j)\)</span>即不同目标值的概率为： <span class="math display">\[
P(yes)=9/14=0.64, P(no)=5/14=0.36
\]</span></p>
<p>条件概率<span class="math inline">\(P(a_i|v_j)\)</span>为： <span class="math display">\[
P(Wind=strong|yes)=3/9=0.33 \\
P(Wind=strong|no)=3/5=0.60 \\
...
\]</span></p>
<p>因此可以计算： <span class="math display">\[
P(yes)P(sunny|yes)P(cool|yes)P(high|yes)P(strong|yes)=0.0053 \\
P(no)P(sunny|no)P(cool|no)P(high|no)P(strong|no)=0.0206 \\
\]</span></p>
<p>故最终的预测结果为no。</p>
<h2 id="贝叶斯信念网络">贝叶斯信念网络</h2>
<p>贝叶斯最优分类器应用起来代价太大，朴素贝叶斯分类器虽然使用条件独立假设降低了代价，但是很多情况下条件独立假设都难以满足。因此，贝叶斯信念网络做了一个折衷，允许对属性集合的子集应用条件独立假设。</p>
<p>贝叶斯信念网络是一种概率图模型，通过有向无环图（DAG）来表示一系列变量及它们的条件依赖关系和变量集合的联合概率分布。通常用结点表示变量，可以是观测变量、隐藏变量、未知参数和假设等等；用边表示结点间的依赖关系；条件概率表的每个元素对应图中唯一的结点，存储该结点对于其所有直接前驱结点的联合条件概率。</p>
<p>贝叶斯信念网络一条非常重要的性质是：每个结点在其直接前驱结点的值给定后，该结点条件独立于其所有非直接前驱结点。条件独立的定义是：在给定Z的条件下X的概率分布与Y的取值无关，即： <span class="math display">\[
\forall x_i,y_j,z_k\ P(X=x_i|Y=y_j,Z=z_k)=P(X=x_i|Z=z_k)
\]</span></p>
<p>条件独立的定义可以扩展到多个变量的情形：即在给定变量<span class="math inline">\(Z_1,...,Z_n\)</span>的条件下，变量集合<span class="math inline">\(X_1,...,X_l\)</span>的概率分布与变量集合<span class="math inline">\(Y_1,...,Y_m\)</span>的取值无关： <span class="math display">\[
P(X_1,...,X_l|Y_1,...,Y_m,Z_1,...,Z_n)=P(X_1,...,X_l|Z_1,...,Z_n)
\]</span></p>
<p>朴素贝叶斯分类器即使用了条件独立假设使得<span class="math inline">\(P(X,Y|Z)=P(X|Y,Z)P(Y|Z)=P(X|Z)P(Y|Z)\)</span>。</p>
<p>贝叶斯网络也可以看作是表示变量之间因果性的因果图，可以进行原因推理或结果预测。例如，假设草坪是湿的记作变量W，那么有多大概率是因为下雨（记作变量R）造成的？那么可以利用贝叶斯网络进行原因推理： <span class="math display">\[
P(R|W)=\frac{P(W|R)P(R)}{P(W)}=\frac{P(W|R)P(R)}{P(W|R)P(R)+P(W|\sim R)P(\sim R)}
\]</span></p>
<p>同样可以进行结果的预测，假设洒水器打开记作事件S，那么有多大概率草坪是湿的是因为S导致的？即洒水器和下雨都可能导致草坪是湿的： <span class="math display">\[
P(W|S)=P(W|R,S)P(R|S)+P(W|\sim R,S)P(\sim R|S) \\
=P(W|R,S)P(R)+P(W|\sim R,S)P(\sim R)
\]</span></p>
<p>随着贝叶斯网络的结点与边的增加，可以进行更加复杂的因果推断。</p>
<h2 id="总结">总结</h2>
<p>贝叶斯学习为基于先验知识的概率学习方法提供了理论基础，在先验知识的基础上，根据观测数据修正先验知识，计算出每个假设的后验概率进而进行预测。可以选择出在给定观测数据下的最有可能的假设即MAP假设，贝叶斯最优分类器通过后验概率的加权结合了所有可能假设的预测结果去得到新实例的最有可能的预测结果。朴素贝叶斯分类器通过条件独立假设增强了其实用性，在很多实际应用中表现很好。贝叶斯信念网络提供了一种条件独立的变量之间更强大的表示方法，使得其可以有更加广泛的应用场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/15/Segment%20Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/15/Segment%20Tree/" class="post-title-link" itemprop="url">Segment Tree</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-15 10:38:00" itemprop="dateCreated datePublished" datetime="2020-01-15T10:38:00+08:00">2020-01-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>线段树</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/15/Segment%20Tree/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/13/Binary%20Index%20Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/13/Binary%20Index%20Tree/" class="post-title-link" itemprop="url">Binary Indexed Tree</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 16:37:00" itemprop="dateCreated datePublished" datetime="2020-01-13T16:37:00+08:00">2020-01-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>树状数组</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/13/Binary%20Index%20Tree/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/11/Binary%20Search/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/11/Binary%20Search/" class="post-title-link" itemprop="url">Binary Search</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-11 15:17:00" itemprop="dateCreated datePublished" datetime="2020-01-11T15:17:00+08:00">2020-01-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>二分查找</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/01/11/Binary%20Search/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/10/Regular%20Expression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/Regular%20Expression/" class="post-title-link" itemprop="url">Regular Expression</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 03:48:00" itemprop="dateCreated datePublished" datetime="2020-01-10T03:48:00+08:00">2020-01-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。</p>
</blockquote>
<p>先看一个判断Email地址是否合法的例子： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\\w+@\\w+(\\.\\w&#123;2,3&#125;)*\\.\\w&#123;2,3&#125;&quot;</span></span><br></pre></td></tr></table></figure> 一般Email地址的格式为：<code>X@X.com</code>，<code>X</code>表示一个或多个字符，<code>.com</code>后面可能还会跟有<code>.cn</code>等。总结这些规律，我们用上述的regex来匹配。 当然，这种匹配可能会遗漏某些特殊的Email地址，想要更大范围的覆盖，还需要更为复杂精巧的设计。 接着解释下上面的regex： <code>\\w</code>表示匹配字母/数字/下划线/汉字； <code>+</code>表示字符可以出现一次/多次； <code>(\\.\\w&#123;2,3&#125;)*</code>表示类似<code>.edu</code>格式的字符串可以出现零次/多次。 <code>\</code>在计算机科学中一般表示转义，形如<code>\w</code>的叫做<strong>元字符</strong>，类似的还有：</p>
<table>
<thead>
<tr class="header">
<th>元字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.</td>
<td>除换行符外任意字符</td>
</tr>
<tr class="even">
<td></td>
<td>数字</td>
</tr>
<tr class="odd">
<td></td>
<td>字母/数字/汉字/下划线</td>
</tr>
<tr class="even">
<td></td>
<td>单词的开始/结束</td>
</tr>
<tr class="odd">
<td>^</td>
<td>字符串的开始</td>
</tr>
<tr class="even">
<td>$</td>
<td>字符串的结束</td>
</tr>
</tbody>
</table>
<p>还可以通过<code>[]</code>表示元字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;[abc]23&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样<code>a23</code>，<code>b23</code>，<code>c23</code>都是匹配的字符串。 形如<code>+</code>，<code>*</code>叫做<strong>修饰限定符</strong>，用来控制某类串重复多少次：</p>
<table>
<thead>
<tr class="header">
<th>修饰限定符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>*</td>
<td>0次/多次</td>
</tr>
<tr class="even">
<td>+</td>
<td>1次/多次</td>
</tr>
<tr class="odd">
<td>？</td>
<td>0次/1次</td>
</tr>
<tr class="even">
<td>{n}</td>
<td>n次</td>
</tr>
<tr class="odd">
<td>{n,}</td>
<td>n次/更多次</td>
</tr>
<tr class="even">
<td>{n,m}</td>
<td>n~m次</td>
</tr>
</tbody>
</table>
<p>很多语言和文本编辑器都集成了正则表达式引擎，以Java为例来测试下上述例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String regex = <span class="string">&quot;\\w+@\\w+(\\.\\w&#123;2,3&#125;)*\\.\\w&#123;2,3&#125;&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;hello@stu.edu.cn&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.matches(regex))</span><br><span class="line">            System.out.println(<span class="string">&quot;Valid Address!&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述内容只是最最基本的关于正则表达式的知识，还有零宽断言、递归匹配等更加复杂的内容有待挖掘~</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/06/Dynamic%20Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/06/Dynamic%20Programming/" class="post-title-link" itemprop="url">Dynamic Programming</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-06 13:04:00" itemprop="dateCreated datePublished" datetime="2020-01-06T13:04:00+08:00">2020-01-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>DP是算法学习中非常重要的一种思想，关于动态规划的解释，可以参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23995189/answer/613096905?hb_wx_block=1">这篇文章</a>。 ## 概念 使用DP三个条件：</p>
<ol type="1">
<li>最优子结构：待解决的问题可以被分解为若干子问题，并且递归地找到子问题的最优解；</li>
<li>重叠子问题：在解决子问题的过程中，很多子问题都会被求解多次，第一次计算后存储该子问题的解，以后就可以直接使用，即降低了时间复杂度。如果子问题没有重叠，那么这就是<strong>分治</strong>的问题；</li>
<li>无后效性：子问题的最优解是确定的，完全可以用来解决更大的子问题。</li>
</ol>
<p>DP一般有两种形式：</p>
<ul>
<li>Top-down: 记忆化递归可能stackoverflow</li>
<li>Bottom-up</li>
</ul>
<p>模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化递归</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>=&quot;&quot;&gt; hash;               <span class="comment">// memory dict</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(i, j, ...)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">base_case</span><span class="params">(i, j)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">return</span> ...</span>;</span><br><span class="line">    <span class="keyword">if</span> (i, j) <span class="keyword">not</span> in hash</span><br><span class="line">        hash[(i, j)] = ...;</span><br><span class="line">    <span class="keyword">return</span> hash[(i, j)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">f</span>(n, m);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DP</span></span><br><span class="line"><span class="keyword">int</span> dp[][];   <span class="comment">// need padding sometimes</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = ...;   <span class="comment">// base case</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j =  <span class="number">0</span>;j &lt; m;++j)</span><br><span class="line">        dp[i][j] = ...                <span class="comment">// 状态转移</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[n][m];</span><br></pre></td></tr></table></figure>
<h2 id="分类">分类</h2>
<ul>
<li>基础题：LeetCode 509/70/746/62/63/343/96/<a target="_blank" rel="noopener" href="https://www.cnblogs.com/EIMadrigal/p/11478906.html">Fibonacci</a></li>
<li>背包问题：
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/EIMadrigal/p/12345051.html">0/1 Knapsack</a>：LeetCode 416/1049/494/474</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/EIMadrigal/p/12345051.html">Unbounded Knapsack</a>：LeetCode 518/377/70/322/279/139</li>
</ul></li>
<li>House Thief：LeetCode 198/213/337</li>
<li>股票问题：LeetCode 121/122/123/188/309/714</li>
<li>Longest Common Substring/Subsequeunce：LeetCode 300/1143/1035/674/718/53/392/115/583/72/647/516</li>
</ul>
<h2 id="步骤">步骤</h2>
<p>一般来讲，都是通过暴力-&gt;记忆化递归-&gt;Bottom-up三部曲，当然熟悉后可以快速判断这是一个DP问题，然后直接写出Bottom-up的解法。 我个人认为最难的一步在于判断出你的暴力解法满足DP的性质（你要能认出来这是一个DP问题），可以用DP去优化暴力解法。 - 确定问题分类 - 确定状态：需要几个变量来跟踪目前的状态，一般来讲至少需要index，因为这决定了我们已经考虑过了哪些值，没考虑哪些值，正在考虑哪些值。选定的变量组合要能唯一确定一个状态 - 状态转移：为了达到base case，当前状态怎么才能由之前的状态得到。也就是Top-down逐渐分解问题，每一次递归调用都会分解一下 - base case：一般比较简单，不废话了 - code：思路清楚了，也不难 - 优化：一般优化空间复杂度</p>
<h2 id="ref">Ref</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/target-sum/discuss/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions.">DP IS EASY! 5 Steps to Think Through DP Questions.</a> &lt;/int,&gt;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/01/%E7%95%99%E7%99%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/%E7%95%99%E7%99%BD/" class="post-title-link" itemprop="url">留白</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-01 15:17:00" itemprop="dateCreated datePublished" datetime="2020-01-01T15:17:00+08:00">2020-01-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>hello</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/01/%E4%BB%80%E4%B9%88%E6%98%AFP%E9%97%AE%E9%A2%98%E3%80%81NP%E9%97%AE%E9%A2%98%E5%92%8CNPC%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/%E4%BB%80%E4%B9%88%E6%98%AFP%E9%97%AE%E9%A2%98%E3%80%81NP%E9%97%AE%E9%A2%98%E5%92%8CNPC%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">什么是P问题、NP问题和NPC问题</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-01 15:12:00" itemprop="dateCreated datePublished" datetime="2020-01-01T15:12:00+08:00">2020-01-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很久之前观看WJMZBMR特奖答辩时听到了<span class="math inline">\(P!=NP\)</span>，一直似懂非懂，看了Matrix67的<a target="_blank" rel="noopener" href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a>，<del>特意作文纪念</del> 。</p>
<p>一张图就可以解释三者间的关系：<img src="https://img-blog.csdnimg.cn/20190728150856295.png" alt="在这里插入图片描述" /> ## 什么是P问题、NP问题和NPC问题 这或许是众多OIer最大的误区之一。 你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是NPC问题是一个多大的错误。</p>
<p>还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有<span class="math inline">\(O(1)\)</span>的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是<span class="math inline">\(O(n)\)</span>，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于<span class="math inline">\(O(n^2)\)</span>的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是<span class="math inline">\(O(a^n)\)</span>的指数级复杂度，甚至<span class="math inline">\(O(n!)\)</span>的阶乘级复杂度。不会存在<span class="math inline">\(O(2*n^2)\)</span>的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，<span class="math inline">\(O (n^3+n^2)\)</span>的复杂度也就是<span class="math inline">\(O(n^3)\)</span>的复杂度。因此，我们会说，一个<span class="math inline">\(O(0.01*n^3)\)</span>的程序的效率比<span class="math inline">\(O(100*n^2)\)</span>的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终<span class="math inline">\(O(n^3)\)</span>的复杂度将远远超过<span class="math inline">\(O(n^2)\)</span>。我们也说，<span class="math inline">\(O(n^{100})\)</span>的复杂度小于<span class="math inline">\(O(1.01^n)\)</span>的复杂度。</p>
<p>容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是<span class="math inline">\(O(1),O(log(n)),O(n^a)\)</span>等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是<span class="math inline">\(O(a^n)\)</span>和<span class="math inline">\(O(n!)\)</span>型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p>
<p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。The Halting Problem就是一个著名的不可解问题，在我的Blog上有过专门的介绍和证明。再比如，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p>
<p>下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。哪些问题是P类问题呢？通常NOI和NOIP不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。</p>
<p>接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100 小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。</p>
<p>之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。</p>
<p>很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。</p>
<p>NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。</p>
<p>目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p>
<p>为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。</p>
<p>简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。</p>
<p>“问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。</p>
<p>很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。</p>
<p>现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。</p>
<p>当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p>
<p>好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p>
<p>NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</p>
<p>既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p>
<p>顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p>
<p>不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。下文即将介绍它。</p>
<p>下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。</p>
<p>逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。 什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。 <img src="https://img-blog.csdnimg.cn/20190728155740104.png" alt="在这里插入图片描述" /> 这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。</p>
<p>有输出无论如何都不可能为True的逻辑电路吗？有。下面就是一个简单的例子。 <img src="https://img-blog.csdnimg.cn/20190728155803196.png" alt="在这里插入图片描述" /> 上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。</p>
<p>回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。</p>
<p>逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。</p>
<p>有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/01/Pointers%20and%20Memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/Pointers%20and%20Memory/" class="post-title-link" itemprop="url">Pointers and Memory</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-01 15:07:00" itemprop="dateCreated datePublished" datetime="2020-01-01T15:07:00+08:00">2020-01-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><em>Stanford CS Education Library #102</em> ## Basic Pointers 指针主要有两个用途：使不同的代码段共享信息、方便链表（树）的处理。 指针示意图： <img src="https://img-blog.csdnimg.cn/2019041619200938.png" alt="在这里插入图片描述" /> <code>dereference</code>操作会根据指针的值去找到它的<code>pointee</code>。 <code>NULL</code>是一个特殊的指针值（一般是地址0），表示这个指针不指向任何<code>pointee</code>。 <img src="https://img-blog.csdnimg.cn/20190416193109659.png" alt="在这里插入图片描述" /> 指针的赋值会使得两个指针指向相同的<code>pointee</code>，但<code>pointee</code>本身不会改变： <img src="https://img-blog.csdnimg.cn/20190416192708547.png" alt="在这里插入图片描述" /> 传指针vs传值： <img src="https://img-blog.csdnimg.cn/20190416193445969.png" alt="在这里插入图片描述" /> 定义一个指针后，这个指针是没有被初始化的： <img src="https://img-blog.csdnimg.cn/2019041619372662.png" alt="在这里插入图片描述" /> 这时候如果进行<code>dereference</code>操作会发生Runtime Error. 对于Java、LISP等语言，当定义一个指针时，系统会将其设置为<code>NULL</code>，并且会在<code>dereference</code>操作时检查其值，这也是Java比较慢的原因之一。 <img src="https://img-blog.csdnimg.cn/20190416194404553.png" alt="在这里插入图片描述" /> 一个比较典型的指针错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BadPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p;  <span class="comment">//allocate the pointer, but not the pointee</span></span><br><span class="line">    *p = <span class="number">42</span>; <span class="comment">//serious RE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行<code>*p</code>时： <img src="https://img-blog.csdnimg.cn/20190416195104100.png" alt="在这里插入图片描述" /></p>
<h2 id="local-memory">Local Memory</h2>
<p>函数开始运行时，会为局部变量分配内存，结束运行会回收内存。 看一个错误的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TAB -- The Ampersand Bug function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">TAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">return</span> (&amp;temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Victim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ptr;</span><br><span class="line">    ptr = TAB();</span><br><span class="line">    *ptr = <span class="number">42</span>;    <span class="comment">//The pointee was local to TAB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题在于<code>TAB()</code>返回了一个局部变量的地址，但这个局部变量的空间已经被回收，<code>ptr</code>指针没有<code>pointee</code>。</p>
<h2 id="reference-parameters">Reference Parameters</h2>
<p>传值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> worth)</span> </span>&#123;</span><br><span class="line">    worth++;</span><br><span class="line">    <span class="comment">// T2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> netWorth = <span class="number">55</span>;  <span class="comment">//T1</span></span><br><span class="line">    B(netWorth);</span><br><span class="line">    <span class="comment">// T3 -- B() did not change netWorth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190416203356234.png" alt="在这里插入图片描述" /> 传指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>* worthRef)</span> </span>&#123;</span><br><span class="line">    (*worthRef)++;</span><br><span class="line">    <span class="comment">// T2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> netWorth = <span class="number">55</span>;  <span class="comment">//T1</span></span><br><span class="line">    B(&amp;netWorth);</span><br><span class="line">    <span class="comment">// T3</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190416203939385.png" alt="在这里插入图片描述" /> 传指针在c++中可以通过<strong>传引用</strong>的方式实现： <img src="https://img-blog.csdnimg.cn/20190416205349526.png" alt="在这里插入图片描述" /></p>
<h2 id="heap-memory">Heap Memory</h2>
<p>分配示意图： <img src="https://img-blog.csdnimg.cn/20190416205821650.png" alt="在这里插入图片描述" /> 释放示意图： <img src="https://img-blog.csdnimg.cn/20190416210059909.png" alt="在这里插入图片描述" /> 释放后，指针虽然还在，但却不可以在使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size以字节为单位，分配成功返回指针，失败返回NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要size，因为heap manager之前已经记录过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* heapBlockPointer)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190416211219354.png" alt="在这里插入图片描述" /> <img src="https://img-blog.csdnimg.cn/20190416211242340.png" alt="在这里插入图片描述" /> 一个<code>StringCopy()</code>的例子： <img src="https://img-blog.csdnimg.cn/20190416211900707.png" alt="在这里插入图片描述" /> 对于分配的堆内存，只有一个负责释放的，要么是<code>caller</code>，要么是<code>callee</code>： <img src="https://img-blog.csdnimg.cn/20190416212610387.png" alt="在这里插入图片描述" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EIMadrigal"
      src="/images/favicon.png">
  <p class="site-author-name" itemprop="name">EIMadrigal</p>
  <div class="site-description" itemprop="description">Hello World</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">172</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/EIMadrigal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:andrew.renj@gmail.com" title="E-Mail → mailto:andrew.renj@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/EIMadrigal" title="cnblogs → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-codiepie fa-fw"></i>cnblogs</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/EIMadrigal" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EIMadrigal</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">Total views: <span id="busuanzi_value_site_pv"></span></span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">Total visitors: <span id="busuanzi_value_site_uv"></span></span>
    <span class="post-meta-divider">|</span>

<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);
    var countOffset = 20000;

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset);
            clearInterval(int);
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>

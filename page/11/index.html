<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eimadrigal.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Hello World">
<meta property="og:type" content="website">
<meta property="og:title" content="EI Madrigal&#39;s Space">
<meta property="og:url" content="https://eimadrigal.github.io/page/11/index.html">
<meta property="og:site_name" content="EI Madrigal&#39;s Space">
<meta property="og:description" content="Hello World">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="EIMadrigal">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://eimadrigal.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>EI Madrigal's Space</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EI Madrigal's Space</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/01/Linked%20List-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/Linked%20List-2/" class="post-title-link" itemprop="url">Linked List-2</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-01 15:03:00" itemprop="dateCreated datePublished" datetime="2020-01-01T15:03:00+08:00">2020-01-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="三编码技巧">三、编码技巧</h2>
<p><strong>1、遍历链表</strong> 先将<code>head</code>指针赋值给一个局部变量<code>current</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//return the number of nodes in a list (while-loop version)</span><br><span class="line">int Length(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    struct node* current = head;</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (current = head; current != NULL; current = current-&gt;next) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、通过传递<code>reference pointer</code>改变某个指针</strong> 看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Change the passed in head pointer to be NULL</span><br><span class="line">//Uses a reference pointer to access the caller&#x27;s memory</span><br><span class="line">void ChangeToNull(struct node** headRef)  //takes a pointer to the value of interest</span><br><span class="line">&#123;</span><br><span class="line">    *headRef = NULL;	//use * to access the value of interest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ChangeCaller()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head1;</span><br><span class="line">    struct node* head2;</span><br><span class="line"></span><br><span class="line">    ChangeToNull(&amp;head1);	//use &amp; to compute and pass a pointer to</span><br><span class="line">    ChangeToNull(&amp;head2);	//the value of interest</span><br><span class="line">    //head1 and head2 are NULL at this point</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块的思想是和（一）中的<code>Push()</code>类似。 内存示意图： <img src="https://img-blog.csdnimg.cn/20190330151133187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <strong>3、通过<code>Push()</code>建立链表（头插法）</strong> 这种方式的优点是速度飞快，简单易行，缺点是得到的链表是逆序的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct node* AddAtHead()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;head, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //head == &#123;5,4,3,2,1&#125;;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、尾插法建立链表</strong> 这种方法需要找到链表最后一个节点，改变其<code>.next</code>域： <img src="https://img-blog.csdnimg.cn/20190330155111506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<ul>
<li>插入或者删除节点，需要找到该节点的前一个节点的指针，改变其<code>.next</code>域；</li>
<li>特例：<strong>如果涉及第一个节点的操作，那么一定要改变<code>head</code>指针。</strong></li>
</ul>
<p><strong>5、特例+尾插法</strong> 如果要构建一个新的链表，那么头节点就要单独处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithSpecialCase()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line">    struct node* tail;</span><br><span class="line">    </span><br><span class="line">    //deal with the head node here, and set the tail pointer</span><br><span class="line">    Push(&amp;head, 1);</span><br><span class="line">    tail = head;</span><br><span class="line"></span><br><span class="line">    //do all the other nodes using &quot;tail&quot;</span><br><span class="line">    for (int i = 2; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;(tail-&gt;next), i);   //add node at tail-&gt;next</span><br><span class="line">        tail = tail-&gt;next;     //advance tail to point to last node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head;    //head == &#123;1,2,3,4,5&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6、临时节点建立</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithDummyNode()</span><br><span class="line">&#123;</span><br><span class="line">    struct node dummy;   //dummy node is temporarily the first node</span><br><span class="line">    struct node* tail = &amp;dummy;   //build the list on dummy.next</span><br><span class="line"></span><br><span class="line">    dummy.next = NULL;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;(tail-&gt;next), i);</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //the real result list is now in dummy.next</span><br><span class="line">    //dummy.next == &#123;1,2,3,4,5&#125;</span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>7、本地指针建立</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct node* BuildWithLocalRef()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line">    struct node** lastPtrRef = &amp;head;   //start out pointing to the head pointer</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; 6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(lastPtrRef, i);  //add node at the last pointer in the list</span><br><span class="line">        //advance to point to the new last pointer</span><br><span class="line">        lastPtrRef = &amp;((*lastPtrRef)-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return head;  //head == &#123;1,2,3,4,5&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块可能有些抽象： 1）<code>lastPtrRef</code>开始指向<code>head</code>指针，以后指向链表最后一个节点中的<code>.next</code>域； 2）在最后加上一个节点； 3）让<code>lastPtrRef</code>指针向后移动，指向最后一个<strong>节点的<code>.next</code>域</strong>。 <code>(*lastPtrRef)-&gt;next</code>可以理解为<code>*lastPtrRef</code>指针指向的节点的<code>next</code>域。 <img src="https://img-blog.csdnimg.cn/20190403193507385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ## 四、代码示例 <strong>1、AppendNode()</strong> 1) 不使用<code>Push()</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct node* AppendNode(struct node** headRef, int num)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = *headRef;</span><br><span class="line">    struct node* newNode;</span><br><span class="line"></span><br><span class="line">    newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">    newNode-&gt;data = num;</span><br><span class="line">    newNode-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //special case for length 0</span><br><span class="line">    if (current == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        *headRef = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //Locate the last node</span><br><span class="line">        while (current-&gt;next != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用<code>Push()</code>函数：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct node* AppendNode(struct node** headRef, int num)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = *headRef;</span><br><span class="line"></span><br><span class="line">    //special case for length 0</span><br><span class="line">    if (current == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(headRef, num);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        //Locate the last node</span><br><span class="line">        while (current-&gt;next != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //Build the node after the last node</span><br><span class="line">        Push(&amp;(current-&gt;next), num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、CopyList</strong> 用一个指针遍历原来的链表，两个指针跟踪新生成的链表（一个<code>head</code>，一个<code>tail</code>）。</p>
<ol type="1">
<li>不使用<code>Push()</code>函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* newList = NULL;   //head of the new list</span><br><span class="line">    struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (newList == NULL)    //special case for the first new node</span><br><span class="line">        &#123;</span><br><span class="line">            newList = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">            newList-&gt;data = current-&gt;data;</span><br><span class="line">            newList-&gt;next = NULL;</span><br><span class="line">            tail = newList;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            tail-&gt;data = current-&gt;data;</span><br><span class="line">            tail-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 内存示意图： <img src="https://img-blog.csdnimg.cn/20190407094454488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li>
<li>使用<code>Push()</code>函数：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList2(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* newList = NULL;   //head of the new list</span><br><span class="line">    struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if (newList == NULL)    //special case for the first new node</span><br><span class="line">        &#123;</span><br><span class="line">            Push(&amp;newList, current-&gt;data);</span><br><span class="line">            tail = newList;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Push(&amp;(tail-&gt;next), current-&gt;data);   //add each node at the tail </span><br><span class="line">            tail = tail-&gt;next;       //advance the tail to the new last node;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用<code>Dummy Node</code>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList3(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* tail = NULL;     //kept pointing to the last node in the new list</span><br><span class="line">    struct node dummy;            //build the new list off this dummy node</span><br><span class="line"></span><br><span class="line">    dummy.next = NULL;</span><br><span class="line">    tail = &amp;dummy;      //start the tail pointing at the dummy</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(&amp;(tail-&gt;next), current-&gt;data);   //add each node at the tail</span><br><span class="line">        tail = tail-&gt;next;                    //advance the tail to the new last node</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>使用<code>Local References</code>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList4(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;   //used to iterate over the original list</span><br><span class="line">    struct node* newList = NULL;   //head of the new list</span><br><span class="line">    struct node** lastPtr;           </span><br><span class="line"></span><br><span class="line">    lastPtr = &amp;newList;      //start off pointing to the head itself</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Push(lastPtr, current-&gt;data);   //add each node at the lastPtr</span><br><span class="line">        lastPtr = &amp;((*lastPtr)-&gt;next);    //advance lastPtr</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心思想是使用<code>lastPtr</code>指针指向每个节点的<code>.next</code>域这个指针，而不是指向节点本身。</p>
<ol start="5" type="1">
<li>使用<code>Recursive</code>：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct node* CopyList5(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;</span><br><span class="line">    if (head == NULL)</span><br><span class="line">        return NULL;</span><br><span class="line">    else &#123;</span><br><span class="line">        struct node* newList = (struct node*)malloc(sizeof(struct node));  //make one node</span><br><span class="line">        newList-&gt;data = current-&gt;data;</span><br><span class="line"></span><br><span class="line">        newList-&gt;next = CopyList5(current-&gt;next);    //recur for the rest</span><br><span class="line">        return newList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/01/01/Linked%20List-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/01/Linked%20List-1/" class="post-title-link" itemprop="url">Linked List-1</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-01 15:01:00" itemprop="dateCreated datePublished" datetime="2020-01-01T15:01:00+08:00">2020-01-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>链表一直是面试的重点问题，恰好最近看到了Stanford的一篇<a target="_blank" rel="noopener" href="http://cslibrary.stanford.edu/">材料</a>，涵盖了链表的基础知识以及派生的各种问题。 第一篇主要是关于链表的基础知识。 ## 一、基本结构 <strong>1、数组回顾</strong> 链表和数组都是用来存储一堆数据的集合，其中单个元素的类型可以有很多种。 通过数组下标可以直接访问数组中的元素，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void ArrayTest()</span><br><span class="line">&#123;</span><br><span class="line">    int scores[100];</span><br><span class="line"></span><br><span class="line">    //初始化前3个元素</span><br><span class="line">    scores[0] = 1;</span><br><span class="line">    scores[1] = 2;</span><br><span class="line">    scores[2] = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最关键的是：整个数组被分配了一整块内存： <img src="https://img-blog.csdnimg.cn/2019032615150057.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" /> 数组元素之所以能被快速访问，原因在于其地址的计算是通过首地址加上偏移值得到的，只有一次乘法和一次加法运算而已。 数组的缺点在于：</p>
<ul>
<li>数组的大小是固定的：数组的规模在编译时就被确定，当然你可以在运行时通过<code>malloc</code>在堆中改变数组的大小，不过很麻烦；</li>
<li>由于上述原因，所以很多人就会定义一个很大的数组，不过这又会导致两个问题： 1）数组的大部分空间可能被浪费掉； 2）如果程序需要更大的空间，就会崩溃。</li>
<li>在数组前面插入元素代价很大，需要移动很多元素。 链表也有自己的优缺点，只不过和数组刚好互补：链表会在需要时为每个节点单独分配内存。 <strong>2、指针回顾</strong> 指针存储了变量的地址，如果指针的值是<code>NULL</code>（c/c++中<code>NULL</code>可以表示逻辑<code>false</code>），那么该指针不指向任何变量。 在c/c++中，没有初始化的指针就是野指针，对野指针进行<code>dereference</code>操作可能导致程序崩溃。 两个指针的赋值结果就是都指向相同的内存区域。 <code>malloc()</code>函数用来在堆中申请一块内存，并且返回一个指向该块的指针，如果申请失败，会返回<code>NULL</code>，使用后，需要用<code>free()</code>去释放。这些堆函数原型都在<code>stdlib.h</code>头文件中声明。 <strong>3、链表</strong> 一个包含<code>&#123;1,2,3&#125;</code>三个元素的链表： <img src="https://img-blog.csdnimg.cn/20190326161911717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 空链表的<code>head</code>的值是<code>NULL</code>，<strong>编程时要考虑到这种边界情况</strong>。</li>
</ul>
<p>节点的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指向节点的指针类型是<code>struct node*</code>。 接着看看上图中的链表是怎么建立的？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Build the list &#123;1,2,3&#125; in the heap and store</span><br><span class="line">its head pointer in a local stack variable.</span><br><span class="line">Returns the head pointer to the caller.</span><br><span class="line">*/</span><br><span class="line">struct node* BuildOneTwoThree()</span><br><span class="line">&#123;</span><br><span class="line">    //there are three pointers in the stack, but pointer assignment link the list.</span><br><span class="line">    struct node* head = NULL;</span><br><span class="line">    struct node* second = NULL;</span><br><span class="line">    struct node* third = NULL;</span><br><span class="line"></span><br><span class="line">    //allocate 3 nodes</span><br><span class="line">    head = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">    second = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">    third = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    head-&gt;data = 1;    //setup first node</span><br><span class="line">    head-&gt;next = second;   //note:pointer assignment rule</span><br><span class="line"></span><br><span class="line">    second-&gt;data = 2;    //setup second node</span><br><span class="line">    second-&gt;next = third;</span><br><span class="line"></span><br><span class="line">    third-&gt;data = 3;    //setup third node</span><br><span class="line">    third-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    //at this point, the linked list referenced by &quot;head&quot;</span><br><span class="line">    //matches the list in the drawing.</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何求链表中的元素个数呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Given a linked list head pointer, compute </span><br><span class="line">and return the number of nodes in the list.</span><br><span class="line">*/</span><br><span class="line">int Length(struct node* head)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* current = head;</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    while (current != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，传递进函数的只是头指针，这样调用者和被调用者都有了头指针，但是却共享了整个链表。</p>
<ul>
<li><code>current</code>指针占据的空间会被自动释放，但是堆中的链表仍然保留；</li>
<li><code>while</code>循环已经考虑了空链表的情况；</li>
<li><code>current</code>最后的值会是<code>NULL</code>。 调用<code>Length()</code>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void LengthTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* myList = BuildOneTwoThree();</span><br><span class="line">    int len = Length(myList);    //results in len == 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>Length()</code>之前： <img src="https://img-blog.csdnimg.cn/20190326172043909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li>
<li>执行<code>Length()</code>过程中： <img src="https://img-blog.csdnimg.cn/20190326172354519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></li>
</ul>
<h2 id="二链表建立">二、链表建立</h2>
<p>用<code>BuildOneTwoThree()</code>函数来建立链表未免有些古板，下面用头插法建立链表：</p>
<p>1、分配节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct node* newNode;</span><br><span class="line">newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line">newNode-&gt;data = data_client_wants_stored;</span><br></pre></td></tr></table></figure>
<p>2、让新节点的<code>next</code>指向当前链表的第一个节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newNode-&gt;next = head;</span><br></pre></td></tr></table></figure>
<p>3、让<code>head</code>指针指向链表的第一个节点： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head = newNode;</span><br></pre></td></tr></table></figure> 整理下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void LinkTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();  //suppose this builds list &#123;2,3&#125;</span><br><span class="line">    struct node* newNode;</span><br><span class="line"></span><br><span class="line">    newNode = (struct node*)malloc(sizeof(struct node));  //allocate</span><br><span class="line">    newNode-&gt;data = 1;</span><br><span class="line">    </span><br><span class="line">    newNode-&gt;next = head;   //link next</span><br><span class="line"></span><br><span class="line">    head = newNode;   //link head</span><br><span class="line"></span><br><span class="line">    //now head points to the list &#123;1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如图： <img src="https://img-blog.csdnimg.cn/20190326205401503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> <em>先看一个错误的示范：</em> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void WrongPush(struct node* head,int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    head = newNode;    //NO this line does not work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WrongPushTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();  </span><br><span class="line">    </span><br><span class="line">    WrongPush(head, 1);    //try to push 1 on front -- doesn&#x27;t work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这个问题就在于C语言的<strong>值传递</strong>，在<code>WrongPush()</code>中对<code>head</code>指针的改变不会影响到<code>WrongPushTest</code>中的我们需要的<code>head</code>指针。 这个问题传统的解决方案是传递当前值的指针给函数而不是传递一份当前值的拷贝，即： 要改变调用者中<code>int</code>的值，就传一个<code>int*</code>给被调用者。在这个例子中，要改变<code>struct node*</code>，就要传递<code>struct node**</code>。也即：<code>head</code>的类型是<code>pointer to a struct node</code>，想要改变这个指针，就需要传一个指向该指针的指针<code>pointer to a pointer to a struct node</code>。 <strong>规则就是：<code>to modify caller memory, pass a pointer to that memory.</code></strong></p>
<p><em>所以正确的代码如下：</em> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Takes a list and a data value.</span><br><span class="line">Creates a new link with the given data and pushes it</span><br><span class="line">onto the front of the list.</span><br><span class="line">The list is not passed in by its head pointer.</span><br><span class="line">Instead the list is passed in as a &quot;reference&quot; pointer</span><br><span class="line">to the head pointer -- this allows us to modify the caller&#x27;s memory.</span><br><span class="line">*/</span><br><span class="line">void Push(struct node** headRef,int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = *headRef;	//the * to dereferences back to the real head </span><br><span class="line">    *headRef = newNode;    //ditto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PushTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();	//suppose this returns the list &#123;2,3&#125;</span><br><span class="line">    </span><br><span class="line">    Push(&amp;head, 1);    //note the &amp;</span><br><span class="line">    Push(&amp;head, 13);</span><br><span class="line"></span><br><span class="line">    //head is now the list &#123;13,1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 内存示意图： <img src="https://img-blog.csdnimg.cn/20190330143627528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VJTWFkcmlnYWw=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 如果是C++，那么可以用<strong>引用</strong>完成上述工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Push in C++ -- We just add a &amp; to the right hand side of the head parameter type,</span><br><span class="line">and the compiler makes that parameter work by reference. So this code changes the </span><br><span class="line">caller&#x27;s memory, but no extra uses of * are necessary -- we just access &quot;head&quot; directly,</span><br><span class="line">and the compiler makes that change reference back to the caller.</span><br><span class="line">*/</span><br><span class="line">void Push(struct node*&amp; head,int data)</span><br><span class="line">&#123;</span><br><span class="line">    struct node* newNode = (struct node*)malloc(sizeof(struct node));</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = head;	//No extra use of * necessary on head -- the compiler</span><br><span class="line">    head = newNode;    //just takes care of it behind the scenes.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PushTest()</span><br><span class="line">&#123;</span><br><span class="line">    struct node* head = buildTwoThree();	//suppose this returns the list &#123;2,3&#125;</span><br><span class="line">    </span><br><span class="line">    Push(head, 1);    //No extra use &amp; necessary -- the compiler </span><br><span class="line">    Push(head, 13);   //takes care of it here too. Head is being changed by these calls. </span><br><span class="line"></span><br><span class="line">    //head is now the list &#123;13,1,2,3&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2019/12/02/%E8%80%81%E5%AE%9E%E4%BA%BA%E7%9A%84%E6%91%B8%E7%B4%A2%E4%B8%8E%E5%8F%8D%E6%80%9D---%E5%86%99%E5%9C%A8%E9%AB%98%E8%80%83%E4%B8%83%E5%B9%B4%E5%90%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/02/%E8%80%81%E5%AE%9E%E4%BA%BA%E7%9A%84%E6%91%B8%E7%B4%A2%E4%B8%8E%E5%8F%8D%E6%80%9D---%E5%86%99%E5%9C%A8%E9%AB%98%E8%80%83%E4%B8%83%E5%B9%B4%E5%90%8E/" class="post-title-link" itemprop="url">老实人的摸索与反思---写在高考七年后</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-02 22:46:32" itemprop="dateCreated datePublished" datetime="2019-12-02T22:46:32+08:00">2019-12-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hills/" itemprop="url" rel="index"><span itemprop="name">Hills</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>老实人！</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/02/%E8%80%81%E5%AE%9E%E4%BA%BA%E7%9A%84%E6%91%B8%E7%B4%A2%E4%B8%8E%E5%8F%8D%E6%80%9D---%E5%86%99%E5%9C%A8%E9%AB%98%E8%80%83%E4%B8%83%E5%B9%B4%E5%90%8E/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2019/10/02/Codeforces%20Round%20#590/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/02/Codeforces%20Round%20#590/" class="post-title-link" itemprop="url">Codeforces Round</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-02 05:09:00" itemprop="dateCreated datePublished" datetime="2019-10-02T05:09:00+08:00">2019-10-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>题目链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1234">Round #590</a> 题目答案：<a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/70233">官方Editorial</a>、<a target="_blank" rel="noopener" href="https://github.com/EIMadrigal/CF">My Solution</a> ## A. Equalize Prices Again 签到题还WA了一发，向上取整有点问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my wrong code, 1.0 * sum返回double</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="number">1.0</span> * sum / n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//right code</span></span><br><span class="line">(<span class="keyword">int</span>)<span class="built_in">ceil</span>(<span class="number">1.0</span> * sum / n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ceil()原型</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>float</code>能保证6位精度（有效数字），<code>double</code>能保证15位精度。但是<code>float</code>和<code>double</code><strong>默认都只显示6位有效数字</strong>，所以一旦<code>1.0 * sum / n</code>大于6位，函数返回的<code>double</code>就显示不全，造成精度损失（比如结果应该是<code>5336844</code>，但返回<code>5.33684e+006</code>），故进行强制类型转换。 ## B1. Social Network (easy version) 题意：屏幕可以容纳<span class="math inline">\(k\)</span>条短信，有若干朋友发来<span class="math inline">\(n\)</span>条短信。如果某个朋友已经在屏幕上，不做改变；否则将其他朋友下移，新收到的朋友置顶。求最终自顶向下显示在屏幕上的朋友。 思路：按照题意模拟，我搞得有些繁琐（用<code>queue + set</code>来考虑是否将新来的短信放入屏幕，再用<code>queue.size()</code>和<span class="math inline">\(k\)</span>判断是否需要将旧短信<code>pop()</code>，最后将队列中的元素逆序输出）。 ## B2. Social Network (hard version) 数据量变到了<span class="math inline">\(10^5\)</span>级别，官方题解和我在B1中的思路一致。不过最后输出我是先压栈，题解是先存入<code>vector</code>，再用<code>reverse()</code>函数逆序，复杂度<span class="math inline">\(O(nlogk)\)</span>。 ## C. Pipes 模拟题：比赛时候发现了既然可以无限旋转，那么管道一共有2类：<span class="math inline">\(12\)</span>一样，<span class="math inline">\(3456\)</span>一样。 水流到<span class="math inline">\(12\)</span>这类，只能水平向右流； 流到<span class="math inline">\(3456\)</span>这类，那么另一行对应的位置也必须是<span class="math inline">\(3456\)</span>类，水就会换一行流动（异或即可换行），否则水没法继续流动。 最后判断水能否流到第二行第<span class="math inline">\(n\)</span>列。 ## D. Distinct Characters Queries 题意：给一字符串和<span class="math inline">\(q\)</span>次查询，查询分为两类：一类是替换字符串中某个字母，另一类是求子串中非重复字符的个数。 比赛时的思路是：遇到第一类查询就按规则替换，第二类先拿到子串，依次把子串的每个字符放入<code>set</code>中，最后返回<code>set.size()</code>即是非重复字符个数。 此题的教训就是要学会根据数据量级猜算法：1s/2s时限，C++运算次数大约在<span class="math inline">\(10^7\)</span>，本题的数据范围<span class="math inline">\(10^5\)</span>，我傻傻地把<span class="math inline">\(O(n^2)\)</span>的算法交了三次，TLE了三次，我还以为是<code>cin</code>的问题。。。 参考下大佬经验：<a target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/32/">由数据范围反推算法复杂度</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2019/09/23/Codeforces%20Round%20#587/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/23/Codeforces%20Round%20#587/" class="post-title-link" itemprop="url">Codeforces Round</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-23 14:13:00" itemprop="dateCreated datePublished" datetime="2019-09-23T14:13:00+08:00">2019-09-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>题目链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1216">Round #587</a> 题目答案：<a target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/69954">官方Editorial</a>、<a target="_blank" rel="noopener" href="https://github.com/EIMadrigal/CF">My Solution</a> ## A. Prefixes 题意：给一字符串，只含有<code>'a'</code>或<code>'b'</code>，需要改变某些位置（<code>'a'</code>变<code>'b'</code>或<code>'b'</code>变<code>'a'</code>），使得该字符串任意偶数长度前缀中<code>'a'</code>和<code>'b'</code>个数相等，求改变的最少次数以及更改后的字符串。</p>
<p>题解：遍历，判断<code>s[2i]</code>和<code>s[2i+1]</code>是否相等。如果相等，需要一次更改，并将其中一个改为不同字母。 ## B. Shooting 题意：给<span class="math inline">\(n\)</span>个编号<span class="math inline">\(1\)</span>~<span class="math inline">\(n\)</span>的射击目标，每个目标有不同的耐久度，假设已经击倒了<span class="math inline">\(x\)</span>个目标，将要射击第<span class="math inline">\(i\)</span>个目标，那么需要<span class="math inline">\(a_i*x+1\)</span>次才可以击倒该目标，<span class="math inline">\(a_i\)</span>为第<span class="math inline">\(i\)</span>个目标的耐久度。求击倒所有目标的最少射击次数以及射击次序。</p>
<p>题解：贪心。想要射击次数最少，就要先射击耐久度大的目标，所以按照耐久度由大到小排序，同时记录对应的目标序号。 ## C. White Sheet 题意：给定三个矩形，两黑一白，判断两个黑色矩形是否可以完全覆盖白色矩形，不能完全覆盖输出<code>YES</code>。</p>
<p>题解：分两种情况，记白色矩形面积为<span class="math inline">\(S_w\)</span>，一个黑色矩形与白色矩形交叉面积为<span class="math inline">\(S_{wb1}\)</span>，另一个黑色矩形与白色矩形交叉面积为<span class="math inline">\(S_{wb2}\)</span>，两黑色矩形交叉面积为<span class="math inline">\(S_{bb}\)</span>： 1、两黑色矩形无交叉：只要<span class="math inline">\(S_{wb1}+S_{wb2}&lt;S_w\)</span>，就可以看到白色矩形； 2、两黑色矩形有交叉：如果<span class="math inline">\(S_{wb1}+S_{wb2}-S_{bb}&lt;S_w\)</span>，可以看到白色矩形。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2019/09/16/Recursion%20and%20Backtracking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/16/Recursion%20and%20Backtracking/" class="post-title-link" itemprop="url">Recursion and Backtracking</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-16 15:24:00" itemprop="dateCreated datePublished" datetime="2019-09-16T15:24:00+08:00">2019-09-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="tree-recursion">Tree Recursion</h2>
<p>递归是计算机科学中一个非常重要的概念，对于斐波那契那种比较简单的递归，分析起来比较容易，但是由于二叉树涉及指针操作，所以模拟下遍历过程中系统栈的情况。 以二叉树中序遍历为例演示： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 中序遍历的递归实现： <img src="https://img-blog.csdnimg.cn/20190915232047750.png" alt="在这里插入图片描述" /> 假设二叉树如图所示： <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTI2MDU4MS8yMDE5MDkvMTI2MDU4MS0yMDE5MDkxNTIzMTQyMDE5MS0xMTMxOTk2Nzc2LnBuZw?x-oss-process=image/format,png" /> 其中序遍历序列为<span class="math inline">\(2413\)</span>，可以在VS中用单步调试的方法跟踪相应的变量： 当<code>root==NULL(root指向2的左孩子)</code>时，此时的系统栈（将1和2都压栈，因为中序遍历需要先访问左孩子）： <img src="https://img-blog.csdnimg.cn/20190916223229149.png" alt="在这里插入图片描述" /> 这时<code>if</code>不成立，执行83行的<code>return</code>语句，接着退栈，回到78行，此时的<code>root指向2(因为此时程序已经来到了新的栈顶)，并且向这个新栈顶返回了一个空的seq</code>： <img src="https://img-blog.csdnimg.cn/20190916223847870.png" alt="在这里插入图片描述" /> 接着执行79行(因为这是上一个函数<code>return</code>的，所以不会再一次执行78行)，将2存入<code>seq</code>中； 执行80行（<code>root</code>指向4），进而执行78行，<code>root</code>指向4的左孩子，此时的系统栈（很明显可以看到从<strong>栈底到栈顶依次存放根结点到当前<code>root</code>结点的路径</strong>上的结点）： <img src="https://img-blog.csdnimg.cn/20190916225924483.png" alt="在这里插入图片描述" /> 同样，执行<code>return</code>语句，退栈，将<code>seq</code>(里面只有2)返回到这一层，这一层的<code>root</code>指向4，接着将4存入<code>seq</code>； 到80行，调用<code>inOrder()</code>使得<code>root</code>指向4的右孩子，右孩子为空，所以返回并退栈，<code>root</code>重新指向4，此时80行执行完毕，整个<code>if</code>执行完毕，返回<code>seq</code>并退栈，<code>root</code>返回到了2，以2为根结点的子树中序遍历完毕，系统栈： <img src="https://img-blog.csdnimg.cn/20190916230804141.png" alt="在这里插入图片描述" /> 继续执行，return到78行，<code>root</code>指向1，将1存入seq，以此类推，就可以得到整个的遍历序列。</p>
<p>最关键的是：之所以要递归调用<code>inOrder</code>，就是因为现在还不想访问当前的结点（对于中序，要先找到最左边的结点），所以通过递归的方式将当前暂时不想访问的结点压入系统栈，找到了想访问的结点后，访问它并利用退栈操作返回父结点。 有关树的问题，有一些通用的模板： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one root</span></span><br><span class="line"><span class="function">func <span class="title">solve</span><span class="params">(root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == null)  <span class="keyword">return</span> ...</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">f</span>(root) <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">solve</span>(root-&gt;left);</span><br><span class="line">    r = <span class="built_in">solve</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(root, l , r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// two roots</span></span><br><span class="line"><span class="function">func <span class="title">solve</span><span class="params">(p, q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == null &amp;&amp; q == null)  <span class="keyword">return</span> ...</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">f</span>(p, q)  <span class="keyword">return</span> ...</span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">solve</span>(p.child, q.child);</span><br><span class="line">    r = <span class="built_in">solve</span>(p.child, q.child);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g</span>(p, q, l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="经典递归">经典递归</h2>
<p>除了树这种本身就是递归定义的结构外，还有一些search的问题也可以通过递归解决： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">length</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>] == s[s.<span class="built_in">length</span>() - <span class="number">1</span>] &amp;&amp;</span><br><span class="line">        <span class="built_in">isPalindrome</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>, s.<span class="built_in">length</span>() - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NotFound = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSearch</span><span class="params">(vector&lt;string&gt;&amp; v, <span class="keyword">int</span> start, <span class="keyword">int</span> stop, string key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; stop) <span class="keyword">return</span> NotFound;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (start + stop) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == v[mid])</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; v[mid])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSearch</span>(v, mid + <span class="number">1</span>, stop, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSearch</span>(v, start, mid - <span class="number">1</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == k || k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">C</span>(n - <span class="number">1</span>, k) + <span class="built_in">C</span>(n - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(string soFar, string rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rest.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            string next = soFar + rest[i];</span><br><span class="line">            string remaining = rest.<span class="built_in">substr</span>(<span class="number">0</span>, i) + rest.<span class="built_in">substr</span>(i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">permute</span>(next, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">per</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> d, vector&lt;<span class="keyword">bool</span>&gt;&amp; used, vector&lt;<span class="keyword">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == d) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">per</span>(nums, n, d + <span class="number">1</span>, used, cur, ans);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对数组a的[l, r]做全排列</span></span><br><span class="line"><span class="comment"> * 每个数字都要充当第一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perm</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[l], a[i]);  <span class="comment">// 第i个元素充当第一个</span></span><br><span class="line">        <span class="built_in">perm</span>(a, l + <span class="number">1</span>, r);  <span class="comment">// 剩余元素全排列</span></span><br><span class="line">        <span class="built_in">swap</span>(a[l], a[i]);  <span class="comment">// 恢复状态，保证下个做第一个元素的状态正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200704153124426.png" alt="在这里插入图片描述" /> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">com</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == d) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">com</span>(nums, n, d + <span class="number">1</span>, i + <span class="number">1</span>, cur, ans);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subsets</span><span class="params">(string soFar,string rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        cout &lt;&lt; soFar &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// add to subset, remove from rest, recur</span></span><br><span class="line">        <span class="built_in">subsets</span>(soFar + rest[<span class="number">0</span>], rest.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// do not add to subset, remove from rest, recur</span></span><br><span class="line">        <span class="built_in">subsets</span>(soFar, rest.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200704153731705.png" alt="在这里插入图片描述" /> 从递归树可以看到：Permutation和Subsets都是关于<em>选择</em>的问题，树的深度代表选择的次数，每层的宽度代表每次决定时的选项。这种都是Exhaustive Recursion，所以复杂度很高。</p>
<h2 id="backtracking">Backtracking</h2>
<figure>
<img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211129144559235-1738742177.png" alt="" /><figcaption>image</figcaption>
</figure>
<p>主要可以解决<strong>组合问题</strong>、<strong>排列问题</strong>、<strong>子集问题</strong>、<strong>字符串切割问题</strong>、<strong>棋盘问题</strong>，这些问题都可以抽象为<strong>多叉树的搜索问题</strong></p>
<figure>
<img src="https://img2020.cnblogs.com/blog/1260581/202111/1260581-20211129090136628-461210128.png" alt="" /><figcaption>image</figcaption>
</figure>
<p>回溯用来搜索选择性问题（a series of choices）的所有/部分解，每做一次选择，就递归一次，如果约束条件不满足，需要<strong>回退到上一层递归的参数状态</strong>。 通过约束条件的剪枝可以避免对整个搜索空间的穷举，从而提高效率。</p>
<p>三个关键点：</p>
<ol type="1">
<li>Choice 明确要做的决定，<strong>每次递归代表一次决定，每次的决策结果都保存在这一层的call stack中</strong>。 eg. 遍历二叉树时，当处在某一层的某结点时，下一次递归调用是向左还是向右。</li>
<li>Constraints 怎样剪枝，当前状态已经invalid，不必再从该状态继续搜索，直接返回。</li>
<li>Goal 找到target后，就要回溯到上一层，进行其它可能性的搜索。</li>
</ol>
<p>Pattern： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// backtracking</span></span><br><span class="line"><span class="keyword">bool</span>/<span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(configuration conf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (no more choices)  <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">return</span> (conf is goal state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (all available choices) &#123;</span><br><span class="line">        <span class="keyword">try</span> one choice c:</span><br><span class="line">        <span class="comment">// solve from here, if works out, you are done</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(conf with choice c made))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        unmake choice c;   <span class="comment">// explore other solutions</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// tried all choices, no soln found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>几个例子：</p>
<ol type="1">
<li>N-Queens 对照N皇后问题，明确三个关键点： 1）对于每一列，要做的决定是将Q放在哪一行，每次递归都会进入下一列的决策； 2）约束条件：不能出现在同一行、同一列、同一斜线； 3）目标：当在最后一列成功放置Q后，就可以回溯到上一层去探索其它解。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(grid&lt;<span class="keyword">bool</span>&gt;&amp; board, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (col &gt;= board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> rowToTry = <span class="number">0</span>; rowToTry &lt; board.<span class="built_in">size</span>(); ++rowToTry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSafe</span>(board, rowToTry, col)) &#123;</span><br><span class="line">            <span class="built_in">placeQueen</span>(board, rowToTry, col);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(board, col + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">removeQueen</span>(board, rowToTry, col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>Sudoku <img src="https://img-blog.csdnimg.cn/20200704162901848.png" alt="在这里插入图片描述" /> 将1-9放入格子，要求每行、每列、每块不能有重复数字。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(Grid&lt;<span class="keyword">int</span>&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the gird to check, we should check all the grids</span></span><br><span class="line">    <span class="keyword">int</span> row, col;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all grids assigned successfully</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">findUnassigned</span>(grid, row, col)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; ++num) &#123; <span class="comment">// options are 1-9</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">noConflict</span>(grid, row, col, num)) &#123;</span><br><span class="line">            <span class="built_in">grid</span>(row, col) = num; <span class="comment">// try assign</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">solve</span>(grid)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">grid</span>(row, col) = UNASSIGNED; <span class="comment">// undo and try again</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2019/09/10/%E7%90%83%E5%91%98%E5%BD%92%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/10/%E7%90%83%E5%91%98%E5%BD%92%E5%8C%96/" class="post-title-link" itemprop="url">球员归化</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-10 23:59:32" itemprop="dateCreated datePublished" datetime="2019-09-10T23:59:32+08:00">2019-09-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Arts/" itemprop="url" rel="index"><span itemprop="name">Arts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中国足球</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/09/10/%E7%90%83%E5%91%98%E5%BD%92%E5%8C%96/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2019/09/06/%E9%AB%98%E5%A2%99%E4%B8%8E%E9%B8%A1%E8%9B%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/06/%E9%AB%98%E5%A2%99%E4%B8%8E%E9%B8%A1%E8%9B%8B/" class="post-title-link" itemprop="url">高墙与鸡蛋</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-06 00:00:32" itemprop="dateCreated datePublished" datetime="2019-09-06T00:00:32+08:00">2019-09-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Arts/" itemprop="url" rel="index"><span itemprop="name">Arts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>村上春树在耶路撒冷</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/09/06/%E9%AB%98%E5%A2%99%E4%B8%8E%E9%B8%A1%E8%9B%8B/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2019/08/31/%E7%BF%BB%E5%94%B1%E4%B8%8E%E6%8A%84%E8%A2%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/31/%E7%BF%BB%E5%94%B1%E4%B8%8E%E6%8A%84%E8%A2%AD/" class="post-title-link" itemprop="url">翻唱与抄袭</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-31 23:31:32" itemprop="dateCreated datePublished" datetime="2019-08-31T23:31:32+08:00">2019-08-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Arts/" itemprop="url" rel="index"><span itemprop="name">Arts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>华语乐坛加油咯</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/08/31/%E7%BF%BB%E5%94%B1%E4%B8%8E%E6%8A%84%E8%A2%AD/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2019/08/26/Norwegian%20Wood/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/08/26/Norwegian%20Wood/" class="post-title-link" itemprop="url">Norwegian Wood</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-26 22:32:32" itemprop="dateCreated datePublished" datetime="2019-08-26T22:32:32+08:00">2019-08-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Arts/" itemprop="url" rel="index"><span itemprop="name">Arts</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>挪威的森林-小说的背后故事</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/08/26/Norwegian%20Wood/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EIMadrigal"
      src="/images/favicon.png">
  <p class="site-author-name" itemprop="name">EIMadrigal</p>
  <div class="site-description" itemprop="description">Hello World</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">169</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/EIMadrigal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:andrew.renj@gmail.com" title="E-Mail → mailto:andrew.renj@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/EIMadrigal" title="cnblogs → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-codiepie fa-fw"></i>cnblogs</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/EIMadrigal" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EIMadrigal</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">Total views: <span id="busuanzi_value_site_pv"></span></span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">Total visitors: <span id="busuanzi_value_site_uv"></span></span>
    <span class="post-meta-divider">|</span>

<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);
    var countOffset = 20000;

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset);
            clearInterval(int);
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>

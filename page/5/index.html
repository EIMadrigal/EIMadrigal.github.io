<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"eimadrigal.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Hello World">
<meta property="og:type" content="website">
<meta property="og:title" content="EI Madrigal&#39;s Space">
<meta property="og:url" content="https://eimadrigal.github.io/page/5/index.html">
<meta property="og:site_name" content="EI Madrigal&#39;s Space">
<meta property="og:description" content="Hello World">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="EIMadrigal">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://eimadrigal.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>EI Madrigal's Space</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EI Madrigal's Space</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/12/10/Quarterly%20Review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/10/Quarterly%20Review/" class="post-title-link" itemprop="url">Quarterly Review</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-10 11:15:00" itemprop="dateCreated datePublished" datetime="2020-12-10T11:15:00+08:00">2020-12-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="section">2020.9.9~2020.12.9</h1>
<p>转眼开学已经3个月了，在此做一个简短的总结，明确优缺，针对性改进。 整体来看：可以给自己打75分，各项计划也都在推进，但是有的事情很不顺利，唉习惯了~</p>
<ul>
<li>课业 相对来讲优先级很低，我翘掉了应该翘的所有课，节省了宝贵的时间。 弄清了培养方案的细节；英语课通过了免修考试；彻底结束了口语课、人工智能、自然辩证法；</li>
<li>CS学习 完成了15213的malloc lab；CS 61B的bear map；</li>
<li>科研 确定了科研选题和研究计划，并着手开始阅读文献；</li>
<li>其它 教师资格笔试（1门未通过）；六级口语考试；每周运动；适当外出放松；顺利成为积极分子；王道兼职进行的非常顺利，暂时做到了经济独立；</li>
</ul>
<p><strong>选定以后，扎实去做</strong> <strong>应付了事，不如不做</strong> - 教资笔试没有全部通过，这是3个月里最糟糕的事情，要拖到21年3月再考一次笔试，面试就只能顺延到21年5月。反思：当时复习时确实轻视了综合素质这门课，总归是付出代价了。。 - 百度人工智能班选拔失败，申请时过于应付，其实不太想去。反思：<strong>以后一旦决定某事，就尽全力准备，不要犹犹豫豫，应付了事，不想做的事就坚决拒绝，不要费力不讨好。</strong> - 系统看书/paper太少，跟老师学长交流比较少。反思：<strong>还是有些浮躁，没有扎扎实实地对待每一件计划内的事，总想着短平快，这是要栽跟头的。</strong> - 平时遇到的一些老师同学，尽量打个招呼，留个联系方式，不要装作没看见，逃避不是好办法； - 对于自己以往的经历，不要撒谎，谎言可能需要更多谎言去弥补。 # 2020.12.9~2021.3.9 ### 生活 对于幸福的追求将会是孜孜不倦、持之以恒的，探索生活的意义永远都是第一要务。</p>
<p>最近关注了一个UP主<a target="_blank" rel="noopener" href="https://b23.tv/n62zL9">天真的和感伤的小说家</a>，使得我又有了一些思考：如果没有自我身份和自我实现的认同，那么会很害怕死亡。无论是现实层面抑或是理想层面，所做之事即使不是引以为傲，至少也要发自内心地赞同。少年时总觉得理想为天，刻不容缓，哪怕粉身碎骨；稍稍长大，觉得首先确保自己的生存，再去向理想看齐并不可耻。解决个人的生存是用另外一种方式促进社会的进步，间接地为理想助力。</p>
<p>一直觉得自己像是戴了一层面具生活，过得十分拧巴，跟以前的朋友随着时间、距离、阅历的不同而逐渐疏远，更不用说所谓的新认识的“朋友”。摘下面具最好的方法就是“真诚”，当然这里的意思并不是傻乎乎地全盘托出，而是适当地袒露自己的真实想法。卸下伪装对于我有两点：</p>
<ol type="1">
<li>完全没必要用认识很多NB朋友和所谓的社会性话术、酒桌技能来突出自己的人脉或是为人处世的成熟；</li>
<li>真实地交流自己的经历。</li>
</ol>
<p>读研后其实就很少把自己看作纯粹的学生了，希望自己成为半个社会人，为人处世也要遵循规范。意味着属于自己的可支配时间变得越来越少，要协调处理家庭、同事、朋友各种圈子，能敞开心扉倒苦水的人越来越少，要更加珍惜朋友。力所能及的事情，哪怕是陌生人，能帮就帮帮吧，我想会有一些乐趣的。</p>
<p>最后，学CS实在没什么可炫耀的，家里条件好的谁来这个用命换钱的行业。 ### 学业 一如既往地翘课，但是作业和考试还算是认真对待。 六级很逗比，听力答题卡才涂了一半就被收走了，现在有点纠结今年6月要不要再来一次？</p>
<p>稍微麻烦一些的事在于：<strong>我还是不够扎实，我太着急了，着急着想要一个结果，着急着完成任务，没有真正属于自己的理解</strong>，更不用谈自己独立做出来！！计算机系的同学应该把提高能力远远地放在第一位，而不是浮华表面的成绩、比赛，最切身的周围环境无时无刻不在消耗着我对于这个学科的热爱，处在一个快节奏的社会，任何事物都追求短平快，内卷加剧浮躁，浮躁也促进内卷，焦虑值继而攀升。</p>
<p>我还是低估了环境对人的同化作用，读研前我觉得一定要跟大家不一样，但对于意志力不坚定的我，实验室学长的归宿可能是我最好的盼望了。那么这些问题应当如何解决？</p>
<p>应该时常反问自己：愿意成为一个整天赶作业，均分90+，但是脑袋空空半懂不懂的水货，还是愿意成为真的学了一些东西，可以讲出自己的理解的人？这次扎实学了，下次捡起来就可以省力很多，这大概就是磨刀不误砍柴工？不要在环境的内卷中迷失本质的能力！！对计算机科学（任何科学知识）保持谦卑和敬畏的态度，汲取养分，返璞归真。</p>
<p>在“来西交基本等于完蛋，来生信实验室彻底完蛋”的氛围下，少受一些周围同学的影响，平静接受自己难以改变的，经常反思自己：<strong>我是水货吗？？</strong></p>
<p><strong>真的不要再浮躁和偷懒了，最后的时光了</strong>。做事情要保证基本的连贯，不要频繁切换。learning by doing目前来看效果不错。</p>
<p>合作时弄清什么是自己该做的，什么是该推给别人的，不要当圣母，该喷就喷，否则会把自己搞得很累，还吃力不讨好，将来工作是要吃亏的。</p>
<p>最后，经常和学长学姐沟通！！！ ### 工作 接下来要准备下<strong>实习的申请</strong>：刷题、熟悉简历，不论最后能不能去，先拿到入场券总是不差的。</p>
<p>最重要的是<strong>自信</strong>，很多事情都可以努力争取，不去争取怎么知道可不可以呢？遇到稍微有点冲突的事情，不要因为畏惧而觉得几件事一定冲突，只能选一件，其实很多时候，合理安排都可以兼得，<strong>勇敢尝试，不要畏手畏脚</strong>。机会多如牛毛，多去试试，失败了还有其他的呢。</p>
<p>合格的职场人<span class="math inline">\(\Rightarrow\)</span>合格的工程师<span class="math inline">\(\Rightarrow\)</span>合格的算法工程师： <img src="https://img-blog.csdnimg.cn/20210224140520159.png" alt="在这里插入图片描述" /> 关于程序员大龄危机，抠个<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/392425409/answer/1207099799">回答</a>：</p>
<blockquote>
<p>租鸡青一，不买房不结婚不约会不大额消费，做程序员工资高，争取35之前存够100万，然后能撑多久撑多久，一旦40岁裁员下岗，就去四线城市找个安静的地方安度接下来的日子，自己买个便宜的商铺开开小卖部或五金店，反正自己吃住都在那里。有空能线上接单就接单，做做教程装装逼能赚点外快有一点是一点，不炒股不炒币投资理财只买银行保本型。把自己消费控制在每年3万以内，每天跑步加强锻炼，不抽烟不喝酒多吃肉蛋奶少吃高糖高油高盐，相信我，这样你会比你的同龄人活得更久，这样一来差不多可以苟到退休，退休后运气好就有退休金了！运气不好退休金玩完了，就提前买辆车跑滴滴。 你说生病了怎么办？这个世界上只有一种病：穷病！小病自己熬，大病自付超过三万主动放弃，和医生明确时间，然后去完成自己最后的愿望，别多想，这就是人生，命运从不讲道理。你要想，你已经比那些加班到突然猝死，什么遗愿都没去完成，带着劳累痛苦而走的同龄人要幸运太多了。 年轻人别想太多，你们有选择的权利！</p>
</blockquote>
<p>最后，目前打算毕业去一线互联网，之后跳槽独角兽或者回西安。 ### 乱七八糟 抠个网抑云热评：</p>
<blockquote>
<p>世上最幸福的便是： wifi满格 您的快递正在配送 打开电视就看到自己的偶像 天气刚好 旧衣服里的零钱 手机只剩1%时刚好踏进家门 买到炸鸡店里最后一只鸡腿 考的都会 蒙的全对 你喜欢的人刚好也喜欢你 幸福就是这么简单</p>
</blockquote>
<p>坚持锻炼身体，坚持午休，保持高效的作息，注意用眼卫生。</p>
<p>最后的最后，<strong>计划一直都在，高效认真执行否？</strong> # 2021.3.9~2021.6.9 以前的学习太关注整理优质资料，只是把别人的复述下而已，这不是真正学习的方法，一定要有自己的<a target="_blank" rel="noopener" href="https://lyqlola.github.io/MyBlog/hs%E8%AF%B4/">motivation</a>，这样之后用自己的理解写出来。</p>
<p>还是有点浮躁和自以为是，整天喷这个骂那个，其实潜意识里认为自己已经什么都会，但事实上并没有静心钻研，事情也没有认真对待。不要让焦虑控制自己，扪心自问：老师讲的你都会了吗？能自己独立推导吗？能自己独立实现吗？</p>
<p>另外，每天晚上走的有点早，总是潜意识认为自己回来有事，实际上还是看b站。</p>
<p>首先，不要乱喷，自己心里知道就好，也不要以国外的课为荣，不管哪种方式和资源，掌握知识才是最重要的。</p>
<p>其次，仔细认真对待磕研任务，公开课学习，以及刷题过程中的数学计算机知识，相信以后会有用的。要能踏实地坐在工位上，专注学习，翘课当然没问题，最主要还是为了更重要的事情。</p>
<p>做好当下的事和未来的计划，合理安排时间，不要以喷为荣，当做自己的本事，真正的本事应该是知识的触类旁通。</p>
<p>碰到难点或者麻烦点，不要着急，该花的时间还得花，不要急于求成，忽略理解和实现的过程。这一点要向一览和英鹏看齐。</p>
<p>加油吧少年，未来还很长，不要给自己太大压力。</p>
<p>找时间系统输入知识，而不是疯狂输出，零碎补充，这就没油了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/11/28/Malloc%20Lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/28/Malloc%20Lab/" class="post-title-link" itemprop="url">Malloc Lab</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-28 10:12:00" itemprop="dateCreated datePublished" datetime="2020-11-28T10:12:00+08:00">2020-11-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CSAPP</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/28/Malloc%20Lab/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/11/17/Stacking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/17/Stacking/" class="post-title-link" itemprop="url">Stacking</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-17 02:29:00" itemprop="dateCreated datePublished" datetime="2020-11-17T02:29:00+08:00">2020-11-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Ensemble Learning的基本思想就是将多个基学习器组合在一起，产生泛化能力更强的模型。 组合策略有许多种，包括Voting、平均法和Stacking等，Stacking就是选择某种学习器作为组合基学习器的方式。 <img src="https://img-blog.csdnimg.cn/20200926193430376.png" alt="在这里插入图片描述" /> 既然要结合多个基学习器的优点，那么基学习器的选择最好是“准而不同”，元学习器一般选择比较简单的模型（如逻辑回归），防止过拟合。 比较简单的想法就是将全部训练集用于训练基学习器，将基学习器的预测结果作为元学习器的训练集，从而得到整个模型。 这样做的问题在于：基学习器最终在训练集上的表现非常好，再用基学习器在该训练集上的预测结果作为次级训练集，同样元学习器在该训练集上表现也会非常好，但是模型的泛化能力不一定很好，有过拟合的风险。 因此，采用K折交叉验证的方式，用训练基学习器未使用的样本来产生次级训练集。 <img src="https://img-blog.csdnimg.cn/20201109191045436.jpg" alt="在这里插入图片描述" /> 具体来讲： 在训练阶段（假设训练集<span class="math inline">\(400*10\)</span>），对于每个基学习器（假设有3个基学习器），进行5次训练与验证，得到<span class="math inline">\(400*1\)</span>的验证结果，那么最终次级训练集是<span class="math inline">\(400*3\)</span>（类标签还是原始类标签），用这些数据训练次级学习器，完成后再用全部的训练集训练所有的基学习器（可选，提高基学习器性能）； 在测试阶段，如果训练阶段选了最后一步，那么每个基学习器直接得到一个结果，就会得到3个测试结果，送入次级学习器，得到最终的预测结果；如果训练时没有选最后一步，那么每个基学习器都有5个小模型，将测试样本用5个小模型分别测试，将5个结果平均得到某个基学习器的预测结果，也会得到3个测试结果。 <img src="https://img-blog.csdnimg.cn/20201109192340496.png" alt="在这里插入图片描述" /> Weka里的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Buildclassifier selects a classifier from the set of classifiers</span></span><br><span class="line"><span class="comment">   * by minimising error on the training data.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> data the training data to be used for generating the</span></span><br><span class="line"><span class="comment">   * boosted classifier.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the classifier could not be built successfully</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 建立整个模型</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildClassifier</span><span class="params">(Instances data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_MetaClassifier == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No meta classifier has been set&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断分类器是否有能力处理该数据集</span></span><br><span class="line">    getCapabilities().testWithFail(data);</span><br><span class="line">    <span class="comment">// 删除类标签缺失数据</span></span><br><span class="line">    Instances newData = <span class="keyword">new</span> Instances(data);</span><br><span class="line">    m_BaseFormat = <span class="keyword">new</span> Instances(data, <span class="number">0</span>);</span><br><span class="line">    newData.deleteWithMissingClass();</span><br><span class="line">    </span><br><span class="line">    Random random = <span class="keyword">new</span> Random(m_Seed);</span><br><span class="line">    newData.randomize(random); <span class="comment">// 打乱整个数据集</span></span><br><span class="line">    <span class="comment">// 如果是分类问题，分层抽样</span></span><br><span class="line">    <span class="comment">// 原始数据按照类标签集中在一起，按m_NumFolds为步长重新抽取数据，保持训练集/验证集数据分布一致性, 避免因数据划分引入额外的偏差</span></span><br><span class="line">    <span class="keyword">if</span> (newData.classAttribute().isNominal()) &#123;</span><br><span class="line">      newData.stratify(m_NumFolds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理原始数据得到新的数据，建立meta classifier</span></span><br><span class="line">    generateMetaLevel(newData, random);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// restart the executor pool because at the end of processing</span></span><br><span class="line">    <span class="comment">// a set of classifiers it gets shutdown to prevent the program</span></span><br><span class="line">    <span class="comment">// executing as a server</span></span><br><span class="line">    <span class="comment">// 创建线程池，为下面的基学习器训练做准备</span></span><br><span class="line">    <span class="keyword">super</span>.buildClassifier(newData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提高基础模型的准确度，使其在测试数据表现更好，用所有的训练集进行基学习器的训练</span></span><br><span class="line">    <span class="comment">// 这里为了节省时间，测试时，可以直接在多个基学习器预测后取平均</span></span><br><span class="line">    <span class="comment">// Rebuild all the base classifiers on the full training data</span></span><br><span class="line">    buildClassifiers(newData);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Generates the meta data</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newData the data to work on</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> random the random number generator to use for cross-validation</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">generateMetaLevel</span><span class="params">(Instances newData, Random random)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 先用newData得到metaData的格式m_MetaFormat</span></span><br><span class="line">    <span class="comment">// 确定元分类器需要的属性</span></span><br><span class="line">    Instances metaData = metaFormat(newData);</span><br><span class="line">    m_MetaFormat = <span class="keyword">new</span> Instances(metaData, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_NumFolds; j++) &#123;</span><br><span class="line">      <span class="comment">// 得到训练集</span></span><br><span class="line">      Instances train = newData.trainCV(m_NumFolds, j, random);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// start the executor pool (if necessary)</span></span><br><span class="line">      <span class="comment">// has to be done after each set of classifiers as the</span></span><br><span class="line">      <span class="comment">// executor pool gets shut down in order to prevent the</span></span><br><span class="line">      <span class="comment">// program executing as a server (and not returning to</span></span><br><span class="line">      <span class="comment">// the command prompt when run from the command line</span></span><br><span class="line">      <span class="comment">// 线程池，多线程并行构建基学习器</span></span><br><span class="line">      <span class="keyword">super</span>.buildClassifier(train);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构建基学习器</span></span><br><span class="line">      buildClassifiers(train);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Classify test instances and add to meta data</span></span><br><span class="line">      <span class="comment">// 将未使用过的原始训练数据通过基学习器预测后加入metadata作为新的训练集</span></span><br><span class="line">      Instances test = newData.testCV(m_NumFolds, j);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.numInstances(); i++) &#123;</span><br><span class="line">        metaData.add(metaInstance(test.instance(i)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用元数据建立元分类器</span></span><br><span class="line">    m_MetaClassifier.buildClassifier(metaData);    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>因为基学习器之间的训练是独立的，所以每次交叉验证划分好数据后，都是利用线程池并行训练。 如果是在分层抽样的基础上划分训练集和验证集，<code>trainCV()</code>抽取数据后，需要将新的训练集Shuffle，保证独立同分布。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes the format for the level-1 data.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> instances the level-0 format</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the format for the meta data</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the format generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 生成元数据格式</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Instances <span class="title">metaFormat</span><span class="params">(Instances instances)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果m_BaseFormat属性连续，就加入m_Classifiers.length个属性</span></span><br><span class="line">    <span class="comment">// 如果是离散的，每次要加入level 0类别属性取值个数个属性</span></span><br><span class="line">    ArrayList&lt;attribute&gt; attributes = <span class="keyword">new</span> ArrayList&lt;attribute&gt;();</span><br><span class="line">    Instances metaFormat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历基学习器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m_Classifiers.length; k++) &#123;</span><br><span class="line">      Classifier classifier = (Classifier) getClassifier(k);</span><br><span class="line">      String name = classifier.getClass().getName() + <span class="string">&quot;-&quot;</span> + (k+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (m_BaseFormat.classAttribute().isNumeric()) &#123;</span><br><span class="line">        attributes.add(<span class="keyword">new</span> Attribute(name));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果离散，后续会通过每个取值的概率来判断，比如杂色、圆花，这2种特性不能用一个属性表示，所以每个取值都要独立成单独的属性</span></span><br><span class="line">          <span class="comment">// 来保存概率值</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_BaseFormat.classAttribute().numValues(); j++) &#123;</span><br><span class="line">            attributes.add(</span><br><span class="line">              <span class="keyword">new</span> Attribute(</span><br><span class="line">              name + <span class="string">&quot;:&quot;</span> + m_BaseFormat.classAttribute().value(j)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加上原始类标签</span></span><br><span class="line">    attributes.add((Attribute) m_BaseFormat.classAttribute().copy());</span><br><span class="line">    <span class="comment">// 形成元数据格式</span></span><br><span class="line">    metaFormat = <span class="keyword">new</span> Instances(<span class="string">&quot;Meta format&quot;</span>, attributes, <span class="number">0</span>);</span><br><span class="line">    metaFormat.setClassIndex(metaFormat.numAttributes() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> metaFormat;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>生成元数据格式时，如果是分类问题，类标签的每个属性都被作为一个新的属性： <img src="https://img-blog.csdnimg.cn/20201109195503863.png" alt="在这里插入图片描述" /> 这里我个人这样理解：有的基分类器可以输出属于某个类的概率（如逻辑回归），将概率作为元属性而不是直接将基学习器的分类结果作为元属性，这样做能够减小基学习器的分类误差带给元学习器的影响，模型整体更加精确： <img src="https://img-blog.csdnimg.cn/20201109195918632.png#pic_center" alt="在这里插入图片描述" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Makes a level-1 instance from the given instance.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> instance the instance to be transformed</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the level-1 instance</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if the instance generation fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 产生元数据</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Instance <span class="title">metaInstance</span><span class="params">(Instance instance)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// values保存分类结果，连续属性直接保存，离散属性则先求得分布，将每种取值的分布加入values，设置为m_MetaFormat格式返回</span></span><br><span class="line">    <span class="keyword">double</span>[] values = <span class="keyword">new</span> <span class="keyword">double</span>[m_MetaFormat.numAttributes()];</span><br><span class="line">    Instance metaInstance;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m_Classifiers.length; k++) &#123;</span><br><span class="line">      Classifier classifier = getClassifier(k);</span><br><span class="line">      <span class="keyword">if</span> (m_BaseFormat.classAttribute().isNumeric()) &#123;</span><br><span class="line">        values[i++] = classifier.classifyInstance(instance);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 基学习器对该实例的分类的概率分布, sum(dist)=1</span></span><br><span class="line">        <span class="keyword">double</span>[] dist = classifier.distributionForInstance(instance);</span><br><span class="line">        <span class="comment">// 将该基学习器对该实例的预测概率输出到对应的元属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dist.length; j++) &#123;</span><br><span class="line">          values[i++] = dist[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标签值对应最后一个元属性</span></span><br><span class="line">    values[i] = instance.classValue();</span><br><span class="line">    metaInstance = <span class="keyword">new</span> DenseInstance(<span class="number">1</span>, values);</span><br><span class="line">    metaInstance.setDataset(m_MetaFormat);</span><br><span class="line">    <span class="keyword">return</span> metaInstance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在实际数据集上的结果其实不一定比其他模型效果好，可能是我参数调的不好吧（雾）~ </attribute></attribute></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/11/07/Bear%20Maps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/07/Bear%20Maps/" class="post-title-link" itemprop="url">Bear Maps</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-07 07:45:00" itemprop="dateCreated datePublished" datetime="2020-11-07T07:45:00+08:00">2020-11-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="intro">Intro</h2>
<p>这是CS 61B的Project 3，也是最后一个Proj。刚好上完这门课出去旅个游，放松下心情开始15213。 完成基本的要求花了5天时间，当然现在的版本还十分简陋，这个工程我是想做得比较大，后面还得抽时间消化理解、完善优化。</p>
<p>SP18用了<a target="_blank" rel="noopener" href="https://maven.apache.org/">Apache Maven</a>做项目建构工具，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41431457/article/details/102999439">折腾</a>了一天也没有配好，<del>不知道这么垃圾的工具有啥用</del> ，最后实在没辙就把该项目所有需要的jar包导进来，后来发现SP19就抛弃了maven。 <img src="https://img-blog.csdnimg.cn/20200623161825813.png" alt="在这里插入图片描述" /> 项目需要的地图集以及地图上的点/路信息都是Google采集好的，可在<a target="_blank" rel="noopener" href="https://github.com/Berkeley-CS61B">这里</a>下载，当然这个地图只是一小部分，后面想要扩展可以去下载需要的<a target="_blank" rel="noopener" href="https://www.openstreetmap.org/">数据集</a>，包括tile images和map feature data。</p>
<p>整体需求是实现一个网页端地图，用户通过浏览器输入URL，Java程序接收，然后生成相应的地图结果并返回，在浏览器中显示。服务器框架用的是<a target="_blank" rel="noopener" href="http://sparkjava.com/documentation.html#getting-started">Spark</a>，前端以及前后端交互的部分已经写好了（TA真的太强了），其实我有时候觉得这些dirty的工作比较考验码力，这些代码写得漂亮说明System的能力是挺强的。</p>
<p>后端至少需要实现3个类：</p>
<ul>
<li><code>Rasterer</code> 输入upper left latitude and longitude, lower right latitude and longitude, a window width, and a window height. 输出2D array of filenames corresponding to the files to be rendered.</li>
<li><code>GraphDB</code> 输入Open Street Map数据集，将其转为图存储起来：每个结点是a single intersection，每条边是一条路。</li>
<li><code>Router</code> 输入GraphDB, a starting latitude and longitude, and a destination latitude and longitude. 输出从起点到终点的一系列结点，以及路径导航信息。 ## Map Rastering 首先要将用户查询的真实世界的经纬度信息转为实际地图，<code>Rasterer.java</code>会接收用户请求的矩形参数<code>Map&lt;String, Double&gt; params</code>，生成对应的图像名称<code>String[][]</code>： 主要工作在<code>getMapRaster()</code>方法中完成，用户输入的查询请求共有6个参数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;lrlon=-<span class="number">122.2104604264636</span>, ullon=-<span class="number">122.30410170759153</span>, w=<span class="number">1085.0</span>, h=<span class="number">566.0</span>, ullat=<span class="number">37.870213571328854</span>, lrlat=<span class="number">37.8318576119893</span>&#125;</span><br></pre></td></tr></table></figure>
<p>表示用户希望显示经度范围<code>lrlon</code>~<code>ullon</code>，纬度范围<code>ullat</code>~<code>lrlat</code>的区域，并且分辨率大概是<code>w*h</code>。</p>
<p>街景图采用<strong>冗余存储</strong>，所有图片都是<code>256*256</code>：<code>d0_x0_y0.png</code>是整个区域的街景，但是分辨率最低，<code>d1_x0_y0.png/d1_x0_y1.png/d1_x1_y0.png/d1_x1_y1.png</code>分别代表西北/东北/西南/东南四个角的街景，但是分辨率加倍。</p>
<p>更加规范的说：在第D个缩放级别，共有<span class="math inline">\(4^D\)</span>张图片，<code>dD_x0_y0.png</code>到<code>dD_xk_yk.png</code>，<span class="math inline">\(k=2^D-1\)</span>，随<code>x</code>增大向东移动，随<code>y</code>增大向南移动，我们需要返回<code>String[][]</code>代表用户请求区域的图片文件名矩阵，当然还有一些其他参数（查询是否成功等）：由于Java只能返回一个值，所以结果组装成<code>Map&lt;String, Object&gt;</code>返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[d2_x0_y1.png, d2_x1_y1.png, d2_x2_y1.png, d2_x3_y1.png],</span><br><span class="line">[d2_x0_y2.png, d2_x1_y2.png, d2_x2_y2.png, d2_x3_y2.png],</span><br><span class="line">[d2_x0_y3.png, d2_x1_y3.png, d2_x2_y3.png, d2_x3_y3.png]]</span><br></pre></td></tr></table></figure>
<p>上述返回结果的分辨率为<code>1024*768</code>，几乎满足用户分辨率要求<code>1085*556</code>。</p>
<p>这样对于同一个区域，可以有很多选择：可以用更多张高分辨率图片的组合，也可以用较少几张低分辨率的图片组合，只要满足用户要求，比如对于上述例子，<code>d2_x0_y1.png</code>可以采用<code>d3_x0_y2.png/d3_x1_y2.png/d3_x0_y3.png/d3_x1_y3.png</code>代替，这样返回的图片是<code>6*8</code>共48张，分辨率可达<code>2048*1536</code>。</p>
<p>但这样做很可能overflow，远远超过用户要求，浪费时间和资源，因为分辨率高就意味着展示的空间小，并且前端是不会做缩放的，如果用很多高分辨率图片，浏览器会有太多太多照片加载显示，因为大家都是<code>256*256</code>的。</p>
<p>所以定义单位像素的经度距离：<span class="math inline">\(\text{LonDPP} = \frac{\text{lower right longitude} - \text{upper left longitude}}{\text{width of the image (or box) in pixels}}\)</span>，我们要展示的是小于用户要求的LonDPP的最大值，比方说用户要求每个像素2度，如果我们大于2，那么分辨率低到不能满足要求，只有小于2才能满足要求。又不能太小，分辨率太高展示范围变小。当然如果用户要求的LonDPP很低，只能用现有的最低的LonDPP图片，即<code>d7</code>系列。 可以将LonDPP理解为模糊程度，LonDPP越大，显示的图片越模糊，比如<code>d0</code>系列就有最大的LonDPP。 纬度也要做类似处理。</p>
<p>举例来看：<code>d2</code>系列共有16张图片，用户请求Query Box应该返回9张图片： <img src="https://img-blog.csdnimg.cn/20200624205748557.png" alt="在这里插入图片描述" /> 具体实现只有1个方法<code>public Map&lt;String, Object&gt; getMapRaster(Map&lt;String, Double&gt; params)</code>，分2步：</p>
<ul>
<li>需要的图片的<code>depth</code> 全图即<code>d0</code>的经纬度范围是：<code>-122.29980, 37.89220/-122.21191, 37.82280</code> 因为地球不是规则的，但是在确定Depth时，经度方向的LonDPP满足要求即可，不需考虑纬度方向的影响。</li>
<li>确定四个角的下标</li>
<li>corner case 判断输入是否合法时，边界判断一定要加EPS，不然一点小误差会崩掉程序。 输入不合法（用户拖动至全图外等），将<code>query_success</code>置为<code>false</code>返回即可。</li>
</ul>
<p>Bug：读取图片文件时，总是<code>javax.imageio.IOException: Can't read input file!</code>。一般都是路径问题。 ## Routing &amp; Location Data 明确了前端需要显示哪些图片后，接下来就是要建一个图，因为最后要路径规划嘛。 路由和位置数据是通过<code>berkeley-2018.osm.xml</code>文件给的，是整个<a target="_blank" rel="noopener" href="https://download.bbbike.org/osm/">地球数据</a>的一部分，文件格式是<a target="_blank" rel="noopener" href="https://wiki.openstreetmap.org/wiki/OSM_XML">OSM XML</a>。</p>
<p>解析XML数据用的是SAX Parser，遍历每个element，在每个元素的开始和结束位置，调用<code>startElement</code>和<code>endElement</code>回调函数。</p>
<p>先来熟悉下OSM XML文档： <img src="https://img-blog.csdnimg.cn/20200625122049178.png" alt="在这里插入图片描述" /> <code>node</code>元素是组成地图的主干，有id/lat/lon等属性。如果结点是一个位置，那么<code>tag</code>标签就会有<code>name</code>，如果是其他的，比如路上的一个点，那么就没有<code>tag</code>。 <img src="https://img-blog.csdnimg.cn/20200625122412890.png" alt="在这里插入图片描述" /> <code>way</code>元素表示一条路，路上可能有很多<code>node</code>，用<code>id</code>表示。<code>tag</code>会包含额外信息，如果<code>name</code>是highway，那么<code>v</code>就是道路类型。假设所有道路都是双向的。</p>
<p>在类<code>GraphDB</code>中存储图，要求允许插入和删除结点，最后要用<code>clean()</code>清理掉没有连接的结点。 <code>GraphBuildingHandler</code>会解析XML文件并调用<code>GraphDB</code>的一些接口函数构建整个图。</p>
<p>如果选择邻接矩阵存储，由于这是一个动态的图，可能要增加或者删除结点，所以一开始顶点个数是不确定的，也就不能用<code>int[][]</code>表示。所以选择邻接表，因为有<code>clean()</code>操作，需要判断结点是否与其他结点相邻，邻接表速度更快。</p>
<p><code>GraphBuildingHandler</code>每次只处理XML的一行，也就是一个标签，<code>GraphBuildingHandler</code>这个类可以被其它方法多次调用去处理完所有的XML，我发现这种拆分很有用，系统会变得简单，只需要考虑当前状态就很好写。清楚需求后，需要设计类的接口，数据结构和算法，这才是最难的部分。</p>
<p>由于parser的解析是从上到下的，所以处理<code>way</code>时最好不要直接把边和边上的结点直接加进图里，因为后面的<code>highway</code>的值可能不在合法范围内，这种边是不算的。所以在碰到边上的点，先存到一个数组里，最后<code>endElement()</code>时候如果路合法，再加进图里。处理<code>node</code>也同理，在<code>endElement()</code>时加入图。记得每次做完一个<code>node</code>或<code>way</code>要<code>clear()</code>上一个的状态信息。</p>
<p>每个<code>node</code>有一些属性（id/lat/lon），每条边也有一些属性（fromID/toID/name），所以首先要有<code>Node</code>类和<code>Edge</code>类。 邻接表的顶点表<code>Map&lt;Long, Node&gt; vertex</code>，边表<code>Map&lt;Long, Set&lt;Edge&gt;&gt; adj</code>。</p>
<p>Bug：对<code>ArrayList</code>等在迭代时同时进行修改就会引发异常<code>ConcurrentModificationException</code>。</p>
<p><code>long closest(double lon, double lat)</code>方法会被用来找最短路，需要返回最近的<strong>有邻居</strong>的<code>node</code>，一个点可能没有邻居，因为他是饭店啥的，不能用来找最短路。另外，这个方法复杂度要求<span class="math inline">\(O(lgn)\)</span>，先实现一个<span class="math inline">\(O(n)\)</span>的做法，后续有时间再去优化吧。 ## Route Search 建好地图后，就要做路由工作：给定起点和终点的经纬度，选一条距离最短的路径，需要在类<code>Router</code>中实现<code>shortestPath</code>方法。 应该从距起点最近的<code>node</code>开始导航到距终点最近的<code>node</code>结束，当然这些<code>node</code>必须是connected的。</p>
<p>两个<code>node</code>间的距离采用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Great-circle_distance">great-circle distance</a>，即当作球模型来计算弧长距离。整体距离就是计算1/2之间、2/3之间...的距离之和，还要考虑经度和纬度有不同的尺度，并且随着纬度变化，每度代表的实际距离也是不同的，还好计算距离的函数已经由🐂🍺的TA写好了。</p>
<p>最好用A*而不是Dijkstra，启发函数h(n)用结点n到终点的great-circle distance就行，要注意目标不可达的情况。</p>
<p>开始只能在<code>berkeley-2018-small-osm.xml</code>上跑起来，我以为是笔记本配置太烂，跑大的数据集跑不动，只能用小的来测试，后来发现<code>GraphDB</code>里一行写错了。。。debug真痛苦啊！！</p>
<p>找到最优路线后，这里有一个optional feature，就是显示方向导航信息Turn-by-turn Navigation，需要在类<code>Router</code>中实现<code>routeDirections</code>方法。导航方向的表示是在<code>Router</code>类中写了一个新类<code>NavigationDirection</code>，具体的导航信息格式如下： DIRECTION on WAY for DISTANCE miles 其中，DIRECTION有8种选择： - “Start” - “Continue straight” - “Slight left/right” - “Turn left/right” - “Sharp left/right”</p>
<p>所以我们需要确定正确的DIRECTION/WAY/DISTANCE，方向取决于当前结点和上一个节点间的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bearing_(navigation)">relative bearing</a>：</p>
<ul>
<li>Between -15 and 15 degrees the direction should be “Continue straight”.</li>
<li>Beyond -15 and 15 degrees but between -30 and 30 degrees the direction should be “Slight left/right”.</li>
<li>Beyond -30 and 30 degrees but between -100 and 100 degrees the direction should be “Turn left/right”.</li>
<li>Beyond -100 and 100 degrees the direction should be “Sharp left/right”.</li>
</ul>
<p>难点在于：一条<code>way</code>上可能包含了若干<code>node</code>，如何在遍历<code>node</code>的过程中判断<code>way</code>是否发生了改变，只有<code>way</code>变化后才能产生一条新的导航信息。如果恰好来到了一条没有<code>name</code>的路，就将WAY设为“unknown road”。</p>
<p>举例来说： 假设出发的<code>node</code>在“Shattuck Avenue”这条路上，那么DIRECTION应该设为“Start”，遍历接下来的<code>node</code>时，需要累加在这条路上走过的距离，最终到达一个不在“Shattuck Avenue”的<code>node</code>时，设置WAY为“Shattuck Avenue”，DISTANCE为之前的累加值。接着，下一条导航信息的DIRECTION应该根据相对方位计算，WAY是当前<code>node</code>所在的路，DISTANCE重新累加。</p>
<p>最终的效果：蓝色线表示最优路线： <img src="https://img-blog.csdnimg.cn/20201126192103548.png" alt="在这里插入图片描述" /> 单元测试还是非常重要的，只有确保每一个函数都是正确的，最终组合的功能才可能正确。 ## Autocomplete and Search 作为一个很有用的Feature，自动补全还是很酷的：搜索地名时只输入一部分，就返回以它开头的所有地名。需要在<code>MapServer</code>类中实现<code>List&lt;String&gt; getLocationsByPrefix(String prefix)</code>方法。</p>
<p>输入的参数<code>prefix</code>是clean后的字符串：除了大小写字母以及空格外，其它字符全部被移除，全部由小写字母组成。 需要返回所有locations（有<code>name</code>的<code>node</code>）的全名，前提是clean后的全名与<code>prefix</code>匹配。 复杂度要求<span class="math inline">\(O(k)\)</span>，k是共享同一前缀的所有地名。</p>
<p>比如这样： <img src="https://img-blog.csdnimg.cn/20200902160016738.png" alt="在这里插入图片描述" /> 除了自动补全，还需要完成Search功能：clean后的用户输入与clean后的<code>locationName</code>完全匹配，同名的<code>location</code>都需要加入<code>List</code>。 复杂度要求<span class="math inline">\(O(k)\)</span>，k是匹配的地名个数。 需要在<code>MapServer</code>类中实现<code>List&lt;Map&lt;String, Object&gt;&gt; getLocations(String locationName)</code>方法，返回同名的所有地方的信息，如果正确实现，那么就会有一个mark标记在那个地方： <img src="https://img-blog.csdnimg.cn/20200906101859262.png" alt="在这里插入图片描述" /> 具体实现一般用Trie，这里的难点在于输入是clean后的字符串，需要输出clean前的全名，所以我们的Trie结点除了有<code>children</code>和<code>isWord</code>外，还需要保存一些额外的信息（clean前的<code>name</code>/<code>id</code>/<code>lat</code>/<code>lon</code>），当然这些信息只有叶子结点才需要保存，用<code>List&lt;Map&lt;String, Object&gt;&gt; extraInfo</code>来存储。这样重名的地点虽然占用了相同的叶子，但是所有地点的信息都存在了该叶子的<code>extraInfo</code>当中，可以直接展示出来。</p>
<p>Debug好痛苦啊！！有一次怎么样在浏览器都渲染不出来，折腾了一天，最后发现是因为html文件里一个js文件要FQ才可以访问，醉了。 ## Extensions - Front-end Integration 现在是每调用一次，就在后台raster the entire image，然后传到前端显示。实际中前端可以缓存用过的tiles以及路线，下次调用无需后台计算。 - Vectored Tiles 现在的数据是一张张图片，实际上这些图片是可以从roads, lines, filled areas, buildings等基础矢量几何图形提取，可以用OpenGL/WebGL将其全部绘制为三角形，这样非常同一的工作就可以用GPU去做，速度比CPU要快很多，这些矢量图形可以在<a target="_blank" rel="noopener" href="https://wiki.openstreetmap.org/wiki/Vector_tiles">这里</a>下载。 - <a target="_blank" rel="noopener" href="https://sp19.datastructur.es/materials/proj/proj2c/heroku">Deploy on Heroku</a> 目前为止，我们的地图还只能在本地运行，下来就将它部署到服务器~ 具体的部署过程可以参考上述链接，完成后APP就会部署到<a target="_blank" rel="noopener" href="http://bearmaps-fun.herokuapp.com/map.html">这里</a>。 后续的代码更改需要rebuild jar包，然后redeploy。 ## TODO 做工程真是长期的活，遇到bug每天能写50行就不错了。</p>
<p>所有<a target="_blank" rel="noopener" href="https://github.com/EIMadrigal/CS61B/tree/master/proj3">代码</a>均已通过AG的测试： Part I： <img src="https://img-blog.csdnimg.cn/20200917210047412.png" alt="在这里插入图片描述" /> PART II &amp; III： <img src="https://img-blog.csdnimg.cn/20200917210119434.png" alt="在这里插入图片描述" /> 附加Feature： <img src="https://img-blog.csdnimg.cn/20201127214331958.png" alt="在这里插入图片描述" /> 单元测试除了<code>TestDirections</code>外全部通过。 <img src="https://img-blog.csdnimg.cn/20201129193519713.png" alt="在这里插入图片描述" /> 这个Bug真的有些诡异，不过： <img src="https://img-blog.csdnimg.cn/20201201103328818.png" alt="在这里插入图片描述" /> 尽量少用<code>protected</code>修饰成员变量，写一个函数接口去访问。 ## Reference <a target="_blank" rel="noopener" href="https://sp18.datastructur.es/materials/proj/proj3/proj3">Project 3: Bear Maps, version 3.0</a> <a target="_blank" rel="noopener" href="https://sp19.datastructur.es/materials/proj/proj2c/proj2c">Project 2C: Bear Maps, version 4.0</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/11/02/Support%20Vector%20Machine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/02/Support%20Vector%20Machine/" class="post-title-link" itemprop="url">Support Vector Machine</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-02 04:52:00" itemprop="dateCreated datePublished" datetime="2020-11-02T04:52:00+08:00">2020-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>SVM是入门机器学习绕不开的一个话题，但愿这篇文章我能把它讲清楚。 ## 线性可分 SVM的核心思想是：对于<span class="math inline">\(p\)</span>维输入数据集，找一个有着maximum margin的<span class="math inline">\(p-1\)</span>维的超平面去做decision boundary，这与直觉是相符的： <img src="https://img-blog.csdnimg.cn/20200903193214259.png" alt="在这里插入图片描述" /> 回忆下小学数学讲过的几何知识：空间中一个超平面由法向量<span class="math inline">\(\vec w\)</span>和截距<span class="math inline">\(b\)</span>唯一确定： <span class="math display">\[a(x-x_1)+b(y-y_1)+c(z-z_1)+...=0, \\
w^Tx+b=0\]</span> 那么如何求解最优超平面的<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>呢？</p>
<p>假设<span class="math inline">\(\vec w\)</span>指向的一侧为正类（设为负类也没关系，后面会统一表示的），还<strong>假设</strong>在正类的支持向量上有<span class="math inline">\(w^Tx+b=1\)</span>，在负类的支持向量上有<span class="math inline">\(w^Tx+b=-1\)</span>，这里之所以将间隔假设为1主要是为了方便表示和求解，并不影响最终求得的最优超平面和决策函数，证明如下：</p>
<p>假设正类支持向量距最优超平面距离为<span class="math inline">\(c(c&gt;0)\)</span>，即<span class="math inline">\(w^Tx+b=c\)</span>，此时对应的最优超平面为<span class="math inline">\(w^Tx+b=0\)</span>；又<span class="math inline">\(\frac{w^T}{c}x+\frac{b}{c}=1\)</span>，即<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>同时缩小<span class="math inline">\(c\)</span>倍，那么这时超平面方程同除以<span class="math inline">\(c\)</span>并不改变其形式。</p>
<p>因此对于正负样本有： <span class="math display">\[w\cdot x_++b\geq 1 \\
w\cdot x_-+b\leq -1
\]</span> 为了统一表示上面2种情况，引入<span class="math inline">\(y_i=\begin{cases} 1,&amp;\text{+sample}\\ -1,&amp;\text{-sample} \end{cases}\)</span>，所有样本统一表示为： <span class="math display">\[y_i(w\cdot x_i+b)-1\geq 0\]</span> 如果能确定<span class="math inline">\(b\)</span>和<span class="math inline">\(w\)</span>，那么分类超平面和决策函数也就随即确定。</p>
<p>根据小学数学，间隔即为2个平行超平面的距离： <span class="math display">\[width=\frac{(b+1)-(b-1)}{||w||}=\frac{2}{||w||}\tag{1}\]</span></p>
<p>综上，<strong>原优化问题</strong>为： <span class="math display">\[
\begin{array}{ll}
\min _{w, b} &amp; \frac{1}{2}\|w\|^{2} \\
\text { s.t. } &amp; y_{i}\left(w \cdot x_{i}+b\right)-1 \geqslant 0, \quad i=1,2, \cdots, N
\end{array}\tag{2}
\]</span> 这里之所以构造为<span class="math inline">\(\frac{1}{2}\|w\|^{2}\)</span>而不是<span class="math inline">\(||w||\)</span>是为了后面构造的Lagrangian求导的便利。</p>
<p>明眼人都看得出来：优化目标是一个Convex Quadratic Optimization Problem，并且只有线性约束条件，意味着不会卡在局部极大，一定可以找到全局最优解。此时上述问题已经完全可以用一些QP软件求解了。之所以还要继续讨论下去得到其对偶形式，一是为了在高维空间应用kernel，二是对偶形式的求解有着更加高效的算法。</p>
<p>回忆下学过的高等数学：有约束优化问题可以通过拉格朗日乘子法求解。首先构造Lagrangian： <span class="math display">\[L(w,b,\alpha)=\frac{||w||^2}{2}-\sum_{i=1}^{N}\alpha_i[y_i(w\cdot x_i+b)-1],\alpha_i\geq0\tag{3}\]</span> 如果<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>满足<span class="math inline">\((2)\)</span>中的约束，那么<span class="math inline">\(\max_{\alpha}L(w,b,\alpha)=\frac{||w||^2}{2}\)</span>； 如果<span class="math inline">\(w\)</span>和<span class="math inline">\(b\)</span>不满足<span class="math inline">\((2)\)</span>中的约束，那么<span class="math inline">\(\max_{\alpha}L(w,b,\alpha)=+\infin\)</span>。 因此下式的优化问题与<span class="math inline">\((2)\)</span>完全等价： <span class="math display">\[
\min_{w, b}\max_{\alpha} L(w, b, \alpha)\tag{4}
\]</span> 根据拉格朗日对偶性（不懂就暂时当作成立吧嘻嘻），<span class="math inline">\((4)\)</span>的对偶问题为： <span class="math display">\[
\max_{\alpha} \min_{w, b} L(w, b, \alpha)\tag{5}
\]</span> 为了求解对偶问题<span class="math inline">\((4)\)</span>，先求<span class="math inline">\(L\)</span>对<span class="math inline">\(w,b\)</span>的极小，再求对<span class="math inline">\(\alpha\)</span>的极大：</p>
<ol type="1">
<li>固定<span class="math inline">\(\alpha\)</span>，求<span class="math inline">\(\min_{w, b} L(w, b, \alpha)\)</span> 分别求<span class="math inline">\(L\)</span>对<span class="math inline">\(\vec{w}\)</span>和<span class="math inline">\(b\)</span>的偏导并令其为0： <span class="math display">\[\frac{\partial L}{\partial\vec{w}}=\vec{w}-\Sigma\alpha_iy_ix_i=0, \vec{w}=\Sigma\alpha_iy_ix_i \\
\frac{\partial L}{\partial b}=\Sigma\alpha_iy_i=0, \Sigma\alpha_iy_i=0\tag{6}\]</span> 决策向量<span class="math inline">\(\vec{w}\)</span>是样本的线性和，将<span class="math inline">\(\vec{w}\)</span>代入<span class="math inline">\((3)\)</span>： <span class="math display">\[\min_{w, b}L=\Sigma\alpha_i-\frac{1}{2}\Sigma_i\Sigma_j\alpha_i\alpha_jy_iy_jx_i\cdot x_j\tag{7}\]</span></li>
<li>求<span class="math inline">\(\min_{w, b} L(w, b, \alpha)\)</span>对<span class="math inline">\(\alpha\)</span>的极大 即求<span class="math inline">\((7)\)</span>对<span class="math inline">\(\alpha\)</span>的极大，等价于取负号求对<span class="math inline">\(\alpha\)</span>的极小，于是终于得到了<strong>原优化问题</strong><span class="math inline">\((2)\)</span>的<strong>对偶优化问题</strong>： <span class="math display">\[
\begin{array}{ll}
\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i} \\
\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\
&amp; \alpha_{i} \geqslant 0, \quad i=1,2, \cdots, N
\end{array}\tag{8}
\]</span></li>
</ol>
<p>利用SMO等算法可以比普通的二次规划算法更高效求得最优的<span class="math inline">\(\alpha^*\)</span>，进而根据<span class="math inline">\((6)\)</span>求得： <span class="math display">\[w^{*}=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i}\tag{9}\]</span> 再利用KKT条件（不懂就装懂吧嘻嘻）求得： <span class="math display">\[b^{*}=y_{j}-(w^*)^Tx_j=y_{j}-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}\left(x_{i} \cdot x_{j}\right)\tag{10}\]</span> 其中，<span class="math inline">\(y_{j}\)</span>为任意一个支持向量。</p>
<p>最终的分类超平面为： <span class="math display">\[w^{*}\cdot x+b^{*}=0,\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}(x_{i}\cdot x)+b^{*}=0\tag{11}\]</span> 分类决策函数为： <span class="math display">\[f(x)=sign(w^{*}\cdot x+b^{*})=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}(x_{i}\cdot x)+b^{*}\tag{12}\]</span> 最后要bb的是关于支持向量，根据KKT条件里的互补条件<span class="math inline">\(\alpha_{i}^{*}[y_{i}(x_{i}\cdot w^*+b^{*})-1]=0\)</span>：非支持向量必然有<span class="math inline">\(\alpha_{i}^{*}=0\)</span>，只有支持向量才可能出现<span class="math inline">\(\alpha_{i}^{*}&gt;0\)</span>。</p>
<p>如果回头看<span class="math inline">\((9)(10)(11)(12)\)</span>，所有的非支持向量对SVM没有任何影响，最优超平面以及决策函数都只由少量的支持向量决定，这大概就是支持向量机名称的由来吧~ ## 近似线性可分 上面讨论了完全线性可分的情况，然而在现实情况中，训练数据会有一些outliers，除去这些点后数据是线性可分的。为了处理这种情况，允许SVM分错一些样本。对每个样本点引入松弛因子<span class="math inline">\(\xi_{i} \geqslant 0\)</span>，即样本点的函数间隔只需要大于<span class="math inline">\(1-\xi_{i}\)</span>，放松了限制条件，<strong>原优化问题</strong>变为： <span class="math display">\[
\begin{array}{ll}
\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i} \\
\text { s.t. } &amp; y_{i}\left(w \cdot x_{i}+b\right) \geqslant 1-\xi_{i}, \quad i=1,2, \cdots, N \\
&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N
\end{array}\tag{13}
\]</span> 如果样本点严格满足约束，对于损失函数没有贡献；如果不严格满足即<span class="math inline">\(\xi_{i}&gt;0\)</span>，损失函数就会有相应的惩罚。惩罚参数<span class="math inline">\(C\)</span>控制了一种权衡：既要间隔最大（即<span class="math inline">\(min\ ||w||\)</span>），又要分对尽可能多的样本点。</p>
<p>类似地，<span class="math inline">\((13)\)</span>可以通过拉格朗日乘子法转换为对偶问题后再去求解，建议吃饱的同学自己尝试一下。<span class="math inline">\((13)\)</span>的<strong>对偶优化问题</strong>是： <span class="math display">\[
\begin{array}{ll}
\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i} \\
\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\
&amp; 0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N
\end{array}\tag{14}
\]</span> 此时此刻恰如彼时彼刻，使用普通的二次规划算法或者更高效的SMO求解<span class="math inline">\((14)\)</span>得到最优的<span class="math inline">\(\alpha_{i}^{*}\)</span>，进而得到软间隔SVM的解： <span class="math display">\[
w^{*}=\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i} \\
b^{*}=y_{j}-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}\left(x_{i} \cdot x_{j}\right)\tag{15}
\]</span> 其中，<span class="math inline">\(y_{j}\)</span>要满足<span class="math inline">\(0&lt;\alpha_j&lt;C\)</span>。 ## 非线性可分 上面讨论了线性分类问题，对于非线性可分问题，SVM的思想是做一个变换<span class="math inline">\(\phi(\vec{x})\)</span>，将样本映射到另外一个空间，也许就线性可分了。 由于目标函数和决策函数<strong>只依赖于样本对之间的点积</strong>，所以无需显式定义变换<span class="math inline">\(\phi(\vec{x})\)</span>，只要定义一个函数<span class="math inline">\(K(\vec{x_i},\vec{x_j})=\phi(\vec{x_i})\cdot\phi(\vec{x_j})\)</span>提供新空间的样本点的点积即可，<span class="math inline">\(K\)</span>叫做<strong>Kernel Function</strong>。 此时原优化问题为： <span class="math display">\[
\begin{array}{ll}
\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i} \\
\text { s.t. } &amp; y_{i}\left(w^T \phi(x_{i})+b\right) \geqslant 1-\xi_{i}, \quad i=1,2, \cdots, N \\
&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N
\end{array}
\]</span> 对偶问题为： <span class="math display">\[
\begin{array}{ll}
\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(K(x_{i},x_{j})\right)-\sum_{i=1}^{N} \alpha_{i} \\
\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\
&amp; 0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N
\end{array}
\]</span> 一种常用的kernel是线性的：<span class="math inline">\((\vec{u}\cdot\vec{v}+1)^n\)</span>，当前空间的<span class="math inline">\(u\)</span>和<span class="math inline">\(v\)</span>通过简单的点积映射到了另一个空间； 另一种kernel是高斯核：<span class="math inline">\(e^{-\frac{||x_i-x_j||^2}{\sigma}}=e^{-\gamma{||x_i-x_j||}^2}\)</span>。 高斯核对应高斯径向基函数分类器，这里有2个参数<span class="math inline">\(C\)</span>和<span class="math inline">\(\gamma\)</span>需要调节：惩罚系数<span class="math inline">\(C\)</span>表示分类器对于误差的宽容度，<span class="math inline">\(C\)</span>越大表示越不能容忍误差，容易过拟合，按照经验可以在<span class="math inline">\([10^{-4},10^4]\)</span>间调节；<span class="math inline">\(\gamma\)</span>控制径向作用范围，<span class="math inline">\(\gamma\)</span>越大，径向作用范围越小，有可能将每个样本点单独形成一个分类，容易过拟合，<span class="math inline">\(\gamma\)</span>过小，径向范围过大，容易将2个样本映射为同一个点，无法区分，一般<span class="math inline">\(\gamma=\frac{1}{样本特征数}\)</span>。另外，这2个参数可以通过交叉验证和grid-search来调整。 ## 扩展 SVM处理多分类问题的方式主要有2种：</p>
<ul>
<li>one-against-one 在每2个类之间都构造一个binary SVM，共有<span class="math inline">\(C_m^2\)</span>个SVM，对新数据采用Voting的方式进行分类。</li>
<li>one-against-the-rest 对每个类，将其作为正类，其余<span class="math inline">\(m-1\)</span>个类作为负类，共<span class="math inline">\(m\)</span>个SVM，对新数据采用winner-takes-all策略。</li>
</ul>
<p>如果样本不均衡，目标函数中的惩罚项主要由多数类构成，超平面偏向少数类，甚至将所有样本都分在同一侧。 此时目标变为了在不严重损失多数类精度的情况下，在少数类上获得尽可能高的分类正确率。一般来讲有2种做法：</p>
<ul>
<li>数据合成 对少数类样本进行分析并根据其特点人工插值合成新样本添加到数据集中，构成均衡数据集。比较常用的方法是SMOTE(Synthetic Minority Oversampling Technique)。</li>
<li>加权SVM 将少数类分错的代价很大，所以在惩罚项中对两个类设置不同的惩罚系数，少数类的系数设置更大，甚至可以对每个样本都设置不同的惩罚系数，此时原优化问题变为： <span class="math display">\[
\begin{array}{ll}
\min _{w, b, \xi} &amp; \frac{1}{2}\|w\|^{2}+C^+ \sum_{y_i=1} \xi_{i}+C^-\sum_{y_i=-1} \xi_{i} \\
\text { s.t. } &amp; y_{i}\left(w^T \phi(x_{i})+b\right) \geqslant 1-\xi_{i}, \quad i=1,2, \cdots, N \\
&amp; \xi_{i} \geqslant 0, \quad i=1,2, \cdots, N
\end{array}
\]</span> 对偶问题： <span class="math display">\[
\begin{array}{ll}
\min _{\alpha} &amp; \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(K(x_{i},x_{j})\right)-\sum_{i=1}^{N} \alpha_{i} \\
\text { s.t. } &amp; \sum_{i=1}^{N} \alpha_{i} y_{i}=0 \\
&amp; 0 \leqslant \alpha_{i} \leqslant C^+, y_i=+1 \\
&amp; 0 \leqslant \alpha_{i} \leqslant C^-, y_i=-1
\end{array}
\]</span></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/10/23/IO%20Multiplexing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/23/IO%20Multiplexing/" class="post-title-link" itemprop="url">IO Multiplexing</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-23 10:28:00" itemprop="dateCreated datePublished" datetime="2020-10-23T10:28:00+08:00">2020-10-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当多个独立的I/O事件同时发生时，I/O多路复用是一种解决方式。 为了提高服务器的吞吐量，<strong>单个线程</strong>通过记录跟踪每个I/O流的状态同时管理多个I/O流，非常类似时分复用技术。 <img src="https://img-blog.csdnimg.cn/20200825092905568.gif#pic_center" alt="在这里插入图片描述" /> I/O多路复用的具体实现方式有3种：<code>select()</code>、<code>poll()</code>和<code>epoll()</code>。 ## select <code>select()</code>系统调用：<code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code> <code>select()</code>会一直阻塞直到至少一个文件描述符就绪，可以读写，或者出现异常。 中间3个参数会被修改，表示哪个FD准备好了，最后一个表示等待时间，NULL表示无限等待。 返回就绪的FD数目，有错-1。只知道有就绪，不知道哪个FD就绪了。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd[];  <span class="comment">// 需要监听的socket集合</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = select();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fd.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET()) &#123;  <span class="comment">// 判断哪个socket接收到数据</span></span><br><span class="line">            <span class="comment">// 处理数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>select()</code>是阻塞方法，只有某个socket接收到数据才会继续执行，唤醒进程。 直接的方式缺点就比较多：</p>
<ul>
<li>时间开销大，所以规定最多监听1024个socket；</li>
<li>每次调用都要把fd集合从用户态拷贝到内核态。</li>
<li>线程不安全：</li>
</ul>
<blockquote>
<p>If a file descriptor being monitored by select() is closed in another thread, the result is unspecified. ## poll 去掉了1024的限制，线程不安全。 ## epoll 线程安全，知道哪个FD就绪，只有Linux支持。 相比于<code>select()</code>，<code>epoll()</code>不会无差别轮询，只处理接收到数据的socket，这样复杂度就降低为<span class="math inline">\(O(k)\)</span>。 ## Reference <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/32163005/answer/55772739">I/O多路复用是什么意思</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/10/18/%E9%AD%8F%E6%99%8B%E9%A3%8E%E5%BA%A6%E6%B5%85%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/18/%E9%AD%8F%E6%99%8B%E9%A3%8E%E5%BA%A6%E6%B5%85%E6%8E%A2/" class="post-title-link" itemprop="url">魏晋风度浅探</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-18 14:00:00" itemprop="dateCreated datePublished" datetime="2020-10-18T14:00:00+08:00">2020-10-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从小学作文开始，就喜欢写一些辞藻华丽的诗歌文章。 竹林七贤我当时只听说过山涛、阮籍和嵇康，引用之意是觉这几位遗世独立、傲然风骨，没有世俗羁绊，整日琴棋书画、饮酒作乐、不问世事，潇洒写意的生活，正是吾向往之。《广陵散》和《与山巨源绝交书》更是勾起了我对于嵇康无限的崇拜。 我极喜欢嵇康和纳兰性德，即使一些毫无关联的题目，也要用他们的事例强行去阐述论点。但由于只喜欢钻研近现代的战争史（可以原谅，男孩一般都喜欢枪支、火炮等近现代武器），一直对古代史不感兴趣，觉得几千年前的文化故事不过是落后、腐朽的代名词而已，所以其实对一些人物只是略知一二，最近花了些时间重新捋了一下魏晋那段历史，故分享于此。 ## 历史背景 我一直觉得想要真正了解一段文化、一个人物，就首先要了解他们所处的历史时代。 曹操在东汉末年的群雄逐鹿中“挟天子以令诸侯”，在三国末期势力最强。曹操去世后，其子曹丕于公元220年建立曹魏政权。公元265年，司马炎建立西晋，史称晋武帝。竹林七贤就是生活在这样一段历史时期： 山涛：205~283 阮籍：210~263 嵇康：224~263 刘伶：221~300 向秀：227~272 阮咸：不详 王戎：234~305 曹丕去世后，曹叡即位，公元239年隆冬时节，曹叡驾崩之际，将皇位传给仅仅8岁的曹芳，并将其同时托孤给司马懿和曹爽，于是在接下来漫长的几十年中，曹氏集团和司马氏集团开始了你死我活的政治斗争，史称“曹马之争”。 ## 竹林七贤 在那个极其黑暗动荡的乱世之中，文学和艺术却得到了出乎意料的大发展，人们对自由解放的追求达到了极致，鲁迅先生称之为魏晋风度。当时盛行清谈和隐逸，古人的心灵更加丰富和缠绵，规则的约束压抑了个性与自我，却在频频交流中迎来了文化的繁荣。不要用成王败寇的观点去评价历史人物，参差百态，实乃幸福本源。</p>
<p>而对魏晋风度影响最大的自然就是竹林七贤，虽然百年之后后人将其称之为七贤，但这个文人沙龙的规模其实大于7人，之所以定为七贤，据刘强老师的说法是为了攀附《论语》：</p>
<blockquote>
<p>贤者辟世，其次辟地，其次辟色，其次辟言。作者七人矣。</p>
</blockquote>
<p>另外，关于竹林七贤是否因为经常在竹林活动而得名也存疑。陈寅恪先生认为有可能是借佛经之中的“竹林精舍”的故事来表达出世的理想。据考证，他们的活动地点在都城洛阳以及山阳（今云台山）附近，后来当地可能为了借竹林七贤的名声促进旅游业的发展，所以人工栽种了一些竹林。</p>
<p>当时流行修身齐家治国平天下，但是这些才华横溢的文人开始却不愿做官，这是为什么呢？</p>
<p>“曹马之争”愈演愈烈，再加上这些名士的名气和影响力，他们被逼站队才能得以生存。那么问题来了，是站在司马家族一边，还是支持曹氏集团呢？曹爽此时被封为大将军，司马懿则是太尉，选择稍有不慎，很可能会被秋后算账。</p>
<p>作为老大哥，山涛最先受到“曹马之争”的冲击。</p>
<p>山涛早年丧父，出身庶族，隐居不仕，刘老师说可能是因为时机不成熟，2个政治集团的形势不明朗。山涛本人是有政治抱负的，但为了自保只能暂时推脱出仕邀请。</p>
<p>公元244年，他觉得形势明朗，自己的机会来了，终于在40岁时开始了官宦生涯，并且选择站到曹爽队伍里。</p>
<p>为了彻底击败曹氏集团，司马懿称病不朝，以退为进。极富政治头脑的山涛嗅出了不同的味道，突然醒悟，夜半弃官。</p>
<p>山涛弃官以后，司马懿在称病迷惑曹爽的同时，积累军事力量、联络曹魏老臣取得道义支持、散播舆论蛊惑人心，家族势力日渐强大。而就在此时，山涛结交了阮籍、嵇康等名士，整日醉饮玩乐。</p>
<p>公元249年，司马懿发动政变，一举粉碎了政敌曹爽集团，史称“高平陵之变”，以谋反罪处死了曹氏整个家族，数千人惨死，竹林七贤也受到了惊吓。接着为了缓解白色恐怖的气氛，司马家族开始招贤纳士、笼络人心，竹林七贤自然也在招贤之列：</p>
<p>山涛由于和司马氏的姻亲关系，第二次做官便凭借亲戚的身份主动投靠司马师，从此以后官运亨通，步入了仕途的快车道。</p>
<p>相比之下，在音乐、诗赋方面才华横溢的阮籍就显得异常凄惨。</p>
<p>阮籍的背景十分复杂，他的父亲阮瑀是建安七子之一，和曹魏关系密切；同时他又是司马氏的亲戚。 被招纳时，由于害怕司马懿的屠刀，于是阮籍答应为官，做了一个闲职。但他尸位素餐，整日划水摸鱼，几乎没有作为。并且他和司马氏倡导的封建礼教格格不入（司马氏当时号召“以孝治天下”，公元258年左右，阮籍丧母，他公然违背礼法，在葬礼期间喝酒吃肉），生活得极其痛苦但又不想过早结束生命，所以只能寄托于司马懿的死亡。</p>
<p>司马懿死后，其子司马师又把阮籍召去做官。司马昭上台后，为了拉拢阮籍，想要将阮籍的女儿嫁给司马昭的儿子司马炎，阮籍只能用烂醉如泥来应付。天天这样也不是办法，他就主动求官，调往外地，金蝉脱壳之计，但很不幸，十天后又被司马昭看穿并召回幕府。从此慎言慎行、明哲保身、郁郁寡欢。</p>
<p>嵇康死后，阮籍抑郁而终，晚年被迫为司马昭写了一篇歌功颂德的《劝进文》，成为了人生的污点。</p>
<p>向秀跟嵇康关系最好，嵇康的死给他带去了巨大的阴影，后来为了自保也踏上了仕途。</p>
<p>王戎后来做了大官，却变得非常吝啬，跟年轻时候判若两人，但是他依然很重情谊。 阮咸后来被山涛举荐，但没有被任用。</p>
<p>刘伶据说是7人里最丑的，但是他的精神自我十分强大，整日烂醉如泥，在酒中放飞自我，晚景凄凉。代表作《酒德颂》，刘强老师说他是真正的行为艺术家hh。 ## 嵇康 嵇康出身普通，自幼颠沛流离。和曹操同乡，其妻子是曹操的曾孙女长乐亭主，嵇康最后被司马昭所杀可能与这个因素也有关系。诗歌、文章、书法、乐理造诣很高，据传还是个大帅哥，史书记载：</p>
<blockquote>
<p>嵇康为人，肃肃如松下风，酒醉时倾倒，若玉山之将崩。</p>
</blockquote>
<p>他提出越名教任自然，反对礼教，追求自然和本我，厌恶政治斗争，据传嵇康在打铁时，司马氏的走狗钟会前来探访，所谓道不同不相与谋，故意把钟会晾在一边不说，走前还冷嘲热讽了一通。</p>
<p>当时司马师废掉了曹芳，引起淮南兵变，嵇康也想起兵响应，被山涛劝阻。</p>
<p>公元255年，司马师在平定叛乱时，由于得病死掉了。随后司马昭上台，希望招纳嵇康，嵇康借口避地河东。</p>
<p>嵇康以宽厚待人，虽然他的哥哥嵇喜还有几个朋友做了司马氏的官，但仍然没有影响他们的友谊。对待朋友友好，但是对待敌人却像严冬一样冷峻无情，也导致了后来悲剧的发生。</p>
<p>后来他又多次拒绝司马昭的邀请，但很不幸，嵇康最终还是卷进了政治斗争： 皇帝曹髦一直被司马昭操控，被迫封其为相国，眼看分分钟就要被取代的节奏。后来也由此诞生一个成语：司马昭之心——路人皆知。公元260年，曹髦很快就被司马昭干掉了，又找了一个傀儡。</p>
<p>公元261年，山涛升迁，找到嵇康希望他代替自己之前的官职。两人虽然“契若金兰”，但嵇康依然愤怒地写下《与山巨源绝交书》，极尽讽刺羞辱山涛，他觉得山涛拉拢他是为了缓解自己的尴尬，一起下水就不觉得那么罪过了。嵇康在书里自明心志：自己生性疏懒，阐述了自己做官的七不堪、二不可： 没法睡懒觉；喜欢休闲弹琴，出去玩不自由；需要正襟危坐；不喜欢写公务信；不喜欢吊丧；不喜欢和俗人共事；性情不耐烦，不喜欢做繁琐的事情。 菲薄古代的圣贤，被发现就挂了；性格刚烈、嫉恶如仇，沉不住气，不适合做官。</p>
<p>历史上关于两人是否真的绝交有争论：尤其是后来还发生了托孤事件。</p>
<p>屋漏偏逢连夜雨，接下来又发生了吕安事件，直接将嵇康送入了火坑之中：</p>
<p>吕巽是吕安的哥哥，对吕安的妻子有非分之想并且给他带了绿帽子，吕安告诉了嵇康，嵇康严词谴责了吕巽，但为了声誉，劝吕安隐忍不发，事情就这样被捂了下来。</p>
<p>吕巽和钟会关系很好，为了报复吕安，他向钟会进献谗言，钟会很可能为了牵出嵇康，以报一箭之仇，不久后就抓了吕安。嵇康听到消息后十分愤怒，写了一封《与吕长悌绝交书》，之后只身前往洛阳，去为吕安辩护。</p>
<p>吕安在流放途中，给嵇康写了一封言辞激烈的信。大意是说天下大乱，自己承受冤屈，他要改天换地。这封信很快落到了钟会手上，钟会终于等到了机会。</p>
<p>吕安事件由此升级为谋反罪，嵇康被当作同犯抓了。司马昭本来就忌惮嵇康，对他的不合作态度怀恨在心，但对于是否要杀嵇康也犹豫不决，此时钟会又站了出来上纲上线，说嵇康上不臣天子，下不事王侯，私下又罗织了几个理由：他说嵇康是人中龙凤，并且当年有起兵谋反之意。</p>
<p>欲加之罪，何患无辞？于是吕安和嵇康被关入死囚牢房，等待秋后问斩。</p>
<p>命犯小人，嵇康入狱后，有几千太学生为他抱打不平。他也在狱中反思自己，写下了《幽愤诗》，觉得自己虽然心地善良，但却没有识别坏人的能力。</p>
<p>临死前将其儿子嵇绍托付给山涛，有人说这是为了缓解山涛的愧疚之意，山涛接受了嵇康的托孤，把嵇绍培养的很好：</p>
<blockquote>
<p>巨源在，汝不孤矣！</p>
</blockquote>
<p>就在行刑前，太学生又请愿释放嵇康当太学老师。司马昭看到嵇康如此的影响力，杀心更重： 公元263年，嵇康与吕安一起在都城洛阳被处死。</p>
<p>据记载，行刑那天人山人海，嵇康顾看日影、神色坦然。</p>
<p>嵇康找哥哥嵇喜要了一把琴，嵇喜果然随身携带，而且嵇康的弹奏要求竟然被同意： 在刑场上，他平静呼吸，调整琴弦，弹完了最后的哀歌《广陵散》后说到：当年有一个朋友袁孝尼求学此散，自己由于吝惜，没有教给他：</p>
<blockquote>
<p>广陵散于今绝矣！ ## Reference 同济大学的刘强老师是魏晋史的专家，百家讲坛和上海图书馆系列讲座中都收录了他的精彩分享： <a target="_blank" rel="noopener" href="http://tv.cctv.com/lm/bjjt/index.shtml#&amp;Type=0&amp;Y=2010&amp;M=10">百家讲坛之竹林七贤</a> <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Zt411d7Fr">竹林七贤与魏晋风度</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/10/04/Bomb%20Lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/04/Bomb%20Lab/" class="post-title-link" itemprop="url">Bomb Lab</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-04 09:09:00" itemprop="dateCreated datePublished" datetime="2020-10-04T09:09:00+08:00">2020-10-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>给了<code>bomb.c</code>和<code>bomb</code>二进制可执行目标程序，<code>bomb.c</code>不能直接编译和运行，只是有一些提示，但是程序大致结构是：有6个关卡，每个都需要输入（stdin/文件）一个字符串，运行后判断是否输入了正确的字符串。我们需要反汇编<code>bomb</code>，找到这6个正确的字符串。 我是在Amazon的云服务器上完成的，64位Red Hat。</p>
<p>第一步把汇编代码扔到一个文件中，方便调试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.asm</span><br></pre></td></tr></table></figure>
<h2 id="phase-1">phase 1</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 我们的input作为第一个参数存入rdi，第二个参数0x402400存入rsi，传入函数处理， 调用了<code>401338</code>处的函数<code>strings_not_equal</code>：</p>
<p>在400ee4设个断点，看看402400里是啥：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb</span><br><span class="line">file bomb</span><br><span class="line">b *0x400ee4</span><br><span class="line">run</span><br><span class="line">x/s Addr// 显示内存值为字符串</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200703101513705.png" alt="在这里插入图片描述" /> 为了确认这就是我们要的答案，再去看看调用的函数： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0000000000401338 &lt;strings_not_equal&gt;:</span><br><span class="line">  401338:	41 54                	push   %r12</span><br><span class="line">  40133a:	55                   	push   %rbp</span><br><span class="line">  40133b:	53                   	push   %rbx</span><br><span class="line">  40133c:	48 89 fb             	mov    %rdi,%rbx # 第一个参数(地址)存入rbx</span><br><span class="line">  40133f:	48 89 f5             	mov    %rsi,%rbp # 第二个参数(地址)存入rbp</span><br><span class="line">  401342:	e8 d4 ff ff ff       	callq  40131b &lt;string_length&gt; # 用rdi的值调用string_length</span><br><span class="line">  401347:	41 89 c4             	mov    %eax,%r12d # 返回值存入r12d</span><br><span class="line">  40134a:	48 89 ef             	mov    %rbp,%rdi # 第二个参数作为入参调用string_length</span><br><span class="line">  40134d:	e8 c9 ff ff ff       	callq  40131b &lt;string_length&gt;</span><br><span class="line">  401352:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  401357:	41 39 c4             	cmp    %eax,%r12d # 比较两个字符串的长度</span><br><span class="line">  40135a:	75 3f                	jne    40139b &lt;strings_not_equal+0x63&gt; # 不相等跳转</span><br><span class="line">  40135c:	0f b6 03             	movzbl (%rbx),%eax # 将rbx地址中的值(input的第一个字母)存入eax</span><br><span class="line">  40135f:	84 c0                	test   %al,%al</span><br><span class="line">  401361:	74 25                	je     401388 &lt;strings_not_equal+0x50&gt;</span><br><span class="line">  401363:	3a 45 00             	cmp    0x0(%rbp),%al # 比较rbp地址中的值(待比较的第一个字母)</span><br><span class="line">  401366:	74 0a                	je     401372 &lt;strings_not_equal+0x3a&gt; # 相等跳转</span><br><span class="line">  401368:	eb 25                	jmp    40138f &lt;strings_not_equal+0x57&gt; # 不相等跳转</span><br><span class="line">  40136a:	3a 45 00             	cmp    0x0(%rbp),%al</span><br><span class="line">  40136d:	0f 1f 00             	nopl   (%rax)</span><br><span class="line">  401370:	75 24                	jne    401396 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line">  401372:	48 83 c3 01          	add    $0x1,%rbx # 指针+1</span><br><span class="line">  401376:	48 83 c5 01          	add    $0x1,%rbp # 指针+1</span><br><span class="line">  40137a:	0f b6 03             	movzbl (%rbx),%eax</span><br><span class="line">  40137d:	84 c0                	test   %al,%al</span><br><span class="line">  40137f:	75 e9                	jne    40136a &lt;strings_not_equal+0x32&gt; # 跳回循环</span><br><span class="line">  401381:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  401386:	eb 13                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401388:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  40138d:	eb 0c                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40138f:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  401394:	eb 05                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401396:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  40139b:	89 d0                	mov    %edx,%eax</span><br><span class="line">  40139d:	5b                   	pop    %rbx</span><br><span class="line">  40139e:	5d                   	pop    %rbp</span><br><span class="line">  40139f:	41 5c                	pop    %r12</span><br><span class="line">  4013a1:	c3                   	retq</span><br></pre></td></tr></table></figure> 所以这个函数就是比较两个字符串是否相同，先比较长度，再比较每个字符。故我们的第一个key就是Border relations with Canada have never been better. ## phase 2 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp # 栈指针-40</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi # 栈指针作为第二个参数</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp) # 检查是否相等</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt; # 相等跳转</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax # (rbx-4)赋给eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx) # 比较当前数与下一个数</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt; # 相等跳转</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx # 是否比完了6个数</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx # 栈指针+4赋给rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp # 栈指针+24赋给rbp</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq</span><br></pre></td></tr></table></figure> 第一次是1，第二次是2，4，8，16，32 ## phase 3 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp # 栈指针-24</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx # 栈指针+12赋给rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx # 栈指针+8赋给rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; # 返回值存入eax</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt; # 大于跳转</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt; # 否则爆炸</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp) #(rsp+8)即输入的第一个整数与7比较</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt; # 大于爆炸</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax # 输入的第一个整数赋给eax</span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8) # 跳转8*rax+0x402470</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	retq</span><br></pre></td></tr></table></figure> 400f51将地址0x4025cf赋给esi，作为第二个参数，看下这个地址有啥：为了方便，我们把前面问题的答案仍在一个文件ans.txt中， <img src="https://img-blog.csdnimg.cn/20200703164446264.png" alt="在这里插入图片描述" /> 输入是2个整数，第一个不能大于7，基于第一个整数（0-7）跳转...... </explode_bomb>&lt;/phase_3+0x86&gt;&lt;/phase_3+0x7b&gt;</explode_bomb>&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x7b&gt;&lt;/phase_3+0x6a&gt;</explode_bomb>&lt;/phase_3+0x27&gt;</phase_3>&lt;/phase_2+0x1b&gt;&lt;/phase_2+0x40&gt;&lt;/phase_2+0x1b&gt;</explode_bomb>&lt;/phase_2+0x29&gt;&lt;/phase_2+0x34&gt;</explode_bomb>&lt;/phase_2+0x34&gt;</read_six_numbers></phase_2>&lt;/strings_not_equal+0x63&gt;&lt;/strings_not_equal+0x63&gt;&lt;/strings_not_equal+0x63&gt;&lt;/strings_not_equal+0x32&gt;&lt;/strings_not_equal+0x5e&gt;&lt;/strings_not_equal+0x57&gt;&lt;/strings_not_equal+0x3a&gt;&lt;/strings_not_equal+0x50&gt;&lt;/strings_not_equal+0x63&gt;</string_length></string_length></strings_not_equal></explode_bomb>&lt;/phase_1+0x17&gt;</strings_not_equal></phase_1></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/09/26/%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%90%86%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/26/%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%90%86%E6%83%B3/" class="post-title-link" itemprop="url">谈谈我的理想</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-26 16:03:00" itemprop="dateCreated datePublished" datetime="2020-09-26T16:03:00+08:00">2020-09-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Life/" itemprop="url" rel="index"><span itemprop="name">Life</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Say Goodbye~</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/26/%E8%B0%88%E8%B0%88%E6%88%91%E7%9A%84%E7%90%86%E6%83%B3/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://eimadrigal.github.io/2020/09/16/MIT%20Operating%20System%20Engineering#0%20Booting%20a%20PC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="EIMadrigal">
      <meta itemprop="description" content="Hello World">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EI Madrigal's Space">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/MIT%20Operating%20System%20Engineering#0%20Booting%20a%20PC/" class="post-title-link" itemprop="url">MIT Operating System Engineering#0 Booting a PC</a>
        </h2>

        <div class="post-meta">

		  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-16 01:25:00" itemprop="dateCreated datePublished" datetime="2020-09-16T01:25:00+08:00">2020-09-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><em>最近在学MIT的OS课程，lab绝对业界良心。 XJTU的操作系统课就是写一个系统调用，改下进程软中断通信的代码，代码量不足500。。。 MIT上课用xv6来教学，lab是做一个完整的小型操作系统JOS。</em></p>
<hr />
<h2 id="配置环境">配置环境</h2>
<p>虽然没什么技术含量，但是这真的是令人头疼的事。附：<a target="_blank" rel="noopener" href="https://blog.csdn.net/eye_water/article/details/80638463">图文教程</a> 需要一台x86机器，一般的Linux发行版应该都可以，可以使用<code>unabenlme -a</code>查看，如果显示<code>xxx GNU/Linux</code>就行，MIT的学生可以使用配置好的远程Server。 本来打算白嫖下Harvard的服务器，但是没有<code>root</code>权限，只能可怜巴巴地在Win环境用虚拟机。 平台：Vmware Player15，<a target="_blank" rel="noopener" href="http://old-releases.ubuntu.com/releases/14.04.5/">Ubuntu-14.04.5-desktop-i386.iso</a></p>
<ul>
<li>检验编译链 <code>objdump -i</code>：第二行显示elf32-i386； <code>gcc -m32 -print-libgcc-file-name</code>：打印出/usr/lib/gcc/i686-linux-gnu/4.8/libgcc.a</li>
<li>安装git：<code>sudo apt-get install git</code></li>
<li>下载qemu 建议不要作死，安装MIT Patch过的版本：<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code></li>
<li>安装依赖库 官方说要装5个库，但其实libtool-bin好像找不到，不过不影响后续： <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt<span class="literal">-get</span> install libsdl1.<span class="number">2</span><span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libglib2.<span class="number">0</span><span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libz<span class="literal">-dev</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install libpixman<span class="literal">-1</span><span class="literal">-dev</span></span><br></pre></td></tr></table></figure></li>
<li>配置qemu 切到qemu目录，<code>./configure --disable-kvm --disable-werror --target-list="i386-softmmu x86_64-softmmu"</code> <code>[--prefix=PFX]</code>可选参数是选择安装路径，这里就默认在<code>/usr/local</code></li>
<li>安装qemu：<code>sudo make &amp;&amp; sudo make install</code></li>
<li>下载实验代码 根目录下新建6.828目录，切到该目录，<code>git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</code>，切到<code>lab</code>目录，<code>make</code>就可以了。 ## PC Bootstrap 物理地址空间： <img src="https://img-blog.csdnimg.cn/20200523082913317.png" alt="在这里插入图片描述" /> 以前的PC内存只有1MB，Low Memory是PC唯一能用的RAM。VGA Display是VGA缓冲区和固件，BIOS以前都在ROM中，不过现今都在闪存中，做完系统初始化（PCI总线等重要设备），寻找bootable设备(硬盘)，读取boot loader加载OS，将控制权转OS。后来内存远远超过1MB，可用的也就有Extended Memory，不过为了后向兼容，还是保留了Low Memory，这样可用的RAM就被分为了两部分。如果64位系统，那么内存更大，这样为了兼容，32-bit memory mapped devices还是要保留，就又被割裂了。 ## The Boot Loader 硬盘的第一个分区存放启动程序，包括一个汇编文件<code>boot/boot.S</code>和一个C文件<code>boot/main.c</code>，启动程序将CPU从实模式转为32位保护模式，通过特殊的I/O指令读取内核。 ## The Kernel</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="EIMadrigal"
      src="/images/favicon.png">
  <p class="site-author-name" itemprop="name">EIMadrigal</p>
  <div class="site-description" itemprop="description">Hello World</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">171</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/EIMadrigal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:andrew.renj@gmail.com" title="E-Mail → mailto:andrew.renj@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/EIMadrigal" title="cnblogs → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-codiepie fa-fw"></i>cnblogs</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/EIMadrigal" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;EIMadrigal" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EIMadrigal</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">Total views: <span id="busuanzi_value_site_pv"></span></span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">Total visitors: <span id="busuanzi_value_site_uv"></span></span>
    <span class="post-meta-divider">|</span>

<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);
    var countOffset = 20000;

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset);
            clearInterval(int);
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


</body>
</html>
